[
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/ITabStatesListener.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/ITabStatesListener.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/ITabStatesListener.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/ITabStatesListener.java\n@@ -63,4 +63,6 @@ default void onTabsReorder(List<TabBlueprint> blueprints) {\n \tdefault void onTabSave(TabBlueprint blueprint, EditorViewState viewState) {\n \t}\n \n+\tdefault void onTabPreviewChange(TabBlueprint blueprint) {\n+\t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/LogTabStates.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/LogTabStates.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/LogTabStates.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/LogTabStates.java\n@@ -79,4 +79,9 @@ public void onTabsRestoreDone() {\n \tpublic void onTabVisibilityChange(TabBlueprint blueprint) {\n \t\tLOG.debug(\"onTabVisibilityChange: blueprint={}\", blueprint);\n \t}\n+\n+\t@Override\n+\tpublic void onTabPreviewChange(TabBlueprint blueprint) {\n+\t\tLOG.debug(\"onTabPreviewChange: blueprint={}\", blueprint);\n+\t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java\n@@ -64,7 +64,13 @@ public void loadSettings() {\n \t}\n \n \tprivate Font getLabelFont() {\n-\t\treturn tabsController.getMainWindow().getSettings().getFont().deriveFont(Font.BOLD);\n+\t\tFont font = tabsController.getMainWindow().getSettings().getFont();\n+\t\tint style = font.getStyle();\n+\t\tstyle |= Font.BOLD;\n+\t\tif (getBlueprint().isPreviewTab()) {\n+\t\t\tstyle ^= Font.ITALIC; // flip italic bit to distinguish preview\n+\t\t}\n+\t\treturn font.deriveFont(style);\n \t}\n \n \tprivate void init() {\n@@ -75,14 +81,12 @@ private void init() {\n \t\ticon = new OverlayIcon(node.getIcon());\n \n \t\tlabel = new NodeLabel(buildTabTitle(node), node.disableHtml());\n-\t\tmakeLabelFont();\n \t\tString toolTip = contentPanel.getTabTooltip();\n \t\tif (toolTip != null) {\n \t\t\tsetToolTipText(toolTip);\n \t\t}\n \t\tlabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 10));\n \t\tlabel.setIcon(icon);\n-\t\tupdateBookmarkIcon();\n \t\tif (node instanceof JEditableNode) {\n \t\t\t((JEditableNode) node).addChangeListener(c -> label.setText(buildTabTitle(node)));\n \t\t}\n@@ -122,18 +126,28 @@ public void mousePressed(MouseEvent e) {\n \t\t\t\t\tmenu.show(e.getComponent(), e.getX(), e.getY());\n \t\t\t\t} else if (SwingUtilities.isLeftMouseButton(e)) {\n \t\t\t\t\ttabsController.selectTab(node);\n+\t\t\t\t\tif (e.getClickCount() == 2) {\n+\t\t\t\t\t\ttabsController.setTabPreview(node, false);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t};\n \t\taddMouseListener(clickAdapter);\n \t\taddListenerForDnd();\n \n \t\tadd(label);\n-\t\tupdateCloseOrPinButton();\n \t\tsetBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));\n+\n+\t\tupdate();\n+\t}\n+\n+\tpublic void update() {\n+\t\tupdateCloseOrPinButton();\n+\t\tupdateBookmarkIcon();\n+\t\tupdateFont();\n \t}\n \n-\tpublic void updateCloseOrPinButton() {\n+\tprivate void updateCloseOrPinButton() {\n \t\tif (getBlueprint().isPinned()) {\n \t\t\tif (closeBtn.isShowing()) {\n \t\t\t\tremove(closeBtn);\n@@ -151,7 +165,7 @@ public void updateCloseOrPinButton() {\n \t\t}\n \t}\n \n-\tpublic void updateBookmarkIcon() {\n+\tprivate void updateBookmarkIcon() {\n \t\ticon.clear();\n \n \t\tif (getBlueprint().isBookmarked()) {\n@@ -174,14 +188,8 @@ private void toggleBookmark() {\n \t\ttabsController.setTabBookmarked(getNode(), bookmarked);\n \t}\n \n-\tprivate void makeLabelFont() {\n-\t\tboolean previewTab = getBlueprint().isPreviewTab();\n-\t\tif (previewTab) {\n-\t\t\tFont newLabelFont = new Font(label.getFont().getName(), Font.ITALIC, label.getFont().getSize());\n-\t\t\tlabel.setFont(newLabelFont);\n-\t\t} else {\n-\t\t\tlabel.setFont(getLabelFont());\n-\t\t}\n+\tprivate void updateFont() {\n+\t\tlabel.setFont(getLabelFont());\n \t}\n \n \tprivate void addListenerForDnd() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabbedPane.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabbedPane.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabbedPane.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabbedPane.java\n@@ -442,13 +442,28 @@ public void onTabSmaliJump(TabBlueprint blueprint, int pos, boolean debugMode) {\n \n \t@Override\n \tpublic void onTabClose(TabBlueprint blueprint) {\n-\t\tContentPanel contentPanel = getTabByNode(blueprint.getNode());\n-\t\tif (contentPanel == null) {\n+\t\tContentPanel contentPanelToClose = getTabByNode(blueprint.getNode());\n+\t\tif (contentPanelToClose == null) {\n \t\t\treturn;\n \t\t}\n-\t\ttabsMap.remove(contentPanel.getNode());\n-\t\tremove(contentPanel);\n-\t\tcontentPanel.dispose();\n+\n+\t\tContentPanel currentContentPanel = getSelectedContentPanel();\n+\t\tif (currentContentPanel == contentPanelToClose) {\n+\t\t\tif (lastTab != null && lastTab.getNode() != null) {\n+\t\t\t\tselectTab(lastTab);\n+\t\t\t} else if (getTabCount() > 1) {\n+\t\t\t\tint removalIdx = indexOfComponent(contentPanelToClose);\n+\t\t\t\tif (removalIdx > 0) { // select left tab\n+\t\t\t\t\tsetSelectedIndex(removalIdx - 1);\n+\t\t\t\t} else if (removalIdx == 0) { // select right tab\n+\t\t\t\t\tsetSelectedIndex(removalIdx + 1);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\ttabsMap.remove(contentPanelToClose.getNode());\n+\t\tremove(contentPanelToClose);\n+\t\tcontentPanelToClose.dispose();\n \t}\n \n \t@Override\n@@ -465,9 +480,13 @@ private void setTabPosition(ContentPanel contentPanel, int position) {\n \t\tif (tabComponent == null) {\n \t\t\treturn;\n \t\t}\n+\t\tboolean restoreSelection = contentPanel == getSelectedContentPanel();\n \t\tremove(contentPanel);\n \t\tadd(contentPanel, position);\n \t\tsetTabComponentAt(position, tabComponent);\n+\t\tif (restoreSelection) {\n+\t\t\tsetSelectedIndex(position);\n+\t\t}\n \t}\n \n \t@Override\n@@ -476,7 +495,7 @@ public void onTabPinChange(TabBlueprint blueprint) {\n \t\tif (tabComponent == null) {\n \t\t\treturn;\n \t\t}\n-\t\ttabComponent.updateCloseOrPinButton();\n+\t\ttabComponent.update();\n \t}\n \n \t@Override\n@@ -485,7 +504,7 @@ public void onTabBookmarkChange(TabBlueprint blueprint) {\n \t\tif (tabComponent == null) {\n \t\t\treturn;\n \t\t}\n-\t\ttabComponent.updateBookmarkIcon();\n+\t\ttabComponent.update();\n \t}\n \n \t@Override\n@@ -498,6 +517,15 @@ public void onTabVisibilityChange(TabBlueprint blueprint) {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void onTabPreviewChange(TabBlueprint blueprint) {\n+\t\tTabComponent tabComponent = getTabComponentByNode(blueprint.getNode());\n+\t\tif (tabComponent == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\ttabComponent.update();\n+\t}\n+\n \t@Override\n \tpublic void onTabRestore(TabBlueprint blueprint, EditorViewState viewState) {\n \t\tContentPanel contentPanel = getTabByNode(blueprint.getNode());\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n@@ -281,6 +281,18 @@ private void setTabHiddenInternal(TabBlueprint blueprint, boolean hidden) {\n \t\t}\n \t}\n \n+\tpublic void setTabPreview(JNode node, boolean isPreview) {\n+\t\tTabBlueprint blueprint = getTabByNode(node);\n+\t\tsetTabPreviewInternal(blueprint, isPreview);\n+\t}\n+\n+\tprivate void setTabPreviewInternal(TabBlueprint blueprint, boolean isPreview) {\n+\t\tif (blueprint != null && blueprint.isPreviewTab() != isPreview) {\n+\t\t\tblueprint.setPreviewTab(isPreview);\n+\t\t\tlisteners.forEach(l -> l.onTabPreviewChange(blueprint));\n+\t\t}\n+\t}\n+\n \tprivate void removeTabIfNotReferenced(TabBlueprint blueprint) {\n \t\tif (blueprint.isHidden() && !blueprint.isReferenced()) {\n \t\t\ttabsMap.remove(blueprint.getNode());",
    "output": "Fix various tabs related fixes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java\n@@ -5,6 +5,7 @@\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.regex.Matcher;\n \n import jadx.api.ICodeWriter;\n import jadx.api.impl.SimpleCodeWriter;\n@@ -30,6 +31,7 @@\n public class DotGraphVisitor extends AbstractVisitor {\n \n \tprivate static final String NL = \"\\\\l\";\n+\tprivate static final String NLQR = Matcher.quoteReplacement(NL);\n \tprivate static final boolean PRINT_DOMINATORS = false;\n \tprivate static final boolean PRINT_DOMINATORS_INFO = false;\n \n@@ -324,7 +326,7 @@ private String escape(String string) {\n \t\t\t\t\t.replace(\"\\\"\", \"\\\\\\\"\")\n \t\t\t\t\t.replace(\"-\", \"\\\\-\")\n \t\t\t\t\t.replace(\"|\", \"\\\\|\")\n-\t\t\t\t\t.replaceAll(\"\\\\R\", NL);\n+\t\t\t\t\t.replaceAll(\"\\\\R\", NLQR);\n \t\t}\n \t}\n }",
    "output": "Use proper newlines when generating CFG"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n@@ -49,6 +49,7 @@\n \n import ch.qos.logback.classic.Level;\n \n+import jadx.api.JavaNode;\n import jadx.gui.logs.LogOptions;\n import jadx.gui.treemodel.JNode;\n import jadx.gui.treemodel.JResSearchNode;\n@@ -185,9 +186,12 @@ protected void copyAllSearchResults() {\n \t\tStringBuilder sb = new StringBuilder();\n \t\tSet<String> uniqueRefs = new HashSet<>();\n \t\tfor (JNode node : resultsModel.rows) {\n-\t\t\tString codeNodeRef = node.getJavaNode().getCodeNodeRef().toString();\n-\t\t\tif (uniqueRefs.add(codeNodeRef)) {\n-\t\t\t\tsb.append(codeNodeRef).append(\"\\n\");\n+\t\t\tJavaNode javaNode = node.getJavaNode();\n+\t\t\tif (javaNode != null) {\n+\t\t\t\tString codeNodeRef = javaNode.getCodeNodeRef().toString();\n+\t\t\t\tif (uniqueRefs.add(codeNodeRef)) {\n+\t\t\t\t\tsb.append(codeNodeRef).append(\"\\n\");\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tUiUtils.copyToClipboard(sb.toString());",
    "output": "Fix NullPointerException in copyAllSearchResults"
  },
  {
    "input": "diff --git a/jadx-commons/jadx-app-commons/src/main/java/jadx/commons/app/JadxCommonFiles.java b/jadx-commons/jadx-app-commons/src/main/java/jadx/commons/app/JadxCommonFiles.java\n--- a/jadx-commons/jadx-app-commons/src/main/java/jadx/commons/app/JadxCommonFiles.java\n+++ b/jadx-commons/jadx-app-commons/src/main/java/jadx/commons/app/JadxCommonFiles.java\n@@ -81,12 +81,15 @@ private synchronized ProjectDirectories loadDirs() {\n \t\t}\n \n \t\t/**\n-\t\t * Return JNI or Foreign implementation\n+\t\t * Return JNI, Foreign or PowerShell implementation\n \t\t */\n \t\tprivate static Windows getWinDirs() {\n \t\t\tWindows defSup = Windows.getDefaultSupplier().get();\n \t\t\tif (defSup instanceof WindowsPowerShell) {\n-\t\t\t\treturn new WindowsJni();\n+\t\t\t\tif (JadxSystemInfo.IS_AMD64) {\n+\t\t\t\t\t// JNI library compiled for x86-64\n+\t\t\t\t\treturn new WindowsJni();\n+\t\t\t\t}\n \t\t\t}\n \t\t\treturn defSup;\n \t\t}",
    "output": "Use 'dev.dirs' JNI implementation only on x86-64"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n@@ -479,12 +479,7 @@ public boolean isDisposed() {\n \t}\n \n \tpublic void dispose() {\n-\t\t// code area reference can still be used somewhere in UI objects,\n-\t\t// reset node reference to allow to GC jadx objects tree\n-\t\tnode = null;\n-\t\tcontentPanel = null;\n-\n-\t\t// also clear internals\n+\t\t// clear internals\n \t\ttry {\n \t\t\tsetIgnoreRepaint(true);\n \t\t\tsetText(\"\");\n@@ -513,6 +508,10 @@ public void dispose() {\n \t\t} catch (Throwable e) {\n \t\t\tLOG.debug(\"Error on code area dispose\", e);\n \t\t}\n+\t\t// code area reference can still be used somewhere in UI objects,\n+\t\t// reset node reference to allow to GC jadx objects tree\n+\t\tnode = null;\n+\t\tcontentPanel = null;\n \t}\n \n \t@Override",
    "output": "Fix resolve NPE on code area close"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -2,6 +2,7 @@\n \n import java.awt.BorderLayout;\n import java.awt.Component;\n+import java.awt.Desktop;\n import java.awt.Dimension;\n import java.awt.DisplayMode;\n import java.awt.Font;\n@@ -1297,7 +1298,13 @@ public void actionPerformed(ActionEvent e) {\n \t\t\tuiWatchDog.setState(UIWatchDog.onStart());\n \t\t\thelp.add(uiWatchDog);\n \t\t}\n-\t\thelp.add(aboutAction);\n+\n+\t\tif (SystemInfo.IS_MAC) {\n+\t\t\tSystem.setProperty(\"apple.laf.useScreenMenuBar\", \"true\");\n+\t\t\tDesktop.getDesktop().setAboutHandler(e -> aboutAction.actionPerformed(null));\n+\t\t} else {\n+\t\t\thelp.add(aboutAction);\n+\t\t}\n \n \t\tmenuBar = new JadxMenuBar();\n \t\tmenuBar.add(file);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/AboutDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/AboutDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/AboutDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/AboutDialog.java\n@@ -3,7 +3,6 @@\n import java.awt.BorderLayout;\n import java.awt.Container;\n import java.awt.Dimension;\n-import java.awt.Font;\n import java.net.URL;\n \n import javax.swing.BorderFactory;\n@@ -29,21 +28,16 @@ public AboutDialog() {\n \t}\n \n \tpublic final void initUI() {\n-\t\tFont font = new Font(\"Serif\", Font.BOLD, 13);\n-\n \t\tURL logoURL = getClass().getResource(\"/logos/jadx-logo-48px.png\");\n-\t\tIcon logo = new ImageIcon(logoURL, \"jadx logo\");\n+\t\tIcon logo = new ImageIcon(logoURL, \"JADX logo\");\n \n-\t\tJLabel name = new JLabel(\"jadx\", logo, SwingConstants.CENTER);\n-\t\tname.setFont(font);\n+\t\tJLabel name = new JLabel(\"JADX\", logo, SwingConstants.CENTER);\n \t\tname.setAlignmentX(0.5f);\n \n \t\tJLabel desc = new JLabel(\"Dex to Java decompiler\");\n-\t\tdesc.setFont(font);\n \t\tdesc.setAlignmentX(0.5f);\n \n-\t\tJLabel version = new JLabel(\"jadx version: \" + JadxDecompiler.getVersion());\n-\t\tversion.setFont(font);\n+\t\tJLabel version = new JLabel(\"JADX version: \" + JadxDecompiler.getVersion());\n \t\tversion.setAlignmentX(0.5f);\n \n \t\tString javaVm = System.getProperty(\"java.vm.name\");\n@@ -52,12 +46,10 @@ public final void initUI() {\n \t\tjavaVm = javaVm == null ? \"\" : javaVm;\n \n \t\tJLabel javaVmLabel = new JLabel(\"Java VM: \" + javaVm);\n-\t\tjavaVmLabel.setFont(font);\n \t\tjavaVmLabel.setAlignmentX(0.5f);\n \n \t\tjavaVer = javaVer == null ? \"\" : javaVer;\n \t\tJLabel javaVerLabel = new JLabel(\"Java version: \" + javaVer);\n-\t\tjavaVerLabel.setFont(font);\n \t\tjavaVerLabel.setAlignmentX(0.5f);\n \n \t\tJPanel textPane = new JPanel();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n@@ -5,6 +5,7 @@\n import java.awt.Component;\n import java.awt.Dimension;\n import java.awt.Font;\n+import java.awt.Rectangle;\n import java.awt.event.ActionEvent;\n import java.awt.event.KeyAdapter;\n import java.awt.event.KeyEvent;\n@@ -381,6 +382,15 @@ public void updateTable() {\n \t\tpublic Object getValueAt(int row, int column) {\n \t\t\treturn model.getValueAt(row, column);\n \t\t}\n+\n+\t\t@Override\n+\t\tpublic int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) {\n+\t\t\t// ResultsTable only has two wide columns, the default increment is way too fast\n+\t\t\tif (orientation == SwingConstants.HORIZONTAL) {\n+\t\t\t\treturn 30;\n+\t\t\t}\n+\t\t\treturn super.getScrollableUnitIncrement(visibleRect, orientation, direction);\n+\t\t}\n \t}\n \n \tprotected static final class ResultsModel extends AbstractTableModel {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n@@ -556,7 +556,7 @@ private void initSearchEvents() {\n \t\t\t\t\tsearchEmitter.getFlowable()));\n \t\t}\n \t\tsearchDisposable = searchEvents\n-\t\t\t\t.debounce(50, TimeUnit.MILLISECONDS)\n+\t\t\t\t.debounce(100, TimeUnit.MILLISECONDS)\n \t\t\t\t.observeOn(Schedulers.from(searchBackgroundExecutor))\n \t\t\t\t.subscribe(t -> this.search(searchField.getText()));\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabbedPane.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabbedPane.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabbedPane.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabbedPane.java\n@@ -86,12 +86,7 @@ public void mousePressed(MouseEvent e) {\n \t\t\tint index = getSelectedIndex();\n \t\t\tint maxIndex = getTabCount() - 1;\n \t\t\tindex += direction;\n-\t\t\t// switch between first tab <-> last tab\n-\t\t\tif (index < 0) {\n-\t\t\t\tindex = maxIndex;\n-\t\t\t} else if (index > maxIndex) {\n-\t\t\t\tindex = 0;\n-\t\t\t}\n+\t\t\tindex = Math.max(0, Math.min(maxIndex, index));\n \t\t\ttry {\n \t\t\t\tsetSelectedIndex(index);\n \t\t\t} catch (IndexOutOfBoundsException e) {",
    "output": "Fix minor UI fixes"
  },
  {
    "input": "diff --git a/jadx-commons/jadx-zip/src/main/java/jadx/zip/ZipContent.java b/jadx-commons/jadx-zip/src/main/java/jadx/zip/ZipContent.java\n--- a/jadx-commons/jadx-zip/src/main/java/jadx/zip/ZipContent.java\n+++ b/jadx-commons/jadx-zip/src/main/java/jadx/zip/ZipContent.java\n@@ -2,22 +2,37 @@\n \n import java.io.Closeable;\n import java.io.IOException;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n \n import org.jetbrains.annotations.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n public class ZipContent implements Closeable {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(ZipContent.class);\n+\n \tprivate final IZipParser zipParser;\n \tprivate final List<IZipEntry> entries;\n \tprivate final Map<String, IZipEntry> entriesMap;\n \n \tpublic ZipContent(IZipParser zipParser, List<IZipEntry> entries) {\n \t\tthis.zipParser = zipParser;\n \t\tthis.entries = entries;\n-\t\tthis.entriesMap = entries.stream().collect(Collectors.toMap(IZipEntry::getName, Function.identity()));\n+\t\tthis.entriesMap = buildNameMap(zipParser, entries);\n+\t}\n+\n+\tprivate static Map<String, IZipEntry> buildNameMap(IZipParser zipParser, List<IZipEntry> entries) {\n+\t\tMap<String, IZipEntry> map = new HashMap<>(entries.size());\n+\t\tfor (IZipEntry entry : entries) {\n+\t\t\tString name = entry.getName();\n+\t\t\tIZipEntry prevEntry = map.put(name, entry);\n+\t\t\tif (prevEntry != null) {\n+\t\t\t\tLOG.warn(\"Found duplicate entry: {} in {}\", name, zipParser);\n+\t\t\t}\n+\t\t}\n+\t\treturn map;\n \t}\n \n \tpublic List<IZipEntry> getEntries() {",
    "output": "Fix allow to load zip with duplicate names in entries"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -1216,7 +1216,7 @@ private void initMenuAndToolbar() {\n \t\tJadxGuiAction forwardVariantAction = new JadxGuiAction(ActionModel.FORWARD_V, navController::navForward);\n \t\tJadxGuiAction quarkAction = new JadxGuiAction(ActionModel.QUARK,\n \t\t\t\t() -> new QuarkDialog(MainWindow.this).setVisible(true));\n-\t\tJadxGuiAction openDeviceAction = new JadxGuiAction(ActionModel.OPEN_DEVICE,\n+\t\tJadxGuiAction debuggerAction = new JadxGuiAction(ActionModel.OPEN_DEVICE,\n \t\t\t\t() -> new ADBDialog(MainWindow.this).setVisible(true));\n \n \t\tJMenu file = new JadxMenu(NLS.str(\"menu.file\"), shortcutsController);\n@@ -1276,7 +1276,7 @@ private void initMenuAndToolbar() {\n \t\ttools.add(resetCacheAction);\n \t\ttools.add(deobfMenuItem);\n \t\ttools.add(quarkAction);\n-\t\ttools.add(openDeviceAction);\n+\t\ttools.add(debuggerAction);\n \n \t\tJMenu help = new JadxMenu(NLS.str(\"menu.help\"), shortcutsController);\n \t\thelp.setMnemonic(KeyEvent.VK_H);\n@@ -1344,7 +1344,7 @@ public void actionPerformed(ActionEvent e) {\n \t\ttoolbar.addSeparator();\n \t\ttoolbar.add(deobfToggleBtn);\n \t\ttoolbar.add(quarkAction);\n-\t\ttoolbar.add(openDeviceAction);\n+\t\ttoolbar.add(debuggerAction);\n \t\ttoolbar.addSeparator();\n \t\ttoolbar.add(showLogAction);\n \t\ttoolbar.addSeparator();\n@@ -1379,6 +1379,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t\tdecompileAllAction.setEnabled(loaded);\n \t\t\tdeobfAction.setEnabled(loaded);\n \t\t\tquarkAction.setEnabled(loaded);\n+\t\t\tdebuggerAction.setEnabled(loaded);\n \t\t\tresetCacheAction.setEnabled(loaded);\n \t\t\treturn false;\n \t\t});",
    "output": "Fix disable debugger action if project not loaded"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/search/providers/MethodSearchProvider.java b/jadx-gui/src/main/java/jadx/gui/search/providers/MethodSearchProvider.java\n--- a/jadx-gui/src/main/java/jadx/gui/search/providers/MethodSearchProvider.java\n+++ b/jadx-gui/src/main/java/jadx/gui/search/providers/MethodSearchProvider.java\n@@ -23,6 +23,9 @@ public MethodSearchProvider(MainWindow mw, SearchSettings searchSettings, List<J\n \n \t@Override\n \tpublic @Nullable JNode next(Cancelable cancelable) {\n+\t\tif (classes.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n \t\twhile (true) {\n \t\t\tif (cancelable.isCanceled()) {\n \t\t\t\treturn null;",
    "output": "Fix prevent IndexOutOfBoundsException in MethodSearchProvider"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n@@ -11,6 +11,7 @@\n import jadx.api.impl.AnnotatedCodeWriter;\n import jadx.api.impl.NoOpCodeCache;\n import jadx.api.impl.SimpleCodeWriter;\n+import jadx.api.usage.impl.EmptyUsageInfoCache;\n import jadx.cli.LogHelper.LogLevelEnum;\n import jadx.cli.plugins.JadxFilesGetter;\n import jadx.core.utils.exceptions.JadxArgsValidateException;\n@@ -57,6 +58,7 @@ private static JadxArgs buildArgs(JadxCLIArgs cliArgs) {\n \t\tLogHelper.setLogLevelsForLoadingStage();\n \t\tJadxArgs jadxArgs = cliArgs.toJadxArgs();\n \t\tjadxArgs.setCodeCache(new NoOpCodeCache());\n+\t\tjadxArgs.setUsageInfoCache(new EmptyUsageInfoCache());\n \t\tjadxArgs.setPluginLoader(new JadxExternalPluginsLoader());\n \t\tjadxArgs.setFilesGetter(JadxFilesGetter.INSTANCE);\n \t\tinitCodeWriterProvider(jadxArgs);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/JadxCommentsAttr.java b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/JadxCommentsAttr.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/JadxCommentsAttr.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/JadxCommentsAttr.java\n@@ -1,10 +1,11 @@\n package jadx.core.dex.attributes.nodes;\n \n-import java.util.ArrayList;\n import java.util.Collections;\n import java.util.EnumMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.stream.Collectors;\n \n import jadx.api.CommentsLevel;\n@@ -30,10 +31,10 @@ private static JadxCommentsAttr initFor(IAttributeNode node) {\n \t\treturn newAttr;\n \t}\n \n-\tprivate final Map<CommentsLevel, List<String>> comments = new EnumMap<>(CommentsLevel.class);\n+\tprivate final Map<CommentsLevel, Set<String>> comments = new EnumMap<>(CommentsLevel.class);\n \n \tpublic void add(CommentsLevel level, String comment) {\n-\t\tcomments.computeIfAbsent(level, l -> new ArrayList<>()).add(comment);\n+\t\tcomments.computeIfAbsent(level, l -> new HashSet<>()).add(comment);\n \t}\n \n \tpublic List<String> formatAndFilter(CommentsLevel level) {\n@@ -47,12 +48,11 @@ public List<String> formatAndFilter(CommentsLevel level) {\n \t\t\t\t\treturn e.getValue().stream()\n \t\t\t\t\t\t\t.map(v -> \"JADX \" + levelName + \": \" + v);\n \t\t\t\t})\n-\t\t\t\t.distinct()\n \t\t\t\t.sorted()\n \t\t\t\t.collect(Collectors.toList());\n \t}\n \n-\tpublic Map<CommentsLevel, List<String>> getComments() {\n+\tpublic Map<CommentsLevel, Set<String>> getComments() {\n \t\treturn comments;\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -150,6 +150,8 @@ private void restoreUsageData() {\n \t\tIUsageInfoData usageInfoData = root.getArgs().getUsageInfoCache().get(root);\n \t\tif (usageInfoData != null) {\n \t\t\tusageInfoData.applyForClass(this);\n+\t\t} else {\n+\t\t\tLOG.warn(\"Can't restore usage data for class: {}\", this);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/DecompilerScheduler.java b/jadx-core/src/main/java/jadx/core/utils/DecompilerScheduler.java\n--- a/jadx-core/src/main/java/jadx/core/utils/DecompilerScheduler.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/DecompilerScheduler.java\n@@ -65,7 +65,7 @@ public List<List<JavaClass>> internalBatches(List<JavaClass> classes) {\n \t\t\t\t\tmergedBatch = new ArrayList<>(MERGED_BATCH_SIZE);\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tList<JavaClass> batch = new ArrayList<>(depsSize + 1);\n+\t\t\t\tList<JavaClass> batch = new ArrayList<>();\n \t\t\t\tfor (JavaClass dep : cls.getDependencies()) {\n \t\t\t\t\tJavaClass topDep = dep.getTopParentClass();\n \t\t\t\t\tif (!added.contains(topDep)) {\n@@ -75,7 +75,7 @@ public List<List<JavaClass>> internalBatches(List<JavaClass> classes) {\n \t\t\t\t}\n \t\t\t\tbatch.sort(cmpDepSize);\n \t\t\t\tbatch.add(cls);\n-\t\t\t\tresult.add(batch);\n+\t\t\t\tresult.add(Utils.lockList(batch));\n \t\t\t}\n \t\t}\n \t\tif (!mergedBatch.isEmpty()) {",
    "output": "Fix improve memory usage in jadx-cli"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -65,7 +65,7 @@ public synchronized ICodeInfo parse(InputStream inputStream) throws IOException\n \t\tresourceIds = null;\n \t\tis = new ParserStream(inputStream);\n \t\tif (!isBinaryXml()) {\n-\t\t\treturn ResourcesLoader.loadToCodeWriter(inputStream);\n+\t\t\treturn ResourcesLoader.loadToCodeWriter(is);\n \t\t}\n \t\tnsMapGenerated = new HashSet<>();\n \t\tnsMap = new HashMap<>();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java\n@@ -9,7 +9,7 @@\n \n import org.jetbrains.annotations.NotNull;\n \n-public class ParserStream {\n+public class ParserStream extends InputStream {\n \n \tprotected static final Charset STRING_CHARSET_UTF16 = StandardCharsets.UTF_16LE;\n \tprotected static final Charset STRING_CHARSET_UTF8 = StandardCharsets.UTF_8;\n@@ -88,7 +88,8 @@ public byte[] readInt8Array(int count) throws IOException {\n \t\treturn arr;\n \t}\n \n-\tpublic void skip(long count) throws IOException {\n+\t@Override\n+\tpublic long skip(long count) throws IOException {\n \t\treadPos += count;\n \t\tlong pos = input.skip(count);\n \t\twhile (pos < count) {\n@@ -98,6 +99,7 @@ public void skip(long count) throws IOException {\n \t\t\t}\n \t\t\tpos += skipped;\n \t\t}\n+\t\treturn pos;\n \t}\n \n \tpublic void checkInt8(int expected, String error) throws IOException {\n@@ -140,14 +142,16 @@ public void skipToPos(long expectedOffset, String error) throws IOException {\n \t\tcheckPos(expectedOffset, error);\n \t}\n \n-\tpublic void mark(int len) throws IOException {\n+\t@Override\n+\tpublic void mark(int len) {\n \t\tif (!input.markSupported()) {\n-\t\t\tthrow new IOException(\"Mark not supported for input stream \" + input.getClass());\n+\t\t\tthrow new RuntimeException(\"Mark not supported for input stream \" + input.getClass());\n \t\t}\n \t\tinput.mark(len);\n \t\tmarkPos = readPos;\n \t}\n \n+\t@Override\n \tpublic void reset() throws IOException {\n \t\tinput.reset();\n \t\treadPos = markPos;\n@@ -172,6 +176,16 @@ public void readFully(byte[] b, int off, int len) throws IOException {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic int read() throws IOException {\n+\t\treturn input.read();\n+\t}\n+\n+\t@Override\n+\tpublic int read(@NotNull byte[] b, int off, int len) throws IOException {\n+\t\treturn input.read(b, off, len);\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn \"pos: 0x\" + Long.toHexString(readPos);",
    "output": "Fix correct loading for plain text XML files"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/action/FridaAction.java b/jadx-gui/src/main/java/jadx/gui/ui/action/FridaAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/action/FridaAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/action/FridaAction.java\n@@ -136,7 +136,7 @@ private String generateClassSnippet(JClass jc) {\n \t\tJavaClass javaClass = jc.getCls();\n \t\tString rawClassName = StringEscapeUtils.escapeEcmaScript(javaClass.getRawName());\n \t\tString shortClassName = javaClass.getName();\n-\t\treturn String.format(\"let %s = Java.use(\\\"%s\\\");\", shortClassName, rawClassName);\n+\t\treturn String.format(\"var %s = Java.use(\\\"%s\\\");\", shortClassName, rawClassName);\n \t}\n \n \tprivate void showMethodSelectionDialog(JClass jc) {",
    "output": "Use `var` instead `let` for class variable in Frida script"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/action/FridaAction.java b/jadx-gui/src/main/java/jadx/gui/ui/action/FridaAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/action/FridaAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/action/FridaAction.java\n@@ -78,7 +78,9 @@ private void copySnipped(String fridaSnippet) {\n \t}\n \n \tprivate String generateMethodSnippet(JMethod jMth) {\n-\t\treturn getMethodSnippet(jMth.getJavaMethod(), jMth.getJParent());\n+\t\tString classSnippet = generateClassSnippet(jMth.getJParent());\n+\t\tString methodSnippet = getMethodSnippet(jMth.getJavaMethod(), jMth.getJParent());\n+\t\treturn String.format(\"%s\\n%s\", classSnippet, methodSnippet);\n \t}\n \n \tprivate String generateMethodSnippet(JavaMethod javaMethod, JClass jc) {\n@@ -115,17 +117,14 @@ private String getMethodSnippet(JavaMethod javaMethod, JClass jc) {\n \t\t\tlogArgs = \": \" + argNames.stream().map(arg -> arg + \"=${\" + arg + \"}\").collect(Collectors.joining(\", \"));\n \t\t}\n \t\tString shortClassName = mth.getParentClass().getAlias();\n-\t\tString classSnippet = generateClassSnippet(jc);\n \t\tif (methodInfo.isConstructor() || methodInfo.getReturnType() == ArgType.VOID) {\n \t\t\t// no return value\n-\t\t\treturn classSnippet + \"\\n\"\n-\t\t\t\t\t+ shortClassName + \"[\\\"\" + methodName + \"\\\"]\" + overload + \".implementation = function (\" + args + \") {\\n\"\n+\t\t\treturn shortClassName + \"[\\\"\" + methodName + \"\\\"]\" + overload + \".implementation = function (\" + args + \") {\\n\"\n \t\t\t\t\t+ \"    console.log(`\" + shortClassName + \".\" + newMethodName + \" is called\" + logArgs + \"`);\\n\"\n \t\t\t\t\t+ \"    this[\\\"\" + methodName + \"\\\"](\" + args + \");\\n\"\n \t\t\t\t\t+ \"};\";\n \t\t}\n-\t\treturn classSnippet + \"\\n\"\n-\t\t\t\t+ shortClassName + \"[\\\"\" + methodName + \"\\\"]\" + overload + \".implementation = function (\" + args + \") {\\n\"\n+\t\treturn shortClassName + \"[\\\"\" + methodName + \"\\\"]\" + overload + \".implementation = function (\" + args + \") {\\n\"\n \t\t\t\t+ \"    console.log(`\" + shortClassName + \".\" + newMethodName + \" is called\" + logArgs + \"`);\\n\"\n \t\t\t\t+ \"    let result = this[\\\"\" + methodName + \"\\\"](\" + args + \");\\n\"\n \t\t\t\t+ \"    console.log(`\" + shortClassName + \".\" + newMethodName + \" result=${result}`);\\n\"\n@@ -150,6 +149,8 @@ private void showMethodSelectionDialog(JClass jc) {\n \n \tprivate String generateClassAllMethodSnippet(JClass jc, List<JavaMethod> methodList) {\n \t\tStringBuilder result = new StringBuilder();\n+\t\tString classSnippet = generateClassSnippet(jc);\n+\t\tresult.append(classSnippet).append(\"\\n\");\n \t\tfor (JavaMethod javaMethod : methodList) {\n \t\t\tresult.append(generateMethodSnippet(javaMethod, jc)).append(\"\\n\");\n \t\t}",
    "output": "Remove duplicate class of Frida snippet"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n@@ -4,6 +4,8 @@\n import java.awt.Dimension;\n import java.awt.FlowLayout;\n import java.awt.Insets;\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentEvent;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.EnumSet;\n@@ -347,6 +349,8 @@ private void initUI() {\n \t\t\tboolean resSearch = searchOptions.contains(RESOURCE);\n \t\t\tresExtFilePanel.setVisible(resSearch);\n \t\t\tsizeLimitPanel.setVisible(resSearch);\n+\t\t\toptionsPanel.revalidate();\n+\t\t\toptionsPanel.repaint();\n \t\t});\n \n \t\tJPanel searchPane = new JPanel();\n@@ -367,6 +371,13 @@ private void initUI() {\n \t\tcontentPanel.add(buttonPane, BorderLayout.PAGE_END);\n \t\tgetContentPane().add(contentPanel);\n \n+\t\taddComponentListener(new ComponentAdapter() {\n+\t\t\t@Override\n+\t\t\tpublic void componentResized(ComponentEvent e) {\n+\t\t\t\toptionsPanel.revalidate();\n+\t\t\t\toptionsPanel.repaint();\n+\t\t\t}\n+\t\t});\n \t\tsetLocationRelativeTo(null);\n \t\tsetDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n \t}",
    "output": "Fix workaround for wrap layout repaint issue in search dialog"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/Utils.java b/jadx-core/src/main/java/jadx/core/utils/Utils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/Utils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java\n@@ -16,9 +16,12 @@\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Consumer;\n import java.util.function.Function;\n \n+import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n \n import jadx.api.ICodeWriter;\n@@ -504,6 +507,27 @@ public static void checkThreadInterrupt() {\n \t\t}\n \t}\n \n+\tpublic static ThreadFactory simpleThreadFactory(String name) {\n+\t\treturn new SimpleThreadFactory(name);\n+\t}\n+\n+\tprivate static final class SimpleThreadFactory implements ThreadFactory {\n+\t\tprivate static final AtomicInteger POOL = new AtomicInteger(0);\n+\t\tprivate final AtomicInteger number = new AtomicInteger(0);\n+\t\tprivate final String name;\n+\n+\t\tpublic SimpleThreadFactory(String name) {\n+\t\t\tthis.name = name;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Thread newThread(@NotNull Runnable r) {\n+\t\t\treturn new Thread(r, \"jadx-\" + name\n+\t\t\t\t\t+ '-' + POOL.incrementAndGet()\n+\t\t\t\t\t+ '-' + number.incrementAndGet());\n+\t\t}\n+\t}\n+\n \t/**\n \t * @deprecated env vars shouldn't be used in core modules.\n \t *             Prefer to parse in `app` (use JadxCommonEnv from 'app-commons') and set in jadx args.\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/tasks/TaskExecutor.java b/jadx-core/src/main/java/jadx/core/utils/tasks/TaskExecutor.java\n--- a/jadx-core/src/main/java/jadx/core/utils/tasks/TaskExecutor.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/tasks/TaskExecutor.java\n@@ -13,6 +13,7 @@\n \n import jadx.api.JadxArgs;\n import jadx.api.utils.tasks.ITaskExecutor;\n+import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public class TaskExecutor implements ITaskExecutor {\n@@ -99,7 +100,7 @@ public void execute() {\n \t\trunning.set(true);\n \t\tprogress.set(0);\n \t\tterminating.set(false);\n-\t\texecutor = Executors.newFixedThreadPool(1);\n+\t\texecutor = Executors.newFixedThreadPool(1, Utils.simpleThreadFactory(\"task-s\"));\n \t\texecutor.execute(this::runStages);\n \t\texecutor.shutdown();\n \t}\n@@ -142,7 +143,8 @@ private void runStages() {\n \t\t\t\t\t\twrapTask(task);\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tExecutorService parallelExecutor = Executors.newFixedThreadPool(threads);\n+\t\t\t\t\tExecutorService parallelExecutor = Executors.newFixedThreadPool(\n+\t\t\t\t\t\t\tthreads, Utils.simpleThreadFactory(\"task-p\"));\n \t\t\t\t\tfor (Runnable task : stage.getTasks()) {\n \t\t\t\t\t\tparallelExecutor.execute(() -> wrapTask(task));\n \t\t\t\t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n--- a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n+++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n@@ -22,6 +22,7 @@\n import org.slf4j.LoggerFactory;\n \n import jadx.api.utils.tasks.ITaskExecutor;\n+import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.settings.JadxSettings;\n import jadx.gui.ui.MainWindow;\n@@ -104,7 +105,7 @@ public Future<TaskStatus> execute(String title, Runnable backgroundRunnable) {\n \t}\n \n \tprivate synchronized void reset() {\n-\t\ttaskQueueExecutor = (ThreadPoolExecutor) Executors.newFixedThreadPool(1);\n+\t\ttaskQueueExecutor = (ThreadPoolExecutor) Executors.newFixedThreadPool(1, Utils.simpleThreadFactory(\"bg\"));\n \t\ttaskRunning.clear();\n \t\tidSupplier.set(0);\n \t}\n@@ -162,6 +163,7 @@ protected TaskStatus doInBackground() throws Exception {\n \t\t\t\t} finally {\n \t\t\t\t\ttaskComplete(id);\n \t\t\t\t\tprogressPane.changeVisibility(this, false);\n+\t\t\t\t\tremovePropertyChangeListener(progressPane);\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn status;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -537,14 +537,19 @@ private static Path getProjectPathForFile(Path loadedFile) {\n \t}\n \n \tpublic void reopen() {\n-\t\tsynchronized (ReloadProject.EVENT) {\n-\t\t\tsaveAll();\n-\t\t\tcloseAll();\n-\t\t\tloadFiles(() -> {\n-\t\t\t\tmenuBar.reloadShortcuts();\n-\t\t\t\tevents().send(ReloadSettingsWindow.INSTANCE);\n-\t\t\t});\n-\t\t}\n+\t\tLOG.debug(\"starting reopen\");\n+\t\tUiUtils.bgRun(() -> {\n+\t\t\tgetBackgroundExecutor().waitForComplete();\n+\t\t\tsynchronized (ReloadProject.EVENT) {\n+\t\t\t\tsaveAll();\n+\t\t\t\tcloseAll();\n+\t\t\t\tloadFiles(() -> {\n+\t\t\t\t\tmenuBar.reloadShortcuts();\n+\t\t\t\t\tevents().send(ReloadSettingsWindow.INSTANCE);\n+\t\t\t\t\tLOG.debug(\"reopen complete\");\n+\t\t\t\t});\n+\t\t\t}\n+\t\t});\n \t}\n \n \tprivate void openProject(Path path, Runnable onFinish) {\n@@ -622,7 +627,7 @@ private void closeAll() {\n \t\tshortcutsController.reset();\n \t\tUiUtils.resetClipboardOwner();\n \t\tSystem.gc();\n-\t\tupdate();\n+\t\tUiUtils.uiRun(this::update);\n \t}\n \n \tprivate void checkLoadedStatus() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n@@ -20,6 +20,8 @@\n import java.util.List;\n import java.util.Timer;\n import java.util.TimerTask;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n \n import javax.swing.AbstractAction;\n import javax.swing.Action;\n@@ -79,6 +81,8 @@ public String toString() {\n \t\t}\n \t};\n \n+\tprivate static final ExecutorService BACKGROUND_THREAD = Executors.newSingleThreadExecutor(Utils.simpleThreadFactory(\"utils-bg\"));\n+\n \tprivate UiUtils() {\n \t}\n \n@@ -420,6 +424,14 @@ public static void uiRunAndWait(Runnable runnable) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Run task in background thread.\n+\t * Uses single thread, so all tasks are ordered.\n+\t */\n+\tpublic static void bgRun(Runnable runnable) {\n+\t\tBACKGROUND_THREAD.submit(runnable);\n+\t}\n+\n \tpublic static void uiThreadGuard() {\n \t\tif (!SwingUtilities.isEventDispatchThread()) {\n \t\t\tLOG.warn(\"Expect UI thread, got: {}\", Thread.currentThread(), new JadxRuntimeException());",
    "output": "Fix prevent UI thread freeze on plugin install/uninstall"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n@@ -38,6 +38,7 @@\n import javax.swing.SwingUtilities;\n import javax.swing.WindowConstants;\n \n+import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -56,6 +57,8 @@\n import jadx.api.plugins.events.types.ReloadSettingsWindow;\n import jadx.api.plugins.gui.ISettingsGroup;\n import jadx.core.utils.GsonUtils;\n+import jadx.core.utils.StringUtils;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.settings.JadxSettings;\n import jadx.gui.settings.JadxSettingsAdapter;\n import jadx.gui.settings.JadxUpdateChannel;\n@@ -91,6 +94,7 @@ public class JadxSettingsWindow extends JDialog {\n \tprivate transient boolean needReload = false;\n \tprivate transient SettingsTree tree;\n \tprivate List<ISettingsGroup> groups;\n+\tprivate JPanel wrapGroupPanel;\n \n \tpublic JadxSettingsWindow(MainWindow mainWindow, JadxSettings settings) {\n \t\tthis.mainWindow = mainWindow;\n@@ -127,7 +131,7 @@ private void reloadUI() {\n \t}\n \n \tprivate void initUI() {\n-\t\tJPanel wrapGroupPanel = new JPanel(new BorderLayout(10, 10));\n+\t\twrapGroupPanel = new JPanel(new BorderLayout(10, 10));\n \n \t\tgroups = new ArrayList<>();\n \t\tgroups.add(makeDecompilationGroup());\n@@ -140,8 +144,8 @@ private void initUI() {\n \t\tgroups.add(new PluginSettings(mainWindow, settings).build());\n \t\tgroups.add(makeOtherGroup());\n \n-\t\ttree = new SettingsTree();\n-\t\ttree.init(wrapGroupPanel, groups);\n+\t\ttree = new SettingsTree(this);\n+\t\ttree.init(groups);\n \t\ttree.setFocusable(true);\n \t\tJScrollPane leftPane = new JScrollPane(tree);\n \t\tleftPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 3, 3));\n@@ -194,6 +198,46 @@ private JPanel buildButtonsPane() {\n \t\treturn buttonPane;\n \t}\n \n+\t/**\n+\t * Activate the settings page by location.\n+\t *\n+\t * @param location - can be title of a settings group or settings group class implementation (end\n+\t *                 with .class)\n+\t */\n+\tpublic void activatePage(String location) {\n+\t\tif (location.endsWith(\".class\")) {\n+\t\t\tString clsName = StringUtils.removeSuffix(location, \".class\");\n+\t\t\tfor (ISettingsGroup group : groups) {\n+\t\t\t\tString groupCls = group.getClass().getSimpleName();\n+\t\t\t\tif (groupCls.equals(clsName)) {\n+\t\t\t\t\tselectGroup(group);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tthrow new JadxRuntimeException(\"No setting group class: \" + location);\n+\t\t} else {\n+\t\t\tfor (ISettingsGroup group : groups) {\n+\t\t\t\tif (group.getTitle().equals(location)) {\n+\t\t\t\t\tselectGroup(group);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tthrow new JadxRuntimeException(\"No setting group with title: \" + location);\n+\t\t}\n+\t}\n+\n+\tpublic void selectGroup(ISettingsGroup group) {\n+\t\ttree.selectGroup(group);\n+\t}\n+\n+\tpublic void activateGroup(@Nullable ISettingsGroup group) {\n+\t\twrapGroupPanel.removeAll();\n+\t\tif (group != null) {\n+\t\t\twrapGroupPanel.add(group.buildComponent());\n+\t\t}\n+\t\twrapGroupPanel.updateUI();\n+\t}\n+\n \tprivate static void enableComponents(Container container, boolean enable) {\n \t\tfor (Component component : container.getComponents()) {\n \t\t\tif (component instanceof Container) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/SettingsTree.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/SettingsTree.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/SettingsTree.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/SettingsTree.java\n@@ -1,10 +1,10 @@\n package jadx.gui.settings.ui;\n \n import java.util.Collections;\n+import java.util.Enumeration;\n import java.util.List;\n import java.util.Objects;\n \n-import javax.swing.JPanel;\n import javax.swing.JTree;\n import javax.swing.event.TreeExpansionEvent;\n import javax.swing.event.TreeWillExpandListener;\n@@ -15,18 +15,26 @@\n import javax.swing.tree.TreePath;\n import javax.swing.tree.TreeSelectionModel;\n \n+import org.jetbrains.annotations.Nullable;\n+\n import jadx.api.plugins.gui.ISettingsGroup;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.utils.NLS;\n \n public class SettingsTree extends JTree {\n+\tprivate final JadxSettingsWindow settingsWindow;\n+\n+\tpublic SettingsTree(JadxSettingsWindow settingsWindow) {\n+\t\tthis.settingsWindow = settingsWindow;\n+\t}\n \n-\tpublic void init(JPanel groupPanel, List<ISettingsGroup> groups) {\n+\tpublic void init(List<ISettingsGroup> groups) {\n \t\tDefaultMutableTreeNode treeRoot = new DefaultMutableTreeNode(NLS.str(\"preferences.title\"));\n \t\taddGroups(treeRoot, groups);\n \t\tsetModel(new DefaultTreeModel(treeRoot));\n \t\tgetSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n \t\tsetFocusable(false);\n-\t\taddTreeSelectionListener(e -> switchGroup(groupPanel));\n+\t\taddTreeSelectionListener(ev -> switchGroup());\n \t\t// expand all nodes and disallow collapsing\n \t\tsetNodeExpandedState(this, treeRoot, true);\n \t\taddTreeWillExpandListener(new DisableRootCollapseListener(treeRoot));\n@@ -41,13 +49,34 @@ private static void addGroups(DefaultMutableTreeNode base, List<ISettingsGroup>\n \t\t}\n \t}\n \n-\tprivate void switchGroup(JPanel groupPanel) {\n+\tpublic void selectGroup(ISettingsGroup group) {\n+\t\tSettingsTreeNode node = searchTreeNode(group);\n+\t\tif (node == null) {\n+\t\t\tthrow new JadxRuntimeException(\"Settings group not found: \" + group);\n+\t\t}\n+\t\tsetSelectionPath(new TreePath(node.getPath()));\n+\t}\n+\n+\tprivate @Nullable SettingsTreeNode searchTreeNode(ISettingsGroup group) {\n+\t\tDefaultMutableTreeNode root = (DefaultMutableTreeNode) getModel().getRoot();\n+\t\tEnumeration<TreeNode> enumeration = root.children();\n+\t\twhile (enumeration.hasMoreElements()) {\n+\t\t\tSettingsTreeNode node = (SettingsTreeNode) enumeration.nextElement();\n+\t\t\tif (node.getGroup() == group) {\n+\t\t\t\treturn node;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate void switchGroup() {\n \t\tObject selected = getLastSelectedPathComponent();\n-\t\tgroupPanel.removeAll();\n \t\tif (selected instanceof SettingsTreeNode) {\n-\t\t\tgroupPanel.add(((SettingsTreeNode) selected).getGroup().buildComponent());\n+\t\t\tISettingsGroup group = ((SettingsTreeNode) selected).getGroup();\n+\t\t\tsettingsWindow.activateGroup(group);\n+\t\t} else {\n+\t\t\tsettingsWindow.activateGroup(null);\n \t\t}\n-\t\tgroupPanel.updateUI();\n \t}\n \n \tprivate static void setNodeExpandedState(JTree tree, TreeNode node, boolean expanded) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -39,7 +39,6 @@\n import javax.swing.Box;\n import javax.swing.JCheckBox;\n import javax.swing.JCheckBoxMenuItem;\n-import javax.swing.JDialog;\n import javax.swing.JFileChooser;\n import javax.swing.JFrame;\n import javax.swing.JLabel;\n@@ -117,7 +116,6 @@\n import jadx.gui.settings.JadxProject;\n import jadx.gui.settings.JadxSettings;\n import jadx.gui.settings.ui.JadxSettingsWindow;\n-import jadx.gui.settings.ui.plugins.PluginSettings;\n import jadx.gui.tree.TreeExpansionService;\n import jadx.gui.treemodel.ApkSignatureNode;\n import jadx.gui.treemodel.JInputFiles;\n@@ -1138,7 +1136,7 @@ private void initMenuAndToolbar() {\n \t\thexViewerMenu = new JadxMenu(NLS.str(\"menu.hex_viewer\"), shortcutsController);\n \t\tinitHexViewMenu();\n \n-\t\tJadxGuiAction prefsAction = new JadxGuiAction(ActionModel.PREFS, this::openSettings);\n+\t\tJadxGuiAction prefsAction = new JadxGuiAction(ActionModel.PREFS, () -> openSettings());\n \t\tJadxGuiAction exitAction = new JadxGuiAction(ActionModel.EXIT, this::closeWindow);\n \n \t\tisFlattenPackage = settings.isFlattenPackage();\n@@ -1532,16 +1530,23 @@ public void setLocationAndPosition() {\n \t}\n \n \tprivate void openSettings() {\n+\t\topenSettings(null);\n+\t}\n+\n+\tprivate void openSettings(@Nullable String navigateTo) {\n \t\tsettingsOpen = true;\n \n-\t\tJDialog settingsWindow = new JadxSettingsWindow(MainWindow.this, settings);\n-\t\tsettingsWindow.setVisible(true);\n+\t\tJadxSettingsWindow settingsWindow = new JadxSettingsWindow(MainWindow.this, settings);\n \t\tsettingsWindow.addWindowListener(new WindowAdapter() {\n \t\t\t@Override\n \t\t\tpublic void windowClosed(WindowEvent e) {\n \t\t\t\tsettingsOpen = false;\n \t\t\t}\n \t\t});\n+\t\tif (navigateTo != null) {\n+\t\t\tsettingsWindow.activatePage(navigateTo);\n+\t\t}\n+\t\tsettingsWindow.setVisible(true);\n \t}\n \n \tpublic boolean isSettingsOpen() {\n@@ -1780,8 +1785,8 @@ public JMenu getPluginsMenu() {\n \n \tpublic void resetPluginsMenu() {\n \t\tpluginsMenu.removeAll();\n-\t\tpluginsMenu.add(new ActionHandler(() -> new PluginSettings(this, settings).addPlugin())\n-\t\t\t\t.withNameAndDesc(NLS.str(\"preferences.plugins.install\")));\n+\t\tpluginsMenu.add(new ActionHandler(() -> openSettings(\"PluginSettingsGroup.class\"))\n+\t\t\t\t.withNameAndDesc(NLS.str(\"preferences.plugins.manage\")));\n \t}\n \n \tpublic void addToPluginsMenu(Action item) {",
    "output": "Fix redirect plugins menu action to show plugins settings page"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourceFile.java b/jadx-core/src/main/java/jadx/api/ResourceFile.java\n--- a/jadx-core/src/main/java/jadx/api/ResourceFile.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java\n@@ -56,12 +56,12 @@ public ResContainer loadContent() {\n \t\treturn ResourcesLoader.loadContent(decompiler, this);\n \t}\n \n-\tpublic boolean setAlias(ResourceEntry entry, boolean useHeders) {\n+\tpublic boolean setAlias(ResourceEntry entry, boolean useHeaders) {\n \t\tStringBuilder sb = new StringBuilder();\n \t\tsb.append(\"res/\").append(entry.getTypeName()).append(entry.getConfig());\n \t\tsb.append(\"/\").append(entry.getKeyName());\n \n-\t\tif (useHeders) {\n+\t\tif (useHeaders) {\n \t\t\ttry {\n \t\t\t\tint maxBytesToReadLimit = 4096;\n \t\t\t\tbyte[] bytes = ResourcesLoader.decodeStream(this, (size, is) -> {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n@@ -153,14 +153,15 @@ private static void sortResNodes(List<JResource> nodes) {\n \t\tif (resFile == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tif (resFile.getType() == ResourceType.IMG) {\n-\t\t\treturn new ImagePanel(tabbedPane, this);\n-\t\t}\n-\t\tif (resFile.getType() == ResourceType.LIB) {\n-\t\t\treturn new BinaryContentPanel(tabbedPane, this, false);\n-\t\t}\n-\t\tif (resFile.getType() == ResourceType.FONT) {\n-\t\t\treturn new FontPanel(tabbedPane, this);\n+\t\t// TODO: allow to register custom viewers\n+\t\tswitch (resFile.getType()) {\n+\t\t\tcase IMG:\n+\t\t\t\treturn new ImagePanel(tabbedPane, this);\n+\t\t\tcase LIB:\n+\t\t\tcase CODE:\n+\t\t\t\treturn new BinaryContentPanel(tabbedPane, this, false);\n+\t\t\tcase FONT:\n+\t\t\t\treturn new FontPanel(tabbedPane, this);\n \t\t}\n \t\tif (getSyntaxByExtension(resFile.getDeobfName()) == null) {\n \t\t\treturn new BinaryContentPanel(tabbedPane, this);\n@@ -326,7 +327,6 @@ public Icon getIcon() {\n \n \tpublic static boolean isSupportedForView(ResourceType type) {\n \t\tswitch (type) {\n-\t\t\tcase CODE:\n \t\t\tcase SOUNDS:\n \t\t\tcase VIDEOS:\n \t\t\tcase ARCHIVE:\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/BinaryContentPanel.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/BinaryContentPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/BinaryContentPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/BinaryContentPanel.java\n@@ -3,6 +3,7 @@\n import java.awt.BorderLayout;\n import java.awt.Component;\n import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import javax.swing.JSplitPane;\n import javax.swing.JTabbedPane;\n@@ -20,6 +21,7 @@\n import jadx.gui.treemodel.JResource;\n import jadx.gui.ui.hexviewer.HexPreviewPanel;\n import jadx.gui.ui.tab.TabbedPane;\n+import jadx.gui.utils.NLS;\n \n public class BinaryContentPanel extends AbstractCodeContentPanel {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(BinaryContentPanel.class);\n@@ -46,23 +48,36 @@ public BinaryContentPanel(TabbedPane panel, JNode jnode, boolean supportsText) {\n \t\tareaTabbedPane = buildTabbedPane();\n \t\tadd(areaTabbedPane);\n \n-\t\tSwingUtilities.invokeLater(this::loadCodePanel);\n+\t\tSwingUtilities.invokeLater(this::loadSelectedPanel);\n \t}\n \n \tprivate void loadToHexView(JNode binaryNode) {\n-\t\tbyte[] bytes = null;\n-\t\tif (binaryNode instanceof JResource) {\n-\t\t\tJResource jResource = (JResource) binaryNode;\n-\t\t\ttry {\n-\t\t\t\tbytes = ResourcesLoader.decodeStream(jResource.getResFile(), (size, is) -> is.readAllBytes());\n-\t\t\t} catch (JadxException e) {\n-\t\t\t\tLOG.error(\"Failed to directly load resource binary data {}: {}\", jResource.getName(), e.getMessage());\n-\t\t\t}\n+\t\tif (hexPreviewPanel.isDataLoaded()) {\n+\t\t\treturn;\n \t\t}\n-\t\tif (bytes == null) {\n-\t\t\tbytes = binaryNode.getCodeInfo().getCodeStr().getBytes(StandardCharsets.UTF_8);\n-\t\t}\n-\t\thexPreviewPanel.setData(bytes);\n+\t\tAtomicReference<byte[]> bytesRef = new AtomicReference<>();\n+\t\tgetMainWindow().getBackgroundExecutor().execute(NLS.str(\"progress.load\"),\n+\t\t\t\t() -> {\n+\t\t\t\t\tbyte[] bytes = null;\n+\t\t\t\t\tif (binaryNode instanceof JResource) {\n+\t\t\t\t\t\tJResource jResource = (JResource) binaryNode;\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tbytes = ResourcesLoader.decodeStream(jResource.getResFile(), (size, is) -> is.readAllBytes());\n+\t\t\t\t\t\t} catch (JadxException e) {\n+\t\t\t\t\t\t\tLOG.error(\"Failed to directly load resource binary data {}: {}\", jResource.getName(), e.getMessage());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (bytes == null) {\n+\t\t\t\t\t\tbytes = binaryNode.getCodeInfo().getCodeStr().getBytes(StandardCharsets.UTF_8);\n+\t\t\t\t\t}\n+\t\t\t\t\tbytesRef.set(bytes);\n+\t\t\t\t},\n+\t\t\t\ttaskStatus -> {\n+\t\t\t\t\tbyte[] bytes = bytesRef.get();\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\thexPreviewPanel.setData(bytes);\n+\t\t\t\t\t}\n+\t\t\t\t});\n \t}\n \n \tprivate JTabbedPane buildTabbedPane() {\n@@ -75,16 +90,16 @@ private JTabbedPane buildTabbedPane() {\n \t\ttabbedPane.add(hexPreviewPanel, \"Hex\");\n \t\ttabbedPane.addChangeListener(e -> {\n \t\t\tgetMainWindow().toggleHexViewMenu();\n+\t\t\tloadSelectedPanel();\n \t\t});\n \t\treturn tabbedPane;\n \t}\n \n-\tprivate void loadCodePanel() {\n+\tprivate void loadSelectedPanel() {\n \t\tComponent codePanel = getSelectedPanel();\n \t\tif (codePanel instanceof CodeArea) {\n \t\t\tCodeArea codeArea = (CodeArea) codePanel;\n \t\t\tcodeArea.load();\n-\t\t\tloadToHexView(getNode());\n \t\t} else {\n \t\t\tloadToHexView(getNode());\n \t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/hexviewer/HexPreviewPanel.java b/jadx-gui/src/main/java/jadx/gui/ui/hexviewer/HexPreviewPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/hexviewer/HexPreviewPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/hexviewer/HexPreviewPanel.java\n@@ -38,14 +38,15 @@\n import jadx.gui.utils.UiUtils;\n \n public class HexPreviewPanel extends JPanel {\n-\tprivate static final long serialVersionUID = 1L;\n+\tprivate static final long serialVersionUID = 3261685857479120073L;\n \tprivate static final int CACHE_SIZE = 250;\n+\n \tprivate final byte[] valuesCache = new byte[CACHE_SIZE];\n-\tprivate SectCodeArea hexCodeArea;\n-\tprivate SectionCodeAreaColorProfile defaultColors;\n-\tprivate HexEditorHeader header;\n-\tprivate HexSearchBar searchBar;\n-\tprivate HexInspectorPanel inspector;\n+\tprivate final SectCodeArea hexCodeArea;\n+\tprivate final SectionCodeAreaColorProfile defaultColors;\n+\tprivate final HexEditorHeader header;\n+\tprivate final HexSearchBar searchBar;\n+\tprivate final HexInspectorPanel inspector;\n \n \tprivate JPopupMenu popupMenu;\n \tprivate JMenuItem cutAction;\n@@ -59,11 +60,11 @@ public class HexPreviewPanel extends JPanel {\n \tprivate BasicCodeAreaZone popupMenuPositionZone = BasicCodeAreaZone.UNKNOWN;\n \n \tpublic HexPreviewPanel(JadxSettings settings) {\n-\t\tthis.hexCodeArea = new SectCodeArea();\n-\t\tthis.hexCodeArea.setCodeFont(settings.getFont());\n-\t\tthis.hexCodeArea.setEditMode(EditMode.READ_ONLY);\n-\t\tthis.hexCodeArea.setCharset(StandardCharsets.UTF_8);\n-\t\tthis.hexCodeArea.setComponentPopupMenu(new JPopupMenu() {\n+\t\thexCodeArea = new SectCodeArea();\n+\t\thexCodeArea.setCodeFont(settings.getFont());\n+\t\thexCodeArea.setEditMode(EditMode.READ_ONLY);\n+\t\thexCodeArea.setCharset(StandardCharsets.UTF_8);\n+\t\thexCodeArea.setComponentPopupMenu(new JPopupMenu() {\n \t\t\t@Override\n \t\t\tpublic void show(Component invoker, int x, int y) {\n \t\t\t\tpopupMenuPositionZone = hexCodeArea.getPainter().getPositionZone(x, y);\n@@ -76,10 +77,10 @@ public void show(Component invoker, int x, int y) {\n \t\t\t}\n \t\t});\n \n-\t\tthis.inspector = new HexInspectorPanel();\n-\t\tthis.searchBar = new HexSearchBar(hexCodeArea);\n-\t\tthis.header = new HexEditorHeader(hexCodeArea);\n-\t\tthis.header.setFont(settings.getFont());\n+\t\tinspector = new HexInspectorPanel();\n+\t\tsearchBar = new HexSearchBar(hexCodeArea);\n+\t\theader = new HexEditorHeader(hexCodeArea);\n+\t\theader.setFont(settings.getFont());\n \n \t\tCodeAreaPainter painter = hexCodeArea.getPainter();\n \t\tdefaultColors = (SectionCodeAreaColorProfile) hexCodeArea.getColorsProfile();\n@@ -116,15 +117,19 @@ public void focusLost(FocusEvent e) {\n \tpublic SectionCodeAreaColorProfile getColorsProfile() {\n \t\tboolean isDarkTheme = UiUtils.isDarkTheme(Objects.requireNonNull(defaultColors.getColor(CodeAreaBasicColors.TEXT_BACKGROUND)));\n \t\tColor markAllHighlightColor = isDarkTheme ? Color.decode(\"#32593D\") : Color.decode(\"#ffc800\");\n-\t\tColor editorSelectionBackground = defaultColors.getColor(CodeAreaBasicColors.SELECTION_BACKGROUND);\n+\t\tColor editorSelectionBackground = Objects.requireNonNull(defaultColors.getColor(CodeAreaBasicColors.SELECTION_BACKGROUND));\n \t\tColor currentMatchColor = UiUtils.adjustBrightness(editorSelectionBackground, isDarkTheme ? 0.6f : 1.4f);\n \t\tdefaultColors.setColor(CodeAreaMatchColorType.MATCH_BACKGROUND, markAllHighlightColor);\n \t\tdefaultColors.setColor(CodeAreaMatchColorType.CURRENT_MATCH_BACKGROUND, currentMatchColor);\n \t\treturn defaultColors;\n \t}\n \n+\tpublic boolean isDataLoaded() {\n+\t\treturn !hexCodeArea.getContentData().isEmpty();\n+\t}\n+\n \tpublic void setData(byte[] data) {\n-\t\tif (hexCodeArea != null && data != null) {\n+\t\tif (data != null) {\n \t\t\thexCodeArea.setContentData(new ByteArrayEditableData(data));\n \t\t\tinspector.setBytes(data);\n \t\t}",
    "output": "Fix lazy load hex viewer content"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n@@ -102,7 +102,7 @@ public ResContainer decodeFiles() {\n \t\tResXmlGen resGen = new ResXmlGen(resStorage, vp, root.initManifestAttributes());\n \n \t\tICodeInfo content = XmlGenUtils.makeXmlDump(root.makeCodeWriter(), resStorage);\n-\t\tList<ResContainer> xmlFiles = resGen.makeResourcesXml(root.getArgs(), baseFileName);\n+\t\tList<ResContainer> xmlFiles = resGen.makeResourcesXml(root.getArgs());\n \t\treturn ResContainer.resourceTable(baseFileName, xmlFiles, content);\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n@@ -52,10 +52,6 @@ public ResXmlGen(ResourceStorage resStorage, ValuesParser vp, ManifestAttributes\n \t}\n \n \tpublic List<ResContainer> makeResourcesXml(JadxArgs args) {\n-\t\treturn makeResourcesXml(args, \"\");\n-\t}\n-\n-\tpublic List<ResContainer> makeResourcesXml(JadxArgs args, String baseFileName) {\n \t\tMap<String, ICodeWriter> contMap = new HashMap<>();\n \t\tfor (ResourceEntry ri : resStorage.getResources()) {\n \t\t\tif (SKIP_RES_TYPES.contains(ri.getTypeName())) {\n@@ -72,17 +68,14 @@ public List<ResContainer> makeResourcesXml(JadxArgs args, String baseFileName) {\n \t\t\t}\n \t\t\taddValue(cw, ri);\n \t\t}\n-\t\tString filePrefix = baseFileName.isEmpty() ? null : baseFileName + ':';\n+\n \t\tList<ResContainer> files = new ArrayList<>(contMap.size());\n \t\tfor (Map.Entry<String, ICodeWriter> entry : contMap.entrySet()) {\n \t\t\tString fileName = entry.getKey();\n \t\t\tICodeWriter content = entry.getValue();\n \t\t\tcontent.decIndent();\n \t\t\tcontent.startLine(\"</resources>\");\n \t\t\tICodeInfo codeInfo = content.finish();\n-\t\t\tif (filePrefix != null) {\n-\t\t\t\tfileName = filePrefix + fileName;\n-\t\t\t}\n \t\t\tfiles.add(ResContainer.textResource(fileName, codeInfo));\n \t\t}\n \t\tCollections.sort(files);\n\ndiff --git a/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java b/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java\n--- a/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java\n+++ b/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java\n@@ -75,7 +75,7 @@ public void testResourcesLoad() {\n \t\t\t\t\t.findFirst().orElseThrow();\n \t\t\tResContainer resContainer = arsc.loadContent();\n \t\t\tResContainer xmlRes = resContainer.getSubFiles().stream()\n-\t\t\t\t\t.filter(r -> r.getName().equals(\"resources.arsc:res/values/colors.xml\"))\n+\t\t\t\t\t.filter(r -> r.getName().equals(\"res/values/colors.xml\"))\n \t\t\t\t\t.findFirst().orElseThrow();\n \t\t\tassertThat(xmlRes.getText())\n \t\t\t\t\t.code()\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/res/ResTableHelper.java b/jadx-gui/src/main/java/jadx/gui/utils/res/ResTableHelper.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/res/ResTableHelper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/res/ResTableHelper.java\n@@ -21,15 +21,17 @@ public class ResTableHelper {\n \t * @return root nodes\n \t */\n \tpublic static List<JResource> buildTree(ResContainer resTable) {\n-\t\tResTableHelper resTableHelper = new ResTableHelper();\n+\t\tResTableHelper resTableHelper = new ResTableHelper(resTable.getFileName());\n \t\tresTableHelper.process(resTable);\n \t\treturn resTableHelper.roots;\n \t}\n \n \tprivate final List<JResource> roots = new ArrayList<>();\n \tprivate final Map<String, JResource> dirs = new HashMap<>();\n+\tprivate final String resNamePrefix;\n \n-\tprivate ResTableHelper() {\n+\tprivate ResTableHelper(String resTableFileName) {\n+\t\tthis.resNamePrefix = resTableFileName + \":/\";\n \t}\n \n \tprivate void process(ResContainer resTable) {\n@@ -52,7 +54,7 @@ private void loadSubNodes(ResContainer rc) {\n \t\t}\n \t\tICodeInfo code = rc.getText();\n \t\tResourceFileContent fileContent = new ResourceFileContent(name, ResourceType.XML, code);\n-\t\tJResource resFile = new JResource(fileContent, resName, name, JResource.JResType.FILE);\n+\t\tJResource resFile = new JResource(fileContent, resNamePrefix + resName, name, JResource.JResType.FILE);\n \t\taddResFile(dir, resFile);\n \n \t\tfor (ResContainer subFile : rc.getSubFiles()) {\n@@ -80,7 +82,7 @@ private void addResFile(@Nullable String dir, JResource resFile) {\n \t\t\tJResource curDir = dirs.get(path);\n \t\t\tif (curDir == null) {\n \t\t\t\tString dirName = last ? dir.substring(prevStart) : dir.substring(prevStart, splitPos);\n-\t\t\t\tcurDir = new JResource(null, dirName, JResource.JResType.DIR);\n+\t\t\t\tcurDir = new JResource(null, resNamePrefix + path, dirName, JResource.JResType.DIR);\n \t\t\t\tdirs.put(path, curDir);\n \t\t\t\tif (parentDir == null) {\n \t\t\t\t\troots.add(curDir);\n\ndiff --git a/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/parsers/ResTableProtoParser.java b/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/parsers/ResTableProtoParser.java\n--- a/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/parsers/ResTableProtoParser.java\n+++ b/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/parsers/ResTableProtoParser.java\n@@ -53,7 +53,7 @@ public synchronized ResContainer decodeFiles() {\n \t\tValuesParser vp = new ValuesParser(new BinaryXMLStrings(), resStorage.getResourcesNames());\n \t\tResXmlGen resGen = new ResXmlGen(resStorage, vp, root.initManifestAttributes());\n \t\tICodeInfo content = XmlGenUtils.makeXmlDump(root.makeCodeWriter(), resStorage);\n-\t\tList<ResContainer> xmlFiles = resGen.makeResourcesXml(root.getArgs(), baseFileName);\n+\t\tList<ResContainer> xmlFiles = resGen.makeResourcesXml(root.getArgs());\n \t\treturn ResContainer.resourceTable(baseFileName, xmlFiles, content);\n \t}",
    "output": "Add arsc file name prefix only in jadx-gui"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n--- a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n@@ -160,6 +160,7 @@ public IResTableParser decodeTable(ResourceFile resFile, InputStream is) throws\n \t\tif (parser == null) {\n \t\t\tthrow new JadxRuntimeException(\"Unknown type of resource file: \" + resFile.getOriginalName());\n \t\t}\n+\t\tparser.setBaseFileName(resFile.getDeobfName());\n \t\tparser.decode(is);\n \t\treturn parser;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/IResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/IResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/IResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/IResTableParser.java\n@@ -12,4 +12,8 @@ public interface IResTableParser {\n \tResourceStorage getResStorage();\n \n \tBinaryXMLStrings getStrings();\n+\n+\tdefault void setBaseFileName(String fileName) {\n+\t\t// optional\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n@@ -67,6 +67,7 @@ public BinaryXMLStrings getKeyStrings() {\n \n \tprivate ResourceStorage resStorage;\n \tprivate BinaryXMLStrings strings;\n+\tprivate String baseFileName = \"\";\n \n \tpublic ResTableBinaryParser(RootNode root) {\n \t\tthis(root, false);\n@@ -77,6 +78,11 @@ public ResTableBinaryParser(RootNode root, boolean useRawResNames) {\n \t\tthis.useRawResName = useRawResNames;\n \t}\n \n+\t@Override\n+\tpublic void setBaseFileName(String fileName) {\n+\t\tthis.baseFileName = fileName;\n+\t}\n+\n \t@Override\n \tpublic void decode(InputStream inputStream) throws IOException {\n \t\tlong start = System.currentTimeMillis();\n@@ -96,8 +102,8 @@ public ResContainer decodeFiles() {\n \t\tResXmlGen resGen = new ResXmlGen(resStorage, vp, root.initManifestAttributes());\n \n \t\tICodeInfo content = XmlGenUtils.makeXmlDump(root.makeCodeWriter(), resStorage);\n-\t\tList<ResContainer> xmlFiles = resGen.makeResourcesXml(root.getArgs());\n-\t\treturn ResContainer.resourceTable(\"res\", xmlFiles, content);\n+\t\tList<ResContainer> xmlFiles = resGen.makeResourcesXml(root.getArgs(), baseFileName);\n+\t\treturn ResContainer.resourceTable(baseFileName, xmlFiles, content);\n \t}\n \n \tvoid decodeTableChunk() throws IOException {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n@@ -52,6 +52,10 @@ public ResXmlGen(ResourceStorage resStorage, ValuesParser vp, ManifestAttributes\n \t}\n \n \tpublic List<ResContainer> makeResourcesXml(JadxArgs args) {\n+\t\treturn makeResourcesXml(args, \"\");\n+\t}\n+\n+\tpublic List<ResContainer> makeResourcesXml(JadxArgs args, String baseFileName) {\n \t\tMap<String, ICodeWriter> contMap = new HashMap<>();\n \t\tfor (ResourceEntry ri : resStorage.getResources()) {\n \t\t\tif (SKIP_RES_TYPES.contains(ri.getTypeName())) {\n@@ -68,14 +72,17 @@ public List<ResContainer> makeResourcesXml(JadxArgs args) {\n \t\t\t}\n \t\t\taddValue(cw, ri);\n \t\t}\n-\n+\t\tString filePrefix = baseFileName.isEmpty() ? null : baseFileName + ':';\n \t\tList<ResContainer> files = new ArrayList<>(contMap.size());\n \t\tfor (Map.Entry<String, ICodeWriter> entry : contMap.entrySet()) {\n \t\t\tString fileName = entry.getKey();\n \t\t\tICodeWriter content = entry.getValue();\n \t\t\tcontent.decIndent();\n \t\t\tcontent.startLine(\"</resources>\");\n \t\t\tICodeInfo codeInfo = content.finish();\n+\t\t\tif (filePrefix != null) {\n+\t\t\t\tfileName = filePrefix + fileName;\n+\t\t\t}\n \t\t\tfiles.add(ResContainer.textResource(fileName, codeInfo));\n \t\t}\n \t\tCollections.sort(files);\n\ndiff --git a/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java b/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java\n--- a/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java\n+++ b/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java\n@@ -75,7 +75,7 @@ public void testResourcesLoad() {\n \t\t\t\t\t.findFirst().orElseThrow();\n \t\t\tResContainer resContainer = arsc.loadContent();\n \t\t\tResContainer xmlRes = resContainer.getSubFiles().stream()\n-\t\t\t\t\t.filter(r -> r.getName().equals(\"res/values/colors.xml\"))\n+\t\t\t\t\t.filter(r -> r.getName().equals(\"resources.arsc:res/values/colors.xml\"))\n \t\t\t\t\t.findFirst().orElseThrow();\n \t\t\tassertThat(xmlRes.getText())\n \t\t\t\t\t.code()\n\ndiff --git a/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/parsers/ResTableProtoParser.java b/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/parsers/ResTableProtoParser.java\n--- a/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/parsers/ResTableProtoParser.java\n+++ b/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/parsers/ResTableProtoParser.java\n@@ -27,11 +27,17 @@\n public class ResTableProtoParser extends CommonProtoParser implements IResTableParser {\n \tprivate final RootNode root;\n \tprivate ResourceStorage resStorage;\n+\tprivate String baseFileName = \"\";\n \n \tpublic ResTableProtoParser(RootNode root) {\n \t\tthis.root = root;\n \t}\n \n+\t@Override\n+\tpublic void setBaseFileName(String fileName) {\n+\t\tthis.baseFileName = fileName;\n+\t}\n+\n \t@Override\n \tpublic void decode(InputStream inputStream) throws IOException {\n \t\tresStorage = new ResourceStorage(root.getArgs().getSecurity());\n@@ -47,8 +53,8 @@ public synchronized ResContainer decodeFiles() {\n \t\tValuesParser vp = new ValuesParser(new BinaryXMLStrings(), resStorage.getResourcesNames());\n \t\tResXmlGen resGen = new ResXmlGen(resStorage, vp, root.initManifestAttributes());\n \t\tICodeInfo content = XmlGenUtils.makeXmlDump(root.makeCodeWriter(), resStorage);\n-\t\tList<ResContainer> xmlFiles = resGen.makeResourcesXml(root.getArgs());\n-\t\treturn ResContainer.resourceTable(\"res\", xmlFiles, content);\n+\t\tList<ResContainer> xmlFiles = resGen.makeResourcesXml(root.getArgs(), baseFileName);\n+\t\treturn ResContainer.resourceTable(baseFileName, xmlFiles, content);\n \t}\n \n \tprivate void parse(Package p) {",
    "output": "Use resource table file name as prefix in sub files"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/plugins/files/TempFilesGetter.java b/jadx-core/src/main/java/jadx/core/plugins/files/TempFilesGetter.java\n--- a/jadx-core/src/main/java/jadx/core/plugins/files/TempFilesGetter.java\n+++ b/jadx-core/src/main/java/jadx/core/plugins/files/TempFilesGetter.java\n@@ -9,15 +9,20 @@ public class TempFilesGetter implements IJadxFilesGetter {\n \n \tpublic static final TempFilesGetter INSTANCE = new TempFilesGetter();\n \n-\tprivate final Path tempRootDir;\n+\tprivate static final class TempRootHolder {\n+\t\tpublic static final Path TEMP_ROOT_DIR;\n+\n+\t\tstatic {\n+\t\t\ttry {\n+\t\t\t\tTEMP_ROOT_DIR = Files.createTempDirectory(\"jadx-temp-\");\n+\t\t\t\tTEMP_ROOT_DIR.toFile().deleteOnExit();\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tthrow new RuntimeException(\"Failed to create temp directory\", e);\n+\t\t\t}\n+\t\t}\n+\t}\n \n \tprivate TempFilesGetter() {\n-\t\ttry {\n-\t\t\ttempRootDir = Files.createTempDirectory(\"jadx-temp-\");\n-\t\t\ttempRootDir.toFile().deleteOnExit();\n-\t\t} catch (Exception e) {\n-\t\t\tthrow new RuntimeException(\"Failed to create temp directory\", e);\n-\t\t}\n \t}\n \n \t@Override\n@@ -32,11 +37,11 @@ public Path getCacheDir() {\n \n \t@Override\n \tpublic Path getTempDir() {\n-\t\treturn tempRootDir;\n+\t\treturn makeSubDir(\"tmp\");\n \t}\n \n \tprivate Path makeSubDir(String subDir) {\n-\t\tPath dir = tempRootDir.resolve(subDir);\n+\t\tPath dir = TempRootHolder.TEMP_ROOT_DIR.resolve(subDir);\n \t\tFileUtils.makeDirs(dir);\n \t\treturn dir;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n@@ -150,7 +150,7 @@ public static CommonGuiPluginsContext initGuiPluginsContext(JadxDecompiler decom\n \t\tdecompiler.getPluginManager().registerAddPluginListener(pluginContext -> {\n \t\t\tAppContext appContext = new AppContext();\n \t\t\tappContext.setGuiContext(guiPluginsContext.buildForPlugin(pluginContext));\n-\t\t\tappContext.setFilesGetter(JadxFilesGetter.INSTANCE);\n+\t\t\tappContext.setFilesGetter(decompiler.getArgs().getFilesGetter());\n \t\t\tpluginContext.setAppContext(appContext);\n \t\t});\n \t\treturn guiPluginsContext;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/plugins/CollectPlugins.java b/jadx-gui/src/main/java/jadx/gui/utils/plugins/CollectPlugins.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/plugins/CollectPlugins.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/plugins/CollectPlugins.java\n@@ -34,12 +34,13 @@ public CloseablePlugins build() {\n \t\t// collect and init not loaded plugins in new temp context\n \t\tRunnable closeable = null;\n \t\tJadxArgs jadxArgs = mainWindow.getSettings().toJadxArgs();\n+\t\tjadxArgs.setFilesGetter(JadxFilesGetter.INSTANCE);\n \t\ttry (JadxDecompiler decompiler = new JadxDecompiler(jadxArgs)) {\n \t\t\tJadxPluginManager pluginManager = decompiler.getPluginManager();\n \t\t\tpluginManager.registerAddPluginListener(pluginContext -> {\n \t\t\t\tAppContext appContext = new AppContext();\n \t\t\t\tappContext.setGuiContext(null); // load temp plugins without UI context\n-\t\t\t\tappContext.setFilesGetter(JadxFilesGetter.INSTANCE);\n+\t\t\t\tappContext.setFilesGetter(jadxArgs.getFilesGetter());\n \t\t\t\tpluginContext.setAppContext(appContext);\n \t\t\t});\n \t\t\tpluginManager.load(new JadxExternalPluginsLoader());",
    "output": "Fix lazily create dirs in default file getter implementation"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MethodThrowsVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodThrowsVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MethodThrowsVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodThrowsVisitor.java\n@@ -110,27 +110,30 @@ private void mergeExceptions(Set<String> excSet) {\n \t\ttoRemove.forEach(excSet::remove);\n \t}\n \n-\tprivate void processInstructions(MethodNode mth) throws JadxException {\n+\tprivate void processInstructions(MethodNode mth) {\n \t\tif (mth.isNoCode() || mth.getBasicBlocks() == null) {\n \t\t\treturn;\n \t\t}\n-\n-\t\tblocks: for (final BlockNode block : mth.getBasicBlocks()) {\n-\t\t\t// Skip e.g. throw instructions of synchronized regions\n-\t\t\tboolean skipExceptions = block.contains(AFlag.REMOVE) || block.contains(AFlag.DONT_GENERATE);\n-\t\t\tSet<String> excludedExceptions = new HashSet<>();\n-\t\t\tCatchAttr catchAttr = block.get(AType.EXC_CATCH);\n-\t\t\tif (catchAttr != null) {\n-\t\t\t\tfor (ExceptionHandler handler : catchAttr.getHandlers()) {\n-\t\t\t\t\tif (handler.isCatchAll()) {\n-\t\t\t\t\t\tcontinue blocks;\n+\t\ttry {\n+\t\t\tblocks: for (final BlockNode block : mth.getBasicBlocks()) {\n+\t\t\t\t// Skip e.g. throw instructions of synchronized regions\n+\t\t\t\tboolean skipExceptions = block.contains(AFlag.REMOVE) || block.contains(AFlag.DONT_GENERATE);\n+\t\t\t\tSet<String> excludedExceptions = new HashSet<>();\n+\t\t\t\tCatchAttr catchAttr = block.get(AType.EXC_CATCH);\n+\t\t\t\tif (catchAttr != null) {\n+\t\t\t\t\tfor (ExceptionHandler handler : catchAttr.getHandlers()) {\n+\t\t\t\t\t\tif (handler.isCatchAll()) {\n+\t\t\t\t\t\t\tcontinue blocks;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\texcludedExceptions.add(handler.getArgType().toString());\n \t\t\t\t\t}\n-\t\t\t\t\texcludedExceptions.add(handler.getArgType().toString());\n+\t\t\t\t}\n+\t\t\t\tfor (final InsnNode insn : block.getInstructions()) {\n+\t\t\t\t\tcheckInsn(mth, insn, excludedExceptions, skipExceptions);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tfor (final InsnNode insn : block.getInstructions()) {\n-\t\t\t\tcheckInsn(mth, insn, excludedExceptions, skipExceptions);\n-\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tmth.addWarnComment(\"Failed to analyze thrown exceptions\", e);\n \t\t}\n \t}",
    "output": "Fix wrap `MethodThrowsVisitor` insns processing in try/catch"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java\n@@ -8,13 +8,15 @@\n import java.nio.file.Path;\n import java.util.Collections;\n import java.util.List;\n+import java.util.stream.Collectors;\n \n import javax.swing.JDialog;\n import javax.swing.JFileChooser;\n import javax.swing.JOptionPane;\n import javax.swing.UIManager;\n \n import jadx.api.plugins.utils.CommonFileUtils;\n+import jadx.core.utils.StringUtils;\n import jadx.core.utils.Utils;\n import jadx.core.utils.files.FileUtils;\n import jadx.gui.ui.MainWindow;\n@@ -42,8 +44,13 @@ public List<Path> showDialog() {\n \t\tsetAcceptAllFileFilterUsed(true);\n \t\tList<String> fileExtList = data.getFileExtList();\n \t\tif (Utils.notEmpty(fileExtList)) {\n-\t\t\tString description = NLS.str(\"file_dialog.supported_files\") + \": (\" + Utils.listToString(fileExtList) + ')';\n-\t\t\tsetFileFilter(new FileNameMultiExtensionFilter(description, fileExtList.toArray(new String[0])));\n+\t\t\tList<String> validFileExtList = fileExtList.stream()\n+\t\t\t\t\t.filter(StringUtils::notBlank)\n+\t\t\t\t\t.collect(Collectors.toList());\n+\t\t\tif (Utils.notEmpty(validFileExtList)) {\n+\t\t\t\tString description = NLS.str(\"file_dialog.supported_files\") + \": (\" + Utils.listToString(validFileExtList) + ')';\n+\t\t\t\tsetFileFilter(new FileNameMultiExtensionFilter(description, validFileExtList.toArray(new String[0])));\n+\t\t\t}\n \t\t}\n \t\tif (data.getSelectedFile() != null) {\n \t\t\tsetSelectedFile(data.getSelectedFile().toFile());\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/FileDialogWrapper.java b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/FileDialogWrapper.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/FileDialogWrapper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/FileDialogWrapper.java\n@@ -23,7 +23,7 @@ public class FileDialogWrapper {\n \n \tprivate boolean isOpen;\n \tprivate String title;\n-\tprivate List<String> fileExtList;\n+\tprivate List<String> fileExtList = new ArrayList<>();\n \tprivate int selectionMode = JFileChooser.FILES_AND_DIRECTORIES;\n \tprivate @Nullable Path currentDir;\n \tprivate @Nullable Path selectedFile;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/popupmenu/JResourcePopupMenu.java b/jadx-gui/src/main/java/jadx/gui/ui/popupmenu/JResourcePopupMenu.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/popupmenu/JResourcePopupMenu.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/popupmenu/JResourcePopupMenu.java\n@@ -67,7 +67,9 @@ private Path getSaveFilePath(JResource resource) {\n \t\tString extension = CommonFileUtils.getFileExtension(resource.getName());\n \n \t\tFileDialogWrapper fileDialog = new FileDialogWrapper(mainWindow, FileOpenMode.EXPORT_NODE);\n-\t\tfileDialog.setFileExtList(Collections.singletonList(extension));\n+\t\tif (extension != null) {\n+\t\t\tfileDialog.setFileExtList(Collections.singletonList(extension));\n+\t\t}\n \t\tPath currentDir = fileDialog.getCurrentDir();\n \t\tif (currentDir != null) {\n \t\t\tfileDialog.setSelectedFile(currentDir.resolve(resource.getName()));",
    "output": "Fix validate extensions list in file dialog"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/GotoAddressDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/GotoAddressDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/GotoAddressDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/GotoAddressDialog.java\n@@ -4,6 +4,7 @@\n \n import org.exbin.bined.swing.section.SectCodeArea;\n \n+import jadx.gui.utils.HexUtils;\n import jadx.gui.utils.NLS;\n \n public class GotoAddressDialog {\n@@ -14,6 +15,11 @@ public void showSetSelectionDialog(SectCodeArea codeArea) {\n \t\t\t\tJOptionPane.QUESTION_MESSAGE, null, null,\n \t\t\t\tLong.toHexString(codeArea.getDataPosition()));\n \t\tif (o != null) {\n+\t\t\tboolean isValidAddress = HexUtils.isValidHexString(toString());\n+\t\t\tif (!isValidAddress) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\n \t\t\tcodeArea.setActiveCaretPosition(Long.parseLong(o.toString(), 16));\n \t\t\tcodeArea.validateCaret();\n \t\t\tcodeArea.revealCursor();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n@@ -486,7 +486,7 @@ private SearchTask prepareSearch(String text) {\n \t\tString searchPackageText = packageField.getText();\n \t\tSearchSettings searchSettings = new SearchSettings(text, !ignoreCase, useRegex, searchPackageText);\n \t\tString error = searchSettings.prepare(mainWindow);\n-\t\tchangeSearchFieldStyle(!StringUtils.isEmpty(error));\n+\t\tUiUtils.highlightAsErrorField(searchField, !StringUtils.isEmpty(error));\n \t\tif (!StringUtils.isEmpty(error)) {\n \t\t\tresultsInfoLabel.setText(error);\n \t\t\treturn null;\n@@ -499,15 +499,6 @@ private SearchTask prepareSearch(String text) {\n \t\treturn newSearchTask;\n \t}\n \n-\tprivate void changeSearchFieldStyle(boolean isError) {\n-\t\tif (isError) {\n-\t\t\tsearchField.putClientProperty(\"JComponent.outline\", \"error\");\n-\t\t} else {\n-\t\t\tsearchField.putClientProperty(\"JComponent.outline\", \"\");\n-\t\t}\n-\t\tsearchField.repaint();\n-\t}\n-\n \tprivate boolean buildSearch(SearchTask newSearchTask, String text, SearchSettings searchSettings) {\n \t\tList<JavaClass> searchClasses;\n \t\tif (options.contains(ACTIVE_TAB)) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/hexviewer/HexSearchBar.java b/jadx-gui/src/main/java/jadx/gui/ui/hexviewer/HexSearchBar.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/hexviewer/HexSearchBar.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/hexviewer/HexSearchBar.java\n@@ -25,9 +25,11 @@\n import jadx.gui.ui.hexviewer.search.SearchCondition;\n import jadx.gui.ui.hexviewer.search.SearchParameters;\n import jadx.gui.ui.hexviewer.search.service.BinarySearchServiceImpl;\n+import jadx.gui.utils.HexUtils;\n import jadx.gui.utils.Icons;\n import jadx.gui.utils.NLS;\n import jadx.gui.utils.TextStandardActions;\n+import jadx.gui.utils.UiUtils;\n \n public class HexSearchBar extends JToolBar {\n \tprivate static final long serialVersionUID = 1836871286618633003L;\n@@ -237,15 +239,18 @@ private SearchCondition makeSearchCondition() {\n \t\t\t\tcondition.setSearchText(searchField.getText());\n \t\t\t} else {\n \t\t\t\tString hexBytes = searchField.getText();\n-\t\t\t\tif (isValidHexString(hexBytes)) {\n-\t\t\t\t\tcondition.setBinaryData(new ByteArrayEditableData(hexStringToByteArray(hexBytes)));\n+\t\t\t\tboolean isValidHexInput = HexUtils.isValidHexString(hexBytes);\n+\t\t\t\tUiUtils.highlightAsErrorField(searchField, !isValidHexInput);\n+\t\t\t\tif (isValidHexInput) {\n+\t\t\t\t\tcondition.setBinaryData(new ByteArrayEditableData(HexUtils.hexStringToByteArray(hexBytes)));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn condition;\n \t}\n \n \tpublic void updateFindStatus() {\n+\t\tUiUtils.highlightAsErrorField(searchField, false);\n \t\tSearchCondition condition = makeSearchCondition();\n \t\tif (condition.getSearchMode() == SearchCondition.SearchMode.TEXT) {\n \t\t\tfindTypeCB.setSelected(false);\n@@ -262,45 +267,6 @@ private void makeFindByHexButton() {\n \t\tfindTypeCB.setToolTipText(NLS.str(\"search.find_type_hex\"));\n \t}\n \n-\tprivate boolean isValidHexString(String hexString) {\n-\t\tString cleanS = hexString.replace(\" \", \"\");\n-\t\tint len = cleanS.length();\n-\t\ttry {\n-\t\t\tboolean isPair = len % 2 == 0;\n-\t\t\tif (isPair) {\n-\t\t\t\tLong.parseLong(cleanS, 16);\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t} catch (NumberFormatException ex) {\n-\t\t\t// ignore error\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\tpublic byte[] hexStringToByteArray(String hexString) {\n-\t\tif (hexString == null || hexString.isEmpty()) {\n-\t\t\treturn new byte[0];\n-\t\t}\n-\t\tString cleanS = hexString.replace(\" \", \"\");\n-\t\tint len = cleanS.length();\n-\t\tif (!isValidHexString(hexString)) {\n-\t\t\tthrow new IllegalArgumentException(\"Hex string must have even length. Input length: \" + len);\n-\t\t}\n-\n-\t\tbyte[] data = new byte[len / 2];\n-\t\tfor (int i = 0; i < len; i += 2) {\n-\t\t\tString byteString = cleanS.substring(i, i + 2);\n-\t\t\ttry {\n-\t\t\t\tint intValue = Integer.parseInt(byteString, 16);\n-\t\t\t\tdata[i / 2] = (byte) intValue;\n-\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\tthrow new IllegalArgumentException(\"Input string contains non-hex characters at index \" + i + \": \" + byteString, e);\n-\t\t\t}\n-\t\t}\n-\t\treturn data;\n-\t}\n-\n \tpublic interface Control {\n \n \t\tvoid prevMatch();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/HexUtils.java b/jadx-gui/src/main/java/jadx/gui/utils/HexUtils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/HexUtils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/HexUtils.java\n@@ -0,0 +1,43 @@\n+package jadx.gui.utils;\n+\n+public class HexUtils {\n+\n+\tpublic static boolean isValidHexString(String hexString) {\n+\t\tString cleanS = hexString.replace(\" \", \"\");\n+\t\tint len = cleanS.length();\n+\t\ttry {\n+\t\t\tboolean isPair = len % 2 == 0;\n+\t\t\tif (isPair) {\n+\t\t\t\tLong.parseLong(cleanS, 16);\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} catch (NumberFormatException ex) {\n+\t\t\t// ignore error\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic static byte[] hexStringToByteArray(String hexString) {\n+\t\tif (hexString == null || hexString.isEmpty()) {\n+\t\t\treturn new byte[0];\n+\t\t}\n+\t\tString cleanS = hexString.replace(\" \", \"\");\n+\t\tint len = cleanS.length();\n+\t\tif (!isValidHexString(hexString)) {\n+\t\t\tthrow new IllegalArgumentException(\"Hex string must have even length. Input length: \" + len);\n+\t\t}\n+\n+\t\tbyte[] data = new byte[len / 2];\n+\t\tfor (int i = 0; i < len; i += 2) {\n+\t\t\tString byteString = cleanS.substring(i, i + 2);\n+\t\t\ttry {\n+\t\t\t\tint intValue = Integer.parseInt(byteString, 16);\n+\t\t\t\tdata[i / 2] = (byte) intValue;\n+\t\t\t} catch (NumberFormatException e) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Input string contains non-hex characters at index \" + i + \": \" + byteString, e);\n+\t\t\t}\n+\t\t}\n+\t\treturn data;\n+\t}\n+}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n@@ -27,6 +27,7 @@\n import javax.swing.ImageIcon;\n import javax.swing.JComponent;\n import javax.swing.JOptionPane;\n+import javax.swing.JTextField;\n import javax.swing.JTree;\n import javax.swing.KeyStroke;\n import javax.swing.RootPaneContainer;\n@@ -514,4 +515,13 @@ public static Color adjustBrightness(Color color, float factor) {\n \t\thsb[2] = Math.min(1.0f, hsb[2] * factor); // Adjust brightness\n \t\treturn Color.getHSBColor(hsb[0], hsb[1], hsb[2]);\n \t}\n+\n+\tpublic static void highlightAsErrorField(final JTextField field, boolean isError) {\n+\t\tif (isError) {\n+\t\t\tfield.putClientProperty(\"JComponent.outline\", \"error\");\n+\t\t} else {\n+\t\t\tfield.putClientProperty(\"JComponent.outline\", \"\");\n+\t\t}\n+\t\tfield.repaint();\n+\t}\n }",
    "output": "Fix validate hex address in `GotoAddressDialog`"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/SynchronizedRegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/SynchronizedRegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/SynchronizedRegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/SynchronizedRegionMaker.java\n@@ -9,7 +9,9 @@\n import org.slf4j.LoggerFactory;\n \n import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.instructions.ConstClassNode;\n import jadx.core.dex.instructions.InsnType;\n+import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.nodes.BlockNode;\n import jadx.core.dex.nodes.IContainer;\n@@ -141,22 +143,42 @@ public static void removeSynchronized(MethodNode mth) {\n \t\tList<IContainer> subBlocks = startRegion.getSubBlocks();\n \t\tif (!subBlocks.isEmpty() && subBlocks.get(0) instanceof SynchronizedRegion) {\n \t\t\tSynchronizedRegion synchRegion = (SynchronizedRegion) subBlocks.get(0);\n-\t\t\tInsnNode synchInsn = synchRegion.getEnterInsn();\n-\t\t\tif (!synchInsn.getArg(0).isThis()) {\n-\t\t\t\tLOG.warn(\"In synchronized method {}, top region not synchronized by 'this' {}\", mth, synchInsn);\n-\t\t\t\treturn;\n+\t\t\tInsnNode syncInsn = synchRegion.getEnterInsn();\n+\t\t\tif (canRemoveSyncBlock(mth, syncInsn)) {\n+\t\t\t\t// replace synchronized block with an inner region\n+\t\t\t\tstartRegion.getSubBlocks().set(0, synchRegion.getRegion());\n+\t\t\t\t// remove 'monitor-enter' instruction\n+\t\t\t\tInsnRemover.remove(mth, syncInsn);\n+\t\t\t\t// remove 'monitor-exit' instruction\n+\t\t\t\tfor (InsnNode exit : synchRegion.getExitInsns()) {\n+\t\t\t\t\tInsnRemover.remove(mth, exit);\n+\t\t\t\t}\n+\t\t\t\t// run region cleaner again\n+\t\t\t\tCleanRegions.process(mth);\n+\t\t\t\t// assume that CodeShrinker will be run after this\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static boolean canRemoveSyncBlock(MethodNode mth, InsnNode synchInsn) {\n+\t\tInsnArg syncArg = synchInsn.getArg(0);\n+\t\tif (mth.getAccessFlags().isStatic()) {\n+\t\t\tif (syncArg.isInsnWrap() && syncArg.isConst()) {\n+\t\t\t\tInsnNode constInsn = syncArg.unwrap();\n+\t\t\t\tif (constInsn.getType() == InsnType.CONST_CLASS) {\n+\t\t\t\t\tArgType clsType = ((ConstClassNode) constInsn).getClsType();\n+\t\t\t\t\tif (clsType.equals(mth.getParentClass().getType())) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n-\t\t\t// replace synchronized block with inner region\n-\t\t\tstartRegion.getSubBlocks().set(0, synchRegion.getRegion());\n-\t\t\t// remove 'monitor-enter' instruction\n-\t\t\tInsnRemover.remove(mth, synchInsn);\n-\t\t\t// remove 'monitor-exit' instruction\n-\t\t\tfor (InsnNode exit : synchRegion.getExitInsns()) {\n-\t\t\t\tInsnRemover.remove(mth, exit);\n+\t\t\tmth.addWarnComment(\"In static synchronized method top region not synchronized by class const: \" + syncArg);\n+\t\t} else {\n+\t\t\tif (syncArg.isThis()) {\n+\t\t\t\treturn true;\n \t\t\t}\n-\t\t\t// run region cleaner again\n-\t\t\tCleanRegions.process(mth);\n-\t\t\t// assume that CodeShrinker will be run after this\n+\t\t\tmth.addWarnComment(\"In synchronized method top region not synchronized by 'this': \" + syncArg);\n \t\t}\n+\t\treturn false;\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized2.java b/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized2.java\n@@ -2,35 +2,25 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.tests.api.IntegrationTest;\n-import jadx.tests.api.utils.assertj.JadxAssertions;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n \n public class TestSynchronized2 extends IntegrationTest {\n \n+\t@SuppressWarnings(\"unused\")\n \tpublic static class TestCls {\n-\t\t@SuppressWarnings(\"unused\")\n \t\tprivate static synchronized boolean test(Object obj) {\n \t\t\treturn obj.toString() != null;\n \t\t}\n \t}\n \n \t@Test\n \tpublic void test() {\n-\t\tJadxAssertions.assertThat(getClassNode(TestCls.class))\n+\t\tassertThat(getClassNode(TestCls.class))\n \t\t\t\t.code()\n \t\t\t\t.contains(\"private static synchronized boolean test(Object obj) {\")\n+\t\t\t\t.doesNotContain(\"synchronized (\")\n \t\t\t\t.contains(\"obj.toString() != null;\");\n \t}\n-\n-\t@Test\n-\t@NotYetImplemented\n-\tpublic void test2() {\n-\t\tuseDexInput(); // java bytecode don't add exception handlers\n-\n-\t\tJadxAssertions.assertThat(getClassNode(TestCls.class))\n-\t\t\t\t.code()\n-\t\t\t\t.contains(\"return obj.toString() != null;\")\n-\t\t\t\t.doesNotContain(\"synchronized (\");\n-\t}\n }",
    "output": "Fix for static synchronized methods remove top `synchronized` block"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/pkgs/JRenamePackage.java b/jadx-gui/src/main/java/jadx/gui/utils/pkgs/JRenamePackage.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/pkgs/JRenamePackage.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/pkgs/JRenamePackage.java\n@@ -102,7 +102,7 @@ public void addUpdateNodes(List<JavaNode> toUpdate) {\n \t@Override\n \tpublic void reload(MainWindow mainWindow) {\n \t\tmainWindow.rebuildPackagesTree();\n-\t\tmainWindow.reloadTree();\n+\t\tmainWindow.reloadTreePreservingState();\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/pkgs/PackageHelper.java b/jadx-gui/src/main/java/jadx/gui/utils/pkgs/PackageHelper.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/pkgs/PackageHelper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/pkgs/PackageHelper.java\n@@ -58,13 +58,14 @@ public List<JRenamePackage> getRenameNodes(JPackage pkg) {\n \t\tSet<String> added = new HashSet<>();\n \t\tdo {\n \t\t\tJPackage jPkg = pkgInfoMap.get(pkgInfo);\n-\t\t\tif (jPkg != null) {\n+\t\t\tif (jPkg != null && !jPkg.isSynthetic()) {\n \t\t\t\tJavaPackage javaPkg = jPkg.getPkg();\n-\t\t\t\tString fullName = javaPkg.isDefault() ? JPackage.PACKAGE_DEFAULT_HTML_STR : javaPkg.getFullName();\n-\t\t\t\tString name = jPkg.isSynthetic() || javaPkg.isParentRenamed() ? fullName : javaPkg.getName();\n-\t\t\t\tJRenamePackage renamePkg = new JRenamePackage(javaPkg, javaPkg.getRawFullName(), fullName, name);\n-\t\t\t\tif (added.add(fullName)) {\n-\t\t\t\t\tlist.add(renamePkg);\n+\t\t\t\tif (!javaPkg.isDefault()) {\n+\t\t\t\t\tJRenamePackage renamePkg = new JRenamePackage(javaPkg,\n+\t\t\t\t\t\t\tjavaPkg.getRawFullName(), javaPkg.getFullName(), javaPkg.getName());\n+\t\t\t\t\tif (added.add(javaPkg.getFullName())) {\n+\t\t\t\t\t\tlist.add(renamePkg);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tpkgInfo = pkgInfo.getParentPkg();",
    "output": "Fix rename package behaviors"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -314,7 +314,7 @@ private void parseAttribute(int i, boolean newLine, Set<String> attrCache, int a\n \t\t\twriter.add(' ');\n \t\t}\n \t\twriter.add(attrFullName).add(\"=\\\"\");\n-\t\tString decodedAttr = manifestAttributes.decode(attrName, attrValData);\n+\t\tString decodedAttr = manifestAttributes.decode(attrFullName, attrValData);\n \t\tif (decodedAttr != null) {\n \t\t\tmemorizePackageName(attrName, decodedAttr);\n \t\t\tif (isDeobfCandidateAttr(attrFullName)) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n@@ -51,13 +51,23 @@ public Map<Long, String> getValues() {\n \t\t\treturn values;\n \t\t}\n \n+\t\tpublic void addValue(long key, String value) {\n+\t\t\tvalues.put(key, value);\n+\t\t}\n+\n \t\t@Override\n \t\tpublic String toString() {\n \t\t\treturn \"[\" + type + \", \" + values + ']';\n \t\t}\n \t}\n \n \tprivate final IJadxSecurity security;\n+\n+\t/**\n+\t * Map containing default Android resource attribute definitions.\n+\t * Keys are Android attribute names (e.g., \"android:layout_width\"),\n+\t * and values are their corresponding {@link MAttr} objects.\n+\t */\n \tprivate final Map<String, MAttr> attrMap = new HashMap<>();\n \tprivate final Map<String, MAttr> appAttrMap = new HashMap<>();\n \n@@ -135,7 +145,7 @@ private void parseValues(String name, NodeList nodeList) {\n \t\t\t\t\tif (attr == null) {\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n-\t\t\t\t\tattrMap.put(name, attr);\n+\t\t\t\t\tattrMap.put(\"android:\" + name, attr);\n \t\t\t\t}\n \t\t\t\tNamedNodeMap attributes = tempNode.getAttributes();\n \t\t\t\tNode nameNode = attributes.getNamedItem(\"name\");\n@@ -151,7 +161,7 @@ private void parseValues(String name, NodeList nodeList) {\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tkey = Long.parseLong(nodeValue);\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tattr.getValues().put(key, nameNode.getNodeValue());\n+\t\t\t\t\t\t\tattr.addValue(key, nameNode.getNodeValue());\n \t\t\t\t\t\t} catch (NumberFormatException e) {\n \t\t\t\t\t\t\tLOG.debug(\"Failed parse manifest number\", e);\n \t\t\t\t\t\t}\n@@ -164,19 +174,24 @@ private void parseValues(String name, NodeList nodeList) {\n \tpublic String decode(String attrName, long value) {\n \t\tMAttr attr = attrMap.get(attrName);\n \t\tif (attr == null) {\n+\t\t\tif (attrName.contains(\":\")) {\n+\t\t\t\tattrName = attrName.split(\":\", 2)[1];\n+\t\t\t}\n \t\t\tattr = appAttrMap.get(attrName);\n \t\t\tif (attr == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t}\n+\n+\t\tMap<Long, String> attrValuesMap = attr.getValues();\n \t\tif (attr.getType() == MAttrType.ENUM) {\n-\t\t\treturn attr.getValues().get(value);\n+\t\t\treturn attrValuesMap.get(value);\n \t\t} else if (attr.getType() == MAttrType.FLAG) {\n \t\t\tList<String> flagList = new ArrayList<>();\n-\t\t\tList<Long> attrKeys = new ArrayList<>(attr.getValues().keySet());\n+\t\t\tList<Long> attrKeys = new ArrayList<>(attrValuesMap.keySet());\n \t\t\tattrKeys.sort((a, b) -> Long.compare(b, a)); // sort descending\n \t\t\tfor (Long key : attrKeys) {\n-\t\t\t\tString attrValue = attr.getValues().get(key);\n+\t\t\t\tString attrValue = attrValuesMap.get(key);\n \t\t\t\tif (value == key) {\n \t\t\t\t\tflagList.add(attrValue);\n \t\t\t\t\tbreak;\n@@ -217,7 +232,7 @@ public void updateAttributes(IResTableParser parser) {\n \t\t\t\tfor (int i = 1; i < ri.getNamedValues().size(); i++) {\n \t\t\t\t\tRawNamedValue rv = ri.getNamedValues().get(i);\n \t\t\t\t\tString value = vp.decodeNameRef(rv.getNameRef());\n-\t\t\t\t\tattr.getValues().put((long) rv.getRawValue().getData(), value.startsWith(\"id.\") ? value.substring(3) : value);\n+\t\t\t\t\tattr.addValue(rv.getRawValue().getData(), value.startsWith(\"id.\") ? value.substring(3) : value);\n \t\t\t\t}\n \t\t\t\tappAttrMap.put(ri.getKeyName(), attr);\n \t\t\t}",
    "output": "Fix decode xml attributes value * fix(res): now when decoding attributes used namespace (fix #1675) * fix: code formatted * fix: some code improved on ManifestAttributes class"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n@@ -200,6 +200,7 @@ private ICodeInfo loadContent() {\n \t\t\tList<JResource> nodes = ResTableHelper.buildTree(rc);\n \t\t\tsortResNodes(nodes);\n \t\t\tsubNodes = nodes;\n+\t\t\tUiUtils.uiRun(this::update);\n \t\t\treturn codeInfo;\n \t\t}\n \t\t// single node",
    "output": "Fix update resource.arsc nodes after opened tab with resource ids"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n@@ -254,8 +254,7 @@ public void addUpdateNodes(List<JavaNode> toUpdate) {\n \t@Override\n \tpublic void reload(MainWindow mainWindow) {\n \t\t// TODO: rebuild packages only if class package has been changed\n-\t\tmainWindow.rebuildPackagesTree();\n-\t\tmainWindow.reloadTree();\n+\t\tmainWindow.reloadTreePreservingState();\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JField.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JField.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JField.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JField.java\n@@ -104,7 +104,7 @@ public void addUpdateNodes(List<JavaNode> toUpdate) {\n \n \t@Override\n \tpublic void reload(MainWindow mainWindow) {\n-\t\tmainWindow.reloadTree();\n+\t\tmainWindow.reloadTreePreservingState();\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java\n@@ -202,7 +202,7 @@ public void addUpdateNodes(List<JavaNode> toUpdate) {\n \n \t@Override\n \tpublic void reload(MainWindow mainWindow) {\n-\t\tmainWindow.reloadTree();\n+\t\tmainWindow.reloadTreePreservingState();\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -852,6 +852,14 @@ public void rebuildPackagesTree() {\n \t\ttreeRoot.update();\n \t}\n \n+\t// simple save and restore tree state after renaming\n+\t// maybe need improve for find and update only changed node\n+\tpublic void reloadTreePreservingState() {\n+\t\tList<String> treePath = treeExpansionService.save();\n+\t\treloadTree();\n+\t\ttreeExpansionService.load(treePath);\n+\t}\n+\n \tprivate void toggleFlattenPackage() {\n \t\tsetFlattenPackage(!isFlattenPackage);\n \t}",
    "output": "Fix restore tree state after renaming"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/TabStateViewAdapter.java b/jadx-gui/src/main/java/jadx/gui/settings/TabStateViewAdapter.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/TabStateViewAdapter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/TabStateViewAdapter.java\n@@ -32,6 +32,7 @@ public static TabViewState build(EditorViewState viewState) {\n \t\ttvs.setPinned(viewState.isPinned());\n \t\ttvs.setBookmarked(viewState.isBookmarked());\n \t\ttvs.setHidden(viewState.isHidden());\n+\t\ttvs.setPreviewTab(viewState.isPreviewTab());\n \t\treturn tvs;\n \t}\n \n@@ -47,6 +48,7 @@ public static EditorViewState load(MainWindow mw, TabViewState tvs) {\n \t\t\tviewState.setPinned(tvs.isPinned());\n \t\t\tviewState.setBookmarked(tvs.isBookmarked());\n \t\t\tviewState.setHidden(tvs.isHidden());\n+\t\t\tviewState.setPreviewTab(tvs.isPreviewTab());\n \t\t\treturn viewState;\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Failed to load tab state: \" + tvs, e);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/data/TabViewState.java b/jadx-gui/src/main/java/jadx/gui/settings/data/TabViewState.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/data/TabViewState.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/data/TabViewState.java\n@@ -10,6 +10,7 @@ public class TabViewState {\n \tboolean pinned;\n \tboolean bookmarked;\n \tboolean hidden;\n+\tboolean previewTab;\n \n \tpublic String getType() {\n \t\treturn type;\n@@ -82,4 +83,12 @@ public boolean isHidden() {\n \tpublic void setHidden(boolean hidden) {\n \t\tthis.hidden = hidden;\n \t}\n+\n+\tpublic boolean isPreviewTab() {\n+\t\treturn previewTab;\n+\t}\n+\n+\tpublic void setPreviewTab(boolean previewTab) {\n+\t\tthis.previewTab = previewTab;\n+\t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -115,11 +115,15 @@\n import jadx.gui.settings.ui.plugins.PluginSettings;\n import jadx.gui.tree.TreeExpansionService;\n import jadx.gui.treemodel.ApkSignature;\n+import jadx.gui.treemodel.JInputFiles;\n+import jadx.gui.treemodel.JInputScripts;\n+import jadx.gui.treemodel.JInputs;\n import jadx.gui.treemodel.JLoadableNode;\n import jadx.gui.treemodel.JNode;\n import jadx.gui.treemodel.JPackage;\n import jadx.gui.treemodel.JResource;\n import jadx.gui.treemodel.JRoot;\n+import jadx.gui.treemodel.JSources;\n import jadx.gui.ui.action.ActionModel;\n import jadx.gui.ui.action.JadxGuiAction;\n import jadx.gui.ui.codearea.AbstractCodeArea;\n@@ -882,8 +886,15 @@ private boolean nodeClickAction(@Nullable Object obj) {\n \t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t} else if (obj instanceof JNode) {\n-\t\t\t\ttabsController.codeJump((JNode) obj, true);\n-\t\t\t\treturn true;\n+\t\t\t\tJNode treeNode = (JNode) obj;\n+\t\t\t\tif (!(treeNode instanceof JPackage)\n+\t\t\t\t\t\t&& !(treeNode instanceof JSources)\n+\t\t\t\t\t\t&& !(treeNode instanceof JInputs)\n+\t\t\t\t\t\t&& !(treeNode instanceof JInputFiles)\n+\t\t\t\t\t\t&& !(treeNode instanceof JInputScripts)) {\n+\t\t\t\t\ttabsController.codeJump(treeNode, true);\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n \t\t\t}\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Content loading error\", e);\n@@ -1062,11 +1073,10 @@ private void initMenuAndToolbar() {\n \t\tflatPkgMenuItem = new JCheckBoxMenuItem(NLS.str(\"menu.flatten\"), Icons.FLAT_PKG);\n \t\tflatPkgMenuItem.setState(isFlattenPackage);\n \n-\t\tJCheckBoxMenuItem enablePreviewTabMenuItem = new JCheckBoxMenuItem(NLS.str(\"menu.enable_preview_tab\"));\n-\t\tenablePreviewTabMenuItem.setState(settings.isEnablePreviewTab());\n-\t\tenablePreviewTabMenuItem.addActionListener(event -> {\n+\t\tJadxGuiAction enablePreviewTabAction = new JadxGuiAction(ActionModel.PREVIEW_TAB, () -> {\n \t\t\tsettings.setEnablePreviewTab(!settings.isEnablePreviewTab());\n \t\t});\n+\t\tenablePreviewTabAction.setSelected(settings.isEnablePreviewTab());\n \n \t\tJCheckBoxMenuItem heapUsageBarMenuItem = new JCheckBoxMenuItem(NLS.str(\"menu.heapUsageBar\"));\n \t\theapUsageBarMenuItem.setState(settings.isShowHeapUsageBar());\n@@ -1159,7 +1169,7 @@ private void initMenuAndToolbar() {\n \t\tview.add(quickTabsAction.makeCheckBoxMenuItem());\n \t\tview.add(flatPkgMenuItem);\n \t\tview.addSeparator();\n-\t\tview.add(enablePreviewTabMenuItem);\n+\t\tview.add(enablePreviewTabAction.makeCheckBoxMenuItem());\n \t\tview.add(syncAction);\n \t\tview.add(alwaysSelectOpened);\n \t\tview.addSeparator();\n@@ -1241,6 +1251,7 @@ public void actionPerformed(ActionEvent e) {\n \t\ttoolbar.addSeparator();\n \t\ttoolbar.add(syncAction);\n \t\ttoolbar.add(flatPkgButton);\n+\t\ttoolbar.add(enablePreviewTabAction.makeToggleButton());\n \t\ttoolbar.add(quickTabsAction.makeToggleButton());\n \t\ttoolbar.addSeparator();\n \t\ttoolbar.add(textSearchAction);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/action/ActionModel.java b/jadx-gui/src/main/java/jadx/gui/ui/action/ActionModel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/action/ActionModel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/action/ActionModel.java\n@@ -57,6 +57,8 @@ public enum ActionModel {\n \t\t\tShortcut.keyboard(KeyEvent.VK_A, UiUtils.ctrlButton() | KeyEvent.SHIFT_DOWN_MASK)),\n \tGO_TO_ANDROID_MANIFEST(MENU_TOOLBAR, \"menu.go_to_android_manifest\", \"menu.go_to_android_manifest\", \"ui/androidManifest\",\n \t\t\tShortcut.none()),\n+\tPREVIEW_TAB(MENU_TOOLBAR, \"menu.enable_preview_tab\", \"menu.enable_preview_tab\", \"ui/editorPreview\",\n+\t\t\tShortcut.none()),\n \tDECOMPILE_ALL(MENU_TOOLBAR, \"menu.decompile_all\", \"menu.decompile_all\", \"ui/runAll\",\n \t\t\tShortcut.none()),\n \tRESET_CACHE(MENU_TOOLBAR, \"menu.reset_cache\", \"menu.reset_cache\", \"ui/reset\",\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/EditorViewState.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/EditorViewState.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/EditorViewState.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/EditorViewState.java\n@@ -17,6 +17,7 @@ public class EditorViewState {\n \tprivate boolean pinned;\n \tprivate boolean bookmarked;\n \tprivate boolean hidden;\n+\tprivate boolean previewTab;\n \n \tpublic EditorViewState(JNode node) {\n \t\tthis(node, \"\", 0, EditorViewState.ZERO);\n@@ -85,6 +86,14 @@ public boolean isHidden() {\n \t\treturn hidden;\n \t}\n \n+\tpublic boolean isPreviewTab() {\n+\t\treturn previewTab;\n+\t}\n+\n+\tpublic void setPreviewTab(boolean previewTab) {\n+\t\tthis.previewTab = previewTab;\n+\t}\n+\n \tpublic void setHidden(boolean hidden) {\n \t\tthis.hidden = hidden;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n@@ -83,7 +83,7 @@ public TabBlueprint openTab(JNode node, boolean hidden, boolean preview) {\n \tpublic TabBlueprint previewTab(JNode node) {\n \t\tTabBlueprint blueprint = getPreviewTab();\n \t\tif (blueprint != null) {\n-\t\t\tcloseTabForce(blueprint);\n+\t\t\tcloseTab(blueprint.getNode());\n \t\t}\n \n \t\tblueprint = openTab(node, false, true);\n@@ -244,6 +244,7 @@ public void setTabPinned(JNode node, boolean pinned) {\n \n \tpublic void setTabPinnedInternal(TabBlueprint blueprint, boolean pinned) {\n \t\tif (blueprint.isPinned() != pinned) {\n+\t\t\tblueprint.setPreviewTab(false);\n \t\t\tblueprint.setPinned(pinned);\n \t\t\tlisteners.forEach(l -> l.onTabPinChange(blueprint));\n \t\t}\n@@ -256,6 +257,7 @@ public void setTabBookmarked(JNode node, boolean bookmarked) {\n \n \tprivate void setTabBookmarkedInternal(TabBlueprint blueprint, boolean bookmarked) {\n \t\tif (blueprint.isBookmarked() != bookmarked) {\n+\t\t\tblueprint.setPreviewTab(false);\n \t\t\tblueprint.setBookmarked(bookmarked);\n \t\t\tlisteners.forEach(l -> l.onTabBookmarkChange(blueprint));\n \t\t\tremoveTabIfNotReferenced(blueprint);\n@@ -269,6 +271,7 @@ public void setTabHidden(JNode node, boolean hidden) {\n \n \tprivate void setTabHiddenInternal(TabBlueprint blueprint, boolean hidden) {\n \t\tif (blueprint != null && blueprint.isHidden() != hidden) {\n+\t\t\tblueprint.setPreviewTab(false);\n \t\t\tblueprint.setHidden(hidden);\n \t\t\tlisteners.forEach(l -> l.onTabVisibilityChange(blueprint));\n \t\t}\n@@ -338,7 +341,7 @@ public TabBlueprint getPreviewTab() {\n \n \tpublic void restoreEditorViewState(EditorViewState viewState) {\n \t\tJNode node = viewState.getNode();\n-\t\tTabBlueprint blueprint = openTab(node, viewState.isHidden());\n+\t\tTabBlueprint blueprint = openTab(node, viewState.isHidden(), viewState.isPreviewTab());\n \t\tsetTabPinnedInternal(blueprint, viewState.isPinned());\n \t\tsetTabBookmarkedInternal(blueprint, viewState.isBookmarked());\n \t\tlisteners.forEach(l -> l.onTabRestore(blueprint, viewState));\n@@ -373,6 +376,7 @@ public EditorViewState getEditorViewState(TabBlueprint blueprint) {\n \t\tviewState.setPinned(blueprint.isPinned());\n \t\tviewState.setBookmarked(blueprint.isBookmarked());\n \t\tviewState.setHidden(blueprint.isHidden());\n+\t\tviewState.setPreviewTab(blueprint.isPreviewTab());\n \t\treturn viewState;\n \t}\n }",
    "output": "Fix improved preview tab behaviors"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -624,6 +624,7 @@ private void checkLoadedStatus() {\n \t\t\t\tshowLogViewer(LogOptions.allWithLevel(Level.ERROR));\n \t\t\t}\n \t\t} else {\n+\t\t\tshowLogViewer(LogOptions.allWithLevel(Level.WARN));\n \t\t\tUiUtils.showMessageBox(this, NLS.str(\"message.no_classes\"));\n \t\t}\n \t}\n\ndiff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java\n@@ -6,6 +6,7 @@\n import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.Collection;\n@@ -18,6 +19,7 @@\n import org.slf4j.LoggerFactory;\n \n import jadx.api.plugins.utils.CommonFileUtils;\n+import jadx.core.utils.files.FileUtils;\n import jadx.plugins.input.dex.sections.DexConsts;\n import jadx.plugins.input.dex.sections.DexHeaderV41;\n import jadx.plugins.input.dex.utils.DexCheckSum;\n@@ -69,11 +71,17 @@ private List<DexReader> load(@Nullable File file, InputStream inputStream, Strin\n \t\t\tif (in.read(magic) != magic.length) {\n \t\t\t\treturn Collections.emptyList();\n \t\t\t}\n-\t\t\tif (isStartWithBytes(magic, DexConsts.DEX_FILE_MAGIC) || fileName.endsWith(\".dex\")) {\n+\t\t\tif (isStartWithBytes(magic, DexConsts.DEX_FILE_MAGIC)) {\n \t\t\t\tin.reset();\n \t\t\t\tbyte[] content = readAllBytes(in);\n \t\t\t\treturn loadDexReaders(fileName, content);\n \t\t\t}\n+\t\t\tif (fileName.endsWith(\".dex\")) {\n+\t\t\t\t// report invalid magic in '.dex' file\n+\t\t\t\tString hex = FileUtils.bytesToHex(magic);\n+\t\t\t\tString str = new String(magic, StandardCharsets.US_ASCII);\n+\t\t\t\tLOG.warn(\"Invalid DEX magic: 0x{}(\\\"{}\\\") in file: {}\", hex, str, fileName);\n+\t\t\t}\n \t\t\tif (file != null) {\n \t\t\t\t// allow only top level zip files\n \t\t\t\tif (isStartWithBytes(magic, DexConsts.ZIP_FILE_MAGIC) || CommonFileUtils.isZipFileExt(fileName)) {",
    "output": "Fix check and report invalid magic in '.dex' files"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/theme/DynamicCodeAreaTheme.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/theme/DynamicCodeAreaTheme.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/theme/DynamicCodeAreaTheme.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/theme/DynamicCodeAreaTheme.java\n@@ -66,6 +66,7 @@ public void apply(RSyntaxTextArea textArea) {\n \t\t\tscheme.getStyle(Token.RESERVED_WORD).foreground = Color.decode(\"#569CD6\");\n \t\t\tscheme.getStyle(Token.RESERVED_WORD_2).foreground = dataTypeColor;\n \t\t\tscheme.getStyle(Token.FUNCTION).foreground = Color.decode(\"#DCDCAA\");\n+\t\t\tscheme.getStyle(Token.ANNOTATION).foreground = Color.decode(\"#B3AE60\");\n \t\t\tscheme.getStyle(Token.LITERAL_NUMBER_DECIMAL_INT).foreground = Color.decode(\"#D7BA7D\");\n \t\t\tscheme.getStyle(Token.LITERAL_NUMBER_FLOAT).foreground = Color.decode(\"#D7BA7D\");\n \t\t\tscheme.getStyle(Token.LITERAL_NUMBER_HEXADECIMAL).foreground = Color.decode(\"#D7BA7D\");",
    "output": "Add missing annotations color for dynamic theme"
  },
  {
    "input": "diff --git a/jadx-cli/src/test/java/jadx/cli/BaseCliIntegrationTest.java b/jadx-cli/src/test/java/jadx/cli/BaseCliIntegrationTest.java\n--- a/jadx-cli/src/test/java/jadx/cli/BaseCliIntegrationTest.java\n+++ b/jadx-cli/src/test/java/jadx/cli/BaseCliIntegrationTest.java\n@@ -95,6 +95,10 @@ static void printFiles(List<Path> files) {\n \t\tLOG.info(\"\");\n \t}\n \n+\tString pathToUniformString(Path path) {\n+\t\treturn path.toString().replace('\\\\', '/');\n+\t}\n+\n \tPath printFileContent(Path file) {\n \t\ttry {\n \t\t\tString content = Files.readString(outputDir.resolve(file));\n\ndiff --git a/jadx-cli/src/test/java/jadx/cli/TestExport.java b/jadx-cli/src/test/java/jadx/cli/TestExport.java\n--- a/jadx-cli/src/test/java/jadx/cli/TestExport.java\n+++ b/jadx-cli/src/test/java/jadx/cli/TestExport.java\n@@ -1,7 +1,5 @@\n package jadx.cli;\n \n-import java.nio.file.Path;\n-\n import org.assertj.core.api.Condition;\n import org.junit.jupiter.api.Test;\n \n@@ -14,7 +12,7 @@ public void testBasicExport() throws Exception {\n \t\tint result = execJadxCli(\"samples/small.apk\");\n \t\tassertThat(result).isEqualTo(0);\n \t\tassertThat(collectAllFilesInDir(outputDir))\n-\t\t\t\t.map(Path::toString)\n+\t\t\t\t.map(this::pathToUniformString)\n \t\t\t\t.haveExactly(2, new Condition<>(f -> f.startsWith(\"sources/\") && f.endsWith(\".java\"), \"sources\"))\n \t\t\t\t.haveExactly(10, new Condition<>(f -> f.startsWith(\"resources/\"), \"resources\"))\n \t\t\t\t.haveExactly(1, new Condition<>(f -> f.equals(\"resources/AndroidManifest.xml\"), \"manifest\"))\n@@ -27,7 +25,7 @@ public void testGradleExportApk() throws Exception {\n \t\tassertThat(result).isEqualTo(0);\n \t\tassertThat(collectAllFilesInDir(outputDir))\n \t\t\t\t.describedAs(\"check output files\")\n-\t\t\t\t.map(Path::toString)\n+\t\t\t\t.map(this::pathToUniformString)\n \t\t\t\t.haveExactly(2, new Condition<>(f -> f.endsWith(\".java\"), \"java classes\"))\n \t\t\t\t.haveExactly(0, new Condition<>(f -> f.endsWith(\"classes.dex\"), \"dex files\"))\n \t\t\t\t.hasSize(15);\n@@ -40,7 +38,7 @@ public void testGradleExportAAR() throws Exception {\n \t\tassertThat(collectAllFilesInDir(outputDir))\n \t\t\t\t.describedAs(\"check output files\")\n \t\t\t\t.map(this::printFileContent)\n-\t\t\t\t.map(Path::toString)\n+\t\t\t\t.map(this::pathToUniformString)\n \t\t\t\t.haveExactly(1, new Condition<>(f -> f.startsWith(\"lib/src/main/java/\") && f.endsWith(\".java\"), \"java\"))\n \t\t\t\t.haveExactly(0, new Condition<>(f -> f.endsWith(\".jar\"), \"jar files\"))\n \t\t\t\t.hasSize(8);\n@@ -53,7 +51,7 @@ public void testGradleExportSimpleJava() throws Exception {\n \t\tassertThat(collectAllFilesInDir(outputDir))\n \t\t\t\t.describedAs(\"check output files\")\n \t\t\t\t.map(this::printFileContent)\n-\t\t\t\t.map(Path::toString)\n+\t\t\t\t.map(this::pathToUniformString)\n \t\t\t\t.haveExactly(1, new Condition<>(f -> f.endsWith(\".java\") && f.startsWith(\"app/src/main/java/\"), \"java\"))\n \t\t\t\t.haveExactly(0, new Condition<>(f -> f.endsWith(\".class\"), \"class files\"))\n \t\t\t\t.haveExactly(1, new Condition<>(f -> f.equals(\"settings.gradle.kts\"), \"settings\"))\n@@ -69,7 +67,7 @@ public void testGradleExportInvalidType() throws Exception {\n \t\tassertThat(collectAllFilesInDir(outputDir))\n \t\t\t\t.describedAs(\"check output files\")\n \t\t\t\t.map(this::printFileContent)\n-\t\t\t\t.map(Path::toString)\n+\t\t\t\t.map(this::pathToUniformString)\n \t\t\t\t.haveExactly(1, new Condition<>(f -> f.endsWith(\".java\") && f.startsWith(\"app/src/main/java/\"), \"java\"))\n \t\t\t\t.haveExactly(1, new Condition<>(f -> f.equals(\"settings.gradle\"), \"settings\"))\n \t\t\t\t.haveExactly(1, new Condition<>(f -> f.equals(\"build.gradle\"), \"build\"))",
    "output": "Fix paths check on Windows"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n@@ -1,5 +1,8 @@\n package jadx.cli;\n \n+import java.util.function.Consumer;\n+\n+import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -26,10 +29,18 @@ public static void main(String[] args) {\n \t}\n \n \tpublic static int execute(String[] args) {\n+\t\treturn execute(args, null);\n+\t}\n+\n+\tpublic static int execute(String[] args, @Nullable Consumer<JadxArgs> argsMod) {\n \t\ttry {\n-\t\t\tJadxCLIArgs jadxArgs = new JadxCLIArgs();\n-\t\t\tif (jadxArgs.processArgs(args)) {\n-\t\t\t\treturn processAndSave(jadxArgs);\n+\t\t\tJadxCLIArgs cliArgs = new JadxCLIArgs();\n+\t\t\tif (cliArgs.processArgs(args)) {\n+\t\t\t\tJadxArgs jadxArgs = buildArgs(cliArgs);\n+\t\t\t\tif (argsMod != null) {\n+\t\t\t\t\targsMod.accept(jadxArgs);\n+\t\t\t\t}\n+\t\t\t\treturn runSave(jadxArgs, cliArgs);\n \t\t\t}\n \t\t\treturn 0;\n \t\t} catch (JadxArgsValidateException e) {\n@@ -41,7 +52,7 @@ public static int execute(String[] args) {\n \t\t}\n \t}\n \n-\tprivate static int processAndSave(JadxCLIArgs cliArgs) {\n+\tprivate static JadxArgs buildArgs(JadxCLIArgs cliArgs) {\n \t\tLogHelper.initLogLevel(cliArgs);\n \t\tLogHelper.setLogLevelsForLoadingStage();\n \t\tJadxArgs jadxArgs = cliArgs.toJadxArgs();\n@@ -50,6 +61,10 @@ private static int processAndSave(JadxCLIArgs cliArgs) {\n \t\tjadxArgs.setFilesGetter(JadxFilesGetter.INSTANCE);\n \t\tinitCodeWriterProvider(jadxArgs);\n \t\tJadxAppCommon.applyEnvVars(jadxArgs);\n+\t\treturn jadxArgs;\n+\t}\n+\n+\tprivate static int runSave(JadxArgs jadxArgs, JadxCLIArgs cliArgs) {\n \t\ttry (JadxDecompiler jadx = new JadxDecompiler(jadxArgs)) {\n \t\t\tjadx.load();\n \t\t\tif (checkForErrors(jadx)) {\n\ndiff --git a/jadx-cli/src/test/java/jadx/cli/TestInput.java b/jadx-cli/src/test/java/jadx/cli/TestInput.java\n--- a/jadx-cli/src/test/java/jadx/cli/TestInput.java\n+++ b/jadx-cli/src/test/java/jadx/cli/TestInput.java\n@@ -13,11 +13,15 @@\n import java.util.stream.Stream;\n \n import org.assertj.core.api.Condition;\n+import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.io.TempDir;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.api.plugins.loader.JadxBasePluginLoader;\n+import jadx.core.plugins.files.SingleDirFilesGetter;\n+\n import static org.assertj.core.api.Assertions.assertThat;\n \n public class TestInput {\n@@ -31,17 +35,24 @@ public class TestInput {\n \t@TempDir\n \tPath testDir;\n \n+\tPath outputDir;\n+\n+\t@BeforeEach\n+\tpublic void setUp() {\n+\t\toutputDir = testDir.resolve(\"output\");\n+\t}\n+\n \t@Test\n \tpublic void testHelp() {\n-\t\tint result = JadxCLI.execute(new String[] { \"--help\" });\n+\t\tint result = execJadxCli(new String[] { \"--help\" });\n \t\tassertThat(result).isEqualTo(0);\n \t}\n \n \t@Test\n \tpublic void testApkInput() throws Exception {\n-\t\tint result = JadxCLI.execute(buildArgs(List.of(), \"samples/small.apk\"));\n+\t\tint result = execJadxCli(buildArgs(List.of(), \"samples/small.apk\"));\n \t\tassertThat(result).isEqualTo(0);\n-\t\tList<Path> resultFiles = collectAllFilesInDir(testDir);\n+\t\tList<Path> resultFiles = collectAllFilesInDir(outputDir);\n \t\tprintFiles(resultFiles);\n \t\tassertThat(resultFiles)\n \t\t\t\t.describedAs(\"check output files\")\n@@ -75,48 +86,56 @@ public void testMultipleInput() throws Exception {\n \n \t@Test\n \tpublic void testFallbackMode() throws Exception {\n-\t\tint result = JadxCLI.execute(buildArgs(List.of(\"-f\"), \"samples/hello.dex\"));\n+\t\tint result = execJadxCli(buildArgs(List.of(\"-f\"), \"samples/hello.dex\"));\n \t\tassertThat(result).isEqualTo(0);\n-\t\tList<Path> files = collectJavaFilesInDir(testDir);\n+\t\tList<Path> files = collectJavaFilesInDir(outputDir);\n \t\tassertThat(files).hasSize(1);\n \t}\n \n \t@Test\n \tpublic void testSimpleMode() throws Exception {\n-\t\tint result = JadxCLI.execute(buildArgs(List.of(\"--decompilation-mode\", \"simple\"), \"samples/hello.dex\"));\n+\t\tint result = execJadxCli(buildArgs(List.of(\"--decompilation-mode\", \"simple\"), \"samples/hello.dex\"));\n \t\tassertThat(result).isEqualTo(0);\n-\t\tList<Path> files = collectJavaFilesInDir(testDir);\n+\t\tList<Path> files = collectJavaFilesInDir(outputDir);\n \t\tassertThat(files).hasSize(1);\n \t}\n \n \t@Test\n \tpublic void testResourceOnly() throws Exception {\n-\t\tint result = JadxCLI.execute(buildArgs(List.of(), \"samples/resources-only.apk\"));\n+\t\tint result = execJadxCli(buildArgs(List.of(), \"samples/resources-only.apk\"));\n \t\tassertThat(result).isEqualTo(0);\n-\t\tList<Path> files = collectFilesInDir(testDir,\n+\t\tList<Path> files = collectFilesInDir(outputDir,\n \t\t\t\tpath -> path.getFileName().toString().equalsIgnoreCase(\"AndroidManifest.xml\"));\n \t\tassertThat(files).isNotEmpty();\n \t}\n \n \tprivate void decompile(String... inputSamples) throws URISyntaxException, IOException {\n-\t\tint result = JadxCLI.execute(buildArgs(List.of(), inputSamples));\n+\t\tint result = execJadxCli(buildArgs(List.of(), inputSamples));\n \t\tassertThat(result).isEqualTo(0);\n-\t\tList<Path> resultJavaFiles = collectJavaFilesInDir(testDir);\n+\t\tList<Path> resultJavaFiles = collectJavaFilesInDir(outputDir);\n \t\tassertThat(resultJavaFiles).isNotEmpty();\n \n \t\t// do not copy input files as resources\n-\t\tfor (Path path : collectFilesInDir(testDir, LOG_ALL_FILES)) {\n+\t\tfor (Path path : collectFilesInDir(outputDir, LOG_ALL_FILES)) {\n \t\t\tfor (String inputSample : inputSamples) {\n \t\t\t\tassertThat(path.toAbsolutePath().toString()).doesNotContain(inputSample);\n \t\t\t}\n \t\t}\n \t}\n \n+\tprivate int execJadxCli(String[] args) {\n+\t\treturn JadxCLI.execute(args, jadxArgs -> {\n+\t\t\t// don't use global config and plugins\n+\t\t\tjadxArgs.setFilesGetter(new SingleDirFilesGetter(testDir));\n+\t\t\tjadxArgs.setPluginLoader(new JadxBasePluginLoader());\n+\t\t});\n+\t}\n+\n \tprivate String[] buildArgs(List<String> options, String... inputSamples) throws URISyntaxException {\n \t\tList<String> args = new ArrayList<>(options);\n \t\targs.add(\"-v\");\n \t\targs.add(\"-d\");\n-\t\targs.add(testDir.toAbsolutePath().toString());\n+\t\targs.add(outputDir.toAbsolutePath().toString());\n \n \t\tfor (String inputSample : inputSamples) {\n \t\t\tURL resource = getClass().getClassLoader().getResource(inputSample);\n@@ -130,7 +149,7 @@ private String[] buildArgs(List<String> options, String... inputSamples) throws\n \tprivate void printFiles(List<Path> files) {\n \t\tLOG.info(\"Output files (count: {}):\", files.size());\n \t\tfor (Path file : files) {\n-\t\t\tLOG.info(\" {}\", testDir.relativize(file));\n+\t\t\tLOG.info(\" {}\", outputDir.relativize(file));\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/plugins/files/SingleDirFilesGetter.java b/jadx-core/src/main/java/jadx/core/plugins/files/SingleDirFilesGetter.java\n--- a/jadx-core/src/main/java/jadx/core/plugins/files/SingleDirFilesGetter.java\n+++ b/jadx-core/src/main/java/jadx/core/plugins/files/SingleDirFilesGetter.java\n@@ -0,0 +1,37 @@\n+package jadx.core.plugins.files;\n+\n+import java.nio.file.Path;\n+\n+import jadx.core.utils.files.FileUtils;\n+\n+/**\n+ * Use single directory for all jadx files\n+ */\n+public class SingleDirFilesGetter implements IJadxFilesGetter {\n+\tprivate final Path baseDir;\n+\n+\tpublic SingleDirFilesGetter(Path baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Override\n+\tpublic Path getConfigDir() {\n+\t\treturn makeSubDir(\"config\");\n+\t}\n+\n+\t@Override\n+\tpublic Path getCacheDir() {\n+\t\treturn makeSubDir(\"cache\");\n+\t}\n+\n+\t@Override\n+\tpublic Path getTempDir() {\n+\t\treturn makeSubDir(\"temp\");\n+\t}\n+\n+\tprivate Path makeSubDir(String subDir) {\n+\t\tPath dir = baseDir.resolve(subDir);\n+\t\tFileUtils.makeDirs(dir);\n+\t\treturn dir;\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n@@ -178,7 +178,9 @@ private static void deleteDir(Path dir) {\n \t}\n \n \tpublic static void clearTempRootDir() {\n-\t\tclearDir(tempRootDir);\n+\t\tif (Files.isDirectory(tempRootDir)) {\n+\t\t\tclearDir(tempRootDir);\n+\t\t}\n \t}\n \n \tpublic static void clearDir(Path clearDir) {",
    "output": "Fix don't use global configs for cli integration tests"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfo.java b/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfo.java\n@@ -148,15 +148,19 @@ public void fieldUse(ICodeNode node, FieldInfo useFld) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Visit all class nodes found in subtypes of the provided type.\n+\t */\n \tprivate void processType(ArgType type, Consumer<ClassNode> consumer) {\n-\t\tif (type == null) {\n+\t\tif (type == null || type == ArgType.OBJECT) {\n \t\t\treturn;\n \t\t}\n \t\tif (type.isArray()) {\n \t\t\tprocessType(type.getArrayRootElement(), consumer);\n \t\t\treturn;\n \t\t}\n-\t\tif (type.isObject() && !type.isGenericType()) {\n+\t\tif (type.isObject()) {\n+\t\t\t// TODO: support custom handlers via API\n \t\t\tClspClass clsDetails = root.getClsp().getClsDetails(type);\n \t\t\tif (clsDetails != null && clsDetails.getSource() == ClspClassSource.APACHE_HTTP_LEGACY_CLIENT) {\n \t\t\t\troot.getGradleInfoStorage().setUseApacheHttpLegacy(true);\n@@ -166,19 +170,30 @@ private void processType(ArgType type, Consumer<ClassNode> consumer) {\n \t\t\t\tconsumer.accept(clsNode);\n \t\t\t}\n \t\t\tList<ArgType> genericTypes = type.getGenericTypes();\n-\t\t\tif (type.isGeneric() && notEmpty(genericTypes)) {\n+\t\t\tif (notEmpty(genericTypes)) {\n \t\t\t\tfor (ArgType argType : genericTypes) {\n \t\t\t\t\tprocessType(argType, consumer);\n \t\t\t\t}\n \t\t\t}\n+\t\t\tList<ArgType> extendTypes = type.getExtendTypes();\n+\t\t\tif (notEmpty(extendTypes)) {\n+\t\t\t\tfor (ArgType extendType : extendTypes) {\n+\t\t\t\t\tprocessType(extendType, consumer);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tArgType wildcardType = type.getWildcardType();\n+\t\t\tif (wildcardType != null) {\n+\t\t\t\tprocessType(wildcardType, consumer);\n+\t\t\t}\n+\t\t\t// TODO: process 'outer' types (check TestOuterGeneric test)\n \t\t}\n \t}\n \n-\tprivate static <T extends Comparable<T>> List<T> sortedList(Set<T> deps) {\n-\t\tif (deps == null || deps.isEmpty()) {\n+\tprivate static <T extends Comparable<T>> List<T> sortedList(Set<T> nodes) {\n+\t\tif (nodes == null || nodes.isEmpty()) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n-\t\tList<T> list = new ArrayList<>(deps);\n+\t\tList<T> list = new ArrayList<>(nodes);\n \t\tCollections.sort(list);\n \t\treturn list;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfoVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfoVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfoVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfoVisitor.java\n@@ -88,12 +88,14 @@ private static void processClass(ClassNode cls, UsageInfo usageInfo) {\n \t\tfor (ArgType interfaceType : cls.getInterfaces()) {\n \t\t\tusageInfo.clsUse(cls, interfaceType);\n \t\t}\n+\t\tfor (ArgType genericTypeParameter : cls.getGenericTypeParameters()) {\n+\t\t\tusageInfo.clsUse(cls, genericTypeParameter);\n+\t\t}\n \t\tfor (FieldNode fieldNode : cls.getFields()) {\n \t\t\tusageInfo.clsUse(cls, fieldNode.getType());\n \t\t\tprocessAnnotations(fieldNode, usageInfo);\n \t\t\t// TODO: process types from field 'constant value'\n \t\t}\n-\t\t// TODO: process generics\n \t\tprocessAnnotations(cls, usageInfo);\n \t\tfor (MethodNode methodNode : cls.getMethods()) {\n \t\t\tprocessMethod(methodNode, usageInfo);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/generics/TestUsageInGenerics.java b/jadx-core/src/test/java/jadx/tests/integration/generics/TestUsageInGenerics.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/generics/TestUsageInGenerics.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/generics/TestUsageInGenerics.java\n@@ -0,0 +1,47 @@\n+package jadx.tests.integration.generics;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.core.dex.nodes.MethodNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestUsageInGenerics extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic static class A {\n+\t\t}\n+\n+\t\tpublic static class B<T extends A> {\n+\t\t}\n+\n+\t\tpublic static class C {\n+\t\t\tpublic List<? extends A> list;\n+\t\t}\n+\n+\t\tpublic <T extends A> T test() {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tClassNode testCls = searchCls(cls.getInnerClasses(), \"A\");\n+\t\tClassNode bCls = searchCls(cls.getInnerClasses(), \"B\");\n+\t\tClassNode cCls = searchCls(cls.getInnerClasses(), \"C\");\n+\t\tMethodNode testMth = getMethod(cls, \"test\");\n+\n+\t\tassertThat(testCls.getUseIn()).contains(cls, bCls, cCls);\n+\t\tassertThat(testCls.getUseInMth()).contains(testMth);\n+\n+\t\tassertThat(cls)\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"public <T extends A> T test() {\");\n+\t}\n+}",
    "output": "Fix collect usage info in generic types"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n@@ -9,6 +9,7 @@\n \n import org.jetbrains.annotations.Nullable;\n \n+import jadx.core.deobf.NameMapper;\n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.nodes.ClassNode;\n@@ -167,7 +168,7 @@ private void parseFieldSignature(FieldNode field) {\n \t\t\t}\n \t\t\tArgType type = root.getTypeUtils().expandTypeVariables(cls, signatureType);\n \t\t\tif (!validateParsedType(type, field.getType())) {\n-\t\t\t\tcls.addWarnComment(\"Incorrect field signature: \" + sp.getSignature());\n+\t\t\t\tfield.addInfoComment(\"Incorrect field signature: \" + sp.getSignature());\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tfield.updateType(type);\n@@ -256,9 +257,29 @@ private List<ArgType> checkArgTypes(MethodNode mth, SignatureParser sp, List<Arg\n \n \tprivate boolean validateParsedType(ArgType parsedType, ArgType currentType) {\n \t\tTypeCompareEnum result = root.getTypeCompare().compareTypes(parsedType, currentType);\n+\t\tif (result == TypeCompareEnum.UNKNOWN\n+\t\t\t\t&& parsedType.isObject()\n+\t\t\t\t&& !validateFullClsName(parsedType.getObject())) {\n+\t\t\t// ignore external invalid class names: may be a reserved words or garbage\n+\t\t\treturn false;\n+\t\t}\n \t\treturn result != TypeCompareEnum.CONFLICT;\n \t}\n \n+\tprivate boolean validateFullClsName(String fullClsName) {\n+\t\tif (!NameMapper.isValidFullIdentifier(fullClsName)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (fullClsName.indexOf('.') > 0) {\n+\t\t\tfor (String namePart : fullClsName.split(\"\\\\.\")) {\n+\t\t\t\tif (!NameMapper.isValidIdentifier(namePart)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n \tprivate boolean validateInnerType(List<ArgType> types) {\n \t\tfor (ArgType type : types) {\n \t\t\tif (!validateInnerType(type)) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestIncorrectFieldSignature.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestIncorrectFieldSignature.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestIncorrectFieldSignature.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestIncorrectFieldSignature.java\n@@ -0,0 +1,19 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestIncorrectFieldSignature extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"public static boolean A;\")\n+\t\t\t\t.containsOne(\"public static Boolean B;\")\n+\t\t\t\t.countString(2, \"/* JADX INFO: Incorrect field signature:\");\n+\t}\n+}",
    "output": "Fix ignore external and invalid class names in signature"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/pkgs/PackageHelper.java b/jadx-gui/src/main/java/jadx/gui/utils/pkgs/PackageHelper.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/pkgs/PackageHelper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/pkgs/PackageHelper.java\n@@ -75,7 +75,7 @@ public List<JRenamePackage> getRenameNodes(JPackage pkg) {\n \tprivate List<JPackage> prepareFlatPackages() {\n \t\tList<JPackage> list = new ArrayList<>();\n \t\tfor (JavaPackage javaPkg : wrapper.getPackages()) {\n-\t\t\tif (javaPkg.isLeaf()) {\n+\t\t\tif (javaPkg.isLeaf() || !javaPkg.getClasses().isEmpty()) {\n \t\t\t\tJPackage pkg = buildJPackage(javaPkg, false);\n \t\t\t\tpkg.setName(javaPkg.getFullName());\n \t\t\t\tlist.add(pkg);",
    "output": "Fix flatten packages view: non-leaf packages with classes were not visible in the sources tree"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/IfRegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/IfRegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/IfRegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/IfRegionMaker.java\n@@ -400,6 +400,11 @@ private static BlockNode getBranchBlock(BlockNode first, BlockNode second, Set<B\n \t\t\tskipBlocks.add(first);\n \t\t\treturn second;\n \t\t}\n+\t\tif (BlockUtils.isDuplicateBlockPath(first, second)) {\n+\t\t\tfirst.add(AFlag.REMOVE);\n+\t\t\tskipBlocks.add(first);\n+\t\t\treturn second;\n+\t\t}\n \t\tBlockNode cross = BlockUtils.getPathCross(mth, first, second);\n \t\tif (cross != null) {\n \t\t\tBlockUtils.visitBlocksOnPath(mth, first, cross, skipBlocks::add);\n@@ -465,48 +470,12 @@ private static IfInfo getNextIfNodeInfo(IfInfo info, BlockNode block) {\n \t\tif (successors.size() != 1) {\n \t\t\treturn null;\n \t\t}\n-\n \t\tBlockNode next = successors.get(0);\n-\t\tif (next.getPredecessors().size() != 1) {\n+\t\tif (next.getPredecessors().size() != 1 || next.contains(AFlag.ADDED_TO_REGION)) {\n \t\t\treturn null;\n \t\t}\n-\t\tif (next.contains(AFlag.ADDED_TO_REGION)) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tList<InsnNode> insns = block.getInstructions();\n-\t\tboolean pass = true;\n \t\tList<InsnNode> forceInlineInsns = new ArrayList<>();\n-\t\tif (!insns.isEmpty()) {\n-\t\t\t// check that all instructions can be inlined\n-\t\t\tfor (InsnNode insn : insns) {\n-\t\t\t\tRegisterArg res = insn.getResult();\n-\t\t\t\tif (res == null) {\n-\t\t\t\t\tpass = false;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tList<RegisterArg> useList = res.getSVar().getUseList();\n-\t\t\t\tint useCount = useList.size();\n-\t\t\t\tif (useCount == 0) {\n-\t\t\t\t\t// TODO?\n-\t\t\t\t\tpass = false;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tInsnArg arg = useList.get(0);\n-\t\t\t\tInsnNode usePlace = arg.getParentInsn();\n-\t\t\t\tif (!BlockUtils.blockContains(block, usePlace)\n-\t\t\t\t\t\t&& !BlockUtils.blockContains(next, usePlace)) {\n-\t\t\t\t\tpass = false;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (useCount > 1) {\n-\t\t\t\t\tforceInlineInsns.add(insn);\n-\t\t\t\t} else {\n-\t\t\t\t\t// allow only forced assign inline\n-\t\t\t\t\tpass = false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tif (!pass) {\n+\t\tif (!checkInsnsInline(block, next, forceInlineInsns)) {\n \t\t\treturn null;\n \t\t}\n \t\tIfInfo nextInfo = makeIfInfo(info.getMth(), next);\n@@ -516,4 +485,40 @@ private static IfInfo getNextIfNodeInfo(IfInfo info, BlockNode block) {\n \t\tnextInfo.addInsnsForForcedInline(forceInlineInsns);\n \t\treturn nextInfo;\n \t}\n+\n+\t/**\n+\t * Check that all instructions can be inlined\n+\t */\n+\tprivate static boolean checkInsnsInline(BlockNode block, BlockNode next, List<InsnNode> forceInlineInsns) {\n+\t\tList<InsnNode> insns = block.getInstructions();\n+\t\tif (insns.isEmpty()) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tboolean pass = true;\n+\t\tfor (InsnNode insn : insns) {\n+\t\t\tRegisterArg res = insn.getResult();\n+\t\t\tif (res == null) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tList<RegisterArg> useList = res.getSVar().getUseList();\n+\t\t\tint useCount = useList.size();\n+\t\t\tif (useCount == 0) {\n+\t\t\t\t// TODO?\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tInsnArg arg = useList.get(0);\n+\t\t\tInsnNode usePlace = arg.getParentInsn();\n+\t\t\tif (!BlockUtils.blockContains(block, usePlace)\n+\t\t\t\t\t&& !BlockUtils.blockContains(next, usePlace)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (useCount > 1) {\n+\t\t\t\tforceInlineInsns.add(insn);\n+\t\t\t} else {\n+\t\t\t\t// allow only forced assign inline\n+\t\t\t\tpass = false;\n+\t\t\t}\n+\t\t}\n+\t\treturn pass;\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -10,6 +10,7 @@\n import java.util.HashSet;\n import java.util.LinkedHashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Queue;\n import java.util.Set;\n import java.util.function.Consumer;\n@@ -1208,7 +1209,7 @@ public static boolean isEqualPaths(BlockNode b1, BlockNode b2) {\n \t\tif (b1 == null || b2 == null) {\n \t\t\treturn false;\n \t\t}\n-\t\treturn isEqualReturnBlocks(b1, b2) || isEmptySyntheticPath(b1, b2);\n+\t\treturn isEqualReturnBlocks(b1, b2) || isEmptySyntheticPath(b1, b2) || isDuplicateBlockPath(b1, b2);\n \t}\n \n \tprivate static boolean isEmptySyntheticPath(BlockNode b1, BlockNode b2) {\n@@ -1244,4 +1245,45 @@ public static boolean isEqualReturnBlocks(BlockNode b1, BlockNode b2) {\n \t\t}\n \t\treturn firstArg.equals(secondArg);\n \t}\n+\n+\tpublic static boolean isDuplicateBlockPath(BlockNode first, BlockNode second) {\n+\t\tif (first.getSuccessors().size() == 1 && second.getSuccessors().size() == 1\n+\t\t\t\t&& first.getSuccessors().get(0).equals(second.getSuccessors().get(0))) {\n+\t\t\treturn isSameInsnsBlocks(first, second);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic static boolean isSameInsnsBlocks(BlockNode first, BlockNode second) {\n+\t\tList<InsnNode> firstInsns = first.getInstructions();\n+\t\tList<InsnNode> secondInsns = second.getInstructions();\n+\t\tif (firstInsns.size() != secondInsns.size()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tint len = firstInsns.size();\n+\t\tfor (int i = 0; i < len; i++) {\n+\t\t\tInsnNode firstInsn = firstInsns.get(i);\n+\t\t\tInsnNode secondInsn = secondInsns.get(i);\n+\t\t\tif (!isInsnDeepEquals(firstInsn, secondInsn)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate static boolean isInsnDeepEquals(InsnNode first, InsnNode second) {\n+\t\tif (first == second) {\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn first.isSame(second)\n+\t\t\t\t&& Objects.equals(first.getArguments(), second.getArguments())\n+\t\t\t\t&& resultIsSameReg(first.getResult(), second.getResult());\n+\t}\n+\n+\tprivate static boolean resultIsSameReg(RegisterArg first, RegisterArg second) {\n+\t\tif (first == null || second == null) {\n+\t\t\treturn first == second;\n+\t\t}\n+\t\treturn first.getRegNum() == second.getRegNum();\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java b/jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java\n--- a/jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java\n@@ -131,7 +131,7 @@ private void printMethods(ClassNode classNode, @NotNull String mthPattern) {\n \t\tfor (MethodNode mth : classNode.getMethods()) {\n \t\t\tif (isMthMatch(mth, mthPattern)) {\n \t\t\t\tLOG.info(\"Print method: {}\\n{}\\n{}\\n{}\",\n-\t\t\t\t\t\tmth.getMethodInfo().getShortId(),\n+\t\t\t\t\t\tmth.getMethodInfo().getRawFullId(),\n \t\t\t\t\t\tdashLine,\n \t\t\t\t\t\tmth.getCodeStr(),\n \t\t\t\t\t\tdashLine);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf3.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf3.java\n@@ -0,0 +1,19 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestComplexIf3 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.countString(1, \"iArr = null;\")\n+\t\t\t\t.countString(2, \"z = false;\");\n+\t}\n+}",
    "output": "Fix deduplicate blocks to help 'complex if' restructure"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java\n@@ -2,7 +2,12 @@\n \n import java.io.IOException;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n public class CommonBinaryParser extends ParserConstants {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(CommonBinaryParser.class);\n+\n \tprotected ParserStream is;\n \n \tprotected BinaryXMLStrings parseStringPool() throws IOException {\n@@ -12,10 +17,17 @@ protected BinaryXMLStrings parseStringPool() throws IOException {\n \n \tprotected BinaryXMLStrings parseStringPoolNoType() throws IOException {\n \t\tlong start = is.getPos() - 2;\n-\t\tis.checkInt16(0x001c, \"String pool header size not 0x001c\");\n+\t\tint headerSize = is.readInt16();\n+\t\tif (headerSize != 0x1c) {\n+\t\t\tLOG.warn(\"Unexpected string pool header size: 0x{}, expected: 0x1C\", Integer.toHexString(headerSize));\n+\t\t}\n \t\tlong size = is.readUInt32();\n \t\tlong chunkEnd = start + size;\n \n+\t\treturn parseStringPoolNoSize(start, chunkEnd);\n+\t}\n+\n+\tprotected BinaryXMLStrings parseStringPoolNoSize(long start, long chunkEnd) throws IOException {\n \t\tint stringCount = is.readInt32();\n \t\tint styleCount = is.readInt32();\n \t\tint flags = is.readInt32();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n@@ -1,6 +1,7 @@\n package jadx.core.xmlgen;\n \n import java.io.BufferedInputStream;\n+import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.ArrayList;\n@@ -102,41 +103,52 @@ public ResContainer decodeFiles() {\n \tvoid decodeTableChunk() throws IOException {\n \t\tis.checkInt16(RES_TABLE_TYPE, \"Not a table chunk\");\n \t\tis.checkInt16(0x000c, \"Unexpected table header size\");\n-\t\t/* int size = */\n-\t\tis.readInt32();\n+\t\tint size = is.readInt32();\n \t\tint pkgCount = is.readInt32();\n \n-\t\tstrings = parseStringPool();\n-\t\tfor (int i = 0; i < pkgCount; i++) {\n-\t\t\tparsePackage();\n+\t\tint pkgNum = 0;\n+\t\twhile (is.getPos() < size) {\n+\t\t\tlong chuckStart = is.getPos();\n+\t\t\tint type = is.readInt16();\n+\t\t\tint headerSize = is.readInt16();\n+\t\t\tlong chunkSize = is.readUInt32();\n+\t\t\tlong chunkEnd = chuckStart + chunkSize;\n+\t\t\tswitch (type) {\n+\t\t\t\tcase RES_NULL_TYPE:\n+\t\t\t\t\t// skip\n+\t\t\t\t\tbreak;\n+\n+\t\t\t\tcase RES_STRING_POOL_TYPE:\n+\t\t\t\t\tstrings = parseStringPoolNoSize(chuckStart, chunkEnd);\n+\t\t\t\t\tbreak;\n+\n+\t\t\t\tcase RES_TABLE_PACKAGE_TYPE:\n+\t\t\t\t\tparsePackage(chuckStart, headerSize, chunkEnd);\n+\t\t\t\t\tpkgNum++;\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tis.skipToPos(chunkEnd, \"Skip to table chunk end\");\n+\t\t}\n+\t\tif (pkgNum != pkgCount) {\n+\t\t\tLOG.warn(\"Unexpected package chunks, read: {}, expected: {}\", pkgNum, pkgCount);\n \t\t}\n \t}\n \n-\tprivate PackageChunk parsePackage() throws IOException {\n-\t\tlong start = is.getPos();\n-\t\tis.checkInt16(RES_TABLE_PACKAGE_TYPE, \"Not a table chunk\");\n-\t\tint headerSize = is.readInt16();\n+\tprivate void parsePackage(long pkgChunkStart, int headerSize, long pkgChunkEnd) throws IOException {\n \t\tif (headerSize < 0x011c) {\n \t\t\tdie(\"Package header size too small\");\n+\t\t\treturn;\n \t\t}\n-\t\tlong size = is.readUInt32();\n-\t\tlong endPos = start + size;\n-\n \t\tint id = is.readInt32();\n \t\tString name = is.readString16Fixed(128);\n-\n-\t\tlong typeStringsOffset = start + is.readInt32();\n-\t\t/* int lastPublicType = */\n-\t\tis.readInt32();\n-\t\tlong keyStringsOffset = start + is.readInt32();\n-\t\t/* int lastPublicKey = */\n-\t\tis.readInt32();\n-\n+\t\tlong typeStringsOffset = pkgChunkStart + is.readInt32();\n+\t\tint lastPublicType = is.readInt32();\n+\t\tlong keyStringsOffset = pkgChunkStart + is.readInt32();\n+\t\tint lastPublicKey = is.readInt32();\n \t\tif (headerSize >= 0x0120) {\n-\t\t\t/* int typeIdOffset = */\n-\t\t\tis.readInt32();\n+\t\t\tint typeIdOffset = is.readInt32();\n \t\t}\n-\t\tis.skipToPos(start + headerSize, \"package header end\");\n+\t\tis.skipToPos(pkgChunkStart + headerSize, \"package header end\");\n \n \t\tBinaryXMLStrings typeStrings = null;\n \t\tif (typeStringsOffset != 0) {\n@@ -152,7 +164,7 @@ private PackageChunk parsePackage() throws IOException {\n \t\tPackageChunk pkg = new PackageChunk(id, name, typeStrings, keyStrings);\n \t\tresStorage.setAppPackage(name);\n \n-\t\twhile (is.getPos() < endPos) {\n+\t\twhile (is.getPos() < pkgChunkEnd) {\n \t\t\tlong chunkStart = is.getPos();\n \t\t\tint type = is.readInt16();\n \t\t\tLOG.trace(\"res package chunk start at {} type {}\", chunkStart, type);\n@@ -182,7 +194,6 @@ private PackageChunk parsePackage() throws IOException {\n \t\t\t\t\tLOG.warn(\"Unknown chunk type {} encountered at offset {}\", type, chunkStart);\n \t\t\t}\n \t\t}\n-\t\treturn pkg;\n \t}\n \n \t@SuppressWarnings(\"unused\")\n@@ -493,69 +504,59 @@ private RawValue parseValue() throws IOException {\n \tprivate EntryConfig parseConfig() throws IOException {\n \t\tlong start = is.getPos();\n \t\tint size = is.readInt32();\n-\t\tif (size < 28) {\n-\t\t\tthrow new IOException(\"Config size < 28\");\n+\t\tif (size < 4) {\n+\t\t\tthrow new IOException(\"Config size < 4\");\n \t\t}\n \n-\t\tshort mcc = (short) is.readInt16();\n-\t\tshort mnc = (short) is.readInt16();\n+\t\t// Android zero fill this structure and only read the data present\n+\t\tvar configData = new byte[Math.max(52, size - 4)];\n+\t\tis.readFully(configData, 0, size - 4);\n+\t\tvar configIs = new ParserStream(new ByteArrayInputStream(configData));\n \n-\t\tchar[] language = unpackLocaleOrRegion((byte) is.readInt8(), (byte) is.readInt8(), 'a');\n-\t\tchar[] country = unpackLocaleOrRegion((byte) is.readInt8(), (byte) is.readInt8(), '0');\n+\t\tshort mcc = (short) configIs.readInt16();\n+\t\tshort mnc = (short) configIs.readInt16();\n \n-\t\tbyte orientation = (byte) is.readInt8();\n-\t\tbyte touchscreen = (byte) is.readInt8();\n-\t\tint density = is.readInt16();\n+\t\tchar[] language = unpackLocaleOrRegion((byte) configIs.readInt8(), (byte) configIs.readInt8(), 'a');\n+\t\tchar[] country = unpackLocaleOrRegion((byte) configIs.readInt8(), (byte) configIs.readInt8(), '0');\n \n-\t\tbyte keyboard = (byte) is.readInt8();\n-\t\tbyte navigation = (byte) is.readInt8();\n-\t\tbyte inputFlags = (byte) is.readInt8();\n-\t\tbyte grammaticalInflection = (byte) is.readInt8();\n+\t\tbyte orientation = (byte) configIs.readInt8();\n+\t\tbyte touchscreen = (byte) configIs.readInt8();\n+\t\tint density = configIs.readInt16();\n \n-\t\tshort screenWidth = (short) is.readInt16();\n-\t\tshort screenHeight = (short) is.readInt16();\n+\t\tbyte keyboard = (byte) configIs.readInt8();\n+\t\tbyte navigation = (byte) configIs.readInt8();\n+\t\tbyte inputFlags = (byte) configIs.readInt8();\n+\t\tbyte grammaticalInflection = (byte) configIs.readInt8();\n \n-\t\tshort sdkVersion = (short) is.readInt16();\n-\t\tis.readInt16(); // minorVersion must always be 0\n+\t\tshort screenWidth = (short) configIs.readInt16();\n+\t\tshort screenHeight = (short) configIs.readInt16();\n \n-\t\tbyte screenLayout = 0;\n-\t\tbyte uiMode = 0;\n-\t\tshort smallestScreenWidthDp = 0;\n-\t\tif (size >= 32) {\n-\t\t\tscreenLayout = (byte) is.readInt8();\n-\t\t\tuiMode = (byte) is.readInt8();\n-\t\t\tsmallestScreenWidthDp = (short) is.readInt16();\n-\t\t}\n+\t\tshort sdkVersion = (short) configIs.readInt16();\n+\t\tconfigIs.readInt16(); // minorVersion must always be 0\n \n-\t\tshort screenWidthDp = 0;\n-\t\tshort screenHeightDp = 0;\n-\t\tif (size >= 36) {\n-\t\t\tscreenWidthDp = (short) is.readInt16();\n-\t\t\tscreenHeightDp = (short) is.readInt16();\n-\t\t}\n+\t\tbyte screenLayout = (byte) configIs.readInt8();\n+\t\tbyte uiMode = (byte) configIs.readInt8();\n+\t\tshort smallestScreenWidthDp = (short) configIs.readInt16();\n+\t\tshort screenWidthDp = (short) configIs.readInt16();\n+\t\tshort screenHeightDp = (short) configIs.readInt16();\n \n-\t\tchar[] localeScript = null;\n-\t\tchar[] localeVariant = null;\n-\t\tif (size >= 48) {\n-\t\t\tlocaleScript = readScriptOrVariantChar(4).toCharArray();\n-\t\t\tlocaleVariant = readScriptOrVariantChar(8).toCharArray();\n-\t\t}\n+\t\tchar[] localeScript = readScriptOrVariantChar(4, configIs).toCharArray();\n+\t\tchar[] localeVariant = readScriptOrVariantChar(8, configIs).toCharArray();\n \n-\t\tbyte screenLayout2 = 0;\n-\t\tbyte colorMode = 0;\n-\t\tif (size >= 52) {\n-\t\t\tscreenLayout2 = (byte) is.readInt8();\n-\t\t\tcolorMode = (byte) is.readInt8();\n-\t\t\tis.readInt16(); // reserved padding\n-\t\t}\n+\t\tbyte screenLayout2 = (byte) configIs.readInt8();\n+\t\tbyte colorMode = (byte) configIs.readInt8();\n+\t\tconfigIs.readInt16(); // reserved padding\n \n-\t\tis.skipToPos(start + size, \"Config skip trailing bytes\");\n+\t\tis.checkPos(start + size, \"Config skip trailing bytes\");\n \n \t\treturn new EntryConfig(mcc, mnc, language, country,\n \t\t\t\torientation, touchscreen, density, keyboard, navigation,\n \t\t\t\tinputFlags, grammaticalInflection, screenWidth, screenHeight, sdkVersion,\n \t\t\t\tscreenLayout, uiMode, smallestScreenWidthDp, screenWidthDp,\n-\t\t\t\tscreenHeightDp, localeScript, localeVariant, screenLayout2,\n+\t\t\t\tscreenHeightDp,\n+\t\t\t\tlocaleScript.length == 0 ? null : localeScript,\n+\t\t\t\tlocaleVariant.length == 0 ? null : localeVariant,\n+\t\t\t\tscreenLayout2,\n \t\t\t\tcolorMode, false, size);\n \t}\n \n@@ -574,16 +575,20 @@ private char[] unpackLocaleOrRegion(byte in0, byte in1, char base) {\n \t}\n \n \tprivate String readScriptOrVariantChar(int length) throws IOException {\n-\t\tlong start = is.getPos();\n+\t\treturn readScriptOrVariantChar(length, is);\n+\t}\n+\n+\tprivate static String readScriptOrVariantChar(int length, ParserStream ps) throws IOException {\n+\t\tlong start = ps.getPos();\n \t\tStringBuilder sb = new StringBuilder(16);\n \t\tfor (int i = 0; i < length; i++) {\n-\t\t\tshort ch = (short) is.readInt8();\n+\t\t\tshort ch = (short) ps.readInt8();\n \t\t\tif (ch == 0) {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tsb.append((char) ch);\n \t\t}\n-\t\tis.skipToPos(start + length, \"readScriptOrVariantChar\");\n+\t\tps.skipToPos(start + length, \"readScriptOrVariantChar\");\n \t\treturn sb.toString();\n \t}",
    "output": "Fix improve resource table and config decoding"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n@@ -142,6 +142,7 @@ private void initUI() {\n \n \t\ttree = new SettingsTree();\n \t\ttree.init(wrapGroupPanel, groups);\n+\t\ttree.setFocusable(true);\n \t\tJScrollPane leftPane = new JScrollPane(tree);\n \t\tleftPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 3, 3));\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/SettingsGroup.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/SettingsGroup.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/SettingsGroup.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/SettingsGroup.java\n@@ -39,10 +39,18 @@ public JLabel addRow(String label, JComponent comp) {\n \t}\n \n \tpublic JLabel addRow(String label, String tooltip, JComponent comp) {\n-\t\tc.gridy = row++;\n \t\tJLabel rowLbl = new JLabel(label);\n \t\trowLbl.setLabelFor(comp);\n \t\trowLbl.setHorizontalAlignment(SwingConstants.LEFT);\n+\t\tif (tooltip != null) {\n+\t\t\trowLbl.setToolTipText(tooltip);\n+\t\t\tcomp.setToolTipText(tooltip);\n+\t\t} else {\n+\t\t\tcomp.setToolTipText(label);\n+\t\t}\n+\t\tcomp.getAccessibleContext().setAccessibleName(label);\n+\n+\t\tc.gridy = row++;\n \t\tc.gridx = 0;\n \t\tc.gridwidth = 1;\n \t\tc.anchor = GridBagConstraints.LINE_START;\n@@ -55,10 +63,6 @@ public JLabel addRow(String label, String tooltip, JComponent comp) {\n \t\tc.weightx = 0.7;\n \t\tc.fill = GridBagConstraints.LINE_START;\n \n-\t\tif (tooltip != null) {\n-\t\t\trowLbl.setToolTipText(tooltip);\n-\t\t\tcomp.setToolTipText(tooltip);\n-\t\t}\n \t\tgridPanel.add(comp, c);\n \t\tcomp.addPropertyChangeListener(\"enabled\", evt -> rowLbl.setEnabled((boolean) evt.getNewValue()));\n \t\treturn rowLbl;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettingsGroup.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettingsGroup.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettingsGroup.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettingsGroup.java\n@@ -96,6 +96,7 @@ private JPanel buildMainSettingsPage() {\n \t\tpluginList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n \t\tpluginList.setCellRenderer(new PluginsListCellRenderer());\n \t\tpluginList.addListSelectionListener(ev -> onSelection(pluginList.getSelectedValue()));\n+\t\tpluginList.setFocusable(true);\n \n \t\tJScrollPane scrollPane = new JScrollPane(pluginList);\n \t\tscrollPane.setMinimumSize(new Dimension(80, 120));\n@@ -276,8 +277,7 @@ public PluginsListCellRenderer() {\n \n \t\t\ttitleLbl = new JLabel();\n \t\t\ttitleLbl.setHorizontalAlignment(SwingConstants.CENTER);\n-\t\t\ttitleLbl.setEnabled(false);\n-\t\t\tversionLbl.setPreferredSize(new Dimension(40, 10));\n+\t\t\ttitleLbl.setPreferredSize(new Dimension(40, 10));\n \t\t}\n \n \t\t@Override\n@@ -290,6 +290,7 @@ public Component getListCellRendererComponent(JList<? extends BasePluginListNode\n \t\t\tnameLbl.setText(plugin.getTitle());\n \t\t\tnameLbl.setToolTipText(plugin.getLocationId());\n \t\t\tversionLbl.setText(Utils.getOrElse(plugin.getVersion(), \"\"));\n+\t\t\tpanel.getAccessibleContext().setAccessibleName(plugin.getTitle());\n \n \t\t\tboolean enabled = !plugin.isDisabled();\n \t\t\tnameLbl.setEnabled(enabled);",
    "output": "Fix improve accessibility of preferences dialog"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n@@ -275,33 +275,33 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t\t\t}\n \t\t}\n \t\tis.skipToPos(entriesStart, \"Failed to skip to entries start\");\n+\t\tint ignoredEoc = 0; // ignored entries because they are located after end of chunk\n \t\tfor (EntryOffset entryOffset : offsets) {\n \t\t\tint offset = entryOffset.getOffset();\n \t\t\tif (offset == NO_ENTRY) {\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tint index = entryOffset.getIdx();\n-\t\t\tif (is.getPos() >= chunkEnd) {\n+\t\t\tlong entryStartOffset = entriesStart + offset;\n+\t\t\tif (entryStartOffset >= chunkEnd) {\n \t\t\t\t// Certain resource obfuscated apps like com.facebook.orca have more entries defined\n-\t\t\t\t// than actually fit into the chunk size -> ignore the remaining entries\n-\t\t\t\tLOG.warn(\"End of chunk reached - ignoring remaining {} entries in type: {}\", entryCount - index, typeName);\n-\t\t\t\tbreak;\n+\t\t\t\t// than actually fit into the chunk size -> ignore this entry\n+\t\t\t\tignoredEoc++;\n+\t\t\t\t// LOG.debug(\"Pos is after chunk end: {} end {}\", entryStartOffset, chunkEnd);\n+\t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tlong entryStartOffset = entriesStart + offset;\n \t\t\tif (entryStartOffset < is.getPos()) {\n \t\t\t\t// workaround for issue #2343: if the entryStartOffset is located before our current position\n \t\t\t\tis.reset();\n \t\t\t}\n+\t\t\tint index = entryOffset.getIdx();\n \t\t\tis.skipToPos(entryStartOffset, \"Expected start of entry \" + index);\n \t\t\tparseEntry(pkg, id, index, config.getQualifiers());\n \t\t}\n-\t\tif (chunkEnd > is.getPos()) {\n-\t\t\t// Skip remaining unknown data in this chunk (e.g. type 8 entries\")\n-\t\t\tlong skipSize = chunkEnd - is.getPos();\n-\t\t\tLOG.debug(\"Unknown data at the end of type chunk encountered, skipping {} bytes and continuing at offset {}\", skipSize,\n-\t\t\t\t\tchunkEnd);\n-\t\t\tis.skip(skipSize);\n+\t\tif (ignoredEoc > 0) {\n+\t\t\t// invalid = data offset is after the chunk end\n+\t\t\tLOG.warn(\"{} entries of type {} has been ignored (invalid offset)\", ignoredEoc, typeName);\n \t\t}\n+\t\tis.skipToPos(chunkEnd, \"End of chunk\");\n \t}\n \n \tprivate static class EntryOffset {",
    "output": "Fix chunk parsing was aborted too early for unordered entries"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n@@ -348,11 +348,12 @@ public boolean equals(Object o) {\n \t\tif (o == null || getClass() != o.getClass()) {\n \t\t\treturn false;\n \t\t}\n-\t\treturn name.equals(((JResource) o).name);\n+\t\tJResource other = (JResource) o;\n+\t\treturn name.equals(other.name) && type.equals(other.type);\n \t}\n \n \t@Override\n \tpublic int hashCode() {\n-\t\treturn name.hashCode();\n+\t\treturn name.hashCode() + 31 * type.ordinal();\n \t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n@@ -64,19 +64,17 @@ private JResource getHierarchyResources(List<ResourceFile> resources) {\n \t\t\tString[] parts = new File(rfName).getPath().split(splitPathStr);\n \t\t\tJResource curRf = root;\n \t\t\tint count = parts.length;\n-\t\t\tfor (int i = 0; i < count; i++) {\n+\t\t\tfor (int i = 0; i < count - 1; i++) {\n \t\t\t\tString name = parts[i];\n \t\t\t\tJResource subRF = getResourceByName(curRf, name);\n \t\t\t\tif (subRF == null) {\n-\t\t\t\t\tif (i != count - 1) {\n-\t\t\t\t\t\tsubRF = new JResource(null, name, JResType.DIR);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tsubRF = new JResource(rf, rf.getDeobfName(), name, JResType.FILE);\n-\t\t\t\t\t}\n+\t\t\t\t\tsubRF = new JResource(null, name, JResType.DIR);\n \t\t\t\t\tcurRf.addSubNode(subRF);\n \t\t\t\t}\n \t\t\t\tcurRf = subRF;\n \t\t\t}\n+\t\t\tJResource leaf = new JResource(rf, rf.getDeobfName(), parts[count - 1], JResType.FILE);\n+\t\t\tcurRf.addSubNode(leaf);\n \t\t}\n \t\troot.sortSubNodes();\n \t\troot.update();",
    "output": "Fix allow file and directory have same name in tree"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -39,7 +39,6 @@\n import javax.swing.AbstractAction;\n import javax.swing.Action;\n import javax.swing.Box;\n-import javax.swing.ImageIcon;\n import javax.swing.JCheckBox;\n import javax.swing.JCheckBoxMenuItem;\n import javax.swing.JDialog;\n@@ -159,6 +158,7 @@\n import jadx.gui.utils.DesktopEntryUtils;\n import jadx.gui.utils.FontUtils;\n import jadx.gui.utils.ILoadListener;\n+import jadx.gui.utils.Icons;\n import jadx.gui.utils.LafManager;\n import jadx.gui.utils.Link;\n import jadx.gui.utils.NLS;\n@@ -179,26 +179,6 @@ public class MainWindow extends JFrame {\n \tprivate static final double WINDOW_RATIO = 1 - BORDER_RATIO * 2;\n \tpublic static final double SPLIT_PANE_RESIZE_WEIGHT = 0.15;\n \n-\tprivate static final ImageIcon ICON_ADD_FILES = UiUtils.openSvgIcon(\"ui/addFile\");\n-\tprivate static final ImageIcon ICON_RELOAD = UiUtils.openSvgIcon(\"ui/refresh\");\n-\tprivate static final ImageIcon ICON_EXPORT = UiUtils.openSvgIcon(\"ui/export\");\n-\tprivate static final ImageIcon ICON_EXIT = UiUtils.openSvgIcon(\"ui/exit\");\n-\tprivate static final ImageIcon ICON_SYNC = UiUtils.openSvgIcon(\"ui/pagination\");\n-\tprivate static final ImageIcon ICON_FLAT_PKG = UiUtils.openSvgIcon(\"ui/moduleGroup\");\n-\tprivate static final ImageIcon ICON_SEARCH = UiUtils.openSvgIcon(\"ui/find\");\n-\tprivate static final ImageIcon ICON_FIND = UiUtils.openSvgIcon(\"ui/ejbFinderMethod\");\n-\tprivate static final ImageIcon ICON_COMMENT_SEARCH = UiUtils.openSvgIcon(\"ui/usagesFinder\");\n-\tprivate static final ImageIcon ICON_MAIN_ACTIVITY = UiUtils.openSvgIcon(\"ui/home\");\n-\tprivate static final ImageIcon ICON_BACK = UiUtils.openSvgIcon(\"ui/left\");\n-\tprivate static final ImageIcon ICON_FORWARD = UiUtils.openSvgIcon(\"ui/right\");\n-\tprivate static final ImageIcon ICON_QUARK = UiUtils.openSvgIcon(\"ui/quark\");\n-\tprivate static final ImageIcon ICON_PREF = UiUtils.openSvgIcon(\"ui/settings\");\n-\tprivate static final ImageIcon ICON_DEOBF = UiUtils.openSvgIcon(\"ui/helmChartLock\");\n-\tprivate static final ImageIcon ICON_DECOMPILE_ALL = UiUtils.openSvgIcon(\"ui/runAll\");\n-\tprivate static final ImageIcon ICON_LOG = UiUtils.openSvgIcon(\"ui/logVerbose\");\n-\tprivate static final ImageIcon ICON_INFO = UiUtils.openSvgIcon(\"ui/showInfos\");\n-\tprivate static final ImageIcon ICON_DEBUGGER = UiUtils.openSvgIcon(\"ui/startDebugger\");\n-\n \tprivate final transient JadxWrapper wrapper;\n \tprivate final transient JadxSettings settings;\n \tprivate final transient CacheObject cacheObject;\n@@ -1082,7 +1062,7 @@ private void initMenuAndToolbar() {\n \t\tJadxGuiAction exitAction = new JadxGuiAction(ActionModel.EXIT, this::closeWindow);\n \n \t\tisFlattenPackage = settings.isFlattenPackage();\n-\t\tflatPkgMenuItem = new JCheckBoxMenuItem(NLS.str(\"menu.flatten\"), ICON_FLAT_PKG);\n+\t\tflatPkgMenuItem = new JCheckBoxMenuItem(NLS.str(\"menu.flatten\"), Icons.FLAT_PKG);\n \t\tflatPkgMenuItem.setState(isFlattenPackage);\n \n \t\tJCheckBoxMenuItem heapUsageBarMenuItem = new JCheckBoxMenuItem(NLS.str(\"menu.heapUsageBar\"));\n@@ -1105,16 +1085,15 @@ private void initMenuAndToolbar() {\n \t\tdockLog.setState(settings.isDockLogViewer());\n \t\tdockLog.addActionListener(event -> settings.setDockLogViewer(!settings.isDockLogViewer()));\n \n-\t\tJCheckBoxMenuItem dockQuickTabs = new JCheckBoxMenuItem(NLS.str(\"menu.dock_quick_tabs\"));\n-\t\tdockQuickTabs.setState(settings.isDockQuickTabs());\n-\t\tdockQuickTabs.addActionListener(event -> {\n+\t\tActionHandler quickTabsAction = new ActionHandler(ev -> {\n \t\t\tboolean visible = quickTabsTree == null;\n \t\t\tsetQuickTabsVisibility(visible);\n \t\t\tsettings.setDockQuickTabs(visible);\n \t\t});\n-\t\tif (dockQuickTabs.getState()) {\n-\t\t\tsetQuickTabsVisibility(true);\n-\t\t}\n+\t\tquickTabsAction.setNameAndDesc(NLS.str(\"menu.dock_quick_tabs\"));\n+\t\tquickTabsAction.setIcon(Icons.QUICK_TABS);\n+\t\tquickTabsAction.setSelected(settings.isDockQuickTabs());\n+\t\tsetQuickTabsVisibility(settings.isDockQuickTabs());\n \n \t\tJadxGuiAction syncAction = new JadxGuiAction(ActionModel.SYNC, this.editorSyncManager::sync);\n \t\tJadxGuiAction textSearchAction = new JadxGuiAction(ActionModel.TEXT_SEARCH, this::textSearch);\n@@ -1174,12 +1153,14 @@ private void initMenuAndToolbar() {\n \n \t\tJMenu view = new JadxMenu(NLS.str(\"menu.view\"), shortcutsController);\n \t\tview.setMnemonic(KeyEvent.VK_V);\n+\t\tview.add(quickTabsAction.makeCheckBoxMenuItem());\n \t\tview.add(flatPkgMenuItem);\n+\t\tview.addSeparator();\n \t\tview.add(syncAction);\n-\t\tview.add(heapUsageBarMenuItem);\n \t\tview.add(alwaysSelectOpened);\n+\t\tview.addSeparator();\n \t\tview.add(dockLog);\n-\t\tview.add(dockQuickTabs);\n+\t\tview.add(heapUsageBarMenuItem);\n \n \t\tJMenu nav = new JadxMenu(NLS.str(\"menu.navigation\"), shortcutsController);\n \t\tnav.setMnemonic(KeyEvent.VK_N);\n@@ -1235,7 +1216,7 @@ public void actionPerformed(ActionEvent e) {\n \t\tmenuBar.add(help);\n \t\tsetJMenuBar(menuBar);\n \n-\t\tflatPkgButton = new JToggleButton(ICON_FLAT_PKG);\n+\t\tflatPkgButton = new JToggleButton(Icons.FLAT_PKG);\n \t\tflatPkgButton.setSelected(isFlattenPackage);\n \t\tActionListener flatPkgAction = e -> toggleFlattenPackage();\n \t\tflatPkgMenuItem.addActionListener(flatPkgAction);\n@@ -1256,6 +1237,7 @@ public void actionPerformed(ActionEvent e) {\n \t\ttoolbar.addSeparator();\n \t\ttoolbar.add(syncAction);\n \t\ttoolbar.add(flatPkgButton);\n+\t\ttoolbar.add(quickTabsAction.makeToggleButton());\n \t\ttoolbar.addSeparator();\n \t\ttoolbar.add(textSearchAction);\n \t\ttoolbar.add(clsSearchAction);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/action/ActionModel.java b/jadx-gui/src/main/java/jadx/gui/ui/action/ActionModel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/action/ActionModel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/action/ActionModel.java\n@@ -43,7 +43,7 @@ public enum ActionModel {\n \t\t\tShortcut.keyboard(KeyEvent.VK_P, UiUtils.ctrlButton() | KeyEvent.SHIFT_DOWN_MASK)),\n \tEXIT(MENU_TOOLBAR, \"file.exit\", \"file.exit\", \"ui/exit\",\n \t\t\tShortcut.none()),\n-\tSYNC(MENU_TOOLBAR, \"menu.sync\", \"menu.sync\", \"ui/pagination\",\n+\tSYNC(MENU_TOOLBAR, \"menu.sync\", \"menu.sync\", \"ui/selectWeb\",\n \t\t\tShortcut.keyboard(KeyEvent.VK_T, UiUtils.ctrlButton())),\n \tTEXT_SEARCH(MENU_TOOLBAR, \"menu.text_search\", \"menu.text_search\", \"ui/find\",\n \t\t\tShortcut.keyboard(KeyEvent.VK_F, UiUtils.ctrlButton() | KeyEvent.SHIFT_DOWN_MASK)),\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java\n@@ -25,6 +25,9 @@\n import jadx.gui.treemodel.JClass;\n import jadx.gui.treemodel.JEditableNode;\n import jadx.gui.treemodel.JNode;\n+import jadx.gui.ui.MainWindow;\n+import jadx.gui.ui.action.ActionModel;\n+import jadx.gui.ui.action.JadxGuiAction;\n import jadx.gui.ui.panel.ContentPanel;\n import jadx.gui.ui.tab.dnd.TabDndGestureListener;\n import jadx.gui.utils.Icons;\n@@ -234,9 +237,11 @@ private JPopupMenu createTabPopupMenu() {\n \t\t}\n \n \t\tif (nodeFullName != null) {\n-\t\t\tJMenuItem revealTab = new JMenuItem(NLS.str(\"menu.sync\"));\n-\t\t\trevealTab.addActionListener(e -> tabsController.getMainWindow().selectNodeInTree(getNode()));\n-\t\t\tmenu.add(revealTab);\n+\t\t\tMainWindow mainWindow = tabsController.getMainWindow();\n+\t\t\tJadxGuiAction selectInTree = new JadxGuiAction(ActionModel.SYNC, () -> mainWindow.selectNodeInTree(getNode()));\n+\t\t\t// attach shortcut without bind only to show current keybinding\n+\t\t\tselectInTree.setShortcut(mainWindow.getShortcutsController().get(ActionModel.SYNC));\n+\t\t\tmenu.add(selectInTree);\n \t\t\tmenu.addSeparator();\n \t\t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/Icons.java b/jadx-gui/src/main/java/jadx/gui/utils/Icons.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/Icons.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/Icons.java\n@@ -15,6 +15,9 @@ public class Icons {\n \n \tpublic static final ImageIcon SAVE_ALL = UiUtils.openSvgIcon(\"ui/menu-saveall\");\n \n+\tpublic static final ImageIcon FLAT_PKG = UiUtils.openSvgIcon(\"ui/moduleGroup\");\n+\tpublic static final ImageIcon QUICK_TABS = UiUtils.openSvgIcon(\"ui/dataView\");\n+\n \tpublic static final ImageIcon PIN = UiUtils.openSvgIcon(\"nodes/pin\");\n \tpublic static final ImageIcon PIN_DARK = UiUtils.openSvgIcon(\"nodes/pin_dark\");\n \tpublic static final ImageIcon PIN_HOVERED = UiUtils.openSvgIcon(\"nodes/pinHovered\");\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/ui/ActionHandler.java b/jadx-gui/src/main/java/jadx/gui/utils/ui/ActionHandler.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/ui/ActionHandler.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/ui/ActionHandler.java\n@@ -4,9 +4,11 @@\n import java.util.function.Consumer;\n \n import javax.swing.AbstractAction;\n-import javax.swing.ImageIcon;\n+import javax.swing.Icon;\n import javax.swing.JButton;\n+import javax.swing.JCheckBoxMenuItem;\n import javax.swing.JComponent;\n+import javax.swing.JToggleButton;\n import javax.swing.KeyStroke;\n \n import jadx.gui.utils.UiUtils;\n@@ -52,10 +54,14 @@ public void setShortDescription(String desc) {\n \t\tputValue(SHORT_DESCRIPTION, desc);\n \t}\n \n-\tpublic void setIcon(ImageIcon icon) {\n+\tpublic void setIcon(Icon icon) {\n \t\tputValue(SMALL_ICON, icon);\n \t}\n \n+\tpublic void setSelected(boolean selected) {\n+\t\tputValue(SELECTED_KEY, selected);\n+\t}\n+\n \tpublic void setKeyBinding(KeyStroke keyStroke) {\n \t\tputValue(ACCELERATOR_KEY, keyStroke);\n \t}\n@@ -83,4 +89,14 @@ public JButton makeButton() {\n \t\taddKeyBindToDescription();\n \t\treturn new JButton(this);\n \t}\n+\n+\tpublic JToggleButton makeToggleButton() {\n+\t\tJToggleButton toggleButton = new JToggleButton(this);\n+\t\ttoggleButton.setText(\"\");\n+\t\treturn toggleButton;\n+\t}\n+\n+\tpublic JCheckBoxMenuItem makeCheckBoxMenuItem() {\n+\t\treturn new JCheckBoxMenuItem(this);\n+\t}\n }",
    "output": "Fix minor action names and icons adjustments"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Jadx.java b/jadx-core/src/main/java/jadx/core/Jadx.java\n--- a/jadx-core/src/main/java/jadx/core/Jadx.java\n+++ b/jadx-core/src/main/java/jadx/core/Jadx.java\n@@ -102,7 +102,6 @@ public static List<IDexTreeVisitor> getPreDecompilePassesList() {\n \t\tpasses.add(new SignatureProcessor());\n \t\tpasses.add(new OverrideMethodVisitor());\n \t\tpasses.add(new AddAndroidConstants());\n-\t\tpasses.add(new CollectConstValues());\n \n \t\t// rename and deobfuscation\n \t\tpasses.add(new DeobfuscatorVisitor());\n@@ -111,6 +110,7 @@ public static List<IDexTreeVisitor> getPreDecompilePassesList() {\n \t\tpasses.add(new SaveDeobfMapping());\n \n \t\tpasses.add(new UsageInfoVisitor());\n+\t\tpasses.add(new CollectConstValues());\n \t\tpasses.add(new ProcessAnonymous());\n \t\tpasses.add(new ProcessMethodsForInline());\n \t\treturn passes;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/prepare/CollectConstValues.java b/jadx-core/src/main/java/jadx/core/dex/visitors/prepare/CollectConstValues.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/prepare/CollectConstValues.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/prepare/CollectConstValues.java\n@@ -11,11 +11,15 @@\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.visitors.AbstractVisitor;\n import jadx.core.dex.visitors.JadxVisitor;\n+import jadx.core.dex.visitors.usage.UsageInfoVisitor;\n import jadx.core.utils.exceptions.JadxException;\n \n @JadxVisitor(\n \t\tname = \"CollectConstValues\",\n-\t\tdesc = \"Collect and store values from static final fields\"\n+\t\tdesc = \"Collect and store values from static final fields\",\n+\t\trunAfter = {\n+\t\t\t\tUsageInfoVisitor.class // check field usage (do not restore if used somewhere)\n+\t\t}\n )\n public class CollectConstValues extends AbstractVisitor {\n \n@@ -44,12 +48,17 @@ public boolean visit(ClassNode cls) throws JadxException {\n \n \tpublic static @Nullable Object getFieldConstValue(FieldNode fld) {\n \t\tAccessInfo accFlags = fld.getAccessFlags();\n-\t\tif (accFlags.isStatic() && accFlags.isFinal()) {\n-\t\t\tEncodedValue constVal = fld.get(JadxAttrType.CONSTANT_VALUE);\n-\t\t\tif (constVal != null && constVal != EncodedValue.NULL) {\n-\t\t\t\treturn constVal.getValue();\n-\t\t\t}\n+\t\tif (!accFlags.isStatic() || !accFlags.isFinal()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tEncodedValue constVal = fld.get(JadxAttrType.CONSTANT_VALUE);\n+\t\tif (constVal == null || constVal == EncodedValue.NULL) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tif (!fld.getUseIn().isEmpty()) {\n+\t\t\t// field still used somewhere and not inlined by compiler, so we don't need to restore it\n+\t\t\treturn null;\n \t\t}\n-\t\treturn null;\n+\t\treturn constVal.getValue();\n \t}\n }",
    "output": "Fix do not replace constant fields which still used in code"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -81,8 +81,9 @@ public MethodNode getMethodNode() {\n \n \tpublic boolean addDefinition(ICodeWriter code) {\n \t\tif (mth.getMethodInfo().isClassInit()) {\n+\t\t\tcode.startLine();\n \t\t\tcode.attachDefinition(mth);\n-\t\t\tcode.startLine(\"static\");\n+\t\t\tcode.add(\"static\");\n \t\t\treturn true;\n \t\t}\n \t\tif (mth.contains(AFlag.ANONYMOUS_CONSTRUCTOR)) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n@@ -186,6 +186,10 @@ public int adjustOffsetForWordToken(int offset) {\n \t\t\tif (type == TokenTypes.ANNOTATION && token.length() > 1) {\n \t\t\t\treturn token.getOffset() + 1;\n \t\t\t}\n+\t\t\tif (type == TokenTypes.RESERVED_WORD && token.length() == 6 && token.getLexeme().equals(\"static\")) {\n+\t\t\t\t// maybe a class init method\n+\t\t\t\treturn token.getOffset();\n+\t\t\t}\n \t\t} else if (type == TokenTypes.MARKUP_TAG_ATTRIBUTE_VALUE) {\n \t\t\treturn token.getOffset() + 1; // skip quote at start (\")\n \t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java\n@@ -6,7 +6,6 @@\n import javax.swing.text.Highlighter;\n \n import org.fife.ui.rsyntaxtextarea.Token;\n-import org.fife.ui.rsyntaxtextarea.TokenTypes;\n import org.fife.ui.rtextarea.SmartHighlightPainter;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -44,7 +43,7 @@ private boolean addHighlight(MouseEvent e) {\n \t\t}\n \t\ttry {\n \t\t\tToken token = codeArea.viewToToken(e.getPoint());\n-\t\t\tif (token == null || token.getType() != TokenTypes.IDENTIFIER) {\n+\t\t\tif (token == null) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\tint tokenOffset = token.getOffset();",
    "output": "Fix correct class init method actions and highlight"
  },
  {
    "input": "diff --git a/jadx-plugins/jadx-smali-input/src/main/java/jadx/plugins/input/smali/SmaliConvert.java b/jadx-plugins/jadx-smali-input/src/main/java/jadx/plugins/input/smali/SmaliConvert.java\n--- a/jadx-plugins/jadx-smali-input/src/main/java/jadx/plugins/input/smali/SmaliConvert.java\n+++ b/jadx-plugins/jadx-smali-input/src/main/java/jadx/plugins/input/smali/SmaliConvert.java\n@@ -1,11 +1,8 @@\n package jadx.plugins.input.smali;\n \n-import java.io.ByteArrayOutputStream;\n import java.io.OutputStream;\n import java.io.PrintStream;\n-import java.io.Reader;\n import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.PathMatcher;\n import java.util.ArrayList;\n@@ -33,12 +30,8 @@ public boolean execute(List<Path> input, SmaliInputOptions options) {\n \t\tif (smaliFiles.isEmpty()) {\n \t\t\treturn false;\n \t\t}\n-\t\ttry (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n-\t\t\tcollectSystemErrors(out, () -> compile(smaliFiles, options));\n-\t\t\tboolean success = out.size() == 0;\n-\t\t\tif (!success) {\n-\t\t\t\tLOG.error(\"Smali error:\\n{}\", out);\n-\t\t\t}\n+\t\ttry {\n+\t\t\tcompile(smaliFiles, options);\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Smali process error\", e);\n \t\t}\n@@ -56,7 +49,7 @@ private void compile(List<Path> inputFiles, SmaliInputOptions options) {\n \t\tint threads = options.getThreads();\n \t\tLOG.debug(\"Compiling smali files: {}, threads: {}\", inputFiles.size(), threads);\n \t\tlong start = System.currentTimeMillis();\n-\t\tif (threads == 1) {\n+\t\tif (threads == 1 || inputFiles.size() == 1) {\n \t\t\tfor (Path inputFile : inputFiles) {\n \t\t\t\tassemble(inputFile, smaliOptions);\n \t\t\t}\n@@ -78,12 +71,12 @@ private void compile(List<Path> inputFiles, SmaliInputOptions options) {\n \t}\n \n \tprivate void assemble(Path inputFile, SmaliOptions smaliOptions) {\n-\t\tString fileName = inputFile.toAbsolutePath().toString();\n-\t\ttry (Reader reader = Files.newBufferedReader(inputFile)) {\n-\t\t\tbyte[] assemble = SmaliUtils.assemble(reader, smaliOptions);\n-\t\t\tdexData.add(new SimpleDexData(fileName, assemble));\n+\t\tPath path = inputFile.toAbsolutePath();\n+\t\ttry {\n+\t\t\tbyte[] dexContent = SmaliUtils.assemble(path.toFile(), smaliOptions);\n+\t\t\tdexData.add(new SimpleDexData(path.toString(), dexContent));\n \t\t} catch (Exception e) {\n-\t\t\tthrow new RuntimeException(\"Fail to compile: \" + fileName, e);\n+\t\t\tLOG.error(\"Failed to assemble smali file: {}\", path, e);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-plugins/jadx-smali-input/src/main/java/jadx/plugins/input/smali/SmaliUtils.java b/jadx-plugins/jadx-smali-input/src/main/java/jadx/plugins/input/smali/SmaliUtils.java\n--- a/jadx-plugins/jadx-smali-input/src/main/java/jadx/plugins/input/smali/SmaliUtils.java\n+++ b/jadx-plugins/jadx-smali-input/src/main/java/jadx/plugins/input/smali/SmaliUtils.java\n@@ -1,17 +1,20 @@\n package jadx.plugins.input.smali;\n \n+import java.io.File;\n+import java.io.FileInputStream;\n import java.io.IOException;\n-import java.io.Reader;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n \n import org.antlr.runtime.CommonTokenStream;\n import org.antlr.runtime.RecognitionException;\n-import org.antlr.runtime.TokenSource;\n+import org.antlr.runtime.TokenStream;\n import org.antlr.runtime.tree.CommonTreeNodeStream;\n+import org.antlr.runtime.tree.TreeNodeStream;\n \n import com.android.tools.smali.dexlib2.Opcodes;\n import com.android.tools.smali.dexlib2.writer.builder.DexBuilder;\n import com.android.tools.smali.dexlib2.writer.io.MemoryDataStore;\n-import com.android.tools.smali.smali.LexerErrorInterface;\n import com.android.tools.smali.smali.SmaliOptions;\n import com.android.tools.smali.smali.smaliFlexLexer;\n import com.android.tools.smali.smali.smaliParser;\n@@ -24,31 +27,67 @@\n public class SmaliUtils {\n \n \t@SuppressWarnings(\"ExtractMethodRecommender\")\n-\tpublic static byte[] assemble(Reader reader, SmaliOptions options) throws IOException, RecognitionException {\n-\t\tLexerErrorInterface lexer = new smaliFlexLexer(reader, options.apiLevel);\n-\t\tCommonTokenStream tokens = new CommonTokenStream((TokenSource) lexer);\n-\t\tsmaliParser parser = new smaliParser(tokens);\n-\t\tparser.setVerboseErrors(options.verboseErrors);\n-\t\tparser.setAllowOdex(options.allowOdexOpcodes);\n-\t\tparser.setApiLevel(options.apiLevel);\n-\t\tsmaliParser.smali_file_return parseResult = parser.smali_file();\n-\t\tif (parser.getNumberOfSyntaxErrors() > 0 || lexer.getNumberOfSyntaxErrors() > 0) {\n-\t\t\tthrow new RuntimeException(\"Parse error\");\n+\tpublic static byte[] assemble(File smaliFile, SmaliOptions options) throws IOException {\n+\t\tStringBuilder errors = new StringBuilder();\n+\t\ttry (FileInputStream fis = new FileInputStream(smaliFile);\n+\t\t\t\tInputStreamReader reader = new InputStreamReader(fis, StandardCharsets.UTF_8)) {\n+\n+\t\t\tsmaliFlexLexer lexer = new smaliFlexLexer(reader, options.apiLevel);\n+\t\t\tlexer.setSourceFile(smaliFile);\n+\t\t\tCommonTokenStream tokens = new CommonTokenStream(lexer);\n+\t\t\tParserWrapper parser = new ParserWrapper(tokens, errors);\n+\t\t\tparser.setVerboseErrors(options.verboseErrors);\n+\t\t\tparser.setAllowOdex(options.allowOdexOpcodes);\n+\t\t\tparser.setApiLevel(options.apiLevel);\n+\t\t\tParserWrapper.smali_file_return parseResult = parser.smali_file();\n+\t\t\tif (parser.getNumberOfSyntaxErrors() > 0 || lexer.getNumberOfSyntaxErrors() > 0) {\n+\t\t\t\tthrow new RuntimeException(\"Smali parse error: \" + errors);\n+\t\t\t}\n+\t\t\tCommonTreeNodeStream treeStream = new CommonTreeNodeStream(parseResult.getTree());\n+\t\t\ttreeStream.setTokenStream(tokens);\n+\n+\t\t\tDexBuilder dexBuilder = new DexBuilder(Opcodes.forApi(options.apiLevel));\n+\t\t\tTreeWalkerWrapper dexGen = new TreeWalkerWrapper(treeStream, errors);\n+\t\t\tdexGen.setApiLevel(options.apiLevel);\n+\t\t\tdexGen.setVerboseErrors(options.verboseErrors);\n+\t\t\tdexGen.setDexBuilder(dexBuilder);\n+\t\t\tdexGen.smali_file();\n+\t\t\tif (dexGen.getNumberOfSyntaxErrors() > 0) {\n+\t\t\t\tthrow new RuntimeException(\"Smali compile error: \" + errors);\n+\t\t\t}\n+\t\t\tMemoryDataStore dataStore = new MemoryDataStore();\n+\t\t\tdexBuilder.writeTo(dataStore);\n+\t\t\treturn dataStore.getData();\n+\t\t} catch (RecognitionException e) {\n+\t\t\tthrow new RuntimeException(\"Smali process error: \" + errors, e);\n \t\t}\n-\t\tCommonTreeNodeStream treeStream = new CommonTreeNodeStream(parseResult.getTree());\n-\t\ttreeStream.setTokenStream(tokens);\n-\n-\t\tDexBuilder dexBuilder = new DexBuilder(Opcodes.forApi(options.apiLevel));\n-\t\tsmaliTreeWalker dexGen = new smaliTreeWalker(treeStream);\n-\t\tdexGen.setApiLevel(options.apiLevel);\n-\t\tdexGen.setVerboseErrors(options.verboseErrors);\n-\t\tdexGen.setDexBuilder(dexBuilder);\n-\t\tdexGen.smali_file();\n-\t\tif (dexGen.getNumberOfSyntaxErrors() > 0) {\n-\t\t\tthrow new RuntimeException(\"Compile error\");\n+\t}\n+\n+\tprivate static final class ParserWrapper extends smaliParser {\n+\t\tprivate final StringBuilder errors;\n+\n+\t\tpublic ParserWrapper(TokenStream input, StringBuilder errors) {\n+\t\t\tsuper(input);\n+\t\t\tthis.errors = errors;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void emitErrorMessage(String msg) {\n+\t\t\terrors.append('\\n').append(msg);\n+\t\t}\n+\t}\n+\n+\tprivate static final class TreeWalkerWrapper extends smaliTreeWalker {\n+\t\tprivate final StringBuilder errors;\n+\n+\t\tpublic TreeWalkerWrapper(TreeNodeStream input, StringBuilder errors) {\n+\t\t\tsuper(input);\n+\t\t\tthis.errors = errors;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void emitErrorMessage(String msg) {\n+\t\t\terrors.append('\\n').append(msg);\n \t\t}\n-\t\tMemoryDataStore dataStore = new MemoryDataStore();\n-\t\tdexBuilder.writeTo(dataStore);\n-\t\treturn dataStore.getData();\n \t}\n }",
    "output": "Fix improve error report for smali assemble"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n@@ -5,7 +5,6 @@\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n@@ -133,6 +132,9 @@ public void setFilePaths(List<Path> files) {\n \t}\n \n \tpublic void setTreeExpansions(List<String> list) {\n+\t\tif (list.equals(data.getTreeExpansionsV2())) {\n+\t\t\treturn;\n+\t\t}\n \t\tdata.setTreeExpansionsV2(list);\n \t\tchanged();\n \t}\n@@ -141,19 +143,6 @@ public List<String> getTreeExpansions() {\n \t\treturn data.getTreeExpansionsV2();\n \t}\n \n-\tprivate boolean isParentOfExpansion(String[] parent, String[] child) {\n-\t\tif (Arrays.equals(parent, child)) {\n-\t\t\treturn true;\n-\t\t}\n-\t\tfor (int i = child.length - parent.length; i > 0; i--) {\n-\t\t\tString[] arr = Arrays.copyOfRange(child, i, child.length);\n-\t\t\tif (Arrays.equals(parent, arr)) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n \tpublic JadxCodeData getCodeData() {\n \t\treturn data.getCodeData();\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -694,45 +694,52 @@ private void addTreeCustomNodes() {\n \t}\n \n \tprivate boolean ensureProjectIsSaved() {\n-\t\tif (!project.isSaved() && !project.isInitial()) {\n-\t\t\t// Check if we saved settings that indicate what to do\n-\n-\t\t\tif (settings.getSaveOption() == JadxSettings.SAVEOPTION.NEVER) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\n-\t\t\tif (settings.getSaveOption() == JadxSettings.SAVEOPTION.ALWAYS) {\n-\t\t\t\tsaveProject();\n-\t\t\t\treturn true;\n-\t\t\t}\n+\t\tif (project.isSaved() || project.isInitial()) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (project.getFilePaths().isEmpty()) {\n+\t\t\t// ignore blank project save\n+\t\t\treturn true;\n+\t\t}\n+\t\t// Check if we saved settings that indicate what to do\n+\t\tif (settings.getSaveOption() == JadxSettings.SAVEOPTION.NEVER) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (settings.getSaveOption() == JadxSettings.SAVEOPTION.ALWAYS) {\n+\t\t\tsaveProject();\n+\t\t\treturn true;\n+\t\t}\n \n-\t\t\tJCheckBox remember = new JCheckBox(NLS.str(\"confirm.remember\"));\n-\t\t\tJLabel message = new JLabel(NLS.str(\"confirm.not_saved_message\"));\n+\t\tJCheckBox remember = new JCheckBox(NLS.str(\"confirm.remember\"));\n+\t\tJLabel message = new JLabel(NLS.str(\"confirm.not_saved_message\"));\n \n-\t\t\tJPanel inner = new JPanel(new BorderLayout());\n-\t\t\tinner.add(remember, BorderLayout.SOUTH);\n-\t\t\tinner.add(message, BorderLayout.NORTH);\n+\t\tJPanel inner = new JPanel(new BorderLayout());\n+\t\tinner.add(remember, BorderLayout.SOUTH);\n+\t\tinner.add(message, BorderLayout.NORTH);\n \n-\t\t\tint res = JOptionPane.showConfirmDialog(\n-\t\t\t\t\tthis,\n-\t\t\t\t\tinner,\n-\t\t\t\t\tNLS.str(\"confirm.not_saved_title\"),\n-\t\t\t\t\tJOptionPane.YES_NO_CANCEL_OPTION);\n-\t\t\tif (res == JOptionPane.CANCEL_OPTION) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tif (res == JOptionPane.YES_OPTION) {\n+\t\tint res = JOptionPane.showConfirmDialog(\n+\t\t\t\tthis,\n+\t\t\t\tinner,\n+\t\t\t\tNLS.str(\"confirm.not_saved_title\"),\n+\t\t\t\tJOptionPane.YES_NO_CANCEL_OPTION);\n+\t\tswitch (res) {\n+\t\t\tcase JOptionPane.YES_OPTION:\n \t\t\t\tif (remember.isSelected()) {\n \t\t\t\t\tsettings.setSaveOption(JadxSettings.SAVEOPTION.ALWAYS);\n \t\t\t\t\tsettings.sync();\n \t\t\t\t}\n \t\t\t\tsaveProject();\n-\t\t\t} else if (res == JOptionPane.NO_OPTION) {\n+\t\t\t\treturn true;\n+\n+\t\t\tcase JOptionPane.NO_OPTION:\n \t\t\t\tif (remember.isSelected()) {\n \t\t\t\t\tsettings.setSaveOption(JadxSettings.SAVEOPTION.NEVER);\n \t\t\t\t\tsettings.sync();\n \t\t\t\t}\n-\t\t\t}\n+\t\t\t\treturn true;\n+\n+\t\t\tcase JOptionPane.CANCEL_OPTION:\n+\t\t\t\treturn false;\n \t\t}\n \t\treturn true;\n \t}",
    "output": "Fix don't ask to save blank project"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -261,8 +261,10 @@ public void removeRecentProject(Path projectPath) {\n \n \tpublic void saveWindowPos(Window window) {\n \t\tWindowLocation pos = new WindowLocation(window.getClass().getSimpleName(), window.getBounds());\n-\t\twindowPos.put(pos.getWindowId(), pos);\n-\t\tpartialSync(settings -> settings.windowPos = windowPos);\n+\t\tWindowLocation prevPos = windowPos.put(pos.getWindowId(), pos);\n+\t\tif (prevPos == null || !prevPos.equals(pos)) {\n+\t\t\tpartialSync(settings -> settings.windowPos = windowPos);\n+\t\t}\n \t}\n \n \tpublic boolean loadWindowPos(Window window) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/WindowLocation.java b/jadx-gui/src/main/java/jadx/gui/settings/WindowLocation.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/WindowLocation.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/WindowLocation.java\n@@ -31,6 +31,21 @@ public void setBounds(Rectangle bounds) {\n \t\tthis.bounds = bounds;\n \t}\n \n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn windowId.hashCode();\n+\t}\n+\n+\t@Override\n+\tpublic final boolean equals(Object o) {\n+\t\tif (o instanceof WindowLocation) {\n+\t\t\tWindowLocation that = (WindowLocation) o;\n+\t\t\treturn windowId.equals(that.windowId) && bounds.equals(that.bounds);\n+\t\t}\n+\t\treturn false;\n+\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn \"WindowLocation{\"",
    "output": "Fix skip window pos saving if not changed"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommentDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommentDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommentDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommentDialog.java\n@@ -189,6 +189,7 @@ public void keyPressed(KeyEvent e) {\n \t\t\tsetTitle(NLS.str(\"comment_dialog.title.add\"));\n \t\t}\n \t\tpack();\n+\t\tsetMinimumSize(getSize());\n \t\tif (!codeArea.getMainWindow().getSettings().loadWindowPos(this)) {\n \t\t\tsetSize(400, 340);\n \t\t}",
    "output": "Fix set minimum size for comment dialog"
  },
  {
    "input": "diff --git a/jadx-commons/jadx-app-commons/src/main/java/jadx/commons/app/JadxCommonFiles.java b/jadx-commons/jadx-app-commons/src/main/java/jadx/commons/app/JadxCommonFiles.java\n--- a/jadx-commons/jadx-app-commons/src/main/java/jadx/commons/app/JadxCommonFiles.java\n+++ b/jadx-commons/jadx-app-commons/src/main/java/jadx/commons/app/JadxCommonFiles.java\n@@ -8,6 +8,9 @@\n import org.jetbrains.annotations.Nullable;\n \n import dev.dirs.ProjectDirectories;\n+import dev.dirs.impl.Windows;\n+import dev.dirs.impl.WindowsPowerShell;\n+import dev.dirs.jni.WindowsJni;\n \n public class JadxCommonFiles {\n \n@@ -58,11 +61,22 @@ private Path loadEnvDir(String envVar, Function<ProjectDirectories, String> dirF\n \n \t\tprivate synchronized ProjectDirectories loadDirs() {\n \t\t\tif (dirs == null) {\n-\t\t\t\tdirs = ProjectDirectories.from(\"io.github\", \"skylot\", \"jadx\");\n+\t\t\t\tdirs = ProjectDirectories.from(\"io.github\", \"skylot\", \"jadx\", DirsLoader::getWinDirs);\n \t\t\t}\n \t\t\treturn dirs;\n \t\t}\n \n+\t\t/**\n+\t\t * Return JNI or Foreign implementation\n+\t\t */\n+\t\tprivate static Windows getWinDirs() {\n+\t\t\tWindows defSup = Windows.getDefaultSupplier().get();\n+\t\t\tif (defSup instanceof WindowsPowerShell) {\n+\t\t\t\treturn new WindowsJni();\n+\t\t\t}\n+\t\t\treturn defSup;\n+\t\t}\n+\n \t\tpublic Path getCacheDir() {\n \t\t\treturn cacheDir;\n \t\t}",
    "output": "Use fork of directories library with JNI implemetation for Windows"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n@@ -240,19 +240,19 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t\t// The type identifier this chunk is holding. Type IDs start at 1 (corresponding\n \t\t// to the value of the type bits in a resource identifier). 0 is invalid.\n \t\tint id = is.readInt8();\n+\t\tString typeName = pkg.getTypeStrings().get(id - 1);\n \n \t\tint flags = is.readInt8();\n \t\tboolean isSparse = (flags & FLAG_SPARSE) != 0;\n \t\tboolean isOffset16 = (flags & FLAG_OFFSET16) != 0;\n \n-\t\tis.checkInt16(0, \"type chunk, reserved\");\n+\t\tis.readInt16(); // ignore reserved value - should be zero but in some apps it is not zero; see #2402\n \t\tint entryCount = is.readInt32();\n \t\tlong entriesStart = start + is.readInt32();\n \n \t\tEntryConfig config = parseConfig();\n \n \t\tif (config.isInvalid) {\n-\t\t\tString typeName = pkg.getTypeStrings().get(id - 1);\n \t\t\tLOG.warn(\"Invalid config flags detected: {}{}\", typeName, config.getQualifiers());\n \t\t}\n \n@@ -285,7 +285,7 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t\t\tif (is.getPos() >= chunkEnd) {\n \t\t\t\t// Certain resource obfuscated apps like com.facebook.orca have more entries defined\n \t\t\t\t// than actually fit into the chunk size -> ignore the remaining entries\n-\t\t\t\tLOG.warn(\"End of chunk reached - ignoring remaining {} entries\", entryCount - index);\n+\t\t\t\tLOG.warn(\"End of chunk reached - ignoring remaining {} entries in type: {}\", entryCount - index, typeName);\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tlong entryStartOffset = entriesStart + offset;",
    "output": "Fix ignore reserved value in type chunk fix: ignore reserved value in type chunk"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JavaClass.java b/jadx-core/src/main/java/jadx/api/JavaClass.java\n--- a/jadx-core/src/main/java/jadx/api/JavaClass.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java\n@@ -122,24 +122,27 @@ public ClassNode getClassNode() {\n \t\tif (listsLoaded) {\n \t\t\treturn null;\n \t\t}\n-\t\tlistsLoaded = true;\n-\n \t\tICodeInfo code;\n \t\tif (cls.getState().isProcessComplete()) {\n \t\t\t// already decompiled -> class internals loaded\n \t\t\tcode = null;\n \t\t} else {\n \t\t\tcode = cls.decompile();\n \t\t}\n+\t\tloadLists();\n+\t\treturn code;\n+\t}\n \n+\tprivate void loadLists() {\n+\t\tlistsLoaded = true;\n \t\tJadxDecompiler rootDecompiler = getRootDecompiler();\n \t\tint inClsCount = cls.getInnerClasses().size();\n \t\tif (inClsCount != 0) {\n \t\t\tList<JavaClass> list = new ArrayList<>(inClsCount);\n \t\t\tfor (ClassNode inner : cls.getInnerClasses()) {\n \t\t\t\tif (!inner.contains(AFlag.DONT_GENERATE)) {\n \t\t\t\t\tJavaClass javaClass = rootDecompiler.convertClassNode(inner);\n-\t\t\t\t\tjavaClass.load();\n+\t\t\t\t\tjavaClass.loadLists();\n \t\t\t\t\tlist.add(javaClass);\n \t\t\t\t}\n \t\t\t}\n@@ -150,7 +153,7 @@ public ClassNode getClassNode() {\n \t\t\tList<JavaClass> list = new ArrayList<>(inlinedClsCount);\n \t\t\tfor (ClassNode inner : cls.getInlinedClasses()) {\n \t\t\t\tJavaClass javaClass = rootDecompiler.convertClassNode(inner);\n-\t\t\t\tjavaClass.load();\n+\t\t\t\tjavaClass.loadLists();\n \t\t\t\tlist.add(javaClass);\n \t\t\t}\n \t\t\tthis.inlinedClasses = Collections.unmodifiableList(list);\n@@ -178,7 +181,6 @@ public ClassNode getClassNode() {\n \t\t\tmths.sort(Comparator.comparing(JavaMethod::getName));\n \t\t\tthis.methods = Collections.unmodifiableList(mths);\n \t\t}\n-\t\treturn code;\n \t}\n \n \tJadxDecompiler getRootDecompiler() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n@@ -72,8 +72,9 @@ public void loadNode() {\n \tpublic SimpleTask getLoadTask() {\n \t\tJClass rootClass = getRootClass();\n \t\treturn new SimpleTask(NLS.str(\"progress.decompile\"),\n-\t\t\t\t() -> rootClass.getCls().decompile(),\n-\t\t\t\trootClass::load);\n+\t\t\t\t() -> rootClass.getCls().getClassNode().decompile(), // run decompilation in background\n+\t\t\t\trootClass::load // load class internals and update UI\n+\t\t);\n \t}\n \n \tprivate synchronized void load() {",
    "output": "Fix workaround to force class decompilation in loading task"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n@@ -5,12 +5,15 @@\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.Set;\n import java.util.StringJoiner;\n+import java.util.TreeSet;\n import java.util.function.Consumer;\n import java.util.stream.Collectors;\n \n@@ -138,13 +141,20 @@ public List<String[]> getTreeExpansions() {\n \t}\n \n \tpublic void addTreeExpansion(String[] expansion) {\n+\t\tdata.getTreeExpansions().removeIf(arr -> Arrays.equals(arr, expansion));\n \t\tdata.getTreeExpansions().add(expansion);\n-\t\tchanged();\n \t}\n \n \tpublic void removeTreeExpansion(String[] expansion) {\n \t\tdata.getTreeExpansions().removeIf(strings -> isParentOfExpansion(expansion, strings));\n-\t\tchanged();\n+\t}\n+\n+\tprivate void reduceTreeExpansions() {\n+\t\t// remove same entries before a project file save\n+\t\t// this is mostly needed for old projects ('add' guard don't work for existed entries)\n+\t\tSet<String[]> set = new TreeSet<>((a, b) -> Arrays.equals(a, b) ? 0 : Integer.compare(Arrays.hashCode(a), Arrays.hashCode(b)));\n+\t\tset.addAll(data.getTreeExpansions());\n+\t\tdata.setTreeExpansions(new ArrayList<>(set));\n \t}\n \n \tprivate boolean isParentOfExpansion(String[] parent, String[] child) {\n@@ -277,6 +287,10 @@ private void changed() {\n \t\tmainWindow.updateProject(this);\n \t}\n \n+\tprivate void onSave() {\n+\t\treduceTreeExpansions();\n+\t}\n+\n \tpublic String getName() {\n \t\treturn name;\n \t}\n@@ -300,6 +314,7 @@ public void saveAs(Path path) {\n \t}\n \n \tpublic void save() {\n+\t\tonSave();\n \t\tPath savePath = getProjectPath();\n \t\tif (savePath != null) {\n \t\t\tPath basePath = savePath.toAbsolutePath().getParent();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -862,8 +862,9 @@ private void expand(TreeNode node, List<String[]> treeExpansions) {\n \t\t\treturn;\n \t\t}\n \t\tTreePath path = new TreePath(pathNodes);\n+\t\tString[] pathExpansion = getPathExpansion(path);\n \t\tfor (String[] expansion : treeExpansions) {\n-\t\t\tif (Arrays.equals(expansion, getPathExpansion(path))) {\n+\t\t\tif (Arrays.equals(expansion, pathExpansion)) {\n \t\t\t\ttree.expandPath(path);\n \t\t\t\tbreak;\n \t\t\t}",
    "output": "Fix improve expand tree (speed up and duplicate entries removal)"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n@@ -200,6 +200,12 @@ public class JadxCLIArgs {\n \t)\n \tprotected UseSourceNameAsClassNameAlias useSourceNameAsClassNameAlias = null;\n \n+\t@Parameter(\n+\t\t\tnames = { \"--source-name-repeat-limit\" },\n+\t\t\tdescription = \"allow using source name if it appears less than a limit number\"\n+\t)\n+\tprotected int sourceNameRepeatLimit = 10;\n+\n \t@Parameter(\n \t\t\tnames = { \"--use-kotlin-methods-for-var-names\" },\n \t\t\tdescription = \"use kotlin intrinsic methods to rename variables, values: disable, apply, apply-and-hide\",\n@@ -352,6 +358,7 @@ public JadxArgs toJadxArgs() {\n \t\targs.setDeobfuscationMaxLength(deobfuscationMaxLength);\n \t\targs.setDeobfuscationWhitelist(Arrays.asList(deobfuscationWhitelistStr.split(\" \")));\n \t\targs.setUseSourceNameAsClassNameAlias(getUseSourceNameAsClassNameAlias());\n+\t\targs.setSourceNameRepeatLimit(sourceNameRepeatLimit);\n \t\targs.setUseKotlinMethodsForVarNames(useKotlinMethodsForVarNames);\n \t\targs.setResourceNameSource(resourceNameSource);\n \t\targs.setEscapeUnicode(escapeUnicode);\n@@ -508,6 +515,10 @@ public UseSourceNameAsClassNameAlias getUseSourceNameAsClassNameAlias() {\n \t\t}\n \t}\n \n+\tpublic int getSourceNameRepeatLimit() {\n+\t\treturn sourceNameRepeatLimit;\n+\t}\n+\n \t/**\n \t * @deprecated Use {@link #getUseSourceNameAsClassNameAlias()} instead.\n \t */\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JadxArgs.java b/jadx-core/src/main/java/jadx/api/JadxArgs.java\n--- a/jadx-core/src/main/java/jadx/api/JadxArgs.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java\n@@ -106,6 +106,7 @@ public class JadxArgs implements Closeable {\n \n \tprivate boolean deobfuscationOn = false;\n \tprivate UseSourceNameAsClassNameAlias useSourceNameAsClassNameAlias = UseSourceNameAsClassNameAlias.getDefault();\n+\tprivate int sourceNameRepeatLimit = 10;\n \n \tprivate File generatedRenamesMappingFile = null;\n \tprivate GeneratedRenamesMappingFileMode generatedRenamesMappingFileMode = GeneratedRenamesMappingFileMode.getDefault();\n@@ -460,6 +461,14 @@ public void setUseSourceNameAsClassNameAlias(UseSourceNameAsClassNameAlias useSo\n \t\tthis.useSourceNameAsClassNameAlias = useSourceNameAsClassNameAlias;\n \t}\n \n+\tpublic int getSourceNameRepeatLimit() {\n+\t\treturn sourceNameRepeatLimit;\n+\t}\n+\n+\tpublic void setSourceNameRepeatLimit(int sourceNameRepeatLimit) {\n+\t\tthis.sourceNameRepeatLimit = sourceNameRepeatLimit;\n+\t}\n+\n \t/**\n \t * @deprecated Use {@link #getUseSourceNameAsClassNameAlias()} instead.\n \t */\n@@ -800,7 +809,7 @@ public String makeCodeArgsHash(@Nullable JadxDecompiler decompiler) {\n \t\tString argStr = \"args:\" + decompilationMode + useImports + showInconsistentCode\n \t\t\t\t+ inlineAnonymousClasses + inlineMethods + moveInnerClasses + allowInlineKotlinLambda\n \t\t\t\t+ deobfuscationOn + deobfuscationMinLength + deobfuscationMaxLength + deobfuscationWhitelist\n-\t\t\t\t+ useSourceNameAsClassNameAlias\n+\t\t\t\t+ useSourceNameAsClassNameAlias + sourceNameRepeatLimit\n \t\t\t\t+ resourceNameSource\n \t\t\t\t+ useKotlinMethodsForVarNames\n \t\t\t\t+ insertDebugLines + extractFinally\n@@ -841,6 +850,7 @@ public String toString() {\n \t\t\t\t+ \", generatedRenamesMappingFileMode=\" + generatedRenamesMappingFileMode\n \t\t\t\t+ \", resourceNameSource=\" + resourceNameSource\n \t\t\t\t+ \", useSourceNameAsClassNameAlias=\" + useSourceNameAsClassNameAlias\n+\t\t\t\t+ \", sourceNameRepeatLimit=\" + sourceNameRepeatLimit\n \t\t\t\t+ \", useKotlinMethodsForVarNames=\" + useKotlinMethodsForVarNames\n \t\t\t\t+ \", insertDebugLines=\" + insertDebugLines\n \t\t\t\t+ \", extractFinally=\" + extractFinally\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/SourceFileRename.java b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/SourceFileRename.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/SourceFileRename.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/SourceFileRename.java\n@@ -34,11 +34,15 @@ public void init(RootNode root) throws JadxException {\n \t\tif (useSourceName == UseSourceNameAsClassNameAlias.NEVER) {\n \t\t\treturn;\n \t\t}\n+\t\tint repeatLimit = root.getArgs().getSourceNameRepeatLimit();\n+\t\tif (repeatLimit <= 1) {\n+\t\t\treturn;\n+\t\t}\n \n \t\tList<ClassNode> classes = root.getClasses();\n-\t\tMap<String, Boolean> canUseAlias = new HashMap<>();\n+\t\tMap<String, Integer> aliasUseCount = new HashMap<>();\n \t\tfor (ClassNode cls : classes) {\n-\t\t\tcanUseAlias.put(cls.getClassInfo().getShortName(), Boolean.FALSE);\n+\t\t\taliasUseCount.put(cls.getClassInfo().getShortName(), 1);\n \t\t}\n \t\tList<ClsRename> renames = new ArrayList<>();\n \t\tfor (ClassNode cls : classes) {\n@@ -47,19 +51,17 @@ public void init(RootNode root) throws JadxException {\n \t\t\t}\n \t\t\tString alias = getAliasFromSourceFile(cls);\n \t\t\tif (alias != null) {\n-\t\t\t\tBoolean prev = canUseAlias.get(alias);\n-\t\t\t\tif (prev == null) {\n-\t\t\t\t\tcanUseAlias.put(alias, Boolean.TRUE);\n-\t\t\t\t\trenames.add(new ClsRename(cls, alias));\n-\t\t\t\t} else if (prev == Boolean.TRUE) {\n-\t\t\t\t\tcanUseAlias.put(alias, Boolean.FALSE);\n+\t\t\t\tint count = aliasUseCount.merge(alias, 1, Integer::sum);\n+\t\t\t\tif (count < repeatLimit) {\n+\t\t\t\t\trenames.add(new ClsRename(cls, alias, count));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tfor (ClsRename clsRename : renames) {\n \t\t\tString alias = clsRename.getAlias();\n-\t\t\tif (canUseAlias.get(alias) == Boolean.TRUE) {\n-\t\t\t\tapplyRename(clsRename.getCls(), alias, useSourceName);\n+\t\t\tInteger count = aliasUseCount.get(alias);\n+\t\t\tif (count < repeatLimit) {\n+\t\t\t\tapplyRename(clsRename.getCls(), clsRename.buildAlias(), useSourceName);\n \t\t\t}\n \t\t}\n \t}\n@@ -112,10 +114,12 @@ private static String getBetterName(String currentName, String sourceName, UseSo\n \tprivate static final class ClsRename {\n \t\tprivate final ClassNode cls;\n \t\tprivate final String alias;\n+\t\tprivate final int suffix;\n \n-\t\tprivate ClsRename(ClassNode cls, String alias) {\n+\t\tprivate ClsRename(ClassNode cls, String alias, int suffix) {\n \t\t\tthis.cls = cls;\n \t\t\tthis.alias = alias;\n+\t\t\tthis.suffix = suffix;\n \t\t}\n \n \t\tpublic ClassNode getCls() {\n@@ -126,9 +130,17 @@ public String getAlias() {\n \t\t\treturn alias;\n \t\t}\n \n+\t\tpublic int getSuffix() {\n+\t\t\treturn suffix;\n+\t\t}\n+\n+\t\tpublic String buildAlias() {\n+\t\t\treturn suffix < 2 ? alias : alias + suffix;\n+\t\t}\n+\n \t\t@Override\n \t\tpublic String toString() {\n-\t\t\treturn \"ClsRename{\" + cls + \" -> '\" + alias + \"'}\";\n+\t\t\treturn \"ClsRename{\" + cls + \" -> '\" + alias + suffix + \"'}\";\n \t\t}\n \t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -406,6 +406,10 @@ public void setUseSourceNameAsClassNameAlias(UseSourceNameAsClassNameAlias useSo\n \t\tthis.useSourceNameAsClassNameAlias = useSourceNameAsClassNameAlias;\n \t}\n \n+\tpublic void setSourceNameRepeatLimit(int sourceNameRepeatLimit) {\n+\t\tthis.sourceNameRepeatLimit = sourceNameRepeatLimit;\n+\t}\n+\n \t/**\n \t * @deprecated Use {@link #setUseSourceNameAsClassNameAlias(UseSourceNameAsClassNameAlias)} instead.\n \t */\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n@@ -302,11 +302,18 @@ private SettingsGroup makeRenameGroup() {\n \t\t\tneedReload();\n \t\t});\n \n+\t\tJSpinner repeatLimit = new JSpinner(new SpinnerNumberModel(settings.getSourceNameRepeatLimit(), 1, Integer.MAX_VALUE, 1));\n+\t\trepeatLimit.addChangeListener(e -> {\n+\t\t\tsettings.setSourceNameRepeatLimit((Integer) repeatLimit.getValue());\n+\t\t\tneedReload();\n+\t\t});\n+\n \t\tSettingsGroup group = new SettingsGroup(NLS.str(\"preferences.rename\"));\n \t\tgroup.addRow(NLS.str(\"preferences.rename_case\"), renameCaseSensitive);\n \t\tgroup.addRow(NLS.str(\"preferences.rename_valid\"), renameValid);\n \t\tgroup.addRow(NLS.str(\"preferences.rename_printable\"), renamePrintable);\n \t\tgroup.addRow(NLS.str(\"preferences.rename_use_source_name_as_class_name_alias\"), useSourceNameAsClassNameAlias);\n+\t\tgroup.addRow(NLS.str(\"preferences.rename_source_name_repeat_limit\"), repeatLimit);\n \t\treturn group;\n \t}",
    "output": "Fix improve rename using source class name"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/commands/CommandPlugins.java b/jadx-cli/src/main/java/jadx/cli/commands/CommandPlugins.java\n--- a/jadx-cli/src/main/java/jadx/cli/commands/CommandPlugins.java\n+++ b/jadx-cli/src/main/java/jadx/cli/commands/CommandPlugins.java\n@@ -156,7 +156,7 @@ private static void printPlugins(List<JadxPluginMetadata> installed) {\n \t\t\t\tsb.append(\" (disabled)\");\n \t\t\t}\n \t\t\tsb.append(\" - \").append(plugin.getName());\n-\t\t\tsb.append(\": \").append(plugin.getDescription());\n+\t\t\tsb.append(\": \").append(formatDescription(plugin.getDescription()));\n \t\t\tSystem.out.println(sb);\n \t\t}\n \t}\n@@ -192,11 +192,24 @@ private static void printAllPlugins() {\n \t\t\tif (!installedSet.contains(plugin.getPluginId())) {\n \t\t\t\tSystem.out.println(\" - \" + plugin.getPluginId()\n \t\t\t\t\t\t+ \" - \" + plugin.getName()\n-\t\t\t\t\t\t+ \": \" + plugin.getDescription());\n+\t\t\t\t\t\t+ \": \" + formatDescription(plugin.getDescription()));\n \t\t\t}\n \t\t}\n \t}\n \n+\tprivate static String formatDescription(String desc) {\n+\t\tif (desc.contains(\"\\n\")) {\n+\t\t\t// remove new lines\n+\t\t\tdesc = desc.replaceAll(\"\\\\R+\", \" \");\n+\t\t}\n+\t\tint maxLen = 512;\n+\t\tif (desc.length() > maxLen) {\n+\t\t\t// truncate very long descriptions\n+\t\t\tdesc = desc.substring(0, maxLen) + \" ...\";\n+\t\t}\n+\t\treturn desc;\n+\t}\n+\n \tprivate void installPlugin(String locationId) {\n \t\tJadxPluginMetadata plugin = JadxPluginsTools.getInstance().install(locationId);\n \t\tSystem.out.println(\"Plugin installed: \" + plugin.getPluginId() + \":\" + plugin.getVersion());",
    "output": "Fix concat new lines in plugin description"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/export/TemplateFile.java b/jadx-core/src/main/java/jadx/core/export/TemplateFile.java\n--- a/jadx-core/src/main/java/jadx/core/export/TemplateFile.java\n+++ b/jadx-core/src/main/java/jadx/core/export/TemplateFile.java\n@@ -11,7 +11,6 @@\n import java.util.HashMap;\n import java.util.Map;\n \n-import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n \n import jadx.core.utils.exceptions.JadxRuntimeException;\n@@ -49,8 +48,8 @@ private TemplateFile(String name, InputStream in) {\n \t\tthis.template = in;\n \t}\n \n-\tpublic void add(String name, @NotNull Object value) {\n-\t\tvalues.put(name, value.toString());\n+\tpublic void add(String name, @Nullable Object value) {\n+\t\tvalues.put(name, String.valueOf(value));\n \t}\n \n \tpublic String build() throws IOException {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/android/AndroidManifestParser.java b/jadx-core/src/main/java/jadx/core/utils/android/AndroidManifestParser.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/AndroidManifestParser.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidManifestParser.java\n@@ -66,31 +66,37 @@ private ApplicationParams parseAttributes() {\n \t\tString mainActivity = null;\n \t\tString application = null;\n \n+\t\t@Nullable\n \t\tElement manifest = (Element) androidManifest.getElementsByTagName(\"manifest\").item(0);\n+\t\t@Nullable\n \t\tElement usesSdk = (Element) androidManifest.getElementsByTagName(\"uses-sdk\").item(0);\n \n \t\tif (parseAttrs.contains(AppAttribute.APPLICATION_LABEL)) {\n \t\t\tapplicationLabel = getApplicationLabel();\n \t\t}\n-\t\tif (parseAttrs.contains(AppAttribute.MIN_SDK_VERSION)) {\n-\t\t\tminSdkVersion = Integer.valueOf(usesSdk.getAttribute(\"android:minSdkVersion\"));\n-\t\t}\n-\t\tif (parseAttrs.contains(AppAttribute.TARGET_SDK_VERSION)) {\n-\t\t\tString stringTargetSdk = usesSdk.getAttribute(\"android:targetSdkVersion\");\n-\t\t\tif (!stringTargetSdk.isEmpty()) {\n-\t\t\t\ttargetSdkVersion = Integer.valueOf(stringTargetSdk);\n-\t\t\t} else {\n-\t\t\t\tif (minSdkVersion == null) {\n-\t\t\t\t\tminSdkVersion = Integer.valueOf(usesSdk.getAttribute(\"android:minSdkVersion\"));\n+\t\tif (usesSdk != null) {\n+\t\t\tif (parseAttrs.contains(AppAttribute.MIN_SDK_VERSION)) {\n+\t\t\t\tminSdkVersion = Integer.valueOf(usesSdk.getAttribute(\"android:minSdkVersion\"));\n+\t\t\t}\n+\t\t\tif (parseAttrs.contains(AppAttribute.TARGET_SDK_VERSION)) {\n+\t\t\t\tString stringTargetSdk = usesSdk.getAttribute(\"android:targetSdkVersion\");\n+\t\t\t\tif (!stringTargetSdk.isEmpty()) {\n+\t\t\t\t\ttargetSdkVersion = Integer.valueOf(stringTargetSdk);\n+\t\t\t\t} else {\n+\t\t\t\t\tif (minSdkVersion == null) {\n+\t\t\t\t\t\tminSdkVersion = Integer.valueOf(usesSdk.getAttribute(\"android:minSdkVersion\"));\n+\t\t\t\t\t}\n+\t\t\t\t\ttargetSdkVersion = minSdkVersion;\n \t\t\t\t}\n-\t\t\t\ttargetSdkVersion = minSdkVersion;\n \t\t\t}\n \t\t}\n-\t\tif (parseAttrs.contains(AppAttribute.VERSION_CODE)) {\n-\t\t\tversionCode = Integer.valueOf(manifest.getAttribute(\"android:versionCode\"));\n-\t\t}\n-\t\tif (parseAttrs.contains(AppAttribute.VERSION_NAME)) {\n-\t\t\tversionName = manifest.getAttribute(\"android:versionName\");\n+\t\tif (manifest != null) {\n+\t\t\tif (parseAttrs.contains(AppAttribute.VERSION_CODE)) {\n+\t\t\t\tversionCode = Integer.valueOf(manifest.getAttribute(\"android:versionCode\"));\n+\t\t\t}\n+\t\t\tif (parseAttrs.contains(AppAttribute.VERSION_NAME)) {\n+\t\t\t\tversionName = manifest.getAttribute(\"android:versionName\");\n+\t\t\t}\n \t\t}\n \t\tif (parseAttrs.contains(AppAttribute.MAIN_ACTIVITY)) {\n \t\t\tmainActivity = getMainActivityName();",
    "output": "Fix handle null values in android manifest parsing"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/IfRegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/IfRegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/IfRegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/IfRegionMaker.java\n@@ -178,6 +178,8 @@ static IfInfo restructureIf(MethodNode mth, BlockNode block, IfInfo info) {\n \t\t\tinfo.setOutBlock(null);\n \t\t\treturn info;\n \t\t}\n+\t\t// init outblock, which will be used in isBadBranchBlock to compare with branch block\n+\t\tinfo.setOutBlock(BlockUtils.getPathCross(mth, thenBlock, elseBlock));\n \t\tboolean badThen = isBadBranchBlock(info, thenBlock);\n \t\tboolean badElse = isBadBranchBlock(info, elseBlock);\n \t\tif (badThen && badElse) {\n@@ -193,8 +195,6 @@ static IfInfo restructureIf(MethodNode mth, BlockNode block, IfInfo info) {\n \t\t\tinfo = IfInfo.invert(info);\n \t\t\tinfo = new IfInfo(info, elseBlock, null);\n \t\t\tinfo.setOutBlock(thenBlock);\n-\t\t} else {\n-\t\t\tinfo.setOutBlock(BlockUtils.getPathCross(mth, thenBlock, elseBlock));\n \t\t}\n \t\tif (BlockUtils.isBackEdge(block, info.getOutBlock())) {\n \t\t\tinfo.setOutBlock(null);\n@@ -219,6 +219,10 @@ private static boolean isBadBranchBlock(IfInfo info, BlockNode block) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\t// if branch block itself is outblock\n+\t\tif (info.getOutBlock() != null) {\n+\t\t\treturn block == info.getOutBlock();\n+\t\t}\n \t\treturn !allPathsFromIf(block, info);\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -761,18 +761,22 @@ public static BlockNode getCommonDominator(MethodNode mth, List<BlockNode> block\n \t/**\n \t * Return common cross block for input set.\n \t *\n-\t * @return null if cross is a method exit block.\n+\t * @return could be one of the giving blocks. null if cross is a method exit block.\n \t */\n \t@Nullable\n \tpublic static BlockNode getPathCross(MethodNode mth, Collection<BlockNode> blocks) {\n \t\tBitSet domFrontBS = newBlocksBitSet(mth);\n+\t\tBitSet tmpBS = newBlocksBitSet(mth); // store block itself and its domFrontier\n \t\tboolean first = true;\n \t\tfor (BlockNode b : blocks) {\n+\t\t\ttmpBS.clear();\n+\t\t\ttmpBS.set(b.getId());\n+\t\t\ttmpBS.or(b.getDomFrontier());\n \t\t\tif (first) {\n-\t\t\t\tdomFrontBS.or(b.getDomFrontier());\n+\t\t\t\tdomFrontBS.or(tmpBS);\n \t\t\t\tfirst = false;\n \t\t\t} else {\n-\t\t\t\tdomFrontBS.and(b.getDomFrontier());\n+\t\t\t\tdomFrontBS.and(tmpBS);\n \t\t\t}\n \t\t}\n \t\tdomFrontBS.clear(mth.getExitBlock().getId());\n@@ -790,7 +794,7 @@ public static BlockNode getPathCross(MethodNode mth, Collection<BlockNode> block\n \t\tmth.getLoops().forEach(l -> excluded.set(l.getStart().getId()));\n \t\tif (!mth.isNoExceptionHandlers()) {\n \t\t\t// exclude exception handlers paths\n-\t\t\tmth.getExceptionHandlers().forEach(h -> mergeExcHandlerDomFrontier(mth, h, excluded));\n+\t\t\tmth.getExceptionHandlers().forEach(h -> addExcHandler(mth, h, excluded));\n \t\t}\n \t\tdomFrontBS.andNot(excluded);\n \t\toneBlock = bitSetToOneBlock(mth, domFrontBS);\n@@ -805,7 +809,6 @@ public static BlockNode getPathCross(MethodNode mth, Collection<BlockNode> block\n \t\t\t\tBitSet domFrontier = block.getDomFrontier();\n \t\t\t\tif (!domFrontier.isEmpty()) {\n \t\t\t\t\tcombinedDF.or(domFrontier);\n-\t\t\t\t\tcombinedDF.clear(block.getId());\n \t\t\t\t}\n \t\t\t});\n \t\t\tcombinedDF.andNot(excluded);\n@@ -827,18 +830,13 @@ public static BlockNode getPathCross(MethodNode mth, Collection<BlockNode> block\n \t\t}\n \t}\n \n-\tprivate static void mergeExcHandlerDomFrontier(MethodNode mth, ExceptionHandler handler, BitSet set) {\n+\tprivate static void addExcHandler(MethodNode mth, ExceptionHandler handler, BitSet set) {\n \t\tBlockNode handlerBlock = handler.getHandlerBlock();\n \t\tif (handlerBlock == null) {\n \t\t\tmth.addDebugComment(\"Null handler block in: \" + handler);\n \t\t\treturn;\n \t\t}\n-\t\tBitSet domFrontier = handlerBlock.getDomFrontier();\n-\t\tif (domFrontier == null) {\n-\t\t\tmth.addDebugComment(\"Null dom frontier in handler: \" + handler);\n-\t\t\treturn;\n-\t\t}\n-\t\tset.or(domFrontier);\n+\t\tset.set(handlerBlock.getId());\n \t}\n \n \tpublic static BlockNode getPathCross(MethodNode mth, BlockNode b1, BlockNode b2) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestOutBlock.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestOutBlock.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestOutBlock.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestOutBlock.java\n@@ -0,0 +1,22 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+/**\n+ * Issue #2384\n+ */\n+public class TestOutBlock extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tallowWarnInCode();\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"setContentView\");\n+\t}\n+}",
    "output": "Fix IfRegionMaker find the wrong outBlock"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/DecompilationMode.java b/jadx-core/src/main/java/jadx/api/DecompilationMode.java\n--- a/jadx-core/src/main/java/jadx/api/DecompilationMode.java\n+++ b/jadx-core/src/main/java/jadx/api/DecompilationMode.java\n@@ -19,5 +19,18 @@ public enum DecompilationMode {\n \t/**\n \t * Raw instructions without modifications\n \t */\n-\tFALLBACK\n+\tFALLBACK;\n+\n+\tpublic boolean isSpecial() {\n+\t\tswitch (this) {\n+\t\t\tcase AUTO:\n+\t\t\tcase RESTRUCTURE:\n+\t\t\t\treturn false;\n+\t\t\tcase SIMPLE:\n+\t\t\tcase FALLBACK:\n+\t\t\t\treturn true;\n+\t\t\tdefault:\n+\t\t\t\tthrow new RuntimeException(\"Unexpected decompilation mode: \" + this);\n+\t\t}\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -347,6 +347,10 @@ private void addMethod(ICodeWriter code, MethodNode mth) {\n \t * Additional checks for inlined methods\n \t */\n \tprivate boolean skipMethod(MethodNode mth) {\n+\t\tif (cls.root().getArgs().getDecompilationMode().isSpecial()) {\n+\t\t\t// show all methods for special decompilation modes\n+\t\t\treturn false;\n+\t\t}\n \t\tMethodInlineAttr inlineAttr = mth.get(AType.METHOD_INLINE);\n \t\tif (inlineAttr == null || inlineAttr.notNeeded()) {\n \t\t\treturn false;",
    "output": "Fix show all methods for 'simple' and 'fallback' decompilation modes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java\n@@ -59,6 +59,14 @@ public void getRegisterArgs(Collection<RegisterArg> list) {\n \t\tlist.addAll(condition.getRegisterArgs());\n \t}\n \n+\t@Override\n+\tpublic boolean replaceArg(InsnArg from, InsnArg to) {\n+\t\tif (super.replaceArg(from, to)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn condition.replaceArg(from, to);\n+\t}\n+\n \tpublic void visitInsns(Consumer<InsnNode> visitor) {\n \t\tsuper.visitInsns(visitor);\n \t\tcondition.visitInsns(visitor);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n--- a/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n@@ -16,6 +16,7 @@\n import jadx.core.dex.instructions.IfNode;\n import jadx.core.dex.instructions.IfOp;\n import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.InsnWrapArg;\n import jadx.core.dex.instructions.args.LiteralArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n@@ -264,6 +265,18 @@ public List<RegisterArg> getRegisterArgs() {\n \t\treturn list;\n \t}\n \n+\tpublic boolean replaceArg(InsnArg from, InsnArg to) {\n+\t\tif (mode == Mode.COMPARE) {\n+\t\t\treturn compare.getInsn().replaceArg(from, to);\n+\t\t}\n+\t\tfor (IfCondition arg : args) {\n+\t\t\tif (arg.replaceArg(from, to)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tpublic void visitInsns(Consumer<InsnNode> visitor) {\n \t\tif (mode == Mode.COMPARE) {\n \t\t\tcompare.getInsn().visitInsns(visitor);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java b/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java\n@@ -25,6 +25,7 @@\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;\n import jadx.core.utils.BlockUtils;\n+import jadx.core.utils.InsnRemover;\n import jadx.core.utils.ListUtils;\n import jadx.core.utils.exceptions.JadxException;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n@@ -82,51 +83,65 @@ private void processInvokeInsn(MethodNode mth, BlockNode block, InvokeNode insn)\n \n \tprivate void inlineMethod(MethodNode mth, MethodNode callMth, MethodInlineAttr mia, BlockNode block, InvokeNode insn) {\n \t\tInsnNode inlCopy = mia.getInsn().copyWithoutResult();\n-\t\tRegisterArg resultArg = insn.getResult();\n-\t\tif (resultArg != null) {\n-\t\t\tinlCopy.setResult(resultArg.duplicate());\n-\t\t} else if (isAssignNeeded(mia.getInsn(), insn, callMth)) {\n-\t\t\t// add fake result to make correct java expression (see test TestGetterInlineNegative)\n-\t\t\tinlCopy.setResult(mth.makeSyntheticRegArg(callMth.getReturnType(), \"unused\"));\n-\t\t}\n-\t\tif (!callMth.getMethodInfo().getArgumentsTypes().isEmpty()) {\n-\t\t\t// remap args\n-\t\t\tInsnArg[] regs = new InsnArg[callMth.getRegsCount()];\n-\t\t\tint[] regNums = mia.getArgsRegNums();\n-\t\t\tfor (int i = 0; i < regNums.length; i++) {\n-\t\t\t\tInsnArg arg = insn.getArg(i);\n-\t\t\t\tregs[regNums[i]] = arg;\n-\t\t\t}\n-\t\t\t// replace args\n-\t\t\tList<RegisterArg> inlArgs = new ArrayList<>();\n-\t\t\tinlCopy.getRegisterArgs(inlArgs);\n-\t\t\tfor (RegisterArg r : inlArgs) {\n-\t\t\t\tint regNum = r.getRegNum();\n-\t\t\t\tif (regNum >= regs.length) {\n-\t\t\t\t\tmth.addWarnComment(\"Unknown register number '\" + r + \"' in method call: \" + callMth);\n-\t\t\t\t\treturn;\n+\t\tif (replaceRegs(mth, callMth, mia, insn, inlCopy)) {\n+\t\t\tIMethodDetails methodDetailsAttr = inlCopy.get(AType.METHOD_DETAILS);\n+\t\t\t// replaceInsn replaces the attributes as well, make sure to preserve METHOD_DETAILS\n+\t\t\tif (BlockUtils.replaceInsn(mth, block, insn, inlCopy)) {\n+\t\t\t\tif (methodDetailsAttr != null) {\n+\t\t\t\t\tinlCopy.addAttr(methodDetailsAttr);\n \t\t\t\t}\n-\t\t\t\tInsnArg repl = regs[regNum];\n-\t\t\t\tif (repl == null) {\n-\t\t\t\t\tmth.addWarnComment(\"Not passed register '\" + r + \"' in method call: \" + callMth);\n-\t\t\t\t\treturn;\n+\t\t\t\tupdateUsageInfo(mth, callMth, mia.getInsn());\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tmth.addWarnComment(\"Failed to inline method: \" + callMth);\n+\t\t// undo changes to insn\n+\t\tInsnRemover.unbindInsn(mth, inlCopy);\n+\t\tinsn.rebindArgs();\n+\t}\n+\n+\tprivate boolean replaceRegs(MethodNode mth, MethodNode callMth, MethodInlineAttr mia, InvokeNode insn, InsnNode inlCopy) {\n+\t\ttry {\n+\t\t\tif (!callMth.getMethodInfo().getArgumentsTypes().isEmpty()) {\n+\t\t\t\t// remap args\n+\t\t\t\tInsnArg[] regs = new InsnArg[callMth.getRegsCount()];\n+\t\t\t\tint[] regNums = mia.getArgsRegNums();\n+\t\t\t\tfor (int i = 0; i < regNums.length; i++) {\n+\t\t\t\t\tInsnArg arg = insn.getArg(i);\n+\t\t\t\t\tregs[regNums[i]] = arg;\n \t\t\t\t}\n-\t\t\t\tif (!inlCopy.replaceArg(r, repl.duplicate())) {\n-\t\t\t\t\tmth.addWarnComment(\"Failed to replace arg \" + r + \" for method inline: \" + callMth);\n-\t\t\t\t\treturn;\n+\t\t\t\t// replace args\n+\t\t\t\tList<RegisterArg> inlArgs = new ArrayList<>();\n+\t\t\t\tinlCopy.getRegisterArgs(inlArgs);\n+\t\t\t\tfor (RegisterArg r : inlArgs) {\n+\t\t\t\t\tint regNum = r.getRegNum();\n+\t\t\t\t\tif (regNum >= regs.length) {\n+\t\t\t\t\t\tmth.addWarnComment(\"Unknown register number '\" + r + \"' in method call: \" + callMth);\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tInsnArg repl = regs[regNum];\n+\t\t\t\t\tif (repl == null) {\n+\t\t\t\t\t\tmth.addWarnComment(\"Not passed register '\" + r + \"' in method call: \" + callMth);\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (!inlCopy.replaceArg(r, repl.duplicate())) {\n+\t\t\t\t\t\tmth.addWarnComment(\"Failed to replace arg \" + r + \" for method inline: \" + callMth);\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tRegisterArg resultArg = insn.getResult();\n+\t\t\tif (resultArg != null) {\n+\t\t\t\tinlCopy.setResult(resultArg.duplicate());\n+\t\t\t} else if (isAssignNeeded(mia.getInsn(), insn, callMth)) {\n+\t\t\t\t// add a fake result to make correct java expression (see test TestGetterInlineNegative)\n+\t\t\t\tinlCopy.setResult(mth.makeSyntheticRegArg(callMth.getReturnType(), \"unused\"));\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t} catch (Exception e) {\n+\t\t\tmth.addWarnComment(\"Method inline failed with exception\", e);\n+\t\t\treturn false;\n \t\t}\n-\t\tIMethodDetails methodDetailsAttr = inlCopy.get(AType.METHOD_DETAILS);\n-\t\tif (!BlockUtils.replaceInsn(mth, block, insn, inlCopy)) {\n-\t\t\tmth.addWarnComment(\"Failed to inline method: \" + callMth);\n-\t\t\treturn;\n-\t\t}\n-\t\t// replaceInsn replaces the attributes as well, make sure to preserve METHOD_DETAILS\n-\t\tif (methodDetailsAttr != null) {\n-\t\t\tinlCopy.addAttr(methodDetailsAttr);\n-\t\t}\n-\t\tupdateUsageInfo(mth, callMth, mia.getInsn());\n \t}\n \n \tprivate boolean isAssignNeeded(InsnNode inlineInsn, InvokeNode parentInsn, MethodNode callMthNode) {",
    "output": "Fix allow to inline methods with ternary instructions"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/impl/AnnotatedCodeWriter.java b/jadx-core/src/main/java/jadx/api/impl/AnnotatedCodeWriter.java\n--- a/jadx-core/src/main/java/jadx/api/impl/AnnotatedCodeWriter.java\n+++ b/jadx-core/src/main/java/jadx/api/impl/AnnotatedCodeWriter.java\n@@ -11,7 +11,6 @@\n import jadx.api.metadata.ICodeAnnotation;\n import jadx.api.metadata.ICodeNodeRef;\n import jadx.api.metadata.annotations.NodeDeclareRef;\n-import jadx.api.metadata.annotations.VarRef;\n import jadx.core.utils.StringUtils;\n \n public class AnnotatedCodeWriter extends SimpleCodeWriter implements ICodeWriter {\n@@ -151,7 +150,6 @@ private void attachSourceLine(int decompiledLine, int sourceLine) {\n \n \t@Override\n \tpublic ICodeInfo finish() {\n-\t\tvalidateAnnotations();\n \t\tString code = buf.toString();\n \t\tbuf = null;\n \t\treturn new AnnotatedCodeInfo(code, lineMap, annotations);\n@@ -161,17 +159,4 @@ public ICodeInfo finish() {\n \tpublic Map<Integer, ICodeAnnotation> getRawAnnotations() {\n \t\treturn annotations;\n \t}\n-\n-\tprivate void validateAnnotations() {\n-\t\tif (annotations.isEmpty()) {\n-\t\t\treturn;\n-\t\t}\n-\t\tannotations.values().removeIf(v -> {\n-\t\t\tif (v.getAnnType() == ICodeAnnotation.AnnType.VAR_REF) {\n-\t\t\t\tVarRef varRef = (VarRef) v;\n-\t\t\t\treturn varRef.getRefPos() == 0;\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t});\n-\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -24,6 +24,7 @@\n import jadx.api.impl.SimpleCodeWriter;\n import jadx.api.metadata.ICodeAnnotation;\n import jadx.api.metadata.annotations.NodeDeclareRef;\n+import jadx.api.metadata.annotations.VarRef;\n import jadx.api.plugins.input.data.IClassData;\n import jadx.api.plugins.input.data.IFieldData;\n import jadx.api.plugins.input.data.IMethodData;\n@@ -423,6 +424,20 @@ private static void processDefinitionAnnotations(ICodeInfo codeInfo) {\n \t\t\t\tdeclareRef.getNode().setDefPosition(pos);\n \t\t\t}\n \t\t}\n+\t\t// validate var refs\n+\t\tannotations.values().removeIf(v -> {\n+\t\t\tif (v.getAnnType() == ICodeAnnotation.AnnType.VAR_REF) {\n+\t\t\t\tVarRef varRef = (VarRef) v;\n+\t\t\t\tif (varRef.getRefPos() == 0) {\n+\t\t\t\t\tif (LOG.isDebugEnabled()) {\n+\t\t\t\t\t\tLOG.debug(\"Var reference '{}' incorrect (ref pos is zero) and was removed from metadata\", varRef);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n \t}\n \n \t@Nullable\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n@@ -41,13 +41,16 @@\n import jadx.api.JadxDecompiler;\n import jadx.api.JadxInternalAccess;\n import jadx.api.JavaClass;\n+import jadx.api.JavaMethod;\n+import jadx.api.JavaVariable;\n import jadx.api.args.GeneratedRenamesMappingFileMode;\n import jadx.api.data.IJavaNodeRef;\n import jadx.api.data.impl.JadxCodeData;\n import jadx.api.data.impl.JadxCodeRename;\n import jadx.api.data.impl.JadxNodeRef;\n import jadx.api.metadata.ICodeMetadata;\n import jadx.api.metadata.annotations.InsnCodeOffset;\n+import jadx.api.metadata.annotations.VarNode;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.MethodNode;\n@@ -646,4 +649,22 @@ protected JadxCodeData getCodeData() {\n \t\t}\n \t\treturn codeData;\n \t}\n+\n+\tprotected JavaClass toJavaClass(ClassNode cls) {\n+\t\tJavaClass javaClass = JadxInternalAccess.convertClassNode(jadxDecompiler, cls);\n+\t\tassertThat(javaClass).isNotNull();\n+\t\treturn javaClass;\n+\t}\n+\n+\tprotected JavaMethod toJavaMethod(MethodNode mth) {\n+\t\tJavaMethod javaMethod = JadxInternalAccess.convertMethodNode(jadxDecompiler, mth);\n+\t\tassertThat(javaMethod).isNotNull();\n+\t\treturn javaMethod;\n+\t}\n+\n+\tprotected JavaVariable toJavaVariable(VarNode varNode) {\n+\t\tJavaVariable javaVariable = (JavaVariable) jadxDecompiler.getJavaNodeByCodeAnnotation(null, varNode);\n+\t\tassertThat(javaVariable).isNotNull();\n+\t\treturn javaVariable;\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestCodeMetadata3.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestCodeMetadata3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestCodeMetadata3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestCodeMetadata3.java\n@@ -0,0 +1,49 @@\n+package jadx.tests.integration.others;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.api.ICodeInfo;\n+import jadx.api.JavaClass;\n+import jadx.api.JavaVariable;\n+import jadx.api.metadata.annotations.VarNode;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.core.dex.nodes.MethodNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+/**\n+ * Test variables refs in code metadata\n+ */\n+public class TestCodeMetadata3 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic String test(String str) {\n+\t\t\tint k = str.length();\n+\t\t\tk++;\n+\t\t\treturn str + ':' + k;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tICodeInfo codeInfo = cls.getCode();\n+\t\tSystem.out.println(codeInfo.getCodeMetadata());\n+\n+\t\tMethodNode testMth = getMethod(cls, \"test\");\n+\t\tJavaClass javaClass = toJavaClass(cls);\n+\t\tList<VarNode> varNodes = testMth.collectArgNodes();\n+\t\tassertThat(varNodes).hasSize(1);\n+\t\tVarNode strVar = varNodes.get(0);\n+\t\tJavaVariable strJavaVar = toJavaVariable(strVar);\n+\t\tassertThat(strJavaVar.getName()).isEqualTo(\"str\");\n+\n+\t\tList<Integer> strUsePlaces = javaClass.getUsePlacesFor(codeInfo, strJavaVar);\n+\t\tassertThat(strUsePlaces).hasSize(2);\n+\t\tassertThat(codeInfo).code().countString(3, \"str\");\n+\t}\n+}",
    "output": "Fix resolve incorrect var ref validation and remove"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n@@ -226,6 +226,10 @@ public Map<ArgType, ArgType> getTypeVariablesMapping(ArgType clsType) {\n \t\tfor (int i = 0; i < genericParamsCount; i++) {\n \t\t\tArgType actualType = actualTypes.get(i);\n \t\t\tArgType typeVar = typeParameters.get(i);\n+\t\t\tif (typeVar.getExtendTypes() != null) {\n+\t\t\t\t// force short form (only type var name)\n+\t\t\t\ttypeVar = ArgType.genericType(typeVar.getObject());\n+\t\t\t}\n \t\t\treplaceMap.put(typeVar, actualType);\n \t\t}\n \t\treturn replaceMap;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestGenerics8.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestGenerics8.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestGenerics8.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestGenerics8.java\n@@ -0,0 +1,47 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestGenerics8 extends IntegrationTest {\n+\n+\tpublic static class TestCls<T> {\n+\n+\t\tpublic abstract static class Class2<S extends I1 & I2> extends Parent2<S> {\n+\t\t\tpublic void test() {\n+\t\t\t\tS s = get();\n+\t\t\t\ts.i1();\n+\t\t\t\ts.i2();\n+\t\t\t}\n+\t\t}\n+\n+\t\tstatic class Parent2<T extends I1> {\n+\t\t\tT t;\n+\n+\t\t\tprotected T get() {\n+\t\t\t\treturn t;\n+\t\t\t}\n+\t\t}\n+\n+\t\tinterface I1 {\n+\t\t\tvoid i1();\n+\t\t}\n+\n+\t\tinterface I2 {\n+\t\t\tvoid i2();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"S s = get();\")\n+\t\t\t\t.containsOne(\"s.i1();\")\n+\t\t\t\t.containsOne(\"s.i2();\");\n+\t}\n+}",
    "output": "Fix force type var short form as a key in generic resolve mapping"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -456,13 +456,15 @@ public void unload() {\n \t\tif (state == NOT_LOADED) {\n \t\t\treturn;\n \t\t}\n-\t\tmethods.forEach(MethodNode::unload);\n-\t\tinnerClasses.forEach(ClassNode::unload);\n-\t\tfields.forEach(FieldNode::unload);\n-\t\tunloadAttributes();\n-\t\tsetState(NOT_LOADED);\n-\t\tthis.loadStage = LoadStage.NONE;\n-\t\tthis.smali = null;\n+\t\tsynchronized (clsInfo) { // decompilation sync\n+\t\t\tmethods.forEach(MethodNode::unload);\n+\t\t\tinnerClasses.forEach(ClassNode::unload);\n+\t\t\tfields.forEach(FieldNode::unload);\n+\t\t\tunloadAttributes();\n+\t\t\tsetState(NOT_LOADED);\n+\t\t\tthis.loadStage = LoadStage.NONE;\n+\t\t\tthis.smali = null;\n+\t\t}\n \t}\n \n \tprivate void buildCache() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n--- a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n+++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n@@ -22,6 +22,7 @@\n import org.slf4j.LoggerFactory;\n \n import jadx.api.utils.tasks.ITaskExecutor;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.settings.JadxSettings;\n import jadx.gui.ui.MainWindow;\n import jadx.gui.ui.panel.ProgressPanel;\n@@ -81,6 +82,15 @@ public synchronized void cancelAll() {\n \t\t}\n \t}\n \n+\tpublic synchronized void waitForComplete() {\n+\t\ttry {\n+\t\t\t// add empty task and wait its completion\n+\t\t\ttaskQueueExecutor.submit(UiUtils.EMPTY_RUNNABLE).get();\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new JadxRuntimeException(\"Failed to wait tasks completion\", e);\n+\t\t}\n+\t}\n+\n \tpublic void execute(String title, List<Runnable> backgroundJobs, Consumer<TaskStatus> onFinishUiRunnable) {\n \t\texecute(new SimpleTask(title, backgroundJobs, onFinishUiRunnable));\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n@@ -182,6 +182,7 @@ public void dispose() {\n \t\tremoveActiveTabListener();\n \t\tsearchBackgroundExecutor.execute(() -> {\n \t\t\tstopSearchTask();\n+\t\t\tmainWindow.getBackgroundExecutor().waitForComplete();\n \t\t\tunloadTempData();\n \t\t});\n \t\tsuper.dispose();",
    "output": "Add missing sync in clean task at search dialog close"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CommentAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CommentAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CommentAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CommentAction.java\n@@ -5,6 +5,8 @@\n \n import javax.swing.event.PopupMenuEvent;\n \n+import org.fife.ui.rsyntaxtextarea.Token;\n+import org.fife.ui.rsyntaxtextarea.TokenTypes;\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -57,6 +59,12 @@ public void popupMenuWillBecomeVisible(PopupMenuEvent e) {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void popupMenuCanceled(PopupMenuEvent e) {\n+\t\tactionComment = null;\n+\t\tsetEnabled(false);\n+\t}\n+\n \tprivate boolean updateCommentAction(int pos) {\n \t\tICodeComment codeComment = getCommentRef(pos);\n \t\tif (codeComment == null) {\n@@ -151,8 +159,7 @@ private ICodeComment getCommentRef(int pos) {\n \t\t\t}\n \n \t\t\t// check if at comment above node definition\n-\t\t\tString lineStr = codeArea.getLineAt(pos).trim();\n-\t\t\tif (lineStr.startsWith(\"//\") || lineStr.startsWith(\"/*\")) {\n+\t\t\tif (isCommentLine(pos)) {\n \t\t\t\tICodeNodeRef nodeRef = metadata.searchDown(pos, (off, ann) -> {\n \t\t\t\t\tif (off > pos && ann.getAnnType() == AnnType.DECLARATION) {\n \t\t\t\t\t\treturn ((NodeDeclareRef) ann).getNode();\n@@ -169,4 +176,34 @@ private ICodeComment getCommentRef(int pos) {\n \t\t}\n \t\treturn null;\n \t}\n+\n+\t/**\n+\t * Check if all tokens are 'comment' in line at 'pos'\n+\t */\n+\tprivate boolean isCommentLine(int pos) {\n+\t\ttry {\n+\t\t\tint line = codeArea.getLineOfOffset(pos);\n+\t\t\tToken lineTokens = codeArea.getTokenListForLine(line);\n+\t\t\tboolean commentFound = false;\n+\t\t\tfor (Token t = lineTokens; t != null; t = t.getNextToken()) {\n+\t\t\t\tif (t.isComment()) {\n+\t\t\t\t\tcommentFound = true;\n+\t\t\t\t} else {\n+\t\t\t\t\tswitch (t.getType()) {\n+\t\t\t\t\t\tcase TokenTypes.WHITESPACE:\n+\t\t\t\t\t\tcase TokenTypes.NULL:\n+\t\t\t\t\t\t\t// allowed tokens\n+\t\t\t\t\t\t\tbreak;\n+\n+\t\t\t\t\t\tdefault:\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn commentFound;\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.warn(\"Failed to check for comment line\", e);\n+\t\t\treturn false;\n+\t\t}\n+\t}\n }",
    "output": "Fix improve detection of multi line method comments for update"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CommentAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CommentAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CommentAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CommentAction.java\n@@ -1,6 +1,7 @@\n package jadx.gui.ui.codearea;\n \n import java.awt.event.ActionEvent;\n+import java.util.Objects;\n \n import javax.swing.event.PopupMenuEvent;\n \n@@ -13,6 +14,7 @@\n import jadx.api.JavaNode;\n import jadx.api.data.ICodeComment;\n import jadx.api.data.impl.JadxCodeComment;\n+import jadx.api.data.impl.JadxCodeData;\n import jadx.api.data.impl.JadxCodeRef;\n import jadx.api.data.impl.JadxNodeRef;\n import jadx.api.metadata.ICodeAnnotation;\n@@ -22,6 +24,7 @@\n import jadx.api.metadata.annotations.InsnCodeOffset;\n import jadx.api.metadata.annotations.NodeDeclareRef;\n import jadx.gui.JadxWrapper;\n+import jadx.gui.settings.JadxProject;\n import jadx.gui.treemodel.JClass;\n import jadx.gui.ui.action.ActionModel;\n import jadx.gui.ui.action.JadxGuiAction;\n@@ -34,9 +37,10 @@ public class CommentAction extends CodeAreaAction implements DefaultPopupMenuLis\n \tprivate static final long serialVersionUID = 4753838562204629112L;\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(CommentAction.class);\n-\tprivate final boolean enabled;\n \n-\tprivate ICodeComment actionComment;\n+\tprivate final boolean enabled;\n+\tprivate @Nullable ICodeComment actionComment;\n+\tprivate boolean updateComment;\n \n \tpublic CommentAction(CodeArea codeArea) {\n \t\tsuper(ActionModel.CODE_COMMENT, codeArea);\n@@ -45,34 +49,63 @@ public CommentAction(CodeArea codeArea) {\n \n \t@Override\n \tpublic void popupMenuWillBecomeVisible(PopupMenuEvent e) {\n-\t\tif (enabled) {\n-\t\t\tICodeComment codeComment = getCommentRef(UiUtils.getOffsetAtMousePosition(codeArea));\n-\t\t\tsetEnabled(codeComment != null);\n-\t\t\tthis.actionComment = codeComment;\n+\t\tif (enabled && updateCommentAction(UiUtils.getOffsetAtMousePosition(codeArea))) {\n+\t\t\tsetNameAndDesc(updateComment ? NLS.str(\"popup.update_comment\") : NLS.str(\"popup.add_comment\"));\n+\t\t\tsetEnabled(true);\n \t\t} else {\n \t\t\tsetEnabled(false);\n \t\t}\n \t}\n \n+\tprivate boolean updateCommentAction(int pos) {\n+\t\tICodeComment codeComment = getCommentRef(pos);\n+\t\tif (codeComment == null) {\n+\t\t\tactionComment = null;\n+\t\t\treturn false;\n+\t\t}\n+\t\tICodeComment exitsComment = searchForExistComment(codeComment);\n+\t\tif (exitsComment != null) {\n+\t\t\tactionComment = exitsComment;\n+\t\t\tupdateComment = true;\n+\t\t} else {\n+\t\t\tactionComment = codeComment;\n+\t\t\tupdateComment = false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n \t@Override\n \tpublic void actionPerformed(ActionEvent e) {\n \t\tif (!enabled) {\n \t\t\treturn;\n \t\t}\n-\n \t\tif (JadxGuiAction.isSource(e)) {\n-\t\t\tshowCommentDialog(getCommentRef(codeArea.getCaretPosition()));\n-\t\t} else {\n-\t\t\tshowCommentDialog(this.actionComment);\n+\t\t\tupdateCommentAction(codeArea.getCaretPosition());\n \t\t}\n-\t}\n-\n-\tprivate void showCommentDialog(ICodeComment codeComment) {\n-\t\tif (codeComment == null) {\n+\t\tif (actionComment == null) {\n \t\t\tUiUtils.showMessageBox(codeArea.getMainWindow(), NLS.str(\"msg.cant_add_comment\"));\n \t\t\treturn;\n \t\t}\n-\t\tCommentDialog.show(codeArea, codeComment);\n+\t\tCommentDialog.show(codeArea, actionComment, updateComment);\n+\t}\n+\n+\tprivate @Nullable ICodeComment searchForExistComment(ICodeComment blankComment) {\n+\t\ttry {\n+\t\t\tJadxProject project = codeArea.getProject();\n+\t\t\tJadxCodeData codeData = project.getCodeData();\n+\t\t\tif (codeData == null || codeData.getComments().isEmpty()) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tfor (ICodeComment comment : codeData.getComments()) {\n+\t\t\t\tif (Objects.equals(comment.getNodeRef(), blankComment.getNodeRef())\n+\t\t\t\t\t\t&& Objects.equals(comment.getCodeRef(), blankComment.getCodeRef())) {\n+\t\t\t\t\treturn comment;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"Error searching for exists comment\", e);\n+\t\t}\n+\t\treturn null;\n \t}\n \n \t/**\n@@ -132,7 +165,7 @@ private ICodeComment getCommentRef(int pos) {\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Failed to add comment at: \" + pos, e);\n+\t\t\tLOG.error(\"Failed to add comment at: {}\", pos, e);\n \t\t}\n \t\treturn null;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommentDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommentDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommentDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommentDialog.java\n@@ -3,14 +3,12 @@\n import java.awt.BorderLayout;\n import java.awt.Component;\n import java.awt.Container;\n-import java.awt.Dialog;\n import java.awt.Dimension;\n import java.awt.event.KeyAdapter;\n import java.awt.event.KeyEvent;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n-import java.util.Objects;\n import java.util.function.Consumer;\n \n import javax.swing.BorderFactory;\n@@ -44,14 +42,8 @@ public class CommentDialog extends JDialog {\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(CommentDialog.class);\n \n-\tpublic static void show(CodeArea codeArea, ICodeComment blankComment) {\n-\t\tICodeComment existComment = searchForExistComment(codeArea, blankComment);\n-\t\tDialog dialog;\n-\t\tif (existComment != null) {\n-\t\t\tdialog = new CommentDialog(codeArea, existComment, true);\n-\t\t} else {\n-\t\t\tdialog = new CommentDialog(codeArea, blankComment, false);\n-\t\t}\n+\tpublic static void show(CodeArea codeArea, ICodeComment comment, boolean updateComment) {\n+\t\tCommentDialog dialog = new CommentDialog(codeArea, comment, updateComment);\n \t\tdialog.setVisible(true);\n \t}\n \n@@ -79,25 +71,6 @@ private static void updateCommentsData(CodeArea codeArea, Consumer<List<ICodeCom\n \t\t}\n \t}\n \n-\tprivate static ICodeComment searchForExistComment(CodeArea codeArea, ICodeComment blankComment) {\n-\t\ttry {\n-\t\t\tJadxProject project = codeArea.getProject();\n-\t\t\tJadxCodeData codeData = project.getCodeData();\n-\t\t\tif (codeData == null || codeData.getComments().isEmpty()) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tfor (ICodeComment comment : codeData.getComments()) {\n-\t\t\t\tif (Objects.equals(comment.getNodeRef(), blankComment.getNodeRef())\n-\t\t\t\t\t\t&& Objects.equals(comment.getCodeRef(), blankComment.getCodeRef())) {\n-\t\t\t\t\treturn comment;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Error searching for exists comment\", e);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n \tprivate final transient CodeArea codeArea;\n \tprivate final transient ICodeComment comment;\n \tprivate final transient boolean updateComment;\n@@ -217,7 +190,7 @@ public void keyPressed(KeyEvent e) {\n \t\t}\n \t\tpack();\n \t\tif (!codeArea.getMainWindow().getSettings().loadWindowPos(this)) {\n-\t\t\tsetSize(800, 140);\n+\t\t\tsetSize(400, 340);\n \t\t}\n \t\tsetLocationRelativeTo(null);\n \t\tsetDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);",
    "output": "Fix text on popup action change if need update comment & fixes default size on comment diallog"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -175,9 +175,7 @@ public void updateGenericClsData(List<ArgType> generics, ArgType superClass, Lis\n \t}\n \n \tprivate static void processSpecialClasses(ClassNode cls) {\n-\t\tAccessInfo flags = cls.getAccessFlags();\n-\t\tif (flags.isSynthetic() && flags.isInterface() && flags.isAbstract()\n-\t\t\t\t&& cls.getName().equals(\"package-info\")) {\n+\t\tif (cls.getName().equals(\"package-info\") && cls.getFields().isEmpty() && cls.getMethods().isEmpty()) {\n \t\t\tcls.add(AFlag.PACKAGE_INFO);\n \t\t\tcls.add(AFlag.DONT_RENAME);\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/special/TestPackageInfoSupport.java b/jadx-core/src/test/java/jadx/tests/integration/special/TestPackageInfoSupport.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/special/TestPackageInfoSupport.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/special/TestPackageInfoSupport.java\n@@ -28,5 +28,7 @@ public void test() {\n \t\t\t\t\t\t\"package special.pkg2;\",\n \t\t\t\t\t\t\"\",\n \t\t\t\t\t\t\"import org.jetbrains.annotations.ApiStatus;\");\n+\t\tassertThat(searchCls(classes, \"special.pkg3.package-info\"))\n+\t\t\t\t.code().isEqualTo(\"\\npackage special.pkg3;\\n\");\n \t}\n }",
    "output": "Fix better package-info support"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n@@ -86,16 +86,21 @@ private static void removeSyntheticFields(ClassNode cls) {\n \t\t\t\t\tClassInfo clsInfo = ClassInfo.fromType(cls.root(), fldType);\n \t\t\t\t\tClassNode fieldsCls = cls.root().resolveClass(clsInfo);\n \t\t\t\t\tClassInfo parentClass = cls.getClassInfo().getParentClass();\n-\t\t\t\t\tif (fieldsCls != null\n-\t\t\t\t\t\t\t&& (inline || Objects.equals(parentClass, fieldsCls.getClassInfo()))) {\n+\t\t\t\t\tif (fieldsCls == null) {\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t\tboolean isParentInst = Objects.equals(parentClass, fieldsCls.getClassInfo());\n+\t\t\t\t\tif (inline || isParentInst) {\n \t\t\t\t\t\tint found = 0;\n \t\t\t\t\t\tfor (MethodNode mth : cls.getMethods()) {\n \t\t\t\t\t\t\tif (removeFieldUsageFromConstructor(mth, field, fieldsCls)) {\n \t\t\t\t\t\t\t\tfound++;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (found != 0) {\n-\t\t\t\t\t\t\tfield.addAttr(new FieldReplaceAttr(fieldsCls.getClassInfo()));\n+\t\t\t\t\t\t\tif (isParentInst) {\n+\t\t\t\t\t\t\t\tfield.addAttr(new FieldReplaceAttr(fieldsCls.getClassInfo()));\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tfield.add(AFlag.DONT_GENERATE);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass22.java b/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass22.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass22.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass22.java\n@@ -0,0 +1,40 @@\n+package jadx.tests.integration.inner;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestAnonymousClass22 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic static class Parent {\n+\t\t\tpublic static Parent test(Class<?> cls) {\n+\t\t\t\tfinal AnotherClass another = new AnotherClass();\n+\t\t\t\treturn new Parent() {\n+\t\t\t\t\t@Override\n+\t\t\t\t\tpublic String func() {\n+\t\t\t\t\t\treturn another.toString();\n+\t\t\t\t\t}\n+\t\t\t\t};\n+\t\t\t}\n+\n+\t\t\tpublic String func() {\n+\t\t\t\treturn \"\";\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic static class AnotherClass {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"return another.toString();\")\n+\t\t\t\t.doesNotContain(\"AnotherClass.this\");\n+\t}\n+}",
    "output": "Fix inline anonymous class wrongly handles field as Classname.this"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -290,7 +290,7 @@ private void initInnerClasses() {\n \t\tList<ClassNode> updated = new ArrayList<>();\n \t\tfor (ClassNode cls : inner) {\n \t\t\tClassInfo clsInfo = cls.getClassInfo();\n-\t\t\tClassNode parent = resolveClass(clsInfo.getParentClass());\n+\t\t\tClassNode parent = resolveParentClass(clsInfo);\n \t\t\tif (parent == null) {\n \t\t\t\tclsMap.remove(clsInfo);\n \t\t\t\tclsInfo.notInner(this);\n@@ -482,6 +482,33 @@ public ClassNode resolveRawClass(String rawFullName) {\n \t\treturn rawClsMap.get(rawFullName);\n \t}\n \n+\t/**\n+\t * Find and correct the parent of an inner class.\n+\t * <br>\n+\t * Sometimes inner ClassInfo generated wrong parent info.\n+\t * e.g. inner is `Cls$mth$1`, current parent = `Cls$mth`, real parent = `Cls`\n+\t */\n+\t@Nullable\n+\tpublic ClassNode resolveParentClass(ClassInfo clsInfo) {\n+\t\tClassInfo parentInfo = clsInfo.getParentClass();\n+\t\tClassNode parentNode = resolveClass(parentInfo);\n+\t\tif (parentNode == null && parentInfo != null) {\n+\t\t\tString parClsName = parentInfo.getFullName();\n+\t\t\t// strip last part as method name\n+\t\t\tint sep = parClsName.lastIndexOf('.');\n+\t\t\tif (sep > 0 && sep != parClsName.length() - 1) {\n+\t\t\t\tString mthName = parClsName.substring(sep + 1);\n+\t\t\t\tString upperParClsName = parClsName.substring(0, sep);\n+\t\t\t\tClassNode tmpParent = resolveClass(upperParClsName);\n+\t\t\t\tif (tmpParent != null && tmpParent.searchMethodByShortName(mthName) != null) {\n+\t\t\t\t\tparentNode = tmpParent;\n+\t\t\t\t\tclsInfo.convertToInner(parentNode);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn parentNode;\n+\t}\n+\n \t/**\n \t * Searches for ClassNode by its full name (original or alias name)\n \t * <br>",
    "output": "Fix inner class parent is wrong when name formatted as Class$method$xxx"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/action/JadxGuiAction.java b/jadx-gui/src/main/java/jadx/gui/ui/action/JadxGuiAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/action/JadxGuiAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/action/JadxGuiAction.java\n@@ -9,12 +9,13 @@\n \n import org.jetbrains.annotations.Nullable;\n \n+import jadx.gui.ui.menu.JadxMenu;\n import jadx.gui.utils.UiUtils;\n import jadx.gui.utils.shortcut.Shortcut;\n import jadx.gui.utils.ui.ActionHandler;\n \n public class JadxGuiAction extends ActionHandler implements IShortcutAction {\n-\tprivate static final String COMMAND = \"JadxGuiAction.Command.%s\";\n+\tprivate static final String COMMAND_PREFIX = \"JadxGuiAction.Command.\";\n \n \tprivate final ActionModel actionModel;\n \tprivate final String id;\n@@ -102,21 +103,20 @@ public void actionPerformed(ActionEvent e) {\n \n \t@Override\n \tpublic void performAction() {\n-\t\tif (shortcutComponent != null && !shortcutComponent.isShowing()) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tString shortcutType = \"null\";\n-\t\tif (shortcut != null) {\n-\t\t\tshortcutType = shortcut.getTypeString();\n+\t\tif (shortcutComponent != null) {\n+\t\t\tif (shortcutComponent == JadxMenu.JADX_MENU_COMPONENT) {\n+\t\t\t\t// always enabled\n+\t\t\t} else if (!shortcutComponent.isShowing()) {\n+\t\t\t\treturn;\n+\t\t\t}\n \t\t}\n-\t\tactionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED,\n-\t\t\t\tString.format(COMMAND, shortcutType)));\n+\t\tString shortcutType = shortcut != null ? shortcut.getTypeString() : \"null\";\n+\t\tactionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, COMMAND_PREFIX + shortcutType));\n \t}\n \n \tpublic static boolean isSource(ActionEvent event) {\n-\t\treturn event.getActionCommand() != null\n-\t\t\t\t&& event.getActionCommand().startsWith(String.format(COMMAND, \"\"));\n+\t\tString command = event.getActionCommand();\n+\t\treturn command != null && command.startsWith(COMMAND_PREFIX);\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/menu/JadxMenu.java b/jadx-gui/src/main/java/jadx/gui/ui/menu/JadxMenu.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/menu/JadxMenu.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/menu/JadxMenu.java\n@@ -12,7 +12,7 @@\n \n public class JadxMenu extends JMenu {\n \t// fake component to fill action shortcut component property\n-\tprivate static final JComponent JADX_MENU_COMPONENT = new JComponent() {\n+\tpublic static final JComponent JADX_MENU_COMPONENT = new JComponent() {\n \t\t@Override\n \t\tpublic String toString() {\n \t\t\treturn \"JADX_MENU_COMPONENT\";\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/shortcut/ShortcutsController.java b/jadx-gui/src/main/java/jadx/gui/utils/shortcut/ShortcutsController.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/shortcut/ShortcutsController.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/shortcut/ShortcutsController.java\n@@ -3,10 +3,11 @@\n import java.awt.AWTEvent;\n import java.awt.Toolkit;\n import java.awt.event.MouseEvent;\n+import java.util.ArrayList;\n import java.util.EnumMap;\n-import java.util.EnumSet;\n import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n@@ -31,7 +32,7 @@ public class ShortcutsController {\n \n \tprivate final JadxSettings settings;\n \tprivate final Map<ActionModel, Set<IShortcutAction>> boundActions = new EnumMap<>(ActionModel.class);\n-\tprivate final Set<ActionModel> mouseActions = EnumSet.noneOf(ActionModel.class);\n+\tprivate final Map<Integer, List<IShortcutAction>> mouseActions = new HashMap<>();\n \n \tprivate ShortcutsWrapper shortcuts;\n \n@@ -73,8 +74,7 @@ public void bind(IShortcutAction action) {\n \t\t\tLOG.warn(\"No shortcut component in action: {}\", action, new JadxRuntimeException());\n \t\t\treturn;\n \t\t}\n-\t\tboundActions.computeIfAbsent(action.getActionModel(), k -> new HashSet<>());\n-\t\tboundActions.get(action.getActionModel()).add(action);\n+\t\tboundActions.computeIfAbsent(action.getActionModel(), k -> new HashSet<>()).add(action);\n \t}\n \n \t/*\n@@ -106,18 +106,12 @@ public void registerMouseEventListener(MainWindow mw) {\n \t\t\tif (mouseEvent.getID() != MouseEvent.MOUSE_PRESSED) {\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\tint mouseButton = mouseEvent.getButton();\n-\t\t\tfor (ActionModel actionModel : mouseActions) {\n-\t\t\t\tShortcut shortcut = shortcuts.get(actionModel);\n-\t\t\t\tif (shortcut != null && shortcut.getMouseButton() == mouseButton) {\n-\t\t\t\t\tSet<IShortcutAction> actions = boundActions.get(actionModel);\n-\t\t\t\t\tif (actions != null) {\n-\t\t\t\t\t\tfor (IShortcutAction action : actions) {\n-\t\t\t\t\t\t\tif (action != null) {\n-\t\t\t\t\t\t\t\tmouseEvent.consume();\n-\t\t\t\t\t\t\t\tUiUtils.uiRun(action::performAction);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n+\t\t\tList<IShortcutAction> actions = mouseActions.get(mouseEvent.getButton());\n+\t\t\tif (actions != null) {\n+\t\t\t\tfor (IShortcutAction action : actions) {\n+\t\t\t\t\tif (action != null) {\n+\t\t\t\t\t\tmouseEvent.consume();\n+\t\t\t\t\t\tUiUtils.uiRun(action::performAction);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n@@ -129,7 +123,11 @@ private void indexMouseActions() {\n \t\tfor (ActionModel actionModel : ActionModel.values()) {\n \t\t\tShortcut shortcut = shortcuts.get(actionModel);\n \t\t\tif (shortcut != null && shortcut.isMouse()) {\n-\t\t\t\tmouseActions.add(actionModel);\n+\t\t\t\tSet<IShortcutAction> actions = boundActions.get(actionModel);\n+\t\t\t\tif (actions != null && !actions.isEmpty()) {\n+\t\t\t\t\tmouseActions.computeIfAbsent(shortcut.getMouseButton(), i -> new ArrayList<>())\n+\t\t\t\t\t\t\t.addAll(actions);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}",
    "output": "Fix resolve ignored mouse actions"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n@@ -150,7 +150,7 @@ private static boolean fixVisibilityOfInlineCode(MethodNode mth, InsnNode insn)\n \t\tif (insnType == InsnType.INVOKE) {\n \t\t\tInvokeNode invoke = (InvokeNode) insn;\n \t\t\tMethodNode callMthNode = mth.root().resolveMethod(invoke.getCallMth());\n-\t\t\tif (callMthNode != null) {\n+\t\t\tif (callMthNode != null && !callMthNode.root().getArgs().isRespectBytecodeAccModifiers()) {\n \t\t\t\tFixAccessModifiers.changeVisibility(callMthNode, newVisFlag);\n \t\t\t}\n \t\t\treturn true;",
    "output": "Fix check respectBytecodeAccModifiers in MarkMethodsForInline"
  },
  {
    "input": "diff --git a/jadx-cli/src/test/java/jadx/plugins/tools/utils/PluginUtilsTest.java b/jadx-cli/src/test/java/jadx/plugins/tools/utils/PluginUtilsTest.java\n--- a/jadx-cli/src/test/java/jadx/plugins/tools/utils/PluginUtilsTest.java\n+++ b/jadx-cli/src/test/java/jadx/plugins/tools/utils/PluginUtilsTest.java\n@@ -0,0 +1,17 @@\n+package jadx.plugins.tools.utils;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static jadx.plugins.tools.utils.PluginUtils.extractVersion;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class PluginUtilsTest {\n+\n+\t@Test\n+\tpublic void testExtractVersion() {\n+\t\tassertThat(extractVersion(\"plugin-name-v1.2.3.jar\")).isEqualTo(\"1.2.3\");\n+\t\tassertThat(extractVersion(\"plugin-name-v1.2.jar\")).isEqualTo(\"1.2\");\n+\t\tassertThat(extractVersion(\"1.2.3.jar\")).isEqualTo(\"1.2.3\");\n+\t}\n+\n+}\n\ndiff --git a/jadx-plugins-tools/src/main/java/jadx/plugins/tools/resolvers/github/GithubReleaseResolver.java b/jadx-plugins-tools/src/main/java/jadx/plugins/tools/resolvers/github/GithubReleaseResolver.java\n--- a/jadx-plugins-tools/src/main/java/jadx/plugins/tools/resolvers/github/GithubReleaseResolver.java\n+++ b/jadx-plugins-tools/src/main/java/jadx/plugins/tools/resolvers/github/GithubReleaseResolver.java\n@@ -10,8 +10,7 @@\n import jadx.plugins.tools.resolvers.IJadxPluginResolver;\n import jadx.plugins.tools.resolvers.github.data.Asset;\n import jadx.plugins.tools.resolvers.github.data.Release;\n-\n-import static jadx.plugins.tools.utils.PluginUtils.removePrefix;\n+import jadx.plugins.tools.utils.PluginUtils;\n \n public class GithubReleaseResolver implements IJadxPluginResolver {\n \tprivate static final Pattern VERSION_PATTERN = Pattern.compile(\"v?\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n@@ -47,8 +46,14 @@ public boolean hasVersion(String locationId) {\n \n \tprivate JadxPluginMetadata buildMetadata(Release release, LocationInfo info) {\n \t\tList<Asset> assets = release.getAssets();\n-\t\tString releaseVersion = removePrefix(release.getName(), \"v\");\n+\t\tString releaseVersion = PluginUtils.removePrefix(release.getName(), \"v\");\n \t\tAsset asset = searchPluginAsset(assets, info.getArtifactPrefix(), releaseVersion);\n+\t\tif (!asset.getName().contains(releaseVersion)) {\n+\t\t\tString assetVersion = PluginUtils.extractVersion(asset.getName());\n+\t\t\tif (assetVersion != null) {\n+\t\t\t\treleaseVersion = assetVersion;\n+\t\t\t}\n+\t\t}\n \n \t\tJadxPluginMetadata metadata = new JadxPluginMetadata();\n \t\tmetadata.setVersion(releaseVersion);\n\ndiff --git a/jadx-plugins-tools/src/main/java/jadx/plugins/tools/utils/PluginUtils.java b/jadx-plugins-tools/src/main/java/jadx/plugins/tools/utils/PluginUtils.java\n--- a/jadx-plugins-tools/src/main/java/jadx/plugins/tools/utils/PluginUtils.java\n+++ b/jadx-plugins-tools/src/main/java/jadx/plugins/tools/utils/PluginUtils.java\n@@ -5,6 +5,10 @@\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.StandardCopyOption;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.jetbrains.annotations.Nullable;\n \n public class PluginUtils {\n \n@@ -22,4 +26,19 @@ public static void downloadFile(String fileUrl, Path destPath) {\n \t\t\tthrow new RuntimeException(\"Failed to download file: \" + fileUrl, e);\n \t\t}\n \t}\n+\n+\tprivate static final Pattern VERSION_LONG = Pattern.compile(\".*v?(\\\\d+\\\\.\\\\d+\\\\.\\\\d+).*\");\n+\tprivate static final Pattern VERSION_SHORT = Pattern.compile(\".*v?(\\\\d+\\\\.\\\\d+).*\");\n+\n+\tpublic static @Nullable String extractVersion(String str) {\n+\t\tMatcher longMatcher = VERSION_LONG.matcher(str);\n+\t\tif (longMatcher.matches()) {\n+\t\t\treturn longMatcher.group(1);\n+\t\t}\n+\t\tMatcher shortMatcher = VERSION_SHORT.matcher(str);\n+\t\tif (shortMatcher.matches()) {\n+\t\t\treturn shortMatcher.group(1);\n+\t\t}\n+\t\treturn null;\n+\t}\n }",
    "output": "Use release from asset if differ from release name with GitHub resolver"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/SwitchRegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/SwitchRegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/SwitchRegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/SwitchRegionMaker.java\n@@ -58,7 +58,7 @@ BlockNode process(IRegion currentRegion, BlockNode block, SwitchInsn insn, Regio\n \t\tcurrentRegion.getSubBlocks().add(sw);\n \t\tstack.push(sw);\n \n-\t\tBlockNode out = calcSwitchOut(block, stack);\n+\t\tBlockNode out = calcSwitchOut(block, insn, stack);\n \t\tstack.addExit(out);\n \n \t\tprocessFallThroughCases(sw, out, stack, blocksMap);\n@@ -122,7 +122,7 @@ private BlockNode getOneIntersectionBlock(BlockNode out, BitSet caseBlocks, BitS\n \t\treturn BlockUtils.bitSetToOneBlock(mth, caseExits);\n \t}\n \n-\tprivate @Nullable BlockNode calcSwitchOut(BlockNode block, RegionStack stack) {\n+\tprivate @Nullable BlockNode calcSwitchOut(BlockNode block, SwitchInsn insn, RegionStack stack) {\n \t\t// union of case blocks dominance frontier\n \t\t// works if no fallthrough cases and no returns inside switch\n \t\tBitSet outs = BlockUtils.newBlocksBitSet(mth);\n@@ -184,11 +184,9 @@ private BlockNode getOneIntersectionBlock(BlockNode out, BitSet caseBlocks, BitS\n \t\t\t// check if all returns are equals and should be treated as single out block\n \t\t\treturn allSameReturns(stack);\n \t\t}\n-\t\tif (out != imPostDom && !mth.isPreExitBlock(imPostDom)) {\n-\t\t\t// stop other paths at common exit\n-\t\t\tstack.addExit(imPostDom);\n-\t\t}\n-\t\tif (block.getCleanSuccessors().contains(imPostDom)) {\n+\t\tif (imPostDom == insn.getDefTargetBlock()\n+\t\t\t\t&& block.getCleanSuccessors().contains(imPostDom)\n+\t\t\t\t&& block.getDomFrontier().get(imPostDom.getId())) {\n \t\t\t// add exit to stop on empty 'default' block\n \t\t\tstack.addExit(imPostDom);\n \t\t}\n@@ -343,5 +341,4 @@ private boolean insertContinueInSwitch(BlockNode switchBlock, BlockNode switchOu\n \t\t}\n \t\treturn inserted;\n \t}\n-\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n@@ -513,7 +513,7 @@ private List<File> compileSourceFiles(List<File> compileFileList) throws IOExcep\n \t}\n \n \tprivate void saveToJar(List<File> files, Path baseDir) throws IOException {\n-\t\tPath jarFile = Files.createTempFile(testDir, \"tests-\" + getTestName() + '-', \".jar\");\n+\t\tPath jarFile = Files.createTempFile(\"tests-\" + getTestName() + '-', \".jar\");\n \t\ttry (JarOutputStream jar = new JarOutputStream(Files.newOutputStream(jarFile))) {\n \t\t\tfor (File file : files) {\n \t\t\t\tPath fullPath = file.toPath();\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop5.java b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop5.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop5.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop5.java\n@@ -0,0 +1,38 @@\n+package jadx.tests.integration.switches;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestSwitchInLoop5 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tprivate static int test(int r) {\n+\t\t\tint i;\n+\t\t\twhile (true) {\n+\t\t\t\tswitch (r) {\n+\t\t\t\t\tcase 42:\n+\t\t\t\t\t\ti = 32;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase 52:\n+\t\t\t\t\t\ti = 42;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tSystem.out.println(\"Default switch case\");\n+\t\t\t\t\t\treturn 1;\n+\t\t\t\t}\n+\t\t\t\tr = i;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"default:\")\n+\t\t\t\t.containsOne(\"System.out.println(\");\n+\t}\n+}",
    "output": "Fix additional checks for default switch case exit"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/tools/ConvertArscFile.java b/jadx-cli/src/main/java/jadx/cli/tools/ConvertArscFile.java\n--- a/jadx-cli/src/main/java/jadx/cli/tools/ConvertArscFile.java\n+++ b/jadx-cli/src/main/java/jadx/cli/tools/ConvertArscFile.java\n@@ -1,6 +1,5 @@\n package jadx.cli.tools;\n \n-import java.io.BufferedInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.file.Files;\n@@ -71,7 +70,7 @@ public static void main(String[] args) throws IOException {\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Load resources.arsc from extracted file\n-\t\t\t\ttry (InputStream inputStream = new BufferedInputStream(Files.newInputStream(resFile))) {\n+\t\t\t\ttry (InputStream inputStream = Files.newInputStream(resFile)) {\n \t\t\t\t\tresTableParser.decode(inputStream);\n \t\t\t\t}\n \t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java\n@@ -18,6 +18,7 @@ public class ParserStream {\n \n \tprivate final InputStream input;\n \tprivate long readPos = 0;\n+\tprivate long markPos = 0;\n \n \tpublic ParserStream(@NotNull InputStream inputStream) {\n \t\tthis.input = inputStream;\n@@ -143,10 +144,12 @@ public void mark(int len) throws IOException {\n \t\t\tthrow new IOException(\"Mark not supported for input stream \" + input.getClass());\n \t\t}\n \t\tinput.mark(len);\n+\t\tmarkPos = readPos;\n \t}\n \n \tpublic void reset() throws IOException {\n \t\tinput.reset();\n+\t\treadPos = markPos;\n \t}\n \n \tpublic void readFully(byte[] b) throws IOException {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n@@ -1,5 +1,6 @@\n package jadx.core.xmlgen;\n \n+import java.io.BufferedInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.ArrayList;\n@@ -79,7 +80,7 @@ public ResTableBinaryParser(RootNode root, boolean useRawResNames) {\n \t@Override\n \tpublic void decode(InputStream inputStream) throws IOException {\n \t\tlong start = System.currentTimeMillis();\n-\t\tis = new ParserStream(inputStream);\n+\t\tis = new ParserStream(new BufferedInputStream(inputStream, 32768));\n \t\tresStorage = new ResourceStorage(root.getArgs().getSecurity());\n \t\tdecodeTableChunk();\n \t\tresStorage.finish();\n@@ -234,6 +235,7 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t\t/* int size = */\n \t\tlong chunkSize = is.readUInt32();\n \t\tlong chunkEnd = start + chunkSize;\n+\t\tis.mark((int) chunkSize);\n \n \t\t// The type identifier this chunk is holding. Type IDs start at 1 (corresponding\n \t\t// to the value of the type bits in a resource identifier). 0 is invalid.\n@@ -286,7 +288,12 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t\t\t\tLOG.warn(\"End of chunk reached - ignoring remaining {} entries\", entryCount - index);\n \t\t\t\tbreak;\n \t\t\t}\n-\t\t\tis.checkPos(entriesStart + offset, \"Expected start of entry \" + index);\n+\t\t\tlong entryStartOffset = entriesStart + offset;\n+\t\t\tif (entryStartOffset < is.getPos()) {\n+\t\t\t\t// workaround for issue #2343: if the entryStartOffset is located before our current position\n+\t\t\t\tis.reset();\n+\t\t\t}\n+\t\t\tis.skipToPos(entryStartOffset, \"Expected start of entry \" + index);\n \t\t\tparseEntry(pkg, id, index, config.getQualifiers());\n \t\t}\n \t\tif (chunkEnd > is.getPos()) {",
    "output": "Fix allow jumping backwards to an already processed position Use buffered stream to allow going backwards in stream in case the type chunk entries are not ordered properly (see #2343)."
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ReplaceNewArray.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ReplaceNewArray.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ReplaceNewArray.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReplaceNewArray.java\n@@ -25,7 +25,6 @@\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n-import jadx.core.utils.BlockUtils;\n import jadx.core.utils.InsnList;\n import jadx.core.utils.InsnRemover;\n import jadx.core.utils.InsnUtils;\n@@ -109,11 +108,15 @@ private static boolean processNewArray(MethodNode mth,\n \t\t}\n \t\t// collect put instructions sorted by array index\n \t\tSortedMap<Long, InsnNode> arrPuts = new TreeMap<>();\n+\t\tInsnNode firstNotAPutUsage = null;\n \t\tfor (RegisterArg registerArg : useList) {\n \t\t\tInsnNode parentInsn = registerArg.getParentInsn();\n \t\t\tif (parentInsn == null\n \t\t\t\t\t|| parentInsn.getType() != InsnType.APUT\n \t\t\t\t\t|| !arrArg.sameRegAndSVar(parentInsn.getArg(0))) {\n+\t\t\t\tif (firstNotAPutUsage == null) {\n+\t\t\t\t\tfirstNotAPutUsage = parentInsn;\n+\t\t\t\t}\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tObject constVal = InsnUtils.getConstValueByArg(mth.root(), parentInsn.getArg(1));\n@@ -158,12 +161,23 @@ private static boolean processNewArray(MethodNode mth,\n \t\t\tremover.addAndUnbind(put);\n \t\t\tprevIndex = index;\n \t\t}\n+\t\t// add missing trailing zeros\n+\t\tfor (long i = prevIndex + 1; i < len; i++) {\n+\t\t\tfilledArr.addArg(InsnArg.lit(0, elemType));\n+\t\t}\n \t\tremover.addAndUnbind(newArrayInsn);\n \n+\t\t// place new insn at last array put or before first usage\n \t\tInsnNode lastPut = arrPuts.get(arrPuts.lastKey());\n-\t\tint replaceIndex = InsnList.getIndex(instructions, lastPut);\n-\t\tinstructions.set(replaceIndex, filledArr);\n-\t\tBlockUtils.replaceInsn(mth, lastPut, filledArr);\n+\t\tint newInsnPos = InsnList.getIndex(instructions, lastPut);\n+\t\tif (firstNotAPutUsage != null) {\n+\t\t\tint idx = InsnList.getIndex(instructions, firstNotAPutUsage);\n+\t\t\tif (idx != -1) {\n+\t\t\t\t// TODO: check that all args already assigned\n+\t\t\t\tnewInsnPos = Math.min(idx, newInsnPos);\n+\t\t\t}\n+\t\t}\n+\t\tinstructions.add(newInsnPos, filledArr);\n \t\treturn true;\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInitField2.java b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInitField2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInitField2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInitField2.java\n@@ -0,0 +1,17 @@\n+package jadx.tests.integration.arrays;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestArrayInitField2 extends SmaliTest {\n+\t@Test\n+\tpublic void test() {\n+\t\tforceDecompiledCheck();\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"static long[] myArr = {1282979400, 0, 0};\");\n+\t}\n+}",
    "output": "Fix insert new filled array insn before first usage"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/regions/SwitchRegion.java b/jadx-core/src/main/java/jadx/core/dex/regions/SwitchRegion.java\n--- a/jadx-core/src/main/java/jadx/core/dex/regions/SwitchRegion.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/regions/SwitchRegion.java\n@@ -58,12 +58,6 @@ public void addCase(List<Object> keysList, IContainer c) {\n \t\tcases.add(new CaseInfo(keysList, c));\n \t}\n \n-\tpublic void addDefaultCase(IContainer c) {\n-\t\tif (c != null) {\n-\t\t\tcases.add(new CaseInfo(Collections.singletonList(DEFAULT_CASE_KEY), c));\n-\t\t}\n-\t}\n-\n \tpublic List<CaseInfo> getCases() {\n \t\treturn cases;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java\n@@ -106,10 +106,9 @@ private boolean restoreSwitchOverString(MethodNode mth, SwitchRegion switchRegio\n \t\t\t// all checks passed, replace with new switch\n \t\t\tIRegion parentRegion = switchRegion.getParent();\n \t\t\tSwitchRegion replaceRegion = new SwitchRegion(parentRegion, switchRegion.getHeader());\n-\t\t\tfor (CaseData caseData : switchData.getCases()) {\n-\t\t\t\treplaceRegion.addCase(Collections.unmodifiableList(caseData.getStrValues()), caseData.getCode());\n+\t\t\tfor (SwitchRegion.CaseInfo caseInfo : switchData.getNewCases()) {\n+\t\t\t\treplaceRegion.addCase(Collections.unmodifiableList(caseInfo.getKeys()), caseInfo.getContainer());\n \t\t\t}\n-\t\t\treplaceRegion.addDefaultCase(switchData.getDefaultCode());\n \t\t\tif (!parentRegion.replaceSubBlock(switchRegion, replaceRegion)) {\n \t\t\t\tmth.addWarnComment(\"Failed to restore switch over string. Please report as a decompilation issue\");\n \t\t\t\treturn false;\n@@ -216,36 +215,53 @@ private boolean mergeWithCode(SwitchData switchData) {\n \t\t\t\t\tblock -> switchData.getToRemove().add(block));\n \t\t}\n \n-\t\tIContainer defaultContainer = null;\n+\t\tfinal var newCases = new ArrayList<SwitchRegion.CaseInfo>();\n \t\tfor (SwitchRegion.CaseInfo caseInfo : codeSwitch.getCases()) {\n-\t\t\tCaseData prevCase = null;\n+\t\t\tSwitchRegion.CaseInfo newCase = null;\n \t\t\tfor (Object key : caseInfo.getKeys()) {\n \t\t\t\tfinal Integer intKey = unwrapIntKey(key);\n \t\t\t\tif (intKey != null) {\n-\t\t\t\t\tCaseData caseData = casesMap.get(intKey);\n+\t\t\t\t\tfinal var caseData = casesMap.remove(intKey);\n \t\t\t\t\tif (caseData == null) {\n \t\t\t\t\t\treturn false;\n \t\t\t\t\t}\n-\t\t\t\t\tif (prevCase == null) {\n-\t\t\t\t\t\tcaseData.setCode(caseInfo.getContainer());\n-\t\t\t\t\t\tprevCase = caseData;\n+\t\t\t\t\tif (newCase == null) {\n+\t\t\t\t\t\tfinal List<Object> keys = new ArrayList<>(caseData.getStrValues());\n+\t\t\t\t\t\tnewCase = new SwitchRegion.CaseInfo(keys, caseInfo.getContainer());\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// merge cases\n-\t\t\t\t\t\tprevCase.getStrValues().addAll(caseData.getStrValues());\n-\t\t\t\t\t\tcaseData.setCodeNum(-1);\n+\t\t\t\t\t\tnewCase.getKeys().addAll(caseData.getStrValues());\n \t\t\t\t\t}\n \t\t\t\t} else if (key == SwitchRegion.DEFAULT_CASE_KEY) {\n-\t\t\t\t\tdefaultContainer = caseInfo.getContainer();\n+\t\t\t\t\tfinal var iterator = casesMap.entrySet().iterator();\n+\t\t\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\t\t\tfinal var caseData = iterator.next().getValue();\n+\t\t\t\t\t\tif (newCase == null) {\n+\t\t\t\t\t\t\tfinal List<Object> keys = new ArrayList<>(caseData.getStrValues());\n+\t\t\t\t\t\t\tnewCase = new SwitchRegion.CaseInfo(keys, caseInfo.getContainer());\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t// merge cases\n+\t\t\t\t\t\t\tnewCase.getKeys().addAll(caseData.getStrValues());\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\titerator.remove();\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (newCase == null) {\n+\t\t\t\t\t\tnewCase = new SwitchRegion.CaseInfo(new ArrayList<>(), caseInfo.getContainer());\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tnewCase.getKeys().add(SwitchRegion.DEFAULT_CASE_KEY);\n \t\t\t\t} else {\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \t\t\t}\n+\t\t\tnewCases.add(newCase);\n \t\t}\n-\t\tcases.removeIf(c -> c.getCodeNum() == -1);\n \n-\t\tswitchData.setDefaultCode(defaultContainer);\n \t\tswitchData.setCodeSwitch(codeSwitch);\n \t\tswitchData.setNumArg(numArg);\n+\t\tswitchData.setNewCases(newCases);\n \t\treturn true;\n \t}\n \n@@ -367,7 +383,7 @@ private static final class SwitchData {\n \t\tprivate final List<IAttributeNode> toRemove = new ArrayList<>();\n \t\tprivate Map<InsnNode, String> strEqInsns;\n \t\tprivate List<CaseData> cases;\n-\t\tprivate IContainer defaultCode;\n+\t\tprivate List<SwitchRegion.CaseInfo> newCases;\n \t\tprivate SwitchRegion codeSwitch;\n \t\tprivate RegisterArg numArg;\n \n@@ -384,12 +400,12 @@ public void setCases(List<CaseData> cases) {\n \t\t\tthis.cases = cases;\n \t\t}\n \n-\t\tpublic IContainer getDefaultCode() {\n-\t\t\treturn defaultCode;\n+\t\tpublic List<SwitchRegion.CaseInfo> getNewCases() {\n+\t\t\treturn newCases;\n \t\t}\n \n-\t\tpublic void setDefaultCode(IContainer defaultCode) {\n-\t\t\tthis.defaultCode = defaultCode;\n+\t\tpublic void setNewCases(List<SwitchRegion.CaseInfo> cases) {\n+\t\t\tthis.newCases = cases;\n \t\t}\n \n \t\tpublic MethodNode getMth() {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchOverStrings2.java b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchOverStrings2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchOverStrings2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchOverStrings2.java\n@@ -0,0 +1,43 @@\n+package jadx.tests.integration.switches;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestSwitchOverStrings2 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic int test(String str) {\n+\t\t\tswitch (str) {\n+\t\t\t\tcase \"branch1\":\n+\t\t\t\tcase \"branch2\":\n+\t\t\t\t\treturn 1;\n+\t\t\t\tcase \"branch3\":\n+\t\t\t\tcase \"branch4\":\n+\t\t\t\tdefault:\n+\t\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(test(\"branch1\")).isEqualTo(1);\n+\t\t\tassertThat(test(\"branch2\")).isEqualTo(1);\n+\t\t\tassertThat(test(\"branch3\")).isEqualTo(0);\n+\t\t\tassertThat(test(\"branch4\")).isEqualTo(0);\n+\t\t\tassertThat(test(\"other\")).isEqualTo(0);\n+\t\t\tassertThat(test(\"other2\")).isEqualTo(0);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.countString(4, \"case \")\n+\t\t\t\t.countString(1, \"default:\")\n+\t\t\t\t.countString(2, \"return \");\n+\t}\n+}",
    "output": "Fix support \"fall-through to default\" case in switch-over-string"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java\n@@ -318,6 +318,9 @@ private boolean processCase(SwitchData switchData, SwitchRegion.CaseInfo caseInf\n \t\t\tif (ifInsn.getOp() == IfOp.NE && ifInsn.getArg(1).isTrue()) {\n \t\t\t\tneg = true;\n \t\t\t}\n+\t\t\tif (ifInsn.getOp() == IfOp.EQ && ifInsn.getArg(1).isFalse()) {\n+\t\t\t\tneg = true;\n+\t\t\t}\n \t\t\tif (str != null) {\n \t\t\t\tswitchData.getToRemove().add(ifInsn);\n \t\t\t\tswitchData.getToRemove().addAll(ifRegion.getConditionBlocks());",
    "output": "Fix improve negation condition checks for switch over string"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java\n@@ -12,6 +12,8 @@\n \n import org.jetbrains.annotations.Nullable;\n \n+import jadx.api.plugins.input.data.annotations.EncodedType;\n+import jadx.api.plugins.input.data.attributes.JadxAttrType;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.IAttributeNode;\n import jadx.core.dex.attributes.nodes.CodeFeaturesAttr;\n@@ -26,6 +28,7 @@\n import jadx.core.dex.instructions.args.LiteralArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n import jadx.core.dex.instructions.args.SSAVar;\n+import jadx.core.dex.nodes.FieldNode;\n import jadx.core.dex.nodes.IContainer;\n import jadx.core.dex.nodes.IRegion;\n import jadx.core.dex.nodes.InsnNode;\n@@ -217,8 +220,8 @@ private boolean mergeWithCode(SwitchData switchData) {\n \t\tfor (SwitchRegion.CaseInfo caseInfo : codeSwitch.getCases()) {\n \t\t\tCaseData prevCase = null;\n \t\t\tfor (Object key : caseInfo.getKeys()) {\n-\t\t\t\tif (key instanceof Integer) {\n-\t\t\t\t\tInteger intKey = (Integer) key;\n+\t\t\t\tfinal Integer intKey = unwrapIntKey(key);\n+\t\t\t\tif (intKey != null) {\n \t\t\t\t\tCaseData caseData = casesMap.get(intKey);\n \t\t\t\t\tif (caseData == null) {\n \t\t\t\t\t\treturn false;\n@@ -246,6 +249,21 @@ private boolean mergeWithCode(SwitchData switchData) {\n \t\treturn true;\n \t}\n \n+\tprivate Integer unwrapIntKey(Object key) {\n+\t\tif (key instanceof Integer) {\n+\t\t\treturn (Integer) key;\n+\t\t} else if (key instanceof FieldNode) {\n+\t\t\tfinal var encodedValue = ((FieldNode) key).get(JadxAttrType.CONSTANT_VALUE);\n+\t\t\tif (encodedValue != null && encodedValue.getType() == EncodedType.ENCODED_INT) {\n+\t\t\t\treturn (Integer) encodedValue.getValue();\n+\t\t\t} else {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn null;\n+\t}\n+\n \tprivate static Map<InsnNode, String> collectEqualsInsns(MethodNode mth, SSAVar strVar) {\n \t\tMap<InsnNode, String> map = new IdentityHashMap<>(strVar.getUseCount() - 1);\n \t\tfor (RegisterArg useReg : strVar.getUseList()) {",
    "output": "Fix unwrap consts in switch-over-string"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n@@ -8,11 +8,14 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.stream.Collectors;\n \n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.api.plugins.input.data.attributes.IJadxAttrType;\n+import jadx.api.plugins.input.data.attributes.IJadxAttribute;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.LoopInfo;\n@@ -36,6 +39,8 @@\n public class BlockProcessor extends AbstractVisitor {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(BlockProcessor.class);\n \n+\tprivate static final boolean DEBUG_MODS = false;\n+\n \t@Override\n \tpublic void visit(MethodNode mth) {\n \t\tif (mth.isNoCode() || mth.getBasicBlocks().isEmpty()) {\n@@ -57,13 +62,27 @@ private static void processBlocksTree(MethodNode mth) {\n \t\t}\n \t\tupdateCleanSuccessors(mth);\n \n+\t\tint blocksCount = mth.getBasicBlocks().size();\n+\t\tint modLimit = Math.max(100, blocksCount);\n+\t\tif (DEBUG_MODS) {\n+\t\t\tmth.addAttr(new DebugModAttr());\n+\t\t}\n \t\tint i = 0;\n \t\twhile (modifyBlocksTree(mth)) {\n \t\t\tcomputeDominators(mth);\n-\t\t\tif (i++ > 100) {\n-\t\t\t\tthrow new JadxRuntimeException(\"CFG modification limit reached, blocks count: \" + mth.getBasicBlocks().size());\n+\t\t\tif (i++ > modLimit) {\n+\t\t\t\tmth.addWarn(\"CFG modification limit reached, blocks count: \" + blocksCount);\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n+\t\tif (DEBUG_MODS && i != 0) {\n+\t\t\tString stats = \"CFG modifications count: \" + i\n+\t\t\t\t\t+ \", blocks count: \" + blocksCount + '\\n'\n+\t\t\t\t\t+ mth.get(DebugModAttr.TYPE).formatStats() + '\\n';\n+\t\t\tmth.addDebugComment(stats);\n+\t\t\tLOG.debug(\"Method: {}\\n{}\", mth, stats);\n+\t\t\tmth.remove(DebugModAttr.TYPE);\n+\t\t}\n \t\tcheckForUnreachableBlocks(mth);\n \n \t\tDominatorTree.computeDominanceFrontier(mth);\n@@ -298,6 +317,9 @@ private static boolean mergeConstReturn(MethodNode mth) {\n \t\t}\n \t\tif (changed) {\n \t\t\tremoveMarkedBlocks(mth);\n+\t\t\tif (DEBUG_MODS) {\n+\t\t\t\tmth.get(DebugModAttr.TYPE).addEvent(\"Merge const return\");\n+\t\t\t}\n \t\t}\n \t\treturn changed;\n \t}\n@@ -338,17 +360,20 @@ private static boolean independentBlockTreeMod(MethodNode mth) {\n \n \tprivate static boolean simplifyLoopEnd(MethodNode mth, LoopInfo loop) {\n \t\tBlockNode loopEnd = loop.getEnd();\n-\t\tif (loopEnd.getSuccessors().size() > 1) {\n-\t\t\t// make loop end a simple path block\n-\t\t\tBlockNode newLoopEnd = BlockSplitter.startNewBlock(mth, -1);\n-\t\t\tnewLoopEnd.add(AFlag.SYNTHETIC);\n-\t\t\tnewLoopEnd.add(AFlag.LOOP_END);\n-\t\t\tBlockNode loopStart = loop.getStart();\n-\t\t\tBlockSplitter.replaceConnection(loopEnd, loopStart, newLoopEnd);\n-\t\t\tBlockSplitter.connect(newLoopEnd, loopStart);\n-\t\t\treturn true;\n+\t\tif (loopEnd.getSuccessors().size() <= 1) {\n+\t\t\treturn false;\n \t\t}\n-\t\treturn false;\n+\t\t// make loop end a simple path block\n+\t\tBlockNode newLoopEnd = BlockSplitter.startNewBlock(mth, -1);\n+\t\tnewLoopEnd.add(AFlag.SYNTHETIC);\n+\t\tnewLoopEnd.add(AFlag.LOOP_END);\n+\t\tBlockNode loopStart = loop.getStart();\n+\t\tBlockSplitter.replaceConnection(loopEnd, loopStart, newLoopEnd);\n+\t\tBlockSplitter.connect(newLoopEnd, loopStart);\n+\t\tif (DEBUG_MODS) {\n+\t\t\tmth.get(DebugModAttr.TYPE).addEvent(\"Simplify loop end\");\n+\t\t}\n+\t\treturn true;\n \t}\n \n \tprivate static boolean checkLoops(MethodNode mth, BlockNode block) {\n@@ -371,7 +396,6 @@ private static boolean checkLoops(MethodNode mth, BlockNode block) {\n \t\tif (loopsCount == 1) {\n \t\t\tLoopInfo loop = loops.get(0);\n \t\t\treturn insertBlocksForContinue(mth, loop)\n-\t\t\t\t\t|| insertBlockForPredecessors(mth, loop)\n \t\t\t\t\t|| insertPreHeader(mth, loop)\n \t\t\t\t\t|| simplifyLoopEnd(mth, loop);\n \t\t}\n@@ -398,15 +422,21 @@ private static boolean insertPreHeader(MethodNode mth, LoopInfo loop) {\n \t\t\tmth.setEnterBlock(newEnterBlock);\n \t\t\tstart.remove(AFlag.MTH_ENTER_BLOCK);\n \t\t\tBlockSplitter.connect(newEnterBlock, start);\n-\t\t\treturn true;\n+\t\t} else {\n+\t\t\t// multiple predecessors\n+\t\t\tBlockNode preHeader = BlockSplitter.startNewBlock(mth, -1);\n+\t\t\tpreHeader.add(AFlag.SYNTHETIC);\n+\t\t\tBlockNode loopEnd = loop.getEnd();\n+\t\t\tfor (BlockNode pred : new ArrayList<>(preds)) {\n+\t\t\t\tif (pred != loopEnd) {\n+\t\t\t\t\tBlockSplitter.replaceConnection(pred, start, preHeader);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tBlockSplitter.connect(preHeader, start);\n \t\t}\n-\t\t// multiple predecessors\n-\t\tBlockNode preHeader = BlockSplitter.startNewBlock(mth, -1);\n-\t\tpreHeader.add(AFlag.SYNTHETIC);\n-\t\tfor (BlockNode pred : new ArrayList<>(preds)) {\n-\t\t\tBlockSplitter.replaceConnection(pred, start, preHeader);\n+\t\tif (DEBUG_MODS) {\n+\t\t\tmth.get(DebugModAttr.TYPE).addEvent(\"Insert loop pre header\");\n \t\t}\n-\t\tBlockSplitter.connect(preHeader, start);\n \t\treturn true;\n \t}\n \n@@ -426,6 +456,9 @@ private static boolean insertBlocksForBreak(MethodNode mth, LoopInfo loop) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tif (DEBUG_MODS && change) {\n+\t\t\tmth.get(DebugModAttr.TYPE).addEvent(\"Insert loop break blocks\");\n+\t\t}\n \t\treturn change;\n \t}\n \n@@ -444,24 +477,10 @@ private static boolean insertBlocksForContinue(MethodNode mth, LoopInfo loop) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\treturn change;\n-\t}\n-\n-\t/**\n-\t * Insert additional block if loop header has several predecessors (exclude back edges)\n-\t */\n-\tprivate static boolean insertBlockForPredecessors(MethodNode mth, LoopInfo loop) {\n-\t\tBlockNode loopHeader = loop.getStart();\n-\t\tList<BlockNode> preds = loopHeader.getPredecessors();\n-\t\tif (preds.size() > 2) {\n-\t\t\tList<BlockNode> blocks = new ArrayList<>(preds);\n-\t\t\tblocks.removeIf(block -> block.contains(AFlag.LOOP_END));\n-\t\t\tBlockNode first = blocks.remove(0);\n-\t\t\tBlockNode preHeader = BlockSplitter.insertBlockBetween(mth, first, loopHeader);\n-\t\t\tblocks.forEach(block -> BlockSplitter.replaceConnection(block, loopHeader, preHeader));\n-\t\t\treturn true;\n+\t\tif (DEBUG_MODS && change) {\n+\t\t\tmth.get(DebugModAttr.TYPE).addEvent(\"Insert loop continue block\");\n \t\t}\n-\t\treturn false;\n+\t\treturn change;\n \t}\n \n \tprivate static boolean splitLoops(MethodNode mth, BlockNode block, List<LoopInfo> loops) {\n@@ -472,17 +491,20 @@ private static boolean splitLoops(MethodNode mth, BlockNode block, List<LoopInfo\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tif (oneHeader) {\n-\t\t\t// several back edges connected to one loop header => make additional block\n-\t\t\tBlockNode newLoopEnd = BlockSplitter.startNewBlock(mth, block.getStartOffset());\n-\t\t\tnewLoopEnd.add(AFlag.SYNTHETIC);\n-\t\t\tconnect(newLoopEnd, block);\n-\t\t\tfor (LoopInfo la : loops) {\n-\t\t\t\tBlockSplitter.replaceConnection(la.getEnd(), block, newLoopEnd);\n-\t\t\t}\n-\t\t\treturn true;\n+\t\tif (!oneHeader) {\n+\t\t\treturn false;\n \t\t}\n-\t\treturn false;\n+\t\t// several back edges connected to one loop header => make additional block\n+\t\tBlockNode newLoopEnd = BlockSplitter.startNewBlock(mth, block.getStartOffset());\n+\t\tnewLoopEnd.add(AFlag.SYNTHETIC);\n+\t\tconnect(newLoopEnd, block);\n+\t\tfor (LoopInfo la : loops) {\n+\t\t\tBlockSplitter.replaceConnection(la.getEnd(), block, newLoopEnd);\n+\t\t}\n+\t\tif (DEBUG_MODS) {\n+\t\t\tmth.get(DebugModAttr.TYPE).addEvent(\"Split loops\");\n+\t\t}\n+\t\treturn true;\n \t}\n \n \tprivate static boolean splitExitBlocks(MethodNode mth) {\n@@ -496,6 +518,9 @@ private static boolean splitExitBlocks(MethodNode mth) {\n \t\t}\n \t\tif (changed) {\n \t\t\tupdateExitBlockConnections(mth);\n+\t\t\tif (DEBUG_MODS) {\n+\t\t\t\tmth.get(DebugModAttr.TYPE).addEvent(\"Split exit block\");\n+\t\t\t}\n \t\t}\n \t\treturn changed;\n \t}\n@@ -691,4 +716,25 @@ private static void clearBlocksState(MethodNode mth) {\n \t\t\tblock.getDominatesOn().clear();\n \t\t});\n \t}\n+\n+\tprivate static final class DebugModAttr implements IJadxAttribute {\n+\t\tstatic final IJadxAttrType<DebugModAttr> TYPE = IJadxAttrType.create(\"DebugModAttr\");\n+\n+\t\tprivate final Map<String, Integer> statMap = new HashMap<>();\n+\n+\t\tpublic void addEvent(String name) {\n+\t\t\tstatMap.merge(name, 1, Integer::sum);\n+\t\t}\n+\n+\t\tpublic String formatStats() {\n+\t\t\treturn statMap.entrySet().stream()\n+\t\t\t\t\t.map(entry -> \" \" + entry.getKey() + \": \" + entry.getValue())\n+\t\t\t\t\t.collect(Collectors.joining(\"\\n\"));\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic IJadxAttrType<DebugModAttr> getAttrType() {\n+\t\t\treturn TYPE;\n+\t\t}\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopRestore3.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopRestore3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopRestore3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopRestore3.java\n@@ -0,0 +1,18 @@\n+package jadx.tests.integration.loops;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestLoopRestore3 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.countString(3, \"while (\");\n+\t}\n+}\n\ndiff --git a/jadx-plugins/jadx-input-api/src/main/java/jadx/api/plugins/input/data/attributes/IJadxAttrType.java b/jadx-plugins/jadx-input-api/src/main/java/jadx/api/plugins/input/data/attributes/IJadxAttrType.java\n--- a/jadx-plugins/jadx-input-api/src/main/java/jadx/api/plugins/input/data/attributes/IJadxAttrType.java\n+++ b/jadx-plugins/jadx-input-api/src/main/java/jadx/api/plugins/input/data/attributes/IJadxAttrType.java\n@@ -18,4 +18,13 @@ static <A extends IJadxAttribute> IJadxAttrType<A> create() {\n \t\treturn new IJadxAttrType<>() {\n \t\t};\n \t}\n+\n+\tstatic <A extends IJadxAttribute> IJadxAttrType<A> create(String name) {\n+\t\treturn new IJadxAttrType<>() {\n+\t\t\t@Override\n+\t\t\tpublic String toString() {\n+\t\t\t\treturn name;\n+\t\t\t}\n+\t\t};\n+\t}\n }",
    "output": "Fix prevent endless loop in pre header insertion mod"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/SwitchOverStringVisitor.java\n@@ -103,10 +103,10 @@ private boolean restoreSwitchOverString(MethodNode mth, SwitchRegion switchRegio\n \t\t\t// all checks passed, replace with new switch\n \t\t\tIRegion parentRegion = switchRegion.getParent();\n \t\t\tSwitchRegion replaceRegion = new SwitchRegion(parentRegion, switchRegion.getHeader());\n-\t\t\treplaceRegion.addDefaultCase(switchData.getDefaultCode());\n \t\t\tfor (CaseData caseData : switchData.getCases()) {\n \t\t\t\treplaceRegion.addCase(Collections.unmodifiableList(caseData.getStrValues()), caseData.getCode());\n \t\t\t}\n+\t\t\treplaceRegion.addDefaultCase(switchData.getDefaultCode());\n \t\t\tif (!parentRegion.replaceSubBlock(switchRegion, replaceRegion)) {\n \t\t\t\tmth.addWarnComment(\"Failed to restore switch over string. Please report as a decompilation issue\");\n \t\t\t\treturn false;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java\n--- a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java\n@@ -4,13 +4,20 @@\n import java.util.Arrays;\n import java.util.List;\n import java.util.function.Function;\n+import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n import org.assertj.core.api.AbstractStringAssert;\n+import org.assertj.core.internal.Failures;\n \n import jadx.tests.api.utils.TestUtils;\n \n+import static org.assertj.core.error.ShouldNotContainSubsequence.shouldNotContainSubsequence;\n+\n public class JadxCodeAssertions extends AbstractStringAssert<JadxCodeAssertions> {\n+\n+\tprivate Failures failures = Failures.instance();\n+\n \tpublic JadxCodeAssertions(String code) {\n \t\tsuper(code, JadxCodeAssertions.class);\n \t}\n@@ -65,6 +72,21 @@ public JadxCodeAssertions containsLines(int commonIndent, String... lines) {\n \t\treturn containsOnlyOnce(sb.substring(1));\n \t}\n \n+\tpublic JadxCodeAssertions doesNotContainSubsequence(CharSequence... values) {\n+\t\tfinal var regex = Arrays.stream(values)\n+\t\t\t\t.map(value -> Pattern.quote(value.toString()))\n+\t\t\t\t.collect(Collectors.joining(\".*\"));\n+\n+\t\tfinal var pattern = Pattern.compile(regex, Pattern.DOTALL);\n+\n+\t\tfinal var matcher = pattern.matcher(actual);\n+\t\tif (matcher.find()) {\n+\t\t\tthrow failures.failure(info, shouldNotContainSubsequence(actual, values, matcher.start()));\n+\t\t}\n+\n+\t\treturn this;\n+\t}\n+\n \tpublic JadxCodeAssertions removeBlockComments() {\n \t\tString code = actual.replaceAll(\"/\\\\*.*\\\\*/\", \"\");\n \t\tJadxCodeAssertions newCode = new JadxCodeAssertions(code);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchOverStrings.java b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchOverStrings.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchOverStrings.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchOverStrings.java\n@@ -46,6 +46,7 @@ public void test() {\n \t\t\t\t.code()\n \t\t\t\t.doesNotContain(\"case -603257287:\")\n \t\t\t\t.doesNotContain(\"c = \")\n+\t\t\t\t.doesNotContainSubsequence(\"default:\", \"case \")\n \t\t\t\t.containsOne(\"case \\\"frewhyh\\\":\")\n \t\t\t\t.countString(5, \"return \");\n \t}",
    "output": "Fix default branch position in switch-over-string"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java\n@@ -243,9 +243,10 @@ private JPopupMenu createTabPopupMenu() {\n \t\tif (tabs.size() > 1) {\n \t\t\tJMenuItem closeOther = new JMenuItem(NLS.str(\"tabs.closeOthers\"));\n \t\t\tcloseOther.addActionListener(e -> {\n+\t\t\t\tJNode currentNode = getNode();\n \t\t\t\tfor (TabBlueprint tab : tabs) {\n-\t\t\t\t\tif (tab != getBlueprint()) {\n-\t\t\t\t\t\ttabsController.closeTab(getNode(), true);\n+\t\t\t\t\tif (tab.getNode() != currentNode) {\n+\t\t\t\t\t\ttabsController.closeTab(tab, true);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t});\n@@ -310,7 +311,6 @@ public TabBlueprint getBlueprint() {\n \t\tif (blueprint == null) {\n \t\t\tthrow new JadxRuntimeException(\"TabComponent does not have a corresponding TabBlueprint\");\n \t\t}\n-\n \t\treturn blueprint;\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n@@ -163,16 +163,16 @@ public void closeTab(JNode node) {\n \n \tpublic void closeTab(JNode node, boolean considerPins) {\n \t\tTabBlueprint blueprint = getTabByNode(node);\n-\n-\t\tif (blueprint == null) {\n-\t\t\treturn;\n+\t\tif (blueprint != null) {\n+\t\t\tcloseTab(blueprint, considerPins);\n \t\t}\n+\t}\n \n+\tpublic void closeTab(TabBlueprint blueprint, boolean considerPins) {\n \t\tif (forceClose) {\n \t\t\tcloseTabForce(blueprint);\n \t\t\treturn;\n \t\t}\n-\n \t\tif (!considerPins || !blueprint.isPinned()) {\n \t\t\tif (!blueprint.isReferenced()) {\n \t\t\t\tcloseTabForce(blueprint);\n@@ -182,15 +182,15 @@ public void closeTab(JNode node, boolean considerPins) {\n \t\t}\n \t}\n \n-\t/*\n+\t/**\n \t * Removes Tab from everywhere\n \t */\n \tprivate void closeTabForce(TabBlueprint blueprint) {\n \t\tlisteners.forEach(l -> l.onTabClose(blueprint));\n \t\ttabsMap.remove(blueprint.getNode());\n \t}\n \n-\t/*\n+\t/**\n \t * Hides Tab from TabbedPane\n \t */\n \tprivate void closeTabSoft(TabBlueprint blueprint) {",
    "output": "Fix correct tabs filter in \"Close others\" tab action"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettingsGroup.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettingsGroup.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettingsGroup.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettingsGroup.java\n@@ -141,11 +141,11 @@ private static void fillListModel(DefaultListModel<BasePluginListNode> listModel\n \t\t\tList<BasePluginListNode> nodes, List<AvailablePluginNode> available) {\n \t\tlistModel.clear();\n \t\tlistModel.addElement(new TitleNode(\"Installed\"));\n-\t\tnodes.stream().filter(n -> n.getVersion() != null).forEach(listModel::addElement);\n+\t\tnodes.stream().filter(n -> n.getAction() == PluginAction.UNINSTALL).forEach(listModel::addElement);\n \t\tlistModel.addElement(new TitleNode(\"Available\"));\n \t\tlistModel.addAll(available);\n \t\tlistModel.addElement(new TitleNode(\"Bundled\"));\n-\t\tnodes.stream().filter(n -> n.getVersion() == null).forEach(listModel::addElement);\n+\t\tnodes.stream().filter(n -> n.getAction() == PluginAction.NONE).forEach(listModel::addElement);\n \t}\n \n \tprivate void loadAvailablePlugins(DefaultListModel<BasePluginListNode> listModel,",
    "output": "Use correct section filter in plugins list"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/plugins/CollectPlugins.java b/jadx-gui/src/main/java/jadx/gui/utils/plugins/CollectPlugins.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/plugins/CollectPlugins.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/plugins/CollectPlugins.java\n@@ -7,16 +7,17 @@\n \n import jadx.api.JadxArgs;\n import jadx.api.JadxDecompiler;\n+import jadx.cli.plugins.JadxFilesGetter;\n+import jadx.core.plugins.AppContext;\n import jadx.core.plugins.JadxPluginManager;\n import jadx.core.plugins.PluginContext;\n-import jadx.gui.JadxWrapper;\n import jadx.gui.ui.MainWindow;\n import jadx.plugins.tools.JadxExternalPluginsLoader;\n \n /**\n  * Collect all plugins.\n  * Init not yet loaded plugins in new temporary context.\n- * Support case if decompiler in wrapper not initialized yet.\n+ * Support a case if decompiler in wrapper is not initialized yet.\n  */\n public class CollectPlugins {\n \n@@ -31,19 +32,26 @@ public List<PluginContext> build() {\n \t\tmainWindow.getWrapper().getCurrentDecompiler()\n \t\t\t\t.ifPresent(decompiler -> allPlugins.addAll(decompiler.getPluginManager().getResolvedPluginContexts()));\n \n-\t\t// collect and init not loaded plugins in new context\n+\t\t// collect and init not loaded plugins in new temp context\n \t\ttry (JadxDecompiler decompiler = new JadxDecompiler(new JadxArgs())) {\n \t\t\tJadxPluginManager pluginManager = decompiler.getPluginManager();\n+\t\t\tpluginManager.registerAddPluginListener(pluginContext -> {\n+\t\t\t\tAppContext appContext = new AppContext();\n+\t\t\t\tappContext.setGuiContext(null); // load temp plugins without UI context\n+\t\t\t\tappContext.setFilesGetter(JadxFilesGetter.INSTANCE);\n+\t\t\t\tpluginContext.setAppContext(appContext);\n+\t\t\t});\n \t\t\tpluginManager.load(new JadxExternalPluginsLoader());\n-\t\t\tJadxWrapper.initGuiPluginsContext(decompiler, mainWindow);\n \t\t\tSortedSet<PluginContext> missingPlugins = new TreeSet<>();\n \t\t\tfor (PluginContext context : pluginManager.getAllPluginContexts()) {\n \t\t\t\tif (!allPlugins.contains(context)) {\n \t\t\t\t\tmissingPlugins.add(context);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tpluginManager.init(missingPlugins);\n-\t\t\tallPlugins.addAll(missingPlugins);\n+\t\t\tif (!missingPlugins.isEmpty()) {\n+\t\t\t\tpluginManager.init(missingPlugins);\n+\t\t\t\tallPlugins.addAll(missingPlugins);\n+\t\t\t}\n \t\t}\n \t\treturn new ArrayList<>(allPlugins);\n \t}",
    "output": "Fix load plugins settings in temp context without UI"
  },
  {
    "input": "diff --git a/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java b/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n--- a/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n+++ b/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n@@ -54,7 +54,9 @@ void testAttrEnum() {\n \t\tResourceStorage resStorage = new ResourceStorage(security);\n \t\tResourceEntry re = new ResourceEntry(2130903103, \"jadx.gui.app\", \"attr\", \"size\", \"\");\n \t\tre.setNamedValues(\n-\t\t\t\tLists.list(new RawNamedValue(16777216, new RawValue(16, 65536)), new RawNamedValue(17039620, new RawValue(16, 1))));\n+\t\t\t\tLists.list(\n+\t\t\t\t\t\tnew RawNamedValue(0x01000000, new RawValue(16, 65536)),\n+\t\t\t\t\t\tnew RawNamedValue(0x01040000, new RawValue(16, 1))));\n \t\tresStorage.add(re);\n \n \t\tValuesParser vp = new ValuesParser(null, resStorage.getResourcesNames());\n@@ -67,7 +69,7 @@ void testAttrEnum() {\n \t\tassertThat(input).isEqualTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n \t\t\t\t+ \"<resources>\\n\"\n \t\t\t\t+ \"    <attr name=\\\"size\\\">\\n\"\n-\t\t\t\t+ \"        <enum name=\\\"android:string.aerr_wait\\\" value=\\\"1\\\" />\\n\"\n+\t\t\t\t+ \"        <enum name=\\\"android:string.cancel\\\" value=\\\"1\\\" />\\n\"\n \t\t\t\t+ \"    </attr>\\n\"\n \t\t\t\t+ \"</resources>\");\n \t}\n@@ -77,7 +79,9 @@ void testAttrFlag() {\n \t\tResourceStorage resStorage = new ResourceStorage(security);\n \t\tResourceEntry re = new ResourceEntry(2130903103, \"jadx.gui.app\", \"attr\", \"size\", \"\");\n \t\tre.setNamedValues(\n-\t\t\t\tLists.list(new RawNamedValue(16777216, new RawValue(16, 131072)), new RawNamedValue(17039620, new RawValue(16, 1))));\n+\t\t\t\tLists.list(\n+\t\t\t\t\t\tnew RawNamedValue(0x01000000, new RawValue(16, 131072)),\n+\t\t\t\t\t\tnew RawNamedValue(0x01040000, new RawValue(16, 1))));\n \t\tresStorage.add(re);\n \n \t\tValuesParser vp = new ValuesParser(null, resStorage.getResourcesNames());\n@@ -90,7 +94,7 @@ void testAttrFlag() {\n \t\tassertThat(input).isEqualTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n \t\t\t\t+ \"<resources>\\n\"\n \t\t\t\t+ \"    <attr name=\\\"size\\\">\\n\"\n-\t\t\t\t+ \"        <flag name=\\\"android:string.aerr_wait\\\" value=\\\"1\\\" />\\n\"\n+\t\t\t\t+ \"        <flag name=\\\"android:string.cancel\\\" value=\\\"1\\\" />\\n\"\n \t\t\t\t+ \"    </attr>\\n\"\n \t\t\t\t+ \"</resources>\");\n \t}",
    "output": "Fix update Android attrs to API 35"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/conditions/ExcludePackageWithTLDNames.java b/jadx-core/src/main/java/jadx/core/deobf/conditions/ExcludePackageWithTLDNames.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/conditions/ExcludePackageWithTLDNames.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/conditions/ExcludePackageWithTLDNames.java\n@@ -9,32 +9,30 @@\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n /**\n- * Provides a list of all top level domains with 3 characters and less,\n- * so we can exclude them from deobfuscation.\n+ * Provides a list of all top level domains, so we can exclude them from deobfuscation.\n  */\n public class ExcludePackageWithTLDNames extends AbstractDeobfCondition {\n \n \t/**\n \t * Lazy load TLD set\n \t */\n \tprivate static class TldHolder {\n-\t\tprivate static final Set<String> TLD_SET = loadTldFile();\n+\t\tprivate static final Set<String> TLD_SET = loadTldSet();\n \t}\n \n-\tprivate static Set<String> loadTldFile() {\n-\t\ttry (BufferedReader reader = new BufferedReader(new InputStreamReader(TldHolder.class.getResourceAsStream(\"tld_3.txt\")))) {\n+\tprivate static Set<String> loadTldSet() {\n+\t\ttry (BufferedReader reader = new BufferedReader(new InputStreamReader(TldHolder.class.getResourceAsStream(\"tlds.txt\")))) {\n \t\t\treturn reader.lines()\n-\t\t\t\t\t.map(String::trim)\n \t\t\t\t\t.filter(line -> !line.startsWith(\"#\") && !line.isEmpty())\n \t\t\t\t\t.collect(Collectors.toSet());\n \t\t} catch (Exception e) {\n-\t\t\tthrow new JadxRuntimeException(\"Failed to load top level domain list file: tld_3.txt\", e);\n+\t\t\tthrow new JadxRuntimeException(\"Failed to load top level domain list file: tlds.txt\", e);\n \t\t}\n \t}\n \n \t@Override\n \tpublic Action check(PackageNode pkg) {\n-\t\tif (TldHolder.TLD_SET.contains(pkg.getName())) {\n+\t\tif (pkg.isRoot() && TldHolder.TLD_SET.contains(pkg.getName())) {\n \t\t\treturn Action.FORBID_RENAME;\n \t\t}\n \t\treturn Action.NO_ACTION;",
    "output": "Fix update TLDs"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/JPreferredFontChooser.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/JPreferredFontChooser.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/JPreferredFontChooser.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/JPreferredFontChooser.java\n@@ -1,52 +0,0 @@\n-package jadx.gui.settings.ui;\n-\n-import java.awt.GraphicsEnvironment;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import say.swing.JFontChooser;\n-\n-public class JPreferredFontChooser extends JFontChooser {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(JPreferredFontChooser.class);\n-\n-\tprivate static final String[] PREFERRED_FONTS = new String[] {\n-\t\t\t\"Monospaced\", \"Consolas\", \"Courier\", \"Courier New\",\n-\t\t\t\"Lucida Sans Typewriter\", \"Lucida Console\",\n-\t\t\t\"SimSun\", \"SimHei\",\n-\t};\n-\n-\tprivate String[] filteredFonts;\n-\n-\t@Override\n-\tprotected String[] getFontFamilies() {\n-\t\tif (filteredFonts == null) {\n-\t\t\tGraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();\n-\t\t\tSet<String> fontSet = new HashSet<>();\n-\t\t\tCollections.addAll(fontSet, env.getAvailableFontFamilyNames());\n-\t\t\tList<String> found = new ArrayList<>(PREFERRED_FONTS.length);\n-\t\t\tfor (String font : PREFERRED_FONTS) {\n-\t\t\t\tif (fontSet.contains(font)) {\n-\t\t\t\t\tfound.add(font);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (found.size() == PREFERRED_FONTS.length) {\n-\t\t\t\tfilteredFonts = PREFERRED_FONTS;\n-\t\t\t} else if (found.size() > 0) {\n-\t\t\t\tfilteredFonts = new String[found.size()];\n-\t\t\t\tfor (int i = 0; i < found.size(); i++) {\n-\t\t\t\t\tfilteredFonts[i] = found.get(i);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tLOG.warn(\"Can't found any preferred fonts for smali, use all available.\");\n-\t\t\t\tfilteredFonts = env.getAvailableFontFamilyNames();\n-\t\t\t}\n-\t\t}\n-\t\treturn filteredFonts;\n-\t}\n-}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n@@ -44,8 +44,6 @@\n import com.google.gson.GsonBuilder;\n import com.google.gson.JsonObject;\n \n-import say.swing.JFontChooser;\n-\n import jadx.api.CommentsLevel;\n import jadx.api.DecompilationMode;\n import jadx.api.JadxArgs;\n@@ -63,6 +61,7 @@\n import jadx.gui.settings.LineNumbersMode;\n import jadx.gui.settings.XposedCodegenLanguage;\n import jadx.gui.settings.ui.cache.CacheSettingsGroup;\n+import jadx.gui.settings.ui.font.JadxFontDialog;\n import jadx.gui.settings.ui.plugins.PluginSettings;\n import jadx.gui.settings.ui.shortcut.ShortcutsSettingsGroup;\n import jadx.gui.ui.MainWindow;\n@@ -371,11 +370,9 @@ private SettingsGroup makeAppearanceGroup() {\n \t\tfontBtn.addMouseListener(new MouseAdapter() {\n \t\t\t@Override\n \t\t\tpublic void mouseClicked(MouseEvent e) {\n-\t\t\t\tJFontChooser fontChooser = new JFontChooser();\n-\t\t\t\tfontChooser.setSelectedFont(settings.getFont());\n-\t\t\t\tint result = fontChooser.showDialog(JadxSettingsWindow.this);\n-\t\t\t\tif (result == JFontChooser.OK_OPTION) {\n-\t\t\t\t\tFont font = fontChooser.getSelectedFont();\n+\t\t\t\tFont font = new JadxFontDialog(JadxSettingsWindow.this, NLS.str(\"preferences.font\"))\n+\t\t\t\t\t\t.select(settings.getFont(), false);\n+\t\t\t\tif (font != null) {\n \t\t\t\t\tLOG.debug(\"Selected Font: {}\", font);\n \t\t\t\t\tsettings.setFont(font);\n \t\t\t\t\tmainWindow.loadSettings();\n@@ -387,11 +384,9 @@ public void mouseClicked(MouseEvent e) {\n \t\tsmaliFontBtn.addMouseListener(new MouseAdapter() {\n \t\t\t@Override\n \t\t\tpublic void mouseClicked(MouseEvent e) {\n-\t\t\t\tJFontChooser fontChooser = new JPreferredFontChooser();\n-\t\t\t\tfontChooser.setSelectedFont(settings.getSmaliFont());\n-\t\t\t\tint result = fontChooser.showDialog(JadxSettingsWindow.this);\n-\t\t\t\tif (result == JFontChooser.OK_OPTION) {\n-\t\t\t\t\tFont font = fontChooser.getSelectedFont();\n+\t\t\t\tFont font = new JadxFontDialog(JadxSettingsWindow.this, NLS.str(\"preferences.smali_font\"))\n+\t\t\t\t\t\t.select(settings.getSmaliFont(), true);\n+\t\t\t\tif (font != null) {\n \t\t\t\t\tLOG.debug(\"Selected Font: {} for smali\", font);\n \t\t\t\t\tsettings.setSmaliFont(font);\n \t\t\t\t\tmainWindow.loadSettings();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/font/FontChooserHack.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/font/FontChooserHack.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/font/FontChooserHack.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/font/FontChooserHack.java\n@@ -0,0 +1,31 @@\n+package jadx.gui.settings.ui.font;\n+\n+import java.lang.reflect.Field;\n+\n+import javax.swing.JCheckBox;\n+\n+import org.drjekyll.fontchooser.FontChooser;\n+import org.drjekyll.fontchooser.panes.FamilyPane;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FontChooserHack {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FontChooserHack.class);\n+\n+\tpublic static void setOnlyMonospace(FontChooser fontChooser) {\n+\t\ttry {\n+\t\t\tFamilyPane familyPane = (FamilyPane) getPrivateField(fontChooser, \"familyPane\");\n+\t\t\tJCheckBox monospacedCheckBox = (JCheckBox) getPrivateField(familyPane, \"monospacedCheckBox\");\n+\t\t\tmonospacedCheckBox.setSelected(true);\n+\t\t\tmonospacedCheckBox.setEnabled(false);\n+\t\t} catch (Throwable e) {\n+\t\t\tLOG.debug(\"Failed to set only monospace check box\", e);\n+\t\t}\n+\t}\n+\n+\tprivate static Object getPrivateField(Object obj, String fieldName) throws NoSuchFieldException, IllegalAccessException {\n+\t\tField f = obj.getClass().getDeclaredField(fieldName);\n+\t\tf.setAccessible(true);\n+\t\treturn f.get(obj);\n+\t}\n+}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/font/JadxFontDialog.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/font/JadxFontDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/font/JadxFontDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/font/JadxFontDialog.java\n@@ -0,0 +1,86 @@\n+package jadx.gui.settings.ui.font;\n+\n+import java.awt.BorderLayout;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+\n+import javax.swing.BorderFactory;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JPanel;\n+import javax.swing.WindowConstants;\n+\n+import org.drjekyll.fontchooser.FontChooser;\n+import org.jetbrains.annotations.Nullable;\n+\n+import jadx.gui.settings.JadxSettings;\n+import jadx.gui.settings.ui.JadxSettingsWindow;\n+import jadx.gui.utils.NLS;\n+\n+public class JadxFontDialog extends JDialog {\n+\tprivate static final long serialVersionUID = 7609857698785777587L;\n+\n+\tprivate final FontChooser fontChooser = new FontChooser();\n+\tprivate final JadxSettings settings;\n+\tprivate boolean selected = false;\n+\n+\tpublic JadxFontDialog(JadxSettingsWindow settingsWindow, String title) {\n+\t\tsuper(settingsWindow, title, true);\n+\t\tsettings = settingsWindow.getMainWindow().getSettings();\n+\t\tinitComponents();\n+\t\tsetDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n+\t\tif (!settings.loadWindowPos(this)) {\n+\t\t\tpack();\n+\t\t}\n+\t}\n+\n+\tpublic @Nullable Font select(Font currentFont, boolean onlyMonospace) {\n+\t\tfontChooser.setSelectedFont(currentFont);\n+\t\tif (onlyMonospace) {\n+\t\t\tFontChooserHack.setOnlyMonospace(fontChooser);\n+\t\t}\n+\t\tsetVisible(true);\n+\t\tFont selectedFont = fontChooser.getSelectedFont();\n+\t\tif (selected && !selectedFont.equals(currentFont)) {\n+\t\t\treturn selectedFont;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate void initComponents() {\n+\t\tJPanel chooserPanel = new JPanel();\n+\t\tchooserPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 0, 10));\n+\t\tchooserPanel.setLayout(new BorderLayout(0, 10));\n+\t\tchooserPanel.add(fontChooser);\n+\n+\t\tJPanel controlPanel = new JPanel();\n+\t\tcontrolPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n+\t\tcontrolPanel.setLayout(new FlowLayout(FlowLayout.TRAILING));\n+\n+\t\tJButton okBtn = new JButton();\n+\t\tokBtn.setText(NLS.str(\"common_dialog.ok\"));\n+\t\tokBtn.setMnemonic('o');\n+\t\tokBtn.addActionListener(event -> {\n+\t\t\tselected = true;\n+\t\t\tdispose();\n+\t\t});\n+\n+\t\tJButton cancelBtn = new JButton();\n+\t\tcancelBtn.setText(NLS.str(\"common_dialog.cancel\"));\n+\t\tcancelBtn.setMnemonic('c');\n+\t\tcancelBtn.addActionListener(event -> dispose());\n+\n+\t\tcontrolPanel.add(okBtn);\n+\t\tcontrolPanel.add(cancelBtn);\n+\n+\t\tadd(chooserPanel);\n+\t\tadd(controlPanel, BorderLayout.PAGE_END);\n+\t\tgetRootPane().setDefaultButton(okBtn);\n+\t}\n+\n+\t@Override\n+\tpublic void dispose() {\n+\t\tsettings.saveWindowPos(this);\n+\t\tsuper.dispose();\n+\t}\n+}",
    "output": "Use another implementation for font dialog"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/SettingsGroup.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/SettingsGroup.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/SettingsGroup.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/SettingsGroup.java\n@@ -15,8 +15,6 @@\n import jadx.api.plugins.gui.ISettingsGroup;\n \n public class SettingsGroup implements ISettingsGroup {\n-\tprivate static final long serialVersionUID = -6487309975896192544L;\n-\n \tprivate final String title;\n \tprivate final JPanel panel;\n \tprivate final JPanel gridPanel;\n@@ -48,14 +46,14 @@ public JLabel addRow(String label, String tooltip, JComponent comp) {\n \t\tc.gridx = 0;\n \t\tc.gridwidth = 1;\n \t\tc.anchor = GridBagConstraints.LINE_START;\n-\t\tc.weightx = 0.8;\n-\t\tc.fill = GridBagConstraints.NONE;\n+\t\tc.weightx = 0.1;\n+\t\tc.fill = GridBagConstraints.LINE_START;\n \t\tgridPanel.add(rowLbl, c);\n \t\tc.gridx = 1;\n \t\tc.gridwidth = GridBagConstraints.REMAINDER;\n-\t\tc.anchor = GridBagConstraints.CENTER;\n-\t\tc.weightx = 0.2;\n-\t\tc.fill = GridBagConstraints.HORIZONTAL;\n+\t\tc.anchor = GridBagConstraints.LINE_START;\n+\t\tc.weightx = 0.7;\n+\t\tc.fill = GridBagConstraints.LINE_START;\n \n \t\tif (tooltip != null) {\n \t\t\trowLbl.setToolTipText(tooltip);",
    "output": "Fix in settings row reduce space between description and value"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettingsGroup.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettingsGroup.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettingsGroup.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/plugins/PluginSettingsGroup.java\n@@ -38,6 +38,7 @@\n import jadx.core.utils.StringUtils;\n import jadx.core.utils.Utils;\n import jadx.gui.ui.MainWindow;\n+import jadx.gui.utils.Link;\n import jadx.gui.utils.NLS;\n import jadx.gui.utils.UiUtils;\n import jadx.plugins.tools.JadxPluginsList;\n@@ -141,10 +142,10 @@ private static void fillListModel(DefaultListModel<BasePluginListNode> listModel\n \t\tlistModel.clear();\n \t\tlistModel.addElement(new TitleNode(\"Installed\"));\n \t\tnodes.stream().filter(n -> n.getVersion() != null).forEach(listModel::addElement);\n-\t\tlistModel.addElement(new TitleNode(\"Bundled\"));\n-\t\tnodes.stream().filter(n -> n.getVersion() == null).forEach(listModel::addElement);\n \t\tlistModel.addElement(new TitleNode(\"Available\"));\n \t\tlistModel.addAll(available);\n+\t\tlistModel.addElement(new TitleNode(\"Bundled\"));\n+\t\tnodes.stream().filter(n -> n.getVersion() == null).forEach(listModel::addElement);\n \t}\n \n \tprivate void loadAvailablePlugins(DefaultListModel<BasePluginListNode> listModel,\n@@ -176,16 +177,15 @@ private void onSelection(BasePluginListNode node) {\n \t\t\tFont baseFont = nameLbl.getFont();\n \t\t\tnameLbl.setFont(baseFont.deriveFont(Font.BOLD, baseFont.getSize2D() + 2));\n \n-\t\t\tString desc;\n+\t\t\tJLabel homeLink = null;\n \t\t\tString homepage = node.getHomepage();\n \t\t\tif (StringUtils.notBlank(homepage)) {\n-\t\t\t\tdesc = node.getDescription() + \"\\n\\nHomepage: \" + homepage;\n-\t\t\t} else {\n-\t\t\t\tdesc = node.getDescription();\n+\t\t\t\thomeLink = new Link(\"Homepage: \" + homepage, homepage);\n+\t\t\t\thomeLink.setHorizontalAlignment(SwingConstants.LEFT);\n \t\t\t}\n \n \t\t\tJTextPane descArea = new JTextPane();\n-\t\t\tdescArea.setText(desc);\n+\t\t\tdescArea.setText(node.getDescription());\n \t\t\tdescArea.setFont(baseFont.deriveFont(baseFont.getSize2D() + 1));\n \t\t\tdescArea.setEditable(false);\n \t\t\tdescArea.setBorder(BorderFactory.createEmptyBorder());\n@@ -200,8 +200,22 @@ private void onSelection(BasePluginListNode node) {\n \t\t\tif (actionBtn != null) {\n \t\t\t\ttop.add(actionBtn);\n \t\t\t}\n+\n+\t\t\tJPanel center = new JPanel();\n+\t\t\tcenter.setLayout(new BoxLayout(center, BoxLayout.PAGE_AXIS));\n+\t\t\tcenter.setBorder(BorderFactory.createEmptyBorder(10, 2, 10, 2));\n+\t\t\tcenter.add(descArea);\n+\t\t\tif (homeLink != null) {\n+\t\t\t\tJPanel link = new JPanel();\n+\t\t\t\tlink.setLayout(new BoxLayout(link, BoxLayout.LINE_AXIS));\n+\t\t\t\tlink.add(homeLink);\n+\t\t\t\tlink.add(Box.createHorizontalGlue());\n+\t\t\t\tcenter.add(link);\n+\t\t\t}\n+\t\t\tcenter.add(Box.createVerticalGlue());\n+\n \t\t\tdetailsPanel.add(top, BorderLayout.PAGE_START);\n-\t\t\tdetailsPanel.add(descArea, BorderLayout.CENTER);\n+\t\t\tdetailsPanel.add(center, BorderLayout.CENTER);\n \t\t}\n \t\tdetailsPanel.updateUI();\n \t}\n@@ -241,15 +255,18 @@ public PluginsListCellRenderer() {\n \t\t\tnameLbl.setOpaque(true);\n \t\t\tversionLbl = new JLabel(\"\");\n \t\t\tversionLbl.setOpaque(true);\n+\t\t\tversionLbl.setPreferredSize(new Dimension(40, 10));\n \n \t\t\tpanel.add(nameLbl);\n \t\t\tpanel.add(Box.createHorizontalStrut(20));\n \t\t\tpanel.add(Box.createHorizontalGlue());\n \t\t\tpanel.add(versionLbl);\n+\t\t\tpanel.add(Box.createHorizontalStrut(10));\n \n \t\t\ttitleLbl = new JLabel();\n \t\t\ttitleLbl.setHorizontalAlignment(SwingConstants.CENTER);\n \t\t\ttitleLbl.setEnabled(false);\n+\t\t\tversionLbl.setPreferredSize(new Dimension(40, 10));\n \t\t}\n \n \t\t@Override",
    "output": "Fix improve plugins preferences group"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -178,7 +178,7 @@ public void close() {\n \t\tcloseInputs();\n \t\tcloseLoaders();\n \t\targs.close();\n-\t\tFileUtils.deleteTempRootDir();\n+\t\tFileUtils.clearTempRootDir();\n \t}\n \n \tprivate void closeInputs() {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n@@ -152,7 +152,7 @@ public static void deleteDirIfExists(Path dir) {\n \t\t}\n \t}\n \n-\tprivate static final SimpleFileVisitor<Path> FILE_DELETE_VISITOR = new SimpleFileVisitor<Path>() {\n+\tprivate static final SimpleFileVisitor<Path> FILE_DELETE_VISITOR = new SimpleFileVisitor<>() {\n \t\t@Override\n \t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n \t\t\tFiles.delete(file);\n@@ -174,8 +174,30 @@ private static void deleteDir(Path dir) {\n \t\t}\n \t}\n \n-\tpublic static void deleteTempRootDir() {\n-\t\tdeleteDirIfExists(tempRootDir);\n+\tpublic static void clearTempRootDir() {\n+\t\tclearDir(tempRootDir);\n+\t}\n+\n+\tpublic static void clearDir(Path clearDir) {\n+\t\ttry {\n+\t\t\tFiles.walkFileTree(clearDir, Collections.emptySet(), Integer.MAX_VALUE, new SimpleFileVisitor<>() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+\t\t\t\t\tFiles.delete(file);\n+\t\t\t\t\treturn FileVisitResult.CONTINUE;\n+\t\t\t\t}\n+\n+\t\t\t\t@Override\n+\t\t\t\tpublic FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+\t\t\t\t\tif (!dir.equals(clearDir)) {\n+\t\t\t\t\t\tFiles.delete(dir);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn FileVisitResult.CONTINUE;\n+\t\t\t\t}\n+\t\t\t});\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new JadxRuntimeException(\"Failed to clear directory \" + clearDir, e);\n+\t\t}\n \t}\n \n \tpublic static Path createTempDir(String prefix) {",
    "output": "Fix clear temp root dir instead delete"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/JadxSettingsWindow.java\n@@ -666,10 +666,10 @@ private SettingsGroup makeOtherGroup() {\n \t\tgroup.addRow(NLS.str(\"preferences.lineNumbersMode\"), lineNumbersMode);\n \t\tgroup.addRow(NLS.str(\"preferences.jumpOnDoubleClick\"), jumpOnDoubleClick);\n \t\tgroup.addRow(NLS.str(\"preferences.useAlternativeFileDialog\"), useAltFileDialog);\n-\t\tgroup.addRow(NLS.str(\"preferences.check_for_updates\"), update);\n \t\tgroup.addRow(NLS.str(\"preferences.cfg\"), cfg);\n \t\tgroup.addRow(NLS.str(\"preferences.raw_cfg\"), rawCfg);\n \t\tgroup.addRow(NLS.str(\"preferences.xposed_codegen_language\"), xposedCodegenLanguage);\n+\t\tgroup.addRow(NLS.str(\"preferences.check_for_updates\"), update);\n \t\tgroup.addRow(NLS.str(\"preferences.update_channel\"), updateChannel);\n \t\treturn group;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/update/VersionComparator.java b/jadx-gui/src/main/java/jadx/gui/update/VersionComparator.java\n--- a/jadx-gui/src/main/java/jadx/gui/update/VersionComparator.java\n+++ b/jadx-gui/src/main/java/jadx/gui/update/VersionComparator.java\n@@ -14,10 +14,23 @@ private static String clean(String str) {\n \t\t\treturn \"\";\n \t\t}\n \t\tString result = str.trim().toLowerCase();\n+\t\tif (result.startsWith(\"jadx-gui-\")) {\n+\t\t\tresult = result.substring(9);\n+\t\t}\n+\t\tif (result.startsWith(\"jadx-\")) {\n+\t\t\tresult = result.substring(5);\n+\t\t}\n \t\tif (result.charAt(0) == 'v') {\n \t\t\tresult = result.substring(1);\n \t\t}\n-\t\t// treat package version as part of version\n+\t\tif (result.charAt(0) == 'r') {\n+\t\t\tresult = result.substring(1);\n+\t\t\tint dot = result.indexOf('.');\n+\t\t\tif (dot != -1) {\n+\t\t\t\tresult = result.substring(0, dot);\n+\t\t\t}\n+\t\t}\n+\t\t// treat a package version as part of version\n \t\tresult = result.replace('-', '.');\n \t\treturn result;\n \t}\n@@ -50,8 +63,7 @@ private static int compare(String str1, String str2) {\n \n \tprivate static boolean isZeroTail(String[] arr, int pos) {\n \t\tfor (int i = pos; i < arr.length; i++) {\n-\t\t\tString s = arr[i];\n-\t\t\tif (Integer.valueOf(s) != 0) {\n+\t\t\tif (Integer.parseInt(arr[i]) != 0) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/update/data/Asset.java b/jadx-gui/src/main/java/jadx/gui/update/data/Asset.java\n--- a/jadx-gui/src/main/java/jadx/gui/update/data/Asset.java\n+++ b/jadx-gui/src/main/java/jadx/gui/update/data/Asset.java\n@@ -1,75 +0,0 @@\n-package jadx.gui.update.data;\n-\n-import com.google.gson.annotations.SerializedName;\n-\n-public class Asset {\n-\tprivate int id;\n-\tprivate String name;\n-\tprivate long size;\n-\n-\t@SerializedName(\"download_count\")\n-\tprivate int downloadCount;\n-\n-\t@SerializedName(\"browser_download_url\")\n-\tprivate String downloadUrl;\n-\n-\t@SerializedName(\"created_at\")\n-\tprivate String createdAt;\n-\n-\tpublic int getId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic void setId(int id) {\n-\t\tthis.id = id;\n-\t}\n-\n-\tpublic String getName() {\n-\t\treturn name;\n-\t}\n-\n-\tpublic void setName(String name) {\n-\t\tthis.name = name;\n-\t}\n-\n-\tpublic long getSize() {\n-\t\treturn size;\n-\t}\n-\n-\tpublic void setSize(long size) {\n-\t\tthis.size = size;\n-\t}\n-\n-\tpublic int getDownloadCount() {\n-\t\treturn downloadCount;\n-\t}\n-\n-\tpublic void setDownloadCount(int downloadCount) {\n-\t\tthis.downloadCount = downloadCount;\n-\t}\n-\n-\tpublic String getDownloadUrl() {\n-\t\treturn downloadUrl;\n-\t}\n-\n-\tpublic void setDownloadUrl(String downloadUrl) {\n-\t\tthis.downloadUrl = downloadUrl;\n-\t}\n-\n-\tpublic String getCreatedAt() {\n-\t\treturn createdAt;\n-\t}\n-\n-\tpublic void setCreatedAt(String createdAt) {\n-\t\tthis.createdAt = createdAt;\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn name\n-\t\t\t\t+ \", size: \" + String.format(\"%.2fMB\", size / 1024. / 1024.)\n-\t\t\t\t+ \", downloads count: \" + downloadCount\n-\t\t\t\t+ \", url: \" + downloadUrl\n-\t\t\t\t+ \", date: \" + createdAt;\n-\t}\n-}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/update/data/Release.java b/jadx-gui/src/main/java/jadx/gui/update/data/Release.java\n--- a/jadx-gui/src/main/java/jadx/gui/update/data/Release.java\n+++ b/jadx-gui/src/main/java/jadx/gui/update/data/Release.java\n@@ -1,44 +0,0 @@\n-package jadx.gui.update.data;\n-\n-import java.util.List;\n-\n-public class Release {\n-\tprivate int id;\n-\tprivate String name;\n-\tprivate List<Asset> assets;\n-\n-\tpublic String getName() {\n-\t\treturn name;\n-\t}\n-\n-\tpublic void setName(String name) {\n-\t\tthis.name = name;\n-\t}\n-\n-\tpublic int getId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic void setId(int id) {\n-\t\tthis.id = id;\n-\t}\n-\n-\tpublic List<Asset> getAssets() {\n-\t\treturn assets;\n-\t}\n-\n-\tpublic void setAssets(List<Asset> assets) {\n-\t\tthis.assets = assets;\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\tStringBuilder sb = new StringBuilder();\n-\t\tsb.append(name);\n-\t\tfor (Asset asset : getAssets()) {\n-\t\t\tsb.append(\"\\n \");\n-\t\t\tsb.append(asset);\n-\t\t}\n-\t\treturn sb.toString();\n-\t}\n-}\n\ndiff --git a/jadx-gui/src/test/java/jadx/gui/update/VersionComparatorTest.java b/jadx-gui/src/test/java/jadx/gui/update/VersionComparatorTest.java\n--- a/jadx-gui/src/test/java/jadx/gui/update/VersionComparatorTest.java\n+++ b/jadx-gui/src/test/java/jadx/gui/update/VersionComparatorTest.java\n@@ -28,6 +28,11 @@ public void testCompare() {\n \t\tcheckCompare(\"1.3.3.1-1\", \"1.3.3\", 1);\n \t}\n \n+\t@Test\n+\tpublic void testCompareUnstable() {\n+\t\tcheckCompare(\"r2190.ce527ed\", \"jadx-r2299.742d30d\", -1);\n+\t}\n+\n \tprivate static void checkCompare(String a, String b, int result) {\n \t\tassertThat(VersionComparator.checkAndCompare(a, b))\n \t\t\t\t.as(\"Compare %s and %s expect %d\", a, b, result)",
    "output": "Fix update check fixed to match current artifact naming"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n@@ -425,20 +425,26 @@ private ResourceEntry buildResourceEntry(PackageChunk pkg, String config, int re\n \t\t\treturn STUB_ENTRY;\n \t\t}\n \n-\t\tString resName = getResName(typeName, resRef, origKeyName);\n-\t\tResourceEntry newResEntry = new ResourceEntry(resRef, pkg.getName(), typeName, resName, config);\n-\t\tResourceEntry prevResEntry = resStorage.searchEntryWithSameName(newResEntry);\n-\t\tif (prevResEntry != null) {\n-\t\t\tnewResEntry = newResEntry.copyWithId();\n-\n-\t\t\t// rename also previous entry for consistency\n-\t\t\tResourceEntry replaceForPrevEntry = prevResEntry.copyWithId();\n-\t\t\tresStorage.replace(prevResEntry, replaceForPrevEntry);\n-\t\t\tresStorage.addRename(replaceForPrevEntry);\n-\t\t}\n-\t\tif (!Objects.equals(origKeyName, newResEntry.getKeyName())) {\n-\t\t\tresStorage.addRename(newResEntry);\n+\t\tResourceEntry newResEntry;\n+\t\tif (useRawResName) {\n+\t\t\tnewResEntry = new ResourceEntry(resRef, pkg.getName(), typeName, origKeyName, config);\n+\t\t} else {\n+\t\t\tString resName = getResName(typeName, resRef, origKeyName);\n+\t\t\tnewResEntry = new ResourceEntry(resRef, pkg.getName(), typeName, resName, config);\n+\t\t\tResourceEntry prevResEntry = resStorage.searchEntryWithSameName(newResEntry);\n+\t\t\tif (prevResEntry != null) {\n+\t\t\t\tnewResEntry = newResEntry.copyWithId();\n+\n+\t\t\t\t// rename also previous entry for consistency\n+\t\t\t\tResourceEntry replaceForPrevEntry = prevResEntry.copyWithId();\n+\t\t\t\tresStorage.replace(prevResEntry, replaceForPrevEntry);\n+\t\t\t\tresStorage.addRename(replaceForPrevEntry);\n+\t\t\t}\n+\t\t\tif (!Objects.equals(origKeyName, newResEntry.getKeyName())) {\n+\t\t\t\tresStorage.addRename(newResEntry);\n+\t\t\t}\n \t\t}\n+\n \t\tresStorage.add(newResEntry);\n \t\treturn newResEntry;\n \t}",
    "output": "Fix don't rename resource entries when useRawResName = true"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -877,12 +877,7 @@ private boolean nodeClickAction(@Nullable Object obj) {\n \t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t} else if (obj instanceof JNode) {\n-\t\t\t\tJNode node = (JNode) obj;\n-\t\t\t\tif (node.getRootClass() != null) {\n-\t\t\t\t\ttabsController.codeJump(node);\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t\ttabsController.selectTab(node);\n+\t\t\t\ttabsController.codeJump((JNode) obj);\n \t\t\t\treturn true;\n \t\t\t}\n \t\t} catch (Exception e) {\n@@ -1022,7 +1017,7 @@ public void goToAndroidManifest() {\n \t\t}\n \n \t\tJResource res = new JResource(androidManifest, androidManifest.getDeobfName(), JResource.JResType.FILE);\n-\t\ttabsController.selectTab(res);\n+\t\ttabsController.codeJump(res);\n \t}\n \n \tprivate void initMenuAndToolbar() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabComponent.java\n@@ -284,7 +284,7 @@ private JPopupMenu createTabPopupMenu() {\n \t\t\t\tJNode node = tab.getNode();\n \t\t\t\tfinal String clsName = node.makeLongString();\n \t\t\t\tJMenuItem item = new JMenuItem(clsName);\n-\t\t\t\titem.addActionListener(e -> tabsController.selectTab(node));\n+\t\t\t\titem.addActionListener(e -> tabsController.codeJump(node));\n \t\t\t\titem.setIcon(node.getIcon());\n \t\t\t\tmenu.add(item);\n \t\t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n@@ -98,10 +98,15 @@ public void codeJump(JNode node) {\n \t\t}\n \n \t\t// Not an inline node, jump normally\n-\t\tif (node.getPos() != 0 || node.getRootClass() == null) {\n+\t\tif (node.getPos() > 0) {\n \t\t\tcodeJump(new JumpPosition(node));\n \t\t\treturn;\n \t\t}\n+\t\tif (node.getRootClass() == null) {\n+\t\t\t// not a class, select tab without position scroll\n+\t\t\tselectTab(node);\n+\t\t\treturn;\n+\t\t}\n \t\t// node need loading\n \t\tloadCodeWithUIAction(node.getRootClass(), () -> codeJump(new JumpPosition(node)));\n \t}\n@@ -140,15 +145,15 @@ private void jumpToInnerClass(JNode node, JavaClass codeParent, JClass jumpCls)\n \t * Prefer {@link TabsController#codeJump(JNode)} method\n \t */\n \tpublic void codeJump(JumpPosition pos) {\n-\t\tif (selectedTab == null) {\n-\t\t\tLOG.warn(\"Cannot codeJump because selectedTab is null\");\n-\t\t\treturn;\n+\t\tif (selectedTab == null || selectedTab.getNode() != pos.getNode()) {\n+\t\t\tselectTab(pos.getNode());\n \t\t}\n \t\tlisteners.forEach(l -> l.onTabCodeJump(selectedTab, pos));\n \t}\n \n \tpublic void smaliJump(JClass cls, int pos, boolean debugMode) {\n-\t\tTabBlueprint blueprint = openTab(cls);\n+\t\tselectTab(cls);\n+\t\tTabBlueprint blueprint = getTabByNode(cls);\n \t\tlisteners.forEach(l -> l.onTabSmaliJump(blueprint, pos, debugMode));\n \t}",
    "output": "Fix send select tab event before code jump"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n@@ -19,6 +19,7 @@ public class NameMapper {\n \n \tprivate static final Set<String> RESERVED_NAMES = new HashSet<>(\n \t\t\tArrays.asList(\n+\t\t\t\t\t\"_\",\n \t\t\t\t\t\"abstract\",\n \t\t\t\t\t\"assert\",\n \t\t\t\t\t\"boolean\",",
    "output": "Fix update reserved keywords"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/SwitchRegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/SwitchRegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/SwitchRegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/maker/SwitchRegionMaker.java\n@@ -15,6 +15,9 @@\n import jadx.core.dex.attributes.nodes.RegionRefAttr;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.SwitchInsn;\n+import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.instructions.args.InsnArg;\n+import jadx.core.dex.instructions.args.RegisterArg;\n import jadx.core.dex.nodes.BlockNode;\n import jadx.core.dex.nodes.IRegion;\n import jadx.core.dex.nodes.InsnNode;\n@@ -132,11 +135,6 @@ private BlockNode getOneIntersectionBlock(BlockNode out, BitSet caseBlocks, BitS\n \t\t}\n \t\touts.clear(block.getId());\n \t\touts.clear(mth.getExitBlock().getId());\n-\t\tif (outs.isEmpty()) {\n-\t\t\t// switch already contains method exit\n-\t\t\t// add everything, out block not needed\n-\t\t\treturn mth.getExitBlock();\n-\t\t}\n \n \t\tBlockNode out = null;\n \t\tif (outs.cardinality() == 1) {\n@@ -161,6 +159,10 @@ private BlockNode getOneIntersectionBlock(BlockNode out, BitSet caseBlocks, BitS\n \t\t\t\t\t\tout = possibleOut;\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tif (outs.isEmpty()) {\n+\t\t\t\t\t// all exits inside switch, keep inside to exit from loop\n+\t\t\t\t\treturn mth.getExitBlock();\n+\t\t\t\t}\n \t\t\t}\n \t\t\tif (out == null) {\n \t\t\t\tBlockNode imPostDom = block.getIPostDom();\n@@ -177,6 +179,11 @@ private BlockNode getOneIntersectionBlock(BlockNode out, BitSet caseBlocks, BitS\n \t\t\tout = mth.getExitBlock();\n \t\t}\n \t\tBlockNode imPostDom = block.getIPostDom();\n+\t\tif (out == null && imPostDom == mth.getExitBlock()) {\n+\t\t\t// all exits inside switch\n+\t\t\t// check if all returns are equals and should be treated as single out block\n+\t\t\treturn allSameReturns(stack);\n+\t\t}\n \t\tif (out != imPostDom && !mth.isPreExitBlock(imPostDom)) {\n \t\t\t// stop other paths at common exit\n \t\t\tstack.addExit(imPostDom);\n@@ -197,6 +204,58 @@ private BlockNode getOneIntersectionBlock(BlockNode out, BitSet caseBlocks, BitS\n \t\treturn out;\n \t}\n \n+\tprivate BlockNode allSameReturns(RegionStack stack) {\n+\t\tBlockNode exitBlock = mth.getExitBlock();\n+\t\tList<BlockNode> preds = exitBlock.getPredecessors();\n+\t\tint count = preds.size();\n+\t\tif (count == 1) {\n+\t\t\treturn preds.get(0);\n+\t\t}\n+\t\tif (mth.getReturnType() == ArgType.VOID) {\n+\t\t\tfor (BlockNode pred : preds) {\n+\t\t\t\tInsnNode insn = BlockUtils.getLastInsn(pred);\n+\t\t\t\tif (insn == null || insn.getType() != InsnType.RETURN) {\n+\t\t\t\t\treturn exitBlock;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tList<InsnArg> returnArgs = new ArrayList<>();\n+\t\t\tfor (BlockNode pred : preds) {\n+\t\t\t\tInsnNode insn = BlockUtils.getLastInsn(pred);\n+\t\t\t\tif (insn == null || insn.getType() != InsnType.RETURN) {\n+\t\t\t\t\treturn exitBlock;\n+\t\t\t\t}\n+\t\t\t\treturnArgs.add(insn.getArg(0));\n+\t\t\t}\n+\t\t\tInsnArg firstArg = returnArgs.get(0);\n+\t\t\tif (firstArg.isRegister()) {\n+\t\t\t\tRegisterArg reg = (RegisterArg) firstArg;\n+\t\t\t\tfor (int i = 1; i < count; i++) {\n+\t\t\t\t\tInsnArg arg = returnArgs.get(1);\n+\t\t\t\t\tif (!arg.isRegister() || !((RegisterArg) arg).sameCodeVar(reg)) {\n+\t\t\t\t\t\treturn exitBlock;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfor (int i = 1; i < count; i++) {\n+\t\t\t\t\tInsnArg arg = returnArgs.get(1);\n+\t\t\t\t\tif (!arg.equals(firstArg)) {\n+\t\t\t\t\t\treturn exitBlock;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t// confirmed\n+\t\tstack.addExits(preds);\n+\t\t// ignore other returns\n+\t\tfor (int i = 1; i < count; i++) {\n+\t\t\tBlockNode block = preds.get(i);\n+\t\t\tblock.add(AFlag.REMOVE);\n+\t\t\tblock.add(AFlag.ADDED_TO_REGION);\n+\t\t}\n+\t\treturn preds.get(0);\n+\t}\n+\n \t/**\n \t * Remove empty case blocks:\n \t * 1. single 'default' case\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch3.java b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch3.java\n@@ -45,7 +45,7 @@ public void check() {\n \tpublic void test() {\n \t\tassertThat(getClassNode(TestCls.class))\n \t\t\t\t.code()\n-\t\t\t\t.countString(0, \"break;\")\n-\t\t\t\t.countString(3, \"return;\");\n+\t\t\t\t.countString(3, \"break;\")\n+\t\t\t\t.countString(0, \"return;\");\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch4.java b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch4.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch4.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch4.java\n@@ -0,0 +1,40 @@\n+package jadx.tests.integration.switches;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestSwitch4 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\t@SuppressWarnings({ \"FallThrough\", \"unused\" })\n+\t\tprivate static int parse(char[] ch, int off, int len) {\n+\t\t\tint num = ch[off + len - 1] - '0';\n+\t\t\tswitch (len) {\n+\t\t\t\tcase 4:\n+\t\t\t\t\tnum += (ch[off++] - '0') * 1000;\n+\t\t\t\tcase 3:\n+\t\t\t\t\tnum += (ch[off++] - '0') * 100;\n+\t\t\t\tcase 2:\n+\t\t\t\t\tnum += (ch[off] - '0') * 10;\n+\t\t\t}\n+\t\t\treturn num;\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(parse(\"123\".toCharArray(), 0, 3)).isEqualTo(123);\n+\t\t\tassertThat(parse(\"a=1234\".toCharArray(), 2, 4)).isEqualTo(1234);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"switch (\")\n+\t\t\t\t.countString(3, \"case \")\n+\t\t\t\t.doesNotContain(\"break\");\n+\t}\n+}",
    "output": "Fix improve switch out block search if all method exits are inside"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -576,6 +576,7 @@ private void closeAll() {\n \t\tLogCollector.getInstance().reset();\n \t\twrapper.close();\n \t\ttabsController.forceCloseAllTabs();\n+\t\tshortcutsController.reset();\n \t\tUiUtils.resetClipboardOwner();\n \t\tSystem.gc();\n \t\tupdate();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/action/JadxGuiAction.java b/jadx-gui/src/main/java/jadx/gui/ui/action/JadxGuiAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/action/JadxGuiAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/action/JadxGuiAction.java\n@@ -13,8 +13,7 @@\n import jadx.gui.utils.shortcut.Shortcut;\n import jadx.gui.utils.ui.ActionHandler;\n \n-public class JadxGuiAction extends ActionHandler\n-\t\timplements IShortcutAction {\n+public class JadxGuiAction extends ActionHandler implements IShortcutAction {\n \tprivate static final String COMMAND = \"JadxGuiAction.Command.%s\";\n \n \tprivate final ActionModel actionModel;\n@@ -24,7 +23,6 @@ public class JadxGuiAction extends ActionHandler\n \tprivate Shortcut shortcut;\n \n \tpublic JadxGuiAction(ActionModel actionModel) {\n-\t\tsuper();\n \t\tthis.actionModel = actionModel;\n \t\tthis.id = actionModel.name();\n \n@@ -48,7 +46,6 @@ public JadxGuiAction(ActionModel actionModel, Consumer<ActionEvent> consumer) {\n \t}\n \n \tpublic JadxGuiAction(String id) {\n-\t\tsuper();\n \t\tthis.actionModel = null;\n \t\tthis.id = id;\n \n@@ -138,4 +135,9 @@ public void setKeyBinding(KeyStroke keyStroke) {\n \t\t\taddedKeyStroke = keyStroke;\n \t\t}\n \t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"JadxGuiAction{\" + id + \", component: \" + shortcutComponent + '}';\n+\t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/menu/JadxMenu.java b/jadx-gui/src/main/java/jadx/gui/ui/menu/JadxMenu.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/menu/JadxMenu.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/menu/JadxMenu.java\n@@ -1,6 +1,7 @@\n package jadx.gui.ui.menu;\n \n import javax.swing.Action;\n+import javax.swing.JComponent;\n import javax.swing.JMenu;\n import javax.swing.JMenuItem;\n \n@@ -10,11 +11,18 @@\n import jadx.gui.utils.shortcut.ShortcutsController;\n \n public class JadxMenu extends JMenu {\n+\t// fake component to fill action shortcut component property\n+\tprivate static final JComponent JADX_MENU_COMPONENT = new JComponent() {\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"JADX_MENU_COMPONENT\";\n+\t\t}\n+\t};\n+\n \tprivate final ShortcutsController shortcutsController;\n \n \tpublic JadxMenu(String name, ShortcutsController shortcutsController) {\n \t\tsuper(name);\n-\n \t\tthis.shortcutsController = shortcutsController;\n \t}\n \n@@ -33,7 +41,12 @@ public JMenuItem add(Action action) {\n \n \tpublic void bindAction(Action action) {\n \t\tif (action instanceof JadxGuiAction) {\n-\t\t\tshortcutsController.bind((JadxGuiAction) action);\n+\t\t\tJadxGuiAction guiAction = (JadxGuiAction) action;\n+\t\t\tJComponent shortcutComponent = guiAction.getShortcutComponent();\n+\t\t\tif (shortcutComponent == null) {\n+\t\t\t\tguiAction.setShortcutComponent(JADX_MENU_COMPONENT);\n+\t\t\t}\n+\t\t\tshortcutsController.bind(guiAction);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/shortcut/ShortcutsController.java b/jadx-gui/src/main/java/jadx/gui/utils/shortcut/ShortcutsController.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/shortcut/ShortcutsController.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/shortcut/ShortcutsController.java\n@@ -3,6 +3,8 @@\n import java.awt.AWTEvent;\n import java.awt.Toolkit;\n import java.awt.event.MouseEvent;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n@@ -12,41 +14,42 @@\n import javax.swing.KeyStroke;\n \n import org.jetbrains.annotations.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.settings.JadxSettings;\n import jadx.gui.settings.data.ShortcutsWrapper;\n import jadx.gui.ui.MainWindow;\n+import jadx.gui.ui.action.ActionCategory;\n import jadx.gui.ui.action.ActionModel;\n import jadx.gui.ui.action.IShortcutAction;\n import jadx.gui.utils.UiUtils;\n \n public class ShortcutsController {\n-\tprivate ShortcutsWrapper shortcuts;\n-\tprivate final JadxSettings settings;\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(ShortcutsController.class);\n \n-\tprivate final Map<ActionModel, Set<IShortcutAction>> boundActions = new HashMap<>();\n+\tprivate final JadxSettings settings;\n+\tprivate final Map<ActionModel, Set<IShortcutAction>> boundActions = new EnumMap<>(ActionModel.class);\n+\tprivate final Set<ActionModel> mouseActions = EnumSet.noneOf(ActionModel.class);\n \n-\tprivate Set<ActionModel> mouseActions = null;\n+\tprivate ShortcutsWrapper shortcuts;\n \n \tpublic ShortcutsController(JadxSettings settings) {\n \t\tthis.settings = settings;\n \t}\n \n \tpublic void loadSettings() {\n-\t\tthis.shortcuts = settings.getShortcuts();\n-\n+\t\tshortcuts = settings.getShortcuts();\n \t\tindexMouseActions();\n-\n-\t\tfor (Map.Entry<ActionModel, Set<IShortcutAction>> actionsEntry : boundActions.entrySet()) {\n-\t\t\tActionModel actionModel = actionsEntry.getKey();\n-\t\t\tSet<IShortcutAction> actions = actionsEntry.getValue();\n-\t\t\tShortcut shortcut = get(actionModel);\n+\t\tboundActions.forEach((actionModel, actions) -> {\n \t\t\tif (actions != null) {\n+\t\t\t\tShortcut shortcut = get(actionModel);\n \t\t\t\tfor (IShortcutAction action : actions) {\n \t\t\t\t\taction.setShortcut(shortcut);\n \t\t\t\t}\n \t\t\t}\n-\t\t}\n+\t\t});\n \t}\n \n \t@Nullable\n@@ -56,17 +59,20 @@ public Shortcut get(ActionModel actionModel) {\n \n \tpublic KeyStroke getKeyStroke(ActionModel actionModel) {\n \t\tShortcut shortcut = get(actionModel);\n-\t\tKeyStroke keyStroke = null;\n \t\tif (shortcut != null && shortcut.isKeyboard()) {\n-\t\t\tkeyStroke = shortcut.toKeyStroke();\n+\t\t\treturn shortcut.toKeyStroke();\n \t\t}\n-\t\treturn keyStroke;\n+\t\treturn null;\n \t}\n \n-\t/*\n+\t/**\n \t * Binds to an action and updates its shortcut every time loadSettings is called\n \t */\n \tpublic void bind(IShortcutAction action) {\n+\t\tif (action.getShortcutComponent() == null) {\n+\t\t\tLOG.warn(\"No shortcut component in action: {}\", action, new JadxRuntimeException());\n+\t\t\treturn;\n+\t\t}\n \t\tboundActions.computeIfAbsent(action.getActionModel(), k -> new HashSet<>());\n \t\tboundActions.get(action.getActionModel()).add(action);\n \t}\n@@ -93,15 +99,13 @@ public void registerMouseEventListener(MainWindow mw) {\n \t\t\tif (mw.isSettingsOpen()) {\n \t\t\t\treturn;\n \t\t\t}\n-\n \t\t\tif (!(event instanceof MouseEvent)) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tMouseEvent mouseEvent = (MouseEvent) event;\n \t\t\tif (mouseEvent.getID() != MouseEvent.MOUSE_PRESSED) {\n \t\t\t\treturn;\n \t\t\t}\n-\n \t\t\tint mouseButton = mouseEvent.getButton();\n \t\t\tfor (ActionModel actionModel : mouseActions) {\n \t\t\t\tShortcut shortcut = shortcuts.get(actionModel);\n@@ -121,22 +125,33 @@ public void registerMouseEventListener(MainWindow mw) {\n \t}\n \n \tprivate void indexMouseActions() {\n-\t\tmouseActions = new HashSet<>();\n+\t\tmouseActions.clear();\n \t\tfor (ActionModel actionModel : ActionModel.values()) {\n \t\t\tShortcut shortcut = shortcuts.get(actionModel);\n \t\t\tif (shortcut != null && shortcut.isMouse()) {\n \t\t\t\tmouseActions.add(actionModel);\n-\t\t\t} else {\n-\t\t\t\tmouseActions.remove(actionModel);\n \t\t\t}\n \t\t}\n \t}\n \n \tpublic void unbindActionsForComponent(JComponent component) {\n-\t\tfor (ActionModel actionModel : ActionModel.values()) {\n-\t\t\tSet<IShortcutAction> actions = boundActions.get(actionModel);\n+\t\tfor (Set<IShortcutAction> actions : boundActions.values()) {\n \t\t\tif (actions != null) {\n-\t\t\t\tactions.removeIf(action -> action != null && action.getShortcutComponent() == component);\n+\t\t\t\tactions.removeIf(action -> action == null\n+\t\t\t\t\t\t|| action.getShortcutComponent() == null\n+\t\t\t\t\t\t|| action.getShortcutComponent() == component);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Keep only actions bound to the main window.\n+\t * Other actions will be added on demand.\n+\t */\n+\tpublic void reset() {\n+\t\tfor (ActionModel actionModel : ActionModel.values()) {\n+\t\t\tif (actionModel.getCategory() != ActionCategory.MENU_TOOLBAR) {\n+\t\t\t\tboundActions.remove(actionModel);\n \t\t\t}\n \t\t}\n \t}",
    "output": "Fix prevent old refs leak in shortcuts controller"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/utils/CodeGenUtils.java b/jadx-core/src/main/java/jadx/core/codegen/utils/CodeGenUtils.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/utils/CodeGenUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/utils/CodeGenUtils.java\n@@ -135,10 +135,15 @@ public static void addSourceFileInfo(ICodeWriter code, ClassNode node) {\n \t\t}\n \t}\n \n-\tpublic static void addInputFileInfo(ICodeWriter code, ClassNode node) {\n-\t\tif (node.getClsData() != null && node.checkCommentsLevel(CommentsLevel.INFO)) {\n-\t\t\tString inputFileName = node.getClsData().getInputFileName();\n+\tpublic static void addInputFileInfo(ICodeWriter code, ClassNode cls) {\n+\t\tif (cls.checkCommentsLevel(CommentsLevel.INFO) && cls.getClsData() != null) {\n+\t\t\tString inputFileName = cls.getClsData().getInputFileName();\n \t\t\tif (inputFileName != null) {\n+\t\t\t\tClassNode declCls = cls.getDeclaringClass();\n+\t\t\t\tif (declCls != null && inputFileName.equals(declCls.getClsData().getInputFileName())) {\n+\t\t\t\t\t// don't add same comment for inner classes\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n \t\t\t\tcode.startLine(\"/* loaded from: \").add(inputFileName).add(\" */\");\n \t\t\t}\n \t\t}",
    "output": "Fix don't add same 'loaded from:' comment for inner classes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoAttachVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoAttachVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoAttachVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoAttachVisitor.java\n@@ -1,15 +1,14 @@\n package jadx.core.dex.visitors.debuginfo;\n \n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.stream.Collectors;\n \n import jadx.api.plugins.input.data.IDebugInfo;\n import jadx.api.plugins.input.data.ILocalVar;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.nodes.LocalVarsDebugInfoAttr;\n import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;\n-import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n@@ -20,7 +19,6 @@\n import jadx.core.dex.visitors.JadxVisitor;\n import jadx.core.dex.visitors.blocks.BlockSplitter;\n import jadx.core.dex.visitors.ssa.SSATransform;\n-import jadx.core.utils.ListUtils;\n import jadx.core.utils.exceptions.InvalidDataException;\n import jadx.core.utils.exceptions.JadxException;\n \n@@ -59,30 +57,44 @@ private void attachSourceLines(MethodNode mth, Map<Integer, Integer> lineMapping\n \t\tif (lineMapping.isEmpty()) {\n \t\t\treturn;\n \t\t}\n-\t\tMap<Integer, Integer> linesStat = new HashMap<>(); // count repeating lines\n \t\tfor (Map.Entry<Integer, Integer> entry : lineMapping.entrySet()) {\n \t\t\ttry {\n-\t\t\t\tInteger offset = entry.getKey();\n-\t\t\t\tInsnNode insn = insnArr[offset];\n+\t\t\t\tInsnNode insn = insnArr[entry.getKey()];\n \t\t\t\tif (insn != null) {\n-\t\t\t\t\tint line = entry.getValue();\n-\t\t\t\t\tinsn.setSourceLine(line);\n-\t\t\t\t\tif (insn.getType() != InsnType.NOP) {\n-\t\t\t\t\t\tlinesStat.merge(line, 1, (v, one) -> v + 1);\n-\t\t\t\t\t}\n+\t\t\t\t\tinsn.setSourceLine(entry.getValue());\n \t\t\t\t}\n \t\t\t} catch (Exception e) {\n \t\t\t\tmth.addWarnComment(\"Error attach source line\", e);\n+\t\t\t\treturn;\n \t\t\t}\n \t\t}\n-\t\t// 3 here is allowed maximum for lines repeat,\n-\t\t// can occur in indexed 'for' loops (3 instructions with same line)\n-\t\tList<Map.Entry<Integer, Integer>> repeatingLines = ListUtils.filter(linesStat.entrySet(), p -> p.getValue() > 3);\n-\t\tif (repeatingLines.isEmpty()) {\n-\t\t\tmth.add(AFlag.USE_LINES_HINTS);\n+\t\tString ignoreReason = verifyDebugLines(lineMapping);\n+\t\tif (ignoreReason != null) {\n+\t\t\tmth.addDebugComment(\"Don't trust debug lines info. \" + ignoreReason);\n \t\t} else {\n-\t\t\tmth.addDebugComment(\"Don't trust debug lines info. Repeating lines: \" + repeatingLines);\n+\t\t\tmth.add(AFlag.USE_LINES_HINTS);\n+\t\t}\n+\t}\n+\n+\tprivate String verifyDebugLines(Map<Integer, Integer> lineMapping) {\n+\t\t// search min line in method\n+\t\tint minLine = lineMapping.values().stream().mapToInt(v -> v).min().orElse(Integer.MAX_VALUE);\n+\t\tif (minLine < 3) {\n+\t\t\treturn \"Lines numbers was adjusted: min line is \" + minLine;\n+\t\t}\n+\n+\t\t// count repeating lines\n+\t\t// 3 here is allowed maximum for line repeat count\n+\t\t// can occur in indexed 'for' loops (3 instructions with the same line)\n+\t\tvar repeatingLines = lineMapping.values().stream()\n+\t\t\t\t.collect(Collectors.toMap(l -> l, l -> 1, Integer::sum))\n+\t\t\t\t.entrySet().stream()\n+\t\t\t\t.filter(p -> p.getValue() > 3)\n+\t\t\t\t.collect(Collectors.toList());\n+\t\tif (!repeatingLines.isEmpty()) {\n+\t\t\treturn \"Repeating lines: \" + repeatingLines;\n \t\t}\n+\t\treturn null;\n \t}\n \n \tprivate void attachDebugInfo(MethodNode mth, List<ILocalVar> localVars, InsnNode[] insnArr) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructor2.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructor2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructor2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructor2.java\n@@ -15,6 +15,7 @@ public class TestConstructor2 extends SmaliTest {\n \tpublic void test() {\n \t\tassertThat(getClassNodeFromSmaliFiles())\n \t\t\t\t.code()\n-\t\t\t\t.containsOne(\"A a = new A();\");\n+\t\t\t\t.containsOne(\"A a = new A();\")\n+\t\t\t\t.doesNotContain(\"return\");\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched3.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched3.java\n@@ -14,6 +14,6 @@ public void test() {\n \t\tdisableCompilation();\n \t\tassertThat(getClassNodeFromSmali())\n \t\t\t\t.code()\n-\t\t\t\t.countString(4, \"return new f(\");\n+\t\t\t\t.countString(2, \"return new f(\");\n \t}\n }",
    "output": "Fix ignore debug lines hints if numbers was adjusted for method"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n@@ -25,8 +25,12 @@ public enum CallType {\n \t}\n \n \tpublic ConstructorInsn(MethodNode mth, InvokeNode invoke) {\n+\t\tthis(mth, invoke, invoke.getCallMth());\n+\t}\n+\n+\tpublic ConstructorInsn(MethodNode mth, InvokeNode invoke, MethodInfo callMth) {\n \t\tsuper(InsnType.CONSTRUCTOR, invoke.getArgsCount() - 1);\n-\t\tthis.callMth = invoke.getCallMth();\n+\t\tthis.callMth = callMth;\n \t\tthis.callType = getCallType(mth, callMth.getDeclClass(), invoke.getArg(0));\n \t\tint argsCount = invoke.getArgsCount();\n \t\tfor (int i = 1; i < argsCount; i++) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n@@ -6,9 +6,13 @@\n \n import jadx.core.codegen.TypeGen;\n import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.info.ClassInfo;\n+import jadx.core.dex.info.MethodInfo;\n+import jadx.core.dex.instructions.IndexInsnNode;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.InvokeNode;\n import jadx.core.dex.instructions.PhiInsn;\n+import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.LiteralArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n@@ -59,10 +63,17 @@ private static boolean replaceInvoke(MethodNode mth) {\n \n \tprivate static boolean processInvoke(MethodNode mth, BlockNode block, int indexInBlock, InsnRemover remover) {\n \t\tInvokeNode inv = (InvokeNode) block.getInstructions().get(indexInBlock);\n-\t\tif (!inv.getCallMth().isConstructor()) {\n+\t\tMethodInfo callMth = inv.getCallMth();\n+\t\tif (!callMth.isConstructor()) {\n \t\t\treturn false;\n \t\t}\n-\t\tConstructorInsn co = new ConstructorInsn(mth, inv);\n+\t\tArgType instType = searchInstanceType(inv);\n+\t\tif (instType != null && !instType.equals(callMth.getDeclClass().getType())) {\n+\t\t\tClassInfo instCls = ClassInfo.fromType(mth.root(), instType);\n+\t\t\tcallMth = MethodInfo.fromDetails(mth.root(), instCls, callMth.getName(),\n+\t\t\t\t\tcallMth.getArgumentsTypes(), callMth.getReturnType());\n+\t\t}\n+\t\tConstructorInsn co = new ConstructorInsn(mth, inv, callMth);\n \t\tif (canRemoveConstructor(mth, co)) {\n \t\t\tremover.addAndUnbind(inv);\n \t\t\treturn false;\n@@ -101,6 +112,18 @@ private static boolean processInvoke(MethodNode mth, BlockNode block, int indexI\n \t\treturn true;\n \t}\n \n+\tprivate static @Nullable ArgType searchInstanceType(InvokeNode inv) {\n+\t\tInsnArg instanceArg = inv.getInstanceArg();\n+\t\tif (instanceArg == null || !instanceArg.isRegister()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tInsnNode assignInsn = ((RegisterArg) instanceArg).getSVar().getAssignInsn();\n+\t\tif (assignInsn == null || assignInsn.getType() != InsnType.NEW_INSTANCE) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn ((IndexInsnNode) assignInsn).getIndexAsType();\n+\t}\n+\n \tprivate static RegisterArg insertPhiInsn(MethodNode mth, BlockNode curBlock,\n \t\t\tRegisterArg instArg, ConstructorInsn otherCtr) {\n \t\tBlockNode otherBlock = BlockUtils.getBlockByInsn(mth, otherCtr);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructor2.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructor2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructor2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructor2.java\n@@ -0,0 +1,20 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+/**\n+ * Constructor called on object instance is from Object not instance type\n+ */\n+public class TestConstructor2 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmaliFiles())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"A a = new A();\");\n+\t}\n+}",
    "output": "Use type from `new-instance` if differ from constructor call"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java\n@@ -120,8 +120,12 @@ private static boolean allPathsFromIf(BlockNode block, IfInfo info) {\n \t\tList<BlockNode> preds = block.getPredecessors();\n \t\tList<BlockNode> ifBlocks = info.getMergedBlocks();\n \t\tfor (BlockNode pred : preds) {\n+\t\t\tif (pred.contains(AFlag.LOOP_END)) {\n+\t\t\t\t// ignore loop back edge\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tBlockNode top = BlockUtils.skipSyntheticPredecessor(pred);\n-\t\t\tif (!ifBlocks.contains(top) && !top.contains(AFlag.LOOP_END)) {\n+\t\t\tif (!ifBlocks.contains(top)) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -182,7 +182,7 @@ private BlockNode processLoop(IRegion curRegion, LoopInfo loop, RegionStack stac\n \t\tSet<BlockNode> exitBlocksSet = loop.getExitNodes();\n \n \t\t// set exit blocks scan order priority\n-\t\t// this can help if loop have several exits (after using 'break' or 'return' in loop)\n+\t\t// this can help if loop has several exits (after using 'break' or 'return' in loop)\n \t\tList<BlockNode> exitBlocks = new ArrayList<>(exitBlocksSet.size());\n \t\tBlockNode nextStart = getNextBlock(loopStart);\n \t\tif (nextStart != null && exitBlocksSet.remove(nextStart)) {\n@@ -299,10 +299,7 @@ private LoopRegion makeLoopRegion(IRegion curRegion, LoopInfo loop, List<BlockNo\n \t\t\t\t// skip nested loop condition\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tBlockNode loopEnd = loop.getEnd();\n-\t\t\tboolean exitAtLoopEnd = block == loopEnd\n-\t\t\t\t\t|| (loopEnd.getInstructions().isEmpty() && ListUtils.isSingleElement(loopEnd.getPredecessors(), block));\n-\n+\t\t\tboolean exitAtLoopEnd = isExitAtLoopEnd(block, loop);\n \t\t\tLoopRegion loopRegion = new LoopRegion(curRegion, loop, block, exitAtLoopEnd);\n \t\t\tboolean found;\n \t\t\tif (block == loop.getStart() || exitAtLoopEnd\n@@ -345,6 +342,18 @@ private LoopRegion makeLoopRegion(IRegion curRegion, LoopInfo loop, List<BlockNo\n \t\treturn null;\n \t}\n \n+\tprivate static boolean isExitAtLoopEnd(BlockNode exit, LoopInfo loop) {\n+\t\tBlockNode loopEnd = loop.getEnd();\n+\t\tif (exit == loopEnd) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tBlockNode loopStart = loop.getStart();\n+\t\tif (loopStart.getInstructions().isEmpty() && ListUtils.isSingleElement(loopStart.getSuccessors(), exit)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn loopEnd.getInstructions().isEmpty() && ListUtils.isSingleElement(loopEnd.getPredecessors(), exit);\n+\t}\n+\n \tprivate boolean checkLoopExits(LoopInfo loop, BlockNode mainExitBlock) {\n \t\tList<Edge> exitEdges = loop.getExitEdges();\n \t\tif (exitEdges.size() < 2) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopRestore2.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopRestore2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopRestore2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopRestore2.java\n@@ -0,0 +1,18 @@\n+package jadx.tests.integration.loops;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.RaungTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestLoopRestore2 extends RaungTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation(); // unreachable statement\n+\t\tassertThat(getClassNodeFromRaung())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"while (1 == 0) {\");\n+\t}\n+}",
    "output": "Fix improve condition branch checks in loops"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/ProcessClass.java b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n--- a/jadx-core/src/main/java/jadx/core/ProcessClass.java\n+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n@@ -140,6 +140,17 @@ public void forceProcess(ClassNode cls) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Generate code for class without processing its deps\n+\t */\n+\tpublic @Nullable ICodeInfo forceGenerateCode(ClassNode cls) {\n+\t\ttry {\n+\t\t\treturn process(cls, true);\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow new JadxRuntimeException(\"Failed to generate code for class: \" + cls.getFullName(), e);\n+\t\t}\n+\t}\n+\n \tpublic void initPasses(RootNode root) {\n \t\tfor (IDexTreeVisitor pass : passes) {\n \t\t\ttry {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -327,7 +327,8 @@ public ICodeInfo decompileWithMode(DecompilationMode mode) {\n \t\t\t\targs.setDecompilationMode(mode);\n \t\t\t\tProcessClass process = new ProcessClass(Jadx.getPassesList(args));\n \t\t\t\tprocess.initPasses(root);\n-\t\t\t\treturn process.generateCode(this);\n+\t\t\t\tICodeInfo code = process.forceGenerateCode(this);\n+\t\t\t\treturn Utils.getOrElse(code, ICodeInfo.EMPTY);\n \t\t\t} finally {\n \t\t\t\targs.setDecompilationMode(baseMode);\n \t\t\t\tunload();",
    "output": "Fix protect class deps from loading in different decompilation mode"
  },
  {
    "input": "diff --git a/jadx-cli/src/test/java/jadx/cli/TestInput.java b/jadx-cli/src/test/java/jadx/cli/TestInput.java\n--- a/jadx-cli/src/test/java/jadx/cli/TestInput.java\n+++ b/jadx-cli/src/test/java/jadx/cli/TestInput.java\n@@ -24,6 +24,17 @@\n public class TestInput {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(TestInput.class);\n \n+\tprivate static final PathMatcher LOG_ALL_FILES = path -> {\n+\t\tLOG.debug(\"File in result dir: {}\", path);\n+\t\treturn true;\n+\t};\n+\n+\t@Test\n+\tpublic void testHelp() {\n+\t\tint result = JadxCLI.execute(new String[] { \"--help\" });\n+\t\tassertThat(result).isEqualTo(0);\n+\t}\n+\n \t@Test\n \tpublic void testDexInput() throws Exception {\n \t\tdecompile(\"dex\", \"samples/hello.dex\");\n@@ -45,63 +56,74 @@ public void testMultipleInput() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testResourceOnly() throws Exception {\n-\t\tdecode(\"resourceOnly\", \"samples/resources-only.apk\");\n+\tpublic void testFallbackMode() throws Exception {\n+\t\tPath tempDir = FileUtils.createTempDir(\"fallback\");\n+\t\tList<String> args = buildArgs(tempDir, \"samples/hello.dex\");\n+\t\targs.add(0, \"-f\");\n+\n+\t\tint result = JadxCLI.execute(args.toArray(new String[0]));\n+\t\tassertThat(result).isEqualTo(0);\n+\t\tList<Path> files = collectJavaFilesInDir(tempDir);\n+\t\tassertThat(files).hasSize(1);\n \t}\n \n-\tprivate void decode(String tmpDirName, String apkSample) throws URISyntaxException, IOException {\n-\t\tList<String> args = new ArrayList<>();\n-\t\tPath tempDir = FileUtils.createTempDir(tmpDirName);\n-\t\targs.add(\"-v\");\n-\t\targs.add(\"-d\");\n-\t\targs.add(tempDir.toAbsolutePath().toString());\n+\t@Test\n+\tpublic void testSimpleMode() throws Exception {\n+\t\tPath tempDir = FileUtils.createTempDir(\"simple\");\n+\t\tList<String> args = buildArgs(tempDir, \"samples/hello.dex\");\n+\t\targs.add(0, \"--decompilation-mode\");\n+\t\targs.add(1, \"simple\");\n \n-\t\tURL resource = getClass().getClassLoader().getResource(apkSample);\n-\t\tassertThat(resource).isNotNull();\n-\t\tString sampleFile = resource.toURI().getRawPath();\n-\t\targs.add(sampleFile);\n+\t\tint result = JadxCLI.execute(args.toArray(new String[0]));\n+\t\tassertThat(result).isEqualTo(0);\n+\t\tList<Path> files = collectJavaFilesInDir(tempDir);\n+\t\tassertThat(files).hasSize(1);\n+\t}\n+\n+\t@Test\n+\tpublic void testResourceOnly() throws Exception {\n+\t\tPath tempDir = FileUtils.createTempDir(\"resourceOnly\");\n+\t\tList<String> args = buildArgs(tempDir, \"samples/resources-only.apk\");\n \n \t\tint result = JadxCLI.execute(args.toArray(new String[0]));\n \t\tassertThat(result).isEqualTo(0);\n-\t\tList<Path> files = Files.find(\n-\t\t\t\ttempDir,\n-\t\t\t\t3,\n-\t\t\t\t(file, attr) -> file.getFileName().toString().equalsIgnoreCase(\"AndroidManifest.xml\"))\n-\t\t\t\t.collect(Collectors.toList());\n+\t\tList<Path> files = collectFilesInDir(tempDir,\n+\t\t\t\tpath -> path.getFileName().toString().equalsIgnoreCase(\"AndroidManifest.xml\"));\n \t\tassertThat(files).isNotEmpty();\n \t}\n \n \tprivate void decompile(String tmpDirName, String... inputSamples) throws URISyntaxException, IOException {\n-\t\tList<String> args = new ArrayList<>();\n \t\tPath tempDir = FileUtils.createTempDir(tmpDirName);\n-\t\targs.add(\"-v\");\n-\t\targs.add(\"-d\");\n-\t\targs.add(tempDir.toAbsolutePath().toString());\n-\n-\t\tfor (String inputSample : inputSamples) {\n-\t\t\tURL resource = getClass().getClassLoader().getResource(inputSample);\n-\t\t\tassertThat(resource).isNotNull();\n-\t\t\tString sampleFile = resource.toURI().getRawPath();\n-\t\t\targs.add(sampleFile);\n-\t\t}\n+\t\tList<String> args = buildArgs(tempDir, inputSamples);\n \n \t\tint result = JadxCLI.execute(args.toArray(new String[0]));\n \t\tassertThat(result).isEqualTo(0);\n \t\tList<Path> resultJavaFiles = collectJavaFilesInDir(tempDir);\n \t\tassertThat(resultJavaFiles).isNotEmpty();\n \n \t\t// do not copy input files as resources\n-\t\tPathMatcher logAllFiles = path -> {\n-\t\t\tLOG.debug(\"File in result dir: {}\", path);\n-\t\t\treturn true;\n-\t\t};\n-\t\tfor (Path path : collectFilesInDir(tempDir, logAllFiles)) {\n+\t\tfor (Path path : collectFilesInDir(tempDir, LOG_ALL_FILES)) {\n \t\t\tfor (String inputSample : inputSamples) {\n \t\t\t\tassertThat(path.toAbsolutePath().toString()).doesNotContain(inputSample);\n \t\t\t}\n \t\t}\n \t}\n \n+\tprivate List<String> buildArgs(Path tempDir, String... inputSamples) throws URISyntaxException {\n+\t\tList<String> args = new ArrayList<>();\n+\t\targs.add(\"-v\");\n+\t\targs.add(\"-d\");\n+\t\targs.add(tempDir.toAbsolutePath().toString());\n+\n+\t\tfor (String inputSample : inputSamples) {\n+\t\t\tURL resource = getClass().getClassLoader().getResource(inputSample);\n+\t\t\tassertThat(resource).isNotNull();\n+\t\t\tString sampleFile = resource.toURI().getRawPath();\n+\t\t\targs.add(sampleFile);\n+\t\t}\n+\t\treturn args;\n+\t}\n+\n \tprivate static List<Path> collectJavaFilesInDir(Path dir) throws IOException {\n \t\tPathMatcher javaMatcher = dir.getFileSystem().getPathMatcher(\"glob:**.java\");\n \t\treturn collectFilesInDir(dir, javaMatcher);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -13,6 +13,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.api.DecompilationMode;\n import jadx.api.ICodeCache;\n import jadx.api.ICodeWriter;\n import jadx.api.JadxArgs;\n@@ -310,6 +311,12 @@ private void initInnerClasses() {\n \t}\n \n \tpublic void mergePasses(Map<JadxPassType, List<JadxPass>> customPasses) {\n+\t\tDecompilationMode mode = args.getDecompilationMode();\n+\t\tif (mode == DecompilationMode.FALLBACK || mode == DecompilationMode.SIMPLE) {\n+\t\t\t// for predefined modes ignore custom (and plugin) passes\n+\t\t\treturn;\n+\t\t}\n+\n \t\tnew PassMerge(preDecompilePasses)\n \t\t\t\t.merge(customPasses.get(JadxPreparePass.TYPE), p -> new PreparePassWrapper((JadxPreparePass) p));\n \t\tnew PassMerge(processClasses.getPasses())",
    "output": "Fix do not add custom passes for fallback and simple modes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n@@ -169,6 +169,24 @@ public ArgType consumeType() {\n \t\tthrow new JadxRuntimeException(\"Can't parse type: \" + debugString() + \", unexpected: \" + ch);\n \t}\n \n+\tpublic List<ArgType> consumeTypeList() {\n+\t\tList<ArgType> list = null;\n+\t\twhile (true) {\n+\t\t\tArgType type = consumeType();\n+\t\t\tif (type == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (list == null) {\n+\t\t\t\tlist = new ArrayList<>();\n+\t\t\t}\n+\t\t\tlist.add(type);\n+\t\t}\n+\t\tif (list == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\treturn list;\n+\t}\n+\n \tprivate ArgType consumeObjectType(boolean innerType) {\n \t\tmark();\n \t\tint ch;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n@@ -48,23 +48,49 @@ private void parseClassSignature(ClassNode cls) {\n \t\t}\n \t\ttry {\n \t\t\tList<ArgType> generics = sp.consumeGenericTypeParameters();\n-\t\t\tArgType superClass = validateClsType(cls, sp.consumeType(), cls.getSuperClass());\n-\t\t\tList<ArgType> interfaces = cls.getInterfaces();\n-\t\t\tfor (int i = 0; i < interfaces.size(); i++) {\n-\t\t\t\tArgType type = sp.consumeType();\n-\t\t\t\tif (type != null) {\n-\t\t\t\t\tinterfaces.set(i, validateClsType(cls, type, interfaces.get(i)));\n-\t\t\t\t} else {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tgenerics = fixTypeParamDeclarations(cls, generics, superClass, interfaces);\n-\t\t\tcls.updateGenericClsData(generics, superClass, interfaces);\n+\t\t\tArgType superClass = processSuperType(cls, sp.consumeType());\n+\t\t\tList<ArgType> interfaces = processInterfaces(cls, sp.consumeTypeList());\n+\t\t\tList<ArgType> resultGenerics = fixTypeParamDeclarations(cls, generics, superClass, interfaces);\n+\t\t\tcls.updateGenericClsData(resultGenerics, superClass, interfaces);\n \t\t} catch (Exception e) {\n \t\t\tcls.addWarnComment(\"Failed to parse class signature: \" + sp.getSignature(), e);\n \t\t}\n \t}\n \n+\tprivate ArgType processSuperType(ClassNode cls, ArgType parsedType) {\n+\t\tArgType superType = cls.getSuperClass();\n+\t\tif (Objects.equals(parsedType.getObject(), cls.getClassInfo().getType().getObject())) {\n+\t\t\tcls.addWarnComment(\"Incorrect class signature: super class is equals to this class\");\n+\t\t\treturn superType;\n+\t\t}\n+\t\treturn bestClsType(cls, parsedType, superType);\n+\t}\n+\n+\t/**\n+\t * Parse, validate and update class interfaces types.\n+\t */\n+\tprivate List<ArgType> processInterfaces(ClassNode cls, List<ArgType> parsedTypes) {\n+\t\tList<ArgType> interfaces = cls.getInterfaces();\n+\t\tif (parsedTypes.isEmpty()) {\n+\t\t\treturn interfaces;\n+\t\t}\n+\t\tint parsedCount = parsedTypes.size();\n+\t\tint interfacesCount = interfaces.size();\n+\t\tList<ArgType> result = new ArrayList<>(interfacesCount);\n+\t\tint count = Math.min(interfacesCount, parsedCount);\n+\t\tfor (int i = 0; i < interfacesCount; i++) {\n+\t\t\tif (i < count) {\n+\t\t\t\tresult.add(bestClsType(cls, parsedTypes.get(i), interfaces.get(i)));\n+\t\t\t} else {\n+\t\t\t\tresult.add(interfaces.get(i));\n+\t\t\t}\n+\t\t}\n+\t\tif (interfacesCount < parsedCount) {\n+\t\t\tcls.addWarnComment(\"Unexpected interfaces in signature: \" + parsedTypes.subList(interfacesCount, parsedCount));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n \t/**\n \t * Add missing type parameters from super type and interfaces to make code compilable\n \t */\n@@ -106,16 +132,22 @@ private static List<ArgType> fixTypeParamDeclarations(ClassNode cls,\n \t\treturn null;\n \t}\n \n-\tprivate ArgType validateClsType(ClassNode cls, ArgType candidateType, ArgType currentType) {\n-\t\tif (!candidateType.isObject()) {\n-\t\t\tcls.addWarnComment(\"Incorrect class signature, class is not object: \" + SignatureParser.getSignature(cls));\n-\t\t\treturn currentType;\n+\tprivate ArgType bestClsType(ClassNode cls, ArgType candidateType, ArgType currentType) {\n+\t\tif (validateClsType(cls, candidateType)) {\n+\t\t\treturn candidateType;\n+\t\t}\n+\t\treturn currentType;\n+\t}\n+\n+\tprivate boolean validateClsType(ClassNode cls, ArgType candidateType) {\n+\t\tif (candidateType == null) {\n+\t\t\treturn false;\n \t\t}\n-\t\tif (Objects.equals(candidateType.getObject(), cls.getClassInfo().getType().getObject())) {\n-\t\t\tcls.addWarnComment(\"Incorrect class signature, class is equals to this class: \" + SignatureParser.getSignature(cls));\n-\t\t\treturn currentType;\n+\t\tif (!candidateType.isObject()) {\n+\t\t\tcls.addWarnComment(\"Incorrect class signature, class is not an object: \" + candidateType);\n+\t\t\treturn false;\n \t\t}\n-\t\treturn candidateType;\n+\t\treturn true;\n \t}\n \n \tprivate void parseFieldSignature(FieldNode field) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestClassImplementsSignature.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestClassImplementsSignature.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestClassImplementsSignature.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestClassImplementsSignature.java\n@@ -0,0 +1,32 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.RaungTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestClassImplementsSignature extends RaungTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic abstract static class A<T> implements Comparable<A<T>> {\n+\t\t\tT value;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"public static abstract class A<T> implements Comparable<A<T>> {\");\n+\t}\n+\n+\t@Test\n+\tpublic void testRaung() {\n+\t\tallowWarnInCode();\n+\t\tassertThat(getClassNodeFromRaung())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"public class TestClassImplementsSignature<T> {\")\n+\t\t\t\t.containsOne(\"Unexpected interfaces in signature\");\n+\t}\n+}",
    "output": "Fix additional checks for class signature"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoAttachVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoAttachVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoAttachVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoAttachVisitor.java\n@@ -21,6 +21,7 @@\n import jadx.core.dex.visitors.blocks.BlockSplitter;\n import jadx.core.dex.visitors.ssa.SSATransform;\n import jadx.core.utils.ListUtils;\n+import jadx.core.utils.exceptions.InvalidDataException;\n import jadx.core.utils.exceptions.JadxException;\n \n @JadxVisitor(\n@@ -40,6 +41,8 @@ public void visit(MethodNode mth) throws JadxException {\n \t\t\tif (debugInfo != null) {\n \t\t\t\tprocessDebugInfo(mth, debugInfo);\n \t\t\t}\n+\t\t} catch (InvalidDataException e) {\n+\t\t\tmth.addWarnComment(e.getMessage());\n \t\t} catch (Exception e) {\n \t\t\tmth.addWarnComment(\"Failed to parse debug info\", e);\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/exceptions/InvalidDataException.java b/jadx-core/src/main/java/jadx/core/utils/exceptions/InvalidDataException.java\n--- a/jadx-core/src/main/java/jadx/core/utils/exceptions/InvalidDataException.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/exceptions/InvalidDataException.java\n@@ -0,0 +1,7 @@\n+package jadx.core.utils.exceptions;\n+\n+public class InvalidDataException extends JadxRuntimeException {\n+\tpublic InvalidDataException(String message) {\n+\t\tsuper(message);\n+\t}\n+}\n\ndiff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/DexCodeReader.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/DexCodeReader.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/DexCodeReader.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/DexCodeReader.java\n@@ -16,6 +16,7 @@\n import jadx.api.plugins.input.data.impl.CatchData;\n import jadx.api.plugins.input.data.impl.TryData;\n import jadx.api.plugins.input.insns.InsnData;\n+import jadx.core.utils.exceptions.InvalidDataException;\n import jadx.plugins.input.dex.DexException;\n import jadx.plugins.input.dex.insns.DexInsnData;\n import jadx.plugins.input.dex.insns.DexInsnFormat;\n@@ -112,6 +113,9 @@ public IDebugInfo getDebugInfo() {\n \t\tif (debugOff == 0) {\n \t\t\treturn null;\n \t\t}\n+\t\tif (debugOff < 0 || debugOff > in.size()) {\n+\t\t\tthrow new InvalidDataException(\"Invalid debug info offset\");\n+\t\t}\n \t\tint regsCount = getRegistersCount();\n \t\tDebugInfoParser debugInfoParser = new DebugInfoParser(in, regsCount, getUnitsCount());\n \t\tdebugInfoParser.initMthArgs(regsCount, in.getMethodParamTypes(mthId));\n\ndiff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/SectionReader.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/SectionReader.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/SectionReader.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/SectionReader.java\n@@ -314,6 +314,10 @@ public int readSleb128() {\n \t\treturn Leb128.readSignedLeb128(this);\n \t}\n \n+\tpublic int size() {\n+\t\treturn buf.capacity();\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn \"SectionReader{buf=\" + buf + \", offset=\" + offset + '}';",
    "output": "Fix check if debug info offset is invalid"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n@@ -248,6 +248,7 @@ public void forceCloseAllTabs() {\n \t\tforceClose = true;\n \t\tcloseAllTabs();\n \t\tforceClose = false;\n+\t\tselectedTab = null;\n \t}\n \n \tpublic boolean isForceClose() {",
    "output": "Fix resolve old objects reference leak in TabsController"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -210,18 +210,13 @@ public void loadResources(ResourcesLoader resLoader, List<ResourceFile> resource\n \t\t\tif (parser != null) {\n \t\t\t\tprocessResources(parser.getResStorage());\n \t\t\t\tupdateObfuscatedFiles(parser, resources);\n-\t\t\t\tupdateManifestAttribMap(parser);\n+\t\t\t\tManifestAttributes.getInstance().updateAttributes(parser);\n \t\t\t}\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Failed to parse 'resources.pb'/'.arsc' file\", e);\n \t\t}\n \t}\n \n-\tprivate void updateManifestAttribMap(IResTableParser parser) {\n-\t\tManifestAttributes manifestAttributes = ManifestAttributes.getInstance();\n-\t\tmanifestAttributes.updateAttributes(parser);\n-\t}\n-\n \tprivate @Nullable ResourceFile getResourceFile(List<ResourceFile> resources) {\n \t\tfor (ResourceFile rf : resources) {\n \t\t\tif (rf.getType() == ResourceType.ARSC) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java\n@@ -4,13 +4,14 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n \n import org.jetbrains.annotations.NotNull;\n \n public class ParserStream {\n \n-\tprotected static final Charset STRING_CHARSET_UTF16 = Charset.forName(\"UTF-16LE\");\n-\tprotected static final Charset STRING_CHARSET_UTF8 = Charset.forName(\"UTF-8\");\n+\tprotected static final Charset STRING_CHARSET_UTF16 = StandardCharsets.UTF_16LE;\n+\tprotected static final Charset STRING_CHARSET_UTF8 = StandardCharsets.UTF_8;\n \n \tprivate static final int[] EMPTY_INT_ARRAY = new int[0];\n \tprivate static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n@@ -90,7 +91,7 @@ public void skip(long count) throws IOException {\n \t\tlong pos = input.skip(count);\n \t\twhile (pos < count) {\n \t\t\tlong skipped = input.skip(count - pos);\n-\t\t\tif (skipped == -1) {\n+\t\t\tif (skipped == 0) {\n \t\t\t\tthrow new IOException(\"No data, can't skip \" + count + \" bytes\");\n \t\t\t}\n \t\t\tpos += skipped;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParser.java\n@@ -72,7 +72,8 @@ public BinaryXMLStrings getKeyStrings() {\n \t */\n \tprivate final boolean useRawResName;\n \tprivate final RootNode root;\n-\tprivate final ResourceStorage resStorage = new ResourceStorage();\n+\n+\tprivate ResourceStorage resStorage;\n \tprivate BinaryXMLStrings strings;\n \n \tpublic ResTableBinaryParser(RootNode root) {\n@@ -88,6 +89,7 @@ public ResTableBinaryParser(RootNode root, boolean useRawResNames) {\n \tpublic void decode(InputStream inputStream) throws IOException {\n \t\tlong start = System.currentTimeMillis();\n \t\tis = new ParserStream(inputStream);\n+\t\tresStorage = new ResourceStorage();\n \t\tdecodeTableChunk();\n \t\tresStorage.finish();\n \t\tif (LOG.isDebugEnabled()) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParserProvider.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParserProvider.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParserProvider.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableBinaryParserProvider.java\n@@ -7,19 +7,19 @@\n import jadx.core.dex.nodes.RootNode;\n \n public class ResTableBinaryParserProvider implements IResTableParserProvider {\n-\tprivate IResTableParser parser;\n+\tprivate RootNode root;\n \n \t@Override\n \tpublic void init(RootNode root) {\n-\t\tparser = new ResTableBinaryParser(root);\n+\t\tthis.root = root;\n \t}\n \n \t@Override\n-\tpublic synchronized @Nullable IResTableParser getParser(ResourceFile resFile) {\n+\tpublic @Nullable IResTableParser getParser(ResourceFile resFile) {\n \t\tString fileName = resFile.getOriginalName();\n \t\tif (!fileName.endsWith(\".arsc\")) {\n \t\t\treturn null;\n \t\t}\n-\t\treturn parser;\n+\t\treturn new ResTableBinaryParser(root);\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java b/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java\n--- a/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java\n+++ b/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java\n@@ -5,10 +5,12 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URL;\n+import java.util.List;\n \n import org.junit.jupiter.api.Test;\n \n import jadx.core.utils.files.FileUtils;\n+import jadx.core.xmlgen.ResContainer;\n import jadx.plugins.input.dex.DexInputPlugin;\n \n import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n@@ -54,6 +56,32 @@ public void testDirectDexInput() throws IOException {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testResourcesLoad() {\n+\t\tFile sampleApk = getFileFromSampleDir(\"app-with-fake-dex.apk\");\n+\t\tFile outDir = FileUtils.createTempDir(\"jadx-usage-example-2\").toFile();\n+\n+\t\tJadxArgs args = new JadxArgs();\n+\t\targs.getInputFiles().add(sampleApk);\n+\t\targs.setOutDir(outDir);\n+\t\targs.setSkipSources(true);\n+\t\ttry (JadxDecompiler jadx = new JadxDecompiler(args)) {\n+\t\t\tjadx.load();\n+\t\t\tList<ResourceFile> resources = jadx.getResources();\n+\t\t\tassertThat(resources).hasSize(8);\n+\t\t\tResourceFile arsc = resources.stream()\n+\t\t\t\t\t.filter(r -> r.getType() == ResourceType.ARSC)\n+\t\t\t\t\t.findFirst().orElseThrow();\n+\t\t\tResContainer resContainer = arsc.loadContent();\n+\t\t\tResContainer xmlRes = resContainer.getSubFiles().stream()\n+\t\t\t\t\t.filter(r -> r.getName().equals(\"res/values/colors.xml\"))\n+\t\t\t\t\t.findFirst().orElseThrow();\n+\t\t\tassertThat(xmlRes.getText())\n+\t\t\t\t\t.code()\n+\t\t\t\t\t.containsOne(\"<color name=\\\"colorPrimary\\\">#008577</color>\");\n+\t\t}\n+\t}\n+\n \tprivate static final String TEST_SAMPLES_DIR = \"test-samples/\";\n \n \tpublic static File getFileFromSampleDir(String fileName) {\n\ndiff --git a/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/ResTableProtoParserProvider.java b/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/ResTableProtoParserProvider.java\n--- a/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/ResTableProtoParserProvider.java\n+++ b/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/ResTableProtoParserProvider.java\n@@ -9,19 +9,19 @@\n import jadx.plugins.input.aab.parsers.ResTableProtoParser;\n \n public class ResTableProtoParserProvider implements IResTableParserProvider {\n-\tprivate ResTableProtoParser parser;\n+\tprivate RootNode root;\n \n \t@Override\n \tpublic void init(RootNode root) {\n-\t\tparser = new ResTableProtoParser(root);\n+\t\tthis.root = root;\n \t}\n \n \t@Override\n-\tpublic synchronized @Nullable IResTableParser getParser(ResourceFile resFile) {\n+\tpublic @Nullable IResTableParser getParser(ResourceFile resFile) {\n \t\tString fileName = resFile.getOriginalName();\n \t\tif (!fileName.endsWith(\"resources.pb\")) {\n \t\t\treturn null;\n \t\t}\n-\t\treturn parser;\n+\t\treturn new ResTableProtoParser(root);\n \t}\n }\n\ndiff --git a/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/parsers/ResTableProtoParser.java b/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/parsers/ResTableProtoParser.java\n--- a/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/parsers/ResTableProtoParser.java\n+++ b/jadx-plugins/jadx-aab-input/src/main/java/jadx/plugins/input/aab/parsers/ResTableProtoParser.java\n@@ -26,14 +26,15 @@\n \n public class ResTableProtoParser extends CommonProtoParser implements IResTableParser {\n \tprivate final RootNode root;\n-\tprivate final ResourceStorage resStorage = new ResourceStorage();\n+\tprivate ResourceStorage resStorage;\n \n \tpublic ResTableProtoParser(RootNode root) {\n \t\tthis.root = root;\n \t}\n \n \t@Override\n \tpublic void decode(InputStream inputStream) throws IOException {\n+\t\tresStorage = new ResourceStorage();\n \t\tResourceTable table = ResourceTable.parseFrom(FileUtils.streamToByteArray(inputStream));\n \t\tfor (Package p : table.getPackageList()) {\n \t\t\tparse(p);",
    "output": "Fix prevent duplication of ARSC entries"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -269,7 +269,7 @@ public void addInstructions(ICodeWriter code) throws CodegenException {\n \t\tJadxArgs args = mth.root().getArgs();\n \t\tswitch (args.getDecompilationMode()) {\n \t\t\tcase AUTO:\n-\t\t\t\tif (classGen.isFallbackMode()) {\n+\t\t\t\tif (classGen.isFallbackMode() || mth.getRegion() == null) {\n \t\t\t\t\t// TODO: try simple mode first\n \t\t\t\t\tdumpInstructions(code);\n \t\t\t\t} else {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -1165,8 +1165,9 @@ public void actionPerformed(ActionEvent e) {\n \t\t\t\t\tExceptionDialog.throwTestException();\n \t\t\t\t}\n \t\t\t});\n-\t\t\thelp.add(new JCheckBoxMenuItem(new ActionHandler(\"UI WatchDog\", UIWatchDog::toggle)));\n-\t\t\tUIWatchDog.onStart();\n+\t\t\tJCheckBoxMenuItem uiWatchDog = new JCheckBoxMenuItem(new ActionHandler(\"UI WatchDog\", UIWatchDog::toggle));\n+\t\t\tuiWatchDog.setState(UIWatchDog.onStart());\n+\t\t\thelp.add(uiWatchDog);\n \t\t}\n \t\thelp.add(aboutAction);\n \n@@ -1550,6 +1551,9 @@ private void restoreOpenTabs(List<EditorViewState> openTabs) {\n \tprivate void preLoadOpenTabs(List<EditorViewState> openTabs) {\n \t\tUiUtils.notUiThreadGuard();\n \t\tfor (EditorViewState tabState : openTabs) {\n+\t\t\tif (tabState.isHidden()) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tJNode node = tabState.getNode();\n \t\t\ttry {\n \t\t\t\tnode.getCodeInfo();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n@@ -26,6 +26,7 @@\n import jadx.gui.treemodel.JNode;\n import jadx.gui.treemodel.JResource;\n import jadx.gui.ui.MainWindow;\n+import jadx.gui.ui.codearea.mode.JCodeMode;\n import jadx.gui.ui.panel.ContentPanel;\n import jadx.gui.utils.CaretPositionFix;\n import jadx.gui.utils.DefaultPopupMenuListener;\n@@ -51,7 +52,7 @@ public final class CodeArea extends AbstractCodeArea {\n \t\tthis.shortcutsController = getMainWindow().getShortcutsController();\n \n \t\tsetSyntaxEditingStyle(node.getSyntaxName());\n-\t\tboolean isJavaCode = node instanceof JClass;\n+\t\tboolean isJavaCode = isCodeNode();\n \t\tif (isJavaCode) {\n \t\t\t((RSyntaxDocument) getDocument()).setSyntaxStyle(new JadxTokenMaker(this));\n \t\t}\n@@ -79,6 +80,10 @@ public void mouseClicked(MouseEvent e) {\n \t\t}\n \t}\n \n+\tpublic boolean isCodeNode() {\n+\t\treturn node instanceof JClass || node instanceof JCodeMode;\n+\t}\n+\n \tprivate boolean jumpOnDoubleClick(MouseEvent e) {\n \t\treturn e.getClickCount() == 2 && getMainWindow().getSettings().isJumpOnDoubleClick();\n \t}\n@@ -174,7 +179,7 @@ public int adjustOffsetForWordToken(int offset) {\n \t\t\treturn -1;\n \t\t}\n \t\tint type = token.getType();\n-\t\tif (node instanceof JClass) {\n+\t\tif (isCodeNode()) {\n \t\t\tif (type == TokenTypes.IDENTIFIER || type == TokenTypes.FUNCTION) {\n \t\t\t\treturn token.getOffset();\n \t\t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/tab/TabsController.java\n@@ -23,7 +23,6 @@\n import jadx.gui.ui.MainWindow;\n import jadx.gui.ui.codearea.EditorViewState;\n import jadx.gui.utils.JumpPosition;\n-import jadx.gui.utils.NLS;\n \n public class TabsController {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(TabsController.class);\n@@ -104,11 +103,6 @@ public void codeJump(JNode node) {\n \t\t\treturn;\n \t\t}\n \t\t// node need loading\n-\t\tmainWindow.getBackgroundExecutor().execute(\n-\t\t\t\tNLS.str(\"progress.load\"),\n-\t\t\t\t() -> node.getRootClass().getCodeInfo(), // run heavy loading in background\n-\t\t\t\tstatus -> codeJump(new JumpPosition(node)));\n-\n \t\tloadCodeWithUIAction(node.getRootClass(), () -> codeJump(new JumpPosition(node)));\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/dbg/UIWatchDog.java b/jadx-gui/src/main/java/jadx/gui/utils/dbg/UIWatchDog.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/dbg/UIWatchDog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/dbg/UIWatchDog.java\n@@ -20,15 +20,17 @@\n public class UIWatchDog {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(UIWatchDog.class);\n \n-\tprivate static final boolean RUN_ON_START = false;\n+\tprivate static final boolean RUN_ON_START = true;\n \n-\tprivate static final int UI_MAX_DELAY_MS = 1000;\n-\tprivate static final int CHECK_INTERVAL_MS = 100;\n+\tprivate static final int UI_MAX_DELAY_MS = 200;\n+\tprivate static final int CHECK_INTERVAL_MS = 50;\n \n-\tpublic static void onStart() {\n+\tpublic static boolean onStart() {\n \t\tif (RUN_ON_START) {\n \t\t\tUiUtils.uiRun(UIWatchDog::toggle);\n+\t\t\treturn true;\n \t\t}\n+\t\treturn false;\n \t}\n \n \tpublic static synchronized void toggle() {",
    "output": "Fix minor fixes for code jumps"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -871,13 +871,14 @@ private BlockNode getOneIntersectionBlock(BlockNode out, BitSet caseBlocks, BitS\n \t\t\touts.or(s.getDomFrontier());\n \t\t}\n \t\touts.clear(block.getId());\n+\t\touts.clear(mth.getExitBlock().getId());\n \t\tif (outs.isEmpty()) {\n \t\t\t// switch already contains method exit\n \t\t\t// add everything, out block not needed\n \t\t\treturn mth.getExitBlock();\n \t\t}\n \n-\t\tBlockNode out;\n+\t\tBlockNode out = null;\n \t\tif (outs.cardinality() == 1) {\n \t\t\t// single exit\n \t\t\tout = BlockUtils.bitSetToOneBlock(mth, outs);\n@@ -886,23 +887,29 @@ private BlockNode getOneIntersectionBlock(BlockNode out, BitSet caseBlocks, BitS\n \t\t\t// possible 'return', 'continue' or fallthrough in one of the cases\n \t\t\tLoopInfo loop = mth.getLoopForBlock(block);\n \t\t\tif (loop != null) {\n-\t\t\t\touts.andNot(block.getPostDoms());\n-\t\t\t\tout = BlockUtils.bitSetToOneBlock(mth, outs);\n-\t\t\t\tif (out != null) {\n-\t\t\t\t\tinsertContinueInSwitch(block, out, loop.getEnd());\n-\t\t\t\t\tif (out == loop.getStart()) {\n-\t\t\t\t\t\t// no other outs instead back edge to loop start\n-\t\t\t\t\t\treturn null;\n+\t\t\t\touts.andNot(loop.getStart().getPostDoms());\n+\t\t\t\touts.andNot(loop.getEnd().getPostDoms());\n+\t\t\t\tBlockNode loopEnd = loop.getEnd();\n+\t\t\t\tif (outs.cardinality() == 2 && outs.get(loopEnd.getId())) {\n+\t\t\t\t\t// insert 'continue' for cases lead to loop end\n+\t\t\t\t\t// expect only 2 exits: loop end and switch out\n+\t\t\t\t\tList<BlockNode> outList = BlockUtils.bitSetToBlocks(mth, outs);\n+\t\t\t\t\toutList.remove(loopEnd);\n+\t\t\t\t\tBlockNode possibleOut = Utils.getOne(outList);\n+\t\t\t\t\tif (possibleOut != null && insertContinueInSwitch(block, possibleOut, loopEnd)) {\n+\t\t\t\t\t\touts.clear(loopEnd.getId());\n+\t\t\t\t\t\tout = possibleOut;\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\touts.clear(mth.getExitBlock().getId());\n+\t\t\t}\n+\t\t\tif (out == null) {\n \t\t\t\tBlockNode imPostDom = block.getIPostDom();\n \t\t\t\tif (outs.get(imPostDom.getId())) {\n-\t\t\t\t\treturn imPostDom;\n+\t\t\t\t\tout = imPostDom;\n+\t\t\t\t} else {\n+\t\t\t\t\touts.andNot(block.getPostDoms());\n+\t\t\t\t\tout = BlockUtils.bitSetToOneBlock(mth, outs);\n \t\t\t\t}\n-\t\t\t\touts.andNot(block.getPostDoms());\n-\t\t\t\tout = BlockUtils.bitSetToOneBlock(mth, outs);\n \t\t\t}\n \t\t}\n \t\tif (out != null && mth.isPreExitBlock(out)) {\n@@ -994,7 +1001,8 @@ private Map<BlockNode, List<Object>> reOrderSwitchCases(Map<BlockNode, List<Obje\n \t\treturn newBlocksMap;\n \t}\n \n-\tprivate void insertContinueInSwitch(BlockNode switchBlock, BlockNode switchOut, BlockNode loopEnd) {\n+\tprivate boolean insertContinueInSwitch(BlockNode switchBlock, BlockNode switchOut, BlockNode loopEnd) {\n+\t\tboolean inserted = false;\n \t\tfor (BlockNode caseBlock : switchBlock.getCleanSuccessors()) {\n \t\t\tif (caseBlock.getDomFrontier().get(loopEnd.getId()) && caseBlock != switchOut) {\n \t\t\t\t// search predecessor of loop end on path from this successor\n@@ -1006,13 +1014,15 @@ private void insertContinueInSwitch(BlockNode switchBlock, BlockNode switchOut,\n \t\t\t\t\t\tif (list.contains(p)) {\n \t\t\t\t\t\t\tif (p.isSynthetic()) {\n \t\t\t\t\t\t\t\tp.getInstructions().add(new InsnNode(InsnType.CONTINUE, 0));\n+\t\t\t\t\t\t\t\tinserted = true;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\treturn inserted;\n \t}\n \n \tpublic IRegion processTryCatchBlocks(MethodNode mth) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchContinue.java b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchContinue.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchContinue.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchContinue.java\n@@ -3,10 +3,12 @@\n import org.junit.jupiter.api.Test;\n \n import jadx.tests.api.IntegrationTest;\n-import jadx.tests.api.utils.assertj.JadxAssertions;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n \n public class TestSwitchContinue extends IntegrationTest {\n \n+\t@SuppressWarnings({ \"StringConcatenationInLoop\", \"DataFlowIssue\" })\n \tpublic static class TestCls {\n \t\tpublic String test(int a) {\n \t\t\tString s = \"\";\n@@ -32,7 +34,7 @@ public String test(int a) {\n \n \t@Test\n \tpublic void test() {\n-\t\tJadxAssertions.assertThat(getClassNode(TestCls.class))\n+\t\tassertThat(getClassNode(TestCls.class))\n \t\t\t\t.code()\n \t\t\t\t.contains(\"switch (a % 4) {\")\n \t\t\t\t.countString(4, \"case \")\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop4.java b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop4.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop4.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop4.java\n@@ -0,0 +1,42 @@\n+package jadx.tests.integration.switches;\n+\n+import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.extensions.profiles.TestProfile;\n+import jadx.tests.api.extensions.profiles.TestWithProfiles;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestSwitchInLoop4 extends IntegrationTest {\n+\n+\t@SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n+\tpublic static class TestCls {\n+\t\tprivate static boolean test(String s, int start) {\n+\t\t\tboolean foundSeparator = false;\n+\t\t\tfor (int i = start; i < s.length(); i++) {\n+\t\t\t\tchar c = s.charAt(i);\n+\t\t\t\tswitch (c) {\n+\t\t\t\t\tcase '.':\n+\t\t\t\t\t\tfoundSeparator = true;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tif (foundSeparator) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn foundSeparator;\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(test(\"a.b\", 0)).isTrue();\n+\t\t\tassertThat(test(\"abc\", 1)).isFalse();\n+\t\t}\n+\t}\n+\n+\t@TestWithProfiles({ TestProfile.DX_J8, TestProfile.D8_J11, TestProfile.JAVA11 })\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"switch (c) {\")\n+\t\t\t\t.containsOne(\"break;\"); // allow replacing second 'break' with 'return'\n+\t}\n+}",
    "output": "Fix improve 'continue' insertion for switch in loop"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n@@ -298,19 +298,30 @@ public JavaNode getEnclosingJavaNode(int offset) {\n \t\t}\n \t}\n \n-\tpublic JavaClass getJavaClassIfAtPos(int pos) {\n+\tpublic @Nullable JavaClass getJavaClassIfAtPos(int pos) {\n \t\ttry {\n \t\t\tICodeInfo codeInfo = getCodeInfo();\n-\t\t\tif (codeInfo.hasMetadata()) {\n-\t\t\t\tICodeAnnotation ann = codeInfo.getCodeMetadata().getAt(pos);\n-\t\t\t\tif (ann != null && ann.getAnnType() == ICodeAnnotation.AnnType.CLASS) {\n+\t\t\tif (!codeInfo.hasMetadata()) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tICodeAnnotation ann = codeInfo.getCodeMetadata().getAt(pos);\n+\t\t\tif (ann == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tswitch (ann.getAnnType()) {\n+\t\t\t\tcase CLASS:\n \t\t\t\t\treturn (JavaClass) getJadxWrapper().getDecompiler().getJavaNodeByCodeAnnotation(codeInfo, ann);\n-\t\t\t\t}\n+\t\t\t\tcase METHOD:\n+\t\t\t\t\t// use class from constructor call\n+\t\t\t\t\tJavaNode node = getJadxWrapper().getDecompiler().getJavaNodeByCodeAnnotation(codeInfo, ann);\n+\t\t\t\t\treturn node != null ? node.getDeclaringClass() : null;\n+\t\t\t\tdefault:\n+\t\t\t\t\treturn null;\n \t\t\t}\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Can't get java node by offset: {}\", pos, e);\n+\t\t\treturn null;\n \t\t}\n-\t\treturn null;\n \t}\n \n \tpublic void refreshClass() {",
    "output": "Fix merge full class name tokens for constructors"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java\n@@ -65,7 +65,6 @@ public void visit(MethodNode mth) {\n \t\tMap<Integer, BlockNode> blocksMap = splitBasicBlocks(mth);\n \t\tsetupConnectionsFromJumps(mth, blocksMap);\n \t\tinitBlocksInTargetNodes(mth);\n-\t\taddTempConnectionsForExcHandlers(mth, blocksMap);\n \n \t\texpandMoveMulti(mth);\n \t\tif (mth.contains(AFlag.RESOLVE_JAVA_JSR)) {\n@@ -76,6 +75,8 @@ public void visit(MethodNode mth) {\n \t\tremoveInsns(mth);\n \t\tremoveEmptyDetachedBlocks(mth);\n \t\tmth.getBasicBlocks().removeIf(BlockSplitter::removeEmptyBlock);\n+\n+\t\taddTempConnectionsForExcHandlers(mth, blocksMap);\n \t\tsetupExitConnections(mth);\n \n \t\tmth.unloadInsnArr();\n@@ -257,10 +258,13 @@ private static void setupConnectionsFromJumps(MethodNode mth, Map<Integer, Block\n \n \t/**\n \t * Connect exception handlers to the throw block.\n-\t * This temporary connection needed to build close to final dominators tree.\n+\t * This temporary connection is necessary to build close to a final dominator tree.\n \t * Will be used and removed in {@code jadx.core.dex.visitors.blocks.BlockExceptionHandler}\n \t */\n \tprivate static void addTempConnectionsForExcHandlers(MethodNode mth, Map<Integer, BlockNode> blocksMap) {\n+\t\tif (mth.isNoExceptionHandlers()) {\n+\t\t\treturn;\n+\t\t}\n \t\tfor (BlockNode block : mth.getBasicBlocks()) {\n \t\t\tfor (InsnNode insn : block.getInstructions()) {\n \t\t\t\tCatchAttr catchAttr = insn.get(AType.EXC_CATCH);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/DebugChecks.java b/jadx-core/src/main/java/jadx/core/utils/DebugChecks.java\n--- a/jadx-core/src/main/java/jadx/core/utils/DebugChecks.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/DebugChecks.java\n@@ -4,10 +4,12 @@\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.function.Supplier;\n \n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.PhiListAttr;\n+import jadx.core.dex.attributes.nodes.TmpEdgeAttr;\n import jadx.core.dex.instructions.IfNode;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.PhiInsn;\n@@ -61,14 +63,14 @@ public static void checkMethod(MethodNode mth) {\n \t\t}\n \t\tfor (BlockNode block : basicBlocks) {\n \t\t\tfor (InsnNode insn : block.getInstructions()) {\n-\t\t\t\tcheckInsn(mth, insn);\n+\t\t\t\tcheckInsn(mth, block, insn);\n \t\t\t}\n \t\t}\n \t\tcheckSSAVars(mth);\n \t\t// checkPHI(mth);\n \t}\n \n-\tprivate static void checkInsn(MethodNode mth, InsnNode insn) {\n+\tprivate static void checkInsn(MethodNode mth, BlockNode block, InsnNode insn) {\n \t\tif (insn.getResult() != null) {\n \t\t\tcheckVar(mth, insn, insn.getResult());\n \t\t}\n@@ -77,24 +79,45 @@ private static void checkInsn(MethodNode mth, InsnNode insn) {\n \t\t\t\tcheckVar(mth, insn, (RegisterArg) arg);\n \t\t\t} else if (arg.isInsnWrap()) {\n \t\t\t\tInsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();\n-\t\t\t\tcheckInsn(mth, wrapInsn);\n+\t\t\t\tcheckInsn(mth, block, wrapInsn);\n \t\t\t}\n \t\t}\n-\t\tif (insn instanceof TernaryInsn) {\n-\t\t\tTernaryInsn ternaryInsn = (TernaryInsn) insn;\n-\t\t\tfor (RegisterArg arg : ternaryInsn.getCondition().getRegisterArgs()) {\n-\t\t\t\tcheckVar(mth, insn, arg);\n-\t\t\t}\n-\t\t} else if (insn instanceof IfNode) {\n-\t\t\tIfNode ifNode = (IfNode) insn;\n-\t\t\tcheckBlock(mth, ifNode.getThenBlock());\n-\t\t\tcheckBlock(mth, ifNode.getElseBlock());\n+\t\tswitch (insn.getType()) {\n+\t\t\tcase TERNARY:\n+\t\t\t\tTernaryInsn ternaryInsn = (TernaryInsn) insn;\n+\t\t\t\tfor (RegisterArg arg : ternaryInsn.getCondition().getRegisterArgs()) {\n+\t\t\t\t\tcheckVar(mth, insn, arg);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\tcase IF:\n+\t\t\t\tIfNode ifNode = (IfNode) insn;\n+\t\t\t\tif (!ifNode.getThenBlock().equals(ifNode.getElseBlock())) {\n+\t\t\t\t\t// exclude temp edges\n+\t\t\t\t\tint branches = (int) block.getSuccessors().stream().filter(b -> !hasTmpEdge(block, b)).count();\n+\t\t\t\t\tif (branches != 2) {\n+\t\t\t\t\t\tDebugUtils.dumpRaw(mth, \"error\");\n+\t\t\t\t\t\tthrow new JadxRuntimeException(\n+\t\t\t\t\t\t\t\t\"Incorrect if block successors count: \" + branches + \" (expect 2), block: \" + block);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tcheckBlock(mth, ifNode.getThenBlock(), () -> \"then block in if insn: \" + ifNode);\n+\t\t\t\tcheckBlock(mth, ifNode.getElseBlock(), () -> \"else block in if insn: \" + ifNode);\n+\t\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tprivate static boolean hasTmpEdge(BlockNode start, BlockNode end) {\n+\t\tTmpEdgeAttr tmpEdgeAttr = end.get(AType.TMP_EDGE);\n+\t\tif (tmpEdgeAttr == null) {\n+\t\t\treturn false;\n \t\t}\n+\t\treturn tmpEdgeAttr.getBlock().equals(start);\n \t}\n \n-\tprivate static void checkBlock(MethodNode mth, BlockNode block) {\n+\tprivate static void checkBlock(MethodNode mth, BlockNode block, Supplier<String> source) {\n \t\tif (!mth.getBasicBlocks().contains(block)) {\n-\t\t\tthrow new JadxRuntimeException(\"Block not registered in method: \" + block);\n+\t\t\tthrow new JadxRuntimeException(\"Block not registered in method: \" + block + \" from \" + source.get());\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch10.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch10.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch10.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch10.java\n@@ -0,0 +1,17 @@\n+package jadx.tests.integration.trycatch;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestTryCatch10 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.countString(3, \"return false;\");\n+\t}\n+}",
    "output": "Fix improve try/catch temp edges injection"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/AccessCheckUtils.java b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/AccessCheckUtils.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/AccessCheckUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/AccessCheckUtils.java\n@@ -0,0 +1,85 @@\n+package jadx.core.dex.nodes.utils;\n+\n+import jadx.core.dex.info.AccessInfo;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.core.dex.nodes.FieldNode;\n+import jadx.core.dex.nodes.ICodeNode;\n+import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.dex.nodes.RootNode;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n+\n+class AccessCheckUtils {\n+\n+\tprivate final RootNode root;\n+\n+\tAccessCheckUtils(RootNode rootNode) {\n+\t\tthis.root = rootNode;\n+\t}\n+\n+\tboolean isAccessible(ICodeNode targetNode, ICodeNode callerNode) {\n+\t\tClassNode targetCls = getDeclaringClass(targetNode);\n+\t\tClassNode callerCls = getDeclaringClass(callerNode);\n+\n+\t\tif (targetCls.equals(callerCls)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tAccessInfo targetVisibility;\n+\t\tif (targetNode == targetCls) {\n+\t\t\ttargetVisibility = targetNode.getAccessFlags().getVisibility();\n+\t\t} else {\n+\t\t\tAccessInfo targetClsVisibility = targetCls.getAccessFlags().getVisibility();\n+\t\t\tAccessInfo targetNodeVisibility = targetNode.getAccessFlags().getVisibility();\n+\t\t\ttargetVisibility = targetClsVisibility.isVisibilityWeakerThan(targetNodeVisibility)\n+\t\t\t\t\t? targetClsVisibility\n+\t\t\t\t\t: targetNodeVisibility;\n+\t\t}\n+\n+\t\tif (targetVisibility.isPublic()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (targetVisibility.isProtected()) {\n+\t\t\treturn isProtectedAccessible(targetCls, callerCls);\n+\t\t}\n+\n+\t\tif (targetVisibility.isPackagePrivate()) {\n+\t\t\treturn isPackagePrivateAccessible(targetCls, callerCls);\n+\t\t}\n+\n+\t\tif (targetVisibility.isPrivate()) {\n+\t\t\treturn isPrivateAccessible(targetCls, callerCls);\n+\t\t}\n+\n+\t\tthrow new JadxRuntimeException(targetVisibility + \" is not supported\");\n+\t}\n+\n+\tprivate ClassNode getDeclaringClass(ICodeNode node) {\n+\t\tif (node instanceof ClassNode) {\n+\t\t\treturn (ClassNode) node;\n+\t\t} else if (node instanceof MethodNode) {\n+\t\t\treturn ((MethodNode) node).getParentClass();\n+\t\t} else if (node instanceof FieldNode) {\n+\t\t\treturn ((FieldNode) node).getParentClass();\n+\t\t} else {\n+\t\t\tthrow new JadxRuntimeException(node + \" is not supported\");\n+\t\t}\n+\t}\n+\n+\tprivate boolean isProtectedAccessible(ClassNode cls, ClassNode callerCls) {\n+\t\treturn isPackagePrivateAccessible(cls, callerCls) || isSuperType(cls, callerCls);\n+\t}\n+\n+\tprivate boolean isPackagePrivateAccessible(ClassNode cls, ClassNode callerCls) {\n+\t\treturn cls.getPackageNode().equals(callerCls.getPackageNode());\n+\t}\n+\n+\tprivate boolean isPrivateAccessible(ClassNode cls, ClassNode callerCls) {\n+\t\treturn cls.getTopParentClass().equals(callerCls.getTopParentClass());\n+\t}\n+\n+\tprivate boolean isSuperType(ClassNode cls, ClassNode superCls) {\n+\t\treturn root.getClsp().getSuperTypes(cls.getRawName()).stream()\n+\t\t\t\t.anyMatch(x -> x.equals(superCls.getRawName()));\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/ClassUtils.java b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/ClassUtils.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/ClassUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/ClassUtils.java\n@@ -1,57 +1,19 @@\n package jadx.core.dex.nodes.utils;\n \n-import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.RootNode;\n-import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public class ClassUtils {\n \n \tprivate final RootNode root;\n+\tprivate final AccessCheckUtils accessCheckUtils;\n \n \tpublic ClassUtils(RootNode rootNode) {\n \t\tthis.root = rootNode;\n+\t\tthis.accessCheckUtils = new AccessCheckUtils(root);\n \t}\n \n \tpublic boolean isAccessible(ClassNode cls, ClassNode callerCls) {\n-\t\tif (cls.equals(callerCls)) {\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\tfinal AccessInfo accessFlags = cls.getAccessFlags();\n-\t\tif (accessFlags.isPublic()) {\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\tif (accessFlags.isProtected()) {\n-\t\t\treturn isProtectedAccessible(cls, callerCls);\n-\t\t}\n-\n-\t\tif (accessFlags.isPackagePrivate()) {\n-\t\t\treturn isPackagePrivateAccessible(cls, callerCls);\n-\t\t}\n-\n-\t\tif (accessFlags.isPrivate()) {\n-\t\t\treturn isPrivateAccessible(cls, callerCls);\n-\t\t}\n-\n-\t\tthrow new JadxRuntimeException(accessFlags + \" is not supported\");\n-\t}\n-\n-\tprivate boolean isProtectedAccessible(ClassNode cls, ClassNode callerCls) {\n-\t\treturn isPackagePrivateAccessible(cls, callerCls) || isSuperType(cls, callerCls);\n-\t}\n-\n-\tprivate boolean isPackagePrivateAccessible(ClassNode cls, ClassNode callerCls) {\n-\t\treturn cls.getPackageNode().equals(callerCls.getPackageNode());\n-\t}\n-\n-\tprivate boolean isPrivateAccessible(ClassNode cls, ClassNode callerCls) {\n-\t\treturn cls.getTopParentClass().equals(callerCls.getTopParentClass());\n-\t}\n-\n-\tprivate boolean isSuperType(ClassNode cls, ClassNode superCls) {\n-\t\treturn root.getClsp().getSuperTypes(cls.getRawName()).stream()\n-\t\t\t\t.anyMatch(x -> x.equals(superCls.getRawName()));\n+\t\treturn accessCheckUtils.isAccessible(cls, callerCls);\n \t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java\n@@ -24,9 +24,11 @@\n \n public class MethodUtils {\n \tprivate final RootNode root;\n+\tprivate final AccessCheckUtils accessCheckUtils;\n \n \tpublic MethodUtils(RootNode rootNode) {\n \t\tthis.root = rootNode;\n+\t\tthis.accessCheckUtils = new AccessCheckUtils(root);\n \t}\n \n \t@Nullable\n@@ -171,4 +173,8 @@ public ClassInfo getMethodOriginDeclClass(MethodNode mth) {\n \t\t}\n \t\treturn mth.getMethodInfo().getDeclClass();\n \t}\n+\n+\tpublic boolean isAccessible(MethodNode mth, MethodNode callerMth) {\n+\t\treturn accessCheckUtils.isAccessible(mth, callerMth);\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n@@ -15,6 +15,7 @@\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.nodes.utils.ClassUtils;\n+import jadx.core.dex.nodes.utils.MethodUtils;\n import jadx.core.utils.exceptions.JadxException;\n \n @JadxVisitor(\n@@ -25,12 +26,14 @@\n public class FixAccessModifiers extends AbstractVisitor {\n \n \tprivate ClassUtils classUtils;\n+\tprivate MethodUtils methodUtils;\n \n \tprivate boolean respectAccessModifiers;\n \n \t@Override\n \tpublic void init(RootNode root) {\n \t\tthis.classUtils = root.getClassUtils();\n+\t\tthis.methodUtils = root.getMethodUtils();\n \t\tthis.respectAccessModifiers = root.getArgs().isRespectBytecodeAccModifiers();\n \t}\n \n@@ -103,11 +106,12 @@ private int fixClassVisibility(ClassNode cls) {\n \t\treturn -1;\n \t}\n \n-\tprivate static int fixMethodVisibility(MethodNode mth) {\n+\tprivate int fixMethodVisibility(MethodNode mth) {\n \t\tAccessInfo accessFlags = mth.getAccessFlags();\n \t\tif (accessFlags.isPublic()) {\n \t\t\treturn -1;\n \t\t}\n+\n \t\tMethodOverrideAttr overrideAttr = mth.get(AType.METHOD_OVERRIDE);\n \t\tif (overrideAttr != null && !overrideAttr.getOverrideList().isEmpty()) {\n \t\t\t// visibility can't be weaker\n@@ -117,17 +121,13 @@ private static int fixMethodVisibility(MethodNode mth) {\n \t\t\t\treturn parentAccInfo.getVisibility().rawValue();\n \t\t\t}\n \t\t}\n-\t\tif (mth.getUseIn().isEmpty()) {\n-\t\t\treturn -1;\n-\t\t}\n \n-\t\tClassNode thisTopParentCls = mth.getParentClass().getTopParentClass();\n \t\tfor (MethodNode useMth : mth.getUseIn()) {\n-\t\t\tClassNode useInTPCls = useMth.getParentClass().getTopParentClass();\n-\t\t\tif (!useInTPCls.equals(thisTopParentCls)) {\n+\t\t\tif (!methodUtils.isAccessible(mth, useMth)) {\n \t\t\t\treturn AccessFlags.PUBLIC;\n \t\t\t}\n \t\t}\n+\n \t\treturn -1;\n \t}\n }",
    "output": "Fix improve checking of access modifiers for methods"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -40,6 +40,7 @@\n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.info.PackageInfo;\n import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.nodes.utils.ClassUtils;\n import jadx.core.dex.nodes.utils.MethodUtils;\n import jadx.core.dex.nodes.utils.TypeUtils;\n import jadx.core.dex.visitors.DepthTraversal;\n@@ -71,6 +72,7 @@ public class RootNode {\n \tprivate final InfoStorage infoStorage = new InfoStorage();\n \tprivate final CacheStorage cacheStorage = new CacheStorage();\n \tprivate final TypeUpdate typeUpdate;\n+\tprivate final ClassUtils classUtils;\n \tprivate final MethodUtils methodUtils;\n \tprivate final TypeUtils typeUtils;\n \tprivate final AttributeStorage attributes = new AttributeStorage();\n@@ -104,6 +106,7 @@ public RootNode(JadxArgs args) {\n \t\tthis.stringUtils = new StringUtils(args);\n \t\tthis.constValues = new ConstStorage(args);\n \t\tthis.typeUpdate = new TypeUpdate(this);\n+\t\tthis.classUtils = new ClassUtils(this);\n \t\tthis.methodUtils = new MethodUtils(this);\n \t\tthis.typeUtils = new TypeUtils(this);\n \t}\n@@ -704,6 +707,10 @@ public ICodeCache getCodeCache() {\n \t\treturn args.getCodeCache();\n \t}\n \n+\tpublic ClassUtils getClassUtils() {\n+\t\treturn classUtils;\n+\t}\n+\n \tpublic MethodUtils getMethodUtils() {\n \t\treturn methodUtils;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/ClassUtils.java b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/ClassUtils.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/ClassUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/ClassUtils.java\n@@ -0,0 +1,57 @@\n+package jadx.core.dex.nodes.utils;\n+\n+import jadx.core.dex.info.AccessInfo;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.core.dex.nodes.RootNode;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n+\n+public class ClassUtils {\n+\n+\tprivate final RootNode root;\n+\n+\tpublic ClassUtils(RootNode rootNode) {\n+\t\tthis.root = rootNode;\n+\t}\n+\n+\tpublic boolean isAccessible(ClassNode cls, ClassNode callerCls) {\n+\t\tif (cls.equals(callerCls)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tfinal AccessInfo accessFlags = cls.getAccessFlags();\n+\t\tif (accessFlags.isPublic()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (accessFlags.isProtected()) {\n+\t\t\treturn isProtectedAccessible(cls, callerCls);\n+\t\t}\n+\n+\t\tif (accessFlags.isPackagePrivate()) {\n+\t\t\treturn isPackagePrivateAccessible(cls, callerCls);\n+\t\t}\n+\n+\t\tif (accessFlags.isPrivate()) {\n+\t\t\treturn isPrivateAccessible(cls, callerCls);\n+\t\t}\n+\n+\t\tthrow new JadxRuntimeException(accessFlags + \" is not supported\");\n+\t}\n+\n+\tprivate boolean isProtectedAccessible(ClassNode cls, ClassNode callerCls) {\n+\t\treturn isPackagePrivateAccessible(cls, callerCls) || isSuperType(cls, callerCls);\n+\t}\n+\n+\tprivate boolean isPackagePrivateAccessible(ClassNode cls, ClassNode callerCls) {\n+\t\treturn cls.getPackageNode().equals(callerCls.getPackageNode());\n+\t}\n+\n+\tprivate boolean isPrivateAccessible(ClassNode cls, ClassNode callerCls) {\n+\t\treturn cls.getTopParentClass().equals(callerCls.getTopParentClass());\n+\t}\n+\n+\tprivate boolean isSuperType(ClassNode cls, ClassNode superCls) {\n+\t\treturn root.getClsp().getSuperTypes(cls.getRawName()).stream()\n+\t\t\t\t.anyMatch(x -> x.equals(superCls.getRawName()));\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n@@ -1,5 +1,8 @@\n package jadx.core.dex.visitors;\n \n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n import jadx.api.plugins.input.data.AccessFlags;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n@@ -11,6 +14,7 @@\n import jadx.core.dex.nodes.IMethodDetails;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.RootNode;\n+import jadx.core.dex.nodes.utils.ClassUtils;\n import jadx.core.utils.exceptions.JadxException;\n \n @JadxVisitor(\n@@ -20,10 +24,13 @@\n )\n public class FixAccessModifiers extends AbstractVisitor {\n \n+\tprivate ClassUtils classUtils;\n+\n \tprivate boolean respectAccessModifiers;\n \n \t@Override\n \tpublic void init(RootNode root) {\n+\t\tthis.classUtils = root.getClassUtils();\n \t\tthis.respectAccessModifiers = root.getArgs().isRespectBytecodeAccModifiers();\n \t}\n \n@@ -60,43 +67,39 @@ public static void changeVisibility(NotificationAttrNode node, int newVisFlag) {\n \t}\n \n \tprivate int fixClassVisibility(ClassNode cls) {\n-\t\tif (cls.getUseIn().isEmpty()) {\n+\t\tAccessInfo accessFlags = cls.getAccessFlags();\n+\t\tif (accessFlags.isPublic()) {\n \t\t\treturn -1;\n \t\t}\n-\t\tAccessInfo accessFlags = cls.getAccessFlags();\n-\t\tif (accessFlags.isPrivate()) {\n-\t\t\tif (!cls.isInner()) {\n-\t\t\t\treturn AccessFlags.PUBLIC;\n-\t\t\t}\n-\t\t\t// check if private inner class is used outside\n-\t\t\tClassNode topParentClass = cls.getTopParentClass();\n-\t\t\tfor (ClassNode useCls : cls.getUseIn()) {\n-\t\t\t\tif (useCls.getTopParentClass() != topParentClass) {\n-\t\t\t\t\treturn AccessFlags.PUBLIC;\n-\t\t\t\t}\n-\t\t\t}\n+\n+\t\tif (cls.isTopClass() && (accessFlags.isPrivate() || accessFlags.isProtected())) {\n+\t\t\treturn AccessFlags.PUBLIC;\n \t\t}\n-\t\tif (accessFlags.isPackagePrivate()) {\n-\t\t\tString pkg = cls.getPackage();\n-\t\t\tfor (ClassNode useCls : cls.getUseIn()) {\n-\t\t\t\tif (!useCls.getPackage().equals(pkg)) {\n-\t\t\t\t\treturn AccessFlags.PUBLIC;\n-\t\t\t\t}\n+\n+\t\tfor (ClassNode useCls : cls.getUseIn()) {\n+\t\t\tif (!classUtils.isAccessible(cls, useCls)) {\n+\t\t\t\treturn AccessFlags.PUBLIC;\n \t\t\t}\n \t\t}\n-\t\tif (!accessFlags.isPublic()) {\n-\t\t\t// if class is used in inlinable method => make it public\n-\t\t\tfor (MethodNode useMth : cls.getUseInMth()) {\n-\t\t\t\tMethodInlineAttr inlineAttr = useMth.get(AType.METHOD_INLINE);\n-\t\t\t\tboolean isInline = inlineAttr != null && !inlineAttr.notNeeded();\n-\t\t\t\tboolean isCandidateForInline = useMth.contains(AFlag.METHOD_CANDIDATE_FOR_INLINE);\n-\n-\t\t\t\tboolean mostLikelyInline = isInline || isCandidateForInline;\n-\t\t\t\tif (mostLikelyInline && !useMth.getUseIn().isEmpty()) {\n-\t\t\t\t\treturn AccessFlags.PUBLIC;\n+\n+\t\tfor (MethodNode useMth : cls.getUseInMth()) {\n+\t\t\tMethodInlineAttr inlineAttr = useMth.get(AType.METHOD_INLINE);\n+\t\t\tboolean isInline = inlineAttr != null && !inlineAttr.notNeeded();\n+\t\t\tboolean isCandidateForInline = useMth.contains(AFlag.METHOD_CANDIDATE_FOR_INLINE);\n+\n+\t\t\tif (isInline || isCandidateForInline) {\n+\t\t\t\tSet<ClassNode> usedInClss = useMth.getUseIn().stream()\n+\t\t\t\t\t\t.map(MethodNode::getParentClass)\n+\t\t\t\t\t\t.collect(Collectors.toSet());\n+\n+\t\t\t\tfor (ClassNode useCls : usedInClss) {\n+\t\t\t\t\tif (!classUtils.isAccessible(cls, useCls)) {\n+\t\t\t\t\t\treturn AccessFlags.PUBLIC;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\n \t\treturn -1;\n \t}",
    "output": "Fix improve checking of access modifiers for classes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -864,6 +864,10 @@ private BlockNode getOneIntersectionBlock(BlockNode out, BitSet caseBlocks, BitS\n \t\t// works if no fallthrough cases and no returns inside switch\n \t\tBitSet outs = BlockUtils.newBlocksBitSet(mth);\n \t\tfor (BlockNode s : block.getCleanSuccessors()) {\n+\t\t\tif (s.contains(AFlag.LOOP_END)) {\n+\t\t\t\t// loop end dom frontier is loop start, ignore it\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\touts.or(s.getDomFrontier());\n \t\t}\n \t\touts.clear(block.getId());\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop3.java b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop3.java\n@@ -0,0 +1,44 @@\n+package jadx.tests.integration.switches;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestSwitchInLoop3 extends IntegrationTest {\n+\n+\t@SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n+\tpublic static class TestCls {\n+\t\tpublic int test(int k) {\n+\t\t\tint a = 0;\n+\t\t\twhile (true) {\n+\t\t\t\tint x = 0; // keep this: force to generate the necessary CFG\n+\t\t\t\tswitch (k) {\n+\t\t\t\t\tcase 0:\n+\t\t\t\t\t\treturn a;\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\ta++;\n+\t\t\t\t\t\tk >>= 1;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(test(1)).isEqualTo(1);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsLines(3,\n+\t\t\t\t\t\t\"switch (k) {\",\n+\t\t\t\t\t\tindent() + \"case 0:\",\n+\t\t\t\t\t\tindent(2) + \"return a;\",\n+\t\t\t\t\t\tindent() + \"default:\",\n+\t\t\t\t\t\tindent(2) + \"a++;\",\n+\t\t\t\t\t\tindent(2) + \"k >>= 1;\");\n+\t}\n+}",
    "output": "Fix improve switch `out` search in loop"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n@@ -348,11 +348,11 @@ public static List<Path> toPathsWithTrim(File[] files) {\n \t}\n \n \tpublic static Path toPathWithTrim(File file) {\n-\t\treturn Path.of(file.getPath().stripTrailing());\n+\t\treturn toPathWithTrim(file.getPath());\n \t}\n \n \tpublic static Path toPathWithTrim(String file) {\n-\t\treturn Path.of(file.stripTrailing());\n+\t\treturn Path.of(file.trim());\n \t}\n \n \tpublic static List<Path> fileNamesToPaths(List<String> fileNames) {",
    "output": "Fix trim also leading spaces in paths from file dialog"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n@@ -343,6 +343,18 @@ public static List<Path> toPaths(File[] files) {\n \t\treturn Stream.of(files).map(File::toPath).collect(Collectors.toList());\n \t}\n \n+\tpublic static List<Path> toPathsWithTrim(File[] files) {\n+\t\treturn Stream.of(files).map(FileUtils::toPathWithTrim).collect(Collectors.toList());\n+\t}\n+\n+\tpublic static Path toPathWithTrim(File file) {\n+\t\treturn Path.of(file.getPath().stripTrailing());\n+\t}\n+\n+\tpublic static Path toPathWithTrim(String file) {\n+\t\treturn Path.of(file.stripTrailing());\n+\t}\n+\n \tpublic static List<Path> fileNamesToPaths(List<String> fileNames) {\n \t\treturn fileNames.stream().map(Paths::get).collect(Collectors.toList());\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java\n@@ -56,11 +56,11 @@ public List<Path> showDialog() {\n \t\tdata.setCurrentDir(getCurrentDirectory().toPath());\n \t\tFile[] selectedFiles = getSelectedFiles();\n \t\tif (selectedFiles.length != 0) {\n-\t\t\treturn FileUtils.toPaths(selectedFiles);\n+\t\t\treturn FileUtils.toPathsWithTrim(selectedFiles);\n \t\t}\n \t\tFile chosenFile = getSelectedFile();\n \t\tif (chosenFile != null) {\n-\t\t\treturn Collections.singletonList(chosenFile.toPath());\n+\t\t\treturn Collections.singletonList(FileUtils.toPathWithTrim(chosenFile));\n \t\t}\n \t\treturn Collections.emptyList();\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileDialog.java\n@@ -37,10 +37,10 @@ public List<Path> showDialog() {\n \t\tFile[] selectedFiles = fileDialog.getFiles();\n \t\tif (!Utils.isEmpty(selectedFiles)) {\n \t\t\tdata.setCurrentDir(Paths.get(fileDialog.getDirectory()));\n-\t\t\treturn FileUtils.toPaths(selectedFiles);\n+\t\t\treturn FileUtils.toPathsWithTrim(selectedFiles);\n \t\t}\n \t\tif (fileDialog.getFile() != null) {\n-\t\t\treturn Collections.singletonList(Paths.get(fileDialog.getFile()));\n+\t\t\treturn Collections.singletonList(FileUtils.toPathWithTrim(fileDialog.getFile()));\n \t\t}\n \t\treturn Collections.emptyList();\n \t}",
    "output": "Fix trim trailing spaces in input files"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n@@ -1,5 +1,7 @@\n package jadx.core.dex.visitors;\n \n+import java.util.List;\n+\n import org.jetbrains.annotations.Nullable;\n \n import jadx.core.codegen.TypeGen;\n@@ -107,7 +109,20 @@ private static RegisterArg insertPhiInsn(MethodNode mth, BlockNode curBlock,\n \t\t}\n \t\tBlockNode crossBlock = BlockUtils.getPathCross(mth, curBlock, otherBlock);\n \t\tif (crossBlock == null) {\n-\t\t\tthrow new JadxRuntimeException(\"Path cross not found for blocks: \" + curBlock + \" and \" + otherBlock);\n+\t\t\t// no path cross => PHI insn not needed\n+\t\t\t// use new SSA var on usage from current path\n+\t\t\tRegisterArg newResArg = instArg.duplicateWithNewSSAVar(mth);\n+\t\t\tList<BlockNode> pathBlocks = BlockUtils.collectAllSuccessors(mth, curBlock, true);\n+\t\t\tfor (RegisterArg useReg : instArg.getSVar().getUseList()) {\n+\t\t\t\tInsnNode parentInsn = useReg.getParentInsn();\n+\t\t\t\tif (parentInsn != null) {\n+\t\t\t\t\tBlockNode useBlock = BlockUtils.getBlockByInsn(mth, parentInsn, pathBlocks);\n+\t\t\t\t\tif (useBlock != null) {\n+\t\t\t\t\t\tparentInsn.replaceArg(useReg, newResArg.duplicate());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn newResArg;\n \t\t}\n \t\tRegisterArg newResArg = instArg.duplicateWithNewSSAVar(mth);\n \t\tRegisterArg useArg = otherCtr.getResult();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -249,8 +249,11 @@ public static boolean containsExitInsn(IBlock block) {\n \t\t\t\t|| type == InsnType.CONTINUE;\n \t}\n \n-\t@Nullable\n-\tpublic static BlockNode getBlockByInsn(MethodNode mth, @Nullable InsnNode insn) {\n+\tpublic static @Nullable BlockNode getBlockByInsn(MethodNode mth, @Nullable InsnNode insn) {\n+\t\treturn getBlockByInsn(mth, insn, mth.getBasicBlocks());\n+\t}\n+\n+\tpublic static @Nullable BlockNode getBlockByInsn(MethodNode mth, @Nullable InsnNode insn, List<BlockNode> blocks) {\n \t\tif (insn == null) {\n \t\t\treturn null;\n \t\t}\n@@ -260,7 +263,7 @@ public static BlockNode getBlockByInsn(MethodNode mth, @Nullable InsnNode insn)\n \t\tif (insn.contains(AFlag.WRAPPED)) {\n \t\t\treturn getBlockByWrappedInsn(mth, insn);\n \t\t}\n-\t\tfor (BlockNode bn : mth.getBasicBlocks()) {\n+\t\tfor (BlockNode bn : blocks) {\n \t\t\tif (blockContains(bn, insn)) {\n \t\t\t\treturn bn;\n \t\t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched3.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched3.java\n@@ -0,0 +1,18 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestConstructorBranched3 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.countString(4, \"return new f(\");\n+\t}\n+}",
    "output": "Fix handle quick return on branched constructor"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n@@ -115,8 +115,8 @@ private static RegisterArg insertPhiInsn(MethodNode mth, BlockNode curBlock,\n \n \t\tPhiInsn phiInsn = SSATransform.addPhi(mth, crossBlock, useArg.getRegNum());\n \t\tphiInsn.setResult(useArg.duplicate());\n-\t\tphiInsn.bindArg(newResArg.duplicate(), BlockUtils.getPrevBlockOnPath(crossBlock, curBlock));\n-\t\tphiInsn.bindArg(otherResArg.duplicate(), BlockUtils.getPrevBlockOnPath(crossBlock, otherBlock));\n+\t\tphiInsn.bindArg(newResArg.duplicate(), BlockUtils.getPrevBlockOnPath(mth, crossBlock, curBlock));\n+\t\tphiInsn.bindArg(otherResArg.duplicate(), BlockUtils.getPrevBlockOnPath(mth, crossBlock, otherBlock));\n \t\tphiInsn.rebindArgs();\n \n \t\totherCtr.setResult(otherResArg.duplicate());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -37,6 +37,7 @@\n import jadx.core.dex.trycatch.CatchAttr;\n import jadx.core.dex.trycatch.ExceptionHandler;\n import jadx.core.utils.blocks.BlockSet;\n+import jadx.core.utils.blocks.DFSIteration;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public class BlockUtils {\n@@ -437,18 +438,21 @@ public static BlockNode getNextBlockToPath(BlockNode block, BlockNode pathEnd) {\n \t/**\n \t * Return predecessor on path from 'pathStart' block\n \t */\n-\tpublic static @Nullable BlockNode getPrevBlockOnPath(BlockNode block, BlockNode pathStart) {\n-\t\tList<BlockNode> preds = block.getPredecessors();\n-\t\tif (preds.contains(pathStart)) {\n+\tpublic static @Nullable BlockNode getPrevBlockOnPath(MethodNode mth, BlockNode block, BlockNode pathStart) {\n+\t\tBlockSet preds = BlockSet.from(mth, block.getPredecessors());\n+\t\tif (preds.get(pathStart)) {\n \t\t\treturn pathStart;\n \t\t}\n-\t\tSet<BlockNode> path = getAllPathsBlocks(pathStart, block);\n-\t\tfor (BlockNode p : preds) {\n-\t\t\tif (path.contains(p)) {\n-\t\t\t\treturn p;\n+\t\tDFSIteration dfs = new DFSIteration(mth, pathStart, BlockNode::getCleanSuccessors);\n+\t\twhile (true) {\n+\t\t\tBlockNode next = dfs.next();\n+\t\t\tif (next == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tif (preds.get(next)) {\n+\t\t\t\treturn next;\n \t\t\t}\n \t\t}\n-\t\treturn null;\n \t}\n \n \t/**\n@@ -515,24 +519,13 @@ public static void visitReverseDFS(MethodNode mth, Consumer<BlockNode> visitor)\n \n \tprivate static void visitDFS(MethodNode mth, BlockNode startBlock,\n \t\t\tFunction<BlockNode, List<BlockNode>> nextFunc, Consumer<BlockNode> visitor) {\n-\t\tBlockSet visited = new BlockSet(mth);\n-\t\tDeque<BlockNode> queue = new ArrayDeque<>();\n-\t\tqueue.addLast(startBlock);\n-\t\tvisited.set(startBlock);\n+\t\tDFSIteration dfsIteration = new DFSIteration(mth, startBlock, nextFunc);\n \t\twhile (true) {\n-\t\t\tBlockNode current = queue.pollLast();\n-\t\t\tif (current == null) {\n+\t\t\tBlockNode next = dfsIteration.next();\n+\t\t\tif (next == null) {\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\tvisitor.accept(current);\n-\t\t\tList<BlockNode> nextBlocks = nextFunc.apply(current);\n-\t\t\tint count = nextBlocks.size();\n-\t\t\tfor (int i = count - 1; i >= 0; i--) { // to preserve order in queue\n-\t\t\t\tBlockNode next = nextBlocks.get(i);\n-\t\t\t\tif (!visited.checkAndSet(next)) {\n-\t\t\t\t\tqueue.addLast(next);\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tvisitor.accept(next);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/blocks/DFSIteration.java b/jadx-core/src/main/java/jadx/core/utils/blocks/DFSIteration.java\n--- a/jadx-core/src/main/java/jadx/core/utils/blocks/DFSIteration.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/blocks/DFSIteration.java\n@@ -0,0 +1,41 @@\n+package jadx.core.utils.blocks;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import jadx.core.dex.nodes.BlockNode;\n+import jadx.core.dex.nodes.MethodNode;\n+\n+public class DFSIteration {\n+\tprivate final Function<BlockNode, List<BlockNode>> nextFunc;\n+\tprivate final Deque<BlockNode> queue;\n+\tprivate final BlockSet visited;\n+\n+\tpublic DFSIteration(MethodNode mth, BlockNode startBlock, Function<BlockNode, List<BlockNode>> next) {\n+\t\tnextFunc = next;\n+\t\tqueue = new ArrayDeque<>();\n+\t\tvisited = new BlockSet(mth);\n+\t\tqueue.addLast(startBlock);\n+\t\tvisited.set(startBlock);\n+\t}\n+\n+\tpublic @Nullable BlockNode next() {\n+\t\tBlockNode current = queue.pollLast();\n+\t\tif (current == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<BlockNode> nextBlocks = nextFunc.apply(current);\n+\t\tint count = nextBlocks.size();\n+\t\tfor (int i = count - 1; i >= 0; i--) { // to preserve order in queue\n+\t\t\tBlockNode next = nextBlocks.get(i);\n+\t\t\tif (!visited.checkAndSet(next)) {\n+\t\t\t\tqueue.addLast(next);\n+\t\t\t}\n+\t\t}\n+\t\treturn current;\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched2.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched2.java\n@@ -0,0 +1,18 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestConstructorBranched2 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.countString(3, \"new StringBuilder()\");\n+\t}\n+}",
    "output": "Use correct approach to get prev block on path"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n@@ -95,6 +95,10 @@ public Iterable<InsnArg> getArguments() {\n \t\treturn arguments;\n \t}\n \n+\tpublic List<InsnArg> getArgList() {\n+\t\treturn arguments;\n+\t}\n+\n \tpublic int getArgsCount() {\n \t\treturn arguments.size();\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n@@ -20,6 +20,7 @@\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.utils.BlockUtils;\n+import jadx.core.utils.ListUtils;\n import jadx.core.utils.exceptions.JadxException;\n \n @JadxVisitor(\n@@ -42,18 +43,22 @@ public void visit(MethodNode mth) throws JadxException {\n \t */\n \t@Nullable\n \tpublic static MethodInlineAttr process(MethodNode mth) {\n-\t\tMethodInlineAttr mia = mth.get(AType.METHOD_INLINE);\n-\t\tif (mia != null) {\n-\t\t\treturn mia;\n-\t\t}\n-\t\tif (mth.contains(AFlag.METHOD_CANDIDATE_FOR_INLINE)) {\n-\t\t\tif (mth.getBasicBlocks() == null) {\n-\t\t\t\treturn null;\n+\t\ttry {\n+\t\t\tMethodInlineAttr mia = mth.get(AType.METHOD_INLINE);\n+\t\t\tif (mia != null) {\n+\t\t\t\treturn mia;\n \t\t\t}\n-\t\t\tMethodInlineAttr inlined = inlineMth(mth);\n-\t\t\tif (inlined != null) {\n-\t\t\t\treturn inlined;\n+\t\t\tif (mth.contains(AFlag.METHOD_CANDIDATE_FOR_INLINE)) {\n+\t\t\t\tif (mth.getBasicBlocks() == null) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tMethodInlineAttr inlined = inlineMth(mth);\n+\t\t\t\tif (inlined != null) {\n+\t\t\t\t\treturn inlined;\n+\t\t\t\t}\n \t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tmth.addWarnComment(\"Method inline analysis failed\", e);\n \t\t}\n \t\treturn MethodInlineAttr.inlineNotNeeded(mth);\n \t}\n@@ -113,9 +118,12 @@ private static boolean isSyntheticAccessPattern(MethodNode mth, InsnNode firstIn\n \t\t\t\t\t\t&& firstInsn.getArg(0).isSameVar(mthRegs.get(0));\n \n \t\t\tcase INVOKE:\n-\t\t\t\treturn !mthRegs.isEmpty()\n-\t\t\t\t\t\t&& firstInsn.getArg(0).isSameVar(mthRegs.get(0))\n-\t\t\t\t\t\t&& retInsn.getArg(0).isSameVar(firstInsn.getResult());\n+\t\t\t\tif (!retInsn.getArg(0).isSameVar(firstInsn.getResult())) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\treturn ListUtils.orderedEquals(\n+\t\t\t\t\t\tmth.getArgRegs(), firstInsn.getArgList(),\n+\t\t\t\t\t\t(mthArg, insnArg) -> insnArg.isSameVar(mthArg));\n \t\t\tdefault:\n \t\t\t\treturn false;\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/ListUtils.java b/jadx-core/src/main/java/jadx/core/utils/ListUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/ListUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/ListUtils.java\n@@ -4,11 +4,13 @@\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Objects;\n import java.util.Set;\n import java.util.TreeSet;\n+import java.util.function.BiPredicate;\n import java.util.function.Function;\n import java.util.function.Predicate;\n \n@@ -30,6 +32,25 @@ public static <T> boolean unorderedEquals(List<T> first, List<T> second) {\n \t\treturn first.containsAll(second);\n \t}\n \n+\tpublic static <T, U> boolean orderedEquals(List<T> list1, List<U> list2, BiPredicate<T, U> comparer) {\n+\t\tif (list1 == list2) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (list1.size() != list2.size()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tfinal Iterator<T> iter1 = list1.iterator();\n+\t\tfinal Iterator<U> iter2 = list2.iterator();\n+\t\twhile (iter1.hasNext() && iter2.hasNext()) {\n+\t\t\tfinal T item1 = iter1.next();\n+\t\t\tfinal U item2 = iter2.next();\n+\t\t\tif (!comparer.test(item1, item2)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn !iter1.hasNext() && !iter2.hasNext();\n+\t}\n+\n \tpublic static <T, R> List<R> map(Collection<T> list, Function<T, R> mapFunc) {\n \t\tif (list == null || list.isEmpty()) {\n \t\t\treturn Collections.emptyList();\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inline/TestSyntheticClassInline.java b/jadx-core/src/test/java/jadx/tests/integration/inline/TestSyntheticClassInline.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inline/TestSyntheticClassInline.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inline/TestSyntheticClassInline.java\n@@ -0,0 +1,23 @@\n+package jadx.tests.integration.inline;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestSyntheticClassInline extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tList<ClassNode> classes = loadFromSmaliFiles();\n+\t\tassertThat(searchCls(classes, \"inline.A\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"static Supplier<Long> test(final long x1, final long x2) {\")\n+\t\t\t\t.containsOne(\"return new Supplier() {\")\n+\t\t\t\t.containsOne(\"return A.lambda$test$0(x1, x2);\");\n+\t}\n+}",
    "output": "Fix improve inlining synthetic accessors"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/ProcessClass.java b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n--- a/jadx-core/src/main/java/jadx/core/ProcessClass.java\n+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n@@ -125,6 +125,22 @@ public ICodeInfo generateCode(ClassNode cls) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Load and process class without its deps\n+\t */\n+\tpublic void forceProcess(ClassNode cls) {\n+\t\tClassNode topParentClass = cls.getTopParentClass();\n+\t\tif (topParentClass != cls) {\n+\t\t\tforceProcess(topParentClass);\n+\t\t\treturn;\n+\t\t}\n+\t\ttry {\n+\t\t\tprocess(cls, false);\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow new JadxRuntimeException(\"Failed to process class: \" + cls.getFullName(), e);\n+\t\t}\n+\t}\n+\n \tpublic void initPasses(RootNode root) {\n \t\tfor (IDexTreeVisitor pass : passes) {\n \t\t\ttry {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java b/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java\n@@ -59,12 +59,17 @@ private void processInvokeInsn(MethodNode mth, BlockNode block, InvokeNode insn)\n \t\t}\n \t\tMethodNode callMth = (MethodNode) callMthDetails;\n \t\ttry {\n-\t\t\t// TODO: sort inner classes process order by dependencies!\n \t\t\tMethodInlineAttr mia = MarkMethodsForInline.process(callMth);\n \t\t\tif (mia == null) {\n-\t\t\t\t// method not yet loaded => will retry at codegen stage\n-\t\t\t\tcallMth.getParentClass().reloadAtCodegenStage();\n-\t\t\t\treturn;\n+\t\t\t\t// method is not yet loaded => force process\n+\t\t\t\tmth.addDebugComment(\"Class process forced to load method for inline: \" + callMth);\n+\t\t\t\tmth.root().getProcessClasses().forceProcess(callMth.getParentClass());\n+\t\t\t\t// run check again\n+\t\t\t\tmia = MarkMethodsForInline.process(callMth);\n+\t\t\t\tif (mia == null) {\n+\t\t\t\t\tmth.addWarnComment(\"Failed to check method for inline after forced process\" + callMth);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n \t\t\t}\n \t\t\tif (mia.notNeeded()) {\n \t\t\t\treturn;",
    "output": "Fix workaround to make method inline deterministic"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n@@ -90,7 +90,6 @@ public enum AFlag {\n \n \tREQUEST_IF_REGION_OPTIMIZE, // run if region visitor again\n \tREQUEST_CODE_SHRINK,\n-\tRERUN_SSA_TRANSFORM,\n \n \tMETHOD_CANDIDATE_FOR_INLINE,\n \tUSE_LINES_HINTS, // source lines info in methods can be trusted\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java\n@@ -43,6 +43,9 @@ public void bindArg(RegisterArg arg, BlockNode pred) {\n \t\tif (blockBinds.contains(pred)) {\n \t\t\tthrow new JadxRuntimeException(\"Duplicate predecessors in PHI insn: \" + pred + \", \" + this);\n \t\t}\n+\t\tif (pred == null) {\n+\t\t\tthrow new JadxRuntimeException(\"Null bind block in PHI insn: \" + this);\n+\t\t}\n \t\tsuper.addArg(arg);\n \t\tblockBinds.add(pred);\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n@@ -6,6 +6,7 @@\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.InvokeNode;\n+import jadx.core.dex.instructions.PhiInsn;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.LiteralArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n@@ -18,6 +19,7 @@\n import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;\n import jadx.core.utils.BlockUtils;\n import jadx.core.utils.InsnRemover;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n \n @JadxVisitor(\n \t\tname = \"ConstructorVisitor\",\n@@ -34,9 +36,6 @@ public void visit(MethodNode mth) {\n \t\tif (replaceInvoke(mth)) {\n \t\t\tMoveInlineVisitor.moveInline(mth);\n \t\t}\n-\t\tif (mth.contains(AFlag.RERUN_SSA_TRANSFORM)) {\n-\t\t\tSSATransform.rerun(mth);\n-\t\t}\n \t}\n \n \tprivate static boolean replaceInvoke(MethodNode mth) {\n@@ -75,7 +74,8 @@ private static boolean processInvoke(MethodNode mth, BlockNode block, int indexI\n \t\t\tif (assignInsn != null) {\n \t\t\t\tif (assignInsn.getType() == InsnType.CONSTRUCTOR) {\n \t\t\t\t\t// arg already used in another constructor instruction\n-\t\t\t\t\tmth.add(AFlag.RERUN_SSA_TRANSFORM);\n+\t\t\t\t\t// insert new PHI insn to merge these branched constructors results\n+\t\t\t\t\tinstanceArg = insertPhiInsn(mth, block, instanceArg, ((ConstructorInsn) assignInsn));\n \t\t\t\t} else {\n \t\t\t\t\tInsnNode newInstInsn = removeAssignChain(mth, assignInsn, remover, InsnType.NEW_INSTANCE);\n \t\t\t\t\tif (newInstInsn != null) {\n@@ -99,6 +99,31 @@ private static boolean processInvoke(MethodNode mth, BlockNode block, int indexI\n \t\treturn true;\n \t}\n \n+\tprivate static RegisterArg insertPhiInsn(MethodNode mth, BlockNode curBlock,\n+\t\t\tRegisterArg instArg, ConstructorInsn otherCtr) {\n+\t\tBlockNode otherBlock = BlockUtils.getBlockByInsn(mth, otherCtr);\n+\t\tif (otherBlock == null) {\n+\t\t\tthrow new JadxRuntimeException(\"Block not found by insn: \" + otherCtr);\n+\t\t}\n+\t\tBlockNode crossBlock = BlockUtils.getPathCross(mth, curBlock, otherBlock);\n+\t\tif (crossBlock == null) {\n+\t\t\tthrow new JadxRuntimeException(\"Path cross not found for blocks: \" + curBlock + \" and \" + otherBlock);\n+\t\t}\n+\t\tRegisterArg newResArg = instArg.duplicateWithNewSSAVar(mth);\n+\t\tRegisterArg useArg = otherCtr.getResult();\n+\t\tRegisterArg otherResArg = useArg.duplicateWithNewSSAVar(mth);\n+\n+\t\tPhiInsn phiInsn = SSATransform.addPhi(mth, crossBlock, useArg.getRegNum());\n+\t\tphiInsn.setResult(useArg.duplicate());\n+\t\tphiInsn.bindArg(newResArg.duplicate(), BlockUtils.getPrevBlockOnPath(crossBlock, curBlock));\n+\t\tphiInsn.bindArg(otherResArg.duplicate(), BlockUtils.getPrevBlockOnPath(crossBlock, otherBlock));\n+\t\tphiInsn.rebindArgs();\n+\n+\t\totherCtr.setResult(otherResArg.duplicate());\n+\t\totherCtr.rebindArgs();\n+\t\treturn newResArg;\n+\t}\n+\n \tprivate static boolean canRemoveConstructor(MethodNode mth, ConstructorInsn co) {\n \t\tClassNode parentClass = mth.getParentClass();\n \t\tif (co.isSuper() && (co.getArgsCount() == 0 || parentClass.isEnum())) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n@@ -44,12 +44,6 @@ public void visit(MethodNode mth) throws JadxException {\n \t\tprocess(mth);\n \t}\n \n-\tpublic static void rerun(MethodNode mth) {\n-\t\tmth.remove(AFlag.RERUN_SSA_TRANSFORM);\n-\t\tresetSSAVars(mth);\n-\t\tprocess(mth);\n-\t}\n-\n \tprivate static void process(MethodNode mth) {\n \t\tif (!mth.getSVars().isEmpty()) {\n \t\t\treturn;\n@@ -87,7 +81,8 @@ private static void placePhi(MethodNode mth, int regNum, LiveVarAnalysis la) {\n \t\t\tfor (int id = domFrontier.nextSetBit(0); id >= 0; id = domFrontier.nextSetBit(id + 1)) {\n \t\t\t\tif (!hasPhi.get(id) && la.isLive(id, regNum)) {\n \t\t\t\t\tBlockNode df = blocks.get(id);\n-\t\t\t\t\taddPhi(mth, df, regNum);\n+\t\t\t\t\tPhiInsn phiInsn = addPhi(mth, df, regNum);\n+\t\t\t\t\tdf.getInstructions().add(0, phiInsn);\n \t\t\t\t\thasPhi.set(id);\n \t\t\t\t\tif (!processed.get(id)) {\n \t\t\t\t\t\tprocessed.set(id);\n@@ -121,7 +116,6 @@ public static PhiInsn addPhi(MethodNode mth, BlockNode block, int regNum) {\n \t\tPhiInsn phiInsn = new PhiInsn(regNum, size);\n \t\tphiList.getList().add(phiInsn);\n \t\tphiInsn.setOffset(block.getStartOffset());\n-\t\tblock.getInstructions().add(0, phiInsn);\n \t\treturn phiInsn;\n \t}\n \n@@ -457,17 +451,6 @@ private static void hidePhiInsns(MethodNode mth) {\n \t\t}\n \t}\n \n-\tprivate static void resetSSAVars(MethodNode mth) {\n-\t\tfor (SSAVar ssaVar : mth.getSVars()) {\n-\t\t\tssaVar.getAssign().resetSSAVar();\n-\t\t\tssaVar.getUseList().forEach(RegisterArg::resetSSAVar);\n-\t\t}\n-\t\tfor (BlockNode block : mth.getBasicBlocks()) {\n-\t\t\tblock.remove(AType.PHI_LIST);\n-\t\t}\n-\t\tmth.getSVars().clear();\n-\t}\n-\n \tprivate static void removeUnusedInvokeResults(MethodNode mth) {\n \t\tIterator<SSAVar> it = mth.getSVars().iterator();\n \t\twhile (it.hasNext()) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -434,6 +434,23 @@ public static BlockNode getNextBlockToPath(BlockNode block, BlockNode pathEnd) {\n \t\treturn null;\n \t}\n \n+\t/**\n+\t * Return predecessor on path from 'pathStart' block\n+\t */\n+\tpublic static @Nullable BlockNode getPrevBlockOnPath(BlockNode block, BlockNode pathStart) {\n+\t\tList<BlockNode> preds = block.getPredecessors();\n+\t\tif (preds.contains(pathStart)) {\n+\t\t\treturn pathStart;\n+\t\t}\n+\t\tSet<BlockNode> path = getAllPathsBlocks(pathStart, block);\n+\t\tfor (BlockNode p : preds) {\n+\t\t\tif (path.contains(p)) {\n+\t\t\t\treturn p;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \t/**\n \t * Visit blocks on any path from start to end.\n \t * Only one path will be visited!",
    "output": "Fix don't rerun SSA transform in ConstructorVisitor"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n@@ -92,7 +92,6 @@ public AbstractCodeArea(ContentPanel contentPanel, JNode node) {\n \n \t\tJadxSettings settings = contentPanel.getTabbedPane().getMainWindow().getSettings();\n \t\tsetLineWrap(settings.isCodeAreaLineWrap());\n-\t\taddWrapLineMenuAction(settings);\n \n \t\tZoomActions.register(this, settings, this::loadSettings);\n \n@@ -135,6 +134,7 @@ protected JPopupMenu createPopupMenu() {\n \t\t\tmenu.add(createPopupMenuItem(getAction(SELECT_ALL_ACTION)));\n \t\t}\n \t\tappendFoldingMenu(menu);\n+\t\tappendWrapLineMenu(menu);\n \t\treturn menu;\n \t}\n \n@@ -146,8 +146,8 @@ protected void appendFoldingMenu(JPopupMenu popup) {\n \t\t}\n \t}\n \n-\tprivate void addWrapLineMenuAction(JadxSettings settings) {\n-\t\tJPopupMenu popupMenu = getPopupMenu();\n+\tprivate void appendWrapLineMenu(JPopupMenu popupMenu) {\n+\t\tJadxSettings settings = contentPanel.getTabbedPane().getMainWindow().getSettings();\n \t\tpopupMenu.addSeparator();\n \t\tJCheckBoxMenuItem wrapItem = new JCheckBoxMenuItem(NLS.str(\"popup.line_wrap\"), getLineWrap());\n \t\twrapItem.setAction(new AbstractAction(NLS.str(\"popup.line_wrap\")) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n@@ -6,6 +6,7 @@\n import java.awt.event.MouseEvent;\n import java.util.Objects;\n \n+import javax.swing.JPopupMenu;\n import javax.swing.event.PopupMenuEvent;\n \n import org.fife.ui.rsyntaxtextarea.RSyntaxDocument;\n@@ -53,7 +54,6 @@ public final class CodeArea extends AbstractCodeArea {\n \t\tboolean isJavaCode = node instanceof JClass;\n \t\tif (isJavaCode) {\n \t\t\t((RSyntaxDocument) getDocument()).setSyntaxStyle(new JadxTokenMaker(this));\n-\t\t\taddMenuItems();\n \t\t}\n \n \t\tif (node instanceof JResource && node.makeString().endsWith(\".json\")) {\n@@ -118,9 +118,18 @@ public void refresh() {\n \t\tsetText(getCodeInfo().getCodeStr());\n \t}\n \n-\tprivate void addMenuItems() {\n+\t@Override\n+\tprotected JPopupMenu createPopupMenu() {\n+\t\tJPopupMenu popup = super.createPopupMenu();\n+\t\tif (node instanceof JClass) {\n+\t\t\tappendCodeMenuItems(popup);\n+\t\t}\n+\t\treturn popup;\n+\t}\n+\n+\tprivate void appendCodeMenuItems(JPopupMenu popupMenu) {\n \t\tShortcutsController shortcutsController = getMainWindow().getShortcutsController();\n-\t\tJNodePopupBuilder popup = new JNodePopupBuilder(this, getPopupMenu(), shortcutsController);\n+\t\tJNodePopupBuilder popup = new JNodePopupBuilder(this, popupMenu, shortcutsController);\n \t\tpopup.addSeparator();\n \t\tpopup.add(new FindUsageAction(this));\n \t\tpopup.add(new GoToDeclarationAction(this));\n@@ -133,7 +142,7 @@ private void addMenuItems() {\n \t\tgetMainWindow().getWrapper().getGuiPluginsContext().appendPopupMenus(this, popup);\n \n \t\t// move caret on mouse right button click\n-\t\tpopup.getMenu().addPopupMenuListener(new DefaultPopupMenuListener() {\n+\t\tpopupMenu.addPopupMenuListener(new DefaultPopupMenuListener() {\n \t\t\t@Override\n \t\t\tpublic void popupMenuWillBecomeVisible(PopupMenuEvent e) {\n \t\t\t\tCodeArea codeArea = CodeArea.this;",
    "output": "Fix show folding actions in code popup menu"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n@@ -3,6 +3,7 @@\n import jadx.api.plugins.input.data.AccessFlags;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.attributes.nodes.MethodInlineAttr;\n import jadx.core.dex.attributes.nodes.MethodOverrideAttr;\n import jadx.core.dex.attributes.nodes.NotificationAttrNode;\n import jadx.core.dex.info.AccessInfo;\n@@ -86,8 +87,12 @@ private int fixClassVisibility(ClassNode cls) {\n \t\tif (!accessFlags.isPublic()) {\n \t\t\t// if class is used in inlinable method => make it public\n \t\t\tfor (MethodNode useMth : cls.getUseInMth()) {\n-\t\t\t\tboolean canInline = useMth.contains(AFlag.METHOD_CANDIDATE_FOR_INLINE) || useMth.contains(AType.METHOD_INLINE);\n-\t\t\t\tif (canInline && !useMth.getUseIn().isEmpty()) {\n+\t\t\t\tMethodInlineAttr inlineAttr = useMth.get(AType.METHOD_INLINE);\n+\t\t\t\tboolean isInline = inlineAttr != null && !inlineAttr.notNeeded();\n+\t\t\t\tboolean isCandidateForInline = useMth.contains(AFlag.METHOD_CANDIDATE_FOR_INLINE);\n+\n+\t\t\t\tboolean mostLikelyInline = isInline || isCandidateForInline;\n+\t\t\t\tif (mostLikelyInline && !useMth.getUseIn().isEmpty()) {\n \t\t\t\t\treturn AccessFlags.PUBLIC;\n \t\t\t\t}\n \t\t\t}",
    "output": "Fix improve checking if methods are inline for FixAccessModifiers"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n@@ -6,6 +6,7 @@\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.stream.Collectors;\n \n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n@@ -292,10 +293,19 @@ public String getDetailedVarInfo(MethodNode mth) {\n \t\tStringBuilder sb = new StringBuilder();\n \t\tsb.append('r').append(regNum).append('v').append(version);\n \t\tif (!names.isEmpty()) {\n-\t\t\tsb.append(\", names: \").append(names);\n+\t\t\tString orderedNames = names.stream()\n+\t\t\t\t\t.sorted()\n+\t\t\t\t\t.collect(Collectors.joining(\", \", \"[\", \"]\"));\n+\n+\t\t\tsb.append(\", names: \").append(orderedNames);\n \t\t}\n \t\tif (!types.isEmpty()) {\n-\t\t\tsb.append(\", types: \").append(types);\n+\t\t\tString orderedTypes = types.stream()\n+\t\t\t\t\t.map(String::valueOf)\n+\t\t\t\t\t.sorted()\n+\t\t\t\t\t.collect(Collectors.joining(\", \", \"[\", \"]\"));\n+\n+\t\t\tsb.append(\", types: \").append(orderedTypes);\n \t\t}\n \t\treturn sb.toString();\n \t}",
    "output": "Fix make detailed var info deterministic"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/JadxEventQueue.java b/jadx-gui/src/main/java/jadx/gui/ui/JadxEventQueue.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/JadxEventQueue.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/JadxEventQueue.java\n@@ -0,0 +1,54 @@\n+package jadx.gui.ui;\n+\n+import java.awt.AWTEvent;\n+import java.awt.EventQueue;\n+import java.awt.Toolkit;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseWheelEvent;\n+\n+import jadx.gui.utils.UiUtils;\n+\n+public class JadxEventQueue extends EventQueue {\n+\n+\tprivate static final boolean IS_X_TOOLKIT = UiUtils.isXToolkit();\n+\n+\tpublic static void register() {\n+\t\tif (IS_X_TOOLKIT) {\n+\t\t\tToolkit.getDefaultToolkit().getSystemEventQueue().push(new JadxEventQueue());\n+\t\t}\n+\t}\n+\n+\tprivate JadxEventQueue() {\n+\t}\n+\n+\t@Override\n+\tprotected void dispatchEvent(AWTEvent event) {\n+\t\tAWTEvent mappedEvent = mapEvent(event);\n+\t\tsuper.dispatchEvent(mappedEvent);\n+\t}\n+\n+\tprivate static AWTEvent mapEvent(AWTEvent event) {\n+\t\tif (IS_X_TOOLKIT && event instanceof MouseEvent && ((MouseEvent) event).getButton() > 3) {\n+\t\t\treturn mapXWindowMouseEvent((MouseEvent) event);\n+\t\t}\n+\t\treturn event;\n+\t}\n+\n+\t@SuppressWarnings({ \"deprecation\", \"MagicConstant\" })\n+\tprivate static AWTEvent mapXWindowMouseEvent(MouseEvent src) {\n+\t\tif (src.getButton() < 6) {\n+\t\t\t// buttons 4-5 come from touchpad, they must be converted to horizontal scrolling events\n+\t\t\tint modifiers = src.getModifiers() | InputEvent.SHIFT_DOWN_MASK;\n+\t\t\treturn new MouseWheelEvent(src.getComponent(), MouseEvent.MOUSE_WHEEL, src.getWhen(), modifiers,\n+\t\t\t\t\tsrc.getX(), src.getY(), 0, false, MouseWheelEvent.WHEEL_UNIT_SCROLL,\n+\t\t\t\t\tsrc.getClickCount(), src.getButton() == 4 ? -1 : 1);\n+\t\t} else {\n+\t\t\t// Here we \"shift\" events with buttons `6` and `7` to similar events with buttons 4 and 5\n+\t\t\t// See `java.awt.InputEvent#BUTTON_DOWN_MASK`, 1<<14 is the 4th physical button, 1<<15 is the 5th.\n+\t\t\tint modifiers = src.getModifiers() | (1 << (8 + src.getButton()));\n+\t\t\treturn new MouseEvent(src.getComponent(), src.getID(), src.getWhen(), modifiers,\n+\t\t\t\t\tsrc.getX(), src.getY(), 1, src.isPopupTrigger(), src.getButton() - 2);\n+\t\t}\n+\t}\n+}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -250,6 +250,7 @@ public MainWindow(JadxSettings settings) {\n \t\tthis.cacheManager = new CacheManager(settings);\n \t\tthis.shortcutsController = new ShortcutsController(settings);\n \n+\t\tJadxEventQueue.register();\n \t\tresetCache();\n \t\tFontUtils.registerBundledFonts();\n \t\tsetEditorTheme(settings.getEditorThemePath());\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/SystemInfo.java b/jadx-gui/src/main/java/jadx/gui/utils/SystemInfo.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/SystemInfo.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/SystemInfo.java\n@@ -17,6 +17,7 @@ public class SystemInfo {\n \tpublic static final boolean IS_WINDOWS = LOWER_OS_NAME.startsWith(\"windows\");\n \tpublic static final boolean IS_MAC = LOWER_OS_NAME.startsWith(\"mac\");\n \tpublic static final boolean IS_LINUX = LOWER_OS_NAME.startsWith(\"linux\");\n+\tpublic static final boolean IS_UNIX = !IS_WINDOWS;\n \n \tprivate SystemInfo() {\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n@@ -394,6 +394,12 @@ public static void notUiThreadGuard() {\n \t\t}\n \t}\n \n+\tpublic static boolean isXToolkit() {\n+\t\treturn SystemInfo.IS_UNIX\n+\t\t\t\t&& !SystemInfo.IS_MAC\n+\t\t\t\t&& \"sun.awt.X11.XToolkit\".equals(Toolkit.getDefaultToolkit().getClass().getName());\n+\t}\n+\n \t@TestOnly\n \tpublic static void debugTimer(int periodInSeconds, Runnable action) {\n \t\tif (!LOG.isDebugEnabled()) {",
    "output": "Fix horizontal scrolling in Linux"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java\n@@ -226,6 +226,10 @@ public boolean isReturnBlock() {\n \t\treturn contains(AFlag.RETURN);\n \t}\n \n+\tpublic boolean isMthExitBlock() {\n+\t\treturn contains(AFlag.MTH_EXIT_BLOCK);\n+\t}\n+\n \tpublic boolean isEmpty() {\n \t\treturn instructions.isEmpty();\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n@@ -627,7 +627,7 @@ private static void removeUnusedExcHandlers(MethodNode mth, List<TryCatchBlockAt\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tfor (TryCatchBlockAttr tcb : tryBlocks) {\n-\t\t\t\tif (tcb.getHandlers().contains(handlerBlock)) {\n+\t\t\t\tif (tcb.getHandlers().contains(eh)) {\n \t\t\t\t\tnotProcessed = false;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -445,8 +445,9 @@ private boolean canInsertBreak(BlockNode exit) {\n \t\tList<BlockNode> simplePath = BlockUtils.buildSimplePath(exit);\n \t\tif (!simplePath.isEmpty()) {\n \t\t\tBlockNode lastBlock = simplePath.get(simplePath.size() - 1);\n-\t\t\tif (lastBlock.contains(AFlag.RETURN)\n-\t\t\t\t\t|| lastBlock.getSuccessors().isEmpty()) {\n+\t\t\tif (lastBlock.isMthExitBlock()\n+\t\t\t\t\t|| lastBlock.isReturnBlock()\n+\t\t\t\t\t|| mth.isPreExitBlock(lastBlock)) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestUnreachableCatch2.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestUnreachableCatch2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestUnreachableCatch2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestUnreachableCatch2.java\n@@ -10,25 +10,24 @@\n import jadx.tests.api.SmaliTest;\n \n import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n-import static org.hamcrest.CoreMatchers.containsString;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n-@SuppressWarnings(\"CommentedOutCode\")\n public class TestUnreachableCatch2 extends SmaliTest {\n \n+\t@SuppressWarnings({ \"unused\", \"DataFlowIssue\" })\n \tpublic static class UnusedExceptionHandlers1 implements AutoCloseable {\n-\t\tpublic static void doSomething(final Object unused1, final Object[] array, final Object o1,\n+\t\tpublic static void test(final Object unused1, final Object[] array, final Object o1,\n \t\t\t\tfinal Object o2, final Object unused2) {\n \t\t\tfor (final Object item : array) {\n \t\t\t\tByteBuffer buffer = null;\n \t\t\t\ttry (final UnusedExceptionHandlers1 u = doSomething2(o1, \"\", o2)) {\n \t\t\t\t\ttry (final FileInputStream fis = new FileInputStream(u.getFilename())) {\n \t\t\t\t\t\tfinal FileChannel fileChannel = fis.getChannel();\n \t\t\t\t\t\tbuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, 42);\n-\t\t\t\t\t} catch (final IOException e) {\n+\t\t\t\t\t} catch (IOException e) {\n \t\t\t\t\t\t// ignore\n \t\t\t\t\t}\n-\t\t\t\t} catch (final IOException e) {\n+\t\t\t\t} catch (IOException e) {\n \t\t\t\t\t// ignore\n \t\t\t\t}\n \t\t\t}\n@@ -50,9 +49,12 @@ public void close() throws IOException {\n \n \t@Test\n \tpublic void test() {\n-\t\t// TODO: result code not compilable because of 'break' after 'throw'\n+\t\t// TODO: result code not compilable because 'try' block split into 2 block and 'fis' var become\n+\t\t// uninitialized\n \t\tdisableCompilation();\n-\t\tString code = getClassNode(UnusedExceptionHandlers1.class).getCode().toString();\n-\t\tassertThat(code, containsString(\"IOException\"));\n+\t\tassertThat(getClassNode(UnusedExceptionHandlers1.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"break;\")\n+\t\t\t\t.countString(2, \"} catch (IOException e\");\n \t}\n }",
    "output": "Fix improve exception handlers checks"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkManager.java b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkManager.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkManager.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkManager.java\n@@ -151,6 +151,7 @@ private void installQuark() {\n \t\tList<String> cmd = new ArrayList<>();\n \t\tcmd.add(getCommand(\"pip3\"));\n \t\tcmd.add(\"install\");\n+\t\tcmd.add(\"setuptools\");\n \t\tcmd.add(\"quark-engine\");\n \t\tcmd.add(\"--upgrade\");\n \t\ttry {\n@@ -213,6 +214,10 @@ private void runCommand(List<String> cmd) throws Exception {\n \t\t} finally {\n \t\t\tprocess.waitFor();\n \t\t}\n+\t\tif (process.exitValue() != 0) {\n+\t\t\tthrow new RuntimeException(\"Execution failed (exit code \" + process.exitValue() + \") - command \"\n+\t\t\t\t\t+ String.join(\" \", cmd) + \"\\nPlease see command log output what was going wrong.\");\n+\t\t}\n \t}\n \n \tprivate boolean checkCommand(String... cmd) {",
    "output": "Fix automated installation and check exit code of executed external commands"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/XposedAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/XposedAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/XposedAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/XposedAction.java\n@@ -1,201 +0,0 @@\n-package jadx.gui.ui.codearea;\n-\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.swing.JOptionPane;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import jadx.api.JavaClass;\n-import jadx.api.JavaField;\n-import jadx.api.JavaMethod;\n-import jadx.core.dex.instructions.args.ArgType;\n-import jadx.core.dex.nodes.MethodNode;\n-import jadx.core.utils.exceptions.JadxRuntimeException;\n-import jadx.gui.settings.XposedCodegenLanguage;\n-import jadx.gui.treemodel.JClass;\n-import jadx.gui.treemodel.JField;\n-import jadx.gui.treemodel.JMethod;\n-import jadx.gui.treemodel.JNode;\n-import jadx.gui.ui.action.ActionModel;\n-import jadx.gui.utils.NLS;\n-import jadx.gui.utils.UiUtils;\n-\n-public class XposedAction extends JNodeAction {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(XposedAction.class);\n-\tprivate static final long serialVersionUID = 2641585141624592578L;\n-\n-\tprivate static final Map<String, String> PRIMITIVE_TYPE_MAPPING = Map.of(\n-\t\t\t\"int\", \"Int\",\n-\t\t\t\"byte\", \"Byte\",\n-\t\t\t\"short\", \"Short\",\n-\t\t\t\"long\", \"Long\",\n-\t\t\t\"float\", \"Float\",\n-\t\t\t\"double\", \"Double\",\n-\t\t\t\"char\", \"Char\",\n-\t\t\t\"boolean\", \"Boolean\");\n-\n-\tpublic XposedAction(CodeArea codeArea) {\n-\t\tsuper(ActionModel.XPOSED_COPY, codeArea);\n-\t}\n-\n-\t@Override\n-\tpublic void runAction(JNode node) {\n-\t\ttry {\n-\t\t\tString xposedSnippet = generateXposedSnippet(node);\n-\t\t\tLOG.info(\"Xposed snippet:\\n{}\", xposedSnippet);\n-\t\t\tUiUtils.copyToClipboard(xposedSnippet);\n-\t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Failed to generate Xposed code snippet\", e);\n-\t\t\tJOptionPane.showMessageDialog(getCodeArea().getMainWindow(), e.getLocalizedMessage(), NLS.str(\"error_dialog.title\"),\n-\t\t\t\t\tJOptionPane.ERROR_MESSAGE);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic boolean isActionEnabled(JNode node) {\n-\t\treturn node instanceof JMethod || node instanceof JClass || node instanceof JField;\n-\t}\n-\n-\tprivate String generateXposedSnippet(JNode node) {\n-\t\tif (node instanceof JMethod) {\n-\t\t\treturn generateMethodSnippet((JMethod) node);\n-\t\t}\n-\t\tif (node instanceof JClass) {\n-\t\t\treturn generateClassSnippet((JClass) node);\n-\t\t}\n-\t\tif (node instanceof JField) {\n-\t\t\treturn generateFieldSnippet((JField) node);\n-\t\t}\n-\t\tthrow new JadxRuntimeException(\"Unsupported node type: \" + (node != null ? node.getClass() : \"null\"));\n-\t}\n-\n-\tprivate String generateMethodSnippet(JMethod jMth) {\n-\t\tJavaMethod javaMethod = jMth.getJavaMethod();\n-\t\tMethodNode mth = javaMethod.getMethodNode();\n-\t\tString methodName;\n-\t\tString xposedMethod;\n-\t\tif (mth.isConstructor()) {\n-\t\t\txposedMethod = \"findAndHookConstructor\";\n-\t\t\tmethodName = \"\";\n-\t\t} else {\n-\t\t\txposedMethod = \"findAndHookMethod\";\n-\t\t\tmethodName = \"\\\"\" + mth.getMethodInfo().getName() + \"\\\", \";\n-\t\t}\n-\t\tString rawClassName = javaMethod.getDeclaringClass().getRawName();\n-\t\tString javaXposedFormatStr =\n-\t\t\t\t\"XposedHelpers.%s(\\\"%s\\\", classLoader, %snew XC_MethodHook() {\\n\"\n-\t\t\t\t\t\t+ \"    @Override\\n\"\n-\t\t\t\t\t\t+ \"    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {\\n\"\n-\t\t\t\t\t\t+ \"        super.beforeHookedMethod(param);\\n\"\n-\t\t\t\t\t\t+ \"    }\\n\"\n-\t\t\t\t\t\t+ \"    @Override\\n\"\n-\t\t\t\t\t\t+ \"    protected void afterHookedMethod(MethodHookParam param) throws Throwable {\\n\"\n-\t\t\t\t\t\t+ \"        super.afterHookedMethod(param);\\n\"\n-\t\t\t\t\t\t+ \"    }\\n\"\n-\t\t\t\t\t\t+ \"});\";\n-\t\tString kotlinXposedFormatStr =\n-\t\t\t\t\"XposedHelpers.%s(\\\"%s\\\", classLoader, %sobject : XC_MethodHook() {\\n\"\n-\t\t\t\t\t\t+ \"    override fun beforeHookedMethod(param: MethodHookParam) {\\n\"\n-\t\t\t\t\t\t+ \"        super.beforeHookedMethod(param)\\n\"\n-\t\t\t\t\t\t+ \"    }\\n\"\n-\t\t\t\t\t\t+ \"\\n\"\n-\t\t\t\t\t\t+ \"    override fun afterHookedMethod(param: MethodHookParam) {\\n\"\n-\t\t\t\t\t\t+ \"        super.afterHookedMethod(param)\\n\"\n-\t\t\t\t\t\t+ \"    }\\n\"\n-\t\t\t\t\t\t+ \"})\";\n-\n-\t\tXposedCodegenLanguage language = getLanguage();\n-\t\tString xposedFormatStr;\n-\t\tswitch (language) {\n-\t\t\tcase JAVA:\n-\t\t\t\txposedFormatStr = javaXposedFormatStr;\n-\t\t\t\tbreak;\n-\t\t\tcase KOTLIN:\n-\t\t\t\txposedFormatStr = kotlinXposedFormatStr;\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new JadxRuntimeException(\"Invalid Xposed code generation language: \" + language);\n-\t\t}\n-\n-\t\tList<ArgType> mthArgs = mth.getArgTypes();\n-\t\tif (mthArgs.isEmpty()) {\n-\t\t\treturn String.format(xposedFormatStr, xposedMethod, rawClassName, methodName);\n-\t\t}\n-\t\tString params = mthArgs.stream()\n-\t\t\t\t.map(type -> fixTypeContent(type) + \".class, \")\n-\t\t\t\t.collect(Collectors.joining());\n-\t\treturn String.format(xposedFormatStr, xposedMethod, rawClassName, methodName + params);\n-\t}\n-\n-\tprivate String fixTypeContent(ArgType type) {\n-\t\tif (type.isGeneric()) {\n-\t\t\treturn type.getObject();\n-\t\t} else if (type.isGenericType() && type.isObject() && type.isTypeKnown()) {\n-\t\t\treturn \"Object\";\n-\t\t}\n-\t\treturn type.toString();\n-\t}\n-\n-\tprivate String generateClassSnippet(JClass jc) {\n-\t\tJavaClass javaClass = jc.getCls();\n-\t\tString rawClassName = javaClass.getRawName();\n-\t\tString shortClassName = javaClass.getName();\n-\n-\t\tString javaXposedFormatStr =\n-\t\t\t\t\"ClassLoader classLoader = lpparam.classLoader;\\n\"\n-\t\t\t\t\t\t+ \"Class<?> %sClass = classLoader.loadClass(\\\"%s\\\");\";\n-\t\tString kotlinXposedFormatStr =\n-\t\t\t\t\"val classLoader = lpparam.classLoader\\n\"\n-\t\t\t\t\t\t+ \"val %sClass = classLoader.loadClass(\\\"%s\\\")\";\n-\n-\t\tXposedCodegenLanguage language = getLanguage();\n-\t\tString xposedFormatStr;\n-\t\tswitch (language) {\n-\t\t\tcase JAVA:\n-\t\t\t\txposedFormatStr = javaXposedFormatStr;\n-\t\t\t\tbreak;\n-\t\t\tcase KOTLIN:\n-\t\t\t\txposedFormatStr = kotlinXposedFormatStr;\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new JadxRuntimeException(\"Invalid Xposed code generation language: \" + language);\n-\t\t}\n-\n-\t\treturn String.format(xposedFormatStr, shortClassName, rawClassName);\n-\t}\n-\n-\tprivate String generateFieldSnippet(JField jf) {\n-\t\tJavaField javaField = jf.getJavaField();\n-\t\tString isStatic = javaField.getAccessFlags().isStatic() ? \"Static\" : \"\";\n-\t\tString type = PRIMITIVE_TYPE_MAPPING.getOrDefault(javaField.getFieldNode().getType().toString(), \"Object\");\n-\t\tString xposedMethod = \"XposedHelpers.get\" + isStatic + type + \"Field\";\n-\n-\t\tString javaXposedFormatStr =\n-\t\t\t\t\"%s(/*runtimeObject*/, \\\"%s\\\");\";\n-\t\tString kotlinXposedFormatStr =\n-\t\t\t\t\"%s(/*runtimeObject*/, \\\"%s\\\")\";\n-\n-\t\tXposedCodegenLanguage language = getLanguage();\n-\t\tString xposedFormatStr;\n-\t\tswitch (language) {\n-\t\t\tcase JAVA:\n-\t\t\t\txposedFormatStr = javaXposedFormatStr;\n-\t\t\t\tbreak;\n-\t\t\tcase KOTLIN:\n-\t\t\t\txposedFormatStr = kotlinXposedFormatStr;\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tthrow new JadxRuntimeException(\"Invalid Xposed code generation language: \" + language);\n-\t\t}\n-\n-\t\treturn String.format(xposedFormatStr, xposedMethod, javaField.getFieldNode().getFieldInfo().getName());\n-\t}\n-\n-\tprivate XposedCodegenLanguage getLanguage() {\n-\t\treturn getCodeArea().getMainWindow().getSettings().getXposedCodegenLanguage();\n-\t}\n-}",
    "output": "Fix Xposed args code generation"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -265,9 +265,10 @@ private void parseElement() throws IOException {\n \t\t\tdie(\"startNS's attributeStart is not 0x14\");\n \t\t}\n \t\tint attributeSize = is.readInt16();\n-\t\tif (attributeSize != 0x14) {\n-\t\t\tdie(\"startNS's attributeSize is not 0x14\");\n+\t\tif (attributeSize < 0x14) {\n+\t\t\tdie(\"startNS's attributeSize is less than 0x14\");\n \t\t}\n+\n \t\tint attributeCount = is.readInt16();\n \t\tint idIndex = is.readInt16();\n \t\tint classIndex = is.readInt16();\n@@ -289,22 +290,24 @@ private void parseElement() throws IOException {\n \t\tSet<String> attrCache = new HashSet<>();\n \t\tboolean attrNewLine = attributeCount != 1 && this.attrNewLine;\n \t\tfor (int i = 0; i < attributeCount; i++) {\n-\t\t\tparseAttribute(i, attrNewLine, attrCache);\n+\t\t\tparseAttribute(i, attrNewLine, attrCache, attributeSize);\n \t\t}\n \t\tlong endPos = is.getPos();\n \t\tif (endPos - startPos + 0x4 < elementSize) {\n \t\t\tis.skip(elementSize - (endPos - startPos + 0x4));\n \t\t}\n \t}\n \n-\tprivate void parseAttribute(int i, boolean newLine, Set<String> attrCache) throws IOException {\n+\tprivate void parseAttribute(int i, boolean newLine, Set<String> attrCache, int attributeSize) throws IOException {\n \t\tint attributeNS = is.readInt32();\n \t\tint attributeName = is.readInt32();\n \t\tint attributeRawValue = is.readInt32();\n \t\tis.skip(3);\n \t\tint attrValDataType = is.readInt8();\n \t\tint attrValData = is.readInt32();\n \n+\t\tis.skip(attributeSize - 0x14);\n+\n \t\tString shortNsName = null;\n \t\tif (attributeNS != -1) {\n \t\t\tshortNsName = getAttributeNS(attributeNS, newLine);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLStrings.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLStrings.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLStrings.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLStrings.java\n@@ -7,6 +7,7 @@\n import java.util.Map;\n \n public class BinaryXMLStrings {\n+\tpublic static final String INVALID_STRING_PLACEHOLDER = \"⟨STRING_DECODE_ERROR⟩\";\n \tprivate final int stringCount;\n \n \tprivate final long stringsStart;\n@@ -40,6 +41,10 @@ public String get(int id) {\n \t\t\treturn cached;\n \t\t}\n \n+\t\tif (id * 4 >= buffer.limit() - 3) {\n+\t\t\treturn INVALID_STRING_PLACEHOLDER;\n+\t\t}\n+\n \t\tlong offset = stringsStart + buffer.getInt(id * 4);\n \t\tString extracted;\n \t\tif (isUtf8) {\n@@ -63,7 +68,7 @@ public int size() {\n \n \tprivate static String extractString8(byte[] strArray, int offset) {\n \t\tif (offset >= strArray.length) {\n-\t\t\treturn \"STRING_DECODE_ERROR\";\n+\t\t\treturn INVALID_STRING_PLACEHOLDER;\n \t\t}\n \t\tint start = offset + skipStrLen8(strArray, offset);\n \t\tint len = strArray[start++];\n@@ -78,6 +83,10 @@ private static String extractString8(byte[] strArray, int offset) {\n \t}\n \n \tprivate static String extractString16(byte[] strArray, int offset) {\n+\t\tif (offset + 2 >= strArray.length) {\n+\t\t\treturn INVALID_STRING_PLACEHOLDER;\n+\t\t}\n+\n \t\tint len = strArray.length;\n \t\tint start = offset + skipStrLen16(strArray, offset);\n \t\tint end = start;",
    "output": "Fix allow for non-standard attributes sizes and avoid index exceptions when decoding some strings More lenient AXML parsing: allow for non-standard attributes sizes and avoid index exceptions when decoding some strings * The attributes size of an XML element is now accounted for. This size must be at least 20 (0x14) bytes but can be greater. Extra bytes are just skipped. When decoding a string, if such decoding is impossible a placeholder string is returned instead of throwing an exception. This is necessary because some malware purposely add android:tag attributes with invalid string index to throw parsers off. They also employ non-standard attribute sizes. * Minor code restyling --------- Co-authored-by: qfalconer <knm241@gmail.com>"
  },
  {
    "input": "diff --git a/jadx-commons/jadx-app-commons/src/main/java/jadx/commons/app/JadxCommonFiles.java b/jadx-commons/jadx-app-commons/src/main/java/jadx/commons/app/JadxCommonFiles.java\n--- a/jadx-commons/jadx-app-commons/src/main/java/jadx/commons/app/JadxCommonFiles.java\n+++ b/jadx-commons/jadx-app-commons/src/main/java/jadx/commons/app/JadxCommonFiles.java\n@@ -3,6 +3,7 @@\n import java.io.IOException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.util.function.Function;\n \n import org.jetbrains.annotations.Nullable;\n \n@@ -35,20 +36,20 @@ private static final class DirsLoader {\n \n \t\tpublic void init() {\n \t\t\ttry {\n-\t\t\t\tconfigDir = loadEnvDir(\"JADX_CONFIG_DIR\");\n-\t\t\t\tcacheDir = loadEnvDir(\"JADX_CACHE_DIR\");\n+\t\t\t\tconfigDir = loadEnvDir(\"JADX_CONFIG_DIR\", pd -> pd.configDir);\n+\t\t\t\tcacheDir = loadEnvDir(\"JADX_CACHE_DIR\", pd -> pd.cacheDir);\n \t\t\t} catch (Exception e) {\n \t\t\t\tthrow new RuntimeException(\"Failed to init common directories\", e);\n \t\t\t}\n \t\t}\n \n-\t\tprivate Path loadEnvDir(String envVar) throws IOException {\n+\t\tprivate Path loadEnvDir(String envVar, Function<ProjectDirectories, String> dirFunc) throws IOException {\n \t\t\tString envDir = JadxCommonEnv.get(envVar, null);\n \t\t\tString dirStr;\n \t\t\tif (envDir != null) {\n \t\t\t\tdirStr = envDir;\n \t\t\t} else {\n-\t\t\t\tdirStr = loadDirs().configDir;\n+\t\t\t\tdirStr = dirFunc.apply(loadDirs());\n \t\t\t}\n \t\t\tPath path = Path.of(dirStr).toAbsolutePath();\n \t\t\tFiles.createDirectories(path);",
    "output": "Fix config dir was used instead cache dir"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java\n@@ -13,7 +13,6 @@\n import javax.swing.JFileChooser;\n import javax.swing.JOptionPane;\n import javax.swing.UIManager;\n-import javax.swing.filechooser.FileNameExtensionFilter;\n \n import jadx.api.plugins.utils.CommonFileUtils;\n import jadx.core.utils.Utils;\n@@ -44,7 +43,7 @@ public List<Path> showDialog() {\n \t\tList<String> fileExtList = data.getFileExtList();\n \t\tif (Utils.notEmpty(fileExtList)) {\n \t\t\tString description = NLS.str(\"file_dialog.supported_files\") + \": (\" + Utils.listToString(fileExtList) + ')';\n-\t\t\tsetFileFilter(new FileNameExtensionFilter(description, fileExtList.toArray(new String[0])));\n+\t\t\tsetFileFilter(new FileNameMultiExtensionFilter(description, fileExtList.toArray(new String[0])));\n \t\t}\n \t\tif (data.getSelectedFile() != null) {\n \t\t\tsetSelectedFile(data.getSelectedFile().toFile());\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/FileNameMultiExtensionFilter.java b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/FileNameMultiExtensionFilter.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/FileNameMultiExtensionFilter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/FileNameMultiExtensionFilter.java\n@@ -0,0 +1,42 @@\n+package jadx.gui.ui.filedialog;\n+\n+import java.io.File;\n+\n+import javax.swing.filechooser.FileFilter;\n+import javax.swing.filechooser.FileNameExtensionFilter;\n+\n+/**\n+ * Custom file filter for filtering files with multiple extensions.\n+ * It overcomes the limitation of {@link FileNameExtensionFilter},\n+ * which treats only the last file extension split by dots as the\n+ * file extension, and does not support multiple extensions such as\n+ * {@code .jadx.kts}.\n+ */\n+class FileNameMultiExtensionFilter extends FileFilter {\n+\tprivate final FileNameExtensionFilter delegate;\n+\tprivate final String[] extensions;\n+\n+\tpublic FileNameMultiExtensionFilter(String description, String... extensions) {\n+\t\tthis.delegate = new FileNameExtensionFilter(description, extensions[0]);\n+\t\tthis.extensions = extensions;\n+\t}\n+\n+\t@Override\n+\tpublic boolean accept(File file) {\n+\t\tif (file.isDirectory()) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tString fileName = file.getName();\n+\t\tfor (String extension : extensions) {\n+\t\t\tif (fileName.endsWith(extension)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic String getDescription() {\n+\t\treturn delegate.getDescription();\n+\t}\n+}",
    "output": "Fix support filtering files with multiple extensions in file dialog"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/HexArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/HexArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/HexArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/HexArea.java\n@@ -15,7 +15,10 @@\n import org.slf4j.LoggerFactory;\n \n import jadx.api.ICodeInfo;\n+import jadx.api.ResourcesLoader;\n+import jadx.core.utils.exceptions.JadxException;\n import jadx.gui.treemodel.JNode;\n+import jadx.gui.treemodel.JResource;\n import jadx.gui.ui.panel.ContentPanel;\n import jadx.gui.utils.UiUtils;\n \n@@ -48,7 +51,18 @@ public HexArea(ContentPanel contentPanel, JNode node) {\n \n \t@Override\n \tpublic void load() {\n-\t\tbyte[] bytes = binaryNode.getCodeInfo().getCodeStr().getBytes(StandardCharsets.UTF_8);\n+\t\tbyte[] bytes = null;\n+\t\tif (binaryNode instanceof JResource) {\n+\t\t\tJResource jResource = ((JResource) binaryNode);\n+\t\t\ttry {\n+\t\t\t\tbytes = ResourcesLoader.decodeStream(jResource.getResFile(), (size, is) -> is.readAllBytes());\n+\t\t\t} catch (JadxException e) {\n+\t\t\t\tLOG.error(\"Failed to directly load resource binary data {}: {}\", jResource.getName(), e.getMessage());\n+\t\t\t}\n+\t\t}\n+\t\tif (bytes == null) {\n+\t\t\tbytes = binaryNode.getCodeInfo().getCodeStr().getBytes(StandardCharsets.UTF_8);\n+\t\t}\n \t\tsetBytes(bytes);\n \t\tif (getBytes().length > 0) {\n \t\t\t// We set the caret after the first byte to prevent it from being highlighted",
    "output": "Fix show correct content of binary resources in hex view"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n@@ -29,7 +29,7 @@\n import jadx.api.args.ResourceNameSource;\n import jadx.api.args.UserRenamesMappingsMode;\n import jadx.core.deobf.conditions.DeobfWhitelist;\n-import jadx.core.utils.exceptions.JadxException;\n+import jadx.core.utils.exceptions.JadxArgsValidateException;\n import jadx.core.utils.files.FileUtils;\n \n public class JadxCLIArgs {\n@@ -287,14 +287,13 @@ private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {\n \t\t\tSystem.out.println(JadxDecompiler.getVersion());\n \t\t\treturn false;\n \t\t}\n-\t\ttry {\n-\t\t\tif (threadsCount <= 0) {\n-\t\t\t\tthrow new JadxException(\"Threads count must be positive, got: \" + threadsCount);\n+\t\tif (threadsCount <= 0) {\n+\t\t\tthrow new JadxArgsValidateException(\"Threads count must be positive, got: \" + threadsCount);\n+\t\t}\n+\t\tfor (String fileName : files) {\n+\t\t\tif (fileName.startsWith(\"-\")) {\n+\t\t\t\tthrow new JadxArgsValidateException(\"Unknown option: \" + fileName);\n \t\t\t}\n-\t\t} catch (JadxException e) {\n-\t\t\tSystem.err.println(\"ERROR: \" + e.getMessage());\n-\t\t\tjcw.printUsage();\n-\t\t\treturn false;\n \t\t}\n \t\treturn true;\n \t}\n@@ -559,8 +558,8 @@ public Set<RenameEnum> convert(String value) {\n \t\t\tfor (String s : value.split(\",\")) {\n \t\t\t\ttry {\n \t\t\t\t\tset.add(RenameEnum.valueOf(s.trim().toUpperCase(Locale.ROOT)));\n-\t\t\t\t} catch (IllegalArgumentException e) {\n-\t\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new JadxArgsValidateException(\n \t\t\t\t\t\t\t'\\'' + s + \"' is unknown for parameter \" + paramName\n \t\t\t\t\t\t\t\t\t+ \", possible values are \" + enumValuesString(RenameEnum.values()));\n \t\t\t\t}\n@@ -625,7 +624,7 @@ public E convert(String value) {\n \t\t\ttry {\n \t\t\t\treturn parse.apply(stringAsEnumName(value));\n \t\t\t} catch (Exception e) {\n-\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\tthrow new JadxArgsValidateException(\n \t\t\t\t\t\t'\\'' + value + \"' is unknown, possible values are: \" + enumValuesString(values.get()));\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLICommands.java b/jadx-cli/src/main/java/jadx/cli/JadxCLICommands.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLICommands.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLICommands.java\n@@ -7,6 +7,7 @@\n \n import jadx.cli.commands.CommandPlugins;\n import jadx.cli.commands.ICommand;\n+import jadx.core.utils.exceptions.JadxArgsValidateException;\n \n public class JadxCLICommands {\n \tprivate static final Map<String, ICommand> COMMANDS_MAP = new TreeMap<>();\n@@ -26,7 +27,8 @@ public static void append(JCommander.Builder builder) {\n \tpublic static boolean process(JCommanderWrapper<?> jcw, JCommander jc, String parsedCommand) {\n \t\tICommand command = COMMANDS_MAP.get(parsedCommand);\n \t\tif (command == null) {\n-\t\t\tthrow new IllegalArgumentException(\"Unknown command: \" + parsedCommand);\n+\t\t\tthrow new JadxArgsValidateException(\"Unknown command: \" + parsedCommand\n+\t\t\t\t\t+ \". Expected one of: \" + COMMANDS_MAP.keySet());\n \t\t}\n \t\tJCommander subCommander = jc.getCommands().get(parsedCommand);\n \t\tcommand.process(jcw, subCommander);\n\ndiff --git a/jadx-cli/src/main/java/jadx/cli/SingleClassMode.java b/jadx-cli/src/main/java/jadx/cli/SingleClassMode.java\n--- a/jadx-cli/src/main/java/jadx/cli/SingleClassMode.java\n+++ b/jadx-cli/src/main/java/jadx/cli/SingleClassMode.java\n@@ -12,6 +12,7 @@\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.visitors.SaveCode;\n+import jadx.core.utils.exceptions.JadxArgsValidateException;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.core.utils.files.FileUtils;\n \n@@ -33,10 +34,10 @@ public static boolean process(JadxDecompiler jadx, JadxCLIArgs cliArgs) {\n \t\t\t\t\t\t.findFirst().orElse(null);\n \t\t\t}\n \t\t\tif (clsForProcess == null) {\n-\t\t\t\tthrow new JadxRuntimeException(\"Input class not found: \" + singleClass);\n+\t\t\t\tthrow new JadxArgsValidateException(\"Input class not found: \" + singleClass);\n \t\t\t}\n \t\t\tif (clsForProcess.contains(AFlag.DONT_GENERATE)) {\n-\t\t\t\tthrow new JadxRuntimeException(\"Input class can't be saved by current jadx settings (marked as DONT_GENERATE)\");\n+\t\t\t\tthrow new JadxArgsValidateException(\"Input class can't be saved by current jadx settings (marked as DONT_GENERATE)\");\n \t\t\t}\n \t\t\tif (clsForProcess.isInner()) {\n \t\t\t\tclsForProcess = clsForProcess.getTopParentClass();\n@@ -52,7 +53,7 @@ public static boolean process(JadxDecompiler jadx, JadxCLIArgs cliArgs) {\n \t\t\tif (size == 1) {\n \t\t\t\tclsForProcess = classes.get(0);\n \t\t\t} else {\n-\t\t\t\tthrow new JadxRuntimeException(\"Found \" + size + \" classes, single class output can't be used\");\n+\t\t\t\tthrow new JadxArgsValidateException(\"Found \" + size + \" classes, single class output can't be used\");\n \t\t\t}\n \t\t}\n \t\tICodeInfo codeInfo;\n\ndiff --git a/jadx-cli/src/test/java/jadx/cli/RenameConverterTest.java b/jadx-cli/src/test/java/jadx/cli/RenameConverterTest.java\n--- a/jadx-cli/src/test/java/jadx/cli/RenameConverterTest.java\n+++ b/jadx-cli/src/test/java/jadx/cli/RenameConverterTest.java\n@@ -7,6 +7,7 @@\n \n import jadx.api.JadxArgs.RenameEnum;\n import jadx.cli.JadxCLIArgs.RenameConverter;\n+import jadx.core.utils.exceptions.JadxArgsValidateException;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -38,7 +39,7 @@ public void none() {\n \n \t@Test\n \tpublic void wrong() {\n-\t\tIllegalArgumentException thrown = assertThrows(IllegalArgumentException.class,\n+\t\tJadxArgsValidateException thrown = assertThrows(JadxArgsValidateException.class,\n \t\t\t\t() -> converter.convert(\"wrong\"),\n \t\t\t\t\"Expected convert() to throw, but it didn't\");\n \n\ndiff --git a/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java\n--- a/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java\n@@ -28,12 +28,6 @@ private static void checkInputFiles(JadxDecompiler jadx, JadxArgs args) {\n \t\tif (inputFiles.isEmpty() && jadx.getCustomCodeLoaders().isEmpty()) {\n \t\t\tthrow new JadxArgsValidateException(\"Please specify input file\");\n \t\t}\n-\t\tfor (File inputFile : inputFiles) {\n-\t\t\tString fileName = inputFile.getName();\n-\t\t\tif (fileName.startsWith(\"--\")) {\n-\t\t\t\tthrow new JadxArgsValidateException(\"Unknown argument: \" + fileName);\n-\t\t\t}\n-\t\t}\n \t\tfor (File file : inputFiles) {\n \t\t\tcheckFile(file);\n \t\t}",
    "output": "Fix don't print stacktrace for incorrect options"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/impl/SimpleCodeWriter.java b/jadx-core/src/main/java/jadx/api/impl/SimpleCodeWriter.java\n--- a/jadx-core/src/main/java/jadx/api/impl/SimpleCodeWriter.java\n+++ b/jadx-core/src/main/java/jadx/api/impl/SimpleCodeWriter.java\n@@ -44,7 +44,7 @@ public SimpleCodeWriter(JadxArgs args) {\n \tpublic SimpleCodeWriter() {\n \t\tthis.insertLineNumbers = false;\n \t\tthis.singleIndentStr = JadxArgs.DEFAULT_INDENT_STR;\n-\t\tthis.newLineStr = JadxArgs.DEFAULT_INDENT_STR;\n+\t\tthis.newLineStr = JadxArgs.DEFAULT_NEW_LINE_STR;\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/SmaliWriter.java b/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/SmaliWriter.java\n--- a/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/SmaliWriter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/SmaliWriter.java\n@@ -11,6 +11,7 @@ public class SmaliWriter extends SimpleCodeWriter {\n \tprivate final ClassNode cls;\n \n \tpublic SmaliWriter(ClassNode cls) {\n+\t\tsuper(cls.root().getArgs());\n \t\tthis.cls = cls;\n \t}",
    "output": "Use correct new line string for simple code writer"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n@@ -132,6 +132,10 @@ public InsnArg wrapInstruction(MethodNode mth, InsnNode insn, boolean unbind) {\n \t\t}\n \t\tInsnArg arg = wrapInsnIntoArg(insn);\n \t\tInsnArg oldArg = parent.getArg(i);\n+\t\tif (arg.getType() == ArgType.UNKNOWN) {\n+\t\t\t// restore arg type if wrapped insn missing result\n+\t\t\targ.setType(oldArg.getType());\n+\t\t}\n \t\tparent.setArg(i, arg);\n \t\tInsnRemover.unbindArgUsage(mth, oldArg);\n \t\tif (unbind) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java\n@@ -1,7 +1,5 @@\n package jadx.core.dex.instructions.args;\n \n-import java.util.Objects;\n-\n import org.jetbrains.annotations.NotNull;\n \n import jadx.core.dex.instructions.ConstStringNode;\n@@ -74,11 +72,19 @@ public boolean equals(Object o) {\n \t\treturn true;\n \t}\n \n+\t@Override\n+\tpublic String toShortString() {\n+\t\tif (wrappedInsn.getType() == InsnType.CONST_STR) {\n+\t\t\treturn \"(\\\"\" + ((ConstStringNode) wrappedInsn).getString() + \"\\\")\";\n+\t\t}\n+\t\treturn \"(wrap:\" + type + \":\" + wrappedInsn.getType() + ')';\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n-\t\tif (wrappedInsn.getType() == InsnType.CONST_STR && Objects.equals(type, ArgType.STRING)) {\n+\t\tif (wrappedInsn.getType() == InsnType.CONST_STR) {\n \t\t\treturn \"(\\\"\" + ((ConstStringNode) wrappedInsn).getString() + \"\\\")\";\n \t\t}\n-\t\treturn \"(wrap: \" + type + \" : \" + wrappedInsn + ')';\n+\t\treturn \"(wrap:\" + type + \":\" + wrappedInsn + ')';\n \t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -402,7 +402,8 @@ private static InsnNode convertStringBuilderChain(MethodNode mth, InvokeNode toS\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (!stringArgFound) {\n-\t\t\t\tmth.addDebugComment(\"TODO: convert one arg to string using `String.valueOf()`, args: \" + args);\n+\t\t\t\tString argStr = Utils.listToString(args, InsnArg::toShortString);\n+\t\t\t\tmth.addDebugComment(\"TODO: convert one arg to string using `String.valueOf()`, args: \" + argStr);\n \t\t\t\treturn null;\n \t\t\t}\n \n@@ -625,7 +626,9 @@ private static ArithNode convertFieldArith(MethodNode mth, InsnNode insn) {\n \t\t\tfor (int i = 1; i < argsCount; i++) {\n \t\t\t\tconcat.addArg(wrap.getArg(i));\n \t\t\t}\n-\t\t\treturn ArithNode.oneArgOp(ArithOp.ADD, fArg, InsnArg.wrapArg(concat));\n+\t\t\tInsnArg concatArg = InsnArg.wrapArg(concat);\n+\t\t\tconcatArg.setType(ArgType.STRING);\n+\t\t\treturn ArithNode.oneArgOp(ArithOp.ADD, fArg, concatArg);\n \t\t} catch (Exception e) {\n \t\t\tLOG.debug(\"Can't convert field arith insn: {}, mth: {}\", insn, mth, e);\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n@@ -3,7 +3,6 @@\n import java.util.ArrayList;\n import java.util.BitSet;\n import java.util.List;\n-import java.util.ListIterator;\n import java.util.Objects;\n import java.util.Set;\n \n@@ -64,12 +63,9 @@ private static void shrinkBlock(MethodNode mth, BlockNode block) {\n \t\tList<WrapInfo> wrapList = new ArrayList<>();\n \t\tfor (ArgsInfo argsInfo : argsList) {\n \t\t\tList<RegisterArg> args = argsInfo.getArgs();\n-\t\t\tif (!args.isEmpty()) {\n-\t\t\t\tListIterator<RegisterArg> it = args.listIterator(args.size());\n-\t\t\t\twhile (it.hasPrevious()) {\n-\t\t\t\t\tRegisterArg arg = it.previous();\n-\t\t\t\t\tcheckInline(mth, block, insnList, wrapList, argsInfo, arg);\n-\t\t\t\t}\n+\t\t\tfor (int i = args.size() - 1; i >= 0; i--) {\n+\t\t\t\tRegisterArg arg = args.get(i);\n+\t\t\t\tcheckInline(mth, block, insnList, wrapList, argsInfo, arg);\n \t\t\t}\n \t\t}\n \t\tif (!wrapList.isEmpty()) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestStringBuilderElimination5.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestStringBuilderElimination5.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestStringBuilderElimination5.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestStringBuilderElimination5.java\n@@ -0,0 +1,45 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestStringBuilderElimination5 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\t@SuppressWarnings(\"StringConcatenationInLoop\")\n+\t\tpublic static String test(long[] a) {\n+\t\t\tString s = \"\";\n+\t\t\tfinal char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n+\t\t\tfor (int i = a.length - 1; i >= 0; i--) {\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 60) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 56) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 52) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 48) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 44) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 40) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 36) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 32) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 28) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 24) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 20) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 16) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 12) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 8) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i] >>> 4) & 0x0f];\n+\t\t\t\ts += hexChars[(int) (a[i]) & 0x0f];\n+\t\t\t\ts += \" \";\n+\t\t\t}\n+\t\t\treturn s;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\".append(\");\n+\t}\n+}",
    "output": "Fix improve StringBuilder elimination"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/ADBDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/ADBDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/ADBDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/ADBDialog.java\n@@ -13,6 +13,7 @@\n import java.net.Socket;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.EnumSet;\n import java.util.List;\n import java.util.Set;\n \n@@ -38,14 +39,17 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.api.JadxDecompiler;\n+import jadx.api.JavaClass;\n import jadx.core.utils.StringUtils;\n+import jadx.core.utils.android.AndroidManifestParser;\n+import jadx.core.utils.android.AppAttribute;\n+import jadx.core.utils.android.ApplicationParams;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n-import jadx.gui.device.debugger.DbgUtils;\n import jadx.gui.device.debugger.DebugSettings;\n import jadx.gui.device.protocol.ADB;\n import jadx.gui.device.protocol.ADBDevice;\n import jadx.gui.device.protocol.ADBDeviceInfo;\n-import jadx.gui.treemodel.JClass;\n import jadx.gui.ui.MainWindow;\n import jadx.gui.ui.panel.IDebugController;\n import jadx.gui.utils.NLS;\n@@ -511,18 +515,35 @@ private void launchApp() {\n \t\t\tUiUtils.showMessageBox(mainWindow, NLS.str(\"adb_dialog.no_devices\"));\n \t\t\treturn;\n \t\t}\n-\t\tJClass cls = DbgUtils.searchMainActivity(mainWindow);\n-\t\tString pkg = DbgUtils.searchPackageName(mainWindow);\n-\t\tif (pkg.isEmpty() || cls == null) {\n-\t\t\tUiUtils.showMessageBox(mainWindow, NLS.str(\"adb_dialog.msg_read_mani_fail\"));\n+\t\tJadxDecompiler decompiler = mainWindow.getWrapper().getDecompiler();\n+\t\tString appPkg = decompiler.getRoot().getAppPackage();\n+\t\tif (appPkg == null) {\n+\t\t\tUiUtils.errorMessage(mainWindow, NLS.str(\"error_dialog.not_found\", \"App package\"));\n \t\t\treturn;\n \t\t}\n-\t\tif (scrollToProcNode(pkg)) {\n+\t\tif (scrollToProcNode(appPkg)) {\n \t\t\treturn;\n \t\t}\n-\t\tString fullName = pkg + \"/\" + cls.getCls().getClassNode().getClassInfo().getFullName();\n \n-\t\tADBDevice device = (lastSelectedDeviceNode == null) ? deviceNodes.get(0).device : lastSelectedDeviceNode.device;\n+\t\tAndroidManifestParser parser = new AndroidManifestParser(\n+\t\t\t\tAndroidManifestParser.getAndroidManifest(decompiler.getResources()),\n+\t\t\t\tEnumSet.of(AppAttribute.MAIN_ACTIVITY));\n+\t\tif (!parser.isManifestFound()) {\n+\t\t\tUiUtils.errorMessage(mainWindow, NLS.str(\"error_dialog.not_found\", \"AndroidManifest.xml\"));\n+\t\t\treturn;\n+\t\t}\n+\t\tApplicationParams results = parser.parse();\n+\t\tif (results.getMainActivityName() == null) {\n+\t\t\tUiUtils.errorMessage(mainWindow, NLS.str(\"adb_dialog.msg_read_mani_fail\"));\n+\t\t\treturn;\n+\t\t}\n+\t\tJavaClass mainActivityClass = results.getMainActivity(decompiler);\n+\t\tif (mainActivityClass == null) {\n+\t\t\tUiUtils.errorMessage(mainWindow, NLS.str(\"error_dialog.not_found\", \"Main activity class\"));\n+\t\t\treturn;\n+\t\t}\n+\t\tString fullName = appPkg + \"/\" + mainActivityClass.getClassNode().getClassInfo().getFullName();\n+\t\tADBDevice device = lastSelectedDeviceNode == null ? deviceNodes.get(0).device : lastSelectedDeviceNode.device;\n \t\tif (device != null) {\n \t\t\ttry {\n \t\t\t\tdevice.launchApp(fullName);",
    "output": "Use common code for manifest parsing in debugger"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/ADBDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/ADBDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/ADBDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/ADBDialog.java\n@@ -69,6 +69,7 @@ public class ADBDialog extends JDialog implements ADB.DeviceStateListener, ADB.J\n \tprivate transient JTree procTree;\n \tprivate Socket deviceSocket;\n \tprivate transient List<DeviceNode> deviceNodes = new ArrayList<>();\n+\tprivate transient DeviceNode lastSelectedDeviceNode;\n \n \tpublic ADBDialog(MainWindow mainWindow) {\n \t\tsuper(mainWindow);\n@@ -147,6 +148,15 @@ public Component getTreeCellRendererComponent(JTree tree, Object value, boolean\n \t\t\t}\n \t\t});\n \n+\t\tprocTree.addTreeSelectionListener(event -> {\n+\t\t\tObject selectedNode = procTree.getLastSelectedPathComponent();\n+\t\t\tif (selectedNode instanceof DeviceTreeNode) {\n+\t\t\t\tlastSelectedDeviceNode = deviceNodes.stream()\n+\t\t\t\t\t\t.filter(item -> item.tNode == selectedNode)\n+\t\t\t\t\t\t.findFirst().orElse(null);\n+\t\t\t}\n+\t\t});\n+\n \t\tJPanel btnPane = new JPanel();\n \t\tBoxLayout boxLayout = new BoxLayout(btnPane, BoxLayout.LINE_AXIS);\n \t\tbtnPane.setLayout(boxLayout);\n@@ -511,7 +521,8 @@ private void launchApp() {\n \t\t\treturn;\n \t\t}\n \t\tString fullName = pkg + \"/\" + cls.getCls().getClassNode().getClassInfo().getFullName();\n-\t\tADBDevice device = deviceNodes.get(0).device; // TODO: if multiple devices presented should let user select the one they desire.\n+\n+\t\tADBDevice device = (lastSelectedDeviceNode == null) ? deviceNodes.get(0).device : lastSelectedDeviceNode.device;\n \t\tif (device != null) {\n \t\t\ttry {\n \t\t\t\tdevice.launchApp(fullName);",
    "output": "Fix remember selected device in debugger"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n@@ -106,4 +106,5 @@ public enum AFlag {\n \tDONT_UNLOAD_CLASS, // don't unload class after code generation (only for tests and debug!)\n \n \tRESOLVE_JAVA_JSR,\n+\tCOMPUTE_POST_DOM,\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n@@ -521,6 +521,7 @@ private SwitchInsn makeSwitch(InsnData insn, boolean packed) {\n \t\tif (payload != null) {\n \t\t\tswInsn.attachSwitchData(new SwitchData((ISwitchPayload) payload), insn.getTarget());\n \t\t}\n+\t\tmethod.add(AFlag.COMPUTE_POST_DOM);\n \t\treturn swInsn;\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n@@ -331,6 +331,17 @@ private static boolean wrapBlocksWithTryCatch(MethodNode mth, TryCatchBlockAttr\n \t\t\treturn false;\n \t\t}\n \t\tBlockNode bottom = searchBottomBlock(mth, blocks);\n+\t\tBlockNode splitReturn;\n+\t\tif (bottom != null && bottom.isReturnBlock()) {\n+\t\t\tif (Consts.DEBUG_EXC_HANDLERS) {\n+\t\t\t\tLOG.debug(\"TryCatch #{} bottom block ({}) is return, split\", tryCatchBlock.id(), bottom);\n+\t\t\t}\n+\t\t\tsplitReturn = bottom;\n+\t\t\tbottom = BlockSplitter.blockSplitTop(mth, bottom);\n+\t\t\tbottom.add(AFlag.SYNTHETIC);\n+\t\t} else {\n+\t\t\tsplitReturn = null;\n+\t\t}\n \t\tif (Consts.DEBUG_EXC_HANDLERS) {\n \t\t\tLOG.debug(\"TryCatch #{} split: top {}, bottom: {}\", tryCatchBlock.id(), top, bottom);\n \t\t}\n@@ -349,6 +360,18 @@ private static boolean wrapBlocksWithTryCatch(MethodNode mth, TryCatchBlockAttr\n \t\t\tbottomSplitterBlock.add(AFlag.EXC_BOTTOM_SPLITTER);\n \t\t\tbottomSplitterBlock.add(AFlag.SYNTHETIC);\n \t\t\tBlockSplitter.connect(bottom, bottomSplitterBlock);\n+\t\t\tif (splitReturn != null) {\n+\t\t\t\t// redirect handler to return block instead synthetic split block to avoid self-loop\n+\t\t\t\tBlockSet bottomPreds = BlockSet.from(mth, bottom.getPredecessors());\n+\t\t\t\tfor (ExceptionHandler handler : tryCatchBlock.getHandlers()) {\n+\t\t\t\t\tif (bottomPreds.intersects(handler.getBlocks())) {\n+\t\t\t\t\t\tBlockNode lastBlock = bottomPreds.intersect(handler.getBlocks()).getOne();\n+\t\t\t\t\t\tif (lastBlock != null) {\n+\t\t\t\t\t\t\tBlockSplitter.replaceConnection(lastBlock, bottom, splitReturn);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \n \t\tif (Consts.DEBUG_EXC_HANDLERS) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/PostDominatorTree.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/PostDominatorTree.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/PostDominatorTree.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/PostDominatorTree.java\n@@ -4,6 +4,7 @@\n import java.util.BitSet;\n import java.util.List;\n \n+import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.nodes.BlockNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.utils.BlockUtils;\n@@ -12,6 +13,9 @@\n public class PostDominatorTree {\n \n \tpublic static void compute(MethodNode mth) {\n+\t\tif (!mth.contains(AFlag.COMPUTE_POST_DOM)) {\n+\t\t\treturn;\n+\t\t}\n \t\ttry {\n \t\t\tint mthBlocksCount = mth.getBasicBlocks().size();\n \t\t\tList<BlockNode> sorted = new ArrayList<>(mthBlocksCount);\n@@ -57,6 +61,9 @@ public static void compute(MethodNode mth) {\n \t\t\t\t}\n \t\t\t\tmth.addInfoComment(\"Infinite loop detected, blocks: \" + blocksDelta + \", insns: \" + insnsCount);\n \t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\t// show error as a warning because this info not always used\n+\t\t\tmth.addWarnComment(\"Failed to build post-dominance tree\", e);\n \t\t} finally {\n \t\t\t// revert block ids change\n \t\t\tmth.updateBlockIds(mth.getBasicBlocks());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/blocks/BlockSet.java b/jadx-core/src/main/java/jadx/core/utils/blocks/BlockSet.java\n--- a/jadx-core/src/main/java/jadx/core/utils/blocks/BlockSet.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/blocks/BlockSet.java\n@@ -2,16 +2,25 @@\n \n import java.util.ArrayList;\n import java.util.BitSet;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n import java.util.function.Consumer;\n \n+import org.jetbrains.annotations.Nullable;\n+\n import jadx.core.dex.nodes.BlockNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.utils.EmptyBitSet;\n \n public class BlockSet {\n \n+\tpublic static BlockSet from(MethodNode mth, Collection<BlockNode> blocks) {\n+\t\tBlockSet newBS = new BlockSet(mth);\n+\t\tnewBS.set(blocks);\n+\t\treturn newBS;\n+\t}\n+\n \tprivate final MethodNode mth;\n \tprivate final BitSet bs;\n \n@@ -28,13 +37,50 @@ public void set(BlockNode block) {\n \t\tbs.set(block.getId());\n \t}\n \n+\tpublic void set(Collection<BlockNode> blocks) {\n+\t\tblocks.forEach(this::set);\n+\t}\n+\n \tpublic boolean checkAndSet(BlockNode block) {\n \t\tint id = block.getId();\n \t\tboolean state = bs.get(id);\n \t\tbs.set(id);\n \t\treturn state;\n \t}\n \n+\tpublic boolean intersects(List<BlockNode> blocks) {\n+\t\tfor (BlockNode block : blocks) {\n+\t\t\tif (get(block)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic BlockSet intersect(List<BlockNode> blocks) {\n+\t\tBlockSet input = from(mth, blocks);\n+\t\tBlockSet result = new BlockSet(mth);\n+\t\tBitSet resultBS = result.bs;\n+\t\tresultBS.or(this.bs);\n+\t\tresultBS.and(input.bs);\n+\t\treturn result;\n+\t}\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn bs.cardinality() == 0;\n+\t}\n+\n+\tpublic int size() {\n+\t\treturn bs.cardinality();\n+\t}\n+\n+\tpublic @Nullable BlockNode getOne() {\n+\t\tif (bs.cardinality() == 1) {\n+\t\t\treturn mth.getBasicBlocks().get(bs.nextSetBit(0));\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \tpublic void forEach(Consumer<? super BlockNode> consumer) {\n \t\tif (bs.isEmpty()) {\n \t\t\treturn;",
    "output": "Fix avoid self-loop for exception handlers"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/clsp/ClspClass.java b/jadx-core/src/main/java/jadx/core/clsp/ClspClass.java\n--- a/jadx-core/src/main/java/jadx/core/clsp/ClspClass.java\n+++ b/jadx-core/src/main/java/jadx/core/clsp/ClspClass.java\n@@ -7,6 +7,8 @@\n import java.util.Map;\n import java.util.Objects;\n \n+import org.intellij.lang.annotations.MagicConstant;\n+\n import jadx.api.plugins.input.data.AccessFlags;\n import jadx.core.dex.instructions.args.ArgType;\n \n@@ -51,6 +53,10 @@ public boolean isInterface() {\n \t\treturn AccessFlags.hasFlag(accFlags, AccessFlags.INTERFACE);\n \t}\n \n+\tpublic boolean hasAccFlag(@MagicConstant(flagsFromClass = AccessFlags.class) int flags) {\n+\t\treturn AccessFlags.hasFlag(accFlags, flags);\n+\t}\n+\n \tpublic ArgType[] getParents() {\n \t\treturn parents;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n@@ -5,22 +5,26 @@\n import java.util.Map;\n import java.util.Objects;\n \n+import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import jadx.api.CommentsLevel;\n import jadx.api.ICodeWriter;\n import jadx.api.metadata.annotations.InsnCodeOffset;\n import jadx.api.metadata.annotations.VarNode;\n+import jadx.api.plugins.input.data.AccessFlags;\n import jadx.api.plugins.input.data.annotations.EncodedValue;\n import jadx.api.plugins.input.data.attributes.JadxAttrType;\n+import jadx.core.clsp.ClspClass;\n import jadx.core.codegen.utils.CodeGenUtils;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.DeclareVariablesAttr;\n import jadx.core.dex.attributes.nodes.ForceReturnAttr;\n import jadx.core.dex.attributes.nodes.LoopLabelAttr;\n import jadx.core.dex.info.ClassInfo;\n+import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.instructions.SwitchInsn;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.CodeVar;\n@@ -268,26 +272,39 @@ public void makeSwitch(SwitchRegion sw, ICodeWriter code) throws CodegenExceptio\n \n \tprivate void addCaseKey(ICodeWriter code, InsnArg arg, Object k) throws CodegenException {\n \t\tif (k instanceof FieldNode) {\n-\t\t\tFieldNode fn = (FieldNode) k;\n-\t\t\tif (fn.getParentClass().isEnum()) {\n-\t\t\t\tcode.add(fn.getAlias());\n-\t\t\t} else {\n-\t\t\t\tstaticField(code, fn.getFieldInfo());\n-\t\t\t\tif (mth.checkCommentsLevel(CommentsLevel.INFO)) {\n-\t\t\t\t\t// print original value, sometimes replaced with incorrect field\n-\t\t\t\t\tEncodedValue constVal = fn.get(JadxAttrType.CONSTANT_VALUE);\n-\t\t\t\t\tif (constVal != null && constVal.getValue() != null) {\n-\t\t\t\t\t\tcode.add(\" /* \").add(constVal.getValue().toString()).add(\" */\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tFieldNode fld = (FieldNode) k;\n+\t\t\tuseField(code, fld.getFieldInfo(), fld);\n+\t\t} else if (k instanceof FieldInfo) {\n+\t\t\tuseField(code, (FieldInfo) k, null);\n \t\t} else if (k instanceof Integer) {\n \t\t\tcode.add(TypeGen.literalToString((Integer) k, arg.getType(), mth, fallback));\n \t\t} else {\n \t\t\tthrow new JadxRuntimeException(\"Unexpected key in switch: \" + (k != null ? k.getClass() : null));\n \t\t}\n \t}\n \n+\tprivate void useField(ICodeWriter code, FieldInfo fldInfo, @Nullable FieldNode fld) throws CodegenException {\n+\t\tboolean isEnum;\n+\t\tif (fld != null) {\n+\t\t\tisEnum = fld.getParentClass().isEnum();\n+\t\t} else {\n+\t\t\tClspClass clsDetails = root.getClsp().getClsDetails(fldInfo.getDeclClass().getType());\n+\t\t\tisEnum = clsDetails != null && clsDetails.hasAccFlag(AccessFlags.ENUM);\n+\t\t}\n+\t\tif (isEnum) {\n+\t\t\tcode.add(fldInfo.getAlias());\n+\t\t\treturn;\n+\t\t}\n+\t\tstaticField(code, fldInfo);\n+\t\tif (fld != null && mth.checkCommentsLevel(CommentsLevel.INFO)) {\n+\t\t\t// print original value, sometimes replaced with incorrect field\n+\t\t\tEncodedValue constVal = fld.get(JadxAttrType.CONSTANT_VALUE);\n+\t\t\tif (constVal != null && constVal.getValue() != null) {\n+\t\t\t\tcode.add(\" /* \").add(constVal.getValue().toString()).add(\" */\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tpublic void makeTryCatch(TryCatchRegion region, ICodeWriter code) throws CodegenException {\n \t\tcode.startLine(\"try {\");\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/android/TestResConstReplace2.java b/jadx-core/src/test/java/jadx/tests/integration/android/TestResConstReplace2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/android/TestResConstReplace2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/android/TestResConstReplace2.java\n@@ -0,0 +1,33 @@\n+package jadx.tests.integration.android;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestResConstReplace2 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic int test(int i) {\n+\t\t\tswitch (i) {\n+\t\t\t\tcase 0x0101013f: // android.R.attr.minWidth\n+\t\t\t\t\treturn 1;\n+\t\t\t\tcase 0x01010140: // android.R.attr.minHeight\n+\t\t\t\t\treturn 2;\n+\t\t\t\tdefault:\n+\t\t\t\t\treturn 0;\n+\t\t\t}\n+\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"import android.R;\")\n+\t\t\t\t.containsOne(\"case R.attr.minWidth:\");\n+\t}\n+}",
    "output": "Fix allow use `FieldInfo` as switch key"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/data/CommentStyle.java b/jadx-core/src/main/java/jadx/api/data/CommentStyle.java\n--- a/jadx-core/src/main/java/jadx/api/data/CommentStyle.java\n+++ b/jadx-core/src/main/java/jadx/api/data/CommentStyle.java\n@@ -9,29 +9,33 @@ public enum CommentStyle {\n \t */\n \tLINE(\"// \", \"// \", \"\"),\n \n+\t// @formatter:off\n \t/**\n \t * <pre>\n \t * /*\n \t *  * comment\n-\t * *&#47;\n+\t *  *&#47;\n \t * </pre>\n \t */\n-\tBLOCK(\"/*\\n \", \" \", \"\\n */\"),\n+\t// @formatter:on\n+\tBLOCK(\"/*\\n * \", \" * \", \"\\n */\"),\n \n \t/**\n \t * <pre>\n \t * /* comment *&#47;\n \t * </pre>\n \t */\n-\tBLOCK_CONDENSED(\"/* \", \" \", \" */\"),\n+\tBLOCK_CONDENSED(\"/* \", \" * \", \" */\"),\n \n+\t// @formatter:off\n \t/**\n \t * <pre>\n \t * /**\n \t *  * comment\n-\t * *&#47;\n+\t *  *&#47;\n \t * </pre>\n \t */\n+\t// @formatter:on\n \tJAVADOC(\"/**\\n * \", \" * \", \"\\n */\"),\n \n \t/**\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/NotificationAttrNode.java b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/NotificationAttrNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/NotificationAttrNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/NotificationAttrNode.java\n@@ -30,7 +30,7 @@ public void addCodeComment(String comment) {\n \t\taddAttr(AType.CODE_COMMENTS, new CodeComment(comment, CommentStyle.LINE));\n \t}\n \n-\tpublic void addCodeComment(CommentStyle style, String comment) {\n+\tpublic void addCodeComment(String comment, CommentStyle style) {\n \t\taddAttr(AType.CODE_COMMENTS, new CodeComment(comment, style));\n \t}",
    "output": "Add missing \" * \" on new line for block comments, flip addCodeComment args"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/FixMultiEntryLoops.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/FixMultiEntryLoops.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/FixMultiEntryLoops.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/FixMultiEntryLoops.java\n@@ -22,8 +22,7 @@ public static boolean process(MethodNode mth) {\n \t\t}\n \t\tList<SpecialEdgeAttr> specialEdges = mth.getAll(AType.SPECIAL_EDGE);\n \t\tList<SpecialEdgeAttr> multiEntryLoops = specialEdges.stream()\n-\t\t\t\t.filter(e -> e.getType() == SpecialEdgeType.BACK_EDGE)\n-\t\t\t\t.filter(e -> !isSingleEntryLoop(e))\n+\t\t\t\t.filter(e -> e.getType() == SpecialEdgeType.BACK_EDGE && !isSingleEntryLoop(e))\n \t\t\t\t.collect(Collectors.toList());\n \t\tif (multiEntryLoops.isEmpty()) {\n \t\t\treturn false;\n@@ -42,25 +41,50 @@ public static boolean process(MethodNode mth) {\n \t}\n \n \tprivate static boolean fixLoop(MethodNode mth, SpecialEdgeAttr backEdge, List<SpecialEdgeAttr> crossEdges) {\n+\t\tif (isHeaderSuccessorEntry(mth, backEdge, crossEdges)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (isEndBlockEntry(mth, backEdge, crossEdges)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tmth.addWarnComment(\"Unsupported multi-entry loop pattern (\" + backEdge + \"). Please report as a decompilation issue!!!\");\n+\t\treturn false;\n+\t}\n+\n+\tprivate static boolean isHeaderSuccessorEntry(MethodNode mth, SpecialEdgeAttr backEdge, List<SpecialEdgeAttr> crossEdges) {\n \t\tBlockNode header = backEdge.getEnd();\n \t\tBlockNode headerIDom = header.getIDom();\n \t\tSpecialEdgeAttr subEntry = ListUtils.filterOnlyOne(crossEdges, e -> e.getStart() == headerIDom);\n-\t\tif (subEntry == null || !isSupportedPattern(header, subEntry)) {\n-\t\t\t// TODO: for now only sub entry in header successor is supported\n-\t\t\tmth.addWarnComment(\"Unsupported multi-entry loop pattern (\" + backEdge + \"). Please submit an issue!!!\");\n+\t\tif (subEntry == null || !ListUtils.isSingleElement(header.getSuccessors(), subEntry.getEnd())) {\n \t\t\treturn false;\n \t\t}\n \t\tBlockNode loopEnd = backEdge.getStart();\n \t\tBlockNode subEntryBlock = subEntry.getEnd();\n \t\tBlockNode copyHeader = BlockSplitter.insertBlockBetween(mth, loopEnd, header);\n \t\tBlockSplitter.copyBlockData(header, copyHeader);\n \t\tBlockSplitter.replaceConnection(copyHeader, header, subEntryBlock);\n-\t\tmth.addDebugComment(\"Duplicate block to fix multi-entry loop: \" + backEdge);\n+\t\tmth.addDebugComment(\"Duplicate block (\" + header + \") to fix multi-entry loop: \" + backEdge);\n+\t\treturn true;\n+\t}\n+\n+\tprivate static boolean isEndBlockEntry(MethodNode mth, SpecialEdgeAttr backEdge, List<SpecialEdgeAttr> crossEdges) {\n+\t\tBlockNode loopEnd = backEdge.getStart();\n+\t\tSpecialEdgeAttr subEntry = ListUtils.filterOnlyOne(crossEdges, e -> e.getEnd() == loopEnd);\n+\t\tif (subEntry == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tdupPath(mth, subEntry.getStart(), loopEnd, backEdge.getEnd());\n+\t\tmth.addDebugComment(\"Duplicate block (\" + loopEnd + \") to fix multi-entry loop: \" + backEdge);\n \t\treturn true;\n \t}\n \n-\tprivate static boolean isSupportedPattern(BlockNode header, SpecialEdgeAttr subEntry) {\n-\t\treturn ListUtils.isSingleElement(header.getSuccessors(), subEntry.getEnd());\n+\t/**\n+\t * Duplicate 'center' block on path from 'start' to 'end'\n+\t */\n+\tprivate static void dupPath(MethodNode mth, BlockNode start, BlockNode center, BlockNode end) {\n+\t\tBlockNode copyCenter = BlockSplitter.insertBlockBetween(mth, start, end);\n+\t\tBlockSplitter.copyBlockData(center, copyCenter);\n+\t\tBlockSplitter.removeConnection(start, center);\n \t}\n \n \tprivate static boolean isSingleEntryLoop(SpecialEdgeAttr e) {\n@@ -75,21 +99,18 @@ private enum BlockColor {\n \t}\n \n \tprivate static void detectSpecialEdges(MethodNode mth) {\n-\t\tList<BlockNode> blocks = mth.getBasicBlocks();\n-\t\tBlockColor[] colors = new BlockColor[blocks.size()];\n+\t\tBlockColor[] colors = new BlockColor[mth.getBasicBlocks().size()];\n \t\tArrays.fill(colors, BlockColor.WHITE);\n-\t\tcolorDFS(mth, blocks, colors, mth.getEnterBlock().getId());\n+\t\tcolorDFS(mth, colors, mth.getEnterBlock());\n \t}\n \n \t// TODO: transform to non-recursive form\n-\tprivate static void colorDFS(MethodNode mth, List<BlockNode> blocks, BlockColor[] colors, int cur) {\n-\t\tcolors[cur] = BlockColor.GRAY;\n-\t\tBlockNode block = blocks.get(cur);\n+\tprivate static void colorDFS(MethodNode mth, BlockColor[] colors, BlockNode block) {\n+\t\tcolors[block.getId()] = BlockColor.GRAY;\n \t\tfor (BlockNode v : block.getSuccessors()) {\n-\t\t\tint vId = v.getId();\n-\t\t\tswitch (colors[vId]) {\n+\t\t\tswitch (colors[v.getId()]) {\n \t\t\t\tcase WHITE:\n-\t\t\t\t\tcolorDFS(mth, blocks, colors, vId);\n+\t\t\t\t\tcolorDFS(mth, colors, v);\n \t\t\t\t\tbreak;\n \t\t\t\tcase GRAY:\n \t\t\t\t\tmth.addAttr(AType.SPECIAL_EDGE, new SpecialEdgeAttr(SpecialEdgeType.BACK_EDGE, block, v));\n@@ -99,6 +120,6 @@ private static void colorDFS(MethodNode mth, List<BlockNode> blocks, BlockColor[\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tcolors[cur] = BlockColor.BLACK;\n+\t\tcolors[block.getId()] = BlockColor.BLACK;\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestMultiEntryLoop2.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestMultiEntryLoop2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestMultiEntryLoop2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestMultiEntryLoop2.java\n@@ -0,0 +1,17 @@\n+package jadx.tests.integration.loops;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestMultiEntryLoop2 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"while (true) {\");\n+\t}\n+}",
    "output": "Fix support end block entry for mutli-entry loops"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n@@ -43,9 +43,7 @@ public void init(RootNode root) {\n \t\tif (!inlineAnonymousClasses) {\n \t\t\treturn;\n \t\t}\n-\t\tfor (ClassNode cls : root.getClasses()) {\n-\t\t\tmarkAnonymousClass(cls);\n-\t\t}\n+\t\troot.getClasses().forEach(ProcessAnonymous::processClass);\n \t\tmergeAnonymousDeps(root);\n \t}\n \n@@ -59,10 +57,18 @@ public boolean visit(ClassNode cls) throws JadxException {\n \t}\n \n \tprivate void visitClassAndInners(ClassNode cls) {\n-\t\tmarkAnonymousClass(cls);\n+\t\tprocessClass(cls);\n \t\tcls.getInnerClasses().forEach(this::visitClassAndInners);\n \t}\n \n+\tprivate static void processClass(ClassNode cls) {\n+\t\ttry {\n+\t\t\tmarkAnonymousClass(cls);\n+\t\t} catch (Throwable e) {\n+\t\t\tcls.addError(\"Anonymous visitor error\", e);\n+\t\t}\n+\t}\n+\n \tprivate static void markAnonymousClass(ClassNode cls) {\n \t\tif (!canBeAnonymous(cls)) {\n \t\t\treturn;\n@@ -273,6 +279,10 @@ private static boolean checkForInstanceFieldUsage(ClassNode cls, MethodNode ctr)\n \t\tif (!ctrUseMth.getMethodInfo().isClassInit()) {\n \t\t\treturn false;\n \t\t}\n+\t\tif (cls.getUseInMth().isEmpty()) {\n+\t\t\t// no outside usage, inline not needed\n+\t\t\treturn false;\n+\t\t}\n \t\tFieldNode instFld = ListUtils.filterOnlyOne(cls.getFields(),\n \t\t\t\tf -> f.getAccessFlags().containsFlags(AccessFlags.PUBLIC, AccessFlags.STATIC, AccessFlags.FINAL)\n \t\t\t\t\t\t&& f.getFieldInfo().getType().equals(cls.getClassInfo().getType()));",
    "output": "Fix in anonymous class checks ignore instance fields not used outside"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -936,7 +936,7 @@ private void makeInvokeLambda(ICodeWriter code, InvokeCustomNode customNode) thr\n \t\tmakeInlinedLambdaMethod(code, customNode, callMth);\n \t}\n \n-\tprivate void makeRefLambda(ICodeWriter code, InvokeCustomNode customNode) {\n+\tprivate void makeRefLambda(ICodeWriter code, InvokeCustomNode customNode) throws CodegenException {\n \t\tInsnNode callInsn = customNode.getCallInsn();\n \t\tif (callInsn instanceof ConstructorInsn) {\n \t\t\tMethodInfo callMth = ((ConstructorInsn) callInsn).getCallMth();\n@@ -950,7 +950,7 @@ private void makeRefLambda(ICodeWriter code, InvokeCustomNode customNode) {\n \t\t\tif (customNode.getHandleType() == MethodHandleType.INVOKE_STATIC) {\n \t\t\t\tuseClass(code, callMth.getDeclClass());\n \t\t\t} else {\n-\t\t\t\tcode.add(\"this\");\n+\t\t\t\taddArg(code, customNode.getArg(0));\n \t\t\t}\n \t\t\tcode.add(\"::\").add(callMth.getAlias());\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaInstance3.java b/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaInstance3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaInstance3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaInstance3.java\n@@ -0,0 +1,54 @@\n+package jadx.tests.integration.java8;\n+\n+import java.util.function.Supplier;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.RaungTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+@SuppressWarnings(\"DataFlowIssue\")\n+public class TestLambdaInstance3 extends RaungTest {\n+\n+\tpublic interface TestCls<R> extends Supplier<R> {\n+\t\tdefault TestCls<R> test() {\n+\t\t\treturn (TestCls<R> & Memoized) Lazy.of(this)::get;\n+\t\t}\n+\t}\n+\n+\tpublic static final class Lazy<T> implements Supplier<T> {\n+\t\tpublic static <T> Lazy<T> of(Supplier<? extends T> supplier) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic T get() {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tinterface Memoized {\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\t// some java versions failed to compile usage of interface with '$' in name\n+\t\taddClsRename(\"jadx.tests.integration.java8.TestLambdaInstance3$TestCls\", \"java8.TestCls\");\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"this::get\")\n+\t\t\t\t.containsOne(\"return (TestCls) of::get;\");\n+\t\t// TODO: type inference set type for 'of' to Memoized and cast incorrectly removed\n+\t\t// .containsOne(\"Memoized)\");\n+\t}\n+\n+\t@Test\n+\tpublic void testRaung() {\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNodeFromRaung())\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"this::get\")\n+\t\t\t\t.containsOne(\" of::get\");\n+\t}\n+}\n\ndiff --git a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/ConstPoolReader.java b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/ConstPoolReader.java\n--- a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/ConstPoolReader.java\n+++ b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/ConstPoolReader.java\n@@ -221,6 +221,8 @@ public EncodedValue readAsEncodedValue(int idx) {\n \t\t\t\treturn new EncodedValue(EncodedType.ENCODED_LONG, data.readS8());\n \t\t\tcase DOUBLE:\n \t\t\t\treturn new EncodedValue(EncodedType.ENCODED_DOUBLE, Double.longBitsToDouble(data.readU8()));\n+\t\t\tcase CLASS:\n+\t\t\t\treturn new EncodedValue(EncodedType.ENCODED_TYPE, getClass(idx));\n \t\t\tcase METHOD_TYPE:\n \t\t\t\treturn new EncodedValue(EncodedType.ENCODED_METHOD_TYPE, DescriptorParser.parseToMethodProto(getUtf8(readU2())));\n \t\t\tcase METHOD_HANDLE:",
    "output": "Fix lambda decoding and code generation"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n@@ -10,6 +10,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.StringJoiner;\n import java.util.function.Consumer;\n import java.util.stream.Collectors;\n \n@@ -113,11 +114,19 @@ public void setFilePaths(List<Path> files) {\n \t\t} else {\n \t\t\tCollections.sort(files);\n \t\t\tdata.setFiles(files);\n-\t\t\tString joinedName = files.stream()\n-\t\t\t\t\t.map(p -> p.getFileName().toString())\n-\t\t\t\t\t.filter(file -> !file.endsWith(\".jadx.kts\"))\n-\t\t\t\t\t.map(CommonFileUtils::removeFileExtension)\n-\t\t\t\t\t.collect(Collectors.joining(\"_\"));\n+\t\t\tStringJoiner joiner = new StringJoiner(\"_\");\n+\t\t\tfor (Path p : files) {\n+\t\t\t\tPath fileNamePart = p.getFileName();\n+\t\t\t\tif (fileNamePart == null) {\n+\t\t\t\t\tjoiner.add(p.toString());\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tString fileName = fileNamePart.toString();\n+\t\t\t\tif (!fileName.endsWith(\".jadx.kts\")) {\n+\t\t\t\t\tjoiner.add(CommonFileUtils.removeFileExtension(fileName));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tString joinedName = joiner.toString();\n \t\t\tname = StringUtils.abbreviate(joinedName, 100);\n \t\t}\n \t\tchanged();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n@@ -173,7 +173,11 @@ public String makeString() {\n \t\t\treturn \"File not open\";\n \t\t}\n \t\tif (count == 1) {\n-\t\t\treturn paths.get(0).getFileName().toString();\n+\t\t\tPath fileNamePath = paths.get(0).getFileName();\n+\t\t\tif (fileNamePath != null) {\n+\t\t\t\treturn fileNamePath.toString();\n+\t\t\t}\n+\t\t\treturn paths.get(0).toString();\n \t\t}\n \t\treturn count + \" files\";\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -460,6 +460,9 @@ private void open(List<Path> paths, Runnable onFinish) {\n \t}\n \n \tprivate boolean openSingleFile(Path singleFile, Runnable onFinish) {\n+\t\tif (singleFile.getFileName() == null) {\n+\t\t\treturn false;\n+\t\t}\n \t\tString fileExtension = CommonFileUtils.getFileExtension(singleFile.getFileName().toString());\n \t\tif (fileExtension != null && fileExtension.equalsIgnoreCase(JadxProject.PROJECT_EXTENSION)) {\n \t\t\topenProject(singleFile, onFinish);",
    "output": "Fix handle paths where file name is null"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourceFile.java b/jadx-core/src/main/java/jadx/api/ResourceFile.java\n--- a/jadx-core/src/main/java/jadx/api/ResourceFile.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java\n@@ -62,6 +62,10 @@ public String getDeobfName() {\n \t\treturn deobfName != null ? deobfName : name;\n \t}\n \n+\tpublic void setDeobfName(String resFullName) {\n+\t\tthis.deobfName = resFullName;\n+\t}\n+\n \tpublic ResourceType getType() {\n \t\treturn type;\n \t}\n@@ -84,7 +88,7 @@ public boolean setAlias(ResourceEntry ri) {\n \t\t}\n \t\tString alias = sb.toString();\n \t\tif (!alias.equals(name)) {\n-\t\t\tdeobfName = alias;\n+\t\t\tsetDeobfName(alias);\n \t\t\treturn true;\n \t\t}\n \t\treturn false;",
    "output": "Fix add example script for resources rename"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/impl/AnnotatedCodeWriter.java b/jadx-core/src/main/java/jadx/api/impl/AnnotatedCodeWriter.java\n--- a/jadx-core/src/main/java/jadx/api/impl/AnnotatedCodeWriter.java\n+++ b/jadx-core/src/main/java/jadx/api/impl/AnnotatedCodeWriter.java\n@@ -154,7 +154,6 @@ private void attachSourceLine(int decompiledLine, int sourceLine) {\n \n \t@Override\n \tpublic ICodeInfo finish() {\n-\t\tprocessDefinitionAnnotations();\n \t\tvalidateAnnotations();\n \t\tString code = buf.toString();\n \t\tbuf = null;\n@@ -166,18 +165,6 @@ public Map<Integer, ICodeAnnotation> getRawAnnotations() {\n \t\treturn annotations;\n \t}\n \n-\tprivate void processDefinitionAnnotations() {\n-\t\tif (!annotations.isEmpty()) {\n-\t\t\tannotations.forEach((k, v) -> {\n-\t\t\t\tif (v instanceof NodeDeclareRef) {\n-\t\t\t\t\tNodeDeclareRef declareRef = (NodeDeclareRef) v;\n-\t\t\t\t\tdeclareRef.setDefPos(k);\n-\t\t\t\t\tdeclareRef.getNode().setDefPosition(k);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\t}\n-\n \tprivate void validateAnnotations() {\n \t\tif (annotations.isEmpty()) {\n \t\t\treturn;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -23,6 +23,8 @@\n import jadx.api.JadxArgs;\n import jadx.api.JavaClass;\n import jadx.api.impl.SimpleCodeInfo;\n+import jadx.api.metadata.ICodeAnnotation;\n+import jadx.api.metadata.annotations.NodeDeclareRef;\n import jadx.api.plugins.input.data.IClassData;\n import jadx.api.plugins.input.data.IFieldData;\n import jadx.api.plugins.input.data.IMethodData;\n@@ -312,6 +314,8 @@ public ICodeInfo decompile() {\n \t\treturn decompile(true);\n \t}\n \n+\tprivate static final Object DECOMPILE_WITH_MODE_SYNC = new Object();\n+\n \t/**\n \t * WARNING: Slow operation! Use with caution!\n \t */\n@@ -320,15 +324,18 @@ public ICodeInfo decompileWithMode(DecompilationMode mode) {\n \t\tif (mode == baseMode) {\n \t\t\treturn decompile(true);\n \t\t}\n-\t\tJadxArgs args = root.getArgs();\n-\t\ttry {\n-\t\t\tunload();\n-\t\t\targs.setDecompilationMode(mode);\n-\t\t\tProcessClass process = new ProcessClass(args);\n-\t\t\tprocess.initPasses(root);\n-\t\t\treturn process.generateCode(this);\n-\t\t} finally {\n-\t\t\targs.setDecompilationMode(baseMode);\n+\t\tsynchronized (DECOMPILE_WITH_MODE_SYNC) {\n+\t\t\tJadxArgs args = root.getArgs();\n+\t\t\ttry {\n+\t\t\t\tunload();\n+\t\t\t\targs.setDecompilationMode(mode);\n+\t\t\t\tProcessClass process = new ProcessClass(args);\n+\t\t\t\tprocess.initPasses(root);\n+\t\t\t\treturn process.generateCode(this);\n+\t\t\t} finally {\n+\t\t\t\targs.setDecompilationMode(baseMode);\n+\t\t\t\tunload();\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -383,20 +390,44 @@ private synchronized ICodeInfo decompile(boolean searchInCache) {\n \t\t\t\treturn code;\n \t\t\t}\n \t\t}\n-\t\tICodeInfo codeInfo;\n+\t\tICodeInfo codeInfo = generateClassCode();\n+\t\tif (codeInfo != ICodeInfo.EMPTY) {\n+\t\t\tcodeCache.add(clsRawName, codeInfo);\n+\t\t}\n+\t\treturn codeInfo;\n+\t}\n+\n+\tprivate ICodeInfo generateClassCode() {\n \t\ttry {\n \t\t\tif (Consts.DEBUG) {\n \t\t\t\tLOG.debug(\"Decompiling class: {}\", this);\n \t\t\t}\n-\t\t\tcodeInfo = root.getProcessClasses().generateCode(this);\n+\t\t\tICodeInfo codeInfo = root.getProcessClasses().generateCode(this);\n+\t\t\tprocessDefinitionAnnotations(codeInfo);\n+\t\t\treturn codeInfo;\n \t\t} catch (Throwable e) {\n \t\t\taddError(\"Code generation failed\", e);\n-\t\t\tcodeInfo = new SimpleCodeInfo(Utils.getStackTrace(e));\n+\t\t\treturn new SimpleCodeInfo(Utils.getStackTrace(e));\n \t\t}\n-\t\tif (codeInfo != ICodeInfo.EMPTY) {\n-\t\t\tcodeCache.add(clsRawName, codeInfo);\n+\t}\n+\n+\t/**\n+\t * Save node definition positions found in code\n+\t */\n+\tprivate static void processDefinitionAnnotations(ICodeInfo codeInfo) {\n+\t\tMap<Integer, ICodeAnnotation> annotations = codeInfo.getCodeMetadata().getAsMap();\n+\t\tif (annotations.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tfor (Map.Entry<Integer, ICodeAnnotation> entry : annotations.entrySet()) {\n+\t\t\tICodeAnnotation ann = entry.getValue();\n+\t\t\tif (ann.getAnnType() == AnnType.DECLARATION) {\n+\t\t\t\tNodeDeclareRef declareRef = (NodeDeclareRef) ann;\n+\t\t\t\tint pos = entry.getKey();\n+\t\t\t\tdeclareRef.setDefPos(pos);\n+\t\t\t\tdeclareRef.getNode().setDefPosition(pos);\n+\t\t\t}\n \t\t}\n-\t\treturn codeInfo;\n \t}\n \n \t@Nullable\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java\n@@ -134,10 +134,22 @@ private synchronized void initLineNumbers() {\n \t\tcodeScrollPane.setLineNumbersEnabled(true);\n \t}\n \n+\tprivate static final LineNumberFormatter SIMPLE_LINE_FORMATTER = new LineNumberFormatter() {\n+\t\t@Override\n+\t\tpublic String format(int lineNumber) {\n+\t\t\treturn Integer.toString(lineNumber);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int getMaxLength(int maxLineNumber) {\n+\t\t\treturn SourceLineFormatter.getNumberLength(maxLineNumber);\n+\t\t}\n+\t};\n+\n \tprivate synchronized void applyLineFormatter() {\n \t\tLineNumberFormatter linesFormatter = useSourceLines\n \t\t\t\t? new SourceLineFormatter(codeArea.getCodeInfo())\n-\t\t\t\t: LineNumberList.DEFAULT_LINE_NUMBER_FORMATTER;\n+\t\t\t\t: SIMPLE_LINE_FORMATTER;\n \t\tcodeScrollPane.getGutter().setLineNumberFormatter(linesFormatter);\n \t}\n \n@@ -170,15 +182,13 @@ private boolean canShowDebugLines() {\n \t}\n \n \tprivate void initLinesModeSwitch() {\n-\t\tif (canShowDebugLines()) {\n-\t\t\tMousePressedHandler lineModeSwitch = new MousePressedHandler(ev -> {\n-\t\t\t\tuseSourceLines = !useSourceLines;\n-\t\t\t\tapplyLineFormatter();\n-\t\t\t});\n-\t\t\tfor (Component gutterComp : codeScrollPane.getGutter().getComponents()) {\n-\t\t\t\tif (gutterComp instanceof LineNumberList) {\n-\t\t\t\t\tgutterComp.addMouseListener(lineModeSwitch);\n-\t\t\t\t}\n+\t\tMousePressedHandler lineModeSwitch = new MousePressedHandler(ev -> {\n+\t\t\tuseSourceLines = !useSourceLines;\n+\t\t\tapplyLineFormatter();\n+\t\t});\n+\t\tfor (Component gutterComp : codeScrollPane.getGutter().getComponents()) {\n+\t\t\tif (gutterComp instanceof LineNumberList) {\n+\t\t\t\tgutterComp.addMouseListener(lineModeSwitch);\n \t\t\t}\n \t\t}\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/SourceLineFormatter.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/SourceLineFormatter.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/SourceLineFormatter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/SourceLineFormatter.java\n@@ -32,8 +32,10 @@ private static int calcMaxLength(ICodeInfo codeInfo) {\n \t\t\t\t.values().stream()\n \t\t\t\t.mapToInt(Integer::intValue)\n \t\t\t\t.max().orElse(1);\n-\t\t// maxLine can be anything including zero and negative numbers,\n-\t\t// so use safe 'stringify' method instead faster 'Math.log10'\n-\t\treturn Integer.toString(maxLine).length();\n+\t\treturn getNumberLength(maxLine);\n+\t}\n+\n+\tpublic static int getNumberLength(int num) {\n+\t\treturn num < 10 ? 1 : 1 + (int) Math.log10(num);\n \t}\n }",
    "output": "Fix don't apply node positions and prevent eager loading for custom decompile modes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -193,10 +193,8 @@ private void parseNameSpaceEnd() throws IOException {\n \t\t\tdie(\"NAMESPACE end is not 0x10 big\");\n \t\t}\n \t\tint dataSize = is.readInt32();\n-\t\tif (dataSize > 0x18) {\n-\t\t\tLOG.warn(\"Invalid namespace size\");\n-\t\t} else if (dataSize < 0x18) {\n-\t\t\tdie(\"NAMESPACE header chunk is not 0x18 big\");\n+\t\tif (dataSize != 0x18) {\n+\t\t\tLOG.warn(\"Invalid namespace end size\");\n \t\t}\n \t\tint endLineNumber = is.readInt32();\n \t\tint comment = is.readInt32();\n@@ -246,7 +244,8 @@ private void parseElement() throws IOException {\n \t\t\tdie(\"ELEMENT HEADER SIZE is not 0x10\");\n \t\t}\n \t\t// TODO: Check element chunk size\n-\t\tis.readInt32();\n+\t\tlong startPos = is.getPos();\n+\t\tint elementSize = is.readInt32();\n \t\tint elementBegLineNumber = is.readInt32();\n \t\tint comment = is.readInt32();\n \t\tint startNS = is.readInt32();\n@@ -291,6 +290,10 @@ private void parseElement() throws IOException {\n \t\tfor (int i = 0; i < attributeCount; i++) {\n \t\t\tparseAttribute(i, attrNewLine, attrCache);\n \t\t}\n+\t\tlong endPos = is.getPos();\n+\t\tif (endPos - startPos + 0x4 < elementSize) {\n+\t\t\tis.skip(elementSize - (endPos - startPos + 0x4));\n+\t\t}\n \t}\n \n \tprivate void parseAttribute(int i, boolean newLine, Set<String> attrCache) throws IOException {",
    "output": "Fix resolve some manifest decode errors * The elementSize may be larger than the actual size of the element chunk. * end namespace chunk size can be any value. * keep at least a warning."
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n@@ -272,10 +272,15 @@ public String getWordUnderCaret() {\n \n \tpublic @Nullable String getWordByPosition(int offset) {\n \t\tToken token = getWordTokenAtOffset(offset);\n-\t\tif (token != null) {\n-\t\t\treturn token.getLexeme();\n+\t\tif (token == null) {\n+\t\t\treturn null;\n \t\t}\n-\t\treturn null;\n+\t\tString str = token.getLexeme();\n+\t\tint len = str.length();\n+\t\tif (len > 2 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\")) {\n+\t\t\treturn str.substring(1, len - 1);\n+\t\t}\n+\t\treturn str;\n \t}\n \n \t/**",
    "output": "Fix copy strings without quotes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -303,7 +303,7 @@ private void parseAttribute(int i, boolean newLine, Set<String> attrCache) throw\n \n \t\tString shortNsName = null;\n \t\tif (attributeNS != -1) {\n-\t\t\tshortNsName = getAttributeNS(attributeNS);\n+\t\t\tshortNsName = getAttributeNS(attributeNS, newLine);\n \t\t}\n \t\tString attrName = getValidTagAttributeName(getAttributeName(attributeName));\n \t\tString attrFullName = shortNsName != null ? shortNsName + \":\" + attrName : attrName;\n@@ -340,7 +340,7 @@ private void parseAttribute(int i, boolean newLine, Set<String> attrCache) throw\n \t\twriter.add('\"');\n \t}\n \n-\tprivate String getAttributeNS(int attributeNS) {\n+\tprivate String getAttributeNS(int attributeNS, boolean newLine) {\n \t\tString attrUrl = getString(attributeNS);\n \t\tif (attrUrl == null || attrUrl.isEmpty()) {\n \t\t\tif (isResInternalId(attributeNS)) {\n@@ -351,12 +351,12 @@ private String getAttributeNS(int attributeNS) {\n \t\t}\n \t\tString attrName = nsMap.get(attrUrl);\n \t\tif (attrName == null) {\n-\t\t\tattrName = generateNameForNS(attrUrl);\n+\t\t\tattrName = generateNameForNS(attrUrl, newLine);\n \t\t}\n \t\treturn attrName;\n \t}\n \n-\tprivate String generateNameForNS(String attrUrl) {\n+\tprivate String generateNameForNS(String attrUrl, boolean newLine) {\n \t\tString attrName;\n \t\tif (ANDROID_NS_URL.equals(attrUrl)) {\n \t\t\tattrName = ANDROID_NS_VALUE;\n@@ -372,6 +372,11 @@ private String generateNameForNS(String attrUrl) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tif (newLine) {\n+\t\t\twriter.startLine().addIndent();\n+\t\t} else {\n+\t\t\twriter.add(' ');\n+\t\t}\n \t\twriter.add(\"xmlns:\").add(attrName).add(\"=\\\"\").add(attrUrl).add(\"\\\" \");\n \t\treturn attrName;\n \t}",
    "output": "Fix add indents for namespace declarations Co-authored-by: bagipro <bugi@bugi>"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -286,43 +286,49 @@ private void parseElement() throws IOException {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tSet<String> attrCache = new HashSet<>();\n \t\tboolean attrNewLine = attributeCount != 1 && this.attrNewLine;\n \t\tfor (int i = 0; i < attributeCount; i++) {\n-\t\t\tparseAttribute(i, attrNewLine);\n+\t\t\tparseAttribute(i, attrNewLine, attrCache);\n \t\t}\n \t}\n \n-\tprivate void parseAttribute(int i, boolean newLine) throws IOException {\n+\tprivate void parseAttribute(int i, boolean newLine, Set<String> attrCache) throws IOException {\n \t\tint attributeNS = is.readInt32();\n \t\tint attributeName = is.readInt32();\n \t\tint attributeRawValue = is.readInt32();\n \t\tis.skip(3);\n \t\tint attrValDataType = is.readInt8();\n \t\tint attrValData = is.readInt32();\n \n-\t\tif (newLine) {\n-\t\t\twriter.startLine().addIndent();\n-\t\t} else {\n-\t\t\twriter.add(' ');\n-\t\t}\n \t\tString shortNsName = null;\n \t\tif (attributeNS != -1) {\n \t\t\tshortNsName = getAttributeNS(attributeNS);\n-\t\t\twriter.add(shortNsName).add(':');\n \t\t}\n \t\tString attrName = getValidTagAttributeName(getAttributeName(attributeName));\n-\t\twriter.add(attrName).add(\"=\\\"\");\n+\t\tString attrFullName = shortNsName != null ? shortNsName + \":\" + attrName : attrName;\n+\t\t// do not dump duplicated values\n+\t\tif (XmlDeobf.isDuplicatedAttr(attrFullName, attrCache)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (newLine) {\n+\t\t\twriter.startLine().addIndent();\n+\t\t} else {\n+\t\t\twriter.add(' ');\n+\t\t}\n+\t\twriter.add(attrFullName).add(\"=\\\"\");\n \t\tString decodedAttr = ManifestAttributes.getInstance().decode(attrName, attrValData);\n \t\tif (decodedAttr != null) {\n \t\t\tmemorizePackageName(attrName, decodedAttr);\n-\t\t\tif (isDeobfCandidateAttr(shortNsName, attrName)) {\n+\t\t\tif (isDeobfCandidateAttr(attrFullName)) {\n \t\t\t\tdecodedAttr = deobfClassName(decodedAttr);\n \t\t\t}\n \t\t\tattachClassNode(writer, attrName, decodedAttr);\n \t\t\twriter.add(StringUtils.escapeXML(decodedAttr));\n \t\t} else {\n \t\t\tdecodeAttribute(attributeNS, attrValDataType, attrValData,\n-\t\t\t\t\tshortNsName, attrName);\n+\t\t\t\t\tattrFullName);\n \t\t}\n \t\tif (shortNsName != null && shortNsName.equals(\"android\")) {\n \t\t\tif (attrName.equals(\"pathData\")) {\n@@ -402,7 +408,7 @@ private String getString(int strId) {\n \t}\n \n \tprivate void decodeAttribute(int attributeNS, int attrValDataType, int attrValData,\n-\t\t\tString shortNsName, String attrName) {\n+\t\t\tString attrFullName) {\n \t\tif (attrValDataType == TYPE_REFERENCE) {\n \t\t\t// reference custom processing\n \t\t\tString resName = resNames.get(attrValData);\n@@ -424,11 +430,11 @@ private void decodeAttribute(int attributeNS, int attrValDataType, int attrValDa\n \t\t\t}\n \t\t} else {\n \t\t\tString str = valuesParser.decodeValue(attrValDataType, attrValData);\n-\t\t\tmemorizePackageName(attrName, str);\n-\t\t\tif (isDeobfCandidateAttr(shortNsName, attrName)) {\n+\t\t\tmemorizePackageName(attrFullName, str);\n+\t\t\tif (isDeobfCandidateAttr(attrFullName)) {\n \t\t\t\tstr = deobfClassName(str);\n \t\t\t}\n-\t\t\tattachClassNode(writer, attrName, str);\n+\t\t\tattachClassNode(writer, attrFullName, str);\n \t\t\twriter.add(str != null ? StringUtils.escapeXML(str) : \"null\");\n \t\t}\n \t}\n@@ -487,11 +493,11 @@ private static String generateTagAttrName() {\n \t\treturn sb.toString();\n \t}\n \n-\tprivate void attachClassNode(ICodeWriter writer, String attrName, String clsName) {\n+\tprivate void attachClassNode(ICodeWriter writer, String attrFullName, String clsName) {\n \t\tif (!writer.isMetadataSupported()) {\n \t\t\treturn;\n \t\t}\n-\t\tif (clsName == null || !attrName.equals(\"name\")) {\n+\t\tif (clsName == null || !attrFullName.equals(\"android:name\")) {\n \t\t\treturn;\n \t\t}\n \t\tString clsFullName;\n@@ -517,18 +523,12 @@ private String deobfClassName(String className) {\n \t\treturn className;\n \t}\n \n-\tprivate boolean isDeobfCandidateAttr(String shortNsName, String attrName) {\n-\t\tString fullName;\n-\t\tif (shortNsName != null) {\n-\t\t\tfullName = shortNsName + ':' + attrName;\n-\t\t} else {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn \"android:name\".equals(fullName);\n+\tprivate boolean isDeobfCandidateAttr(String attrFullName) {\n+\t\treturn \"android:name\".equals(attrFullName);\n \t}\n \n-\tprivate void memorizePackageName(String attrName, String attrValue) {\n-\t\tif (\"manifest\".equals(currentTag) && \"package\".equals(attrName)) {\n+\tprivate void memorizePackageName(String attrFullName, String attrValue) {\n+\t\tif (\"manifest\".equals(currentTag) && \"package\".equals(attrFullName)) {\n \t\t\tappPackageName = attrValue;\n \t\t}\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ProtoXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ProtoXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ProtoXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ProtoXMLParser.java\n@@ -3,8 +3,10 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n import java.util.Random;\n+import java.util.Set;\n \n import com.android.aapt.Resources.XmlAttribute;\n import com.android.aapt.Resources.XmlElement;\n@@ -58,9 +60,12 @@ private void decode(XmlElement e) throws IOException {\n \t\tfor (int i = 0; i < e.getNamespaceDeclarationCount(); i++) {\n \t\t\tdecode(e.getNamespaceDeclaration(i));\n \t\t}\n+\n+\t\tSet<String> attrCache = new HashSet<>();\n \t\tfor (int i = 0; i < e.getAttributeCount(); i++) {\n-\t\t\tdecode(e.getAttribute(i));\n+\t\t\tdecode(e.getAttribute(i), attrCache);\n \t\t}\n+\n \t\tif (e.getChildCount() > 0) {\n \t\t\twriter.add('>');\n \t\t\twriter.incIndent();\n@@ -76,11 +81,13 @@ private void decode(XmlElement e) throws IOException {\n \t\t}\n \t}\n \n-\tprivate void decode(XmlAttribute a) {\n-\t\twriter.add(' ');\n+\tprivate void decode(XmlAttribute a, Set<String> attrCache) {\n \t\tString name = getAttributeFullName(a);\n+\t\tif (XmlDeobf.isDuplicatedAttr(name, attrCache)) {\n+\t\t\treturn;\n+\t\t}\n \t\tString value = deobfClassName(getAttributeValue(a));\n-\t\twriter.add(name).add(\"=\\\"\").add(StringUtils.escapeXML(value)).add('\\\"');\n+\t\twriter.add(' ').add(name).add(\"=\\\"\").add(StringUtils.escapeXML(value)).add('\\\"');\n \t\tmemorizePackageName(name, value);\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/XmlDeobf.java b/jadx-core/src/main/java/jadx/core/xmlgen/XmlDeobf.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/XmlDeobf.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/XmlDeobf.java\n@@ -1,5 +1,7 @@\n package jadx.core.xmlgen;\n \n+import java.util.Set;\n+\n import org.jetbrains.annotations.Nullable;\n \n import jadx.core.dex.info.ClassInfo;\n@@ -30,4 +32,8 @@ public static String deobfClassName(RootNode root, String potentialClassName, St\n \t\t}\n \t\treturn classInfo.getAliasFullName();\n \t}\n+\n+\tpublic static boolean isDuplicatedAttr(String attrFullName, Set<String> attrCache) {\n+\t\treturn !attrCache.add(attrFullName);\n+\t}\n }",
    "output": "Fix avoid duplicated XML attributes Co-authored-by: bagipro <bugi@bugi>"
  },
  {
    "input": "diff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java\n@@ -78,7 +78,7 @@ private List<DexReader> load(@Nullable File file, InputStream inputStream, Strin\n \n \tpublic DexReader loadDexReader(String fileName, byte[] content) {\n \t\tif (options.isVerifyChecksum()) {\n-\t\t\tDexCheckSum.verify(content);\n+\t\t\tDexCheckSum.verify(content, fileName);\n \t\t}\n \t\treturn new DexReader(getNextUniqId(), fileName, content);\n \t}\n\ndiff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/utils/DexCheckSum.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/utils/DexCheckSum.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/utils/DexCheckSum.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/utils/DexCheckSum.java\n@@ -9,17 +9,18 @@\n \n public class DexCheckSum {\n \n-\tpublic static void verify(byte[] content) {\n+\tpublic static void verify(byte[] content, String fileName) {\n \t\tint len = content.length;\n \t\tif (len < 12) {\n-\t\t\tthrow new DexException(\"Dex file truncated, length: \" + len);\n+\t\t\tthrow new DexException(\"Dex file truncated, length: \" + len + \", file: \" + fileName);\n \t\t}\n \t\tint checksum = ByteBuffer.wrap(content, 8, 4).order(LITTLE_ENDIAN).getInt();\n \t\tAdler32 adler32 = new Adler32();\n \t\tadler32.update(content, 12, len - 12);\n \t\tint fileChecksum = (int) (adler32.getValue());\n \t\tif (checksum != fileChecksum) {\n-\t\t\tthrow new DexException(String.format(\"Bad checksum: 0x%08x, expected: 0x%08x\", fileChecksum, checksum));\n+\t\t\tthrow new DexException(String.format(\"Bad dex file checksum: 0x%08x, expected: 0x%08x, file: %s\",\n+\t\t\t\t\tfileChecksum, checksum, fileName));\n \t\t}\n \t}\n }",
    "output": "Fix improve error report message for invalid dex checksum"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java\n@@ -1,7 +1,6 @@\n package jadx.core.dex.visitors;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n \n import org.jetbrains.annotations.Nullable;\n@@ -16,16 +15,12 @@\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.instructions.InsnType;\n-import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.trycatch.CatchAttr;\n import jadx.core.dex.trycatch.ExcHandlerAttr;\n import jadx.core.dex.trycatch.ExceptionHandler;\n-import jadx.core.dex.visitors.typeinference.TypeCompare;\n-import jadx.core.dex.visitors.typeinference.TypeCompareEnum;\n import jadx.core.utils.exceptions.JadxException;\n-import jadx.core.utils.exceptions.JadxRuntimeException;\n \n import static jadx.core.dex.visitors.ProcessInstructionsVisitor.getNextInsnOffset;\n \n@@ -122,7 +117,6 @@ private static List<ExceptionHandler> convertToHandlers(MethodNode mth, ICatch c\n \t\tif (allHandlerOffset >= 0) {\n \t\t\tUtils.addToList(list, createHandler(mth, insnByOffset, allHandlerOffset, null));\n \t\t}\n-\t\tcheckAndFilterHandlers(mth, list);\n \t\treturn list;\n \t}\n \n@@ -149,45 +143,6 @@ private static ExceptionHandler createHandler(MethodNode mth, InsnNode[] insnByO\n \t\treturn handler;\n \t}\n \n-\tprivate static void checkAndFilterHandlers(MethodNode mth, List<ExceptionHandler> list) {\n-\t\tif (list.size() <= 1) {\n-\t\t\treturn;\n-\t\t}\n-\t\t// Remove shadowed handlers (with same or narrow type compared to previous)\n-\t\tTypeCompare typeCompare = mth.root().getTypeCompare();\n-\t\tIterator<ExceptionHandler> it = list.iterator();\n-\t\tArgType maxType = null;\n-\t\twhile (it.hasNext()) {\n-\t\t\tExceptionHandler handler = it.next();\n-\t\t\tArgType maxCatch = maxCatchFromHandler(handler, typeCompare);\n-\t\t\tif (maxType == null) {\n-\t\t\t\tmaxType = maxCatch;\n-\t\t\t} else {\n-\t\t\t\tTypeCompareEnum result = typeCompare.compareObjects(maxType, maxCatch);\n-\t\t\t\tif (result.isWiderOrEqual()) {\n-\t\t\t\t\tif (Consts.DEBUG_EXC_HANDLERS) {\n-\t\t\t\t\t\tLOG.debug(\"Removed shadowed catch handler: {}, from list: {}\", handler, list);\n-\t\t\t\t\t}\n-\t\t\t\t\tit.remove();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static ArgType maxCatchFromHandler(ExceptionHandler handler, TypeCompare typeCompare) {\n-\t\tList<ClassInfo> catchTypes = handler.getCatchTypes();\n-\t\tif (catchTypes.isEmpty()) {\n-\t\t\treturn ArgType.THROWABLE;\n-\t\t}\n-\t\tif (catchTypes.size() == 1) {\n-\t\t\treturn catchTypes.get(0).getType();\n-\t\t}\n-\t\treturn catchTypes.stream()\n-\t\t\t\t.map(ClassInfo::getType)\n-\t\t\t\t.max(typeCompare.getComparator())\n-\t\t\t\t.orElseThrow(() -> new JadxRuntimeException(\"Failed to get max type from catch list: \" + catchTypes));\n-\t}\n-\n \tprivate static InsnNode insertNOP(InsnNode[] insnByOffset, int offset) {\n \t\tInsnNode nop = new InsnNode(InsnType.NOP, 0);\n \t\tnop.setOffset(offset);",
    "output": "Fix don't remove exception handlers"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n@@ -600,7 +600,7 @@ private static void removeUnusedExcHandlers(MethodNode mth, List<TryCatchBlockAt\n \t\tfor (ExceptionHandler eh : mth.getExceptionHandlers()) {\n \t\t\tboolean notProcessed = true;\n \t\t\tBlockNode handlerBlock = eh.getHandlerBlock();\n-\t\t\tif (blocks.get(handlerBlock)) {\n+\t\t\tif (handlerBlock == null || blocks.get(handlerBlock)) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tfor (TryCatchBlockAttr tcb : tryBlocks) {",
    "output": "Fix NPE in unused EcxHandler block removal code"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -40,6 +40,7 @@ public class BinaryXMLParser extends CommonBinaryParser {\n \tprivate final Map<Integer, String> resNames;\n \tprivate Map<String, String> nsMap;\n \tprivate Set<String> nsMapGenerated;\n+\tprivate Set<String> definedNamespaces;\n \tprivate final Map<String, String> tagAttrDeobfNames = new HashMap<>();\n \n \tprivate ICodeWriter writer;\n@@ -78,11 +79,13 @@ public synchronized ICodeInfo parse(InputStream inputStream) throws IOException\n \t\t}\n \t\tnsMapGenerated = new HashSet<>();\n \t\tnsMap = new HashMap<>();\n+\t\tdefinedNamespaces = new HashSet<>();\n \t\twriter = rootNode.makeCodeWriter();\n \t\twriter.add(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\");\n \t\tfirstElement = true;\n \t\tdecode();\n \t\tnsMap = null;\n+\t\tdefinedNamespaces = null;\n \t\tICodeInfo codeInfo = writer.finish();\n \t\tthis.classNameCache = null; // reset class name cache\n \t\treturn codeInfo;\n@@ -269,15 +272,18 @@ private void parseElement() throws IOException {\n \t\tint idIndex = is.readInt16();\n \t\tint classIndex = is.readInt16();\n \t\tint styleIndex = is.readInt16();\n-\t\tif (\"manifest\".equals(currentTag) || writer.getIndent() == 0) {\n+\t\tif (\"manifest\".equals(currentTag) || definedNamespaces.size() != nsMap.size()) {\n \t\t\tfor (Map.Entry<String, String> entry : nsMap.entrySet()) {\n-\t\t\t\tString nsValue = getValidTagAttributeName(entry.getValue());\n-\t\t\t\twriter.add(\" xmlns\");\n-\t\t\t\tif (nsValue != null && !nsValue.trim().isEmpty()) {\n-\t\t\t\t\twriter.add(':');\n-\t\t\t\t\twriter.add(nsValue);\n+\t\t\t\tif (!definedNamespaces.contains(entry.getKey())) {\n+\t\t\t\t\tdefinedNamespaces.add(entry.getKey());\n+\t\t\t\t\tString nsValue = getValidTagAttributeName(entry.getValue());\n+\t\t\t\t\twriter.add(\" xmlns\");\n+\t\t\t\t\tif (nsValue != null && !nsValue.trim().isEmpty()) {\n+\t\t\t\t\t\twriter.add(':');\n+\t\t\t\t\t\twriter.add(nsValue);\n+\t\t\t\t\t}\n+\t\t\t\t\twriter.add(\"=\\\"\").add(StringUtils.escapeXML(entry.getKey())).add('\"');\n \t\t\t\t}\n-\t\t\t\twriter.add(\"=\\\"\").add(StringUtils.escapeXML(entry.getKey())).add('\"');\n \t\t\t}\n \t\t}\n \t\tboolean attrNewLine = attributeCount != 1 && this.attrNewLine;",
    "output": "Fix add missing namespace declarations * fix(res): add missing namespace declarations * remove `writer.getIndent() == 0` --------- Co-authored-by: skylot <118523+skylot@users.noreply.github.com>"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -421,18 +421,19 @@ public void addField(ICodeWriter code, FieldNode f) {\n \t\tif (f.contains(AFlag.DONT_GENERATE)) {\n \t\t\treturn;\n \t\t}\n+\t\tif (f.contains(JadxAttrType.ANNOTATION_LIST) || f.contains(AType.JADX_COMMENTS) || f.getFieldInfo().hasAlias()) {\n+\t\t\tcode.newLine();\n+\t\t}\n \t\tif (Consts.DEBUG_USAGE) {\n \t\t\taddFieldUsageInfo(code, f);\n \t\t}\n+\t\tif (f.getFieldInfo().hasAlias()) {\n+\t\t\tCodeGenUtils.addRenamedComment(code, f, f.getName());\n+\t\t}\n \t\tCodeGenUtils.addComments(code, f);\n \t\tannotationGen.addForField(code, f);\n \n-\t\tboolean addInfoComments = f.checkCommentsLevel(CommentsLevel.INFO);\n-\t\tif (f.getFieldInfo().hasAlias() && addInfoComments) {\n-\t\t\tcode.newLine();\n-\t\t\tCodeGenUtils.addRenamedComment(code, f, f.getName());\n-\t\t}\n-\t\tcode.startLine(f.getAccessFlags().makeString(addInfoComments));\n+\t\tcode.startLine(f.getAccessFlags().makeString(f.checkCommentsLevel(CommentsLevel.INFO)));\n \t\tuseType(code, f.getType());\n \t\tcode.add(' ');\n \t\tcode.attachDefinition(f);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/UserRenames.java b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/UserRenames.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/UserRenames.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/UserRenames.java\n@@ -18,6 +18,7 @@\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.PackageNode;\n import jadx.core.dex.nodes.RootNode;\n+import jadx.core.utils.StringUtils;\n \n public class UserRenames {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(UserRenames.class);\n@@ -57,7 +58,12 @@ private static void applyRename(ClassNode cls, ICodeRename rename) {\n \t\t\tcase FIELD:\n \t\t\t\tFieldNode fieldNode = cls.searchFieldByShortId(nodeRef.getShortId());\n \t\t\t\tif (fieldNode == null) {\n-\t\t\t\t\tLOG.warn(\"Field reference not found: {}\", nodeRef);\n+\t\t\t\t\tString fieldName = StringUtils.getPrefix(nodeRef.getShortId(), \":\");\n+\t\t\t\t\tString fieldSign = cls.getFields().stream()\n+\t\t\t\t\t\t\t.filter(f -> f.getFieldInfo().getName().equals(fieldName))\n+\t\t\t\t\t\t\t.map(f -> f.getFieldInfo().getShortId())\n+\t\t\t\t\t\t\t.collect(Collectors.joining());\n+\t\t\t\t\tLOG.warn(\"Field reference not found: {}. Fields with same name: {}\", nodeRef, fieldSign);\n \t\t\t\t} else {\n \t\t\t\t\tfieldNode.rename(rename.getNewName());\n \t\t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/CodeGenUtils.java b/jadx-core/src/main/java/jadx/core/utils/CodeGenUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/CodeGenUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/CodeGenUtils.java\n@@ -124,8 +124,7 @@ public static void addRenamedComment(ICodeWriter code, NotificationAttrNode node\n \t\tcode.startLine(\"/* renamed from: \").add(origName);\n \t\tRenameReasonAttr renameReasonAttr = node.get(AType.RENAME_REASON);\n \t\tif (renameReasonAttr != null) {\n-\t\t\tcode.add(\"  reason: \");\n-\t\t\tcode.add(renameReasonAttr.getDescription());\n+\t\t\tcode.add(\", reason: \").add(renameReasonAttr.getDescription());\n \t\t}\n \t\tcode.add(\" */\");\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/StringUtils.java b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n@@ -374,6 +374,14 @@ public static String removeSuffix(String str, String suffix) {\n \t\treturn str;\n \t}\n \n+\tpublic static @Nullable String getPrefix(String str, String delim) {\n+\t\tint idx = str.indexOf(delim);\n+\t\tif (idx != -1) {\n+\t\t\treturn str.substring(0, idx);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \tpublic static String getDateText() {\n \t\treturn new SimpleDateFormat(\"HH:mm:ss\").format(new Date());\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/rename/TestFieldRenameFormat.java b/jadx-core/src/test/java/jadx/tests/integration/rename/TestFieldRenameFormat.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/rename/TestFieldRenameFormat.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/rename/TestFieldRenameFormat.java\n@@ -0,0 +1,66 @@\n+package jadx.tests.integration.rename;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+import jadx.api.data.ICodeRename;\n+import jadx.api.data.IJavaNodeRef.RefType;\n+import jadx.api.data.impl.JadxCodeData;\n+import jadx.api.data.impl.JadxCodeRename;\n+import jadx.api.data.impl.JadxNodeRef;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestFieldRenameFormat extends IntegrationTest {\n+\n+\t@SuppressWarnings({ \"unused\", \"NonSerializableClassWithSerialVersionUID\" })\n+\tpublic static class TestCls {\n+\t\tprivate static final long serialVersionUID = -2619335455376089892L;\n+\t\t@SerializedName(\"id\")\n+\t\tprivate int b;\n+\t\t@SerializedName(\"title\")\n+\t\tprivate String c;\n+\t\t@SerializedName(\"images\")\n+\t\tprivate List<String> d;\n+\t\t@SerializedName(\"authors\")\n+\t\tprivate List<String> e;\n+\t\t@SerializedName(\"description\")\n+\t\tprivate String f;\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\n+\t\tString baseClsId = TestCls.class.getName();\n+\t\tList<ICodeRename> renames = Arrays.asList(\n+\t\t\t\tfieldRename(baseClsId, \"b:I\", \"id\"),\n+\t\t\t\tfieldRename(baseClsId, \"c:Ljava/lang/String;\", \"title\"),\n+\t\t\t\tfieldRename(baseClsId, \"e:Ljava/util/List;\", \"authors\"));\n+\n+\t\tJadxCodeData codeData = new JadxCodeData();\n+\t\tcodeData.setRenames(renames);\n+\t\tgetArgs().setCodeData(codeData);\n+\t\tgetArgs().setDeobfuscationOn(false);\n+\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"private int id;\")\n+\t\t\t\t.containsOne(\"private List<String> authors;\")\n+\t\t\t\t.containsLines(1,\n+\t\t\t\t\t\t\"\",\n+\t\t\t\t\t\t\"/* renamed from: c */\",\n+\t\t\t\t\t\t\"@SerializedName(\\\"title\\\")\",\n+\t\t\t\t\t\t\"private String title;\",\n+\t\t\t\t\t\t\"\");\n+\t}\n+\n+\tprivate static JadxCodeRename fieldRename(String baseClsId, String shortId, String id) {\n+\t\treturn new JadxCodeRename(new JadxNodeRef(RefType.FIELD, baseClsId, shortId), id);\n+\t}\n+}",
    "output": "Use empty line before field in correct place"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java\n@@ -139,14 +139,12 @@ public void clearAttributes() {\n \t\tstorage = EMPTY_ATTR_STORAGE;\n \t}\n \n-\t/**\n-\t * Remove all attribute\n-\t */\n \tpublic void unloadAttributes() {\n \t\tif (storage == EMPTY_ATTR_STORAGE) {\n \t\t\treturn;\n \t\t}\n \t\tstorage.unloadAttributes();\n+\t\tstorage.clearFlags();\n \t\tunloadIfEmpty();\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java\n@@ -102,6 +102,10 @@ public void remove(AFlag flag) {\n \t\tflags.remove(flag);\n \t}\n \n+\tpublic void clearFlags() {\n+\t\tflags.clear();\n+\t}\n+\n \tpublic <T extends IJadxAttribute> void remove(IJadxAttrType<T> type) {\n \t\tif (!attributes.isEmpty()) {\n \t\t\twriteAttributes(map -> map.remove(type));\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -432,7 +432,7 @@ public void unload() {\n \t\t}\n \t\tmethods.forEach(MethodNode::unload);\n \t\tinnerClasses.forEach(ClassNode::unload);\n-\t\tfields.forEach(FieldNode::unloadAttributes);\n+\t\tfields.forEach(FieldNode::unload);\n \t\tunloadAttributes();\n \t\tsetState(NOT_LOADED);\n \t\tthis.loadStage = LoadStage.NONE;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java\n@@ -38,6 +38,10 @@ public FieldNode(ClassNode cls, FieldInfo fieldInfo, int accessFlags) {\n \t\tthis.accFlags = new AccessInfo(accessFlags, AFType.FIELD);\n \t}\n \n+\tpublic void unload() {\n+\t\tunloadAttributes();\n+\t}\n+\n \tpublic void updateType(ArgType type) {\n \t\tthis.type = type;\n \t}",
    "output": "Fix clear node flags for custom decompilation mode"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n@@ -41,6 +41,7 @@\n import jadx.core.utils.BlockUtils;\n import jadx.core.utils.InsnRemover;\n import jadx.core.utils.ListUtils;\n+import jadx.core.utils.blocks.BlockSet;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public class BlockExceptionHandler {\n@@ -65,6 +66,10 @@ public static boolean process(MethodNode mth) {\n \t\t\tremoveMonitorExitFromExcHandler(mth, eh);\n \t\t}\n \t\tBlockProcessor.removeMarkedBlocks(mth);\n+\n+\t\tBlockSet sorted = new BlockSet(mth);\n+\t\tBlockUtils.dfsVisit(mth, sorted::set);\n+\t\tremoveUnusedExcHandlers(mth, tryBlocks, sorted);\n \t\treturn true;\n \t}\n \n@@ -586,4 +591,27 @@ private static int compareByTypeAndName(Comparator<ArgType> comparator, ClassInf\n \t\t}\n \t\treturn r;\n \t}\n+\n+\t/**\n+\t * Remove excHandlers that were not used when connecting.\n+\t * Check first if the blocks are unreachable.\n+\t */\n+\tprivate static void removeUnusedExcHandlers(MethodNode mth, List<TryCatchBlockAttr> tryBlocks, BlockSet blocks) {\n+\t\tfor (ExceptionHandler eh : mth.getExceptionHandlers()) {\n+\t\t\tboolean notProcessed = true;\n+\t\t\tBlockNode handlerBlock = eh.getHandlerBlock();\n+\t\t\tif (blocks.get(handlerBlock)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tfor (TryCatchBlockAttr tcb : tryBlocks) {\n+\t\t\t\tif (tcb.getHandlers().contains(handlerBlock)) {\n+\t\t\t\t\tnotProcessed = false;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (notProcessed) {\n+\t\t\t\tBlockProcessor.removeUnreachableBlock(handlerBlock, mth);\n+\t\t\t}\n+\t\t}\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n@@ -646,10 +646,24 @@ public static void removeMarkedBlocks(MethodNode mth) {\n \tprivate static void removeUnreachableBlocks(MethodNode mth) {\n \t\tSet<BlockNode> toRemove = new LinkedHashSet<>();\n \t\tfor (BlockNode block : mth.getBasicBlocks()) {\n-\t\t\tif (block.getPredecessors().isEmpty() && block != mth.getEnterBlock()) {\n-\t\t\t\tBlockSplitter.collectSuccessors(block, mth.getEnterBlock(), toRemove);\n-\t\t\t}\n+\t\t\tcomputeUnreachableFromBlock(toRemove, block, mth);\n+\t\t}\n+\t\tremoveFromMethod(toRemove, mth);\n+\t}\n+\n+\tpublic static void removeUnreachableBlock(BlockNode blockToRemove, MethodNode mth) {\n+\t\tSet<BlockNode> toRemove = new LinkedHashSet<>();\n+\t\tcomputeUnreachableFromBlock(toRemove, blockToRemove, mth);\n+\t\tremoveFromMethod(toRemove, mth);\n+\t}\n+\n+\tprivate static void computeUnreachableFromBlock(Set<BlockNode> toRemove, BlockNode block, MethodNode mth) {\n+\t\tif (block.getPredecessors().isEmpty() && block != mth.getEnterBlock()) {\n+\t\t\tBlockSplitter.collectSuccessors(block, mth.getEnterBlock(), toRemove);\n \t\t}\n+\t}\n+\n+\tprivate static void removeFromMethod(Set<BlockNode> toRemove, MethodNode mth) {\n \t\tif (toRemove.isEmpty()) {\n \t\t\treturn;\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestUnreachableCatch.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestUnreachableCatch.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestUnreachableCatch.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestUnreachableCatch.java\n@@ -0,0 +1,70 @@\n+package jadx.tests.integration.trycatch;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@SuppressWarnings(\"CommentedOutCode\")\n+public class TestUnreachableCatch extends SmaliTest {\n+\n+\t// @formatter:off\n+\t/*\n+\t\tprivate static Map<Uri, ByteBuffer> prepareFontData(Context context, FontInfo[] fonts,\n+\t\t\tCancellationSignal cancellationSignal) {\n+\t\tfinal HashMap<Uri, ByteBuffer> out = new HashMap<>();\n+\t\tfinal ContentResolver resolver = context.getContentResolver();\n+\n+\t\tfor (FontInfo font : fonts) {\n+\t\t\tif (font.getResultCode() != Columns.RESULT_CODE_OK) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tfinal Uri uri = font.getUri();\n+\t\t\tif (out.containsKey(uri)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tByteBuffer buffer = null;\n+\t\t\ttry (final ParcelFileDescriptor pfd =\n+\t\t\t\t\tresolver.openFileDescriptor(uri, \"r\", cancellationSignal)) {\n+\t\t\t\tif (pfd != null) {\n+\t\t\t\t\ttry (final FileInputStream fis =\n+\t\t\t\t\t\t\tnew FileInputStream(pfd.getFileDescriptor())) {\n+\t\t\t\t\t\tfinal FileChannel fileChannel = fis.getChannel();\n+\t\t\t\t\t\tfinal long size = fileChannel.size();\n+\t\t\t\t\t\tbuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, size);\n+\t\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\t\t// ignore\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} catch (IOException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\n+\t\t\t// TODO: try other approach?, e.g. read all contents instead of mmap.\n+\n+\t\t\tout.put(uri, buffer);\n+\t\t}\n+\t\treturn Collections.unmodifiableMap(out);\n+\t}\n+\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tallowWarnInCode();\n+\n+\t\tClassNode cls = getClassNodeFromSmali();\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"IOException\"));\n+\t\tassertThat(code, containsString(\"Collections.unmodifiableMap\"));\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestUnreachableCatch2.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestUnreachableCatch2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestUnreachableCatch2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestUnreachableCatch2.java\n@@ -0,0 +1,58 @@\n+package jadx.tests.integration.trycatch;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+@SuppressWarnings(\"CommentedOutCode\")\n+public class TestUnreachableCatch2 extends SmaliTest {\n+\n+\tpublic static class UnusedExceptionHandlers1 implements AutoCloseable {\n+\t\tpublic static void doSomething(final Object unused1, final Object[] array, final Object o1,\n+\t\t\t\tfinal Object o2, final Object unused2) {\n+\t\t\tfor (final Object item : array) {\n+\t\t\t\tByteBuffer buffer = null;\n+\t\t\t\ttry (final UnusedExceptionHandlers1 u = doSomething2(o1, \"\", o2)) {\n+\t\t\t\t\ttry (final FileInputStream fis = new FileInputStream(u.getFilename())) {\n+\t\t\t\t\t\tfinal FileChannel fileChannel = fis.getChannel();\n+\t\t\t\t\t\tbuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, 42);\n+\t\t\t\t\t} catch (final IOException e) {\n+\t\t\t\t\t\t// ignore\n+\t\t\t\t\t}\n+\t\t\t\t} catch (final IOException e) {\n+\t\t\t\t\t// ignore\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate String getFilename() {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprivate static UnusedExceptionHandlers1 doSomething2(final Object o1, final String s,\n+\t\t\t\tfinal Object o2) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void close() throws IOException {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\t// TODO: result code not compilable because of 'break' after 'throw'\n+\t\tdisableCompilation();\n+\t\tString code = getClassNode(UnusedExceptionHandlers1.class).getCode().toString();\n+\t\tassertThat(code, containsString(\"IOException\"));\n+\t}\n+}",
    "output": "Remove unused ExcHandlers blocks"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/TabComponent.java b/jadx-gui/src/main/java/jadx/gui/ui/TabComponent.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/TabComponent.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabComponent.java\n@@ -79,7 +79,7 @@ private void init() {\n \n \t\tMouseAdapter clickAdapter = new MouseAdapter() {\n \t\t\t@Override\n-\t\t\tpublic void mouseClicked(MouseEvent e) {\n+\t\t\tpublic void mousePressed(MouseEvent e) {\n \t\t\t\tif (SwingUtilities.isMiddleMouseButton(e)) {\n \t\t\t\t\ttabbedPane.closeCodePanel(contentPanel);\n \t\t\t\t} else if (SwingUtilities.isRightMouseButton(e)) {",
    "output": "Fix detecting tab click with mousePressed instead of mouseClicked"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourceFile.java b/jadx-core/src/main/java/jadx/api/ResourceFile.java\n--- a/jadx-core/src/main/java/jadx/api/ResourceFile.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java\n@@ -74,13 +74,20 @@ void setZipRef(ZipRef zipRef) {\n \t\tthis.zipRef = zipRef;\n \t}\n \n-\tpublic void setAlias(ResourceEntry ri) {\n-\t\tint index = name.lastIndexOf('.');\n-\t\tdeobfName = String.format(\"res/%s%s/%s%s\",\n-\t\t\t\tri.getTypeName(),\n-\t\t\t\tri.getConfig(),\n-\t\t\t\tri.getKeyName(),\n-\t\t\t\tindex == -1 ? \"\" : name.substring(index));\n+\tpublic boolean setAlias(ResourceEntry ri) {\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tsb.append(\"res/\").append(ri.getTypeName()).append(ri.getConfig());\n+\t\tsb.append(\"/\").append(ri.getKeyName());\n+\t\tint lastDot = name.lastIndexOf('.');\n+\t\tif (lastDot != -1) {\n+\t\t\tsb.append(name.substring(lastDot));\n+\t\t}\n+\t\tString alias = sb.toString();\n+\t\tif (!alias.equals(name)) {\n+\t\t\tdeobfName = alias;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n \t}\n \n \tpublic ZipRef getZipRef() {\n\ndiff --git a/jadx-core/src/main/java/jadx/api/plugins/utils/ZipSecurity.java b/jadx-core/src/main/java/jadx/api/plugins/utils/ZipSecurity.java\n--- a/jadx-core/src/main/java/jadx/api/plugins/utils/ZipSecurity.java\n+++ b/jadx-core/src/main/java/jadx/api/plugins/utils/ZipSecurity.java\n@@ -71,6 +71,12 @@ public static boolean isValidZipEntryName(String entryName) {\n \t\tif (DISABLE_CHECKS) {\n \t\t\treturn true;\n \t\t}\n+\t\tif (entryName.contains(\"..\")) { // quick pre-check\n+\t\t\tif (entryName.contains(\"../\") || entryName.contains(\"..\\\\\")) {\n+\t\t\t\tLOG.error(\"Path traversal attack detected in entry: '{}'\", entryName);\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n \t\ttry {\n \t\t\tFile currentPath = CommonFileUtils.CWD;\n \t\t\tFile canonical = new File(currentPath, entryName).getCanonicalFile();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -275,8 +275,9 @@ private void updateObfuscatedFiles(IResParser parser, List<ResourceFile> resourc\n \t\tfor (ResourceFile resource : resources) {\n \t\t\tResourceEntry resEntry = entryNames.get(resource.getOriginalName());\n \t\t\tif (resEntry != null) {\n-\t\t\t\tresource.setAlias(resEntry);\n-\t\t\t\trenamedCount++;\n+\t\t\t\tif (resource.setAlias(resEntry)) {\n+\t\t\t\t\trenamedCount++;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (LOG.isDebugEnabled()) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -18,6 +18,7 @@\n \n import jadx.api.ICodeInfo;\n import jadx.api.args.ResourceNameSource;\n+import jadx.api.plugins.utils.ZipSecurity;\n import jadx.core.deobf.NameMapper;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.nodes.FieldNode;\n@@ -84,9 +85,14 @@ public ResTableParser(RootNode root, boolean useRawResNames) {\n \n \t@Override\n \tpublic void decode(InputStream inputStream) throws IOException {\n+\t\tlong start = System.currentTimeMillis();\n \t\tis = new ParserStream(inputStream);\n \t\tdecodeTableChunk();\n \t\tresStorage.finish();\n+\t\tif (LOG.isDebugEnabled()) {\n+\t\t\tLOG.debug(\"Resource table parsed: size: {}, time: {}ms\",\n+\t\t\t\t\tresStorage.size(), System.currentTimeMillis() - start);\n+\t\t}\n \t}\n \n \tpublic ResContainer decodeFiles(InputStream inputStream) throws IOException {\n@@ -356,20 +362,8 @@ private void parseEntry(PackageChunk pkg, int typeId, int entryId, String config\n \t\tint resRef = pkg.getId() << 24 | typeId << 16 | entryId;\n \t\tString typeName = pkg.getTypeStrings().get(typeId - 1);\n \t\tString origKeyName = pkg.getKeyStrings().get(key);\n-\t\tResourceEntry newResEntry = new ResourceEntry(resRef, pkg.getName(), typeName, getResName(typeName, resRef, origKeyName), config);\n-\t\tResourceEntry prevResEntry = resStorage.searchEntryWithSameName(newResEntry);\n-\t\tif (prevResEntry != null) {\n-\t\t\tnewResEntry = newResEntry.copyWithId();\n-\n-\t\t\t// rename also previous entry for consistency\n-\t\t\tResourceEntry replaceForPrevEntry = prevResEntry.copyWithId();\n-\t\t\tresStorage.replace(prevResEntry, replaceForPrevEntry);\n-\t\t\tresStorage.addRename(replaceForPrevEntry);\n-\t\t}\n-\t\tif (!Objects.equals(origKeyName, newResEntry.getKeyName())) {\n-\t\t\tresStorage.addRename(newResEntry);\n-\t\t}\n \n+\t\tResourceEntry newResEntry = buildResourceEntry(pkg, config, resRef, typeName, origKeyName);\n \t\tif ((flags & FLAG_COMPLEX) != 0 || size == 16) {\n \t\t\tint parentRef = is.readInt32();\n \t\t\tint count = is.readInt32();\n@@ -382,7 +376,33 @@ private void parseEntry(PackageChunk pkg, int typeId, int entryId, String config\n \t\t} else {\n \t\t\tnewResEntry.setSimpleValue(parseValue());\n \t\t}\n+\t}\n+\n+\tprivate static final ResourceEntry STUB_ENTRY = new ResourceEntry(-1, \"stub\", \"stub\", \"stub\", \"\");\n+\n+\tprivate ResourceEntry buildResourceEntry(PackageChunk pkg, String config, int resRef, String typeName, String origKeyName) {\n+\t\tif (!ZipSecurity.isValidZipEntryName(origKeyName)) {\n+\t\t\t// malicious entry, ignore it\n+\t\t\t// can't return null here, return stub without adding it to storage\n+\t\t\treturn STUB_ENTRY;\n+\t\t}\n+\n+\t\tString resName = getResName(typeName, resRef, origKeyName);\n+\t\tResourceEntry newResEntry = new ResourceEntry(resRef, pkg.getName(), typeName, resName, config);\n+\t\tResourceEntry prevResEntry = resStorage.searchEntryWithSameName(newResEntry);\n+\t\tif (prevResEntry != null) {\n+\t\t\tnewResEntry = newResEntry.copyWithId();\n+\n+\t\t\t// rename also previous entry for consistency\n+\t\t\tResourceEntry replaceForPrevEntry = prevResEntry.copyWithId();\n+\t\t\tresStorage.replace(prevResEntry, replaceForPrevEntry);\n+\t\t\tresStorage.addRename(replaceForPrevEntry);\n+\t\t}\n+\t\tif (!Objects.equals(origKeyName, newResEntry.getKeyName())) {\n+\t\t\tresStorage.addRename(newResEntry);\n+\t\t}\n \t\tresStorage.add(newResEntry);\n+\t\treturn newResEntry;\n \t}\n \n \tprivate String getResName(String typeName, int resRef, String origKeyName) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResourceStorage.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResourceStorage.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResourceStorage.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourceStorage.java\n@@ -63,6 +63,10 @@ public void finish() {\n \t\trenames.clear();\n \t}\n \n+\tpublic int size() {\n+\t\treturn list.size();\n+\t}\n+\n \tpublic Iterable<ResourceEntry> getResources() {\n \t\treturn list;\n \t}",
    "output": "Fix ignore resource table entries with '../' in name"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n@@ -654,13 +654,14 @@ private static void removeUnreachableBlocks(MethodNode mth) {\n \t\t\treturn;\n \t\t}\n \n-\t\ttoRemove.forEach(BlockSplitter::detachBlock);\n-\t\tmth.getBasicBlocks().removeAll(toRemove);\n \t\tlong notEmptyBlocks = toRemove.stream().filter(block -> !block.getInstructions().isEmpty()).count();\n \t\tif (notEmptyBlocks != 0) {\n \t\t\tint insnsCount = toRemove.stream().mapToInt(block -> block.getInstructions().size()).sum();\n \t\t\tmth.addWarnComment(\"Unreachable blocks removed: \" + notEmptyBlocks + \", instructions: \" + insnsCount);\n \t\t}\n+\n+\t\ttoRemove.forEach(BlockSplitter::detachBlock);\n+\t\tmth.getBasicBlocks().removeAll(toRemove);\n \t}\n \n \tprivate static void clearBlocksState(MethodNode mth) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java\n@@ -455,7 +455,6 @@ static void detachBlock(BlockNode block) {\n \t\t\tsuccessor.getPredecessors().remove(block);\n \t\t}\n \t\tblock.add(AFlag.REMOVE);\n-\t\tblock.getInstructions().clear();\n \t\tblock.getPredecessors().clear();\n \t\tblock.getSuccessors().clear();\n \t}",
    "output": "Use correct order in removeUnreachableBlocks"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JavaVariable.java b/jadx-core/src/main/java/jadx/api/JavaVariable.java\n--- a/jadx-core/src/main/java/jadx/api/JavaVariable.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaVariable.java\n@@ -79,6 +79,7 @@ public List<JavaNode> getUseIn() {\n \n \t@Override\n \tpublic void removeAlias() {\n+\t\tvarNode.setName(null);\n \t}\n \n \t@Override\n\ndiff --git a/jadx-core/src/main/java/jadx/api/plugins/events/types/NodeRenamedByUser.java b/jadx-core/src/main/java/jadx/api/plugins/events/types/NodeRenamedByUser.java\n--- a/jadx-core/src/main/java/jadx/api/plugins/events/types/NodeRenamedByUser.java\n+++ b/jadx-core/src/main/java/jadx/api/plugins/events/types/NodeRenamedByUser.java\n@@ -1,5 +1,7 @@\n package jadx.api.plugins.events.types;\n \n+import org.jetbrains.annotations.Nullable;\n+\n import jadx.api.metadata.ICodeNodeRef;\n import jadx.api.plugins.events.IJadxEvent;\n import jadx.api.plugins.events.JadxEventType;\n@@ -14,7 +16,12 @@ public class NodeRenamedByUser implements IJadxEvent {\n \t/**\n \t * Optional JRenameNode instance\n \t */\n-\tprivate Object renameNode;\n+\tprivate @Nullable Object renameNode;\n+\n+\t/**\n+\t * Request reset name to original\n+\t */\n+\tprivate boolean resetName = false;\n \n \tpublic NodeRenamedByUser(ICodeNodeRef node, String oldName, String newName) {\n \t\tthis.node = node;\n@@ -42,13 +49,24 @@ public void setRenameNode(Object renameNode) {\n \t\tthis.renameNode = renameNode;\n \t}\n \n+\tpublic boolean isResetName() {\n+\t\treturn resetName;\n+\t}\n+\n+\tpublic void setResetName(boolean resetName) {\n+\t\tthis.resetName = resetName;\n+\t}\n+\n \t@Override\n \tpublic JadxEventType<NodeRenamedByUser> getType() {\n \t\treturn JadxEvents.NODE_RENAMED_BY_USER;\n \t}\n \n \t@Override\n \tpublic String toString() {\n-\t\treturn \"NodeRenamedByUser{\" + node + \", '\" + oldName + \"' -> '\" + newName + \"'}\";\n+\t\treturn \"NodeRenamedByUser{\" + node\n+\t\t\t\t+ \", '\" + oldName + \"' -> '\" + newName + '\\''\n+\t\t\t\t+ (resetName ? \", reset name\" : \"\")\n+\t\t\t\t+ '}';\n \t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/CodeRenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/CodeRenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/CodeRenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/CodeRenameVisitor.java\n@@ -106,7 +106,7 @@ private List<ICodeRename> getRenames(ClassNode cls) {\n \t\tif (clsRenamesMap == null) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n-\t\tList<ICodeRename> clsComments = clsRenamesMap.get(cls.getClassInfo().getFullName());\n+\t\tList<ICodeRename> clsComments = clsRenamesMap.get(cls.getClassInfo().getRawName());\n \t\tif (clsComments == null) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/events/services/RenameService.java b/jadx-gui/src/main/java/jadx/gui/events/services/RenameService.java\n--- a/jadx-gui/src/main/java/jadx/gui/events/services/RenameService.java\n+++ b/jadx-gui/src/main/java/jadx/gui/events/services/RenameService.java\n@@ -61,7 +61,7 @@ private void process(NodeRenamedByUser event) {\n \t\ttry {\n \t\t\tLOG.debug(\"Applying rename event: {}\", event);\n \t\t\tJRenameNode node = getRenameNode(event);\n-\t\t\tupdateCodeRenames(set -> processRename(node, event.getNewName(), set));\n+\t\t\tupdateCodeRenames(set -> processRename(node, event, set));\n \t\t\trefreshState(node);\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Rename failed\", e);\n@@ -85,10 +85,10 @@ private void process(NodeRenamedByUser event) {\n \t\tthrow new JadxRuntimeException(\"Failed to resolve node: \" + event.getNode());\n \t}\n \n-\tprivate void processRename(JRenameNode node, String newName, Set<ICodeRename> renames) {\n-\t\tICodeRename rename = node.buildCodeRename(newName, renames);\n+\tprivate void processRename(JRenameNode node, NodeRenamedByUser event, Set<ICodeRename> renames) {\n+\t\tICodeRename rename = node.buildCodeRename(event.getNewName(), renames);\n \t\trenames.remove(rename);\n-\t\tif (newName.isEmpty()) {\n+\t\tif (event.isResetName() || event.getNewName().isEmpty()) {\n \t\t\tnode.removeAlias();\n \t\t} else {\n \t\t\trenames.add(rename);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n@@ -22,6 +22,7 @@\n \n import jadx.api.metadata.ICodeNodeRef;\n import jadx.api.plugins.events.types.NodeRenamedByUser;\n+import jadx.core.utils.Utils;\n import jadx.gui.treemodel.JClass;\n import jadx.gui.treemodel.JNode;\n import jadx.gui.treemodel.JPackage;\n@@ -98,19 +99,23 @@ private void rename(String newName) {\n \t\t\treturn;\n \t\t}\n \t\tString oldName = node.getName();\n-\t\tif (newName.isEmpty()) {\n+\t\tString newNodeName;\n+\t\tboolean reset = newName.isEmpty();\n+\t\tif (reset) {\n \t\t\tnode.removeAlias();\n-\t\t\tsendRenameEvent(oldName, node.getJavaNode().getName());\n+\t\t\tnewNodeName = Utils.getOrElse(node.getJavaNode().getName(), \"\");\n \t\t} else {\n-\t\t\tsendRenameEvent(oldName, newName);\n+\t\t\tnewNodeName = newName;\n \t\t}\n+\t\tsendRenameEvent(oldName, newNodeName, reset);\n \t\tdispose();\n \t}\n \n-\tprivate void sendRenameEvent(String oldName, String newName) {\n+\tprivate void sendRenameEvent(String oldName, String newName, boolean reset) {\n \t\tICodeNodeRef nodeRef = node.getJavaNode().getCodeNodeRef();\n \t\tNodeRenamedByUser event = new NodeRenamedByUser(nodeRef, oldName, newName);\n \t\tevent.setRenameNode(node);\n+\t\tevent.setResetName(reset);\n \t\tmainWindow.events().send(event);\n \t}",
    "output": "Fix allow to reset variable name, fix renames for inner classes"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n@@ -272,40 +272,68 @@ public String getWordUnderCaret() {\n \t\treturn getWordByPosition(getCaretPosition());\n \t}\n \n-\t@Nullable\n-\tpublic String getWordByPosition(int pos) {\n+\tpublic @Nullable String getWordByPosition(int offset) {\n+\t\tToken token = getWordTokenAtOffset(offset);\n+\t\tif (token != null) {\n+\t\t\treturn token.getLexeme();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Return any word token (not whitespace or special symbol) at offset.\n+\t * Select the previous token if the cursor at word end (current token already is whitespace)\n+\t */\n+\tpublic @Nullable Token getWordTokenAtOffset(int offset) {\n \t\ttry {\n-\t\t\tToken token = modelToToken(pos);\n-\t\t\treturn getWordFromToken(token);\n+\t\t\tint line = this.getLineOfOffset(offset);\n+\t\t\tToken lineTokens = this.getTokenListForLine(line);\n+\t\t\tToken token = null;\n+\t\t\tToken prevToken = null;\n+\t\t\tfor (Token t = lineTokens; t != null && t.isPaintable(); t = t.getNextToken()) {\n+\t\t\t\tif (t.containsPosition(offset)) {\n+\t\t\t\t\ttoken = t;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tprevToken = t;\n+\t\t\t}\n+\t\t\tif (token == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tif (isWordToken(token)) {\n+\t\t\t\treturn token;\n+\t\t\t}\n+\t\t\tif (isWordToken(prevToken)) {\n+\t\t\t\treturn prevToken;\n+\t\t\t}\n+\t\t\treturn null;\n \t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Failed to get word at pos: {}\", pos, e);\n+\t\t\tLOG.error(\"Failed to get token at pos: {}\", offset, e);\n \t\t\treturn null;\n \t\t}\n \t}\n \n-\t@Nullable\n-\tprivate static String getWordFromToken(@Nullable Token token) {\n+\tpublic static boolean isWordToken(@Nullable Token token) {\n \t\tif (token == null) {\n-\t\t\treturn null;\n+\t\t\treturn false;\n \t\t}\n \t\tswitch (token.getType()) {\n \t\t\tcase TokenTypes.NULL:\n \t\t\tcase TokenTypes.WHITESPACE:\n \t\t\tcase TokenTypes.SEPARATOR:\n \t\t\tcase TokenTypes.OPERATOR:\n-\t\t\t\treturn null;\n+\t\t\tcase TokenTypes.FUNCTION:\n+\t\t\t\treturn false;\n \n \t\t\tcase TokenTypes.IDENTIFIER:\n \t\t\t\tif (token.length() == 1) {\n \t\t\t\t\tchar ch = token.charAt(0);\n-\t\t\t\t\tif (ch == ';' || ch == '.') {\n-\t\t\t\t\t\treturn null;\n-\t\t\t\t\t}\n+\t\t\t\t\treturn ch != ';' && ch != '.' && ch != ',';\n \t\t\t\t}\n-\t\t\t\treturn token.getLexeme();\n+\t\t\t\treturn true;\n \n \t\t\tdefault:\n-\t\t\t\treturn token.getLexeme();\n+\t\t\t\treturn true;\n \t\t}\n \t}\n \n@@ -386,8 +414,7 @@ public void centerCurrentLine() {\n \t}\n \n \t/**\n-\t * @param str\n-\t *            - if null -> reset current highlights\n+\t * @param str - if null -> reset current highlights\n \t */\n \tprivate void highlightAllMatches(@Nullable String str) {\n \t\tSearchContext context = new SearchContext(str);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n@@ -68,7 +68,7 @@ public final class CodeArea extends AbstractCodeArea {\n \t\t\t@Override\n \t\t\tpublic void mouseClicked(MouseEvent e) {\n \t\t\t\tif (e.isControlDown() || jumpOnDoubleClick(e)) {\n-\t\t\t\t\tnavToDecl(e.getPoint(), codeLinkGenerator);\n+\t\t\t\t\tnavToDecl(e.getPoint());\n \t\t\t\t}\n \t\t\t}\n \t\t});\n@@ -82,10 +82,9 @@ private boolean jumpOnDoubleClick(MouseEvent e) {\n \t\treturn e.getClickCount() == 2 && getMainWindow().getSettings().isJumpOnDoubleClick();\n \t}\n \n-\t@SuppressWarnings(\"deprecation\")\n-\tprivate void navToDecl(Point point, CodeLinkGenerator codeLinkGenerator) {\n-\t\tint offs = viewToModel(point);\n-\t\tJNode node = getJNodeAtOffset(codeLinkGenerator.getLinkSourceOffset(offs));\n+\tprivate void navToDecl(Point point) {\n+\t\tint offs = viewToModel2D(point);\n+\t\tJNode node = getJNodeAtOffset(adjustOffsetForWordToken(offs));\n \t\tif (node != null) {\n \t\t\tcontentPanel.getTabbedPane().codeJump(node);\n \t\t}\n@@ -154,17 +153,16 @@ private void addMenuForJsonFile() {\n \t\tpopup.add(new JsonPrettifyAction(this));\n \t}\n \n-\tpublic int adjustOffsetForToken(@Nullable Token token) {\n+\t/**\n+\t * Search start of word token at specified offset\n+\t *\n+\t * @return -1 if no word token found\n+\t */\n+\tpublic int adjustOffsetForWordToken(int offset) {\n+\t\tToken token = getWordTokenAtOffset(offset);\n \t\tif (token == null) {\n \t\t\treturn -1;\n \t\t}\n-\t\t// fast skip\n-\t\tif (token.length() == 1) {\n-\t\t\tchar ch = token.getTextArray()[token.getTextOffset()];\n-\t\t\tif (ch == '.' || ch == ',' || ch == ';') {\n-\t\t\t\treturn -1;\n-\t\t\t}\n-\t\t}\n \t\tint type = token.getType();\n \t\tif (node instanceof JClass) {\n \t\t\tif (type == TokenTypes.IDENTIFIER || type == TokenTypes.FUNCTION) {\n@@ -208,25 +206,13 @@ private JNode convertJavaNode(JavaNode javaNode) {\n \t@Nullable\n \tpublic JNode getNodeUnderCaret() {\n \t\tint caretPos = getCaretPosition();\n-\t\tToken token = modelToToken(caretPos);\n-\t\tif (token == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tint start = adjustOffsetForToken(token);\n-\t\tif (start == -1) {\n-\t\t\tstart = caretPos;\n-\t\t}\n-\t\treturn getJNodeAtOffset(start);\n+\t\treturn getJNodeAtOffset(adjustOffsetForWordToken(caretPos));\n \t}\n \n \t@Nullable\n \tpublic JNode getEnclosingNodeUnderCaret() {\n \t\tint caretPos = getCaretPosition();\n-\t\tToken token = modelToToken(caretPos);\n-\t\tif (token == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tint start = adjustOffsetForToken(token);\n+\t\tint start = adjustOffsetForWordToken(caretPos);\n \t\tif (start == -1) {\n \t\t\tstart = caretPos;\n \t\t}\n@@ -236,15 +222,13 @@ public JNode getEnclosingNodeUnderCaret() {\n \t@Nullable\n \tpublic JNode getNodeUnderMouse() {\n \t\tPoint pos = UiUtils.getMousePosition(this);\n-\t\tint offset = adjustOffsetForToken(viewToToken(pos));\n-\t\treturn getJNodeAtOffset(offset);\n+\t\treturn getJNodeAtOffset(adjustOffsetForWordToken(viewToModel2D(pos)));\n \t}\n \n \t@Nullable\n \tpublic JNode getEnclosingNodeUnderMouse() {\n \t\tPoint pos = UiUtils.getMousePosition(this);\n-\t\tint offset = adjustOffsetForToken(viewToToken(pos));\n-\t\treturn getEnclosingJNodeAtOffset(offset);\n+\t\treturn getEnclosingJNodeAtOffset(adjustOffsetForWordToken(viewToModel2D(pos)));\n \t}\n \n \t@Nullable\n@@ -281,6 +265,9 @@ public JavaNode getJavaNodeAtOffset(int offset) {\n \t}\n \n \tpublic JavaNode getClosestJavaNode(int offset) {\n+\t\tif (offset == -1) {\n+\t\t\treturn null;\n+\t\t}\n \t\ttry {\n \t\t\treturn getJadxWrapper().getDecompiler().getClosestJavaNode(getCodeInfo(), offset);\n \t\t} catch (Exception e) {\n@@ -290,6 +277,9 @@ public JavaNode getClosestJavaNode(int offset) {\n \t}\n \n \tpublic JavaNode getEnclosingJavaNode(int offset) {\n+\t\tif (offset == -1) {\n+\t\t\treturn null;\n+\t\t}\n \t\ttry {\n \t\t\treturn getJadxWrapper().getDecompiler().getEnclosingNode(getCodeInfo(), offset);\n \t\t} catch (Exception e) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeLinkGenerator.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeLinkGenerator.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeLinkGenerator.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeLinkGenerator.java\n@@ -7,7 +7,6 @@\n import org.fife.ui.rsyntaxtextarea.LinkGenerator;\n import org.fife.ui.rsyntaxtextarea.LinkGeneratorResult;\n import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;\n-import org.fife.ui.rsyntaxtextarea.Token;\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -32,7 +31,7 @@ public JavaNode getNodeAtOffset(int offset) {\n \t\t\tif (!codeArea.getCodeInfo().hasMetadata()) {\n \t\t\t\treturn null;\n \t\t\t}\n-\t\t\tint sourceOffset = getLinkSourceOffset(offset);\n+\t\t\tint sourceOffset = codeArea.adjustOffsetForWordToken(offset);\n \t\t\tif (sourceOffset == -1) {\n \t\t\t\treturn null;\n \t\t\t}\n@@ -49,7 +48,7 @@ public LinkGeneratorResult isLinkAtOffset(RSyntaxTextArea textArea, int offset)\n \t\t\tif (!codeArea.getCodeInfo().hasMetadata()) {\n \t\t\t\treturn null;\n \t\t\t}\n-\t\t\tint sourceOffset = getLinkSourceOffset(offset);\n+\t\t\tint sourceOffset = codeArea.adjustOffsetForWordToken(offset);\n \t\t\tif (sourceOffset == -1) {\n \t\t\t\treturn null;\n \t\t\t}\n@@ -75,11 +74,6 @@ public int getSourceOffset() {\n \t\t}\n \t}\n \n-\tpublic int getLinkSourceOffset(int offset) {\n-\t\tToken token = codeArea.modelToToken(offset);\n-\t\treturn codeArea.adjustOffsetForToken(token);\n-\t}\n-\n \t@Nullable\n \tprivate JumpPosition getJumpBySourceOffset(int sourceOffset) {\n \t\tfinal JumpPosition defPos = codeArea.getDefPosForNodeAtOffset(sourceOffset);",
    "output": "Fix highlight word even if cursor at the end of that word"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java\n@@ -175,7 +175,6 @@ private boolean checkScript() {\n \t\t\terrorService.clearErrors();\n \t\t\terrorService.addCompilerIssues(issues);\n \t\t\terrorService.addLintErrors(lintErrs);\n-\t\t\terrorService.apply();\n \t\t\tif (!success) {\n \t\t\t\tresultLabel.setText(\"Compile issues: \" + issues.size());\n \t\t\t\tshowScriptLog();\n@@ -184,6 +183,7 @@ private boolean checkScript() {\n \t\t\t} else {\n \t\t\t\tresultLabel.setText(\"OK\");\n \t\t\t}\n+\t\t\terrorService.apply();\n \t\t\treturn success;\n \t\t} catch (Throwable e) {\n \t\t\tscriptLog.error(\"Failed to check code\", e);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptErrorService.java b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptErrorService.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptErrorService.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptErrorService.java\n@@ -15,8 +15,8 @@\n import kotlin.script.experimental.api.SourceCode;\n \n public class ScriptErrorService extends AbstractParser {\n-\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ScriptErrorService.class);\n+\n \tprivate final DefaultParseResult result;\n \tprivate final ScriptCodeArea scriptArea;\n \n@@ -39,6 +39,7 @@ public void apply() {\n \t\tscriptArea.removeParser(this);\n \t\tscriptArea.addParser(this);\n \t\tscriptArea.addNotify();\n+\t\tscriptArea.requestFocus();\n \t\tjumpCaretToFirstError();\n \t}\n \n@@ -49,15 +50,15 @@ private void jumpCaretToFirstError() {\n \t\t}\n \t\tParserNotice notice = parserNotices.get(0);\n \t\tint offset = notice.getOffset();\n-\t\tif (offset != -1) {\n-\t\t\tscriptArea.setCaretPosition(offset);\n-\t\t} else {\n+\t\tif (offset == -1) {\n \t\t\ttry {\n-\t\t\t\tscriptArea.setCaretPosition(scriptArea.getLineStartOffset(notice.getLine()));\n+\t\t\t\toffset = scriptArea.getLineStartOffset(notice.getLine());\n \t\t\t} catch (Exception e) {\n \t\t\t\tLOG.error(\"Failed to jump to first error\", e);\n+\t\t\t\treturn;\n \t\t\t}\n \t\t}\n+\t\tscriptArea.scrollToPos(offset);\n \t}\n \n \tpublic void addCompilerIssues(List<ScriptDiagnostic> issues) {",
    "output": "Fix scroll to first error on jadx script check/run"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/ui/cache/CachesTable.java b/jadx-gui/src/main/java/jadx/gui/settings/ui/cache/CachesTable.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ui/cache/CachesTable.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ui/cache/CachesTable.java\n@@ -1,19 +1,18 @@\n package jadx.gui.settings.ui.cache;\n \n import java.awt.Dimension;\n-import java.math.BigInteger;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.util.List;\n import java.util.Map;\n import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n import javax.swing.JTable;\n import javax.swing.ListSelectionModel;\n \n import org.apache.commons.io.FileUtils;\n-import org.apache.commons.io.file.PathUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -102,7 +101,7 @@ private void calcSize(TableRow row) {\n \t\ttry {\n \t\t\tPath dir = Paths.get(cacheDir);\n \t\t\tif (Files.isDirectory(dir)) {\n-\t\t\t\tBigInteger size = PathUtils.sizeOfDirectoryAsBigInteger(dir);\n+\t\t\t\tlong size = calcSizeOfDirectory(dir);\n \t\t\t\trow.setUsage(FileUtils.byteCountToDisplaySize(size));\n \t\t\t} else {\n \t\t\t\trow.setUsage(\"not found\");\n@@ -113,6 +112,27 @@ private void calcSize(TableRow row) {\n \t\t}\n \t}\n \n+\tprivate static long calcSizeOfDirectory(Path dir) {\n+\t\ttry (Stream<Path> stream = Files.walk(dir)) {\n+\t\t\tlong blockSize = Files.getFileStore(dir).getBlockSize();\n+\t\t\treturn stream.mapToLong(p -> {\n+\t\t\t\tif (Files.isRegularFile(p)) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tlong fileSize = Files.size(p);\n+\t\t\t\t\t\t// ceil round to blockSize\n+\t\t\t\t\t\treturn (fileSize / blockSize + 1L) * blockSize;\n+\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\tLOG.error(\"Failed to get file size: {}\", p, e);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn 0;\n+\t\t\t}).sum();\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"Failed to calculate directory size: {}\", dir, e);\n+\t\t\treturn 0;\n+\t\t}\n+\t}\n+\n \tpublic void deleteSelected() {\n \t\tdelete(ListUtils.filter(dataModel.getRows(), TableRow::isSelected));\n \t}",
    "output": "Fix round file size to block size for cache usage calculation"
  },
  {
    "input": "diff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestJavaDup2x2.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestJavaDup2x2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestJavaDup2x2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestJavaDup2x2.java\n@@ -0,0 +1,17 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.RaungTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestJavaDup2x2 extends RaungTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromRaung())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"dArr[0] = 127.5d;\");\n+\t}\n+}\n\ndiff --git a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/CodeDecodeState.java b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/CodeDecodeState.java\n--- a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/CodeDecodeState.java\n+++ b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/CodeDecodeState.java\n@@ -9,6 +9,7 @@\n import jadx.plugins.input.java.data.JavaClassData;\n import jadx.plugins.input.java.data.code.StackState.SVType;\n \n+@SuppressWarnings(\"UnusedReturnValue\")\n public class CodeDecodeState {\n \tprivate final JavaClassData clsData;\n \tprivate final DataReader reader;\n@@ -35,6 +36,7 @@ public void onInsn(int offset) {\n \t\t\tthis.stack = stackState;\n \t\t}\n \t\tif (excHandlers.contains(offset)) {\n+\t\t\tclear();\n \t\t\tstack.push(SVType.NARROW); // push exception\n \t\t\texcHandler = true;\n \t\t} else {\n@@ -112,6 +114,10 @@ public CodeDecodeState pushWide(int arg) {\n \t\treturn this;\n \t}\n \n+\tpublic int insert(int pos, SVType type) {\n+\t\treturn stack.insert(pos, type);\n+\t}\n+\n \tpublic void discard() {\n \t\tstack.pop();\n \t}\n@@ -124,8 +130,9 @@ public void discardWord() {\n \t\t}\n \t}\n \n-\tpublic void clear() {\n+\tpublic CodeDecodeState clear() {\n \t\tstack.clear();\n+\t\treturn this;\n \t}\n \n \tpublic int push(String type) {\n\ndiff --git a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaCodeReader.java b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaCodeReader.java\n--- a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaCodeReader.java\n+++ b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaCodeReader.java\n@@ -70,12 +70,11 @@ public void visitInstructions(Consumer<InsnData> insnConsumer) {\n \t\t\tif (insnInfo == null) {\n \t\t\t\tthrow new JavaClassParseException(\"Unknown opcode: 0x\" + Integer.toHexString(opcode));\n \t\t\t}\n-\t\t\tinsn.setInsnInfo(insnInfo);\n+\t\t\tinsn.setOpcodeUnit(opcode);\n \t\t\tinsn.setInsnInfo(insnInfo);\n \t\t\tinsn.setRegsCount(insnInfo.getRegsCount());\n \t\t\tinsn.setOpcode(insnInfo.getApiOpcode());\n \t\t\tinsn.setPayloadSize(insnInfo.getPayloadSize());\n-\t\t\tinsn.setOpcodeUnit(opcode);\n \t\t\tinsn.setPayload(null);\n \n \t\t\tstate.onInsn(offset);\n\ndiff --git a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaInsnsRegister.java b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaInsnsRegister.java\n--- a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaInsnsRegister.java\n+++ b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaInsnsRegister.java\n@@ -158,21 +158,8 @@ public class JavaInsnsRegister {\n \t\t\t\ts.peek(1).push(0, s.peekType(1));\n \t\t\t}\n \t\t});\n-\t\tregister(arr, 0x5d, \"dup2_x1\", 0, 10, Opcode.MOVE_MULTI,\n-\t\t\t\ts -> {\n-\t\t\t\t\tif (s.peekType(0) == NARROW) {\n-\t\t\t\t\t\ts.push(0, NARROW).peekFrom(2, 1)\n-\t\t\t\t\t\t\t\t.push(2, NARROW).peekFrom(2, 3)\n-\t\t\t\t\t\t\t\t.peekFrom(2, 4).peekFrom(4, 5)\n-\t\t\t\t\t\t\t\t.peekFrom(3, 6).peekFrom(0, 7)\n-\t\t\t\t\t\t\t\t.peekFrom(4, 8).peekFrom(1, 9);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\ts.insn().setRegsCount(6);\n-\t\t\t\t\t\ts.push(0, WIDE).peekFrom(1, 1)\n-\t\t\t\t\t\t\t\t.peekFrom(1, 2).peekFrom(2, 3)\n-\t\t\t\t\t\t\t\t.peekFrom(2, 4).peekFrom(0, 5);\n-\t\t\t\t\t}\n-\t\t\t\t});\n+\t\tregister(arr, 0x5d, \"dup2_x1\", 0, 10, Opcode.MOVE_MULTI, JavaInsnsRegister::dup2x1);\n+\t\tregister(arr, 0x5e, \"dup2_x2\", 0, 12, Opcode.MOVE_MULTI, JavaInsnsRegister::dup2x2);\n \t\tregister(arr, 0x5f, \"swap\", 0, 6, Opcode.MOVE_MULTI,\n \t\t\t\ts -> s.peekFrom(-1, 0).peekFrom(1, 1)\n \t\t\t\t\t\t.peekFrom(1, 2).peekFrom(0, 3)\n@@ -309,6 +296,44 @@ public class JavaInsnsRegister {\n \t\tregister(arr, 0xc8, \"goto_w\", 4, 0, Opcode.GOTO, s -> s.jump(s.reader().readS4()));\n \t}\n \n+\tprivate static void dup2x1(CodeDecodeState s) {\n+\t\tif (s.peekType(0) == NARROW) {\n+\t\t\ts.insert(2, NARROW);\n+\t\t\ts.insert(2, NARROW);\n+\t\t\ts.peekFrom(0, 0).peekFrom(2, 1);\n+\t\t\ts.peekFrom(1, 2).peekFrom(3, 3);\n+\t\t\ts.peekFrom(2, 4).peekFrom(4, 5);\n+\t\t\ts.peekFrom(3, 6).peekFrom(0, 7);\n+\t\t\ts.peekFrom(4, 8).peekFrom(1, 9);\n+\t\t} else {\n+\t\t\ts.insn().setRegsCount(6);\n+\t\t\ts.insert(2, WIDE);\n+\t\t\ts.peekFrom(0, 0).peekFrom(1, 1);\n+\t\t\ts.peekFrom(1, 2).peekFrom(2, 3);\n+\t\t\ts.peekFrom(2, 4).peekFrom(0, 5);\n+\t\t}\n+\t}\n+\n+\tprivate static void dup2x2(CodeDecodeState s) {\n+\t\tif (s.peekType(0) == NARROW) {\n+\t\t\ts.insert(2, NARROW);\n+\t\t\ts.insert(2, NARROW);\n+\t\t\ts.peekFrom(0, 0).peekFrom(2, 1);\n+\t\t\ts.peekFrom(1, 2).peekFrom(3, 3);\n+\t\t\ts.peekFrom(2, 4).peekFrom(4, 5);\n+\t\t\ts.peekFrom(3, 6).peekFrom(5, 7);\n+\t\t\ts.peekFrom(4, 8).peekFrom(0, 9);\n+\t\t\ts.peekFrom(5, 10).peekFrom(1, 11);\n+\t\t} else {\n+\t\t\ts.insn().setRegsCount(8);\n+\t\t\ts.insert(2, WIDE);\n+\t\t\ts.peekFrom(0, 0).peekFrom(1, 1);\n+\t\t\ts.peekFrom(1, 2).peekFrom(2, 3);\n+\t\t\ts.peekFrom(2, 4).peekFrom(3, 5);\n+\t\t\ts.peekFrom(3, 6).peekFrom(0, 7);\n+\t\t}\n+\t}\n+\n \tprivate static IJavaInsnDecoder newArrayMulti() {\n \t\treturn s -> {\n \t\t\ts.idx(s.u2());\n\ndiff --git a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/StackState.java b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/StackState.java\n--- a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/StackState.java\n+++ b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/StackState.java\n@@ -44,6 +44,14 @@ public SVType peekTypeAt(int at) {\n \t\treturn SVType.NARROW;\n \t}\n \n+\tpublic int insert(int at, SVType type) {\n+\t\tint p = pos - at;\n+\t\tSystem.arraycopy(stack, p, stack, p + 1, at);\n+\t\tstack[p] = type;\n+\t\tpos++;\n+\t\treturn p;\n+\t}\n+\n \tpublic int push(SVType type) {\n \t\tint p = ++pos;\n \t\tif (checkStackIndex(p)) {",
    "output": "Use correct registers for dup2_x* opcodes"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n@@ -15,6 +15,7 @@\n import javax.swing.JPanel;\n import javax.swing.JPopupMenu;\n import javax.swing.JTextField;\n+import javax.swing.SwingUtilities;\n import javax.swing.WindowConstants;\n \n import org.jetbrains.annotations.NotNull;\n@@ -42,9 +43,11 @@ public class RenameDialog extends JDialog {\n \tprivate transient JButton renameBtn;\n \n \tpublic static boolean rename(MainWindow mainWindow, JRenameNode node) {\n-\t\tRenameDialog renameDialog = new RenameDialog(mainWindow, node);\n-\t\tUiUtils.uiRun(() -> renameDialog.setVisible(true));\n-\t\tUiUtils.uiRun(renameDialog::initRenameField); // wait for UI events to propagate\n+\t\tSwingUtilities.invokeLater(() -> {\n+\t\t\tRenameDialog renameDialog = new RenameDialog(mainWindow, node);\n+\t\t\trenameDialog.initRenameField();\n+\t\t\trenameDialog.setVisible(true);\n+\t\t});\n \t\treturn true;\n \t}",
    "output": "Fix attempt to resolve field rename issues with shortcut"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n@@ -5,6 +5,7 @@\n \n import jadx.api.JadxArgs;\n import jadx.api.JadxDecompiler;\n+import jadx.api.impl.AnnotatedCodeWriter;\n import jadx.api.impl.NoOpCodeCache;\n import jadx.api.impl.SimpleCodeWriter;\n import jadx.cli.LogHelper.LogLevelEnum;\n@@ -44,8 +45,8 @@ private static int processAndSave(JadxCLIArgs cliArgs) {\n \t\tLogHelper.setLogLevelsForLoadingStage();\n \t\tJadxArgs jadxArgs = cliArgs.toJadxArgs();\n \t\tjadxArgs.setCodeCache(new NoOpCodeCache());\n-\t\tjadxArgs.setCodeWriterProvider(SimpleCodeWriter::new);\n \t\tjadxArgs.setPluginLoader(new JadxExternalPluginsLoader());\n+\t\tinitCodeWriterProvider(jadxArgs);\n \t\ttry (JadxDecompiler jadx = new JadxDecompiler(jadxArgs)) {\n \t\t\tjadx.load();\n \t\t\tif (checkForErrors(jadx)) {\n@@ -66,6 +67,18 @@ private static int processAndSave(JadxCLIArgs cliArgs) {\n \t\treturn 0;\n \t}\n \n+\tprivate static void initCodeWriterProvider(JadxArgs jadxArgs) {\n+\t\tswitch (jadxArgs.getOutputFormat()) {\n+\t\t\tcase JAVA:\n+\t\t\t\tjadxArgs.setCodeWriterProvider(SimpleCodeWriter::new);\n+\t\t\t\tbreak;\n+\t\t\tcase JSON:\n+\t\t\t\t// needed for code offsets and source lines\n+\t\t\t\tjadxArgs.setCodeWriterProvider(AnnotatedCodeWriter::new);\n+\t\t\t\tbreak;\n+\t\t}\n+\t}\n+\n \tprivate static boolean checkForErrors(JadxDecompiler jadx) {\n \t\tif (jadx.getRoot().getClasses().isEmpty()) {\n \t\t\tif (jadx.getArgs().isSkipResources()) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/json/JsonCodeGen.java b/jadx-core/src/main/java/jadx/core/codegen/json/JsonCodeGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/json/JsonCodeGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/json/JsonCodeGen.java\n@@ -4,7 +4,6 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n \n import org.jetbrains.annotations.Nullable;\n \n@@ -77,11 +76,14 @@ private JsonClass processCls(ClassNode cls, @Nullable ClassGen parentCodeGen) {\n \t\t}\n \t\tjsonCls.setType(getClassTypeStr(cls));\n \t\tjsonCls.setAccessFlags(cls.getAccessFlags().rawValue());\n-\t\tif (!Objects.equals(cls.getSuperClass(), ArgType.OBJECT)) {\n-\t\t\tjsonCls.setSuperClass(getTypeAlias(cls.getSuperClass()));\n+\t\tArgType superClass = cls.getSuperClass();\n+\t\tif (superClass != null\n+\t\t\t\t&& !superClass.equals(ArgType.OBJECT)\n+\t\t\t\t&& !cls.contains(AFlag.REMOVE_SUPER_CLASS)) {\n+\t\t\tjsonCls.setSuperClass(getTypeAlias(classGen, superClass));\n \t\t}\n \t\tif (!cls.getInterfaces().isEmpty()) {\n-\t\t\tjsonCls.setInterfaces(Utils.collectionMap(cls.getInterfaces(), this::getTypeAlias));\n+\t\t\tjsonCls.setInterfaces(Utils.collectionMap(cls.getInterfaces(), clsType -> getTypeAlias(classGen, clsType)));\n \t\t}\n \n \t\tICodeWriter cw = new SimpleCodeWriter();\n@@ -148,8 +150,8 @@ private void addMethods(ClassNode cls, JsonClass jsonCls, ClassGen classGen) {\n \t\t\t\tjsonMth.setAlias(mth.getAlias());\n \t\t\t}\n \t\t\tjsonMth.setSignature(mth.getMethodInfo().getShortId());\n-\t\t\tjsonMth.setReturnType(getTypeAlias(mth.getReturnType()));\n-\t\t\tjsonMth.setArguments(Utils.collectionMap(mth.getMethodInfo().getArgumentsTypes(), this::getTypeAlias));\n+\t\t\tjsonMth.setReturnType(getTypeAlias(classGen, mth.getReturnType()));\n+\t\t\tjsonMth.setArguments(Utils.collectionMap(mth.getMethodInfo().getArgumentsTypes(), clsType -> getTypeAlias(classGen, clsType)));\n \n \t\t\tMethodGen mthGen = new MethodGen(classGen, mth);\n \t\t\tICodeWriter cw = new AnnotatedCodeWriter();\n@@ -205,15 +207,10 @@ private List<JsonCodeLine> fillMthCode(MethodNode mth, MethodGen mthGen) {\n \t\treturn codeLines;\n \t}\n \n-\tprivate String getTypeAlias(ArgType clsType) {\n-\t\tif (Objects.equals(clsType, ArgType.OBJECT)) {\n-\t\t\treturn ArgType.OBJECT.getObject();\n-\t\t}\n-\t\tif (clsType.isObject()) {\n-\t\t\tClassInfo classInfo = ClassInfo.fromType(root, clsType);\n-\t\t\treturn classInfo.getAliasFullName();\n-\t\t}\n-\t\treturn clsType.toString();\n+\tprivate String getTypeAlias(ClassGen classGen, ArgType clsType) {\n+\t\tICodeWriter code = new SimpleCodeWriter();\n+\t\tclassGen.useType(code, clsType);\n+\t\treturn code.getCodeStr();\n \t}\n \n \tprivate String getClassTypeStr(ClassNode cls) {",
    "output": "Use correct type printer in json output mode"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n@@ -21,6 +21,7 @@\n \n import jadx.api.metadata.ICodeNodeRef;\n import jadx.api.plugins.events.types.NodeRenamedByUser;\n+import jadx.gui.treemodel.JClass;\n import jadx.gui.treemodel.JNode;\n import jadx.gui.treemodel.JPackage;\n import jadx.gui.treemodel.JRenameNode;\n@@ -155,13 +156,15 @@ private void initUI() {\n \t\trenamePane.setLayout(new FlowLayout(FlowLayout.LEFT));\n \t\trenamePane.add(lbl);\n \t\trenamePane.add(nodeLabel);\n-\t\trenamePane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\t\trenamePane.setBorder(BorderFactory.createEmptyBorder(10, 10, 0, 10));\n \n \t\tJPanel textPane = new JPanel();\n \t\ttextPane.setLayout(new BoxLayout(textPane, BoxLayout.PAGE_AXIS));\n-\t\ttextPane.add(Box.createRigidArea(new Dimension(0, 5)));\n \t\ttextPane.add(renameField);\n-\t\ttextPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+\t\tif (node instanceof JClass) {\n+\t\t\ttextPane.add(new JLabel(NLS.str(\"rename_dialog.class_help\")));\n+\t\t}\n+\t\ttextPane.setBorder(BorderFactory.createEmptyBorder(5, 10, 10, 10));\n \n \t\tJPanel buttonPane = initButtonsPanel();",
    "output": "Add hint for class renaming"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/kotlin/ProcessKotlinInternals.java b/jadx-core/src/main/java/jadx/core/dex/visitors/kotlin/ProcessKotlinInternals.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/kotlin/ProcessKotlinInternals.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/kotlin/ProcessKotlinInternals.java\n@@ -52,7 +52,8 @@ public class ProcessKotlinInternals extends AbstractVisitor {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ProcessKotlinInternals.class);\n \n \tprivate static final String KOTLIN_INTERNAL_PKG = \"kotlin.jvm.internal.\";\n-\tprivate static final String KOTLIN_INTRINSICS_CLS = KOTLIN_INTERNAL_PKG + \"Intrinsics\";\n+\tprivate static final String KOTLIN_INTRINSICS_CLS_SHORT_NAME = \"Intrinsics\";\n+\tprivate static final String KOTLIN_INTRINSICS_CLS = KOTLIN_INTERNAL_PKG + KOTLIN_INTRINSICS_CLS_SHORT_NAME;\n \tprivate static final String KOTLIN_VARNAME_SOURCE_MTH1 = \"(Ljava/lang/Object;Ljava/lang/String;)V\";\n \tprivate static final String KOTLIN_VARNAME_SOURCE_MTH2 = \"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;)V\";\n \n@@ -194,7 +195,12 @@ private static ClassNode searchKotlinIntrinsicsClass(RootNode root) {\n \t}\n \n \tprivate static boolean isKotlinIntrinsicsClass(ClassNode cls) {\n-\t\tif (!cls.getClassInfo().getFullName().startsWith(KOTLIN_INTERNAL_PKG)) {\n+\t\tClassInfo clsInfo = cls.getClassInfo();\n+\t\tif (clsInfo.getAliasShortName().equals(KOTLIN_INTRINSICS_CLS_SHORT_NAME)\n+\t\t\t\t&& clsInfo.getAliasFullName().equals(KOTLIN_INTRINSICS_CLS)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (!clsInfo.getFullName().startsWith(KOTLIN_INTERNAL_PKG)) {\n \t\t\treturn false;\n \t\t}\n \t\tif (cls.getMethods().size() < 5) {",
    "output": "Fix check class alias for Kotlin Intrinsics search"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/XposedAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/XposedAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/XposedAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/XposedAction.java\n@@ -101,11 +101,20 @@ private String generateMethodSnippet(JMethod jMth) {\n \t\t\treturn String.format(xposedFormatStr, xposedMethod, rawClassName, methodName);\n \t\t}\n \t\tString params = mthArgs.stream()\n-\t\t\t\t.map(type -> (type.isGeneric() ? type.getObject() : type) + \".class, \")\n+\t\t\t\t.map(type -> fixTypeContent(type) + \".class, \")\n \t\t\t\t.collect(Collectors.joining());\n \t\treturn String.format(xposedFormatStr, xposedMethod, rawClassName, methodName + params);\n \t}\n \n+\tprivate String fixTypeContent(ArgType type) {\n+\t\tif (type.isGeneric()) {\n+\t\t\treturn type.getObject();\n+\t\t} else if (type.isGenericType() && type.isObject() && type.isTypeKnown()) {\n+\t\t\treturn \"Object\";\n+\t\t}\n+\t\treturn type.toString();\n+\t}\n+\n \tprivate String generateClassSnippet(JClass jc) {\n \t\tJavaClass javaClass = jc.getCls();\n \t\tString rawClassName = javaClass.getRawName();\n@@ -120,6 +129,6 @@ private String generateFieldSnippet(JField jf) {\n \t\tString isStatic = javaField.getAccessFlags().isStatic() ? \"Static\" : \"\";\n \t\tString type = PRIMITIVE_TYPE_MAPPING.getOrDefault(javaField.getFieldNode().getType().toString(), \"Object\");\n \t\tString xposedMethod = \"XposedHelpers.get\" + isStatic + type + \"Field\";\n-\t\treturn String.format(\"%s(/*runtimeObject*/, \\\"%s\\\");\", xposedMethod, javaField.getName());\n+\t\treturn String.format(\"%s(/*runtimeObject*/, \\\"%s\\\");\", xposedMethod, javaField.getFieldNode().getFieldInfo().getName());\n \t}\n }",
    "output": "Use correct type for generic params in Xposed snippet"
  },
  {
    "input": "diff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java\n@@ -74,7 +74,7 @@ public void decode(DexInsnData insn, int opcodeUnit, SectionReader in) {\n \t\t@Override\n \t\tpublic void decode(DexInsnData insn, int opcodeUnit, SectionReader in) {\n \t\t\tint[] regs = insn.getArgsReg();\n-\t\t\tregs[0] = signedByte1(opcodeUnit);\n+\t\t\tregs[0] = byte1(opcodeUnit);\n \t\t\tinsn.setTarget(insn.getOffset() + in.readShort());\n \t\t}\n \t};",
    "output": "Fix IndexOutOfBoundsException with negative register index"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n@@ -32,7 +32,6 @@\n import jadx.core.dex.nodes.IBlock;\n import jadx.core.dex.nodes.IContainer;\n import jadx.core.dex.nodes.InsnNode;\n-import jadx.core.dex.regions.Region;\n import jadx.core.dex.regions.SwitchRegion;\n import jadx.core.dex.regions.SwitchRegion.CaseInfo;\n import jadx.core.dex.regions.SynchronizedRegion;\n@@ -147,15 +146,12 @@ public void makeIf(IfRegion region, ICodeWriter code, boolean newLine) throws Co\n \t * Connect if-else-if block\n \t */\n \tprivate boolean connectElseIf(ICodeWriter code, IContainer els) throws CodegenException {\n-\t\tif (els.contains(AFlag.ELSE_IF_CHAIN) && els instanceof Region) {\n-\t\t\tList<IContainer> subBlocks = ((Region) els).getSubBlocks();\n-\t\t\tif (subBlocks.size() == 1) {\n-\t\t\t\tIContainer elseBlock = subBlocks.get(0);\n-\t\t\t\tif (elseBlock instanceof IfRegion) {\n-\t\t\t\t\tdeclareVars(code, elseBlock);\n-\t\t\t\t\tmakeIf((IfRegion) elseBlock, code, false);\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n+\t\tif (els.contains(AFlag.ELSE_IF_CHAIN)) {\n+\t\t\tIContainer elseBlock = RegionUtils.getSingleSubBlock(els);\n+\t\t\tif (elseBlock instanceof IfRegion) {\n+\t\t\t\tdeclareVars(code, elseBlock);\n+\t\t\t\tmakeIf((IfRegion) elseBlock, code, false);\n+\t\t\t\treturn true;\n \t\t\t}\n \t\t}\n \t\treturn false;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java\n@@ -13,6 +13,7 @@\n import jadx.core.dex.regions.conditions.IfCondition.Mode;\n import jadx.core.dex.regions.conditions.IfRegion;\n import jadx.core.dex.visitors.AbstractVisitor;\n+import jadx.core.utils.InsnUtils;\n import jadx.core.utils.RegionUtils;\n \n import static jadx.core.utils.RegionUtils.insnsCount;\n@@ -81,21 +82,23 @@ private static void orderBranches(MethodNode mth, IfRegion ifRegion) {\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tboolean lastRegion = RegionUtils.hasExitEdge(ifRegion);\n-\t\t\tif (elseSize == 1 && lastRegion && mth.isVoidReturn()) {\n-\t\t\t\tInsnNode lastElseInsn = RegionUtils.getLastInsn(ifRegion.getElseRegion());\n-\t\t\t\tif (lastElseInsn != null && lastElseInsn.getType() == InsnType.THROW) {\n-\t\t\t\t\t// move `throw` into `then` block\n+\t\t\tif (elseSize == 1) {\n+\t\t\t\tboolean lastRegion = RegionUtils.hasExitEdge(ifRegion);\n+\t\t\t\tif (lastRegion && mth.isVoidReturn()) {\n+\t\t\t\t\tInsnNode lastElseInsn = RegionUtils.getLastInsn(ifRegion.getElseRegion());\n+\t\t\t\t\tif (InsnUtils.isInsnType(lastElseInsn, InsnType.THROW)) {\n+\t\t\t\t\t\t// move `throw` into `then` block\n+\t\t\t\t\t\tinvertIfRegion(ifRegion);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// single return at method end will be removed later\n+\t\t\t\t\t}\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tif (thenSize > 2 && !(lastRegion && thenSize < 4 /* keep small code block inside else */)) {\n \t\t\t\t\tinvertIfRegion(ifRegion);\n-\t\t\t\t} else {\n-\t\t\t\t\t// single return at method end will be removed later\n+\t\t\t\t\treturn;\n \t\t\t\t}\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tif (!lastRegion) {\n-\t\t\t\tinvertIfRegion(ifRegion);\n \t\t\t}\n-\t\t\treturn;\n \t\t}\n \t\tboolean thenExit = RegionUtils.hasExitBlock(ifRegion.getThenRegion());\n \t\tboolean elseExit = RegionUtils.hasExitBlock(ifRegion.getElseRegion());\n@@ -155,22 +158,32 @@ public boolean visitRegion(MethodNode mth, IRegion region) {\n \t\t}\n \t}\n \n+\t@SuppressWarnings(\"StatementWithEmptyBody\")\n \tprivate static boolean removeRedundantElseBlock(MethodNode mth, IfRegion ifRegion) {\n-\t\tif (ifRegion.getElseRegion() == null\n-\t\t\t\t|| ifRegion.contains(AFlag.ELSE_IF_CHAIN)\n-\t\t\t\t|| ifRegion.getElseRegion().contains(AFlag.ELSE_IF_CHAIN)) {\n+\t\tif (ifRegion.getElseRegion() == null) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!RegionUtils.hasExitBlock(ifRegion.getThenRegion())) {\n \t\t\treturn false;\n \t\t}\n-\t\t// code style check:\n-\t\t// will remove 'return;' from 'then' and 'else' with one instruction\n-\t\t// see #jadx.tests.integration.conditions.TestConditions9\n-\t\tif (mth.isVoidReturn()\n-\t\t\t\t&& insnsCount(ifRegion.getThenRegion()) == 2\n-\t\t\t\t&& insnsCount(ifRegion.getElseRegion()) == 2) {\n-\t\t\treturn false;\n+\t\tInsnNode lastThanInsn = RegionUtils.getLastInsn(ifRegion.getThenRegion());\n+\t\tif (InsnUtils.isInsnType(lastThanInsn, InsnType.THROW)) {\n+\t\t\t// always omit else after 'throw'\n+\t\t} else {\n+\t\t\t// code style check:\n+\t\t\t// will remove 'return;' from 'then' and 'else' with one instruction\n+\t\t\t// see #jadx.tests.integration.conditions.TestConditions9\n+\t\t\tif (mth.isVoidReturn()) {\n+\t\t\t\tint thenSize = insnsCount(ifRegion.getThenRegion());\n+\t\t\t\t// keep small blocks with same or 'similar' size unchanged\n+\t\t\t\tif (thenSize < 5) {\n+\t\t\t\t\tint elseSize = insnsCount(ifRegion.getElseRegion());\n+\t\t\t\t\tint range = ifRegion.getElseRegion().contains(AFlag.ELSE_IF_CHAIN) ? 4 : 2;\n+\t\t\t\t\tif (thenSize == elseSize || (thenSize * range > elseSize && thenSize < elseSize * range)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\tIRegion parent = ifRegion.getParent();\n \t\tRegion newRegion = new Region(parent);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java b/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java\n@@ -324,6 +324,30 @@ public static boolean isRegionContainsBlock(IContainer container, BlockNode bloc\n \t\t}\n \t}\n \n+\tpublic static IContainer getSingleSubBlock(IContainer container) {\n+\t\tif (container instanceof Region) {\n+\t\t\tList<IContainer> subBlocks = ((Region) container).getSubBlocks();\n+\t\t\tif (subBlocks.size() == 1) {\n+\t\t\t\treturn ignoreSimpleRegionWrapper(subBlocks.get(0));\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate static IContainer ignoreSimpleRegionWrapper(IContainer container) {\n+\t\twhile (true) {\n+\t\t\tif (container instanceof Region) {\n+\t\t\t\tList<IContainer> subBlocks = ((Region) container).getSubBlocks();\n+\t\t\t\tif (subBlocks.size() != 1) {\n+\t\t\t\t\treturn container;\n+\t\t\t\t}\n+\t\t\t\tcontainer = subBlocks.get(0);\n+\t\t\t} else {\n+\t\t\t\treturn container;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tpublic static List<IContainer> getExcHandlersForRegion(IContainer region) {\n \t\tTryCatchBlockAttr tb = region.get(AType.TRY_BLOCK);\n \t\tif (tb != null) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestIfCodeStyle.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestIfCodeStyle.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestIfCodeStyle.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestIfCodeStyle.java\n@@ -129,8 +129,9 @@ public void test() {\n \t\tnoDebugInfo();\n \t\tassertThat(getClassNode(TestCls.class))\n \t\t\t\t.code()\n-\t\t\t\t.doesNotContain(\"else\")\n-\t\t\t\t.countString(8, \"return;\")\n+\t\t\t\t// allow one last 'else'\n+\t\t\t\t.oneOf(c -> c.doesNotContain(\"else\").countString(8, \"return;\"),\n+\t\t\t\t\t\tc -> c.countString(1, \"else\").countString(7, \"return;\"))\n \t\t\t\t.containsLines(2,\n \t\t\t\t\t\t\"if (readInt < 0) {\",\n \t\t\t\t\t\tindent() + \"if (dataPosition > Integer.MAX_VALUE - readInt) {\",\n@@ -146,8 +147,9 @@ public void testSmali() {\n \t\tdisableCompilation();\n \t\tassertThat(getClassNodeFromSmali())\n \t\t\t\t.code()\n-\t\t\t\t.doesNotContain(\"else\")\n-\t\t\t\t.countString(8, \"return;\")\n+\t\t\t\t// allow one last 'else'\n+\t\t\t\t.oneOf(c -> c.doesNotContain(\"else\").countString(8, \"return;\"),\n+\t\t\t\t\t\tc -> c.countString(1, \"else\").countString(7, \"return;\"))\n \t\t\t\t.containsLines(2,\n \t\t\t\t\t\t\"if (_aidl_parcelable_size < 0) {\",\n \t\t\t\t\t\tindent() + \"if (_aidl_start_pos > Integer.MAX_VALUE - _aidl_parcelable_size) {\",\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestIfCodeStyle2.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestIfCodeStyle2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestIfCodeStyle2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestIfCodeStyle2.java\n@@ -0,0 +1,23 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+/**\n+ * Issue #2052\n+ */\n+public class TestIfCodeStyle2 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void testSmali() {\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.countString(1, \"} else if (\")\n+\t\t\t\t.countString(1, \"} else {\")\n+\t\t\t\t.countString(19, \"return \");\n+\t}\n+}",
    "output": "Fix prefer early return for 'if-else-if' block"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/export/ExportGradleTask.java b/jadx-core/src/main/java/jadx/core/export/ExportGradleTask.java\n--- a/jadx-core/src/main/java/jadx/core/export/ExportGradleTask.java\n+++ b/jadx-core/src/main/java/jadx/core/export/ExportGradleTask.java\n@@ -55,7 +55,7 @@ public void run() {\n \t\t\t\t.orElseGet(() -> resContainers.stream()\n \t\t\t\t\t\t.filter(resContainer -> resContainer.getFileName().contains(\"strings.xml\"))\n \t\t\t\t\t\t.findFirst()\n-\t\t\t\t\t\t.orElseThrow(IllegalStateException::new));\n+\t\t\t\t\t\t.orElse(null));\n \n \t\tExportGradleProject export = new ExportGradleProject(root, projectDir, androidManifest, strings);\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/android/AndroidManifestParser.java b/jadx-core/src/main/java/jadx/core/utils/android/AndroidManifestParser.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/AndroidManifestParser.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidManifestParser.java\n@@ -36,8 +36,6 @@ public AndroidManifestParser(ResourceFile androidManifestRes, ResContainer appSt\n \n \t\tthis.androidManifest = parseAndroidManifest(androidManifestRes);\n \t\tthis.appStrings = parseAppStrings(appStrings);\n-\n-\t\tvalidateAttrs();\n \t}\n \n \tpublic boolean isManifestFound() {\n@@ -60,12 +58,6 @@ public ApplicationParams parse() {\n \t\treturn parseAttributes();\n \t}\n \n-\tprivate void validateAttrs() {\n-\t\tif (parseAttrs.contains(AppAttribute.APPLICATION_LABEL) && appStrings == null) {\n-\t\t\tthrow new IllegalArgumentException(\"APPLICATION_LABEL attribute requires non null appStrings\");\n-\t\t}\n-\t}\n-\n \tprivate ApplicationParams parseAttributes() {\n \t\tString applicationLabel = null;\n \t\tInteger minSdkVersion = null;\n@@ -113,6 +105,9 @@ private String getApplicationLabel() {\n \t\tif (application.hasAttribute(\"android:label\")) {\n \t\t\tString appLabelName = application.getAttribute(\"android:label\");\n \t\t\tif (appLabelName.startsWith(\"@string\")) {\n+\t\t\t\tif (appStrings == null) {\n+\t\t\t\t\tthrow new IllegalArgumentException(\"APPLICATION_LABEL attribute requires non null appStrings\");\n+\t\t\t\t}\n \t\t\t\tappLabelName = appLabelName.split(\"/\")[1];\n \t\t\t\tNodeList strings = appStrings.getElementsByTagName(\"string\");",
    "output": "Fix gradle export for APKs without strings.xml"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/XposedAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/XposedAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/XposedAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/XposedAction.java\n@@ -1,6 +1,7 @@\n package jadx.gui.ui.codearea;\n \n import java.util.List;\n+import java.util.Map;\n import java.util.stream.Collectors;\n \n import javax.swing.JOptionPane;\n@@ -9,11 +10,13 @@\n import org.slf4j.LoggerFactory;\n \n import jadx.api.JavaClass;\n+import jadx.api.JavaField;\n import jadx.api.JavaMethod;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.treemodel.JClass;\n+import jadx.gui.treemodel.JField;\n import jadx.gui.treemodel.JMethod;\n import jadx.gui.treemodel.JNode;\n import jadx.gui.ui.action.ActionModel;\n@@ -24,6 +27,16 @@ public class XposedAction extends JNodeAction {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(XposedAction.class);\n \tprivate static final long serialVersionUID = 2641585141624592578L;\n \n+\tprivate static final Map<String, String> PRIMITIVE_TYPE_MAPPING = Map.of(\n+\t\t\t\"int\", \"Int\",\n+\t\t\t\"byte\", \"Byte\",\n+\t\t\t\"short\", \"Short\",\n+\t\t\t\"long\", \"Long\",\n+\t\t\t\"float\", \"Float\",\n+\t\t\t\"double\", \"Double\",\n+\t\t\t\"char\", \"Char\",\n+\t\t\t\"boolean\", \"Boolean\");\n+\n \tpublic XposedAction(CodeArea codeArea) {\n \t\tsuper(ActionModel.XPOSED_COPY, codeArea);\n \t}\n@@ -43,7 +56,7 @@ public void runAction(JNode node) {\n \n \t@Override\n \tpublic boolean isActionEnabled(JNode node) {\n-\t\treturn node instanceof JMethod || node instanceof JClass;\n+\t\treturn node instanceof JMethod || node instanceof JClass || node instanceof JField;\n \t}\n \n \tprivate String generateXposedSnippet(JNode node) {\n@@ -53,6 +66,9 @@ private String generateXposedSnippet(JNode node) {\n \t\tif (node instanceof JClass) {\n \t\t\treturn generateClassSnippet((JClass) node);\n \t\t}\n+\t\tif (node instanceof JField) {\n+\t\t\treturn generateFieldSnippet((JField) node);\n+\t\t}\n \t\tthrow new JadxRuntimeException(\"Unsupported node type: \" + (node != null ? node.getClass() : \"null\"));\n \t}\n \n@@ -84,16 +100,26 @@ private String generateMethodSnippet(JMethod jMth) {\n \t\tif (mthArgs.isEmpty()) {\n \t\t\treturn String.format(xposedFormatStr, xposedMethod, rawClassName, methodName);\n \t\t}\n-\t\tString params = mthArgs.stream().map(type -> type + \".class, \").collect(Collectors.joining());\n+\t\tString params = mthArgs.stream()\n+\t\t\t\t.map(type -> (type.isGeneric() ? type.getObject() : type) + \".class, \")\n+\t\t\t\t.collect(Collectors.joining());\n \t\treturn String.format(xposedFormatStr, xposedMethod, rawClassName, methodName + params);\n \t}\n \n \tprivate String generateClassSnippet(JClass jc) {\n \t\tJavaClass javaClass = jc.getCls();\n \t\tString rawClassName = javaClass.getRawName();\n \t\tString shortClassName = javaClass.getName();\n-\t\treturn String.format(\"ClassLoader classLoader=lpparam.classLoader;\\n\"\n-\t\t\t\t+ \"Class %sClass=classLoader.loadClass(\\\"%s\\\");\",\n+\t\treturn String.format(\"ClassLoader classLoader = lpparam.classLoader;\\n\"\n+\t\t\t\t+ \"Class<?> %sClass = classLoader.loadClass(\\\"%s\\\");\",\n \t\t\t\tshortClassName, rawClassName);\n \t}\n+\n+\tprivate String generateFieldSnippet(JField jf) {\n+\t\tJavaField javaField = jf.getJavaField();\n+\t\tString isStatic = javaField.getAccessFlags().isStatic() ? \"Static\" : \"\";\n+\t\tString type = PRIMITIVE_TYPE_MAPPING.getOrDefault(javaField.getFieldNode().getType().toString(), \"Object\");\n+\t\tString xposedMethod = \"XposedHelpers.get\" + isStatic + type + \"Field\";\n+\t\treturn String.format(\"%s(/*runtimeObject*/, \\\"%s\\\");\", xposedMethod, javaField.getName());\n+\t}\n }",
    "output": "Fix correct type for generic params in Xposed snippet, add fields support"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -514,7 +514,7 @@ private void addEnumFields(ICodeWriter code) throws CodegenException {\n \t\t\t}\n \t\t\tcode.add(';');\n \t\t\tif (isFieldsPresents()) {\n-\t\t\t\tcode.startLine();\n+\t\t\t\tcode.newLine();\n \t\t\t}\n \t\t}\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -244,10 +244,14 @@ private void processConstructorInsn(EnumData data, EnumField enumField, MethodNo\n \t\tif (coResArg == null || coResArg.getSVar().getUseList().size() <= 2) {\n \t\t\tdata.toRemove.add(co);\n \t\t} else {\n-\t\t\t// constructor result used in other places -> replace constructor with enum field get (SGET)\n-\t\t\tIndexInsnNode enumGet = new IndexInsnNode(InsnType.SGET, enumField.getField().getFieldInfo(), 0);\n-\t\t\tenumGet.setResult(coResArg.duplicate());\n-\t\t\tBlockUtils.replaceInsn(classInitMth, co, enumGet);\n+\t\t\tboolean varUseFound = coResArg.getSVar().getUseList().stream()\n+\t\t\t\t\t.anyMatch(useArg -> !data.toRemove.contains(useArg.getParentInsn()));\n+\t\t\tif (varUseFound) {\n+\t\t\t\t// constructor result used in other places -> replace constructor with enum field get (SGET)\n+\t\t\t\tIndexInsnNode enumGet = new IndexInsnNode(InsnType.SGET, enumField.getField().getFieldInfo(), 0);\n+\t\t\t\tenumGet.setResult(coResArg.duplicate());\n+\t\t\t\tBlockUtils.replaceInsn(classInitMth, co, enumGet);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -336,7 +340,7 @@ private EnumField processEnumFieldByWrappedInsn(EnumData data, InsnNode wrappedI\n \t\tif (constructorInsn != null) {\n \t\t\tFieldNode enumFieldNode = createFakeField(data.cls, \"EF\" + constructorInsn.getOffset());\n \t\t\tdata.cls.addField(enumFieldNode);\n-\t\t\treturn createEnumFieldByConstructor(data.cls, enumFieldNode, constructorInsn);\n+\t\t\treturn createEnumFieldByConstructor(data, enumFieldNode, constructorInsn);\n \t\t}\n \t\treturn null;\n \t}\n@@ -365,7 +369,7 @@ private EnumField processEnumFieldByField(EnumData data, InsnNode sgetInsn) {\n \t\t\tdata.toRemove.add(sgetInsn);\n \t\t}\n \t\tdata.toRemove.add(sputInsn);\n-\t\treturn createEnumFieldByConstructor(data.cls, enumFieldNode, co);\n+\t\treturn createEnumFieldByConstructor(data, enumFieldNode, co);\n \t}\n \n \t@Nullable\n@@ -388,7 +392,7 @@ private EnumField processEnumFieldByRegister(EnumData data, RegisterArg arg) {\n \t\t\tenumFieldNode = createFakeField(data.cls, \"EF\" + arg.getRegNum());\n \t\t\tdata.cls.addField(enumFieldNode);\n \t\t}\n-\t\treturn createEnumFieldByConstructor(data.cls, enumFieldNode, (ConstructorInsn) constrInsn);\n+\t\treturn createEnumFieldByConstructor(data, enumFieldNode, (ConstructorInsn) constrInsn);\n \t}\n \n \tprivate FieldNode createFakeField(ClassNode cls, String name) {\n@@ -416,12 +420,13 @@ private FieldNode searchEnumField(EnumData data, SSAVar ssaVar) {\n \t}\n \n \t@SuppressWarnings(\"StatementWithEmptyBody\")\n-\tprivate EnumField createEnumFieldByConstructor(ClassNode cls, FieldNode enumFieldNode, ConstructorInsn co) {\n+\tprivate EnumField createEnumFieldByConstructor(EnumData data, FieldNode enumFieldNode, ConstructorInsn co) {\n \t\t// usually constructor signature is '<init>(Ljava/lang/String;I)V'.\n \t\t// sometimes for one field enum second arg can be omitted\n \t\tif (co.getArgsCount() < 1) {\n \t\t\treturn null;\n \t\t}\n+\t\tClassNode cls = data.cls;\n \t\tClassInfo clsInfo = co.getClassType();\n \t\tClassNode constrCls = cls.root().resolveClass(clsInfo);\n \t\tif (constrCls == null) {\n@@ -441,11 +446,81 @@ private EnumField createEnumFieldByConstructor(ClassNode cls, FieldNode enumFiel\n \t\tList<RegisterArg> regs = new ArrayList<>();\n \t\tco.getRegisterArgs(regs);\n \t\tif (!regs.isEmpty()) {\n-\t\t\tthrow new JadxRuntimeException(\"Init of enum \" + enumFieldNode.getName() + \" uses external variables\");\n+\t\t\tConstructorInsn replacedCo = inlineExternalRegs(data, co);\n+\t\t\tif (replacedCo == null) {\n+\t\t\t\tthrow new JadxRuntimeException(\"Init of enum field '\" + enumFieldNode.getName() + \"' uses external variables\");\n+\t\t\t}\n+\t\t\tdata.toRemove.add(co);\n+\t\t\tco = replacedCo;\n \t\t}\n \t\treturn new EnumField(enumFieldNode, co);\n \t}\n \n+\tprivate ConstructorInsn inlineExternalRegs(EnumData data, ConstructorInsn co) {\n+\t\tConstructorInsn resCo = co.copyWithoutResult();\n+\t\tList<RegisterArg> regs = new ArrayList<>();\n+\t\tresCo.getRegisterArgs(regs);\n+\t\tfor (RegisterArg reg : regs) {\n+\t\t\tFieldInfo enumField = checkExternalRegUsage(data, reg);\n+\t\t\tif (enumField == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tInsnNode enumUse = new IndexInsnNode(InsnType.SGET, enumField, 0);\n+\t\t\tboolean replaced = resCo.replaceArg(reg, InsnArg.wrapArg(enumUse));\n+\t\t\tif (!replaced) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\t\treturn resCo;\n+\t}\n+\n+\tprivate static FieldInfo checkExternalRegUsage(EnumData data, RegisterArg reg) {\n+\t\tClassNode cls = data.cls;\n+\t\tSSAVar ssaVar = reg.getSVar();\n+\t\tInsnNode assignInsn = checkInsnType(ssaVar.getAssignInsn(), InsnType.CONSTRUCTOR);\n+\t\tif (assignInsn == null || !((ConstructorInsn) assignInsn).getClassType().equals(cls.getClassInfo())) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tFieldInfo enumField = null;\n+\t\tfor (RegisterArg useArg : ssaVar.getUseList()) {\n+\t\t\tInsnNode useInsn = useArg.getParentInsn();\n+\t\t\tif (useInsn == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tswitch (useInsn.getType()) {\n+\t\t\t\tcase SPUT: {\n+\t\t\t\t\tFieldInfo field = (FieldInfo) ((IndexInsnNode) useInsn).getIndex();\n+\t\t\t\t\tif (!field.getDeclClass().equals(cls.getClassInfo())\n+\t\t\t\t\t\t\t|| !field.getType().equals(cls.getType())) {\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t}\n+\t\t\t\t\tenumField = field;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tcase CONSTRUCTOR: {\n+\t\t\t\t\tConstructorInsn useCo = (ConstructorInsn) useInsn;\n+\t\t\t\t\tif (!useCo.getClassType().equals(cls.getClassInfo())) {\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tcase FILLED_NEW_ARRAY: {\n+\t\t\t\t\t// allow usage in values init instruction\n+\t\t\t\t\tif (!data.valuesInitInsn.getArg(0).unwrap().equals(useInsn)) {\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tdefault:\n+\t\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\t\tif (enumField != null) {\n+\t\t\tdata.toRemove.add(assignInsn);\n+\t\t}\n+\t\treturn enumField;\n+\t}\n+\n \t@Nullable\n \tprivate InsnNode searchFieldPutInsn(EnumData data, FieldNode enumFieldNode) {\n \t\tfor (BlockNode block : data.staticBlocks) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumUsesOtherEnum.java b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumUsesOtherEnum.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumUsesOtherEnum.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumUsesOtherEnum.java\n@@ -0,0 +1,47 @@\n+package jadx.tests.integration.enums;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+import jadx.tests.api.extensions.profiles.TestProfile;\n+import jadx.tests.api.extensions.profiles.TestWithProfiles;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestEnumUsesOtherEnum extends SmaliTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic enum VType {\n+\t\t\tINT(1),\n+\t\t\tOTHER_INT(INT);\n+\n+\t\t\tprivate final int type;\n+\n+\t\t\tVType(int type) {\n+\t\t\t\tthis.type = type;\n+\t\t\t}\n+\n+\t\t\tVType(VType refType) {\n+\t\t\t\tthis(refType.type);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@TestWithProfiles(TestProfile.D8_J11)\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"OTHER_INT(INT);\")\n+\t\t\t\t.doesNotContain(\"\\n        \\n\"); // no indentation for empty string\n+\t}\n+\n+\t@Test\n+\tpublic void testSmali() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"public enum TestEnumUsesOtherEnum {\")\n+\t\t\t\t.doesNotContain(\"static {\");\n+\t}\n+}",
    "output": "Fix support variables reuse for enum restore"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -70,6 +70,7 @@ public BinaryXMLParser(RootNode rootNode) {\n \t}\n \n \tpublic synchronized ICodeInfo parse(InputStream inputStream) throws IOException {\n+\t\tresourceIds = null;\n \t\tis = new ParserStream(inputStream);\n \t\tif (!isBinaryXml()) {\n \t\t\treturn ResourcesLoader.loadToCodeWriter(inputStream);",
    "output": "Fix resolve resourceIds reuse issue Co-authored-by: mingyinsun <mingyinsun@tencent.com>"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n@@ -1,5 +1,6 @@\n package jadx.core.dex.visitors;\n \n+import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n@@ -58,6 +59,7 @@\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n import static jadx.core.utils.BlockUtils.replaceInsn;\n+import static jadx.core.utils.ListUtils.allMatch;\n \n /**\n  * Visitor for modify method instructions\n@@ -139,6 +141,11 @@ private static void replaceStep(MethodNode mth, InsnRemover remover) {\n \t\t\t\t\t\tprocessArith(mth, parentClass, (ArithNode) insn);\n \t\t\t\t\t\tbreak;\n \n+\t\t\t\t\tcase CMP_L:\n+\t\t\t\t\tcase CMP_G:\n+\t\t\t\t\t\tinlineCMPInsns(mth, block, i, insn, remover);\n+\t\t\t\t\t\tbreak;\n+\n \t\t\t\t\tcase CHECK_CAST:\n \t\t\t\t\t\tremoveCheckCast(mth, block, i, (IndexInsnNode) insn);\n \t\t\t\t\t\tbreak;\n@@ -348,6 +355,27 @@ private static void processArith(MethodNode mth, ClassNode parentClass, ArithNod\n \t\t}\n \t}\n \n+\t/**\n+\t * Inline CMP instructions into 'if' to help conditions merging\n+\t */\n+\tprivate static void inlineCMPInsns(MethodNode mth, BlockNode block, int i, InsnNode insn, InsnRemover remover) {\n+\t\tRegisterArg resArg = insn.getResult();\n+\t\tList<RegisterArg> useList = resArg.getSVar().getUseList();\n+\t\tif (allMatch(useList, use -> InsnUtils.isInsnType(use.getParentInsn(), InsnType.IF))) {\n+\t\t\tfor (RegisterArg useArg : new ArrayList<>(useList)) {\n+\t\t\t\tInsnNode useInsn = useArg.getParentInsn();\n+\t\t\t\tif (useInsn != null) {\n+\t\t\t\t\tInsnArg wrapArg = InsnArg.wrapInsnIntoArg(insn.copyWithoutResult());\n+\t\t\t\t\tif (!useInsn.replaceArg(useArg, wrapArg)) {\n+\t\t\t\t\t\tmth.addWarnComment(\"Failed to inline CMP insn: \" + insn + \" into \" + useInsn);\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tremover.addAndUnbind(insn);\n+\t\t}\n+\t}\n+\n \tprivate static boolean checkArrSizes(MethodNode mth, NewArrayNode newArrInsn, FillArrayInsn fillArrInsn) {\n \t\tint dataSize = fillArrInsn.getSize();\n \t\tInsnArg arrSizeArg = newArrInsn.getArg(0);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java\n--- a/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java\n@@ -10,6 +10,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.core.Consts;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.IAttributeNode;\n import jadx.core.dex.attributes.nodes.JadxError;\n@@ -19,7 +20,7 @@\n \n public class ErrorsCounter {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ErrorsCounter.class);\n-\tprivate static final boolean PRINT_MTH_SIZE = true;\n+\tprivate static final boolean PRINT_MTH_SIZE = Consts.DEBUG;\n \n \tprivate final Set<IAttributeNode> errorNodes = new HashSet<>();\n \tprivate int errorsCount;\n@@ -44,7 +45,9 @@ private synchronized <N extends IDexNode & IAttributeNode> String addError(N nod\n \n \t\tString msg = formatMsg(node, error);\n \t\tif (PRINT_MTH_SIZE && node instanceof MethodNode) {\n-\t\t\tmsg = \"[\" + ((MethodNode) node).getInsnsCount() + \"] \" + msg;\n+\t\t\tString mthSize = \"[\" + ((MethodNode) node).getInsnsCount() + \"] \";\n+\t\t\tmsg = mthSize + msg;\n+\t\t\terror = mthSize + error;\n \t\t}\n \t\tif (e == null) {\n \t\t\tLOG.error(msg);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf3.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf3.java\n@@ -0,0 +1,14 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+public class TestTernaryInIf3 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tgetClassNodeFromSmali();\n+\t}\n+}",
    "output": "Fix inline CMP instructions to help conditions merge"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n@@ -84,11 +84,9 @@ public AbstractCodeArea(ContentPanel contentPanel, JNode node) {\n \t\tthis.node = Objects.requireNonNull(node);\n \n \t\tsetMarkOccurrences(false);\n-\t\tsetEditable(node.isEditable());\n-\t\tsetCodeFoldingEnabled(false);\n \t\tsetFadeCurrentLineHighlight(true);\n-\t\tsetCloseCurlyBraces(true);\n \t\tsetAntiAliasingEnabled(true);\n+\t\tapplyEditableProperties(node);\n \t\tloadSettings();\n \n \t\tJadxSettings settings = contentPanel.getTabbedPane().getMainWindow().getSettings();\n@@ -107,6 +105,47 @@ public AbstractCodeArea(ContentPanel contentPanel, JNode node) {\n \t\t}\n \t}\n \n+\tprivate void applyEditableProperties(JNode node) {\n+\t\tboolean editable = node.isEditable();\n+\t\tsetEditable(editable);\n+\t\tsetCodeFoldingEnabled(editable);\n+\t\tif (editable) {\n+\t\t\tsetCloseCurlyBraces(true);\n+\t\t\tsetCloseMarkupTags(true);\n+\t\t\tsetAutoIndentEnabled(true);\n+\t\t\tsetClearWhitespaceLinesEnabled(true);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected JPopupMenu createPopupMenu() {\n+\t\tJPopupMenu menu = new JPopupMenu();\n+\t\tif (node.isEditable()) {\n+\t\t\tmenu.add(createPopupMenuItem(getAction(UNDO_ACTION)));\n+\t\t\tmenu.add(createPopupMenuItem(getAction(REDO_ACTION)));\n+\t\t\tmenu.addSeparator();\n+\t\t\tmenu.add(createPopupMenuItem(cutAction));\n+\t\t\tmenu.add(createPopupMenuItem(copyAction));\n+\t\t\tmenu.add(createPopupMenuItem(getAction(PASTE_ACTION)));\n+\t\t\tmenu.add(createPopupMenuItem(getAction(DELETE_ACTION)));\n+\t\t\tmenu.addSeparator();\n+\t\t\tmenu.add(createPopupMenuItem(getAction(SELECT_ALL_ACTION)));\n+\t\t} else {\n+\t\t\tmenu.add(createPopupMenuItem(copyAction));\n+\t\t\tmenu.add(createPopupMenuItem(getAction(SELECT_ALL_ACTION)));\n+\t\t}\n+\t\tappendFoldingMenu(menu);\n+\t\treturn menu;\n+\t}\n+\n+\t@Override\n+\tprotected void appendFoldingMenu(JPopupMenu popup) {\n+\t\t// append code folding popup menu entry only if enabled\n+\t\tif (isCodeFoldingEnabled()) {\n+\t\t\tsuper.appendFoldingMenu(popup);\n+\t\t}\n+\t}\n+\n \tprivate void addWrapLineMenuAction(JadxSettings settings) {\n \t\tJPopupMenu popupMenu = getPopupMenu();\n \t\tpopupMenu.addSeparator();\n@@ -280,6 +319,7 @@ private static String getWordFromToken(@Nullable Token token) {\n \n \tpublic void setLoaded() {\n \t\tthis.loaded = true;\n+\t\tdiscardAllEdits(); // disable 'undo' action to empty state (before load)\n \t}\n \n \t/**",
    "output": "Fix hide not needed popup action for not editable code"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/ProcessClass.java b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n--- a/jadx-core/src/main/java/jadx/core/ProcessClass.java\n+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n@@ -104,7 +104,6 @@ public ICodeInfo generateCode(ClassNode cls) {\n \t\ttry {\n \t\t\tif (cls.contains(AFlag.DONT_GENERATE)) {\n \t\t\t\tprocess(cls, false);\n-\t\t\t\tLOG.warn(\"Requested code for class with DONT_GENERATE flag: {}\", cls);\n \t\t\t\treturn NOT_GENERATED;\n \t\t\t}\n \t\t\tfor (ClassNode depCls : cls.getDependencies()) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/search/providers/BaseSearchProvider.java b/jadx-gui/src/main/java/jadx/gui/search/providers/BaseSearchProvider.java\n--- a/jadx-gui/src/main/java/jadx/gui/search/providers/BaseSearchProvider.java\n+++ b/jadx-gui/src/main/java/jadx/gui/search/providers/BaseSearchProvider.java\n@@ -1,9 +1,12 @@\n package jadx.gui.search.providers;\n \n import java.util.List;\n+import java.util.Objects;\n \n+import jadx.api.JadxDecompiler;\n import jadx.api.JavaClass;\n import jadx.api.JavaNode;\n+import jadx.core.dex.nodes.ICodeNode;\n import jadx.gui.search.ISearchMethod;\n import jadx.gui.search.ISearchProvider;\n import jadx.gui.search.SearchSettings;\n@@ -15,12 +18,14 @@\n public abstract class BaseSearchProvider implements ISearchProvider {\n \n \tprivate final JNodeCache nodeCache;\n+\tprivate final JadxDecompiler decompiler;\n \tprotected final ISearchMethod searchMth;\n \tprotected final String searchStr;\n \tprotected final List<JavaClass> classes;\n \n \tpublic BaseSearchProvider(MainWindow mw, SearchSettings searchSettings, List<JavaClass> classes) {\n \t\tthis.nodeCache = mw.getCacheObject().getNodeCache();\n+\t\tthis.decompiler = mw.getWrapper().getDecompiler();\n \t\tthis.searchMth = searchSettings.getSearchMethod();\n \t\tthis.searchStr = searchSettings.getSearchString();\n \t\tthis.classes = classes;\n@@ -38,6 +43,11 @@ protected JClass convert(JavaClass cls) {\n \t\treturn nodeCache.makeFrom(cls);\n \t}\n \n+\tprotected JNode convert(ICodeNode codeNode) {\n+\t\tJavaNode node = Objects.requireNonNull(decompiler.getJavaNodeByRef(codeNode));\n+\t\treturn Objects.requireNonNull(nodeCache.makeFrom(node));\n+\t}\n+\n \t@Override\n \tpublic int total() {\n \t\treturn classes.size();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/search/providers/ClassSearchProvider.java b/jadx-gui/src/main/java/jadx/gui/search/providers/ClassSearchProvider.java\n--- a/jadx-gui/src/main/java/jadx/gui/search/providers/ClassSearchProvider.java\n+++ b/jadx-gui/src/main/java/jadx/gui/search/providers/ClassSearchProvider.java\n@@ -1,7 +1,6 @@\n package jadx.gui.search.providers;\n \n import java.util.List;\n-import java.util.stream.Collectors;\n \n import org.jetbrains.annotations.Nullable;\n \n@@ -17,16 +16,7 @@ public final class ClassSearchProvider extends BaseSearchProvider {\n \tprivate int clsNum = 0;\n \n \tpublic ClassSearchProvider(MainWindow mw, SearchSettings searchSettings, List<JavaClass> classes) {\n-\t\tsuper(mw, searchSettings, filterClasses(classes));\n-\t}\n-\n-\t/**\n-\t * Collect top class with code\n-\t */\n-\tprivate static List<JavaClass> filterClasses(List<JavaClass> classes) {\n-\t\treturn classes.stream()\n-\t\t\t\t.filter(cls -> !cls.isInner() && !cls.isNoCode())\n-\t\t\t\t.collect(Collectors.toList());\n+\t\tsuper(mw, searchSettings, classes);\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/search/providers/CodeSearchProvider.java b/jadx-gui/src/main/java/jadx/gui/search/providers/CodeSearchProvider.java\n--- a/jadx-gui/src/main/java/jadx/gui/search/providers/CodeSearchProvider.java\n+++ b/jadx-gui/src/main/java/jadx/gui/search/providers/CodeSearchProvider.java\n@@ -45,12 +45,14 @@ public CodeSearchProvider(MainWindow mw, SearchSettings searchSettings, List<Jav\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tJavaClass cls = classes.get(clsNum);\n-\t\t\tif (!cls.getClassNode().isInner()) {\n-\t\t\t\tif (code == null) {\n-\t\t\t\t\tcode = getClassCode(cls, codeCache);\n-\t\t\t\t}\n-\t\t\t\tJNode newResult = searchNext(cls, code);\n+\t\t\tString clsCode = code;\n+\t\t\tif (clsCode == null && !cls.isInner() && !cls.isNoCode()) {\n+\t\t\t\tclsCode = getClassCode(cls, codeCache);\n+\t\t\t}\n+\t\t\tif (clsCode != null) {\n+\t\t\t\tJNode newResult = searchNext(cls, clsCode);\n \t\t\t\tif (newResult != null) {\n+\t\t\t\t\tcode = clsCode;\n \t\t\t\t\treturn newResult;\n \t\t\t\t}\n \t\t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/search/providers/FieldSearchProvider.java b/jadx-gui/src/main/java/jadx/gui/search/providers/FieldSearchProvider.java\n--- a/jadx-gui/src/main/java/jadx/gui/search/providers/FieldSearchProvider.java\n+++ b/jadx-gui/src/main/java/jadx/gui/search/providers/FieldSearchProvider.java\n@@ -5,8 +5,8 @@\n import org.jetbrains.annotations.Nullable;\n \n import jadx.api.JavaClass;\n-import jadx.api.JavaField;\n import jadx.core.dex.info.FieldInfo;\n+import jadx.core.dex.nodes.FieldNode;\n import jadx.gui.jobs.Cancelable;\n import jadx.gui.search.SearchSettings;\n import jadx.gui.treemodel.JNode;\n@@ -28,10 +28,10 @@ public FieldSearchProvider(MainWindow mw, SearchSettings searchSettings, List<Ja\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tJavaClass cls = classes.get(clsNum);\n-\t\t\tList<JavaField> fields = cls.getFields();\n+\t\t\tList<FieldNode> fields = cls.getClassNode().getFields();\n \t\t\tif (fldNum < fields.size()) {\n-\t\t\t\tJavaField fld = fields.get(fldNum++);\n-\t\t\t\tif (checkField(fld)) {\n+\t\t\t\tFieldNode fld = fields.get(fldNum++);\n+\t\t\t\tif (checkField(fld.getFieldInfo())) {\n \t\t\t\t\treturn convert(fld);\n \t\t\t\t}\n \t\t\t} else {\n@@ -44,9 +44,10 @@ public FieldSearchProvider(MainWindow mw, SearchSettings searchSettings, List<Ja\n \t\t}\n \t}\n \n-\tprivate boolean checkField(JavaField field) {\n-\t\tFieldInfo fieldInfo = field.getFieldNode().getFieldInfo();\n-\t\treturn isMatch(fieldInfo.getName()) || isMatch(fieldInfo.getAlias());\n+\tprivate boolean checkField(FieldInfo fieldInfo) {\n+\t\treturn isMatch(fieldInfo.getName())\n+\t\t\t\t|| isMatch(fieldInfo.getAlias())\n+\t\t\t\t|| isMatch(fieldInfo.getFullId());\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/search/providers/MethodSearchProvider.java b/jadx-gui/src/main/java/jadx/gui/search/providers/MethodSearchProvider.java\n--- a/jadx-gui/src/main/java/jadx/gui/search/providers/MethodSearchProvider.java\n+++ b/jadx-gui/src/main/java/jadx/gui/search/providers/MethodSearchProvider.java\n@@ -32,7 +32,7 @@ public MethodSearchProvider(MainWindow mw, SearchSettings searchSettings, List<J\n \t\t\tif (mthNum < methods.size()) {\n \t\t\t\tMethodNode mth = methods.get(mthNum++);\n \t\t\t\tif (checkMth(mth.getMethodInfo())) {\n-\t\t\t\t\treturn convert(mth.getJavaNode());\n+\t\t\t\t\treturn convert(mth);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tclsNum++;",
    "output": "Fix another try to fix code search"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -657,6 +657,10 @@ private String useClassInternal(ClassInfo useCls, ClassInfo extClsInfo) {\n \t\tif (useCls.equals(extClsInfo)) {\n \t\t\treturn shortName;\n \t\t}\n+\t\tif (extClsInfo.getAliasPkg().isEmpty()) {\n+\t\t\t// omit import for default package\n+\t\t\treturn shortName;\n+\t\t}\n \t\tif (isClassInnerFor(useCls, extClsInfo)) {\n \t\t\treturn shortName;\n \t\t}\n@@ -678,10 +682,6 @@ private String useClassInternal(ClassInfo useCls, ClassInfo extClsInfo) {\n \t\tif (extClsInfo.getPackage().equals(useCls.getPackage()) && !extClsInfo.isInner()) {\n \t\t\treturn shortName;\n \t\t}\n-\t\t// ignore classes from default package\n-\t\tif (extClsInfo.isDefaultPackage()) {\n-\t\t\treturn shortName;\n-\t\t}\n \t\tif (extClsInfo.getAliasPkg().equals(useCls.getAliasPkg())) {\n \t\t\tfullName = extClsInfo.getAliasNameWithoutPackage();\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/TestDefPkgRename.java b/jadx-core/src/test/java/jadx/tests/integration/names/TestDefPkgRename.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/TestDefPkgRename.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestDefPkgRename.java\n@@ -0,0 +1,67 @@\n+package jadx.tests.integration.names;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestDefPkgRename extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tList<ClassNode> clsList = loadFromSmaliFiles();\n+\t\t// class A moved to 'defpackage'\n+\t\tassertThat(searchCls(clsList, \"A\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"package defpackage;\");\n+\t\tassertThat(searchCls(clsList, \"pkg.B\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"import defpackage.A;\")\n+\t\t\t\t.containsOne(\"public A a;\");\n+\t}\n+\n+\t@Test\n+\tpublic void testNoImports() {\n+\t\targs.setUseImports(false);\n+\t\tList<ClassNode> clsList = loadFromSmaliFiles();\n+\t\t// class A moved to 'defpackage', but use full names\n+\t\tassertThat(searchCls(clsList, \"A\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"package defpackage;\");\n+\t\tassertThat(searchCls(clsList, \"pkg.B\"))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"import\")\n+\t\t\t\t.containsOne(\"public defpackage.A a;\");\n+\t}\n+\n+\t@Test\n+\tpublic void testDeobf() {\n+\t\tenableDeobfuscation();\n+\t\tList<ClassNode> clsList = loadFromSmaliFiles();\n+\t\t// package for class A deobfuscated\n+\t\tassertThat(searchCls(clsList, \"pkg.B\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"import p000.C0000A;\")\n+\t\t\t\t.containsOne(\"public C0000A f0a;\");\n+\t}\n+\n+\t@Test\n+\tpublic void testRenameDisabled() {\n+\t\tdisableCompilation();\n+\t\targs.setRenameFlags(Collections.emptySet());\n+\t\tList<ClassNode> clsList = loadFromSmaliFiles();\n+\t\t// no renaming, code will not compile\n+\t\tassertThat(searchCls(clsList, \"A\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"// default package\");\n+\t\tassertThat(searchCls(clsList, \"pkg.B\"))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"import\") // omit import\n+\t\t\t\t.containsOne(\"public A a;\");\n+\t}\n+}",
    "output": "Use correct imports for classes from default package"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -281,14 +281,16 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t\tMap<Integer, Integer> entryOffsetMap = new LinkedHashMap<>(entryCount);\n \t\tif (flagSparse) {\n \t\t\tfor (int i = 0; i < entryCount; i++) {\n-\t\t\t\tentryOffsetMap.put(is.readInt16(), is.readInt16());\n+\t\t\t\tint idx = is.readInt16();\n+\t\t\t\tint offset = is.readInt16() * 4; // The offset in ResTable_sparseTypeEntry::offset is stored divided by 4.\n+\t\t\t\tentryOffsetMap.put(idx, offset);\n \t\t\t}\n \t\t} else {\n \t\t\tfor (int i = 0; i < entryCount; i++) {\n \t\t\t\tentryOffsetMap.put(i, is.readInt32());\n \t\t\t}\n \t\t}\n-\t\tis.checkPos(entriesStart, \"Expected entry start\");\n+\t\tis.checkPos(entriesStart, \"Expected first entry start\");\n \t\tint processed = 0;\n \t\tfor (int index : entryOffsetMap.keySet()) {\n \t\t\tint offset = entryOffsetMap.get(index);\n@@ -299,6 +301,7 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t\t\t\t\tLOG.warn(\"End of chunk reached - ignoring remaining {} entries\", entryCount - processed);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n+\t\t\t\tis.checkPos(entriesStart + offset, \"Expected start of entry \" + index);\n \t\t\t\tparseEntry(pkg, id, index, config.getQualifiers());\n \t\t\t}\n \t\t\tprocessed++;",
    "output": "Fix add resource entry offset check"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -37,7 +37,7 @@\n public class BinaryXMLParser extends CommonBinaryParser {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(BinaryXMLParser.class);\n \n-\tprivate static final boolean ATTR_NEW_LINE = false;\n+\tprivate static final boolean ATTR_NEW_LINE = true;\n \n \tprivate final Map<Integer, String> resNames;\n \tprivate Map<String, String> nsMap;",
    "output": "Fix place xml attributes on new line"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n@@ -112,10 +112,11 @@ private void updateTitle(String searchText) {\n \t\t}\n \t}\n \n-\tpublic void updateHighlightContext(String text, boolean caseSensitive, boolean regexp) {\n+\tpublic void updateHighlightContext(String text, boolean caseSensitive, boolean regexp, boolean wholeWord) {\n \t\tupdateTitle(text);\n \t\thighlightContext = new SearchContext(text);\n \t\thighlightContext.setMatchCase(caseSensitive);\n+\t\thighlightContext.setWholeWord(wholeWord);\n \t\thighlightContext.setRegularExpression(regexp);\n \t\thighlightContext.setMarkAll(true);\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n@@ -595,7 +595,7 @@ private void updateTable() {\n \n \tprivate void updateTableHighlight() {\n \t\tString text = searchField.getText();\n-\t\tupdateHighlightContext(text, !options.contains(IGNORE_CASE), options.contains(USE_REGEX));\n+\t\tupdateHighlightContext(text, !options.contains(IGNORE_CASE), options.contains(USE_REGEX), false);\n \t\tcache.setLastSearch(text);\n \t\tcache.getLastSearchOptions().put(searchPreset, options);\n \t\tif (!mainWindow.getSettings().isUseAutoSearch()) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n@@ -160,7 +160,7 @@ protected void loadFinished() {\n \n \t\tCollections.sort(usageList);\n \t\tresultsModel.addAll(usageList);\n-\t\tupdateHighlightContext(node.getName(), true, false);\n+\t\tupdateHighlightContext(node.getName(), true, false, true);\n \t\tresultsTable.initColumnWidth();\n \t\tresultsTable.updateTable();\n \t\tupdateProgressLabel(true);",
    "output": "Fix improve highlight in UsageDialog"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n@@ -79,7 +79,7 @@ public void changeShortName(String aliasName) {\n \n \tpublic void changePkg(String aliasPkg) {\n \t\tif (isInner()) {\n-\t\t\tthrow new JadxRuntimeException(\"Can't change package for inner class\");\n+\t\t\tthrow new JadxRuntimeException(\"Can't change package for inner class: \" + this);\n \t\t}\n \t\tif (!Objects.equals(getAliasPkg(), aliasPkg)) {\n \t\t\tClassAliasInfo newAlias = new ClassAliasInfo(aliasPkg, getAliasShortName());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -582,7 +582,7 @@ public void rename(String newName) {\n \t\t\tclsInfo.changeShortName(newName);\n \t\t\treturn;\n \t\t}\n-\t\tif (isInner()) {\n+\t\tif (clsInfo.isInner()) {\n \t\t\taddWarn(\"Can't change package for inner class: \" + this + \" to \" + newName);\n \t\t\treturn;\n \t\t}\n@@ -598,7 +598,7 @@ public void rename(String newName) {\n \n \tprivate boolean changeClassNodePackage(String fullPkg) {\n \t\tif (clsInfo.isInner()) {\n-\t\t\tthrow new JadxRuntimeException(\"Can't change package for inner class\");\n+\t\t\tthrow new JadxRuntimeException(\"Can't change package for inner class: \" + clsInfo);\n \t\t}\n \t\tif (fullPkg.equals(clsInfo.getAliasPkg())) {\n \t\t\treturn false;\n@@ -618,7 +618,7 @@ public void removeAlias() {\n \n \t@Override\n \tpublic void onParentPackageUpdate(PackageNode updatedPkg) {\n-\t\tif (isInner()) {\n+\t\tif (clsInfo.isInner()) {\n \t\t\treturn;\n \t\t}\n \t\tclsInfo.changePkg(packageNode.getAliasPkgInfo().getFullName());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -313,7 +313,7 @@ private void initInnerClasses() {\n \t\t}\n \t\tclasses.forEach(ClassNode::updateParentClass);\n \t\tfor (PackageNode pkg : packages) {\n-\t\t\tpkg.getClasses().removeIf(ClassNode::isInner);\n+\t\t\tpkg.getClasses().removeIf(cls -> cls.getClassInfo().isInner());\n \t\t}\n \t}",
    "output": "Fix attempt to improve package rename checks"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java\n@@ -136,8 +136,7 @@ public void removeAttr(IJadxAttribute attr) {\n \n \t@Override\n \tpublic void clearAttributes() {\n-\t\tstorage.clear();\n-\t\tunloadIfEmpty();\n+\t\tstorage = EMPTY_ATTR_STORAGE;\n \t}\n \n \t/**\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java\n@@ -7,6 +7,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.function.Consumer;\n \n import jadx.api.plugins.input.data.annotations.IAnnotation;\n import jadx.api.plugins.input.data.attributes.IJadxAttrType;\n@@ -48,14 +49,11 @@ public void add(AFlag flag) {\n \t}\n \n \tpublic void add(IJadxAttribute attr) {\n-\t\twriteAttributes().put(attr.getAttrType(), attr);\n+\t\twriteAttributes(map -> map.put(attr.getAttrType(), attr));\n \t}\n \n \tpublic void add(List<IJadxAttribute> list) {\n-\t\tMap<IJadxAttrType<?>, IJadxAttribute> map = writeAttributes();\n-\t\tfor (IJadxAttribute attr : list) {\n-\t\t\tmap.put(attr.getAttrType(), attr);\n-\t\t}\n+\t\twriteAttributes(map -> list.forEach(attr -> map.put(attr.getAttrType(), attr)));\n \t}\n \n \tpublic <T> void add(IJadxAttrType<AttrList<T>> type, T obj) {\n@@ -69,7 +67,9 @@ public <T> void add(IJadxAttrType<AttrList<T>> type, T obj) {\n \n \tpublic void addAll(AttributeStorage otherList) {\n \t\tflags.addAll(otherList.flags);\n-\t\twriteAttributes().putAll(otherList.attributes);\n+\t\tif (!otherList.attributes.isEmpty()) {\n+\t\t\twriteAttributes(m -> m.putAll(otherList.attributes));\n+\t\t}\n \t}\n \n \tpublic boolean contains(AFlag flag) {\n@@ -104,43 +104,42 @@ public void remove(AFlag flag) {\n \n \tpublic <T extends IJadxAttribute> void remove(IJadxAttrType<T> type) {\n \t\tif (!attributes.isEmpty()) {\n-\t\t\tattributes.remove(type);\n+\t\t\twriteAttributes(map -> map.remove(type));\n \t\t}\n \t}\n \n \tpublic void remove(IJadxAttribute attr) {\n \t\tif (!attributes.isEmpty()) {\n-\t\t\tIJadxAttrType<? extends IJadxAttribute> type = attr.getAttrType();\n-\t\t\tIJadxAttribute a = attributes.get(type);\n-\t\t\tif (a == attr) {\n-\t\t\t\tattributes.remove(type);\n-\t\t\t}\n+\t\t\twriteAttributes(map -> {\n+\t\t\t\tIJadxAttrType<? extends IJadxAttribute> type = attr.getAttrType();\n+\t\t\t\tIJadxAttribute a = map.get(type);\n+\t\t\t\tif (a == attr) {\n+\t\t\t\t\tmap.remove(type);\n+\t\t\t\t}\n+\t\t\t});\n \t\t}\n \t}\n \n-\tprivate Map<IJadxAttrType<?>, IJadxAttribute> writeAttributes() {\n+\tprivate void writeAttributes(Consumer<Map<IJadxAttrType<?>, IJadxAttribute>> mapConsumer) {\n \t\tif (attributes.isEmpty()) {\n \t\t\tattributes = new IdentityHashMap<>(5);\n \t\t}\n-\t\treturn attributes;\n-\t}\n-\n-\tpublic void clear() {\n-\t\tflags.clear();\n-\t\tif (!attributes.isEmpty()) {\n-\t\t\tattributes.clear();\n+\t\tsynchronized (this) {\n+\t\t\tmapConsumer.accept(attributes);\n \t\t}\n \t}\n \n-\tpublic synchronized void unloadAttributes() {\n+\tpublic void unloadAttributes() {\n \t\tif (attributes.isEmpty()) {\n \t\t\treturn;\n \t\t}\n-\t\tattributes.entrySet().removeIf(entry -> !entry.getValue().keepLoaded());\n+\t\tsynchronized (this) {\n+\t\t\tattributes.entrySet().removeIf(entry -> !entry.getValue().keepLoaded());\n+\t\t}\n \t}\n \n \tpublic List<String> getAttributeStrings() {\n-\t\tint size = flags.size() + attributes.size() + attributes.size();\n+\t\tint size = flags.size() + attributes.size();\n \t\tif (size == 0) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java\n@@ -34,11 +34,6 @@ public <T> List<T> getAll(IJadxAttrType<AttrList<T>> type) {\n \t\treturn Collections.emptyList();\n \t}\n \n-\t@Override\n-\tpublic void clear() {\n-\t\t// ignore\n-\t}\n-\n \t@Override\n \tpublic void remove(AFlag flag) {\n \t\t// ignore\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -351,8 +351,8 @@ public void deepUnload() {\n \t\t\t// manually added class\n \t\t\treturn;\n \t\t}\n-\t\tunload();\n \t\tclearAttributes();\n+\t\tunload();\n \t\troot().getConstValues().removeForClass(this);\n \t\tload(clsData, true);\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/functional/AttributeStorageTest.java b/jadx-core/src/test/java/jadx/tests/functional/AttributeStorageTest.java\n--- a/jadx-core/src/test/java/jadx/tests/functional/AttributeStorageTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/functional/AttributeStorageTest.java\n@@ -70,15 +70,4 @@ public void testRemoveOtherAttribute() {\n \t\tassertThat(storage.contains(TEST), is(true));\n \t\tassertThat(storage.get(TEST), is(attr));\n \t}\n-\n-\t@Test\n-\tpublic void clear() {\n-\t\tstorage.add(SYNTHETIC);\n-\t\tstorage.add(new TestAttr());\n-\t\tstorage.clear();\n-\n-\t\tassertThat(storage.contains(SYNTHETIC), is(false));\n-\t\tassertThat(storage.contains(TEST), is(false));\n-\t\tassertThat(storage.get(TEST), nullValue());\n-\t}\n }",
    "output": "Fix synchronize attributes map writes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/plugins/utils/ZipSecurity.java b/jadx-core/src/main/java/jadx/api/plugins/utils/ZipSecurity.java\n--- a/jadx-core/src/main/java/jadx/api/plugins/utils/ZipSecurity.java\n+++ b/jadx-core/src/main/java/jadx/api/plugins/utils/ZipSecurity.java\n@@ -17,8 +17,17 @@\n public class ZipSecurity {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ZipSecurity.class);\n \n-\t// size of uncompressed zip entry shouldn't be bigger of compressed in MAX_SIZE_DIFF times\n-\tprivate static final int MAX_SIZE_DIFF = 100;\n+\t/**\n+\t * size of uncompressed zip entry shouldn't be bigger of compressed in\n+\t * {@link #ZIP_BOMB_DETECTION_FACTOR} times\n+\t */\n+\tprivate static final int ZIP_BOMB_DETECTION_FACTOR = 100;\n+\n+\t/**\n+\t * Zip entries that have an uncompressed size of less than {@link #ZIP_BOMB_MIN_UNCOMPRESSED_SIZE}\n+\t * are considered safe\n+\t */\n+\tprivate static final int ZIP_BOMB_MIN_UNCOMPRESSED_SIZE = 25 * 1024 * 1024;\n \tprivate static final int MAX_ENTRIES_COUNT = 100_000;\n \n \tprivate ZipSecurity() {\n@@ -64,13 +73,11 @@ public static boolean isValidZipEntryName(String entryName) {\n \tpublic static boolean isZipBomb(ZipEntry entry) {\n \t\tlong compressedSize = entry.getCompressedSize();\n \t\tlong uncompressedSize = entry.getSize();\n-\t\tif (compressedSize < 0 || uncompressedSize < 0) {\n-\t\t\tLOG.error(\"Zip bomb attack detected, invalid sizes: compressed {}, uncompressed {}, name {}\",\n-\t\t\t\t\tcompressedSize, uncompressedSize, entry.getName());\n-\t\t\treturn true;\n-\t\t}\n-\t\tif (compressedSize * MAX_SIZE_DIFF < uncompressedSize) {\n-\t\t\tLOG.error(\"Zip bomb attack detected, invalid sizes: compressed {}, uncompressed {}, name {}\",\n+\t\tboolean invalidSize = (compressedSize < 0) || (uncompressedSize < 0);\n+\t\tboolean possibleZipBomb = (uncompressedSize >= ZIP_BOMB_MIN_UNCOMPRESSED_SIZE)\n+\t\t\t\t&& (compressedSize * ZIP_BOMB_DETECTION_FACTOR < uncompressedSize);\n+\t\tif (invalidSize || possibleZipBomb) {\n+\t\t\tLOG.error(\"Potential zip bomb attack detected, invalid sizes: compressed {}, uncompressed {}, name {}\",\n \t\t\t\t\tcompressedSize, uncompressedSize, entry.getName());\n \t\t\treturn true;\n \t\t}",
    "output": "Fix exclude ZIP entries of less than 25MB uncompressed size from ZIP bomb check"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/android/AndroidManifestParser.java b/jadx-core/src/main/java/jadx/core/utils/android/AndroidManifestParser.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/AndroidManifestParser.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidManifestParser.java\n@@ -223,6 +223,10 @@ private static Document parseAppStrings(ResContainer appStrings) {\n \t}\n \n \tprivate static Document parseAndroidManifest(ResourceFile androidManifest) {\n+\t\tif (androidManifest == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n \t\tString content = androidManifest.loadContent().getText().getCodeStr();\n \n \t\treturn parseXml(content);",
    "output": "Fix resolve exception when androidmanifest.xml is not found"
  },
  {
    "input": "diff --git a/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java b/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n--- a/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n+++ b/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n@@ -27,12 +27,12 @@ void testSimpleAttr() {\n \t\tList<ResContainer> files = resXmlGen.makeResourcesXml();\n \n \t\tassertEquals(1, files.size());\n-\t\tassertEquals(\"res/values/attrs.xml\", files.get(0).getFileName());\n+\t\tassertEquals(\"res/values/attrs.xml\", files.get(0).getName());\n \t\tassertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n \t\t\t\t+ \"<resources>\\n\"\n \t\t\t\t+ \"    <attr name=\\\"size\\\" format=\\\"dimension\\\">\\n\"\n \t\t\t\t+ \"    </attr>\\n\"\n-\t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n+\t\t\t\t+ \"</resources>\", adaptLineEndings(files.get(0).getText().toString()));\n \t}\n \n \t@Test\n@@ -48,13 +48,13 @@ void testAttrEnum() {\n \t\tList<ResContainer> files = resXmlGen.makeResourcesXml();\n \n \t\tassertEquals(1, files.size());\n-\t\tassertEquals(\"res/values/attrs.xml\", files.get(0).getFileName());\n+\t\tassertEquals(\"res/values/attrs.xml\", files.get(0).getName());\n \t\tassertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n \t\t\t\t+ \"<resources>\\n\"\n \t\t\t\t+ \"    <attr name=\\\"size\\\">\\n\"\n \t\t\t\t+ \"        <enum name=\\\"android:string.aerr_wait\\\" value=\\\"1\\\" />\\n\"\n \t\t\t\t+ \"    </attr>\\n\"\n-\t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n+\t\t\t\t+ \"</resources>\", adaptLineEndings(files.get(0).getText().toString()));\n \t}\n \n \t@Test\n@@ -70,13 +70,13 @@ void testAttrFlag() {\n \t\tList<ResContainer> files = resXmlGen.makeResourcesXml();\n \n \t\tassertEquals(1, files.size());\n-\t\tassertEquals(\"res/values/attrs.xml\", files.get(0).getFileName());\n+\t\tassertEquals(\"res/values/attrs.xml\", files.get(0).getName());\n \t\tassertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n \t\t\t\t+ \"<resources>\\n\"\n \t\t\t\t+ \"    <attr name=\\\"size\\\">\\n\"\n \t\t\t\t+ \"        <flag name=\\\"android:string.aerr_wait\\\" value=\\\"1\\\" />\\n\"\n \t\t\t\t+ \"    </attr>\\n\"\n-\t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n+\t\t\t\t+ \"</resources>\", adaptLineEndings(files.get(0).getText().toString()));\n \t}\n \n \t@Test\n@@ -92,12 +92,12 @@ void testAttrMin() {\n \t\tList<ResContainer> files = resXmlGen.makeResourcesXml();\n \n \t\tassertEquals(1, files.size());\n-\t\tassertEquals(\"res/values/attrs.xml\", files.get(0).getFileName());\n+\t\tassertEquals(\"res/values/attrs.xml\", files.get(0).getName());\n \t\tassertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n \t\t\t\t+ \"<resources>\\n\"\n \t\t\t\t+ \"    <attr name=\\\"size\\\" format=\\\"integer\\\" min=\\\"1\\\">\\n\"\n \t\t\t\t+ \"    </attr>\\n\"\n-\t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n+\t\t\t\t+ \"</resources>\", adaptLineEndings(files.get(0).getText().toString()));\n \t}\n \n \t@Test\n@@ -116,15 +116,15 @@ void testStyle() {\n \t\tList<ResContainer> files = resXmlGen.makeResourcesXml();\n \n \t\tassertEquals(1, files.size());\n-\t\tassertEquals(\"res/values/styles.xml\", files.get(0).getFileName());\n+\t\tassertEquals(\"res/values/styles.xml\", files.get(0).getName());\n \t\tassertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n \t\t\t\t+ \"<resources>\\n\"\n \t\t\t\t+ \"    <style name=\\\"JadxGui\\\" parent=\\\"\\\">\\n\"\n \t\t\t\t+ \"        <item name=\\\"android:windowBackground\\\">@android:color/transparent</item>\\n\"\n \t\t\t\t+ \"    </style>\\n\"\n \t\t\t\t+ \"    <style name=\\\"JadxGui.Dialog\\\" parent=\\\"@style/JadxGui\\\">\\n\"\n \t\t\t\t+ \"    </style>\\n\"\n-\t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n+\t\t\t\t+ \"</resources>\", adaptLineEndings(files.get(0).getText().toString()));\n \t}\n \n \t@Test\n@@ -142,11 +142,11 @@ void testString() {\n \t\tList<ResContainer> files = resXmlGen.makeResourcesXml();\n \n \t\tassertEquals(1, files.size());\n-\t\tassertEquals(\"res/values/strings.xml\", files.get(0).getFileName());\n+\t\tassertEquals(\"res/values/strings.xml\", files.get(0).getName());\n \t\tassertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n \t\t\t\t+ \"<resources>\\n\"\n \t\t\t\t+ \"    <string name=\\\"app_name\\\">Jadx Decompiler App</string>\\n\"\n-\t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n+\t\t\t\t+ \"</resources>\", adaptLineEndings(files.get(0).getText().toString()));\n \t}\n \n \t@Test\n@@ -164,11 +164,11 @@ void testStringFormattedFalse() {\n \t\tList<ResContainer> files = resXmlGen.makeResourcesXml();\n \n \t\tassertEquals(1, files.size());\n-\t\tassertEquals(\"res/values/strings.xml\", files.get(0).getFileName());\n+\t\tassertEquals(\"res/values/strings.xml\", files.get(0).getName());\n \t\tassertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n \t\t\t\t+ \"<resources>\\n\"\n \t\t\t\t+ \"    <string name=\\\"app_name\\\" formatted=\\\"false\\\">%s at %s</string>\\n\"\n-\t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n+\t\t\t\t+ \"</resources>\", adaptLineEndings(files.get(0).getText().toString()));\n \t}\n \n \t@Test\n@@ -186,12 +186,19 @@ void testArrayEscape() {\n \t\tList<ResContainer> files = resXmlGen.makeResourcesXml();\n \n \t\tassertEquals(1, files.size());\n-\t\tassertEquals(\"res/values/arrays.xml\", files.get(0).getFileName());\n+\t\tassertEquals(\"res/values/arrays.xml\", files.get(0).getName());\n \t\tassertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n \t\t\t\t+ \"<resources>\\n\"\n \t\t\t\t+ \"    <array name=\\\"single_quote_escape_sample\\\">\\n\"\n \t\t\t\t+ \"        <item>Let\\\\'s go</item>\\n\"\n \t\t\t\t+ \"    </array>\\n\"\n-\t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n+\t\t\t\t+ \"</resources>\", adaptLineEndings(files.get(0).getText().toString()));\n+\t}\n+\n+\tprivate static String adaptLineEndings(String input) {\n+\t\tif (System.lineSeparator().equals(\"\\n\")) {\n+\t\t\treturn input; // no adaption necessary\n+\t\t}\n+\t\treturn input.replaceAll(System.lineSeparator(), \"\\n\");\n \t}\n }",
    "output": "Fix ResXmlGenTest fails on Windows * fix(core): fix ResXmlGenTest fails on Windows * code style"
  },
  {
    "input": "diff --git a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/JavaInputLoader.java b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/JavaInputLoader.java\n--- a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/JavaInputLoader.java\n+++ b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/JavaInputLoader.java\n@@ -101,7 +101,7 @@ private List<JavaClassReader> collectFromZip(File file, String name) {\n \t\t\t\t}\n \t\t\t});\n \t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Failed to process zip file: {}\", file.getAbsolutePath(), e);\n+\t\t\tLOG.error(\"Failed to process zip file: {}\", name, e);\n \t\t}\n \t\treturn result;\n \t}",
    "output": "Fix disable zip file checks for new JVM versions"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java\n@@ -132,6 +132,15 @@ public String makeStringHtml() {\n \t\treturn name;\n \t}\n \n+\t@Override\n+\tpublic boolean disableHtml() {\n+\t\tif (name.isEmpty()) {\n+\t\t\t// show PACKAGE_DEFAULT_HTML_STR for empty package\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n \t@Override\n \tpublic String makeLongString() {\n \t\treturn pkg.getFullName();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n@@ -40,6 +40,7 @@\n import jadx.gui.settings.JadxProject;\n import jadx.gui.treemodel.JClass;\n import jadx.gui.treemodel.JNode;\n+import jadx.gui.treemodel.JPackage;\n import jadx.gui.treemodel.JRenameNode;\n import jadx.gui.ui.MainWindow;\n import jadx.gui.ui.TabbedPane;\n@@ -51,6 +52,7 @@\n import jadx.gui.utils.NLS;\n import jadx.gui.utils.TextStandardActions;\n import jadx.gui.utils.UiUtils;\n+import jadx.gui.utils.pkgs.JRenamePackage;\n import jadx.gui.utils.ui.DocumentUpdateListener;\n import jadx.gui.utils.ui.NodeLabel;\n \n@@ -250,6 +252,9 @@ private void initUI() {\n \t\tnodeLabel.setIcon(node.getIcon());\n \t\tif (node instanceof JNode) {\n \t\t\tnodeLabel.disableHtml(((JNode) node).disableHtml());\n+\t\t} else if (node instanceof JRenamePackage) {\n+\t\t\t// TODO: get from JRenameNode directly\n+\t\t\tnodeLabel.disableHtml(!node.getTitle().equals(JPackage.PACKAGE_DEFAULT_HTML_STR));\n \t\t}\n \t\tlbl.setLabelFor(nodeLabel);",
    "output": "Fix allow html for empty package name"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -199,6 +199,7 @@ private void loadPlugins() {\n \t}\n \n \tprivate void loadFinished() {\n+\t\tLOG.debug(\"Load finished\");\n \t\tList<JadxPass> list = customPasses.get(JadxAfterLoadPass.TYPE);\n \t\tif (list != null) {\n \t\t\tfor (JadxPass pass : list) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n@@ -2,6 +2,7 @@\n \n import java.util.ArrayList;\n import java.util.HashSet;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n@@ -281,7 +282,7 @@ public Set<String> getEndTypes() {\n \n \t@Nullable\n \tprivate SuperTypesData collectSuperTypes(ClassNode cls) {\n-\t\tList<ArgType> superTypes = new ArrayList<>();\n+\t\tSet<ArgType> superTypes = new LinkedHashSet<>();\n \t\tSet<String> endTypes = new HashSet<>();\n \t\tcollectSuperTypes(cls, superTypes, endTypes);\n \t\tif (superTypes.isEmpty()) {\n@@ -290,10 +291,10 @@ private SuperTypesData collectSuperTypes(ClassNode cls) {\n \t\tif (endTypes.isEmpty()) {\n \t\t\tthrow new JadxRuntimeException(\"No end types in class hierarchy: \" + cls);\n \t\t}\n-\t\treturn new SuperTypesData(superTypes, endTypes);\n+\t\treturn new SuperTypesData(new ArrayList<>(superTypes), endTypes);\n \t}\n \n-\tprivate void collectSuperTypes(ClassNode cls, List<ArgType> superTypes, Set<String> endTypes) {\n+\tprivate void collectSuperTypes(ClassNode cls, Set<ArgType> superTypes, Set<String> endTypes) {\n \t\tRootNode root = cls.root();\n \t\tint k = 0;\n \t\tArgType superClass = cls.getSuperClass();\n@@ -308,21 +309,24 @@ private void collectSuperTypes(ClassNode cls, List<ArgType> superTypes, Set<Stri\n \t\t}\n \t}\n \n-\tprivate int addSuperType(RootNode root, List<ArgType> superTypesMap, Set<String> endTypes, ArgType superType) {\n+\tprivate int addSuperType(RootNode root, Set<ArgType> superTypes, Set<String> endTypes, ArgType superType) {\n \t\tif (Objects.equals(superType, ArgType.OBJECT)) {\n \t\t\treturn 0;\n \t\t}\n-\t\tsuperTypesMap.add(superType);\n+\t\tif (!superTypes.add(superType)) {\n+\t\t\t// found 'super' loop, stop processing\n+\t\t\treturn 0;\n+\t\t}\n \t\tClassNode classNode = root.resolveClass(superType);\n \t\tif (classNode != null) {\n-\t\t\tcollectSuperTypes(classNode, superTypesMap, endTypes);\n+\t\t\tcollectSuperTypes(classNode, superTypes, endTypes);\n \t\t\treturn 1;\n \t\t}\n \t\tClspClass clsDetails = root.getClsp().getClsDetails(superType);\n \t\tif (clsDetails != null) {\n \t\t\tint k = 0;\n \t\t\tfor (ArgType parentType : clsDetails.getParents()) {\n-\t\t\t\tk += addSuperType(root, superTypesMap, endTypes, parentType);\n+\t\t\t\tk += addSuperType(root, superTypes, endTypes, parentType);\n \t\t\t}\n \t\t\tif (k == 0) {\n \t\t\t\tendTypes.add(superType.getObject());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ShadowFieldVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ShadowFieldVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ShadowFieldVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ShadowFieldVisitor.java\n@@ -3,8 +3,10 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n \n import org.jetbrains.annotations.Nullable;\n \n@@ -107,8 +109,14 @@ private static Map<String, List<FieldNode>> groupByName(List<FieldNode> allField\n \n \tprivate static List<FieldNode> collectAllInstanceFields(ClassNode cls) {\n \t\tList<FieldNode> fieldsList = new ArrayList<>();\n+\t\tSet<ClassNode> visited = new HashSet<>();\n \t\tClassNode currentClass = cls;\n \t\twhile (currentClass != null) {\n+\t\t\tif (!visited.add(currentClass)) {\n+\t\t\t\tString msg = \"Found 'super' loop in classes: \" + visited;\n+\t\t\t\tvisited.forEach(c -> c.addWarnComment(msg));\n+\t\t\t\treturn fieldsList;\n+\t\t\t}\n \t\t\tfor (FieldNode field : currentClass.getFields()) {\n \t\t\t\tif (!field.getAccessFlags().isStatic()) {\n \t\t\t\t\tfieldsList.add(field);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestSuperLoop.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestSuperLoop.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestSuperLoop.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestSuperLoop.java\n@@ -0,0 +1,40 @@\n+package jadx.tests.integration.others;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+@SuppressWarnings(\"CommentedOutCode\")\n+public class TestSuperLoop extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tpublic class A extends B {\n+\t\t\tpublic int a;\n+\t\t}\n+\n+\t\tpublic class B extends A {\n+\t\t\tpublic int b;\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tallowWarnInCode();\n+\t\tdisableCompilation();\n+\n+\t\tList<ClassNode> clsList = loadFromSmaliFiles();\n+\t\tassertThat(searchCls(clsList, \"A\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"public class A extends B {\");\n+\n+\t\tassertThat(searchCls(clsList, \"B\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"public class B extends A {\");\n+\t}\n+}",
    "output": "Fix handle classes 'super' loop"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkManager.java b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkManager.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkManager.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkManager.java\n@@ -14,8 +14,11 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import ch.qos.logback.classic.Level;\n+\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.jobs.BackgroundExecutor;\n+import jadx.gui.logs.LogOptions;\n import jadx.gui.treemodel.JRoot;\n import jadx.gui.ui.MainWindow;\n import jadx.gui.utils.SystemInfo;\n@@ -200,10 +203,13 @@ private Path getVenvPath(String cmd) {\n \t}\n \n \tprivate void runCommand(List<String> cmd) throws Exception {\n-\t\tLOG.debug(\"Running command: {}\", String.join(\" \", cmd));\n-\t\tProcess process = Runtime.getRuntime().exec(cmd.toArray(new String[0]));\n+\t\tUiUtils.uiRun(() -> mainWindow.showLogViewer(LogOptions.forLevel(Level.INFO)));\n+\t\tLOG.info(\"Running command: {}\", String.join(\" \", cmd));\n+\t\tProcessBuilder builder = new ProcessBuilder(cmd);\n+\t\tbuilder.redirectErrorStream(true);\n+\t\tProcess process = builder.start();\n \t\ttry (BufferedReader buf = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n-\t\t\tbuf.lines().forEach(msg -> LOG.debug(\"# {}\", msg));\n+\t\t\tbuf.lines().forEach(msg -> LOG.info(\"# {}\", msg));\n \t\t} finally {\n \t\t\tprocess.waitFor();\n \t\t}",
    "output": "Fix display Quark stderr output in Jadx log"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n@@ -10,6 +10,7 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n \n import javax.swing.JTabbedPane;\n import javax.swing.SwingUtilities;\n@@ -18,6 +19,10 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.api.JavaClass;\n+import jadx.api.metadata.ICodeAnnotation;\n+import jadx.api.metadata.ICodeNodeRef;\n+import jadx.api.metadata.annotations.NodeDeclareRef;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.treemodel.JClass;\n import jadx.gui.treemodel.JNode;\n@@ -199,6 +204,34 @@ public MainWindow getMainWindow() {\n \t * Jump to node definition\n \t */\n \tpublic void codeJump(JNode node) {\n+\t\tJClass parentCls = node.getJParent();\n+\t\tif (parentCls != null) {\n+\t\t\tJavaClass cls = node.getJParent().getCls();\n+\t\t\tJavaClass origTopCls = cls.getOriginalTopParentClass();\n+\t\t\tJavaClass codeParent = cls.getTopParentClass();\n+\t\t\tif (!Objects.equals(codeParent, origTopCls)) {\n+\t\t\t\tJClass jumpCls = mainWindow.getCacheObject().getNodeCache().makeFrom(codeParent);\n+\t\t\t\tmainWindow.getBackgroundExecutor().execute(\n+\t\t\t\t\t\tNLS.str(\"progress.load\"),\n+\t\t\t\t\t\tjumpCls::loadNode, // load code in background\n+\t\t\t\t\t\tstatus -> {\n+\t\t\t\t\t\t\t// search original node in jump class\n+\t\t\t\t\t\t\tcodeParent.getCodeInfo().getCodeMetadata().searchDown(0, (pos, ann) -> {\n+\t\t\t\t\t\t\t\tif (ann.getAnnType() == ICodeAnnotation.AnnType.DECLARATION) {\n+\t\t\t\t\t\t\t\t\tICodeNodeRef declNode = ((NodeDeclareRef) ann).getNode();\n+\t\t\t\t\t\t\t\t\tif (declNode.equals(node.getJavaNode().getCodeNodeRef())) {\n+\t\t\t\t\t\t\t\t\t\tcodeJump(new JumpPosition(jumpCls, pos));\n+\t\t\t\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t});\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Not an inline node, jump normally\n \t\tif (node.getPos() != 0 || node.getRootClass() == null) {\n \t\t\tcodeJump(new JumpPosition(node));\n \t\t\treturn;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n@@ -17,7 +17,6 @@\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.List;\n-import java.util.Objects;\n \n import javax.swing.AbstractAction;\n import javax.swing.BorderFactory;\n@@ -47,11 +46,7 @@\n \n import ch.qos.logback.classic.Level;\n \n-import jadx.api.JavaClass;\n-import jadx.api.metadata.ICodeAnnotation;\n-import jadx.api.metadata.annotations.NodeDeclareRef;\n import jadx.gui.logs.LogOptions;\n-import jadx.gui.treemodel.JClass;\n import jadx.gui.treemodel.JNode;\n import jadx.gui.treemodel.JResSearchNode;\n import jadx.gui.ui.MainWindow;\n@@ -151,45 +146,13 @@ protected void openItem(JNode node) {\n \t\t\tJumpPosition jmpPos = new JumpPosition(((JResSearchNode) node).getResNode(), node.getPos());\n \t\t\ttabbedPane.codeJump(jmpPos);\n \t\t} else {\n-\t\t\tif (!checkForRedirects(node)) {\n-\t\t\t\ttabbedPane.codeJump(node);\n-\t\t\t}\n+\t\t\ttabbedPane.codeJump(node);\n \t\t}\n \t\tif (!mainWindow.getSettings().getKeepCommonDialogOpen()) {\n \t\t\tdispose();\n \t\t}\n \t}\n \n-\t// TODO: temp solution, move implementation into corresponding nodes\n-\tprivate boolean checkForRedirects(JNode node) {\n-\t\tif (node instanceof JClass) {\n-\t\t\tJavaClass cls = ((JClass) node).getCls();\n-\t\t\tJavaClass origTopCls = cls.getOriginalTopParentClass();\n-\t\t\tJavaClass codeParent = cls.getTopParentClass();\n-\t\t\tif (Objects.equals(codeParent, origTopCls)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tJClass jumpCls = mainWindow.getCacheObject().getNodeCache().makeFrom(codeParent);\n-\t\t\tmainWindow.getBackgroundExecutor().execute(\n-\t\t\t\t\tNLS.str(\"progress.load\"),\n-\t\t\t\t\tjumpCls::loadNode, // load code in background\n-\t\t\t\t\tstatus -> {\n-\t\t\t\t\t\t// search original node in jump class\n-\t\t\t\t\t\tcodeParent.getCodeInfo().getCodeMetadata().searchDown(0, (pos, ann) -> {\n-\t\t\t\t\t\t\tif (ann.getAnnType() == ICodeAnnotation.AnnType.DECLARATION) {\n-\t\t\t\t\t\t\t\tif (((NodeDeclareRef) ann).getNode().equals(cls.getClassNode())) {\n-\t\t\t\t\t\t\t\t\ttabbedPane.codeJump(new JumpPosition(jumpCls, pos));\n-\t\t\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\treturn null;\n-\t\t\t\t\t\t});\n-\t\t\t\t\t});\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n \t@Nullable\n \tprivate JNode getSelectedNode() {\n \t\ttry {",
    "output": "Fix support inline node for jump to code"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n@@ -250,6 +250,11 @@ private void addSimpleValue(ICodeWriter cw, String typeName, String itemTag, Str\n \t\t\t\tcw.add(' ').add(attrName).add(\"=\\\"\").add(attrValue).add('\"');\n \t\t\t}\n \t\t}\n+\n+\t\tif (itemTag.equals(\"string\") && valueStr.contains(\"%\") && StringFormattedCheck.hasMultipleNonPositionalSubstitutions(valueStr)) {\n+\t\t\tcw.add(\" formatted=\\\"false\\\"\");\n+\t\t}\n+\n \t\tif (valueStr.equals(\"\")) {\n \t\t\tcw.add(\" />\");\n \t\t} else {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/StringFormattedCheck.java b/jadx-core/src/main/java/jadx/core/xmlgen/StringFormattedCheck.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/StringFormattedCheck.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/StringFormattedCheck.java\n@@ -0,0 +1,104 @@\n+package jadx.core.xmlgen;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/*\n+ * This class contains source code form https://github.com/iBotPeaches/Apktool/\n+ * see:\n+ * https://github.com/iBotPeaches/Apktool/blob/master/brut.apktool/apktool-lib/src/main/java/brut/\n+ * androlib/res/xml/ResXmlEncoders.java\n+ */\n+public class StringFormattedCheck {\n+\n+\tpublic static boolean hasMultipleNonPositionalSubstitutions(String str) {\n+\t\tDuo<List<Integer>, List<Integer>> tuple = findSubstitutions(str, 4);\n+\t\treturn !tuple.m1.isEmpty() && tuple.m1.size() + tuple.m2.size() > 1;\n+\t}\n+\n+\t@SuppressWarnings(\"checkstyle:ClassTypeParameterName\")\n+\tprivate static class Duo<T1, T2> {\n+\t\tpublic final T1 m1;\n+\t\tpublic final T2 m2;\n+\n+\t\tpublic Duo(T1 t1, T2 t2) {\n+\t\t\tthis.m1 = t1;\n+\t\t\tthis.m2 = t2;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (obj == null) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (getClass() != obj.getClass()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\t@SuppressWarnings(\"unchecked\")\n+\t\t\tfinal Duo<T1, T2> other = (Duo<T1, T2>) obj;\n+\t\t\tif (!Objects.equals(this.m1, other.m1)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\treturn Objects.equals(this.m2, other.m2);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tint hash = 3;\n+\t\t\thash = 71 * hash + (this.m1 != null ? this.m1.hashCode() : 0);\n+\t\t\thash = 71 * hash + (this.m2 != null ? this.m2.hashCode() : 0);\n+\t\t\treturn hash;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * It returns a tuple of:\n+\t * - a list of offsets of non positional substitutions. non-pos is defined as any \"%\" which isn't\n+\t * \"%%\" nor \"%\\d+\\$\"\n+\t * - a list of offsets of positional substitutions\n+\t */\n+\t@SuppressWarnings({ \"checkstyle:NeedBraces\", \"checkstyle:EmptyStatement\" })\n+\tprivate static Duo<List<Integer>, List<Integer>> findSubstitutions(String str, int nonPosMax) {\n+\t\tif (nonPosMax == -1) {\n+\t\t\tnonPosMax = Integer.MAX_VALUE;\n+\t\t}\n+\t\tint pos;\n+\t\tint pos2 = 0;\n+\t\tList<Integer> nonPositional = new ArrayList<>();\n+\t\tList<Integer> positional = new ArrayList<>();\n+\n+\t\tif (str == null) {\n+\t\t\treturn new Duo<>(nonPositional, positional);\n+\t\t}\n+\n+\t\tint length = str.length();\n+\n+\t\twhile ((pos = str.indexOf('%', pos2)) != -1) {\n+\t\t\tpos2 = pos + 1;\n+\t\t\tif (pos2 == length) {\n+\t\t\t\tnonPositional.add(pos);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tchar c = str.charAt(pos2++);\n+\t\t\tif (c == '%') {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (c >= '0' && c <= '9' && pos2 < length) {\n+\t\t\t\twhile ((c = str.charAt(pos2++)) >= '0' && c <= '9' && pos2 < length)\n+\t\t\t\t\t;\n+\t\t\t\tif (c == '$') {\n+\t\t\t\t\tpositional.add(pos);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tnonPositional.add(pos);\n+\t\t\tif (nonPositional.size() >= nonPosMax) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new Duo<>(nonPositional, positional);\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java b/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n--- a/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n+++ b/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n@@ -149,6 +149,28 @@ void testString() {\n \t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n \t}\n \n+\t@Test\n+\tvoid testStringFormattedFalse() {\n+\t\tResourceStorage resStorage = new ResourceStorage();\n+\t\tResourceEntry re = new ResourceEntry(2130903103, \"jadx.gui.app\", \"string\", \"app_name\", \"\");\n+\t\tre.setSimpleValue(new RawValue(3, 0));\n+\t\tre.setNamedValues(Lists.list());\n+\t\tresStorage.add(re);\n+\n+\t\tBinaryXMLStrings strings = new BinaryXMLStrings();\n+\t\tstrings.put(0, \"%s at %s\");\n+\t\tValuesParser vp = new ValuesParser(strings, resStorage.getResourcesNames());\n+\t\tResXmlGen resXmlGen = new ResXmlGen(resStorage, vp);\n+\t\tList<ResContainer> files = resXmlGen.makeResourcesXml();\n+\n+\t\tassertEquals(1, files.size());\n+\t\tassertEquals(\"res/values/strings.xml\", files.get(0).getFileName());\n+\t\tassertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n+\t\t\t\t+ \"<resources>\\n\"\n+\t\t\t\t+ \"    <string name=\\\"app_name\\\" formatted=\\\"false\\\">%s at %s</string>\\n\"\n+\t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n+\t}\n+\n \t@Test\n \tvoid testArrayEscape() {\n \t\tResourceStorage resStorage = new ResourceStorage();",
    "output": "Fix support formatted=false for strings"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -811,7 +811,13 @@ protected void getDisassembledCode(StringBuilder sb) {\n \t\t}\n \t\tsb.append(String.format(\"###### Class %s (%s)\", getFullName(), getRawName()));\n \t\tsb.append(ICodeWriter.NL);\n-\t\tsb.append(clsData.getDisassembledCode());\n+\t\ttry {\n+\t\t\tsb.append(clsData.getDisassembledCode());\n+\t\t} catch (Throwable e) {\n+\t\t\tsb.append(\"Failed to disassemble class:\");\n+\t\t\tsb.append(ICodeWriter.NL);\n+\t\t\tsb.append(Utils.getStackTrace(e));\n+\t\t}\n \t}\n \n \tpublic IClassData getClsData() {",
    "output": "Fix update raung to fix stack frame issue"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/info/ClassAliasInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/ClassAliasInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/ClassAliasInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassAliasInfo.java\n@@ -2,6 +2,8 @@\n \n import org.jetbrains.annotations.Nullable;\n \n+import jadx.core.utils.StringUtils;\n+\n class ClassAliasInfo {\n \tprivate final String shortName;\n \t@Nullable\n@@ -10,6 +12,9 @@ class ClassAliasInfo {\n \tprivate String fullName;\n \n \tClassAliasInfo(@Nullable String pkg, String shortName) {\n+\t\tif (StringUtils.isEmpty(shortName)) {\n+\t\t\tthrow new IllegalArgumentException(\"Class alias can't be empty\");\n+\t\t}\n \t\tthis.pkg = pkg;\n \t\tthis.shortName = shortName;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n@@ -25,6 +25,7 @@\n import jadx.core.dex.nodes.PackageNode;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.visitors.AbstractVisitor;\n+import jadx.core.utils.StringUtils;\n \n public class RenameVisitor extends AbstractVisitor {\n \tprivate static final Pattern ANONYMOUS_CLASS_PATTERN = Pattern.compile(\"^\\\\d+$\");\n@@ -125,6 +126,9 @@ private static boolean checkPackage(JadxArgs args, IAliasProvider aliasProvider,\n \n \t@Nullable\n \tprivate static String fixClsShortName(JadxArgs args, String clsName) {\n+\t\tif (StringUtils.isEmpty(clsName)) {\n+\t\t\treturn null;\n+\t\t}\n \t\tboolean renameValid = args.isRenameValid();\n \t\tif (renameValid) {\n \t\t\tif (ANONYMOUS_CLASS_PATTERN.matcher(clsName).matches()) {",
    "output": "Fix additional checks for class alias string"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n@@ -209,9 +209,10 @@ public void updateAttributes(IResParser parser) {\n \t\t\tif (ri.getTypeName().equals(\"attr\") && ri.getNamedValues().size() > 1) {\n \t\t\t\tRawNamedValue first = ri.getNamedValues().get(0);\n \t\t\t\tMAttrType attrTyp;\n-\t\t\t\tif (first.getRawValue().getData() == ValuesParser.ATTR_TYPE_FLAGS) {\n+\t\t\t\tint attrTypeVal = first.getRawValue().getData() & 0xff0000;\n+\t\t\t\tif (attrTypeVal == ValuesParser.ATTR_TYPE_FLAGS) {\n \t\t\t\t\tattrTyp = MAttrType.FLAG;\n-\t\t\t\t} else if (first.getRawValue().getData() == ValuesParser.ATTR_TYPE_ENUM || first.getRawValue().getData() == 65600) {\n+\t\t\t\t} else if (attrTypeVal == ValuesParser.ATTR_TYPE_ENUM) {\n \t\t\t\t\tattrTyp = MAttrType.ENUM;\n \t\t\t\t} else {\n \t\t\t\t\tcontinue;",
    "output": "Fix resolve all custom attributes"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n@@ -65,7 +65,9 @@ public JadxProject(MainWindow mainWindow) {\n \n \tpublic void fillJadxArgs(JadxArgs jadxArgs) {\n \t\tjadxArgs.setInputFiles(FileUtils.toFiles(getFilePaths()));\n-\t\tjadxArgs.setUserRenamesMappingsPath(getMappingsPath());\n+\t\tif (jadxArgs.getUserRenamesMappingsPath() == null) {\n+\t\t\tjadxArgs.setUserRenamesMappingsPath(getMappingsPath());\n+\t\t}\n \t\tjadxArgs.setCodeData(getCodeData());\n \t\tjadxArgs.getPluginOptions().putAll(data.getPluginOptions());\n \t}",
    "output": "Fix don't override passed mappings path"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/ArgsInfo.java b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/ArgsInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/ArgsInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/ArgsInfo.java\n@@ -13,6 +13,7 @@\n import jadx.core.dex.instructions.mods.TernaryInsn;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.utils.EmptyBitSet;\n+import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n final class ArgsInfo {\n@@ -62,6 +63,27 @@ List<RegisterArg> getArgs() {\n \t\treturn args;\n \t}\n \n+\tpublic BitSet getArgsSet() {\n+\t\tif (args.isEmpty() && Utils.isEmpty(wrappedInsns)) {\n+\t\t\treturn EmptyBitSet.EMPTY;\n+\t\t}\n+\t\tBitSet set = new BitSet();\n+\t\tfillArgsSet(set);\n+\t\treturn set;\n+\t}\n+\n+\tprivate void fillArgsSet(BitSet set) {\n+\t\tfor (RegisterArg arg : args) {\n+\t\t\tset.set(arg.getRegNum());\n+\t\t}\n+\t\tList<ArgsInfo> wrapList = wrappedInsns;\n+\t\tif (wrapList != null) {\n+\t\t\tfor (ArgsInfo wrappedInsn : wrapList) {\n+\t\t\t\twrappedInsn.fillArgsSet(set);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tpublic WrapInfo checkInline(int assignPos, RegisterArg arg) {\n \t\tif (assignPos >= inlineBorder || !canMove(assignPos, inlineBorder)) {\n \t\t\treturn null;\n@@ -80,18 +102,9 @@ private boolean canMove(int from, int to) {\n \t\tif (start > to) {\n \t\t\tthrow new JadxRuntimeException(\"Invalid inline insn positions: \" + start + \" - \" + to);\n \t\t}\n-\t\tBitSet movedSet;\n-\t\tList<RegisterArg> movedArgs = startInfo.getArgs();\n-\t\tif (movedArgs.isEmpty()) {\n-\t\t\tif (startInfo.insn.isConstInsn()) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\tmovedSet = EmptyBitSet.EMPTY;\n-\t\t} else {\n-\t\t\tmovedSet = new BitSet();\n-\t\t\tfor (RegisterArg arg : movedArgs) {\n-\t\t\t\tmovedSet.set(arg.getRegNum());\n-\t\t\t}\n+\t\tBitSet movedSet = startInfo.getArgsSet();\n+\t\tif (movedSet == EmptyBitSet.EMPTY && startInfo.insn.isConstInsn()) {\n+\t\t\treturn true;\n \t\t}\n \t\tboolean canReorder = startInfo.canReorder();\n \t\tfor (int i = start; i < to; i++) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/code/TestArrayAccessReorder.java b/jadx-core/src/test/java/jadx/tests/integration/code/TestArrayAccessReorder.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/code/TestArrayAccessReorder.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/code/TestArrayAccessReorder.java\n@@ -0,0 +1,40 @@\n+package jadx.tests.integration.code;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestArrayAccessReorder extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic int[] test(int[] arr) {\n+\t\t\tint len = arr.length;\n+\t\t\tint[] result = new int[len];\n+\t\t\tint i = 0;\n+\t\t\tint k = len;\n+\t\t\twhile (k != 0) {\n+\t\t\t\tint v = arr[i];\n+\t\t\t\tk--;\n+\t\t\t\tint t = -v;\n+\t\t\t\ti++;\n+\t\t\t\tresult[k] = t * 5;\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(test(new int[] { 1, 2, 3 })).isEqualTo(new int[] { -15, -10, -5 });\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tgetArgs().setRawCFGOutput(true);\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"i++\");\n+\t}\n+}",
    "output": "Fix check args of inlined insns on reorder"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Jadx.java b/jadx-core/src/main/java/jadx/core/Jadx.java\n--- a/jadx-core/src/main/java/jadx/core/Jadx.java\n+++ b/jadx-core/src/main/java/jadx/core/Jadx.java\n@@ -62,6 +62,7 @@\n import jadx.core.dex.visitors.regions.variables.ProcessVariables;\n import jadx.core.dex.visitors.rename.CodeRenameVisitor;\n import jadx.core.dex.visitors.rename.RenameVisitor;\n+import jadx.core.dex.visitors.rename.SourceFileRename;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n import jadx.core.dex.visitors.ssa.SSATransform;\n import jadx.core.dex.visitors.typeinference.FinishTypeInference;\n@@ -96,6 +97,7 @@ public static List<IDexTreeVisitor> getPreDecompilePassesList() {\n \n \t\t// rename and deobfuscation\n \t\tpasses.add(new DeobfuscatorVisitor());\n+\t\tpasses.add(new SourceFileRename());\n \t\tpasses.add(new RenameVisitor());\n \t\tpasses.add(new SaveDeobfMapping());\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n@@ -40,8 +40,6 @@ public void init(RootNode root) {\n \t}\n \n \tprivate void process(RootNode root) {\n-\t\tSourceFileRename.process(root);\n-\n \t\tUserRenames.apply(root);\n \t\tcheckNames(root);\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/SourceFileRename.java b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/SourceFileRename.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/SourceFileRename.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/SourceFileRename.java\n@@ -1,34 +1,79 @@\n package jadx.core.dex.visitors.rename;\n \n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n import org.jetbrains.annotations.Nullable;\n \n import jadx.api.plugins.input.data.attributes.JadxAttrType;\n import jadx.api.plugins.input.data.attributes.types.SourceFileAttr;\n import jadx.core.deobf.NameMapper;\n import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.attributes.nodes.RenameReasonAttr;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.RootNode;\n+import jadx.core.dex.visitors.AbstractVisitor;\n import jadx.core.utils.BetterName;\n import jadx.core.utils.StringUtils;\n+import jadx.core.utils.exceptions.JadxException;\n \n-public class SourceFileRename {\n+public class SourceFileRename extends AbstractVisitor {\n \n-\tpublic static void process(RootNode root) {\n-\t\tif (root.getArgs().isUseSourceNameAsClassAlias()) {\n-\t\t\tfor (ClassNode cls : root.getClasses()) {\n-\t\t\t\tif (cls.contains(AFlag.DONT_RENAME)) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tString alias = getAliasFromSourceFile(cls);\n-\t\t\t\tif (alias != null) {\n-\t\t\t\t\tcls.rename(alias);\n+\t@Override\n+\tpublic String getName() {\n+\t\treturn \"SourceFileRename\";\n+\t}\n+\n+\t@Override\n+\tpublic void init(RootNode root) throws JadxException {\n+\t\tif (!root.getArgs().isUseSourceNameAsClassAlias()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tList<ClassNode> classes = root.getClasses();\n+\t\tMap<String, Boolean> canUseAlias = new HashMap<>();\n+\t\tfor (ClassNode cls : classes) {\n+\t\t\tcanUseAlias.put(cls.getClassInfo().getShortName(), Boolean.FALSE);\n+\t\t}\n+\t\tList<ClsRename> renames = new ArrayList<>();\n+\t\tfor (ClassNode cls : classes) {\n+\t\t\tif (cls.contains(AFlag.DONT_RENAME)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tString alias = getAliasFromSourceFile(cls);\n+\t\t\tif (alias != null) {\n+\t\t\t\tBoolean prev = canUseAlias.get(alias);\n+\t\t\t\tif (prev == null) {\n+\t\t\t\t\tcanUseAlias.put(alias, Boolean.TRUE);\n+\t\t\t\t\trenames.add(new ClsRename(cls, alias));\n+\t\t\t\t} else if (prev == Boolean.TRUE) {\n+\t\t\t\t\tcanUseAlias.put(alias, Boolean.FALSE);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfor (ClsRename clsRename : renames) {\n+\t\t\tString alias = clsRename.getAlias();\n+\t\t\tif (canUseAlias.get(alias) == Boolean.TRUE) {\n+\t\t\t\tapplyRename(clsRename.getCls(), alias);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static void applyRename(ClassNode cls, String alias) {\n+\t\tif (cls.getClassInfo().hasAlias()) {\n+\t\t\t// ignore source name if current alias is \"better\"\n+\t\t\tString currentAlias = cls.getAlias();\n+\t\t\tString betterName = BetterName.compareAndGet(alias, currentAlias);\n+\t\t\tif (betterName.equals(currentAlias)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tcls.getClassInfo().changeShortName(alias);\n+\t\tcls.addAttr(new RenameReasonAttr(cls).append(\"use source file name\"));\n \t}\n \n-\t@Nullable\n-\tprivate static String getAliasFromSourceFile(ClassNode cls) {\n+\tprivate static @Nullable String getAliasFromSourceFile(ClassNode cls) {\n \t\tSourceFileAttr sourceFileAttr = cls.get(JadxAttrType.SOURCE_FILE);\n \t\tif (sourceFileAttr == null) {\n \t\t\treturn null;\n@@ -42,20 +87,32 @@ private static String getAliasFromSourceFile(ClassNode cls) {\n \t\tif (!NameMapper.isValidAndPrintable(name)) {\n \t\t\treturn null;\n \t\t}\n-\t\tClassNode otherCls = cls.root().resolveClass(cls.getPackage() + '.' + name);\n-\t\tif (otherCls != null) {\n+\t\tif (name.equals(cls.getName())) {\n \t\t\treturn null;\n \t\t}\n+\t\treturn name;\n+\t}\n \n-\t\tif (cls.getClassInfo().hasAlias()) {\n-\t\t\t// ignore source name if current alias is \"better\"\n-\t\t\tString currentAlias = cls.getAlias();\n-\t\t\tString betterName = BetterName.compareAndGet(name, currentAlias);\n-\t\t\tif (betterName.equals(currentAlias)) {\n-\t\t\t\treturn null;\n-\t\t\t}\n+\tprivate static final class ClsRename {\n+\t\tprivate final ClassNode cls;\n+\t\tprivate final String alias;\n+\n+\t\tprivate ClsRename(ClassNode cls, String alias) {\n+\t\t\tthis.cls = cls;\n+\t\t\tthis.alias = alias;\n+\t\t}\n+\n+\t\tpublic ClassNode getCls() {\n+\t\t\treturn cls;\n+\t\t}\n+\n+\t\tpublic String getAlias() {\n+\t\t\treturn alias;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"ClsRename{\" + cls + \" -> '\" + alias + \"'}\";\n \t\t}\n-\t\tcls.remove(JadxAttrType.SOURCE_FILE);\n-\t\treturn name;\n \t}\n }",
    "output": "Fix check source file name alias uniqueness before rename"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptCompleteProvider.java b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptCompleteProvider.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptCompleteProvider.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptCompleteProvider.java\n@@ -49,7 +49,7 @@ private static Map<String, Icon> buildIconsMap() {\n \t}\n \n \tprivate final AbstractCodeArea codeArea;\n-\tprivate ScriptServices scriptComplete;\n+\tprivate ScriptServices scriptServices;\n \n \tpublic ScriptCompleteProvider(AbstractCodeArea codeArea) {\n \t\tthis.codeArea = codeArea;\n@@ -60,8 +60,9 @@ private List<Completion> getCompletions() {\n \t\t\tString code = codeArea.getText();\n \t\t\tint caretPos = codeArea.getCaretPosition();\n \t\t\t// TODO: resolve error after reusing ScriptCompiler\n-\t\t\tscriptComplete = new ScriptServices(codeArea.getNode().getName());\n-\t\t\tScriptCompletionResult result = scriptComplete.complete(code, caretPos);\n+\t\t\tscriptServices = new ScriptServices();\n+\t\t\tString scriptName = codeArea.getNode().getName();\n+\t\t\tScriptCompletionResult result = scriptServices.complete(scriptName, code, caretPos);\n \t\t\tint replacePos = getReplacePos(caretPos, result);\n \t\t\tif (!result.getReports().isEmpty()) {\n \t\t\t\tLOG.debug(\"Script completion reports: {}\", result.getReports());\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java\n@@ -128,6 +128,9 @@ private JPanel buildScriptActionsPanel() {\n \n \tprivate void runScript() {\n \t\tscriptArea.save();\n+\t\tif (!checkScript()) {\n+\t\t\treturn;\n+\t\t}\n \t\tresetResultLabel();\n \n \t\tTabbedPane tabbedPane = getTabbedPane();\n@@ -152,17 +155,17 @@ private boolean checkScript() {\n \t\t\tString code = scriptArea.getText();\n \t\t\tString fileName = scriptArea.getNode().getName();\n \n-\t\t\tScriptServices scriptServices = new ScriptServices(fileName);\n-\t\t\tScriptAnalyzeResult result = scriptServices.analyze(code, scriptArea.getCaretPosition());\n+\t\t\tScriptServices scriptServices = new ScriptServices();\n+\t\t\tScriptAnalyzeResult result = scriptServices.analyze(fileName, code);\n+\t\t\tboolean success = result.getSuccess();\n \t\t\tList<ScriptDiagnostic> issues = result.getIssues();\n-\t\t\tboolean success = true;\n \t\t\tfor (ScriptDiagnostic issue : issues) {\n \t\t\t\tSeverity severity = issue.getSeverity();\n \t\t\t\tif (severity == Severity.ERROR || severity == Severity.FATAL) {\n \t\t\t\t\tscriptLog.error(\"{}\", issue.render(false, true, true, true));\n \t\t\t\t\tsuccess = false;\n-\t\t\t\t} else {\n-\t\t\t\t\tscriptLog.warn(\"Compiler issue: {}\", issue);\n+\t\t\t\t} else if (severity == Severity.WARNING) {\n+\t\t\t\t\tscriptLog.warn(\"Compile issue: {}\", issue);\n \t\t\t\t}\n \t\t\t}\n \t\t\tList<JadxLintError> lintErrs = Collections.emptyList();\n@@ -175,7 +178,7 @@ private boolean checkScript() {\n \t\t\terrorService.addLintErrors(lintErrs);\n \t\t\terrorService.apply();\n \t\t\tif (!success) {\n-\t\t\t\tresultLabel.setText(\"Compiler issues: \" + issues.size());\n+\t\t\t\tresultLabel.setText(\"Compile issues: \" + issues.size());\n \t\t\t\tshowScriptLog();\n \t\t\t} else if (!lintErrs.isEmpty()) {\n \t\t\t\tresultLabel.setText(\"Lint issues: \" + lintErrs.size());\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptErrorService.java b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptErrorService.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptErrorService.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptErrorService.java\n@@ -62,6 +62,9 @@ private void jumpCaretToFirstError() {\n \n \tpublic void addCompilerIssues(List<ScriptDiagnostic> issues) {\n \t\tfor (ScriptDiagnostic issue : issues) {\n+\t\t\tif (issue.getSeverity() == ScriptDiagnostic.Severity.DEBUG) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tDefaultParserNotice notice;\n \t\t\tSourceCode.Location loc = issue.getLocation();\n \t\t\tif (loc == null) {",
    "output": "Use compile instead analyze for scripts with deps"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java\n@@ -128,9 +128,6 @@ private JPanel buildScriptActionsPanel() {\n \n \tprivate void runScript() {\n \t\tscriptArea.save();\n-\t\tif (!checkScript()) {\n-\t\t\treturn;\n-\t\t}\n \t\tresetResultLabel();\n \n \t\tTabbedPane tabbedPane = getTabbedPane();",
    "output": "Fix temp workaround to disable script checks before run"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n@@ -108,6 +108,7 @@ private void addValue(ICodeWriter cw, ResourceEntry ri) {\n \t\t\tString valueStr = vp.decodeValue(ri.getSimpleValue());\n \t\t\taddSimpleValue(cw, ri.getTypeName(), ri.getTypeName(), \"name\", ri.getKeyName(), valueStr);\n \t\t} else {\n+\t\t\tboolean skipNamedValues = false;\n \t\t\tcw.startLine();\n \t\t\tcw.add('<').add(ri.getTypeName()).add(\" name=\\\"\");\n \t\t\tString itemTag = \"item\";\n@@ -123,6 +124,14 @@ private void addValue(ICodeWriter cw, ResourceEntry ri) {\n \t\t\t\tif (formatValue != null) {\n \t\t\t\t\tcw.add(\"\\\" format=\\\"\").add(formatValue);\n \t\t\t\t}\n+\t\t\t\tif (ri.getNamedValues().size() > 1) {\n+\t\t\t\t\tfor (RawNamedValue rv : ri.getNamedValues()) {\n+\t\t\t\t\t\tif (rv.getNameRef() == ParserConstants.ATTR_MIN) {\n+\t\t\t\t\t\t\tcw.add(\"\\\" min=\\\"\").add(String.valueOf(rv.getRawValue().getData()));\n+\t\t\t\t\t\t\tskipNamedValues = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\tcw.add(ri.getKeyName());\n \t\t\t}\n@@ -135,11 +144,13 @@ private void addValue(ICodeWriter cw, ResourceEntry ri) {\n \t\t\t}\n \t\t\tcw.add(\"\\\">\");\n \n-\t\t\tcw.incIndent();\n-\t\t\tfor (RawNamedValue value : ri.getNamedValues()) {\n-\t\t\t\taddItem(cw, itemTag, ri.getTypeName(), value);\n+\t\t\tif (!skipNamedValues) {\n+\t\t\t\tcw.incIndent();\n+\t\t\t\tfor (RawNamedValue value : ri.getNamedValues()) {\n+\t\t\t\t\taddItem(cw, itemTag, ri.getTypeName(), value);\n+\t\t\t\t}\n+\t\t\t\tcw.decIndent();\n \t\t\t}\n-\t\t\tcw.decIndent();\n \t\t\tcw.startLine().add(\"</\").add(ri.getTypeName()).add('>');\n \t\t}\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java b/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n--- a/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n+++ b/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n@@ -79,6 +79,27 @@ void testAttrFlag() {\n \t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n \t}\n \n+\t@Test\n+\tvoid testAttrMin() {\n+\t\tResourceStorage resStorage = new ResourceStorage();\n+\t\tResourceEntry re = new ResourceEntry(2130903103, \"jadx.gui.app\", \"attr\", \"size\", \"\");\n+\t\tre.setNamedValues(\n+\t\t\t\tLists.list(new RawNamedValue(16777216, new RawValue(16, 4)), new RawNamedValue(16777217, new RawValue(16, 1))));\n+\t\tresStorage.add(re);\n+\n+\t\tValuesParser vp = new ValuesParser(null, resStorage.getResourcesNames());\n+\t\tResXmlGen resXmlGen = new ResXmlGen(resStorage, vp);\n+\t\tList<ResContainer> files = resXmlGen.makeResourcesXml();\n+\n+\t\tassertEquals(1, files.size());\n+\t\tassertEquals(\"res/values/attrs.xml\", files.get(0).getFileName());\n+\t\tassertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n+\t\t\t\t+ \"<resources>\\n\"\n+\t\t\t\t+ \"    <attr name=\\\"size\\\" format=\\\"integer\\\" min=\\\"1\\\">\\n\"\n+\t\t\t\t+ \"    </attr>\\n\"\n+\t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n+\t}\n+\n \t@Test\n \tvoid testStyle() {\n \t\tResourceStorage resStorage = new ResourceStorage();",
    "output": "Fix support `min` attr for attrs"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/XmlGenUtils.java b/jadx-core/src/main/java/jadx/core/xmlgen/XmlGenUtils.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/XmlGenUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/XmlGenUtils.java\n@@ -28,7 +28,7 @@ public static byte[] readData(InputStream i) throws IOException {\n \t}\n \n \tpublic static ICodeInfo makeXmlDump(ICodeWriter writer, ResourceStorage resStorage) {\n-\t\twriter.startLine(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\");\n+\t\twriter.add(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\");\n \t\twriter.startLine(\"<resources>\");\n \t\twriter.incIndent();",
    "output": "Remove first empty line in public.xml"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/ArgsInfo.java b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/ArgsInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/ArgsInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/ArgsInfo.java\n@@ -4,6 +4,8 @@\n import java.util.BitSet;\n import java.util.List;\n \n+import org.jetbrains.annotations.Nullable;\n+\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.InsnWrapArg;\n@@ -20,6 +22,7 @@ final class ArgsInfo {\n \tprivate final int pos;\n \tprivate int inlineBorder;\n \tprivate ArgsInfo inlinedInsn;\n+\tprivate @Nullable List<ArgsInfo> wrappedInsns;\n \n \tpublic ArgsInfo(InsnNode insn, List<ArgsInfo> argsList, int pos) {\n \t\tthis.insn = insn;\n@@ -69,7 +72,6 @@ public WrapInfo checkInline(int assignPos, RegisterArg arg) {\n \n \tprivate boolean canMove(int from, int to) {\n \t\tArgsInfo startInfo = argsList.get(from);\n-\t\tList<RegisterArg> movedArgs = startInfo.getArgs();\n \t\tint start = from + 1;\n \t\tif (start == to) {\n \t\t\t// previous instruction or on edge of inline border\n@@ -79,6 +81,7 @@ private boolean canMove(int from, int to) {\n \t\t\tthrow new JadxRuntimeException(\"Invalid inline insn positions: \" + start + \" - \" + to);\n \t\t}\n \t\tBitSet movedSet;\n+\t\tList<RegisterArg> movedArgs = startInfo.getArgs();\n \t\tif (movedArgs.isEmpty()) {\n \t\t\tif (startInfo.insn.isConstInsn()) {\n \t\t\t\treturn true;\n@@ -90,7 +93,7 @@ private boolean canMove(int from, int to) {\n \t\t\t\tmovedSet.set(arg.getRegNum());\n \t\t\t}\n \t\t}\n-\t\tboolean canReorder = startInfo.insn.canReorder();\n+\t\tboolean canReorder = startInfo.canReorder();\n \t\tfor (int i = start; i < to; i++) {\n \t\t\tArgsInfo argsInfo = argsList.get(i);\n \t\t\tif (argsInfo.getInlinedInsn() == this) {\n@@ -110,6 +113,21 @@ private boolean canMove(int from, int to) {\n \t\treturn true;\n \t}\n \n+\tprivate boolean canReorder() {\n+\t\tif (!insn.canReorder()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tList<ArgsInfo> wrapList = wrappedInsns;\n+\t\tif (wrapList != null) {\n+\t\t\tfor (ArgsInfo wrapInsn : wrapList) {\n+\t\t\t\tif (!wrapInsn.canReorder()) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n \tstatic boolean usedArgAssign(InsnNode insn, BitSet args) {\n \t\tif (args.isEmpty()) {\n \t\t\treturn false;\n@@ -124,6 +142,10 @@ static boolean usedArgAssign(InsnNode insn, BitSet args) {\n \tWrapInfo inline(int assignInsnPos, RegisterArg arg) {\n \t\tArgsInfo argsInfo = argsList.get(assignInsnPos);\n \t\targsInfo.inlinedInsn = this;\n+\t\tif (wrappedInsns == null) {\n+\t\t\twrappedInsns = new ArrayList<>(args.size());\n+\t\t}\n+\t\twrappedInsns.add(argsInfo);\n \t\treturn new WrapInfo(argsInfo.insn, arg);\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldAccessReorder.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldAccessReorder.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldAccessReorder.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldAccessReorder.java\n@@ -0,0 +1,35 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class TestFieldAccessReorder extends IntegrationTest {\n+\tpublic static class TestCls {\n+\t\tprivate long field = 10;\n+\n+\t\tpublic final boolean test() {\n+\t\t\tlong value = longCall();\n+\t\t\tlong diff = value - this.field;\n+\t\t\tthis.field = value;\n+\t\t\treturn diff > 250;\n+\t\t}\n+\n+\t\tpublic static long longCall() {\n+\t\t\treturn 261L;\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertTrue(test());\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tgetClassNode(TestCls.class);\n+\t\t// auto check should pass\n+\t}\n+}",
    "output": "Fix additional insns reorder checks"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n@@ -65,7 +65,7 @@ public class RenameDialog extends JDialog {\n \tprivate transient JTextField renameField;\n \tprivate transient JButton renameBtn;\n \n-\tpublic static boolean rename(MainWindow mainWindow, JNode source, JRenameNode node) {\n+\tpublic static boolean rename(MainWindow mainWindow, @Nullable JNode source, JRenameNode node) {\n \t\tRenameDialog renameDialog = new RenameDialog(mainWindow, source, node);\n \t\tUiUtils.uiRun(() -> renameDialog.setVisible(true));\n \t\tUiUtils.uiRun(renameDialog::initRenameField); // wait for UI events to propagate\n@@ -75,12 +75,13 @@ public static boolean rename(MainWindow mainWindow, JNode source, JRenameNode no\n \tpublic static JPopupMenu buildRenamePopup(MainWindow mainWindow, JRenameNode node) {\n \t\tJMenuItem jmi = new JMenuItem(NLS.str(\"popup.rename\"));\n \t\tjmi.addActionListener(action -> RenameDialog.rename(mainWindow, null, node));\n+\t\tjmi.setEnabled(node.canRename());\n \t\tJPopupMenu menu = new JPopupMenu();\n \t\tmenu.add(jmi);\n \t\treturn menu;\n \t}\n \n-\tprivate RenameDialog(MainWindow mainWindow, JNode source, JRenameNode node) {\n+\tprivate RenameDialog(MainWindow mainWindow, @Nullable JNode source, JRenameNode node) {\n \t\tsuper(mainWindow);\n \t\tthis.mainWindow = mainWindow;\n \t\tthis.cache = mainWindow.getCacheObject();",
    "output": "Fix disable rename action in tree popup if not allowed"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n@@ -9,6 +9,7 @@\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.RootNode;\n+import jadx.core.utils.StringUtils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public final class ClassInfo implements Comparable<ClassInfo> {\n@@ -59,13 +60,21 @@ private static ArgType checkClassType(ArgType type) {\n \t}\n \n \tpublic void changeShortName(String aliasName) {\n-\t\tif (!Objects.equals(name, aliasName)) {\n-\t\t\tClassAliasInfo newAlias = new ClassAliasInfo(getAliasPkg(), aliasName);\n-\t\t\tfillAliasFullName(newAlias);\n-\t\t\tthis.alias = newAlias;\n+\t\tClassAliasInfo newAlias;\n+\t\tString aliasPkg = getAliasPkg();\n+\t\tif (Objects.equals(name, aliasName) || StringUtils.isEmpty(aliasName)) {\n+\t\t\tif (Objects.equals(getPackage(), aliasPkg)) {\n+\t\t\t\tnewAlias = null;\n+\t\t\t} else {\n+\t\t\t\tnewAlias = new ClassAliasInfo(aliasPkg, name);\n+\t\t\t}\n \t\t} else {\n-\t\t\tthis.alias = null;\n+\t\t\tnewAlias = new ClassAliasInfo(aliasPkg, aliasName);\n \t\t}\n+\t\tif (newAlias != null) {\n+\t\t\tfillAliasFullName(newAlias);\n+\t\t}\n+\t\tthis.alias = newAlias;\n \t}\n \n \tpublic void changePkg(String aliasPkg) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n@@ -220,7 +220,8 @@ public ICodeRename buildCodeRename(String newName, Set<ICodeRename> renames) {\n \n \t@Override\n \tpublic void removeAlias() {\n-\t\tcls.removeAlias();\n+\t\t// reset only short name, package name should be reset explicitly using PackageNode\n+\t\tcls.getClassNode().rename(\"\");\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n@@ -125,8 +125,9 @@ private void rename() {\n \tprivate void processRename(String newName, Set<ICodeRename> renames) {\n \t\tICodeRename rename = node.buildCodeRename(newName, renames);\n \t\trenames.remove(rename);\n-\t\tnode.removeAlias();\n-\t\tif (!newName.isEmpty()) {\n+\t\tif (newName.isEmpty()) {\n+\t\t\tnode.removeAlias();\n+\t\t} else {\n \t\t\trenames.add(rename);\n \t\t}\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/pkgs/JRenamePackage.java b/jadx-gui/src/main/java/jadx/gui/utils/pkgs/JRenamePackage.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/pkgs/JRenamePackage.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/pkgs/JRenamePackage.java\n@@ -99,4 +99,9 @@ public void reload(MainWindow mainWindow) {\n \t\tmainWindow.rebuildPackagesTree();\n \t\tmainWindow.reloadTree();\n \t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn refPkg.toString();\n+\t}\n }",
    "output": "Fix don't reset package alias on class rename"
  },
  {
    "input": "diff --git a/jadx-plugins/jadx-rename-mappings/src/main/java/jadx/plugins/mappings/save/MappingExporter.java b/jadx-plugins/jadx-rename-mappings/src/main/java/jadx/plugins/mappings/save/MappingExporter.java\n--- a/jadx-plugins/jadx-rename-mappings/src/main/java/jadx/plugins/mappings/save/MappingExporter.java\n+++ b/jadx-plugins/jadx-rename-mappings/src/main/java/jadx/plugins/mappings/save/MappingExporter.java\n@@ -144,10 +144,12 @@ public void exportMappings(Path path, JadxCodeData codeData, MappingFormat mappi\n \n \t\t\tString srcNamespace = MappingUtil.NS_SOURCE_FALLBACK;\n \t\t\tString dstNamespace = MappingUtil.NS_TARGET_FALLBACK;\n+\n+\t\t\t// Copy mappings from potentially imported mappings file\n \t\t\tif (loadedMappingTree != null && loadedMappingTree.getDstNamespaces() != null) {\n-\t\t\t\tsrcNamespace = loadedMappingTree.getSrcNamespace();\n-\t\t\t\tdstNamespace = loadedMappingTree.getDstNamespaces().get(0);\n+\t\t\t\tloadedMappingTree.accept(mappingTree);\n \t\t\t}\n+\n \t\t\tmappingTree.visitHeader();\n \t\t\tmappingTree.visitNamespaces(srcNamespace, Collections.singletonList(dstNamespace));\n \t\t\tmappingTree.visitContent();\n@@ -243,10 +245,6 @@ public void exportMappings(Path path, JadxCodeData codeData, MappingFormat mappi\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\t// Copy mappings from potentially imported mappings file\n-\t\t\tif (loadedMappingTree != null && loadedMappingTree.getDstNamespaces() != null) {\n-\t\t\t\tloadedMappingTree.accept(mappingTree);\n-\t\t\t}\n \t\t\t// Write file\n \t\t\tMappingWriter writer = MappingWriter.create(path, mappingFormat);\n \t\t\tmappingTree.accept(writer);",
    "output": "Fix preserve renames on mapping export"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/impl/AnnotatedCodeWriter.java b/jadx-core/src/main/java/jadx/api/impl/AnnotatedCodeWriter.java\n--- a/jadx-core/src/main/java/jadx/api/impl/AnnotatedCodeWriter.java\n+++ b/jadx-core/src/main/java/jadx/api/impl/AnnotatedCodeWriter.java\n@@ -154,7 +154,6 @@ private void attachSourceLine(int decompiledLine, int sourceLine) {\n \n \t@Override\n \tpublic ICodeInfo finish() {\n-\t\tremoveFirstEmptyLine();\n \t\tprocessDefinitionAnnotations();\n \t\tvalidateAnnotations();\n \t\tString code = buf.toString();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -100,10 +100,12 @@ public ICodeInfo makeClass() throws CodegenException {\n \t\taddClassCode(clsBody);\n \n \t\tICodeWriter clsCode = cls.root().makeCodeWriter();\n-\t\tif (!\"\".equals(cls.getPackage())) {\n+\t\tif (cls.getPackage().isEmpty()) {\n+\t\t\tclsCode.add(\"// default package\");\n+\t\t} else {\n \t\t\tclsCode.add(\"package \").add(cls.getPackage()).add(';');\n-\t\t\tclsCode.newLine();\n \t\t}\n+\t\tclsCode.newLine();\n \t\tint importsCount = imports.size();\n \t\tif (importsCount != 0) {\n \t\t\tList<ClassInfo> sortedImports = new ArrayList<>(imports);",
    "output": "Fix don't change annotated code on finish"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n@@ -14,6 +14,7 @@\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.FieldReplaceAttr;\n import jadx.core.dex.attributes.nodes.MethodReplaceAttr;\n+import jadx.core.dex.attributes.nodes.RenameReasonAttr;\n import jadx.core.dex.attributes.nodes.SkipMethodArgsAttr;\n import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.info.ClassInfo;\n@@ -276,17 +277,18 @@ private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {\n \t\t\t}\n \t\t}\n \t\t// remove confirmed, change visibility and name if needed\n-\t\tif (!wrappedAccFlags.isPublic()) {\n+\t\tif (!wrappedAccFlags.isPublic() && !mth.root().getArgs().isRespectBytecodeAccModifiers()) {\n \t\t\t// must be public\n \t\t\tFixAccessModifiers.changeVisibility(wrappedMth, AccessFlags.PUBLIC);\n \t\t}\n \t\tString alias = mth.getAlias();\n \t\tif (!Objects.equals(wrappedMth.getAlias(), alias)) {\n-\t\t\twrappedMth.getMethodInfo().setAlias(alias);\n+\t\t\twrappedMth.rename(alias);\n+\t\t\tRenameReasonAttr.forNode(wrappedMth).append(\"merged with bridge method [inline-methods]\");\n \t\t}\n \t\twrappedMth.addAttr(new MethodReplaceAttr(mth));\n \t\twrappedMth.copyAttributeFrom(mth, AType.METHOD_OVERRIDE);\n-\t\twrappedMth.addDebugComment(\"Method merged with bridge method\");\n+\t\twrappedMth.addDebugComment(\"Method merged with bridge method: \" + mth.getMethodInfo().getShortId());\n \t\treturn true;\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -602,7 +602,7 @@ private SettingsGroup makeDecompilationGroup() {\n \t\tother.addRow(NLS.str(\"preferences.useImports\"), useImports);\n \t\tother.addRow(NLS.str(\"preferences.useDebugInfo\"), useDebugInfo);\n \t\tother.addRow(NLS.str(\"preferences.inlineAnonymous\"), inlineAnonymous);\n-\t\tother.addRow(NLS.str(\"preferences.inlineMethods\"), moveInnerClasses);\n+\t\tother.addRow(NLS.str(\"preferences.inlineMethods\"), inlineMethods);\n \t\tother.addRow(NLS.str(\"preferences.inlineKotlinLambdas\"), inlineKotlinLambdas);\n \t\tother.addRow(NLS.str(\"preferences.moveInnerClasses\"), moveInnerClasses);\n \t\tother.addRow(NLS.str(\"preferences.extractFinally\"), extractFinally);",
    "output": "Add rename reason for method merged with bridge"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n--- a/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n@@ -74,6 +74,8 @@ private static Object mergeValues(Class<?> type, Object value, Supplier<Object>\n \t}\n \n \tpublic void printUsage() {\n+\t\tLogHelper.setLogLevel(LogHelper.LogLevelEnum.ERROR); // mute logger while printing help\n+\n \t\t// print usage in not sorted fields order (by default sorted by description)\n \t\tPrintStream out = System.out;\n \t\tout.println();\n\ndiff --git a/jadx-cli/src/main/java/jadx/cli/LogHelper.java b/jadx-cli/src/main/java/jadx/cli/LogHelper.java\n--- a/jadx-cli/src/main/java/jadx/cli/LogHelper.java\n+++ b/jadx-cli/src/main/java/jadx/cli/LogHelper.java\n@@ -51,6 +51,11 @@ private static LogLevelEnum getLogLevelFromArgs(JadxCLIArgs args) {\n \t\treturn args.logLevel;\n \t}\n \n+\tpublic static void setLogLevel(LogLevelEnum newLogLevel) {\n+\t\tlogLevelValue = newLogLevel;\n+\t\tapplyLogLevel(logLevelValue);\n+\t}\n+\n \tpublic static void setLogLevelsForLoadingStage() {\n \t\tif (logLevelValue == null) {\n \t\t\treturn;",
    "output": "Use shadow jar in app bundle to reduce jars count"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -553,7 +553,7 @@ public static MethodGen getFallbackMethodGen(MethodNode mth) {\n \t}\n \n \tpublic static String getLabelName(BlockNode block) {\n-\t\treturn String.format(\"L%d\", block.getId());\n+\t\treturn String.format(\"L%d\", block.getCId());\n \t}\n \n \tpublic static String getLabelName(IfNode insn) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n@@ -329,6 +329,21 @@ private static boolean independentBlockTreeMod(MethodNode mth) {\n \t\treturn changed;\n \t}\n \n+\tprivate static boolean simplifyLoopEnd(MethodNode mth, LoopInfo loop) {\n+\t\tBlockNode loopEnd = loop.getEnd();\n+\t\tif (loopEnd.getSuccessors().size() > 1) {\n+\t\t\t// make loop end a simple path block\n+\t\t\tBlockNode newLoopEnd = BlockSplitter.startNewBlock(mth, -1);\n+\t\t\tnewLoopEnd.add(AFlag.SYNTHETIC);\n+\t\t\tnewLoopEnd.add(AFlag.LOOP_END);\n+\t\t\tBlockNode loopStart = loop.getStart();\n+\t\t\tBlockSplitter.replaceConnection(loopEnd, loopStart, newLoopEnd);\n+\t\t\tBlockSplitter.connect(newLoopEnd, loopStart);\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tprivate static boolean checkLoops(MethodNode mth, BlockNode block) {\n \t\tif (!block.contains(AFlag.LOOP_START)) {\n \t\t\treturn false;\n@@ -350,7 +365,8 @@ private static boolean checkLoops(MethodNode mth, BlockNode block) {\n \t\t\tLoopInfo loop = loops.get(0);\n \t\t\treturn insertBlocksForContinue(mth, loop)\n \t\t\t\t\t|| insertBlockForPredecessors(mth, loop)\n-\t\t\t\t\t|| insertPreHeader(mth, loop);\n+\t\t\t\t\t|| insertPreHeader(mth, loop)\n+\t\t\t\t\t|| simplifyLoopEnd(mth, loop);\n \t\t}\n \t\treturn false;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -44,6 +44,7 @@\n import jadx.core.dex.trycatch.ExceptionHandler;\n import jadx.core.dex.trycatch.TryCatchBlockAttr;\n import jadx.core.utils.BlockUtils;\n+import jadx.core.utils.ListUtils;\n import jadx.core.utils.RegionUtils;\n import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxOverflowException;\n@@ -217,6 +218,8 @@ private BlockNode processLoop(IRegion curRegion, LoopInfo loop, RegionStack stac\n \t\t\tcondInfo = IfInfo.invert(condInfo);\n \t\t}\n \t\tloopRegion.updateCondition(condInfo);\n+\t\t// prevent if's merge with loop condition\n+\t\tcondInfo.getMergedBlocks().forEach(b -> b.add(AFlag.ADDED_TO_REGION));\n \t\texitBlocks.removeAll(condInfo.getMergedBlocks());\n \n \t\tif (!exitBlocks.isEmpty()) {\n@@ -234,7 +237,8 @@ private BlockNode processLoop(IRegion curRegion, LoopInfo loop, RegionStack stac\n \t\tBlockNode out;\n \t\tif (loopRegion.isConditionAtEnd()) {\n \t\t\tBlockNode thenBlock = condInfo.getThenBlock();\n-\t\t\tout = thenBlock == loopStart ? condInfo.getElseBlock() : thenBlock;\n+\t\t\tout = (thenBlock == loop.getEnd() || thenBlock == loopStart) ? condInfo.getElseBlock() : thenBlock;\n+\t\t\tout = BlockUtils.followEmptyPath(out);\n \t\t\tloopStart.remove(AType.LOOP);\n \t\t\tloop.getEnd().add(AFlag.ADDED_TO_REGION);\n \t\t\tstack.addExit(loop.getEnd());\n@@ -246,6 +250,7 @@ private BlockNode processLoop(IRegion curRegion, LoopInfo loop, RegionStack stac\n \t\t} else {\n \t\t\tout = condInfo.getElseBlock();\n \t\t\tif (outerRegion != null\n+\t\t\t\t\t&& out != null\n \t\t\t\t\t&& out.contains(AFlag.LOOP_START)\n \t\t\t\t\t&& !out.getAll(AType.LOOP).contains(loop)\n \t\t\t\t\t&& RegionUtils.isRegionContainsBlock(outerRegion, out)) {\n@@ -298,9 +303,13 @@ private LoopRegion makeLoopRegion(IRegion curRegion, LoopInfo loop, List<BlockNo\n \t\t\t\t// skip nested loop condition\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tLoopRegion loopRegion = new LoopRegion(curRegion, loop, block, block == loop.getEnd());\n+\t\t\tBlockNode loopEnd = loop.getEnd();\n+\t\t\tboolean exitAtLoopEnd = block == loopEnd\n+\t\t\t\t\t|| (loopEnd.getInstructions().isEmpty() && ListUtils.isSingleElement(loopEnd.getPredecessors(), block));\n+\n+\t\t\tLoopRegion loopRegion = new LoopRegion(curRegion, loop, block, exitAtLoopEnd);\n \t\t\tboolean found;\n-\t\t\tif (block == loop.getStart() || block == loop.getEnd()\n+\t\t\tif (block == loop.getStart() || exitAtLoopEnd\n \t\t\t\t\t|| BlockUtils.isEmptySimplePath(loop.getStart(), block)) {\n \t\t\t\tfound = true;\n \t\t\t} else if (block.getPredecessors().contains(loop.getStart())) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak2.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak2.java\n@@ -20,7 +20,7 @@ public Object test() {\n \t\t\tdo {\n \t\t\t\tobj = this.it.next();\n \t\t\t\tif (obj == null) {\n-\t\t\t\t\treturn obj; // 'return null' works\n+\t\t\t\t\treturn obj; // 'return null' or 'break' also fine\n \t\t\t\t}\n \t\t\t} while (this.it.hasNext());\n \t\t\treturn obj;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestIterableForEach4.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestIterableForEach4.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestIterableForEach4.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestIterableForEach4.java\n@@ -0,0 +1,29 @@\n+package jadx.tests.integration.loops;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestIterableForEach4 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic void test(List<Object> objects) {\n+\t\t\tfor (Object o : objects) {\n+\t\t\t\tif (o.hashCode() != 42 || o.hashCode() != 1) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"while (\");\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition5.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition5.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition5.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition5.java\n@@ -38,7 +38,10 @@ public void test1() {\n \t\tClassNode cls = getClassNodeFromSmaliWithPath(\"loops\", \"TestLoopCondition5\");\n \t\tString code = cls.getCode().toString();\n \n-\t\tassertThat(code, anyOf(containsOne(\"for (\"), containsOne(\"while (true) {\")));\n+\t\tassertThat(code, anyOf(\n+\t\t\t\tcontainsOne(\"for (\"),\n+\t\t\t\tcontainsOne(\"while (true) {\"),\n+\t\t\t\tcontainsOne(\"} while (iArr[i3] != i);\")));\n \t\tassertThat(code, containsOne(\"return -1;\"));\n \t\tassertThat(code, countString(2, \"return \"));\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops5.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops5.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops5.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops5.java\n@@ -2,13 +2,9 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n-import jadx.core.dex.nodes.ClassNode;\n import jadx.tests.api.IntegrationTest;\n \n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.containsString;\n-import static org.hamcrest.Matchers.not;\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n public class TestNestedLoops5 extends IntegrationTest {\n@@ -36,11 +32,9 @@ public void check() {\n \t}\n \n \t@Test\n-\t@NotYetImplemented\n \tpublic void test() {\n-\t\tClassNode cls = getClassNode(TestCls.class);\n-\t\tString code = cls.getCode().toString();\n-\n-\t\tassertThat(code, not(containsString(\"continue;\")));\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"continue;\");\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestLoopInTryCatch.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestLoopInTryCatch.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestLoopInTryCatch.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestLoopInTryCatch.java\n@@ -40,6 +40,22 @@ public void test() {\n \t\t\t\t\t\t\t\t\"}\",\n \t\t\t\t\t\t\t\t\"if (i != 1) {\",\n \t\t\t\t\t\t\t\t\"    getI();\",\n+\t\t\t\t\t\t\t\t\"}\"),\n+\t\t\t\t\t\t// TODO: weird result but correct, better to not use do-while if not really needed\n+\t\t\t\t\t\tc -> c.containsLines(2,\n+\t\t\t\t\t\t\t\t\"int i;\",\n+\t\t\t\t\t\t\t\t\"do {\",\n+\t\t\t\t\t\t\t\t\"    try {\",\n+\t\t\t\t\t\t\t\t\"        i = getI();\",\n+\t\t\t\t\t\t\t\t\"        if (i == 1) {\",\n+\t\t\t\t\t\t\t\t\"            break;\",\n+\t\t\t\t\t\t\t\t\"        }\",\n+\t\t\t\t\t\t\t\t\"    } catch (RuntimeException unused) {\",\n+\t\t\t\t\t\t\t\t\"        return;\",\n+\t\t\t\t\t\t\t\t\"    }\",\n+\t\t\t\t\t\t\t\t\"} while (i != 2);\",\n+\t\t\t\t\t\t\t\t\"if (i != 1) {\",\n+\t\t\t\t\t\t\t\t\"    getI();\",\n \t\t\t\t\t\t\t\t\"}\"));\n \t}\n }",
    "output": "Fix split loop exit at loop end"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n@@ -8,6 +8,7 @@\n import java.util.Objects;\n \n import jadx.api.plugins.input.data.AccessFlags;\n+import jadx.api.plugins.input.data.attributes.JadxAttrType;\n import jadx.core.Consts;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n@@ -306,19 +307,24 @@ private static boolean registersAndCastsOnly(InsnArg arg) {\n \t * Remove public empty constructors (static or default)\n \t */\n \tprivate static void removeEmptyMethods(MethodNode mth) {\n+\t\tif (!mth.getArgRegs().isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n \t\tAccessInfo af = mth.getAccessFlags();\n-\t\tboolean publicConstructor = af.isConstructor() && af.isPublic();\n+\t\tboolean publicConstructor = mth.isConstructor() && af.isPublic();\n \t\tboolean clsInit = mth.getMethodInfo().isClassInit() && af.isStatic();\n-\t\tif ((publicConstructor || clsInit) && mth.getArgRegs().isEmpty()) {\n-\t\t\tList<BlockNode> bb = mth.getBasicBlocks();\n-\t\t\tif (bb == null || bb.isEmpty() || BlockUtils.isAllBlocksEmpty(bb)) {\n-\t\t\t\tif (clsInit) {\n+\t\tif (publicConstructor || clsInit) {\n+\t\t\tif (!BlockUtils.isAllBlocksEmpty(mth.getBasicBlocks())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (clsInit) {\n+\t\t\t\tmth.add(AFlag.DONT_GENERATE);\n+\t\t\t} else {\n+\t\t\t\t// don't remove default constructor if other constructors exists or constructor has annotations\n+\t\t\t\tif (mth.isDefaultConstructor()\n+\t\t\t\t\t\t&& !isNonDefaultConstructorExists(mth)\n+\t\t\t\t\t\t&& !mth.contains(JadxAttrType.ANNOTATION_LIST)) {\n \t\t\t\t\tmth.add(AFlag.DONT_GENERATE);\n-\t\t\t\t} else {\n-\t\t\t\t\t// don't remove default constructor if other constructors exists\n-\t\t\t\t\tif (mth.isDefaultConstructor() && !isNonDefaultConstructorExists(mth)) {\n-\t\t\t\t\t\tmth.add(AFlag.DONT_GENERATE);\n-\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -981,6 +981,9 @@ public static BlockNode skipSyntheticPredecessor(BlockNode block) {\n \t}\n \n \tpublic static boolean isAllBlocksEmpty(List<BlockNode> blocks) {\n+\t\tif (Utils.isEmpty(blocks)) {\n+\t\t\treturn true;\n+\t\t}\n \t\tfor (BlockNode block : blocks) {\n \t\t\tif (!block.getInstructions().isEmpty()) {\n \t\t\t\treturn false;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestDefConstructorWithAnnotation.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestDefConstructorWithAnnotation.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestDefConstructorWithAnnotation.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestDefConstructorWithAnnotation.java\n@@ -0,0 +1,33 @@\n+package jadx.tests.integration.others;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestDefConstructorWithAnnotation extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\t@AnnotationTest\n+\t\tpublic TestCls() {\n+\t\t}\n+\n+\t\t@Target(ElementType.CONSTRUCTOR)\n+\t\t@Retention(RetentionPolicy.RUNTIME)\n+\t\tpublic @interface AnnotationTest {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"@AnnotationTest\");\n+\t}\n+}",
    "output": "Fix check for annotations before remove empty default constructor"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -1449,6 +1449,11 @@ public Theme getEditorTheme() {\n \t}\n \n \tpublic void loadSettings() {\n+\t\t// queue update to not interrupt current UI tasks\n+\t\tUiUtils.uiRun(this::updateUiSettings);\n+\t}\n+\n+\tprivate void updateUiSettings() {\n \t\tLafManager.updateLaf(settings);\n \n \t\tFont font = settings.getFont();",
    "output": "Fix queue UI settings update"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/finaly/MarkFinallyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/finaly/MarkFinallyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/finaly/MarkFinallyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/finaly/MarkFinallyVisitor.java\n@@ -1,7 +1,9 @@\n package jadx.core.dex.visitors.finaly;\n \n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n@@ -32,6 +34,7 @@\n import jadx.core.utils.InsnList;\n import jadx.core.utils.ListUtils;\n import jadx.core.utils.Utils;\n+import jadx.core.utils.blocks.BlockPair;\n \n @JadxVisitor(\n \t\tname = \"MarkFinallyVisitor\",\n@@ -351,9 +354,14 @@ private static InsnsSlice searchFromFirstBlock(BlockNode dupBlock, BlockNode sta\n \t\tif (dupSlice == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tif (!dupSlice.isComplete()\n-\t\t\t\t&& !checkBlocksTree(dupBlock, startBlock, dupSlice, extractInfo)) {\n-\t\t\treturn null;\n+\t\tif (!dupSlice.isComplete()) {\n+\t\t\tMap<BlockPair, Boolean> checkCache = new HashMap<>();\n+\t\t\tif (checkBlocksTree(dupBlock, startBlock, dupSlice, extractInfo, checkCache)) {\n+\t\t\t\tdupSlice.setComplete(true);\n+\t\t\t\textractInfo.getFinallyInsnsSlice().setComplete(true);\n+\t\t\t} else {\n+\t\t\t\treturn null;\n+\t\t\t}\n \t\t}\n \t\treturn checkTempSlice(dupSlice);\n \t}\n@@ -470,30 +478,41 @@ private static boolean checkInsns(FinallyExtractInfo extractInfo, List<InsnNode>\n \t}\n \n \tprivate static boolean checkBlocksTree(BlockNode dupBlock, BlockNode finallyBlock,\n-\t\t\tInsnsSlice dupSlice, FinallyExtractInfo extractInfo) {\n+\t\t\tInsnsSlice dupSlice, FinallyExtractInfo extractInfo,\n+\t\t\tMap<BlockPair, Boolean> checksCache) {\n+\t\tBlockPair checkBlocks = new BlockPair(dupBlock, finallyBlock);\n+\t\tBoolean checked = checksCache.get(checkBlocks);\n+\t\tif (checked != null) {\n+\t\t\treturn checked;\n+\t\t}\n+\t\tboolean same;\n \t\tInsnsSlice finallySlice = extractInfo.getFinallyInsnsSlice();\n-\n \t\tList<BlockNode> finallyCS = getSuccessorsWithoutLoop(finallyBlock);\n \t\tList<BlockNode> dupCS = getSuccessorsWithoutLoop(dupBlock);\n \t\tif (finallyCS.size() == dupCS.size()) {\n+\t\t\tsame = true;\n \t\t\tfor (int i = 0; i < finallyCS.size(); i++) {\n \t\t\t\tBlockNode finSBlock = finallyCS.get(i);\n \t\t\t\tBlockNode dupSBlock = dupCS.get(i);\n \t\t\t\tif (extractInfo.getAllHandlerBlocks().contains(finSBlock)) {\n \t\t\t\t\tif (!compareBlocks(dupSBlock, finSBlock, dupSlice, extractInfo)) {\n-\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\tsame = false;\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n-\t\t\t\t\tif (!checkBlocksTree(dupSBlock, finSBlock, dupSlice, extractInfo)) {\n-\t\t\t\t\t\treturn false;\n+\t\t\t\t\tif (!checkBlocksTree(dupSBlock, finSBlock, dupSlice, extractInfo, checksCache)) {\n+\t\t\t\t\t\tsame = false;\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\tdupSlice.addBlock(dupSBlock);\n \t\t\t\t\tfinallySlice.addBlock(finSBlock);\n \t\t\t\t}\n \t\t\t}\n+\t\t} else {\n+\t\t\t// stop checks at start blocks (already compared)\n+\t\t\tsame = true;\n \t\t}\n-\t\tdupSlice.setComplete(true);\n-\t\tfinallySlice.setComplete(true);\n-\t\treturn true;\n+\t\tchecksCache.put(checkBlocks, same);\n+\t\treturn same;\n \t}\n \n \tprivate static List<BlockNode> getSuccessorsWithoutLoop(BlockNode block) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/blocks/BlockPair.java b/jadx-core/src/main/java/jadx/core/utils/blocks/BlockPair.java\n--- a/jadx-core/src/main/java/jadx/core/utils/blocks/BlockPair.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/blocks/BlockPair.java\n@@ -0,0 +1,43 @@\n+package jadx.core.utils.blocks;\n+\n+import jadx.core.dex.nodes.BlockNode;\n+\n+public class BlockPair {\n+\tprivate final BlockNode first;\n+\tprivate final BlockNode second;\n+\n+\tpublic BlockPair(BlockNode first, BlockNode second) {\n+\t\tthis.first = first;\n+\t\tthis.second = second;\n+\t}\n+\n+\tpublic BlockNode getFirst() {\n+\t\treturn first;\n+\t}\n+\n+\tpublic BlockNode getSecond() {\n+\t\treturn second;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (!(o instanceof BlockPair)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tBlockPair other = (BlockPair) o;\n+\t\treturn first.equals(other.first) && second.equals(other.second);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn first.hashCode() + 31 * second.hashCode();\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"(\" + first + \", \" + second + ')';\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/blocks/BlockSet.java b/jadx-core/src/main/java/jadx/core/utils/blocks/BlockSet.java\n--- a/jadx-core/src/main/java/jadx/core/utils/blocks/BlockSet.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/blocks/BlockSet.java\n@@ -0,0 +1,68 @@\n+package jadx.core.utils.blocks;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import jadx.core.dex.nodes.BlockNode;\n+import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.utils.EmptyBitSet;\n+\n+public class BlockSet {\n+\n+\tprivate final MethodNode mth;\n+\tprivate final BitSet bs;\n+\n+\tpublic BlockSet(MethodNode mth) {\n+\t\tthis.mth = mth;\n+\t\tthis.bs = new BitSet(mth.getBasicBlocks().size());\n+\t}\n+\n+\tpublic boolean get(BlockNode block) {\n+\t\treturn bs.get(block.getId());\n+\t}\n+\n+\tpublic void set(BlockNode block) {\n+\t\tbs.set(block.getId());\n+\t}\n+\n+\tpublic boolean checkAndSet(BlockNode block) {\n+\t\tint id = block.getId();\n+\t\tboolean state = bs.get(id);\n+\t\tbs.set(id);\n+\t\treturn state;\n+\t}\n+\n+\tpublic void forEach(Consumer<? super BlockNode> consumer) {\n+\t\tif (bs.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tList<BlockNode> blocks = mth.getBasicBlocks();\n+\t\tfor (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {\n+\t\t\tconsumer.accept(blocks.get(i));\n+\t\t}\n+\t}\n+\n+\tpublic List<BlockNode> toList() {\n+\t\tif (bs == null || bs == EmptyBitSet.EMPTY) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tint size = bs.cardinality();\n+\t\tif (size == 0) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tList<BlockNode> mthBlocks = mth.getBasicBlocks();\n+\t\tList<BlockNode> blocks = new ArrayList<>(size);\n+\t\tfor (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {\n+\t\t\tblocks.add(mthBlocks.get(i));\n+\t\t}\n+\t\treturn blocks;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn toList().toString();\n+\t}\n+}",
    "output": "Fix cache finally extract checks on multiple paths"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n@@ -243,7 +243,7 @@ private void addSimpleValue(ICodeWriter cw, String typeName, String itemTag, Str\n \t\t\tcw.add(\" />\");\n \t\t} else {\n \t\t\tcw.add('>');\n-\t\t\tif (itemTag.equals(\"string\")) {\n+\t\t\tif (itemTag.equals(\"string\") || (typeName.equals(\"array\") && valueStr.charAt(0) != '@')) {\n \t\t\t\tcw.add(StringUtils.escapeResStrValue(valueStr));\n \t\t\t} else {\n \t\t\t\tcw.add(StringUtils.escapeResValue(valueStr));\n\ndiff --git a/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java b/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n--- a/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n+++ b/jadx-core/src/test/java/jadx/core/xmlgen/ResXmlGenTest.java\n@@ -125,4 +125,26 @@ void testString() {\n \t\t\t\t+ \"    <string name=\\\"app_name\\\">Jadx Decompiler App</string>\\n\"\n \t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n \t}\n+\n+\t@Test\n+\tvoid testArrayEscape() {\n+\t\tResourceStorage resStorage = new ResourceStorage();\n+\t\tResourceEntry re = new ResourceEntry(2130903103, \"jadx.gui.app\", \"array\", \"single_quote_escape_sample\", \"\");\n+\t\tre.setNamedValues(\n+\t\t\t\tLists.list(new RawNamedValue(16777216, new RawValue(3, 0))));\n+\t\tresStorage.add(re);\n+\n+\t\tValuesParser vp = new ValuesParser(new String[] { \"Let's go\" }, resStorage.getResourcesNames());\n+\t\tResXmlGen resXmlGen = new ResXmlGen(resStorage, vp);\n+\t\tList<ResContainer> files = resXmlGen.makeResourcesXml();\n+\n+\t\tassertEquals(1, files.size());\n+\t\tassertEquals(\"res/values/arrays.xml\", files.get(0).getFileName());\n+\t\tassertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n+\t\t\t\t+ \"<resources>\\n\"\n+\t\t\t\t+ \"    <array name=\\\"single_quote_escape_sample\\\">\\n\"\n+\t\t\t\t+ \"        <item>Let\\\\'s go</item>\\n\"\n+\t\t\t\t+ \"    </array>\\n\"\n+\t\t\t\t+ \"</resources>\", files.get(0).getText().toString());\n+\t}\n }",
    "output": "Fix escaping for string arrays"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n@@ -141,31 +141,25 @@ public int adjustOffsetForToken(@Nullable Token token) {\n \t\tif (token == null) {\n \t\t\treturn -1;\n \t\t}\n-\t\tint type = token.getType();\n-\t\tfinal int sourceOffset;\n-\t\tif (node instanceof JClass) {\n-\t\t\tif (type == TokenTypes.IDENTIFIER) {\n-\t\t\t\tsourceOffset = token.getOffset();\n-\t\t\t} else if (type == TokenTypes.ANNOTATION && token.length() > 1) {\n-\t\t\t\tsourceOffset = token.getOffset() + 1;\n-\t\t\t} else {\n-\t\t\t\treturn -1;\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (type == TokenTypes.MARKUP_TAG_ATTRIBUTE_VALUE) {\n-\t\t\t\tsourceOffset = token.getOffset() + 1; // skip quote at start (\")\n-\t\t\t} else {\n-\t\t\t\treturn -1;\n-\t\t\t}\n-\t\t}\n \t\t// fast skip\n \t\tif (token.length() == 1) {\n \t\t\tchar ch = token.getTextArray()[token.getTextOffset()];\n \t\t\tif (ch == '.' || ch == ',' || ch == ';') {\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t}\n-\t\treturn sourceOffset;\n+\t\tint type = token.getType();\n+\t\tif (node instanceof JClass) {\n+\t\t\tif (type == TokenTypes.IDENTIFIER || type == TokenTypes.FUNCTION) {\n+\t\t\t\treturn token.getOffset();\n+\t\t\t}\n+\t\t\tif (type == TokenTypes.ANNOTATION && token.length() > 1) {\n+\t\t\t\treturn token.getOffset() + 1;\n+\t\t\t}\n+\t\t} else if (type == TokenTypes.MARKUP_TAG_ATTRIBUTE_VALUE) {\n+\t\t\treturn token.getOffset() + 1; // skip quote at start (\")\n+\t\t}\n+\t\treturn -1;\n \t}\n \n \t/**",
    "output": "Fix adjust node by offset search in code area"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java b/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n--- a/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n+++ b/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n@@ -3,39 +3,25 @@\n import java.io.File;\n import java.io.IOException;\n import java.io.StringReader;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n import java.util.regex.Pattern;\n \n import javax.xml.parsers.DocumentBuilder;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n import org.w3c.dom.NodeList;\n import org.xml.sax.InputSource;\n \n import jadx.api.ResourceFile;\n-import jadx.core.dex.attributes.AFlag;\n-import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.core.utils.files.FileUtils;\n import jadx.core.xmlgen.ResContainer;\n import jadx.core.xmlgen.XmlSecurity;\n \n public class ExportGradleProject {\n-\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(ExportGradleProject.class);\n-\n \tprivate static final Pattern ILLEGAL_GRADLE_CHARS = Pattern.compile(\"[/\\\\\\\\:>\\\"?*|]\");\n \n-\tprivate static final Set<String> IGNORE_CLS_NAMES = new HashSet<>(Arrays.asList(\n-\t\t\t\"R\",\n-\t\t\t\"BuildConfig\"));\n-\n \tprivate final RootNode root;\n \tprivate final File projectDir;\n \tprivate final File appDir;\n@@ -61,7 +47,6 @@ public void init() {\n \t\t\tsaveProjectBuildGradle();\n \t\t\tsaveApplicationBuildGradle();\n \t\t\tsaveSettingsGradle();\n-\t\t\tskipGeneratedClasses();\n \t\t} catch (Exception e) {\n \t\t\tthrow new JadxRuntimeException(\"Gradle export failed\", e);\n \t\t}\n@@ -95,16 +80,6 @@ private void saveApplicationBuildGradle() throws IOException {\n \t\ttmpl.save(new File(appDir, \"build.gradle\"));\n \t}\n \n-\tprivate void skipGeneratedClasses() {\n-\t\tfor (ClassNode cls : root.getClasses()) {\n-\t\t\tString shortName = cls.getClassInfo().getShortName();\n-\t\t\tif (IGNORE_CLS_NAMES.contains(shortName)) {\n-\t\t\t\tcls.add(AFlag.DONT_GENERATE);\n-\t\t\t\tLOG.debug(\"Skip class: {}\", cls);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n \tprivate ApplicationParams getApplicationParams(Document androidManifest, Document appStrings) {\n \t\tElement manifest = (Element) androidManifest.getElementsByTagName(\"manifest\").item(0);\n \t\tElement usesSdk = (Element) androidManifest.getElementsByTagName(\"uses-sdk\").item(0);",
    "output": "Remove class filtering on export"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n@@ -259,6 +259,11 @@ public boolean canReorder() {\n \t\t\tcase STR_CONCAT:\n \t\t\t\treturn true;\n \n+\t\t\tcase SGET:\n+\t\t\tcase IGET:\n+\t\t\t\t// TODO: allow to move final fields\n+\t\t\t\treturn false;\n+\n \t\t\tdefault:\n \t\t\t\treturn false;\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -72,7 +72,7 @@ public void visit(MethodNode mth) {\n \t\t\t\tchanged = true;\n \t\t\t}\n \t\t}\n-\t\tif (changed) {\n+\t\tif (changed || mth.contains(AFlag.REQUEST_CODE_SHRINK)) {\n \t\t\tCodeShrinkVisitor.shrinkMethod(mth);\n \t\t}\n \t}\n@@ -121,6 +121,7 @@ private void simplifyArgs(MethodNode mth, InsnNode insn) {\n \t\t}\n \t\tif (changed) {\n \t\t\tinsn.rebindArgs();\n+\t\t\tmth.add(AFlag.REQUEST_CODE_SHRINK);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldUsageMove.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldUsageMove.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldUsageMove.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldUsageMove.java\n@@ -0,0 +1,40 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+import jadx.tests.api.extensions.profiles.TestProfile;\n+import jadx.tests.api.extensions.profiles.TestWithProfiles;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestFieldUsageMove extends SmaliTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic static void test(Object obj) {\n+\t\t\tif (obj instanceof Boolean) {\n+\t\t\t\tSystem.out.println(\"Boolean: \" + obj);\n+\t\t\t}\n+\t\t\tif (obj instanceof Float) {\n+\t\t\t\tSystem.out.println(\"Float: \" + obj);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@TestWithProfiles(TestProfile.D8_J11)\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"System.out.println(\\\"Boolean: \\\" +\")\n+\t\t\t\t.containsOne(\"System.out.println(\\\"Float: \\\" +\");\n+\t}\n+\n+\t@Test\n+\tpublic void testSmali() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"System.out.println(\\\"Boolean: \\\" +\")\n+\t\t\t\t.containsOne(\"System.out.println(\\\"Float: \\\" +\");\n+\t}\n+}",
    "output": "Fix run code schrink after insn args simplify"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/DeboxingVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/DeboxingVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/DeboxingVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DeboxingVisitor.java\n@@ -99,7 +99,7 @@ private InsnNode checkForReplace(InvokeNode insnNode) {\n \t\t\t\t}\n \t\t\t\targ.setType(primitiveType);\n \t\t\t\tboolean forbidInline;\n-\t\t\t\tif (canChangeTypeToPrimitive(resArg)) {\n+\t\t\t\tif (canChangeTypeToPrimitive(resArg, boxType)) {\n \t\t\t\t\tresArg.setType(primitiveType);\n \t\t\t\t\tforbidInline = false;\n \t\t\t\t} else {\n@@ -132,7 +132,7 @@ private boolean isNeedExplicitCast(RegisterArg resArg, ArgType primitiveType, Ar\n \t\treturn false;\n \t}\n \n-\tprivate boolean canChangeTypeToPrimitive(RegisterArg arg) {\n+\tprivate boolean canChangeTypeToPrimitive(RegisterArg arg, ArgType boxType) {\n \t\tfor (SSAVar ssaVar : arg.getSVar().getCodeVar().getSsaVars()) {\n \t\t\tif (ssaVar.isTypeImmutable()) {\n \t\t\t\treturn false;\n@@ -148,6 +148,12 @@ private boolean canChangeTypeToPrimitive(RegisterArg arg) {\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \t\t\t}\n+\t\t\tArgType initType = assignInsn.getResult().getInitType();\n+\t\t\tif (initType.isObject() && !initType.equals(boxType)) {\n+\t\t\t\t// some of related vars have another object type\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n \t\t\tfor (RegisterArg useArg : ssaVar.getUseList()) {\n \t\t\t\tInsnNode parentInsn = useArg.getParentInsn();\n \t\t\t\tif (parentInsn == null) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing5.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing5.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing5.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing5.java\n@@ -0,0 +1,50 @@\n+package jadx.tests.integration.others;\n+\n+import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.extensions.profiles.TestProfile;\n+import jadx.tests.api.extensions.profiles.TestWithProfiles;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestDeboxing5 extends IntegrationTest {\n+\n+\t@SuppressWarnings(\"WrapperTypeMayBePrimitive\")\n+\tpublic static class TestCls {\n+\t\tprivate static String type;\n+\n+\t\tpublic static void test(String[] args) {\n+\t\t\tFloat f = (float) -47.99;\n+\t\t\tBoolean b = args.length == 0;\n+\t\t\tObject o = ((b) ? false : f);\n+\t\t\tcall(o);\n+\t\t}\n+\n+\t\tpublic static void call(Object o) {\n+\t\t\tif (o instanceof Boolean) {\n+\t\t\t\ttype = \"Boolean\";\n+\t\t\t}\n+\t\t\tif (o instanceof Float) {\n+\t\t\t\ttype = \"Float\";\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate static void verify(String[] arr, String str) {\n+\t\t\ttype = null;\n+\t\t\ttest(arr);\n+\t\t\tassertThat(type).isEqualTo(str);\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tverify(new String[0], \"Boolean\");\n+\t\t\tverify(new String[] { \"1\" }, \"Float\");\n+\t\t}\n+\t}\n+\n+\t@TestWithProfiles(TestProfile.D8_J11)\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"boolean valueOf\");\n+\t}\n+}",
    "output": "Fix additional checks for primitive deboxing"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -1003,13 +1003,19 @@ private void makeInlinedLambdaMethod(ICodeWriter code, InvokeCustomNode customNo\n \t\t} else {\n \t\t\tint callArgsCount = callArgs.size();\n \t\t\tint startArg = callArgsCount - implArgs.size();\n+\t\t\tif (callArgsCount - startArg > 1) {\n+\t\t\t\tcode.add('(');\n+\t\t\t}\n \t\t\tfor (int i = startArg; i < callArgsCount; i++) {\n \t\t\t\tif (i != startArg) {\n \t\t\t\t\tcode.add(\", \");\n \t\t\t\t}\n \t\t\t\tCodeVar argCodeVar = callArgs.get(i).getSVar().getCodeVar();\n \t\t\t\tdefVar(code, argCodeVar);\n \t\t\t}\n+\t\t\tif (callArgsCount - startArg > 1) {\n+\t\t\t\tcode.add(')');\n+\t\t\t}\n \t\t}\n \t\t// force set external arg names into call method args\n \t\tint extArgsCount = customNode.getArgsCount();\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaArgs.java b/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaArgs.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaArgs.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaArgs.java\n@@ -0,0 +1,37 @@\n+package jadx.tests.integration.java8;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestLambdaArgs extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic void test1() {\n+\t\t\tcall1(a -> -a);\n+\t\t}\n+\n+\t\tpublic void test2() {\n+\t\t\tcall2((a, b) -> a - b);\n+\t\t}\n+\n+\t\tprivate void call1(Function<Integer, Integer> func) {\n+\t\t}\n+\n+\t\tprivate void call2(BiFunction<Integer, Integer, Integer> func) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"call1(a ->\")\n+\t\t\t\t.containsOne(\"call2((a, b) ->\");\n+\t}\n+}",
    "output": "Add parentheses around multiple lambda arguments"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/plugins/mappings/RenameMappingsGui.java b/jadx-gui/src/main/java/jadx/gui/plugins/mappings/RenameMappingsGui.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/mappings/RenameMappingsGui.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/mappings/RenameMappingsGui.java\n@@ -27,9 +27,13 @@\n import jadx.gui.jobs.TaskStatus;\n import jadx.gui.settings.JadxProject;\n import jadx.gui.settings.JadxSettings;\n+import jadx.gui.treemodel.JNode;\n+import jadx.gui.treemodel.JRoot;\n import jadx.gui.ui.MainWindow;\n+import jadx.gui.ui.TabbedPane;\n import jadx.gui.ui.filedialog.FileDialogWrapper;\n import jadx.gui.ui.filedialog.FileOpenMode;\n+import jadx.gui.ui.panel.ContentPanel;\n import jadx.gui.utils.NLS;\n import jadx.gui.utils.UiUtils;\n import jadx.gui.utils.ui.ActionHandler;\n@@ -41,8 +45,8 @@ public class RenameMappingsGui {\n \n \tprivate final MainWindow mainWindow;\n \n-\t// private MappingFormat currentMappingFormat;\n \tprivate boolean renamesChanged = false;\n+\tprivate JInputMapping mappingNode;\n \n \tprivate transient JMenu openMappingsMenu;\n \tprivate transient Action saveMappingsAction;\n@@ -52,6 +56,7 @@ public class RenameMappingsGui {\n \tpublic RenameMappingsGui(MainWindow mainWindow) {\n \t\tthis.mainWindow = mainWindow;\n \t\tmainWindow.addLoadListener(this::onLoad);\n+\t\tmainWindow.addTreeUpdateListener(this::treeUpdate);\n \t}\n \n \tpublic void addMenuActions(JMenu menu) {\n@@ -84,6 +89,7 @@ public void addMenuActions(JMenu menu) {\n \n \tprivate boolean onLoad(boolean loaded) {\n \t\trenamesChanged = false;\n+\t\tmappingNode = null;\n \t\tif (loaded) {\n \t\t\tRootNode rootNode = mainWindow.getWrapper().getRootNode();\n \t\t\trootNode.registerCodeDataUpdateListener(codeData -> onRename());\n@@ -119,6 +125,29 @@ public void onUpdate(boolean loaded) {\n \t\tcloseMappingsAction.setEnabled(project.getMappingsPath() != null);\n \t}\n \n+\tprivate void treeUpdate(JRoot treeRoot) {\n+\t\tif (mappingNode != null) {\n+\t\t\t// already added\n+\t\t\treturn;\n+\t\t}\n+\t\tPath mappingsPath = mainWindow.getProject().getMappingsPath();\n+\t\tif (mappingsPath == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\tJNode node = treeRoot.followStaticPath(\"JInputs\");\n+\t\tJNode currentNode = node.removeNode(n -> n.getClass().equals(JInputMapping.class));\n+\t\tif (currentNode != null) {\n+\t\t\t// close opened tab\n+\t\t\tTabbedPane tabbedPane = mainWindow.getTabbedPane();\n+\t\t\tContentPanel openedTab = tabbedPane.getOpenTabs().get(currentNode);\n+\t\t\tif (openedTab != null) {\n+\t\t\t\ttabbedPane.closeCodePanel(openedTab);\n+\t\t\t}\n+\t\t}\n+\t\tmappingNode = new JInputMapping(mappingsPath);\n+\t\tnode.add(mappingNode);\n+\t}\n+\n \tprivate void openMappings(MappingFormat mappingFormat, boolean inverted) {\n \t\tFileDialogWrapper fileDialog = new FileDialogWrapper(mainWindow, FileOpenMode.CUSTOM_OPEN);\n \t\tfileDialog.setTitle(NLS.str(\"file.open_mappings\"));\n@@ -205,7 +234,10 @@ private void saveMappingsAs(MappingFormat mappingFormat) {\n \t\t\toptions.put(RenameMappingsOptions.FORMAT_OPT, mappingFormat.name());\n \t\t\toptions.put(RenameMappingsOptions.INVERT_OPT, \"no\");\n \t\t});\n-\t\tsaveInBackground(mappingFormat, savePath, s -> mainWindow.reopen());\n+\t\tsaveInBackground(mappingFormat, savePath, s -> {\n+\t\t\tmappingNode = null;\n+\t\t\tmainWindow.reloadTree();\n+\t\t});\n \t}\n \n \tprivate void saveInBackground(MappingFormat mappingFormat, Path savePath, Consumer<TaskStatus> onFinishUiRunnable) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/TabStateViewAdapter.java b/jadx-gui/src/main/java/jadx/gui/settings/TabStateViewAdapter.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/TabStateViewAdapter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/TabStateViewAdapter.java\n@@ -68,7 +68,7 @@ private static JNode loadJNode(MainWindow mw, TabViewState tvs) {\n \t\t\t\t\t\t.searchNode(node -> node instanceof JInputScript && node.getName().equals(tvs.getTabPath()));\n \n \t\t\tcase \"mapping\":\n-\t\t\t\treturn mw.getTreeRoot().followStaticPath(\"JInputs\", \"JInputMapping\");\n+\t\t\t\treturn mw.getTreeRoot().followStaticPath(\"JInputs\").searchNode(node -> node instanceof JInputMapping);\n \t\t}\n \t\treturn null;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JInputs.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JInputs.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JInputs.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JInputs.java\n@@ -1,6 +1,5 @@\n package jadx.gui.treemodel;\n \n-import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.Iterator;\n@@ -11,7 +10,6 @@\n \n import jadx.core.utils.files.FileUtils;\n import jadx.gui.JadxWrapper;\n-import jadx.gui.plugins.mappings.JInputMapping;\n import jadx.gui.settings.JadxProject;\n import jadx.gui.utils.NLS;\n import jadx.gui.utils.UiUtils;\n@@ -35,11 +33,6 @@ public JInputs(JadxWrapper wrapper) {\n \n \t\tadd(new JInputFiles(files));\n \t\tadd(new JInputScripts(scripts));\n-\n-\t\tPath mappingsPath = project.getMappingsPath();\n-\t\tif (mappingsPath != null && Files.isRegularFile(mappingsPath)) {\n-\t\t\tadd(new JInputMapping(mappingsPath));\n-\t\t}\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n@@ -111,7 +111,7 @@ public String getTooltip() {\n \t}\n \n \tpublic @Nullable JNode searchNode(Predicate<JNode> filter) {\n-\t\tEnumeration<?> en = this.breadthFirstEnumeration();\n+\t\tEnumeration<?> en = this.children();\n \t\twhile (en.hasMoreElements()) {\n \t\t\tJNode node = (JNode) en.nextElement();\n \t\t\tif (filter.test(node)) {\n@@ -121,6 +121,21 @@ public String getTooltip() {\n \t\treturn null;\n \t}\n \n+\t/**\n+\t * Remove and return first found node\n+\t */\n+\tpublic @Nullable JNode removeNode(Predicate<JNode> filter) {\n+\t\tEnumeration<?> en = this.children();\n+\t\twhile (en.hasMoreElements()) {\n+\t\t\tJNode node = (JNode) en.nextElement();\n+\t\t\tif (filter.test(node)) {\n+\t\t\t\tthis.remove(node);\n+\t\t\t\treturn node;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \tprivate static final Comparator<JNode> COMPARATOR = Comparator\n \t\t\t.comparing(JNode::makeLongString)\n \t\t\t.thenComparingInt(JNode::getPos);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -37,6 +37,7 @@\n import java.util.Timer;\n import java.util.TimerTask;\n import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n \n import javax.swing.AbstractAction;\n import javax.swing.Action;\n@@ -212,6 +213,7 @@ public class MainWindow extends JFrame {\n \tprivate transient @Nullable JDebuggerPanel debuggerPanel;\n \n \tprivate final List<ILoadListener> loadListeners = new ArrayList<>();\n+\tprivate final List<Consumer<JRoot>> treeUpdateListener = new ArrayList<>();\n \tprivate boolean loaded;\n \n \tprivate JMenu pluginsMenu;\n@@ -689,6 +691,7 @@ private void clearTree() {\n \n \tpublic void reloadTree() {\n \t\ttreeReloading = true;\n+\t\ttreeUpdateListener.forEach(listener -> listener.accept(treeRoot));\n \n \t\ttreeModel.reload();\n \t\tList<String[]> treeExpansions = project.getTreeExpansions();\n@@ -1526,6 +1529,10 @@ public void notifyLoadListeners(boolean loaded) {\n \t\tloadListeners.removeIf(listener -> listener.update(loaded));\n \t}\n \n+\tpublic void addTreeUpdateListener(Consumer<JRoot> listener) {\n+\t\ttreeUpdateListener.add(listener);\n+\t}\n+\n \tpublic JadxWrapper getWrapper() {\n \t\treturn wrapper;\n \t}",
    "output": "Fix update mappings node instead full reload on 'save as'"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -66,12 +66,12 @@ public class JadxSettings extends JadxCLIArgs {\n \tprivate List<Path> recentProjects = new ArrayList<>();\n \tprivate String fontStr = \"\";\n \tprivate String smaliFontStr = \"\";\n-\tprivate String editorThemePath = \"\";\n+\tprivate String editorThemePath = EditorTheme.getDefaultTheme().getPath();\n \tprivate String lafTheme = LafManager.INITIAL_THEME_NAME;\n \tprivate LangLocale langLocale = NLS.defaultLocale();\n \tprivate boolean autoStartJobs = false;\n \tprivate String excludedPackages = \"\";\n-\tprivate boolean autoSaveProject = false;\n+\tprivate boolean autoSaveProject = true;\n \n \tprivate boolean showHeapUsageBar = false;\n \tprivate boolean alwaysSelectOpened = false;\n@@ -107,7 +107,7 @@ public class JadxSettings extends JadxCLIArgs {\n \n \tprivate boolean dockLogViewer = true;\n \n-\tprivate int settingsVersion = 0;\n+\tprivate int settingsVersion = CURRENT_SETTINGS_VERSION;\n \n \t@JadxSettingsAdapter.GsonExclude\n \t@Parameter(names = { \"-sc\", \"--select-class\" }, description = \"GUI: Open the selected class and show the decompiled code\")\n@@ -699,65 +699,8 @@ public void setDockLogViewer(boolean dockLogViewer) {\n \n \tprivate void upgradeSettings(int fromVersion) {\n \t\tLOG.debug(\"upgrade settings from version: {} to {}\", fromVersion, CURRENT_SETTINGS_VERSION);\n-\t\tif (fromVersion == 0) {\n-\t\t\tsetDeobfuscationMinLength(3);\n-\t\t\tsetDeobfuscationMaxLength(64);\n-\t\t\tsetDeobfuscationUseSourceNameAsAlias(true);\n-\t\t\tsetDeobfuscationParseKotlinMetadata(true);\n-\t\t\tsetGeneratedRenamesMappingFileMode(GeneratedRenamesMappingFileMode.getDefault());\n-\t\t\tsetThreadsCount(JadxArgs.DEFAULT_THREADS_COUNT);\n-\t\t\tsetReplaceConsts(true);\n-\t\t\tsetSkipResources(false);\n-\t\t\tsetAutoStartJobs(false);\n-\t\t\tsetAutoSaveProject(true);\n-\t\t\tfromVersion++;\n-\t\t}\n-\t\tif (fromVersion == 1) {\n-\t\t\tsetEditorThemePath(EditorTheme.getDefaultTheme().getPath());\n-\t\t\tfromVersion++;\n-\t\t}\n-\t\tif (fromVersion == 2) {\n-\t\t\tif (getDeobfuscationMinLength() == 4) {\n-\t\t\t\tsetDeobfuscationMinLength(3);\n-\t\t\t}\n-\t\t\tfromVersion++;\n-\t\t}\n-\t\tif (fromVersion == 3) {\n-\t\t\tsetLangLocale(NLS.defaultLocale());\n-\t\t\tfromVersion++;\n-\t\t}\n-\t\tif (fromVersion == 4) {\n-\t\t\tsetUseImports(true);\n-\t\t\tfromVersion++;\n-\t\t}\n-\t\tif (fromVersion == 5) {\n-\t\t\tsetRespectBytecodeAccessModifiers(false);\n-\t\t\tfromVersion++;\n-\t\t}\n-\t\tif (fromVersion == 6) {\n-\t\t\tif (getFont().getFontName().equals(\"Hack Regular\")) {\n-\t\t\t\tsetFont(null);\n-\t\t\t}\n-\t\t\tfromVersion++;\n-\t\t}\n-\t\tif (fromVersion == 7) {\n-\t\t\toutDir = null;\n-\t\t\toutDirSrc = null;\n-\t\t\toutDirRes = null;\n-\t\t\tfromVersion++;\n-\t\t}\n-\t\tif (fromVersion == 8) {\n-\t\t\tfromVersion++;\n-\t\t}\n-\t\tif (fromVersion == 9) {\n-\t\t\tshowHeapUsageBar = false;\n-\t\t\tfromVersion++;\n-\t\t}\n-\t\tif (fromVersion == 10) {\n-\t\t\tsrhResourceSkipSize = 3;\n-\t\t\tsrhResourceFileExt = \".xml|.html|.js|.json|.txt\";\n-\t\t\tfontStr = fontStr.replace('-', '/');\n-\t\t\tfromVersion++;\n+\t\tif (fromVersion <= 10) {\n+\t\t\tfromVersion = 11;\n \t\t}\n \t\tif (fromVersion == 11) {\n \t\t\tinlineMethods = true;",
    "output": "Fix discard old settings migrations"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/SourceFileRename.java b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/SourceFileRename.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/SourceFileRename.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/SourceFileRename.java\n@@ -8,6 +8,7 @@\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.RootNode;\n+import jadx.core.utils.BetterName;\n import jadx.core.utils.StringUtils;\n \n public class SourceFileRename {\n@@ -45,6 +46,15 @@ private static String getAliasFromSourceFile(ClassNode cls) {\n \t\tif (otherCls != null) {\n \t\t\treturn null;\n \t\t}\n+\n+\t\tif (cls.getClassInfo().hasAlias()) {\n+\t\t\t// ignore source name if current alias is \"better\"\n+\t\t\tString currentAlias = cls.getAlias();\n+\t\t\tString betterName = BetterName.compareAndGet(name, currentAlias);\n+\t\t\tif (betterName.equals(currentAlias)) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n \t\tcls.remove(JadxAttrType.SOURCE_FILE);\n \t\treturn name;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BetterName.java b/jadx-core/src/main/java/jadx/core/utils/BetterName.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BetterName.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BetterName.java\n@@ -25,9 +25,9 @@ public static String compareAndGet(String first, String second) {\n \t\tboolean firstBetter = firstRating >= secondRating;\n \t\tif (DEBUG) {\n \t\t\tif (firstBetter) {\n-\t\t\t\tLOG.info(\"Better name: '{}' > '{}' ({} > {})\", first, second, firstRating, secondRating);\n+\t\t\t\tLOG.debug(\"Better name: '{}' > '{}' ({} > {})\", first, second, firstRating, secondRating);\n \t\t\t} else {\n-\t\t\t\tLOG.info(\"Better name: '{}' > '{}' ({} > {})\", second, first, secondRating, firstRating);\n+\t\t\t\tLOG.debug(\"Better name: '{}' > '{}' ({} > {})\", second, first, secondRating, firstRating);\n \t\t\t}\n \t\t}\n \t\treturn firstBetter ? first : second;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/deobf/TestBadSourceFile.java b/jadx-core/src/test/java/jadx/tests/integration/deobf/TestBadSourceFile.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/deobf/TestBadSourceFile.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/deobf/TestBadSourceFile.java\n@@ -0,0 +1,40 @@\n+package jadx.tests.integration.deobf;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestBadSourceFile extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\t// use source name disabled by default\n+\t\tenableDeobfuscation();\n+\t\targs.setDeobfuscationMinLength(100); // rename everything\n+\t\tassertThat(searchCls(loadFromSmaliFiles(), \"b\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"class C0000b {\");\n+\t}\n+\n+\t@Test\n+\tpublic void testWithUseSourceName() {\n+\t\targs.setUseSourceNameAsClassAlias(true);\n+\t\t// deobfuscation disabled\n+\t\tassertThat(searchCls(loadFromSmaliFiles(), \"b\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"class a {\");\n+\t}\n+\n+\t@Test\n+\tpublic void testWithUseSourceNameAndDeobf() {\n+\t\targs.setUseSourceNameAsClassAlias(true);\n+\t\tenableDeobfuscation();\n+\t\targs.setDeobfuscationMinLength(100); // rename everything\n+\t\tassertThat(searchCls(loadFromSmaliFiles(), \"b\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"class C0000b {\")\n+\t\t\t\t.containsOne(\"/* compiled from: a.java */\");\n+\t}\n+}",
    "output": "Fix ignore source name if current alias is better"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -1016,9 +1016,14 @@ private void makeInlinedLambdaMethod(ICodeWriter code, InvokeCustomNode customNo\n \t\tint startArg = customNode.getHandleType() == MethodHandleType.INVOKE_STATIC ? 0 : 1; // skip 'this' arg\n \t\tint callArg = 0;\n \t\tfor (int i = startArg; i < extArgsCount; i++) {\n-\t\t\tRegisterArg extArg = (RegisterArg) customNode.getArg(i);\n-\t\t\tRegisterArg callRegArg = callArgs.get(callArg++);\n-\t\t\tcallRegArg.getSVar().setCodeVar(extArg.getSVar().getCodeVar());\n+\t\t\tInsnArg arg = customNode.getArg(i);\n+\t\t\tif (arg.isRegister()) {\n+\t\t\t\tRegisterArg extArg = (RegisterArg) arg;\n+\t\t\t\tRegisterArg callRegArg = callArgs.get(callArg++);\n+\t\t\t\tcallRegArg.getSVar().setCodeVar(extArg.getSVar().getCodeVar());\n+\t\t\t} else {\n+\t\t\t\tthrow new JadxRuntimeException(\"Unexpected argument type in lambda call: \" + arg.getClass().getSimpleName());\n+\t\t\t}\n \t\t}\n \t\tcode.add(\" -> {\");\n \t\tcode.incIndent();\n@@ -1075,27 +1080,23 @@ void generateMethodArguments(ICodeWriter code, BaseInvokeNode insn, int startArg\n \t\t}\n \t\tint argsCount = insn.getArgsCount();\n \t\tcode.add('(');\n+\t\tSkipMethodArgsAttr skipAttr = mthNode == null ? null : mthNode.get(AType.SKIP_MTH_ARGS);\n \t\tboolean firstArg = true;\n \t\tif (k < argsCount) {\n \t\t\tfor (int i = k; i < argsCount; i++) {\n \t\t\t\tInsnArg arg = insn.getArg(i);\n-\t\t\t\tif (arg.contains(AFlag.SKIP_ARG)) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tint argOrigPos = i - startArgNum;\n-\t\t\t\tif (SkipMethodArgsAttr.isSkip(mthNode, argOrigPos)) {\n+\t\t\t\tif (arg.contains(AFlag.SKIP_ARG) || (skipAttr != null && skipAttr.isSkip(i - startArgNum))) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n-\t\t\t\tif (!firstArg) {\n-\t\t\t\t\tcode.add(\", \");\n-\t\t\t\t} else {\n+\t\t\t\tif (firstArg) {\n \t\t\t\t\tfirstArg = false;\n+\t\t\t\t} else {\n+\t\t\t\t\tcode.add(\", \");\n \t\t\t\t}\n \t\t\t\tif (i == argsCount - 1 && processVarArg(code, insn, arg)) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\taddArg(code, arg, false);\n-\t\t\t\tfirstArg = false;\n \t\t\t}\n \t\t}\n \t\tcode.add(')');\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n@@ -16,6 +16,7 @@\n import jadx.core.dex.instructions.args.PrimitiveType;\n import jadx.core.dex.instructions.args.RegisterArg;\n import jadx.core.dex.instructions.args.SSAVar;\n+import jadx.core.dex.instructions.mods.ConstructorInsn;\n import jadx.core.dex.nodes.BlockNode;\n import jadx.core.dex.nodes.FieldNode;\n import jadx.core.dex.nodes.InsnNode;\n@@ -178,7 +179,7 @@ private static boolean replaceConst(MethodNode mth, InsnNode constInsn, InsnArg\n \t\tList<RegisterArg> useList = new ArrayList<>(ssaVar.getUseList());\n \t\tint replaceCount = 0;\n \t\tfor (RegisterArg arg : useList) {\n-\t\t\tif (canInline(arg) && replaceArg(mth, arg, constArg, constInsn)) {\n+\t\t\tif (canInline(mth, arg) && replaceArg(mth, arg, constArg, constInsn)) {\n \t\t\t\treplaceCount++;\n \t\t\t}\n \t\t}\n@@ -204,8 +205,8 @@ private static boolean canIgnoreInsn(RegisterArg reg) {\n \t}\n \n \t@SuppressWarnings(\"RedundantIfStatement\")\n-\tprivate static boolean canInline(RegisterArg arg) {\n-\t\tif (arg.contains(AFlag.DONT_INLINE_CONST)) {\n+\tprivate static boolean canInline(MethodNode mth, RegisterArg arg) {\n+\t\tif (arg.contains(AFlag.DONT_INLINE_CONST) || arg.contains(AFlag.DONT_INLINE)) {\n \t\t\treturn false;\n \t\t}\n \t\tInsnNode parentInsn = arg.getParentInsn();\n@@ -219,6 +220,14 @@ private static boolean canInline(RegisterArg arg) {\n \t\t\t// don't inline vars used in finally block\n \t\t\treturn false;\n \t\t}\n+\t\tif (parentInsn.getType() == InsnType.CONSTRUCTOR) {\n+\t\t\t// don't inline into anonymous call if it can be inlined later\n+\t\t\tConstructorInsn ctrInsn = (ConstructorInsn) parentInsn;\n+\t\t\tMethodNode ctrMth = mth.root().getMethodUtils().resolveMethod(ctrInsn);\n+\t\t\tif (ctrMth != null && ctrMth.contains(AFlag.METHOD_CANDIDATE_FOR_INLINE)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n \t\treturn true;\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaExtVar2.java b/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaExtVar2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaExtVar2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaExtVar2.java\n@@ -0,0 +1,37 @@\n+package jadx.tests.integration.java8;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.extensions.profiles.TestProfile;\n+import jadx.tests.api.extensions.profiles.TestWithProfiles;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestLambdaExtVar2 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic void test(List<String> list) {\n+\t\t\tString space = \" \";\n+\t\t\tlist.removeIf(s -> s.equals(space) || s.contains(space));\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tList<String> list = new ArrayList<>(Arrays.asList(\"a\", \" \", \"b\", \"r \"));\n+\t\t\ttest(list);\n+\t\t\tassertThat(list).isEqualTo(Arrays.asList(\"a\", \"b\"));\n+\t\t}\n+\t}\n+\n+\t@TestWithProfiles({ TestProfile.DX_J8, TestProfile.D8_J11, TestProfile.JAVA11 })\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"lambda$\")\n+\t\t\t\t.containsOne(\"String space = \\\" \\\";\")\n+\t\t\t\t.containsOne(\"s.equals(space) || s.contains(space)\");\n+\t}\n+}",
    "output": "Fix don't inline constants into lambdas"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/logs/LogAppender.java b/jadx-gui/src/main/java/jadx/gui/logs/LogAppender.java\n--- a/jadx-gui/src/main/java/jadx/gui/logs/LogAppender.java\n+++ b/jadx-gui/src/main/java/jadx/gui/logs/LogAppender.java\n@@ -6,7 +6,7 @@\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.utils.UiUtils;\n \n-import static jadx.plugins.script.runtime.JadxScriptTemplateKt.JADX_SCRIPT_LOG_PREFIX;\n+import static jadx.plugins.script.runtime.ScriptRuntime.JADX_SCRIPT_LOG_PREFIX;\n \n class LogAppender implements ILogListener {\n \tprivate final LogOptions options;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/logs/LogOptions.java b/jadx-gui/src/main/java/jadx/gui/logs/LogOptions.java\n--- a/jadx-gui/src/main/java/jadx/gui/logs/LogOptions.java\n+++ b/jadx-gui/src/main/java/jadx/gui/logs/LogOptions.java\n@@ -6,7 +6,7 @@\n \n import jadx.core.utils.Utils;\n \n-import static jadx.plugins.script.runtime.JadxScriptTemplateKt.JADX_SCRIPT_LOG_PREFIX;\n+import static jadx.plugins.script.runtime.ScriptRuntime.JADX_SCRIPT_LOG_PREFIX;\n \n public class LogOptions {\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptCompleteProvider.java b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptCompleteProvider.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptCompleteProvider.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptCompleteProvider.java\n@@ -27,10 +27,10 @@\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.ui.codearea.AbstractCodeArea;\n import jadx.gui.utils.Icons;\n-import jadx.plugins.script.ide.ScriptCompiler;\n import jadx.plugins.script.ide.ScriptCompletionResult;\n+import jadx.plugins.script.ide.ScriptServices;\n \n-import static jadx.plugins.script.ide.ScriptCompilerKt.AUTO_COMPLETE_INSERT_STR;\n+import static jadx.plugins.script.ide.ScriptServicesKt.AUTO_COMPLETE_INSERT_STR;\n \n public class ScriptCompleteProvider extends CompletionProviderBase {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ScriptCompleteProvider.class);\n@@ -49,19 +49,18 @@ private static Map<String, Icon> buildIconsMap() {\n \t}\n \n \tprivate final AbstractCodeArea codeArea;\n-\tprivate ScriptCompiler scriptComplete;\n+\tprivate ScriptServices scriptComplete;\n \n \tpublic ScriptCompleteProvider(AbstractCodeArea codeArea) {\n \t\tthis.codeArea = codeArea;\n-\t\t// this.scriptComplete = new ScriptCompiler(codeArea.getNode().getName());\n \t}\n \n \tprivate List<Completion> getCompletions() {\n \t\ttry {\n \t\t\tString code = codeArea.getText();\n \t\t\tint caretPos = codeArea.getCaretPosition();\n \t\t\t// TODO: resolve error after reusing ScriptCompiler\n-\t\t\tscriptComplete = new ScriptCompiler(codeArea.getNode().getName());\n+\t\t\tscriptComplete = new ScriptServices(codeArea.getNode().getName());\n \t\t\tScriptCompletionResult result = scriptComplete.complete(code, caretPos);\n \t\t\tint replacePos = getReplacePos(caretPos, result);\n \t\t\tif (!result.getReports().isEmpty()) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/script/ScriptContentPanel.java\n@@ -40,9 +40,9 @@\n import jadx.gui.utils.ui.ActionHandler;\n import jadx.gui.utils.ui.NodeLabel;\n import jadx.plugins.script.ide.ScriptAnalyzeResult;\n-import jadx.plugins.script.ide.ScriptCompiler;\n+import jadx.plugins.script.ide.ScriptServices;\n \n-import static jadx.plugins.script.runtime.JadxScriptTemplateKt.JADX_SCRIPT_LOG_PREFIX;\n+import static jadx.plugins.script.runtime.ScriptRuntime.JADX_SCRIPT_LOG_PREFIX;\n \n public class ScriptContentPanel extends AbstractCodeContentPanel {\n \tprivate static final long serialVersionUID = 6575696321112417513L;\n@@ -154,8 +154,8 @@ private boolean checkScript() {\n \t\t\tString code = scriptArea.getText();\n \t\t\tString fileName = scriptArea.getNode().getName();\n \n-\t\t\tScriptCompiler scriptCompiler = new ScriptCompiler(fileName);\n-\t\t\tScriptAnalyzeResult result = scriptCompiler.analyze(code, scriptArea.getCaretPosition());\n+\t\t\tScriptServices scriptServices = new ScriptServices(fileName);\n+\t\t\tScriptAnalyzeResult result = scriptServices.analyze(code, scriptArea.getCaretPosition());\n \t\t\tList<ScriptDiagnostic> issues = result.getIssues();\n \t\t\tboolean success = true;\n \t\t\tfor (ScriptDiagnostic issue : issues) {",
    "output": "Fix scripts runtime code and docs clean up"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n@@ -264,6 +264,13 @@ public boolean isSameConst(InsnArg other) {\n \t\treturn false;\n \t}\n \n+\tpublic boolean isSameVar(RegisterArg arg) {\n+\t\tif (isRegister()) {\n+\t\t\treturn ((RegisterArg) this).sameRegAndSVar(arg);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tprotected final <T extends InsnArg> T copyCommonParams(T copy) {\n \t\tcopy.copyAttributesFrom(this);\n \t\tcopy.setParentInsn(parentInsn);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n@@ -80,13 +80,47 @@ private static MethodInlineAttr inlineMth(MethodNode mth) {\n \t\t\treturn addInlineAttr(mth, insn);\n \t\t}\n \t\tif (insnsCount == 2 && insns.get(1).getType() == InsnType.RETURN) {\n-\t\t\t// synthetic field setter\n-\t\t\treturn addInlineAttr(mth, insns.get(0));\n+\t\t\tInsnNode firstInsn = insns.get(0);\n+\t\t\tInsnNode retInsn = insns.get(1);\n+\t\t\tif (retInsn.getArgsCount() == 0\n+\t\t\t\t\t|| isSyntheticAccessPattern(mth, firstInsn, retInsn)) {\n+\t\t\t\treturn addInlineAttr(mth, firstInsn);\n+\t\t\t}\n \t\t}\n \t\t// TODO: inline field arithmetics. Disabled tests: TestAnonymousClass3a and TestAnonymousClass5\n \t\treturn null;\n \t}\n \n+\tprivate static boolean isSyntheticAccessPattern(MethodNode mth, InsnNode firstInsn, InsnNode retInsn) {\n+\t\tList<RegisterArg> mthRegs = mth.getArgRegs();\n+\t\tswitch (firstInsn.getType()) {\n+\t\t\tcase IGET:\n+\t\t\t\treturn mthRegs.size() == 1\n+\t\t\t\t\t\t&& retInsn.getArg(0).isSameVar(firstInsn.getResult())\n+\t\t\t\t\t\t&& firstInsn.getArg(0).isSameVar(mthRegs.get(0));\n+\t\t\tcase SGET:\n+\t\t\t\treturn mthRegs.size() == 0\n+\t\t\t\t\t\t&& retInsn.getArg(0).isSameVar(firstInsn.getResult());\n+\n+\t\t\tcase IPUT:\n+\t\t\t\treturn mthRegs.size() == 2\n+\t\t\t\t\t\t&& retInsn.getArg(0).isSameVar(mthRegs.get(1))\n+\t\t\t\t\t\t&& firstInsn.getArg(0).isSameVar(mthRegs.get(1))\n+\t\t\t\t\t\t&& firstInsn.getArg(1).isSameVar(mthRegs.get(0));\n+\t\t\tcase SPUT:\n+\t\t\t\treturn mthRegs.size() == 1\n+\t\t\t\t\t\t&& retInsn.getArg(0).isSameVar(mthRegs.get(0))\n+\t\t\t\t\t\t&& firstInsn.getArg(0).isSameVar(mthRegs.get(0));\n+\n+\t\t\tcase INVOKE:\n+\t\t\t\treturn mthRegs.size() >= 1\n+\t\t\t\t\t\t&& firstInsn.getArg(0).isSameVar(mthRegs.get(0))\n+\t\t\t\t\t\t&& retInsn.getArg(0).isSameVar(firstInsn.getResult());\n+\t\t\tdefault:\n+\t\t\t\treturn false;\n+\t\t}\n+\t}\n+\n \tprivate static MethodInlineAttr addInlineAttr(MethodNode mth, InsnNode insn) {\n \t\tif (!fixVisibilityOfInlineCode(mth, insn)) {\n \t\t\treturn null;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n@@ -9,6 +9,8 @@\n \n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.instructions.InsnType;\n+import jadx.core.dex.instructions.InvokeCustomNode;\n+import jadx.core.dex.instructions.InvokeNode;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.InsnWrapArg;\n import jadx.core.dex.instructions.args.Named;\n@@ -123,6 +125,9 @@ private static void checkInline(MethodNode mth, BlockNode block, InsnList insnLi\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n+\t\tif (!checkLambdaInline(arg, assignInsn)) {\n+\t\t\treturn;\n+\t\t}\n \n \t\tint assignPos = insnList.getIndex(assignInsn);\n \t\tif (assignPos != -1) {\n@@ -145,6 +150,26 @@ && canMoveBetweenBlocks(mth, assignInsn, assignBlock, block, argsInfo.getInsn())\n \t\t}\n \t}\n \n+\t/**\n+\t * Forbid inline lambda into invoke as an instance arg, i.e. this will not compile:\n+\t * {@code () -> { ... }.apply(); }\n+\t */\n+\tprivate static boolean checkLambdaInline(RegisterArg arg, InsnNode assignInsn) {\n+\t\tif (assignInsn.getType() == InsnType.INVOKE && assignInsn instanceof InvokeCustomNode) {\n+\t\t\tfor (RegisterArg useArg : arg.getSVar().getUseList()) {\n+\t\t\t\tInsnNode parentInsn = useArg.getParentInsn();\n+\t\t\t\tif (parentInsn != null && parentInsn.getType() == InsnType.INVOKE) {\n+\t\t\t\t\tInvokeNode invokeNode = (InvokeNode) parentInsn;\n+\t\t\t\t\tInsnArg instArg = invokeNode.getInstanceArg();\n+\t\t\t\t\tif (instArg != null && instArg == useArg) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n \tprivate static boolean varWithSameNameExists(MethodNode mth, SSAVar inlineVar) {\n \t\tfor (SSAVar ssaVar : mth.getSVars()) {\n \t\t\tif (ssaVar == inlineVar || ssaVar.getCodeVar() == inlineVar.getCodeVar()) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaReturn.java b/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaReturn.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaReturn.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaReturn.java\n@@ -0,0 +1,61 @@\n+package jadx.tests.integration.java8;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.extensions.profiles.TestProfile;\n+import jadx.tests.api.extensions.profiles.TestWithProfiles;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestLambdaReturn extends IntegrationTest {\n+\n+\t@SuppressWarnings(\"unused\")\n+\tpublic static class TestCls {\n+\t\tinterface Function0<R> {\n+\t\t\tR apply();\n+\t\t}\n+\n+\t\tpublic static class T2 {\n+\t\t\tpublic long l;\n+\n+\t\t\tpublic T2(long l) {\n+\t\t\t\tthis.l = l;\n+\t\t\t}\n+\n+\t\t\tpublic void w() {\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic Byte test(Byte b1) {\n+\t\t\tFunction0<Void> f1 = () -> {\n+\t\t\t\tnew T2(94L).w();\n+\t\t\t\treturn null;\n+\t\t\t};\n+\t\t\tf1.apply();\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t@TestWithProfiles(TestProfile.DX_J8)\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsLines(2,\n+\t\t\t\t\t\t\"Function0<Void> f1 = () -> {\",\n+\t\t\t\t\t\tindent() + \"new T2(94L).w();\",\n+\t\t\t\t\t\tindent() + \"return null;\",\n+\t\t\t\t\t\t\"};\");\n+\t}\n+\n+\t@TestWithProfiles(TestProfile.D8_J11_DESUGAR)\n+\tpublic void testLambda() {\n+\t\tgetClassNode(TestCls.class);\n+\t}\n+\n+\t@Test\n+\tpublic void testNoDebug() {\n+\t\tnoDebugInfo();\n+\t\tgetClassNode(TestCls.class);\n+\t}\n+}",
    "output": "Use strict patterns for synthetic methods inline"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n@@ -125,17 +125,30 @@ private static boolean forbidNullInlines(SSAVar sVar) {\n \t\tint k = 0;\n \t\tfor (RegisterArg useArg : useList) {\n \t\t\tInsnNode insn = useArg.getParentInsn();\n-\t\t\tif (insn == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tif (!canUseNull(insn, useArg)) {\n-\t\t\t\tuseArg.add(AFlag.DONT_INLINE_CONST);\n+\t\t\tif (insn != null && forbidNullArgInline(insn, useArg)) {\n \t\t\t\tk++;\n \t\t\t}\n \t\t}\n \t\treturn k == useList.size();\n \t}\n \n+\tprivate static boolean forbidNullArgInline(InsnNode insn, RegisterArg useArg) {\n+\t\tswitch (insn.getType()) {\n+\t\t\tcase MOVE:\n+\t\t\tcase CAST:\n+\t\t\tcase CHECK_CAST:\n+\t\t\t\t// result is null, chain checks\n+\t\t\t\treturn forbidNullInlines(insn.getResult().getSVar());\n+\n+\t\t\tdefault:\n+\t\t\t\tif (!canUseNull(insn, useArg)) {\n+\t\t\t\t\tuseArg.add(AFlag.DONT_INLINE_CONST);\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t\treturn false;\n+\t\t}\n+\t}\n+\n \tprivate static boolean canUseNull(InsnNode insn, RegisterArg useArg) {\n \t\tswitch (insn.getType()) {\n \t\t\tcase INVOKE:\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestNullInline.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestNullInline.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestNullInline.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestNullInline.java\n@@ -0,0 +1,43 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestNullInline extends IntegrationTest {\n+\n+\t@SuppressWarnings({ \"RedundantCast\", \"DataFlowIssue\", \"unused\" })\n+\tpublic static class TestCls {\n+\t\tpublic static Long test(Double d1) {\n+\t\t\tT1<T2, Byte> t1 = (T1<T2, Byte>) null;\n+\t\t\treturn t1.t2.l;\n+\t\t}\n+\n+\t\tstatic class T2 {\n+\t\t\tpublic long l;\n+\t\t}\n+\n+\t\tstatic class T1<H, P extends Byte> {\n+\t\t\tpublic T2 t2;\n+\n+\t\t\tpublic T1(T2 t2) {\n+\t\t\t\tthis.t2 = t2;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"Long.valueOf(t1.t2.l);\");\n+\t}\n+\n+\t@Test\n+\tpublic void testNoDebug() {\n+\t\tnoDebugInfo();\n+\t\tgetClassNode(TestCls.class);\n+\t}\n+}",
    "output": "Fix additional checks to forbid inline of null consts"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -1014,9 +1014,10 @@ private void makeInlinedLambdaMethod(ICodeWriter code, InvokeCustomNode customNo\n \t\t// force set external arg names into call method args\n \t\tint extArgsCount = customNode.getArgsCount();\n \t\tint startArg = customNode.getHandleType() == MethodHandleType.INVOKE_STATIC ? 0 : 1; // skip 'this' arg\n+\t\tint callArg = 0;\n \t\tfor (int i = startArg; i < extArgsCount; i++) {\n \t\t\tRegisterArg extArg = (RegisterArg) customNode.getArg(i);\n-\t\t\tRegisterArg callRegArg = callArgs.get(i);\n+\t\t\tRegisterArg callRegArg = callArgs.get(callArg++);\n \t\t\tcallRegArg.getSVar().setCodeVar(extArg.getSVar().getCodeVar());\n \t\t}\n \t\tcode.add(\" -> {\");\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaInstance2.java b/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaInstance2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaInstance2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaInstance2.java\n@@ -0,0 +1,36 @@\n+package jadx.tests.integration.java8;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestLambdaInstance2 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tprivate String field;\n+\n+\t\tpublic Runnable test(String str, int i) {\n+\t\t\treturn () -> call(str, i);\n+\t\t}\n+\n+\t\tpublic void call(String str, int i) {\n+\t\t\tfield = str + '=' + i;\n+\t\t}\n+\n+\t\tpublic void check() throws Exception {\n+\t\t\tfield = \"\";\n+\t\t\ttest(\"num\", 7).run();\n+\t\t\tassertThat(field).isEqualTo(\"num=7\");\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"lambda$\")\n+\t\t\t\t.containsOne(\"call(str, i)\");\n+\t}\n+}",
    "output": "Fix correct args shift for instance invoke-custom"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n@@ -123,14 +123,15 @@ private void addValue(ICodeWriter cw, ResourceEntry ri) {\n \t\t\t\tif (formatValue != null) {\n \t\t\t\t\tcw.add(\"\\\" format=\\\"\").add(formatValue);\n \t\t\t\t}\n-\t\t\t\tcw.add(\"\\\"\");\n \t\t\t} else {\n-\t\t\t\tcw.add(ri.getKeyName()).add('\\\"');\n+\t\t\t\tcw.add(ri.getKeyName());\n \t\t\t}\n-\t\t\tcw.add(\" parent=\\\"\");\n-\t\t\tif (ri.getParentRef() != 0) {\n-\t\t\t\tString parent = vp.decodeValue(TYPE_REFERENCE, ri.getParentRef());\n-\t\t\t\tcw.add(parent);\n+\t\t\tif (ri.getTypeName().equals(\"style\") || ri.getParentRef() != 0) {\n+\t\t\t\tcw.add(\"\\\" parent=\\\"\");\n+\t\t\t\tif (ri.getParentRef() != 0) {\n+\t\t\t\t\tString parent = vp.decodeValue(TYPE_REFERENCE, ri.getParentRef());\n+\t\t\t\t\tcw.add(parent);\n+\t\t\t\t}\n \t\t\t}\n \t\t\tcw.add(\"\\\">\");",
    "output": "Use parent attibute only for styles"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java b/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n--- a/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n+++ b/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n@@ -6,6 +6,7 @@\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Set;\n+import java.util.regex.Pattern;\n \n import javax.xml.parsers.DocumentBuilder;\n \n@@ -29,6 +30,8 @@ public class ExportGradleProject {\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(ExportGradleProject.class);\n \n+\tprivate static final Pattern ILLEGAL_GRADLE_CHARS = Pattern.compile(\"[/\\\\\\\\:>\\\"?*|]\");\n+\n \tprivate static final Set<String> IGNORE_CLS_NAMES = new HashSet<>(Arrays.asList(\n \t\t\t\"R\",\n \t\t\t\"BuildConfig\"));\n@@ -72,7 +75,7 @@ private void saveProjectBuildGradle() throws IOException {\n \tprivate void saveSettingsGradle() throws IOException {\n \t\tTemplateFile tmpl = TemplateFile.fromResources(\"/export/settings.gradle.tmpl\");\n \n-\t\ttmpl.add(\"applicationName\", applicationParams.getApplicationName());\n+\t\ttmpl.add(\"applicationName\", ILLEGAL_GRADLE_CHARS.matcher(applicationParams.getApplicationName()).replaceAll(\"\"));\n \t\ttmpl.save(new File(projectDir, \"settings.gradle\"));\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/ExportGradleTest.java b/jadx-core/src/test/java/jadx/tests/api/ExportGradleTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/ExportGradleTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/ExportGradleTest.java\n@@ -67,4 +67,10 @@ protected String getAppGradleBuild() {\n \t\tassertThat(appBuildGradle.exists());\n \t\treturn loadFileContent(appBuildGradle);\n \t}\n+\n+\tprotected String getSettingsGradle() {\n+\t\tFile settingsGradle = new File(exportDir, \"settings.gradle\");\n+\t\tassertThat(settingsGradle.exists());\n+\t\treturn loadFileContent(settingsGradle);\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/export/IllegalCharsForGradleWrapper.java b/jadx-core/src/test/java/jadx/tests/export/IllegalCharsForGradleWrapper.java\n--- a/jadx-core/src/test/java/jadx/tests/export/IllegalCharsForGradleWrapper.java\n+++ b/jadx-core/src/test/java/jadx/tests/export/IllegalCharsForGradleWrapper.java\n@@ -0,0 +1,17 @@\n+package jadx.tests.export;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.ExportGradleTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+class IllegalCharsForGradleWrapper extends ExportGradleTest {\n+\n+\t@Test\n+\tvoid test() {\n+\t\texportGradle(\"IllegalCharsForGradleWrapper.xml\", \"strings.xml\");\n+\n+\t\tassertThat(getSettingsGradle()).contains(\"'JadxTestApp'\");\n+\t}\n+}",
    "output": "Fix filter invalid chars in app name for gradle export"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n@@ -109,10 +109,10 @@ private void addValue(ICodeWriter cw, ResourceEntry ri) {\n \t\t\taddSimpleValue(cw, ri.getTypeName(), ri.getTypeName(), \"name\", ri.getKeyName(), valueStr);\n \t\t} else {\n \t\t\tcw.startLine();\n-\t\t\tcw.add('<').add(ri.getTypeName()).add(' ');\n+\t\t\tcw.add('<').add(ri.getTypeName()).add(\" name=\\\"\");\n \t\t\tString itemTag = \"item\";\n \t\t\tif (ri.getTypeName().equals(\"attr\") && !ri.getNamedValues().isEmpty()) {\n-\t\t\t\tcw.add(\"name=\\\"\").add(ri.getKeyName());\n+\t\t\t\tcw.add(ri.getKeyName());\n \t\t\t\tint type = ri.getNamedValues().get(0).getRawValue().getData();\n \t\t\t\tif ((type & ValuesParser.ATTR_TYPE_ENUM) != 0) {\n \t\t\t\t\titemTag = \"enum\";\n@@ -125,13 +125,14 @@ private void addValue(ICodeWriter cw, ResourceEntry ri) {\n \t\t\t\t}\n \t\t\t\tcw.add(\"\\\"\");\n \t\t\t} else {\n-\t\t\t\tcw.add(\"name=\\\"\").add(ri.getKeyName()).add('\\\"');\n+\t\t\t\tcw.add(ri.getKeyName()).add('\\\"');\n \t\t\t}\n+\t\t\tcw.add(\" parent=\\\"\");\n \t\t\tif (ri.getParentRef() != 0) {\n \t\t\t\tString parent = vp.decodeValue(TYPE_REFERENCE, ri.getParentRef());\n-\t\t\t\tcw.add(\" parent=\\\"\").add(parent).add('\\\"');\n+\t\t\t\tcw.add(parent);\n \t\t\t}\n-\t\t\tcw.add(\">\");\n+\t\t\tcw.add(\"\\\">\");\n \n \t\t\tcw.incIndent();\n \t\t\tfor (RawNamedValue value : ri.getNamedValues()) {",
    "output": "Fix set empty parent for styles without a parent, remove duplicated code"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n@@ -211,7 +211,7 @@ public void updateAttributes(IResParser parser) {\n \t\t\t\tMAttrType attrTyp;\n \t\t\t\tif (first.getRawValue().getData() == ValuesParser.ATTR_TYPE_FLAGS) {\n \t\t\t\t\tattrTyp = MAttrType.FLAG;\n-\t\t\t\t} else if (first.getRawValue().getData() == ValuesParser.ATTR_TYPE_ENUM) {\n+\t\t\t\t} else if (first.getRawValue().getData() == ValuesParser.ATTR_TYPE_ENUM || first.getRawValue().getData() == 65600) {\n \t\t\t\t\tattrTyp = MAttrType.ENUM;\n \t\t\t\t} else {\n \t\t\t\t\tcontinue;",
    "output": "Fix resolve declare-styleable atrributes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -43,6 +43,7 @@\n import jadx.core.utils.android.AndroidResourcesUtils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.core.xmlgen.IResParser;\n+import jadx.core.xmlgen.ManifestAttributes;\n import jadx.core.xmlgen.ResDecoder;\n import jadx.core.xmlgen.ResourceStorage;\n import jadx.core.xmlgen.entry.ResourceEntry;\n@@ -174,12 +175,18 @@ public void loadResources(List<ResourceFile> resources) {\n \t\t\tif (parser != null) {\n \t\t\t\tprocessResources(parser.getResStorage());\n \t\t\t\tupdateObfuscatedFiles(parser, resources);\n+\t\t\t\tupdateManifestAttribMap(parser);\n \t\t\t}\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Failed to parse '.arsc' file\", e);\n \t\t}\n \t}\n \n+\tprivate void updateManifestAttribMap(IResParser parser) {\n+\t\tManifestAttributes manifestAttributes = ManifestAttributes.getInstance();\n+\t\tmanifestAttributes.updateAttributes(parser);\n+\t}\n+\n \tprivate @Nullable ResourceFile getResourceFile(List<ResourceFile> resources) {\n \t\tfor (ResourceFile rf : resources) {\n \t\t\tif (rf.getType() == ResourceType.ARSC) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n@@ -17,6 +17,9 @@\n import org.w3c.dom.NodeList;\n \n import jadx.core.utils.exceptions.JadxRuntimeException;\n+import jadx.core.xmlgen.entry.RawNamedValue;\n+import jadx.core.xmlgen.entry.ResourceEntry;\n+import jadx.core.xmlgen.entry.ValuesParser;\n \n public class ManifestAttributes {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ManifestAttributes.class);\n@@ -52,6 +55,8 @@ public String toString() {\n \n \tprivate final Map<String, MAttr> attrMap = new HashMap<>();\n \n+\tprivate final Map<String, MAttr> appAttrMap = new HashMap<>();\n+\n \tprivate static ManifestAttributes instance;\n \n \tpublic static ManifestAttributes getInstance() {\n@@ -168,7 +173,10 @@ private void parseValues(String name, NodeList nodeList) {\n \tpublic String decode(String attrName, long value) {\n \t\tMAttr attr = attrMap.get(attrName);\n \t\tif (attr == null) {\n-\t\t\treturn null;\n+\t\t\tattr = appAttrMap.get(attrName);\n+\t\t\tif (attr == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n \t\t}\n \t\tif (attr.getType() == MAttrType.ENUM) {\n \t\t\treturn attr.getValues().get(value);\n@@ -190,4 +198,32 @@ public String decode(String attrName, long value) {\n \t\t}\n \t\treturn null;\n \t}\n+\n+\tpublic void updateAttributes(IResParser parser) {\n+\t\tappAttrMap.clear();\n+\n+\t\tResourceStorage resStorage = parser.getResStorage();\n+\t\tValuesParser vp = new ValuesParser(parser.getStrings(), resStorage.getResourcesNames());\n+\n+\t\tfor (ResourceEntry ri : resStorage.getResources()) {\n+\t\t\tif (ri.getTypeName().equals(\"attr\") && ri.getNamedValues().size() > 1) {\n+\t\t\t\tRawNamedValue first = ri.getNamedValues().get(0);\n+\t\t\t\tMAttrType attrTyp;\n+\t\t\t\tif (first.getRawValue().getData() == ValuesParser.ATTR_TYPE_FLAGS) {\n+\t\t\t\t\tattrTyp = MAttrType.FLAG;\n+\t\t\t\t} else if (first.getRawValue().getData() == ValuesParser.ATTR_TYPE_ENUM) {\n+\t\t\t\t\tattrTyp = MAttrType.ENUM;\n+\t\t\t\t} else {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tMAttr attr = new MAttr(attrTyp);\n+\t\t\t\tfor (int i = 1; i < ri.getNamedValues().size(); i++) {\n+\t\t\t\t\tRawNamedValue rv = ri.getNamedValues().get(i);\n+\t\t\t\t\tString value = vp.decodeNameRef(rv.getNameRef());\n+\t\t\t\t\tattr.getValues().put((long) rv.getRawValue().getData(), value.startsWith(\"id.\") ? value.substring(3) : value);\n+\t\t\t\t}\n+\t\t\t\tappAttrMap.put(ri.getKeyName(), attr);\n+\t\t\t}\n+\t\t}\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n@@ -177,7 +177,7 @@ private void addItem(ICodeWriter cw, String itemTag, String typeName, RawNamedVa\n \t\t\tif (dataType == ParserConstants.TYPE_INT_DEC && nameStr != null) {\n \t\t\t\ttry {\n \t\t\t\t\tint intVal = Integer.parseInt(valueStr);\n-\t\t\t\t\tString newVal = ManifestAttributes.getInstance().decode(nameStr.replace(\"android:attr.\", \"\"), intVal);\n+\t\t\t\t\tString newVal = ManifestAttributes.getInstance().decode(nameStr.replace(\"android:\", \"\").replace(\"attr.\", \"\"), intVal);\n \t\t\t\t\tif (newVal != null) {\n \t\t\t\t\t\tvalueStr = newVal;\n \t\t\t\t\t}\n@@ -188,7 +188,7 @@ private void addItem(ICodeWriter cw, String itemTag, String typeName, RawNamedVa\n \t\t\tif (dataType == ParserConstants.TYPE_INT_HEX && nameStr != null) {\n \t\t\t\ttry {\n \t\t\t\t\tint intVal = Integer.decode(valueStr);\n-\t\t\t\t\tString newVal = ManifestAttributes.getInstance().decode(nameStr.replace(\"android:attr.\", \"\"), intVal);\n+\t\t\t\t\tString newVal = ManifestAttributes.getInstance().decode(nameStr.replace(\"android:\", \"\").replace(\"attr.\", \"\"), intVal);\n \t\t\t\t\tif (newVal != null) {\n \t\t\t\t\t\tvalueStr = newVal;\n \t\t\t\t\t}",
    "output": "Fix resolve custom attributes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n@@ -185,6 +185,17 @@ private void addItem(ICodeWriter cw, String itemTag, String typeName, RawNamedVa\n \t\t\t\t\t// ignore\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif (dataType == ParserConstants.TYPE_INT_HEX && nameStr != null) {\n+\t\t\t\ttry {\n+\t\t\t\t\tint intVal = Integer.decode(valueStr);\n+\t\t\t\t\tString newVal = ManifestAttributes.getInstance().decode(nameStr.replace(\"android:attr.\", \"\"), intVal);\n+\t\t\t\t\tif (newVal != null) {\n+\t\t\t\t\t\tvalueStr = newVal;\n+\t\t\t\t\t}\n+\t\t\t\t} catch (NumberFormatException e) {\n+\t\t\t\t\t// ignore\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\tswitch (typeName) {\n \t\t\tcase \"attr\":",
    "output": "Fix resolve int hex attributes"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n@@ -17,6 +17,7 @@\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.List;\n+import java.util.Objects;\n \n import javax.swing.AbstractAction;\n import javax.swing.BorderFactory;\n@@ -44,6 +45,10 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.api.JavaClass;\n+import jadx.api.metadata.ICodeAnnotation;\n+import jadx.api.metadata.annotations.NodeDeclareRef;\n+import jadx.gui.treemodel.JClass;\n import jadx.gui.treemodel.JNode;\n import jadx.gui.treemodel.JResSearchNode;\n import jadx.gui.ui.MainWindow;\n@@ -142,13 +147,45 @@ protected void openItem(JNode node) {\n \t\t\tJumpPosition jmpPos = new JumpPosition(((JResSearchNode) node).getResNode(), node.getPos());\n \t\t\ttabbedPane.codeJump(jmpPos);\n \t\t} else {\n-\t\t\ttabbedPane.codeJump(node);\n+\t\t\tif (!checkForRedirects(node)) {\n+\t\t\t\ttabbedPane.codeJump(node);\n+\t\t\t}\n \t\t}\n \t\tif (!mainWindow.getSettings().getKeepCommonDialogOpen()) {\n \t\t\tdispose();\n \t\t}\n \t}\n \n+\t// TODO: temp solution, move implementation into corresponding nodes\n+\tprivate boolean checkForRedirects(JNode node) {\n+\t\tif (node instanceof JClass) {\n+\t\t\tJavaClass cls = ((JClass) node).getCls();\n+\t\t\tJavaClass origTopCls = cls.getOriginalTopParentClass();\n+\t\t\tJavaClass codeParent = cls.getTopParentClass();\n+\t\t\tif (Objects.equals(codeParent, origTopCls)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tJClass jumpCls = mainWindow.getCacheObject().getNodeCache().makeFrom(codeParent);\n+\t\t\tmainWindow.getBackgroundExecutor().execute(\n+\t\t\t\t\tNLS.str(\"progress.load\"),\n+\t\t\t\t\tjumpCls::loadNode, // load code in background\n+\t\t\t\t\tstatus -> {\n+\t\t\t\t\t\t// search original node in jump class\n+\t\t\t\t\t\tcodeParent.getCodeInfo().getCodeMetadata().searchDown(0, (pos, ann) -> {\n+\t\t\t\t\t\t\tif (ann.getAnnType() == ICodeAnnotation.AnnType.DECLARATION) {\n+\t\t\t\t\t\t\t\tif (((NodeDeclareRef) ann).getNode().equals(cls.getClassNode())) {\n+\t\t\t\t\t\t\t\t\ttabbedPane.codeJump(new JumpPosition(jumpCls, pos));\n+\t\t\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \t@Nullable\n \tprivate JNode getSelectedNode() {\n \t\ttry {",
    "output": "Fix redirect jump from search for inlined classes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -4,7 +4,9 @@\n import java.io.InputStream;\n import java.util.ArrayList;\n import java.util.HashSet;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n import java.util.regex.Matcher;\n@@ -174,8 +176,8 @@ private PackageChunk parsePackage() throws IOException {\n \t\t\t\t\tthrow new IOException(\n \t\t\t\t\t\t\tString.format(\"Encountered unsupported chunk type RES_TABLE_TYPE_OVERLAY_POLICY at offset 0x%x \", chunkStart));\n \t\t\t\tcase RES_TABLE_TYPE_STAGED_ALIAS: // 0x0206\n-\t\t\t\t\tthrow new IOException(\n-\t\t\t\t\t\t\tString.format(\"Encountered unsupported chunk type TYPE_STAGED_ALIAS at offset 0x%x \", chunkStart));\n+\t\t\t\t\tparseStagedAliasChunk(chunkStart);\n+\t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tLOG.warn(\"Unknown chunk type {} encountered at offset {}\", type, chunkStart);\n \t\t\t}\n@@ -245,16 +247,27 @@ private void parseLibraryTypeChunk(long chunkStart) throws IOException {\n \t\t}\n \t}\n \n+\t/**\n+\t * Parse an <code>ResTable_type</code> (except for the 2 bytes <code>uint16_t</code>\n+\t * from <code>ResChunk_header</code>).\n+\t *\n+\t * @see <a href=\n+\t *      \"https://github.com/aosp-mirror/platform_frameworks_base/blob/master/libs/androidfw/include/androidfw/ResourceTypes.h\"></a>ResourceTypes.h</a>\n+\t */\n \tprivate void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t\t/* int headerSize = */\n \t\tis.readInt16();\n \t\t/* int size = */\n \t\tlong chunkSize = is.readUInt32();\n \t\tlong chunkEnd = start + chunkSize;\n \n+\t\t// The type identifier this chunk is holding. Type IDs start at 1 (corresponding\n+\t\t// to the value of the type bits in a resource identifier). 0 is invalid.\n \t\tint id = is.readInt8();\n-\t\tis.checkInt8(0, \"type chunk, res0\");\n-\t\tis.checkInt16(0, \"type chunk, res1\");\n+\t\tint flags = is.readInt8(); // 0 or 1\n+\t\tboolean flagSparse = (flags == 1);\n+\n+\t\tis.checkInt16(0, \"type chunk, reserved\");\n \t\tint entryCount = is.readInt32();\n \t\tlong entriesStart = start + is.readInt32();\n \n@@ -265,21 +278,30 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t\t\tLOG.warn(\"Invalid config flags detected: {}{}\", typeName, config.getQualifiers());\n \t\t}\n \n-\t\tint[] entryIndexes = new int[entryCount];\n-\t\tfor (int i = 0; i < entryCount; i++) {\n-\t\t\tentryIndexes[i] = is.readInt32();\n+\t\tMap<Integer, Integer> entryOffsetMap = new LinkedHashMap<>(entryCount);\n+\t\tif (flagSparse) {\n+\t\t\tfor (int i = 0; i < entryCount; i++) {\n+\t\t\t\tentryOffsetMap.put(is.readInt16(), is.readInt16());\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor (int i = 0; i < entryCount; i++) {\n+\t\t\t\tentryOffsetMap.put(i, is.readInt32());\n+\t\t\t}\n \t\t}\n \t\tis.checkPos(entriesStart, \"Expected entry start\");\n-\t\tfor (int i = 0; i < entryCount; i++) {\n-\t\t\tif (entryIndexes[i] != NO_ENTRY) {\n+\t\tint processed = 0;\n+\t\tfor (int index : entryOffsetMap.keySet()) {\n+\t\t\tint offset = entryOffsetMap.get(index);\n+\t\t\tif (offset != NO_ENTRY) {\n \t\t\t\tif (is.getPos() >= chunkEnd) {\n \t\t\t\t\t// Certain resource obfuscated apps like com.facebook.orca have more entries defined\n \t\t\t\t\t// than actually fit into the chunk size -> ignore the remaining entries\n-\t\t\t\t\tLOG.warn(\"End of chunk reached - ignoring remaining {} entries\", entryCount - i);\n+\t\t\t\t\tLOG.warn(\"End of chunk reached - ignoring remaining {} entries\", entryCount - processed);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n-\t\t\t\tparseEntry(pkg, id, i, config.getQualifiers());\n+\t\t\t\tparseEntry(pkg, id, index, config.getQualifiers());\n \t\t\t}\n+\t\t\tprocessed++;\n \t\t}\n \t\tif (chunkEnd > is.getPos()) {\n \t\t\t// Skip remaining unknown data in this chunk (e.g. type 8 entries\")\n@@ -292,16 +314,34 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \n \tprivate void parseOverlayTypeChunk(long chunkStart) throws IOException {\n \t\tLOG.trace(\"parsing overlay type chunk starting at offset {}\", chunkStart);\n-\t\tint headerSize = is.readInt16(); // usually 1032 bytes\n+\t\t// read ResTable_overlayable_header\n+\t\t/* headerSize = */ is.readInt16(); // usually 1032 bytes\n \t\tint chunkSize = is.readInt32(); // e.g. 1056 bytes\n \t\tlong expectedEndPos = chunkStart + chunkSize;\n-\t\tString name = is.readString16Fixed(128); // 256 bytes\n-\t\tString actor = is.readString16Fixed(128); // 256 bytes\n+\t\tString name = is.readString16Fixed(256); // 512 bytes\n+\t\tString actor = is.readString16Fixed(256); // 512 bytes\n \t\tLOG.trace(\"Overlay header data: name={} actor={}\", name, actor);\n-\t\t// the other data in the chunk header and body is unknown\n+\t\t// skip: ResTable_overlayable_policy_header + ResTable_ref * x\n \t\tis.skipToPos(expectedEndPos, \"overlay chunk end\");\n \t}\n \n+\tprivate void parseStagedAliasChunk(long chunkStart) throws IOException {\n+\t\t// read ResTable_staged_alias_header\n+\t\tLOG.trace(\"parsing staged alias chunk starting at offset {}\", chunkStart);\n+\t\t/* headerSize = */ is.readInt16();\n+\t\tint chunkSize = is.readInt32();\n+\t\tlong expectedEndPos = chunkStart + chunkSize;\n+\t\tint count = is.readInt32();\n+\n+\t\tfor (int i = 0; i < count; i++) {\n+\t\t\t// read ResTable_staged_alias_entry\n+\t\t\tint stagedResId = is.readInt32();\n+\t\t\tint finalizedResId = is.readInt32();\n+\t\t\tLOG.debug(\"Staged alias: stagedResId {} finalizedResId {}\", stagedResId, finalizedResId);\n+\t\t}\n+\t\tis.skipToPos(expectedEndPos, \"staged alias chunk end\");\n+\t}\n+\n \tprivate void parseEntry(PackageChunk pkg, int typeId, int entryId, String config) throws IOException {\n \t\tint size = is.readInt16();\n \t\tint flags = is.readInt16();",
    "output": "Fix parsing of sparse RES_TABLE_TYPE_TYPE and RES_TABLE_TYPE_STAGED_ALIAS chunks (#1806 #1803)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n@@ -33,7 +33,8 @@ protected ParserConstants() {\n \tprotected static final int RES_TABLE_TYPE_SPEC_TYPE = 0x0202; // 514\n \tprotected static final int RES_TABLE_TYPE_LIBRARY = 0x0203; // 515\n \tprotected static final int RES_TABLE_TYPE_OVERLAY = 0x0204; // 516\n-\tprotected static final int RES_TABLE_TYPE_STAGED_ALIAS = 0x0206; // 517\n+\tprotected static final int RES_TABLE_TYPE_OVERLAY_POLICY = 0x0205; // 517\n+\tprotected static final int RES_TABLE_TYPE_STAGED_ALIAS = 0x0206; // 518\n \n \t/**\n \t * Type constants\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -168,8 +168,11 @@ private PackageChunk parsePackage() throws IOException {\n \t\t\t\t\tparseLibraryTypeChunk(chunkStart);\n \t\t\t\t\tbreak;\n \t\t\t\tcase RES_TABLE_TYPE_OVERLAY: // 0x0204\n+\t\t\t\t\tparseOverlayTypeChunk(chunkStart);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase RES_TABLE_TYPE_OVERLAY_POLICY: // 0x0205\n \t\t\t\t\tthrow new IOException(\n-\t\t\t\t\t\t\tString.format(\"Encountered unsupported chunk type TYPE_OVERLAY at offset 0x%x \", chunkStart));\n+\t\t\t\t\t\t\tString.format(\"Encountered unsupported chunk type RES_TABLE_TYPE_OVERLAY_POLICY at offset 0x%x \", chunkStart));\n \t\t\t\tcase RES_TABLE_TYPE_STAGED_ALIAS: // 0x0206\n \t\t\t\t\tthrow new IOException(\n \t\t\t\t\t\t\tString.format(\"Encountered unsupported chunk type TYPE_STAGED_ALIAS at offset 0x%x \", chunkStart));\n@@ -287,6 +290,18 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t\t}\n \t}\n \n+\tprivate void parseOverlayTypeChunk(long chunkStart) throws IOException {\n+\t\tLOG.trace(\"parsing overlay type chunk starting at offset {}\", chunkStart);\n+\t\tint headerSize = is.readInt16(); // usually 1032 bytes\n+\t\tint chunkSize = is.readInt32(); // e.g. 1056 bytes\n+\t\tlong expectedEndPos = chunkStart + chunkSize;\n+\t\tString name = is.readString16Fixed(128); // 256 bytes\n+\t\tString actor = is.readString16Fixed(128); // 256 bytes\n+\t\tLOG.trace(\"Overlay header data: name={} actor={}\", name, actor);\n+\t\t// the other data in the chunk header and body is unknown\n+\t\tis.skipToPos(expectedEndPos, \"overlay chunk end\");\n+\t}\n+\n \tprivate void parseEntry(PackageChunk pkg, int typeId, int entryId, String config) throws IOException {\n \t\tint size = is.readInt16();\n \t\tint flags = is.readInt16();",
    "output": "Fix handle RES_TABLE_TYPE_OVERLAY"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -13,8 +13,6 @@\n \n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import jadx.api.DecompilationMode;\n import jadx.api.ICodeCache;\n@@ -56,8 +54,6 @@\n import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;\n \n public class ClassNode extends NotificationAttrNode implements ILoadable, ICodeNode, Comparable<ClassNode> {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(ClassNode.class);\n-\n \tprivate final RootNode root;\n \tprivate final IClassData clsData;\n \n@@ -174,10 +170,10 @@ private ArgType checkSuperType(IClassData cls) {\n \t\treturn ArgType.object(superType);\n \t}\n \n-\tpublic void updateGenericClsData(ArgType superClass, List<ArgType> interfaces, List<ArgType> generics) {\n+\tpublic void updateGenericClsData(List<ArgType> generics, ArgType superClass, List<ArgType> interfaces) {\n+\t\tthis.generics = generics;\n \t\tthis.superClass = superClass;\n \t\tthis.interfaces = interfaces;\n-\t\tthis.generics = generics;\n \t}\n \n \tprivate static void processAttributes(ClassNode cls) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n@@ -2,8 +2,12 @@\n \n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Objects;\n+import java.util.Set;\n+\n+import org.jetbrains.annotations.Nullable;\n \n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.instructions.args.ArgType;\n@@ -18,7 +22,6 @@\n import jadx.core.utils.exceptions.JadxException;\n \n public class SignatureProcessor extends AbstractVisitor {\n-\n \tprivate RootNode root;\n \n \t@Override\n@@ -55,12 +58,54 @@ private void parseClassSignature(ClassNode cls) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcls.updateGenericClsData(superClass, interfaces, generics);\n+\t\t\tgenerics = fixTypeParamDeclarations(cls, generics, superClass, interfaces);\n+\t\t\tcls.updateGenericClsData(generics, superClass, interfaces);\n \t\t} catch (Exception e) {\n \t\t\tcls.addWarnComment(\"Failed to parse class signature: \" + sp.getSignature(), e);\n \t\t}\n \t}\n \n+\t/**\n+\t * Add missing type parameters from super type and interfaces to make code compilable\n+\t */\n+\tprivate static List<ArgType> fixTypeParamDeclarations(ClassNode cls,\n+\t\t\tList<ArgType> generics, ArgType superClass, List<ArgType> interfaces) {\n+\t\tif (interfaces.isEmpty() && superClass.equals(ArgType.OBJECT)) {\n+\t\t\treturn generics;\n+\t\t}\n+\t\tSet<String> typeParams = new HashSet<>();\n+\t\tsuperClass.visitTypes(t -> addGenericType(typeParams, t));\n+\t\tinterfaces.forEach(i -> i.visitTypes(t -> addGenericType(typeParams, t)));\n+\t\tif (typeParams.isEmpty()) {\n+\t\t\treturn generics;\n+\t\t}\n+\t\tList<ArgType> knownTypeParams;\n+\t\tif (cls.isInner()) {\n+\t\t\tknownTypeParams = new ArrayList<>(generics);\n+\t\t\tcls.visitParentClasses(p -> knownTypeParams.addAll(p.getGenericTypeParameters()));\n+\t\t} else {\n+\t\t\tknownTypeParams = generics;\n+\t\t}\n+\t\tfor (ArgType declTypeParam : knownTypeParams) {\n+\t\t\ttypeParams.remove(declTypeParam.getObject());\n+\t\t}\n+\t\tif (typeParams.isEmpty()) {\n+\t\t\treturn generics;\n+\t\t}\n+\t\tcls.addInfoComment(\"Add missing generic type declarations: \" + typeParams);\n+\t\tList<ArgType> fixedGenerics = new ArrayList<>(generics.size() + typeParams.size());\n+\t\tfixedGenerics.addAll(generics);\n+\t\ttypeParams.stream().sorted().map(ArgType::genericType).forEach(fixedGenerics::add);\n+\t\treturn fixedGenerics;\n+\t}\n+\n+\tprivate static @Nullable Object addGenericType(Set<String> usedTypeParameters, ArgType t) {\n+\t\tif (t.isGenericType()) {\n+\t\t\tusedTypeParameters.add(t.getObject());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \tprivate ArgType validateClsType(ClassNode cls, ArgType candidateType, ArgType currentType) {\n \t\tif (!candidateType.isObject()) {\n \t\t\tcls.addWarnComment(\"Incorrect class signature, class is not object: \" + SignatureParser.getSignature(cls));\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n@@ -224,6 +224,11 @@ public List<ClassNode> decompileFiles(List<File> files) {\n \t\treturn sortedClsNodes;\n \t}\n \n+\t@NotNull\n+\tpublic ClassNode searchTestCls(List<ClassNode> list, String shortClsName) {\n+\t\treturn searchCls(list, getTestPkg() + '.' + shortClsName);\n+\t}\n+\n \t@NotNull\n \tpublic ClassNode searchCls(List<ClassNode> list, String clsName) {\n \t\tfor (ClassNode cls : list) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inline/TestInstanceLambda.java b/jadx-core/src/test/java/jadx/tests/integration/inline/TestInstanceLambda.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inline/TestInstanceLambda.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inline/TestInstanceLambda.java\n@@ -0,0 +1,72 @@\n+package jadx.tests.integration.inline;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.NotYetImplemented;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestInstanceLambda extends SmaliTest {\n+\n+\t@SuppressWarnings({ \"unchecked\", \"rawtypes\", \"SameParameterValue\" })\n+\tpublic static class TestCls {\n+\n+\t\tpublic <T> Map<T, T> test(List<? extends T> list) {\n+\t\t\treturn toMap(list, Lambda.INSTANCE);\n+\t\t}\n+\n+\t\t/**\n+\t\t * Smali test missing 'T' definition in 'Lambda<T>'\n+\t\t */\n+\t\tprivate static class Lambda<T> implements Function<T, T> {\n+\t\t\tpublic static final Lambda INSTANCE = new Lambda();\n+\n+\t\t\t@Override\n+\t\t\tpublic T apply(T t) {\n+\t\t\t\treturn t;\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate static <T> Map<T, T> toMap(List<? extends T> list, Function<T, T> valueMap) {\n+\t\t\treturn list.stream().collect(Collectors.toMap(k -> k, valueMap));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code();\n+\t}\n+\n+\t@Test\n+\tpublic void testSmaliDisableInline() {\n+\t\targs.setInlineAnonymousClasses(false);\n+\t\tList<ClassNode> classNodes = loadFromSmaliFiles();\n+\t\tassertThat(searchTestCls(classNodes, \"Lambda\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"class Lambda<T> implements Function<T, T> {\");\n+\t\tassertThat(searchTestCls(classNodes, \"TestCls\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"Lambda.INSTANCE\");\n+\t}\n+\n+\t@NotYetImplemented(\"Inline lambda by instance field\")\n+\t@Test\n+\tpublic void testSmali() {\n+\t\tList<ClassNode> classNodes = loadFromSmaliFiles();\n+\t\tassertThat(classNodes)\n+\t\t\t\t.describedAs(\"Expect lambda to be inlined\")\n+\t\t\t\t.hasSize(1);\n+\t\tassertThat(searchTestCls(classNodes, \"TestCls\"))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"Lambda.INSTANCE\");\n+\t}\n+}",
    "output": "Fix restore missing type parameter declarations"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/device/debugger/DebugController.java b/jadx-gui/src/main/java/jadx/gui/device/debugger/DebugController.java\n--- a/jadx-gui/src/main/java/jadx/gui/device/debugger/DebugController.java\n+++ b/jadx-gui/src/main/java/jadx/gui/device/debugger/DebugController.java\n@@ -14,12 +14,10 @@\n import javax.swing.JOptionPane;\n import javax.swing.tree.DefaultMutableTreeNode;\n \n+import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import io.reactivex.annotations.NonNull;\n-import io.reactivex.annotations.Nullable;\n-\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.nodes.ClassNode;\n@@ -42,6 +40,7 @@\n import jadx.gui.ui.panel.JDebuggerPanel.IListElement;\n import jadx.gui.ui.panel.JDebuggerPanel.ValueTreeNode;\n import jadx.gui.utils.NLS;\n+import jadx.gui.utils.UiUtils;\n \n public final class DebugController implements SmaliDebugger.SuspendListener, IDebugController {\n \n@@ -78,7 +77,7 @@ public boolean startDebugger(JDebuggerPanel debuggerPanel, String adbHost, int a\n \t\t\tinitTypeMap();\n \t\t}\n \t\tthis.debuggerPanel = debuggerPanel;\n-\t\tdebuggerPanel.resetUI();\n+\t\tUiUtils.uiRunAndWait(debuggerPanel::resetUI);\n \t\ttry {\n \t\t\tdebugger = SmaliDebugger.attach(adbHost, adbPort, this);\n \t\t} catch (SmaliDebuggerException e) {\n@@ -251,7 +250,6 @@ private RuntimeType castType(ArgType type) {\n \t\tthrow new JadxRuntimeException(\"Unexpected type: \" + type);\n \t}\n \n-\t@NonNull\n \tprotected static RuntimeType castType(String type) {\n \t\tRuntimeType rt = null;\n \t\tif (!StringUtils.isEmpty(type)) {\n@@ -663,22 +661,22 @@ private void updateAllFieldValues(long thisID, FrameNode frame) {\n \t}\n \n \tprivate void updateAllRegisters(FrameNode frame) {\n-\t\tif (buildRegTreeNodes(frame).size() > 0) {\n-\t\t\tfetchAllRegisters(frame);\n-\t\t}\n+\t\tUiUtils.uiRun(() -> {\n+\t\t\tif (!buildRegTreeNodes(frame).isEmpty()) {\n+\t\t\t\tfetchAllRegisters(frame);\n+\t\t\t}\n+\t\t});\n \t}\n \n \tprivate void fetchAllRegisters(FrameNode frame) {\n \t\tList<SmaliRegister> regs = cur.regAdapter.getInitializedList(frame.getCodeOffset());\n \t\tfor (SmaliRegister reg : regs) {\n-\t\t\tlazyQueue.execute(() -> {\n-\t\t\t\tEntry<String, String> info = cur.regAdapter.getInfo(reg.getRuntimeRegNum(), frame.getCodeOffset());\n-\t\t\t\tRegTreeNode regNode = frame.getRegNodes().get(reg.getRegNum());\n-\t\t\t\tif (info != null) {\n-\t\t\t\t\tapplyDbgInfo(regNode, info);\n-\t\t\t\t}\n-\t\t\t\tupdateRegister(regNode, null, true);\n-\t\t\t});\n+\t\t\tEntry<String, String> info = cur.regAdapter.getInfo(reg.getRuntimeRegNum(), frame.getCodeOffset());\n+\t\t\tRegTreeNode regNode = frame.getRegNodes().get(reg.getRegNum());\n+\t\t\tif (info != null) {\n+\t\t\t\tapplyDbgInfo(regNode, info);\n+\t\t\t}\n+\t\t\tupdateRegister(regNode, null, true);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/ADBDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/ADBDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/ADBDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/ADBDialog.java\n@@ -475,28 +475,28 @@ public void jdwpProcessOccurred(ADBDevice device, Set<String> id) {\n \t\t\tLOG.error(\"Failed to find device\", e);\n \t\t\treturn;\n \t\t}\n-\t\tnode.tNode.removeAllChildren();\n-\t\tDefaultMutableTreeNode tempNode = null;\n-\t\tfor (String s : procList) {\n-\t\t\tDefaultMutableTreeNode pnode = new DefaultMutableTreeNode(s);\n-\t\t\tnode.tNode.add(pnode);\n-\t\t\tif (!debugSetter.expectPkg.isEmpty() && s.endsWith(debugSetter.expectPkg)) {\n-\t\t\t\tif (debugSetter.autoAttachPkg && debugSetter.device.equals(node.device)) {\n-\t\t\t\t\tdebugSetter.set(node.device, debugSetter.ver, getPid(s), s);\n-\t\t\t\t\tif (attachProcess(mainWindow)) {\n-\t\t\t\t\t\tdispose();\n-\t\t\t\t\t\treturn;\n+\n+\t\tSwingUtilities.invokeLater(() -> {\n+\t\t\tnode.tNode.removeAllChildren();\n+\t\t\tDefaultMutableTreeNode foundNode = null;\n+\t\t\tfor (String procStr : procList) {\n+\t\t\t\tDefaultMutableTreeNode pnode = new DefaultMutableTreeNode(procStr);\n+\t\t\t\tnode.tNode.add(pnode);\n+\t\t\t\tif (!debugSetter.expectPkg.isEmpty() && procStr.endsWith(debugSetter.expectPkg)) {\n+\t\t\t\t\tif (debugSetter.autoAttachPkg && debugSetter.device.equals(node.device)) {\n+\t\t\t\t\t\tdebugSetter.set(node.device, debugSetter.ver, getPid(procStr), procStr);\n+\t\t\t\t\t\tif (attachProcess(mainWindow)) {\n+\t\t\t\t\t\t\tdispose();\n+\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\tfoundNode = pnode;\n \t\t\t\t}\n-\t\t\t\ttempNode = pnode;\n \t\t\t}\n-\t\t}\n-\t\tDefaultMutableTreeNode theNode = tempNode;\n-\t\tSwingUtilities.invokeLater(() -> {\n \t\t\tprocTreeModel.reload(node.tNode);\n \t\t\tprocTree.expandPath(new TreePath(node.tNode.getPath()));\n-\t\t\tif (theNode != null) {\n-\t\t\t\tTreePath thePath = new TreePath(theNode.getPath());\n+\t\t\tif (foundNode != null) {\n+\t\t\t\tTreePath thePath = new TreePath(foundNode.getPath());\n \t\t\t\tprocTree.scrollPathToVisible(thePath);\n \t\t\t\tprocTree.setSelectionPath(thePath);\n \t\t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/panel/JDebuggerPanel.java b/jadx-gui/src/main/java/jadx/gui/ui/panel/JDebuggerPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/panel/JDebuggerPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/panel/JDebuggerPanel.java\n@@ -88,6 +88,7 @@ public class JDebuggerPanel extends JPanel {\n \tprivate transient KeyEventDispatcher controllerShortCutDispatcher;\n \n \tpublic JDebuggerPanel(MainWindow mainWindow) {\n+\t\tUiUtils.uiThreadGuard();\n \t\tthis.mainWindow = mainWindow;\n \t\tcontroller = new DebugController();\n \t\tthis.setLayout(new BorderLayout());\n@@ -287,24 +288,26 @@ public void actionPerformed(ActionEvent e) {\n \n \t\t\t@Override\n \t\t\tpublic void onStateChanged(boolean suspended, boolean stopped) {\n-\t\t\t\tif (!stopped) {\n-\t\t\t\t\tif (isGray) {\n-\t\t\t\t\t\tstop.putValue(Action.SMALL_ICON, ICON_STOP);\n+\t\t\t\tUiUtils.uiRun(() -> {\n+\t\t\t\t\tif (!stopped) {\n+\t\t\t\t\t\tif (isGray) {\n+\t\t\t\t\t\t\tstop.putValue(Action.SMALL_ICON, ICON_STOP);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tstop.putValue(Action.SMALL_ICON, ICON_STOP_GRAY);\n+\t\t\t\t\t\trun.putValue(Action.SMALL_ICON, ICON_RUN);\n+\t\t\t\t\t\trun.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"debugger.run\"));\n+\t\t\t\t\t\tisGray = true;\n+\t\t\t\t\t\treturn;\n \t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tstop.putValue(Action.SMALL_ICON, ICON_STOP_GRAY);\n-\t\t\t\t\trun.putValue(Action.SMALL_ICON, ICON_RUN);\n-\t\t\t\t\trun.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"debugger.run\"));\n-\t\t\t\t\tisGray = true;\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tif (suspended) {\n-\t\t\t\t\trun.putValue(Action.SMALL_ICON, ICON_RUN);\n-\t\t\t\t\trun.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"debugger.run\"));\n-\t\t\t\t} else {\n-\t\t\t\t\trun.putValue(Action.SMALL_ICON, ICON_PAUSE);\n-\t\t\t\t\trun.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"debugger.pause\"));\n-\t\t\t\t}\n+\t\t\t\t\tif (suspended) {\n+\t\t\t\t\t\trun.putValue(Action.SMALL_ICON, ICON_RUN);\n+\t\t\t\t\t\trun.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"debugger.run\"));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\trun.putValue(Action.SMALL_ICON, ICON_PAUSE);\n+\t\t\t\t\t\trun.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"debugger.pause\"));\n+\t\t\t\t\t}\n+\t\t\t\t});\n \t\t\t}\n \t\t});\n \n@@ -387,16 +390,18 @@ private void stackFrameSelected(Point p) {\n \tpublic boolean showDebugger(String procName, String host, int port, int androidVer, ADBDevice device, String pid) {\n \t\tboolean ok = controller.startDebugger(this, host, port, androidVer);\n \t\tif (ok) {\n-\t\t\tlog(String.format(\"Attached %s %s:%d\", procName, host, port));\n-\t\t\ttry {\n-\t\t\t\tlogcatPanel.init(device, pid);\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tlog(NLS.str(\"logcat.error_fail_start\"));\n-\t\t\t\tLOG.error(\"Logcat failed to start\", e);\n-\t\t\t}\n-\t\t\tleftSplitter.setDividerLocation(mainWindow.getSettings().getDebuggerStackFrameSplitterLoc());\n-\t\t\trightSplitter.setDividerLocation(mainWindow.getSettings().getDebuggerVarTreeSplitterLoc());\n-\t\t\tmainWindow.showDebuggerPanel();\n+\t\t\tUiUtils.uiRun(() -> {\n+\t\t\t\tlog(String.format(\"Attached %s %s:%d\", procName, host, port));\n+\t\t\t\ttry {\n+\t\t\t\t\tlogcatPanel.init(device, pid);\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tlog(NLS.str(\"logcat.error_fail_start\"));\n+\t\t\t\t\tLOG.error(\"Logcat failed to start\", e);\n+\t\t\t\t}\n+\t\t\t\tleftSplitter.setDividerLocation(mainWindow.getSettings().getDebuggerStackFrameSplitterLoc());\n+\t\t\t\trightSplitter.setDividerLocation(mainWindow.getSettings().getDebuggerVarTreeSplitterLoc());\n+\t\t\t\tmainWindow.showDebuggerPanel();\n+\t\t\t});\n \t\t}\n \t\treturn ok;\n \t}\n@@ -414,6 +419,8 @@ public int getRightSplitterLocation() {\n \t}\n \n \tpublic void loadSettings() {\n+\t\tUiUtils.uiThreadGuard();\n+\n \t\tFont font = mainWindow.getSettings().getFont();\n \t\tvariableTree.setFont(font.deriveFont(font.getSize() + 1.f));\n \t\tvariableTree.setRowHeight(-1);\n@@ -423,6 +430,8 @@ public void loadSettings() {\n \t}\n \n \tpublic void resetUI() {\n+\t\tUiUtils.uiThreadGuard();\n+\n \t\tthisTreeNode.removeAllChildren();\n \t\tregTreeNode.removeAllChildren();\n \n@@ -464,12 +473,11 @@ public void updateThisFieldNodes(List<? extends ValueTreeNode> nodes) {\n \t}\n \n \tpublic void refreshThreadBox(List<? extends IListElement> elements) {\n-\t\tif (elements.size() > 0) {\n-\t\t\tDefaultComboBoxModel<IListElement> model =\n-\t\t\t\t\t(DefaultComboBoxModel<IListElement>) threadBox.getModel();\n-\t\t\telements.forEach(model::addElement);\n-\t\t}\n-\t\tSwingUtilities.invokeLater(() -> {\n+\t\tUiUtils.uiRun(() -> {\n+\t\t\tif (!elements.isEmpty()) {\n+\t\t\t\tDefaultComboBoxModel<IListElement> model = (DefaultComboBoxModel<IListElement>) threadBox.getModel();\n+\t\t\t\telements.forEach(model::addElement);\n+\t\t\t}\n \t\t\tthreadBox.updateUI();\n \t\t\tstackFrameList.setFont(mainWindow.getSettings().getFont());\n \t\t});",
    "output": "Fix process UI updates in correct thread"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java\n@@ -26,7 +26,7 @@ protected String[] parseStringPoolNoType() throws IOException {\n \t\tint[] stringsOffset = is.readInt32Array(stringCount);\n \t\tint[] stylesOffset = is.readInt32Array(styleCount);\n \n-\t\tis.checkPos(start + stringsStart, \"Expected strings start\");\n+\t\tis.skipToPos(start + stringsStart, \"Expected strings start\");\n \t\tString[] strings = new String[stringCount];\n \t\tbyte[] strData = is.readInt8Array((int) (chunkEnd - is.getPos()));\n \t\tif ((flags & UTF8_FLAG) != 0) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java\n@@ -127,6 +127,10 @@ public void checkPos(long expectedOffset, String error) throws IOException {\n \n \tpublic void skipToPos(long expectedOffset, String error) throws IOException {\n \t\tlong pos = getPos();\n+\t\tif (pos > expectedOffset) {\n+\t\t\tthrow new IOException(error + \", expected offset not reachable: 0x\" + Long.toHexString(expectedOffset)\n+\t\t\t\t\t+ \", actual: 0x\" + Long.toHexString(getPos()));\n+\t\t}\n \t\tif (pos < expectedOffset) {\n \t\t\tskip(expectedOffset - pos);\n \t\t}",
    "output": "Fix resolve manifest decoding error `Expected strings start`"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n@@ -7,6 +7,8 @@\n import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n@@ -187,7 +189,7 @@ public class JadxCLIArgs {\n \t@Parameter(\n \t\t\tnames = { \"--log-level\" },\n \t\t\tdescription = \"set log level, values: quiet, progress, error, warn, info, debug\",\n-\t\t\tconverter = LogHelper.LogLevelConverter.class\n+\t\t\tconverter = LogLevelConverter.class\n \t)\n \tprotected LogHelper.LogLevelEnum logLevel = LogHelper.LogLevelEnum.PROGRESS;\n \n@@ -487,67 +489,58 @@ public Set<RenameEnum> convert(String value) {\n \t\t}\n \t}\n \n-\tpublic static class CommentsLevelConverter implements IStringConverter<CommentsLevel> {\n-\t\t@Override\n-\t\tpublic CommentsLevel convert(String value) {\n-\t\t\ttry {\n-\t\t\t\treturn CommentsLevel.valueOf(stringAsEnumName(value));\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t'\\'' + value + \"' is unknown comments level, possible values are: \"\n-\t\t\t\t\t\t\t\t+ JadxCLIArgs.enumValuesString(CommentsLevel.values()));\n-\t\t\t}\n+\tpublic static class CommentsLevelConverter extends BaseEnumConverter<CommentsLevel> {\n+\t\tpublic CommentsLevelConverter() {\n+\t\t\tsuper(CommentsLevel::valueOf, CommentsLevel::values);\n \t\t}\n \t}\n \n-\tpublic static class UseKotlinMethodsForVarNamesConverter implements IStringConverter<UseKotlinMethodsForVarNames> {\n-\t\t@Override\n-\t\tpublic UseKotlinMethodsForVarNames convert(String value) {\n-\t\t\ttry {\n-\t\t\t\treturn UseKotlinMethodsForVarNames.valueOf(stringAsEnumName(value));\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t'\\'' + value + \"' is unknown, possible values are: \"\n-\t\t\t\t\t\t\t\t+ JadxCLIArgs.enumValuesString(CommentsLevel.values()));\n-\t\t\t}\n+\tpublic static class UseKotlinMethodsForVarNamesConverter extends BaseEnumConverter<UseKotlinMethodsForVarNames> {\n+\t\tpublic UseKotlinMethodsForVarNamesConverter() {\n+\t\t\tsuper(UseKotlinMethodsForVarNames::valueOf, UseKotlinMethodsForVarNames::values);\n \t\t}\n \t}\n \n-\tpublic static class DeobfuscationMapFileModeConverter implements IStringConverter<DeobfuscationMapFileMode> {\n-\t\t@Override\n-\t\tpublic DeobfuscationMapFileMode convert(String value) {\n-\t\t\ttry {\n-\t\t\t\treturn DeobfuscationMapFileMode.valueOf(stringAsEnumName(value));\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t'\\'' + value + \"' is unknown, possible values are: \"\n-\t\t\t\t\t\t\t\t+ JadxCLIArgs.enumValuesString(DeobfuscationMapFileMode.values()));\n-\t\t\t}\n+\tpublic static class DeobfuscationMapFileModeConverter extends BaseEnumConverter<DeobfuscationMapFileMode> {\n+\t\tpublic DeobfuscationMapFileModeConverter() {\n+\t\t\tsuper(DeobfuscationMapFileMode::valueOf, DeobfuscationMapFileMode::values);\n \t\t}\n \t}\n \n-\tpublic static class ResourceNameSourceConverter implements IStringConverter<ResourceNameSource> {\n-\t\t@Override\n-\t\tpublic ResourceNameSource convert(String value) {\n-\t\t\ttry {\n-\t\t\t\treturn ResourceNameSource.valueOf(stringAsEnumName(value));\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t'\\'' + value + \"' is unknown, possible values are: \"\n-\t\t\t\t\t\t\t\t+ JadxCLIArgs.enumValuesString(ResourceNameSource.values()));\n-\t\t\t}\n+\tpublic static class ResourceNameSourceConverter extends BaseEnumConverter<ResourceNameSource> {\n+\t\tpublic ResourceNameSourceConverter() {\n+\t\t\tsuper(ResourceNameSource::valueOf, ResourceNameSource::values);\n+\t\t}\n+\t}\n+\n+\tpublic static class DecompilationModeConverter extends BaseEnumConverter<DecompilationMode> {\n+\t\tpublic DecompilationModeConverter() {\n+\t\t\tsuper(DecompilationMode::valueOf, DecompilationMode::values);\n+\t\t}\n+\t}\n+\n+\tpublic static class LogLevelConverter extends BaseEnumConverter<LogHelper.LogLevelEnum> {\n+\t\tpublic LogLevelConverter() {\n+\t\t\tsuper(LogHelper.LogLevelEnum::valueOf, LogHelper.LogLevelEnum::values);\n \t\t}\n \t}\n \n-\tpublic static class DecompilationModeConverter implements IStringConverter<DecompilationMode> {\n+\tpublic abstract static class BaseEnumConverter<E extends Enum<E>> implements IStringConverter<E> {\n+\t\tprivate final Function<String, E> parse;\n+\t\tprivate final Supplier<E[]> values;\n+\n+\t\tpublic BaseEnumConverter(Function<String, E> parse, Supplier<E[]> values) {\n+\t\t\tthis.parse = parse;\n+\t\t\tthis.values = values;\n+\t\t}\n+\n \t\t@Override\n-\t\tpublic DecompilationMode convert(String value) {\n+\t\tpublic E convert(String value) {\n \t\t\ttry {\n-\t\t\t\treturn DecompilationMode.valueOf(stringAsEnumName(value));\n+\t\t\t\treturn parse.apply(stringAsEnumName(value));\n \t\t\t} catch (Exception e) {\n \t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t'\\'' + value + \"' is unknown, possible values are: \"\n-\t\t\t\t\t\t\t\t+ JadxCLIArgs.enumValuesString(DecompilationMode.values()));\n+\t\t\t\t\t\t'\\'' + value + \"' is unknown, possible values are: \" + enumValuesString(values.get()));\n \t\t\t}\n \t\t}\n \t}\n@@ -558,8 +551,8 @@ public static String enumValuesString(Enum<?>[] values) {\n \t\t\t\t.collect(Collectors.joining(\", \"));\n \t}\n \n-\tprivate static String stringAsEnumName(String raw) {\n-        // inverse of enumValuesString conversion\n-\t\treturn value.replace('-', '_').toUpperCase();\n+\tprivate static String stringAsEnumName(String value) {\n+\t\t// inverse of enumValuesString conversion\n+\t\treturn value.replace('-', '_').toUpperCase(Locale.ROOT);\n \t}\n }\n\ndiff --git a/jadx-cli/src/main/java/jadx/cli/LogHelper.java b/jadx-cli/src/main/java/jadx/cli/LogHelper.java\n--- a/jadx-cli/src/main/java/jadx/cli/LogHelper.java\n+++ b/jadx-cli/src/main/java/jadx/cli/LogHelper.java\n@@ -4,8 +4,6 @@\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.LoggerFactory;\n \n-import com.beust.jcommander.IStringConverter;\n-\n import ch.qos.logback.classic.Level;\n import ch.qos.logback.classic.Logger;\n \n@@ -119,18 +117,4 @@ private static boolean isCustomLogConfig() {\n \t\t}\n \t\treturn false;\n \t}\n-\n-\tpublic static class LogLevelConverter implements IStringConverter<LogLevelEnum> {\n-\n-\t\t@Override\n-\t\tpublic LogLevelEnum convert(String value) {\n-\t\t\ttry {\n-\t\t\t\treturn LogLevelEnum.valueOf(value.toUpperCase());\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\t'\\'' + value + \"' is unknown log level, possible values are \"\n-\t\t\t\t\t\t\t\t+ JadxCLIArgs.enumValuesString(LogLevelEnum.values()));\n-\t\t\t}\n-\t\t}\n-\t}\n }",
    "output": "Use common enum args parser"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n@@ -491,7 +491,7 @@ public static class CommentsLevelConverter implements IStringConverter<CommentsL\n \t\t@Override\n \t\tpublic CommentsLevel convert(String value) {\n \t\t\ttry {\n-\t\t\t\treturn CommentsLevel.valueOf(value.toUpperCase());\n+\t\t\t\treturn CommentsLevel.valueOf(stringAsEnumName(value));\n \t\t\t} catch (Exception e) {\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t'\\'' + value + \"' is unknown comments level, possible values are: \"\n@@ -504,7 +504,7 @@ public static class UseKotlinMethodsForVarNamesConverter implements IStringConve\n \t\t@Override\n \t\tpublic UseKotlinMethodsForVarNames convert(String value) {\n \t\t\ttry {\n-\t\t\t\treturn UseKotlinMethodsForVarNames.valueOf(value.replace('-', '_').toUpperCase());\n+\t\t\t\treturn UseKotlinMethodsForVarNames.valueOf(stringAsEnumName(value));\n \t\t\t} catch (Exception e) {\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t'\\'' + value + \"' is unknown, possible values are: \"\n@@ -517,7 +517,7 @@ public static class DeobfuscationMapFileModeConverter implements IStringConverte\n \t\t@Override\n \t\tpublic DeobfuscationMapFileMode convert(String value) {\n \t\t\ttry {\n-\t\t\t\treturn DeobfuscationMapFileMode.valueOf(value.toUpperCase());\n+\t\t\t\treturn DeobfuscationMapFileMode.valueOf(stringAsEnumName(value));\n \t\t\t} catch (Exception e) {\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t'\\'' + value + \"' is unknown, possible values are: \"\n@@ -530,7 +530,7 @@ public static class ResourceNameSourceConverter implements IStringConverter<Reso\n \t\t@Override\n \t\tpublic ResourceNameSource convert(String value) {\n \t\t\ttry {\n-\t\t\t\treturn ResourceNameSource.valueOf(value.toUpperCase());\n+\t\t\t\treturn ResourceNameSource.valueOf(stringAsEnumName(value));\n \t\t\t} catch (Exception e) {\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t'\\'' + value + \"' is unknown, possible values are: \"\n@@ -543,7 +543,7 @@ public static class DecompilationModeConverter implements IStringConverter<Decom\n \t\t@Override\n \t\tpublic DecompilationMode convert(String value) {\n \t\t\ttry {\n-\t\t\t\treturn DecompilationMode.valueOf(value.toUpperCase());\n+\t\t\t\treturn DecompilationMode.valueOf(stringAsEnumName(value));\n \t\t\t} catch (Exception e) {\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t'\\'' + value + \"' is unknown, possible values are: \"\n@@ -557,4 +557,9 @@ public static String enumValuesString(Enum<?>[] values) {\n \t\t\t\t.map(v -> v.name().replace('_', '-').toLowerCase(Locale.ROOT))\n \t\t\t\t.collect(Collectors.joining(\", \"));\n \t}\n+\n+\tprivate static String stringAsEnumName(String raw) {\n+        // inverse of enumValuesString conversion\n+\t\treturn value.replace('-', '_').toUpperCase();\n+\t}\n }",
    "output": "Fix make enum CLI arguments match documented format Currently if you do `jadx --help`, it says the `--deobf-cfg-file-mode` option accepts the value `read-or-save`. However, if you give it that option, it instead prints the following error message: ``` java.lang.IllegalArgumentException: 'read-or-save' is unknown, possible values are: read, read-or-save, overwrite, ignore at jadx.cli.JadxCLIArgs$DeobfuscationMapFileModeConverter.convert(JadxCLIArgs.java:524) at jadx.cli.JadxCLIArgs$DeobfuscationMapFileModeConverter.convert(JadxCLIArgs.java:516) at com.beust.jcommander.JCommander.convertValue(JCommander.java:1340) at com.beust.jcommander.ParameterDescription.addValue(ParameterDescription.java:249) at com.beust.jcommander.JCommander.processFixedArity(JCommander.java:920) at com.beust.jcommander.JCommander.processFixedArity(JCommander.java:901) at com.beust.jcommander.JCommander.parseValues(JCommander.java:731) at com.beust.jcommander.JCommander.parse(JCommander.java:363) at com.beust.jcommander.JCommander.parse(JCommander.java:342) at jadx.cli.JCommanderWrapper.parse(JCommanderWrapper.java:37) at jadx.cli.JadxCLIArgs.processArgs(JadxCLIArgs.java:211) at jadx.cli.JadxCLI.execute(JadxCLI.java:35) at jadx.cli.JadxCLI.main(JadxCLI.java:20) ``` This commit changes all the enum parsers to do the inverse string of `enumValuesString`, so the documented behavior works."
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -309,9 +309,21 @@ private void appendResourcesSaveTasks(List<Runnable> tasks, File outDir) {\n \t\tif (args.isSkipFilesSave()) {\n \t\t\treturn;\n \t\t}\n+\t\t// process AndroidManifest.xml first to load complete resource ids table\n+\t\tfor (ResourceFile resourceFile : getResources()) {\n+\t\t\tif (resourceFile.getType() == ResourceType.MANIFEST) {\n+\t\t\t\tnew ResourcesSaver(outDir, resourceFile).run();\n+\t\t\t}\n+\t\t}\n+\n \t\tSet<String> inputFileNames = args.getInputFiles().stream().map(File::getAbsolutePath).collect(Collectors.toSet());\n \t\tfor (ResourceFile resourceFile : getResources()) {\n-\t\t\tif (resourceFile.getType() != ResourceType.ARSC\n+\t\t\tResourceType resType = resourceFile.getType();\n+\t\t\tif (resType == ResourceType.MANIFEST) {\n+\t\t\t\t// already processed\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (resType != ResourceType.ARSC\n \t\t\t\t\t&& inputFileNames.contains(resourceFile.getOriginalName())) {\n \t\t\t\t// ignore resource made from input file\n \t\t\t\tcontinue;\n@@ -382,7 +394,7 @@ public List<JavaClass> getClassesWithInners() {\n \t\treturn Utils.collectionMap(root.getClasses(), this::convertClassNode);\n \t}\n \n-\tpublic List<ResourceFile> getResources() {\n+\tpublic synchronized List<ResourceFile> getResources() {\n \t\tif (resources == null) {\n \t\t\tif (root == null) {\n \t\t\t\treturn Collections.emptyList();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -8,6 +8,7 @@\n import java.util.Random;\n import java.util.Set;\n \n+import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -51,7 +52,7 @@ public class BinaryXMLParser extends CommonBinaryParser {\n \tprivate boolean isLastEnd = true;\n \tprivate boolean isOneLine = true;\n \tprivate int namespaceDepth = 0;\n-\tprivate int[] resourceIds;\n+\tprivate @Nullable int[] resourceIds;\n \n \tprivate final RootNode rootNode;\n \tprivate String appPackageName;\n@@ -358,7 +359,7 @@ private String getAttributeName(int id) {\n \t\t// As the outcome of https://github.com/skylot/jadx/issues/1208\n \t\t// Android seems to favor entries from AndroidResMap and only if\n \t\t// there is no entry uses the values form the XML string pool\n-\t\tif (0 <= id && id < resourceIds.length) {\n+\t\tif (resourceIds != null && 0 <= id && id < resourceIds.length) {\n \t\t\tint resId = resourceIds[id];\n \t\t\tString str = ValuesParser.getAndroidResMap().get(resId);\n \t\t\tif (str != null) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n@@ -29,7 +29,11 @@ public ResourcesSaver(File outDir, ResourceFile resourceFile) {\n \n \t@Override\n \tpublic void run() {\n-\t\tsaveResources(resourceFile.loadContent());\n+\t\ttry {\n+\t\t\tsaveResources(resourceFile.loadContent());\n+\t\t} catch (Throwable e) {\n+\t\t\tLOG.warn(\"Failed to save resource: {}\", resourceFile.getOriginalName(), e);\n+\t\t}\n \t}\n \n \tprivate void saveResources(ResContainer rc) {",
    "output": "Fix process manifest before other resources"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -532,9 +532,11 @@ private void onOpen() {\n \t\tupdateLiveReload(project.isEnableLiveReload());\n \t\tBreakpointManager.init(project.getFilePaths().get(0).toAbsolutePath().getParent());\n \n+\t\tList<EditorViewState> openTabs = project.getOpenTabs(this);\n \t\tbackgroundExecutor.execute(NLS.str(\"progress.load\"),\n-\t\t\t\tthis::restoreOpenTabs,\n+\t\t\t\t() -> preLoadOpenTabs(openTabs),\n \t\t\t\tstatus -> {\n+\t\t\t\t\trestoreOpenTabs(openTabs);\n \t\t\t\t\trunInitialBackgroundJobs();\n \t\t\t\t\tnotifyLoadListeners(true);\n \t\t\t\t});\n@@ -1503,8 +1505,8 @@ private void saveOpenTabs() {\n \t\tproject.saveOpenTabs(tabbedPane.getEditorViewStates(), tabbedPane.getSelectedIndex());\n \t}\n \n-\tprivate void restoreOpenTabs() {\n-\t\tList<EditorViewState> openTabs = project.getOpenTabs(this);\n+\tprivate void restoreOpenTabs(List<EditorViewState> openTabs) {\n+\t\tUiUtils.uiThreadGuard();\n \t\tif (openTabs.isEmpty()) {\n \t\t\treturn;\n \t\t}\n@@ -1518,6 +1520,18 @@ private void restoreOpenTabs() {\n \t\t}\n \t}\n \n+\tprivate void preLoadOpenTabs(List<EditorViewState> openTabs) {\n+\t\tUiUtils.notUiThreadGuard();\n+\t\tfor (EditorViewState tabState : openTabs) {\n+\t\t\tJNode node = tabState.getNode();\n+\t\t\ttry {\n+\t\t\t\tnode.getCodeInfo();\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tLOG.warn(\"Failed to preload code for node: {}\", node, e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tprivate void saveSplittersInfo() {\n \t\tsettings.setMainWindowVerticalSplitterLoc(verticalSplitter.getDividerLocation());\n \t\tsettings.setDebuggerStackFrameSplitterLoc(debuggerPanel.getLeftSplitterLocation());",
    "output": "Fix split tabs loading to prevent ui dead lock"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -12,7 +12,6 @@\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ThreadPoolExecutor;\n@@ -93,10 +92,6 @@ public final class JadxDecompiler implements Closeable {\n \tprivate BinaryXMLParser binaryXmlParser;\n \tprivate ProtoXMLParser protoXmlParser;\n \n-\tprivate final Map<ClassNode, JavaClass> classesMap = new ConcurrentHashMap<>();\n-\tprivate final Map<MethodNode, JavaMethod> methodsMap = new ConcurrentHashMap<>();\n-\tprivate final Map<FieldNode, JavaField> fieldsMap = new ConcurrentHashMap<>();\n-\n \tprivate final IDecompileScheduler decompileScheduler = new DecompilerScheduler();\n \n \tprivate final List<ILoadResult> customLoads = new ArrayList<>();\n@@ -155,10 +150,6 @@ private void reset() {\n \t\tresources = null;\n \t\tbinaryXmlParser = null;\n \t\tprotoXmlParser = null;\n-\n-\t\tclassesMap.clear();\n-\t\tmethodsMap.clear();\n-\t\tfieldsMap.clear();\n \t}\n \n \t@Override\n@@ -471,33 +462,36 @@ synchronized ProtoXMLParser getProtoXmlParser() {\n \t * Get JavaClass by ClassNode without loading and decompilation\n \t */\n \t@ApiStatus.Internal\n-\tJavaClass convertClassNode(ClassNode cls) {\n-\t\treturn classesMap.compute(cls, (node, prevJavaCls) -> {\n-\t\t\tif (prevJavaCls != null && prevJavaCls.getClassNode() == cls) {\n-\t\t\t\t// keep previous variable\n-\t\t\t\treturn prevJavaCls;\n-\t\t\t}\n-\t\t\tif (cls.isInner()) {\n-\t\t\t\treturn new JavaClass(cls, convertClassNode(cls.getParentClass()));\n-\t\t\t}\n-\t\t\treturn new JavaClass(cls, this);\n-\t\t});\n+\tsynchronized JavaClass convertClassNode(ClassNode cls) {\n+\t\tJavaClass javaClass = cls.getJavaNode();\n+\t\tif (javaClass == null) {\n+\t\t\tjavaClass = cls.isInner()\n+\t\t\t\t\t? new JavaClass(cls, convertClassNode(cls.getParentClass()))\n+\t\t\t\t\t: new JavaClass(cls, this);\n+\t\t\tcls.setJavaNode(javaClass);\n+\t\t}\n+\t\treturn javaClass;\n \t}\n \n \t@ApiStatus.Internal\n-\tJavaField convertFieldNode(FieldNode field) {\n-\t\treturn fieldsMap.computeIfAbsent(field, fldNode -> {\n-\t\t\tJavaClass parentCls = convertClassNode(fldNode.getParentClass());\n-\t\t\treturn new JavaField(parentCls, fldNode);\n-\t\t});\n+\tsynchronized JavaField convertFieldNode(FieldNode fld) {\n+\t\tJavaField javaField = fld.getJavaNode();\n+\t\tif (javaField == null) {\n+\t\t\tJavaClass parentCls = convertClassNode(fld.getParentClass());\n+\t\t\tjavaField = new JavaField(parentCls, fld);\n+\t\t\tfld.setJavaNode(javaField);\n+\t\t}\n+\t\treturn javaField;\n \t}\n \n \t@ApiStatus.Internal\n-\tJavaMethod convertMethodNode(MethodNode method) {\n-\t\treturn methodsMap.computeIfAbsent(method, mthNode -> {\n-\t\t\tClassNode parentCls = mthNode.getParentClass();\n-\t\t\treturn new JavaMethod(convertClassNode(parentCls), mthNode);\n-\t\t});\n+\tsynchronized JavaMethod convertMethodNode(MethodNode mth) {\n+\t\tJavaMethod javaMethod = mth.getJavaNode();\n+\t\tif (javaMethod == null) {\n+\t\t\tjavaMethod = new JavaMethod(convertClassNode(mth.getParentClass()), mth);\n+\t\t\tmth.setJavaNode(javaMethod);\n+\t\t}\n+\t\treturn javaMethod;\n \t}\n \n \t@Nullable\n@@ -574,14 +568,9 @@ public JavaNode getJavaNodeByCodeAnnotation(@Nullable ICodeInfo codeInfo, @Nulla\n \t\t}\n \t}\n \n-\t@Nullable\n \tprivate JavaVariable resolveVarNode(VarNode varNode) {\n-\t\tMethodNode mthNode = varNode.getMth();\n-\t\tJavaMethod mth = convertMethodNode(mthNode);\n-\t\tif (mth == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\treturn new JavaVariable(mth, varNode);\n+\t\tJavaMethod javaNode = convertMethodNode(varNode.getMth());\n+\t\treturn new JavaVariable(javaNode, varNode);\n \t}\n \n \t@Nullable\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -21,6 +21,7 @@\n import jadx.api.ICodeInfo;\n import jadx.api.ICodeWriter;\n import jadx.api.JadxArgs;\n+import jadx.api.JavaClass;\n import jadx.api.impl.SimpleCodeInfo;\n import jadx.api.plugins.input.data.IClassData;\n import jadx.api.plugins.input.data.IFieldData;\n@@ -100,6 +101,8 @@ public class ClassNode extends NotificationAttrNode implements ILoadable, ICodeN\n \t// cache maps\n \tprivate Map<MethodInfo, MethodNode> mthInfoMap = Collections.emptyMap();\n \n+\tprivate JavaClass javaNode;\n+\n \tpublic ClassNode(RootNode root, IClassData cls) {\n \t\tthis.root = root;\n \t\tthis.clsInfo = ClassInfo.fromType(root, ArgType.object(cls.getType()));\n@@ -835,6 +838,14 @@ public String getInputFileName() {\n \t\treturn clsData == null ? \"synthetic\" : clsData.getInputFileName();\n \t}\n \n+\tpublic JavaClass getJavaNode() {\n+\t\treturn javaNode;\n+\t}\n+\n+\tpublic void setJavaNode(JavaClass javaNode) {\n+\t\tthis.javaNode = javaNode;\n+\t}\n+\n \t@Override\n \tpublic AnnType getAnnType() {\n \t\treturn AnnType.CLASS;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java\n@@ -3,6 +3,7 @@\n import java.util.Collections;\n import java.util.List;\n \n+import jadx.api.JavaField;\n import jadx.api.plugins.input.data.IFieldData;\n import jadx.core.dex.attributes.nodes.NotificationAttrNode;\n import jadx.core.dex.info.AccessInfo;\n@@ -21,6 +22,8 @@ public class FieldNode extends NotificationAttrNode implements ICodeNode {\n \n \tprivate List<MethodNode> useIn = Collections.emptyList();\n \n+\tprivate JavaField javaNode;\n+\n \tpublic static FieldNode build(ClassNode cls, IFieldData fieldData) {\n \t\tFieldInfo fieldInfo = FieldInfo.fromRef(cls.root(), fieldData);\n \t\tFieldNode fieldNode = new FieldNode(cls, fieldInfo, fieldData.getAccessFlags());\n@@ -112,6 +115,14 @@ public RootNode root() {\n \t\treturn parentClass.root();\n \t}\n \n+\tpublic JavaField getJavaNode() {\n+\t\treturn javaNode;\n+\t}\n+\n+\tpublic void setJavaNode(JavaField javaNode) {\n+\t\tthis.javaNode = javaNode;\n+\t}\n+\n \t@Override\n \tpublic AnnType getAnnType() {\n \t\treturn AnnType.FIELD;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -10,6 +10,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.api.JavaMethod;\n import jadx.api.plugins.input.data.ICodeReader;\n import jadx.api.plugins.input.data.IDebugInfo;\n import jadx.api.plugins.input.data.IMethodData;\n@@ -71,6 +72,8 @@ public class MethodNode extends NotificationAttrNode implements IMethodDetails,\n \n \tprivate List<MethodNode> useIn = Collections.emptyList();\n \n+\tprivate JavaMethod javaNode;\n+\n \tpublic static MethodNode build(ClassNode classNode, IMethodData methodData) {\n \t\tMethodNode methodNode = new MethodNode(classNode, methodData);\n \t\tmethodNode.addAttrs(methodData.getAttributes());\n@@ -610,6 +613,14 @@ public void setUseIn(List<MethodNode> useIn) {\n \t\tthis.useIn = useIn;\n \t}\n \n+\tpublic JavaMethod getJavaNode() {\n+\t\treturn javaNode;\n+\t}\n+\n+\tpublic void setJavaNode(JavaMethod javaNode) {\n+\t\tthis.javaNode = javaNode;\n+\t}\n+\n \t@Override\n \tpublic AnnType getAnnType() {\n \t\treturn AnnType.METHOD;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n@@ -141,6 +141,10 @@ private List<String> collectMethodArgNames(JavaMethod javaMethod) {\n \t\t\t}\n \t\t\treturn null;\n \t\t});\n+\t\tint argsCount = javaMethod.getMethodNode().getMethodInfo().getArgsCount();\n+\t\tif (argNames.size() != argsCount) {\n+\t\t\tLOG.warn(\"Incorrect args count, expected: {}, got: {}\", argsCount, argNames.size());\n+\t\t}\n \t\treturn argNames;\n \t}",
    "output": "Fix resolve JavaNode caching issues"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n@@ -78,10 +78,13 @@ private String generateMethodSnippet(JMethod jMth) {\n \t\tMethodNode mth = jMth.getJavaMethod().getMethodNode();\n \t\tMethodInfo methodInfo = mth.getMethodInfo();\n \t\tString methodName;\n+\t\tString newMethodName;\n \t\tif (methodInfo.isConstructor()) {\n \t\t\tmethodName = \"$init\";\n+\t\t\tnewMethodName = methodName;\n \t\t} else {\n \t\t\tmethodName = StringEscapeUtils.escapeEcmaScript(methodInfo.getName());\n+\t\t\tnewMethodName = StringEscapeUtils.escapeEcmaScript(methodInfo.getAlias());\n \t\t}\n \t\tString overload;\n \t\tif (isOverloaded(mth)) {\n@@ -97,25 +100,24 @@ private String generateMethodSnippet(JMethod jMth) {\n \t\tif (argNames.isEmpty()) {\n \t\t\tlogArgs = \"\";\n \t\t} else {\n-\t\t\tString joinStr = \" + ', ' + \";\n-\t\t\tlogArgs = joinStr + argNames.stream().map(a -> \"'\" + a + \": ' + \" + a).collect(Collectors.joining(joinStr));\n+\t\t\tlogArgs = \": \" + argNames.stream().map(arg -> arg + \"=${\" + arg + \"}\").collect(Collectors.joining(\", \"));\n \t\t}\n \t\tString shortClassName = mth.getParentClass().getShortName();\n \t\tString classSnippet = generateClassSnippet(jMth.getJParent());\n \t\tif (methodInfo.isConstructor() || methodInfo.getReturnType() == ArgType.VOID) {\n \t\t\t// no return value\n \t\t\treturn classSnippet + \"\\n\"\n \t\t\t\t\t+ shortClassName + \"[\\\"\" + methodName + \"\\\"]\" + overload + \".implementation = function (\" + args + \") {\\n\"\n-\t\t\t\t\t+ \"    console.log('\" + shortClassName + \".\" + methodName + \" is called'\" + logArgs + \");\\n\"\n+\t\t\t\t\t+ \"    console.log(`\" + shortClassName + \".\" + newMethodName + \" is called\" + logArgs + \"`);\\n\"\n \t\t\t\t\t+ \"    this[\\\"\" + methodName + \"\\\"](\" + args + \");\\n\"\n \t\t\t\t\t+ \"};\";\n \t\t}\n \t\treturn classSnippet + \"\\n\"\n \t\t\t\t+ shortClassName + \"[\\\"\" + methodName + \"\\\"]\" + overload + \".implementation = function (\" + args + \") {\\n\"\n-\t\t\t\t+ \"    console.log('\" + shortClassName + \".\" + methodName + \" is called'\" + logArgs + \");\\n\"\n-\t\t\t\t+ \"    let ret = this[\\\"\" + methodName + \"\\\"](\" + args + \");\\n\"\n-\t\t\t\t+ \"    console.log('\" + shortClassName + \".\" + methodName + \" return: ' + ret);\\n\"\n-\t\t\t\t+ \"    return ret;\\n\"\n+\t\t\t\t+ \"    console.log(`\" + shortClassName + \".\" + newMethodName + \" is called\" + logArgs + \"`);\\n\"\n+\t\t\t\t+ \"    let result = this[\\\"\" + methodName + \"\\\"](\" + args + \");\\n\"\n+\t\t\t\t+ \"    console.log(`\" + shortClassName + \".\" + newMethodName + \" result=${result}`);\\n\"\n+\t\t\t\t+ \"    return result;\\n\"\n \t\t\t\t+ \"};\";\n \t}",
    "output": "Fix print the renamed function name in a frida snippet log"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java\n@@ -61,6 +61,11 @@ public String makeLongStringHtml() {\n \t\treturn UiUtils.typeFormatHtml(var.getName(), var.getType());\n \t}\n \n+\t@Override\n+\tpublic boolean disableHtml() {\n+\t\treturn false;\n+\t}\n+\n \t@Override\n \tpublic String getTooltip() {\n \t\tString name = var.getName() + \" (r\" + var.getReg() + \"v\" + var.getSsa() + \")\";",
    "output": "Fix allow html in JVariable to render renaming of variables correctly"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/panel/LogcatPanel.java b/jadx-gui/src/main/java/jadx/gui/ui/panel/LogcatPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/panel/LogcatPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/panel/LogcatPanel.java\n@@ -94,6 +94,8 @@ public void actionPerformed(ActionEvent e) {\n \t};\n \n \tpublic boolean showLogcat() {\n+\t\tthis.removeAll();\n+\n \t\tArrayList<String> pkgs = new ArrayList<>();\n \t\tpids = new ArrayList<>();\n \t\tJPanel procBox;",
    "output": "Fix quick fix for duplicate/overlapping logcat windows"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/invokedynamic/CustomLambdaCall.java b/jadx-core/src/main/java/jadx/core/dex/instructions/invokedynamic/CustomLambdaCall.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/invokedynamic/CustomLambdaCall.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/invokedynamic/CustomLambdaCall.java\n@@ -39,13 +39,11 @@ public static boolean isLambdaInvoke(List<EncodedValue> values) {\n \t\t\treturn false;\n \t\t}\n \t\tIMethodRef methodRef = methodHandle.getMethodRef();\n-\t\tif (!methodRef.getName().equals(\"metafactory\")) {\n-\t\t\treturn false;\n-\t\t}\n \t\tif (!methodRef.getParentClassType().equals(\"Ljava/lang/invoke/LambdaMetafactory;\")) {\n \t\t\treturn false;\n \t\t}\n-\t\treturn true;\n+\t\tString mthName = methodRef.getName();\n+\t\treturn mthName.equals(\"metafactory\") || mthName.equals(\"altMetafactory\");\n \t}\n \n \tpublic static InvokeCustomNode buildLambdaMethodCall(MethodNode mth, InsnData insn, boolean isRange, List<EncodedValue> values) {",
    "output": "Fix allow `altMetafactory` method in lambda call site"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java b/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java\n--- a/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java\n+++ b/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java\n@@ -13,6 +13,8 @@\n \n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import jadx.api.ICodeInfo;\n import jadx.api.plugins.input.data.AccessFlags;\n@@ -46,6 +48,7 @@\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n import static jadx.api.plugins.input.data.AccessFlagsScope.FIELD;\n@@ -67,6 +70,7 @@\n import static jadx.api.plugins.input.insns.Opcode.SPARSE_SWITCH_PAYLOAD;\n \n public class Smali {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(Smali.class);\n \n \tprivate static SmaliInsnDecoder insnDecoder = null;\n \n@@ -219,7 +223,15 @@ private void writeClass(SmaliWriter smali, ClassNode cls) {\n \t\t\t\t\t\twriteFields(smali, clsData, fields, colWidths);\n \t\t\t\t\t\tfields.clear();\n \t\t\t\t\t}\n-\t\t\t\t\twriteMethod(smali, cls.getMethods().get(mthIndex[0]++), m, line);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\twriteMethod(smali, cls.getMethods().get(mthIndex[0]++), m, line);\n+\t\t\t\t\t} catch (Throwable e) {\n+\t\t\t\t\t\tIMethodRef methodRef = m.getMethodRef();\n+\t\t\t\t\t\tString mthFullName = methodRef.getParentClassType() + \"->\" + methodRef.getName();\n+\t\t\t\t\t\tsmali.setIndent(0);\n+\t\t\t\t\t\tsmali.startLine(\"Failed to write method: \" + mthFullName + \"\\n\" + Utils.getStackTrace(e));\n+\t\t\t\t\t\tLOG.error(\"Failed to write smali code for method: {}\", mthFullName, e);\n+\t\t\t\t\t}\n \t\t\t\t\tline.reset();\n \t\t\t\t});\n \n@@ -451,48 +463,45 @@ private boolean formatMthParamInfo(IMethodData mth, SmaliWriter smali, ICodeRead\n \t\tif (types.isEmpty()) {\n \t\t\treturn false;\n \t\t}\n-\t\tint paramCount = 0;\n-\t\tint paramStart = 0;\n-\t\tint regNum = line.smaliMthNode.getParamRegStart();\n-\t\tif (!hasStaticFlag(mth.getAccessFlags())) {\n-\t\t\tline.addRegName(regNum, \"p0\");\n-\t\t\tline.smaliMthNode.setParamReg(regNum, \"p0\");\n-\t\t\tregNum += 1;\n-\t\t\tparamStart = 1;\n-\t\t}\n+\t\tILocalVar[] params = new ILocalVar[codeReader.getRegistersCount()];\n \t\tIDebugInfo dbgInfo = codeReader.getDebugInfo();\n \t\tif (dbgInfo != null) {\n \t\t\tfor (ILocalVar var : dbgInfo.getLocalVars()) {\n-\t\t\t\tif (var.getRegNum() == regNum) {\n-\t\t\t\t\tint i = writeParamInfo(smali, line, regNum, paramStart, var.getName(), var.getType());\n-\t\t\t\t\tregNum += i;\n-\t\t\t\t\tparamStart += i;\n-\t\t\t\t\tparamCount++;\n+\t\t\t\t// collect only method parameters\n+\t\t\t\tif (var.getStartOffset() <= 0) {\n+\t\t\t\t\tparams[var.getRegNum()] = var;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tfor (; paramCount < types.size(); paramCount++) {\n-\t\t\tint i = writeParamInfo(smali, line, regNum, paramStart, \"\", types.get(paramCount));\n-\t\t\tregNum += i;\n-\t\t\tparamStart += i;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tprivate static int writeParamInfo(SmaliWriter smali, LineInfo line,\n-\t\t\tint regNum, int paramNum, String dbgInfoName, String type) {\n-\t\tsmali.startLine(String.format(\".param p%d, \\\"%s\\\":%s\", paramNum, dbgInfoName, type));\n-\t\tString pName = \"p\" + paramNum;\n-\t\tline.addRegName(regNum, pName);\n-\t\tline.smaliMthNode.setParamReg(regNum, pName);\n-\t\tif (isWideType(type)) {\n+\t\tint paramStart = 0;\n+\t\tint regNum = line.smaliMthNode.getParamRegStart();\n+\t\tif (!hasStaticFlag(mth.getAccessFlags())) {\n+\t\t\t// add 'this' register\n+\t\t\tline.addRegName(regNum, \"p0\");\n+\t\t\tline.smaliMthNode.setParamReg(regNum, \"p0\");\n \t\t\tregNum++;\n-\t\t\tdbgInfoName = \"p\" + (paramNum + 1);\n-\t\t\tline.addRegName(regNum, dbgInfoName);\n-\t\t\tline.smaliMthNode.setParamReg(regNum, dbgInfoName);\n-\t\t\treturn 2;\n+\t\t\tparamStart++;\n+\t\t}\n+\t\tfor (String paramType : types) {\n+\t\t\tString name;\n+\t\t\tString type;\n+\t\t\tILocalVar param = params[regNum];\n+\t\t\tif (param != null) {\n+\t\t\t\tname = Utils.getOrElse(param.getName(), \"\");\n+\t\t\t\ttype = Utils.getOrElse(param.getSignature(), paramType);\n+\t\t\t} else {\n+\t\t\t\tname = \"\";\n+\t\t\t\ttype = paramType;\n+\t\t\t}\n+\t\t\tString varName = \"p\" + paramStart;\n+\t\t\tsmali.startLine(String.format(\".param %s, \\\"%s\\\" # %s\", varName, name, type));\n+\t\t\tline.addRegName(regNum, varName);\n+\t\t\tline.smaliMthNode.setParamReg(regNum, varName);\n+\t\t\tint regSize = isWideType(paramType) ? 2 : 1;\n+\t\t\tregNum += regSize;\n+\t\t\tparamStart += regSize;\n \t\t}\n-\t\treturn 1;\n+\t\treturn true;\n \t}\n \n \tprivate static int getParamStartRegNum(IMethodData mth) {\n\ndiff --git a/jadx-gui/src/test/java/jadx/gui/device/debugger/smali/DbgSmaliTest.java b/jadx-gui/src/test/java/jadx/gui/device/debugger/smali/DbgSmaliTest.java\n--- a/jadx-gui/src/test/java/jadx/gui/device/debugger/smali/DbgSmaliTest.java\n+++ b/jadx-gui/src/test/java/jadx/gui/device/debugger/smali/DbgSmaliTest.java\n@@ -8,6 +8,8 @@\n import jadx.core.dex.nodes.ClassNode;\n import jadx.tests.api.SmaliTest;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n+\n class DbgSmaliTest extends SmaliTest {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(DbgSmaliTest.class);\n \n@@ -17,10 +19,20 @@ public void initProject() {\n \t}\n \n \t@Test\n-\tvoid test() {\n+\tvoid testSwitch() {\n \t\tdisableCompilation();\n \t\tClassNode cls = getClassNodeFromSmali(\"switch\", \"SwitchTest\");\n \t\tSmali disasm = Smali.disassemble(cls);\n \t\tLOG.debug(\"{}\", disasm.getCode());\n \t}\n+\n+\t@Test\n+\tvoid testParams() {\n+\t\tdisableCompilation();\n+\t\tClassNode cls = getClassNodeFromSmali(\"params\", \"ParamsTest\");\n+\t\tSmali disasm = Smali.disassemble(cls);\n+\t\tString code = disasm.getCode();\n+\t\tLOG.debug(\"{}\", code);\n+\t\tassertThat(code).doesNotContain(\"Failed to write method\");\n+\t}\n }",
    "output": "Fix improve smali disasm method param write"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java b/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java\n--- a/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java\n+++ b/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java\n@@ -463,7 +463,7 @@ private boolean formatMthParamInfo(IMethodData mth, SmaliWriter smali, ICodeRead\n \t\tIDebugInfo dbgInfo = codeReader.getDebugInfo();\n \t\tif (dbgInfo != null) {\n \t\t\tfor (ILocalVar var : dbgInfo.getLocalVars()) {\n-\t\t\t\tif (var.getStartOffset() == -1) {\n+\t\t\t\tif (var.getRegNum() == regNum) {\n \t\t\t\t\tint i = writeParamInfo(smali, line, regNum, paramStart, var.getName(), var.getType());\n \t\t\t\t\tregNum += i;\n \t\t\t\t\tparamStart += i;",
    "output": "Fix resolve exception in smali method writer"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ProtoXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ProtoXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ProtoXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ProtoXMLParser.java\n@@ -84,7 +84,7 @@ private void decode(XmlAttribute a) {\n \t\t}\n \t\tString name = a.getName();\n \t\tString value = deobfClassName(a.getValue());\n-\t\twriter.add(name).add(\"=\\\"\").add(value).add('\\\"');\n+\t\twriter.add(name).add(\"=\\\"\").add(StringUtils.escapeXML(value)).add('\\\"');\n \t\tmemorizePackageName(name, value);\n \t}",
    "output": "Fix escape special characters in AAB resources"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n@@ -90,7 +90,7 @@ private MethodOverrideAttr processOverrideMethods(MethodNode mth, SuperTypesData\n \t\tfor (ArgType superType : superData.getSuperTypes()) {\n \t\t\tClassNode classNode = mth.root().resolveClass(superType);\n \t\t\tif (classNode != null) {\n-\t\t\t\tMethodNode ovrdMth = searchOverriddenMethod(classNode, signature);\n+\t\t\t\tMethodNode ovrdMth = searchOverriddenMethod(classNode, mth, signature);\n \t\t\t\tif (ovrdMth != null) {\n \t\t\t\t\tif (isMethodVisibleInCls(ovrdMth, cls)) {\n \t\t\t\t\t\toverrideList.add(ovrdMth);\n@@ -107,6 +107,8 @@ private MethodOverrideAttr processOverrideMethods(MethodNode mth, SuperTypesData\n \t\t\t\t\tMap<String, ClspMethod> methodsMap = clsDetails.getMethodsMap();\n \t\t\t\t\tfor (Map.Entry<String, ClspMethod> entry : methodsMap.entrySet()) {\n \t\t\t\t\t\tString mthShortId = entry.getKey();\n+\t\t\t\t\t\t// do not check full signature, classpath methods can be trusted\n+\t\t\t\t\t\t// i.e. doesn't contain methods with same signature in one class\n \t\t\t\t\t\tif (mthShortId.startsWith(signature)) {\n \t\t\t\t\t\t\toverrideList.add(entry.getValue());\n \t\t\t\t\t\t\tbreak;\n@@ -130,12 +132,30 @@ private void addBaseMethod(SuperTypesData superData, List<IMethodDetails> overri\n \t}\n \n \t@Nullable\n-\tprivate MethodNode searchOverriddenMethod(ClassNode cls, String signature) {\n+\tprivate MethodNode searchOverriddenMethod(ClassNode cls, MethodNode mth, String signature) {\n+\t\t// search by exact full signature (with return value) to fight obfuscation (see test\n+\t\t// 'TestOverrideWithSameName')\n+\t\tString shortId = mth.getMethodInfo().getShortId();\n \t\tfor (MethodNode supMth : cls.getMethods()) {\n-\t\t\tif (!supMth.getAccessFlags().isStatic() && supMth.getMethodInfo().getShortId().startsWith(signature)) {\n+\t\t\tif (supMth.getMethodInfo().getShortId().equals(shortId) && !supMth.getAccessFlags().isStatic()) {\n \t\t\t\treturn supMth;\n \t\t\t}\n \t\t}\n+\t\t// search by signature without return value and check if return value is wider type\n+\t\tfor (MethodNode supMth : cls.getMethods()) {\n+\t\t\tif (supMth.getMethodInfo().getShortId().startsWith(signature) && !supMth.getAccessFlags().isStatic()) {\n+\t\t\t\tTypeCompare typeCompare = cls.root().getTypeCompare();\n+\t\t\t\tArgType supRetType = supMth.getMethodInfo().getReturnType();\n+\t\t\t\tArgType mthRetType = mth.getMethodInfo().getReturnType();\n+\t\t\t\tTypeCompareEnum res = typeCompare.compareTypes(supRetType, mthRetType);\n+\t\t\t\tif (res.isWider()) {\n+\t\t\t\t\treturn supMth;\n+\t\t\t\t}\n+\t\t\t\tif (res == TypeCompareEnum.UNKNOWN || res == TypeCompareEnum.CONFLICT) {\n+\t\t\t\t\tmth.addDebugComment(\"Possible override for method \" + supMth.getMethodInfo().getFullId());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\treturn null;\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestOverrideWithSameName.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestOverrideWithSameName.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestOverrideWithSameName.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestOverrideWithSameName.java\n@@ -0,0 +1,67 @@\n+package jadx.tests.integration.others;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+@SuppressWarnings(\"CommentedOutCode\")\n+public class TestOverrideWithSameName extends SmaliTest {\n+\n+\t//@formatter:off\n+\t/*\n+\t\tinterface A {\n+\t\t\tB a();\n+\t\t\tC a();\n+\t\t}\n+\n+\t\tabstract class B implements A {\n+\t\t\t@Override\n+\t\t\tpublic C a() {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic class C extends B {\n+\t\t\t@Override\n+\t\t\tpublic B a() {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t//@formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tList<ClassNode> clsNodes = loadFromSmaliFiles();\n+\t\tassertThat(searchCls(clsNodes, \"test.A\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"C mo0a();\") // assume second method was renamed\n+\t\t\t\t.doesNotContain(\"@Override\");\n+\n+\t\tClassNode bCls = searchCls(clsNodes, \"test.B\");\n+\t\tassertThat(bCls)\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"C mo0a() {\")\n+\t\t\t\t.containsOne(\"@Override\");\n+\n+\t\tassertThat(getMethod(bCls, \"a\").get(AType.METHOD_OVERRIDE).getOverrideList())\n+\t\t\t\t.singleElement()\n+\t\t\t\t.satisfies(mth -> assertThat(mth.getMethodInfo().getDeclClass().getShortName()).isEqualTo(\"A\"));\n+\n+\t\tClassNode cCls = searchCls(clsNodes, \"test.C\");\n+\t\tassertThat(cCls)\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"B a() {\")\n+\t\t\t\t.containsOne(\"@Override\");\n+\n+\t\tassertThat(getMethod(cCls, \"a\").get(AType.METHOD_OVERRIDE).getOverrideList())\n+\t\t\t\t.singleElement()\n+\t\t\t\t.satisfies(mth -> assertThat(mth.getMethodInfo().getDeclClass().getShortName()).isEqualTo(\"A\"));\n+\t}\n+}",
    "output": "Fix check full signature for search method override"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/search/providers/CommentSearchProvider.java b/jadx-gui/src/main/java/jadx/gui/search/providers/CommentSearchProvider.java\n--- a/jadx-gui/src/main/java/jadx/gui/search/providers/CommentSearchProvider.java\n+++ b/jadx-gui/src/main/java/jadx/gui/search/providers/CommentSearchProvider.java\n@@ -5,6 +5,7 @@\n \n import javax.swing.Icon;\n \n+import org.fife.ui.rsyntaxtextarea.SyntaxConstants;\n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n@@ -197,7 +198,7 @@ public Icon getIcon() {\n \n \t\t@Override\n \t\tpublic String getSyntaxName() {\n-\t\t\treturn node.getSyntaxName();\n+\t\t\treturn SyntaxConstants.SYNTAX_STYLE_NONE; // comment is always plain text\n \t\t}\n \n \t\t@Override\n@@ -220,6 +221,11 @@ public String makeLongStringHtml() {\n \t\t\treturn node.makeLongStringHtml();\n \t\t}\n \n+\t\t@Override\n+\t\tpublic boolean disableHtml() {\n+\t\t\treturn node.disableHtml();\n+\t\t}\n+\n \t\t@Override\n \t\tpublic int getPos() {\n \t\t\treturn node.getPos();",
    "output": "Fix correct html render in comments search results"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -23,6 +23,7 @@\n import java.awt.event.MouseEvent;\n import java.awt.event.WindowAdapter;\n import java.awt.event.WindowEvent;\n+import java.awt.geom.AffineTransform;\n import java.io.InputStream;\n import java.net.URL;\n import java.nio.file.Files;\n@@ -1423,8 +1424,9 @@ public void setLocationAndPosition() {\n \t\t}\n \t\tGraphicsDevice gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();\n \t\tDisplayMode mode = gd.getDisplayMode();\n-\t\tint w = mode.getWidth();\n-\t\tint h = mode.getHeight();\n+\t\tAffineTransform trans = gd.getDefaultConfiguration().getDefaultTransform();\n+\t\tint w = (int) (mode.getWidth() / trans.getScaleX());\n+\t\tint h = (int) (mode.getHeight() / trans.getScaleY());\n \t\tsetBounds((int) (w * BORDER_RATIO), (int) (h * BORDER_RATIO),\n \t\t\t\t(int) (w * WINDOW_RATIO), (int) (h * WINDOW_RATIO));\n \t\tsetLocationRelativeTo(null);",
    "output": "Fix hi-dpi main window initial size"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n@@ -23,7 +23,6 @@\n import jadx.core.codegen.TypeGen;\n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.instructions.args.ArgType;\n-import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.treemodel.JClass;\n@@ -76,45 +75,48 @@ private String generateFridaSnippet(JNode node) {\n \t}\n \n \tprivate String generateMethodSnippet(JMethod jMth) {\n-\t\tJavaMethod javaMethod = jMth.getJavaMethod();\n-\t\tMethodInfo methodInfo = javaMethod.getMethodNode().getMethodInfo();\n-\t\tString methodName = StringEscapeUtils.escapeEcmaScript(methodInfo.getName());\n-\n+\t\tMethodNode mth = jMth.getJavaMethod().getMethodNode();\n+\t\tMethodInfo methodInfo = mth.getMethodInfo();\n+\t\tString methodName;\n \t\tif (methodInfo.isConstructor()) {\n \t\t\tmethodName = \"$init\";\n+\t\t} else {\n+\t\t\tmethodName = StringEscapeUtils.escapeEcmaScript(methodInfo.getName());\n \t\t}\n-\n-\t\tString callMethodName = methodName;\n-\t\tString shortClassName = javaMethod.getDeclaringClass().getName();\n-\n-\t\tString functionUntilImplementation;\n-\t\tif (isOverloaded(javaMethod.getMethodNode())) {\n-\t\t\tList<ArgType> methodArgs = methodInfo.getArgumentsTypes();\n-\t\t\tString overloadStr = methodArgs.stream().map(this::parseArgType).collect(Collectors.joining(\", \"));\n-\t\t\tfunctionUntilImplementation = String.format(\"%s[\\\"%s\\\"].overload(%s).implementation\", shortClassName, methodName, overloadStr);\n+\t\tString overload;\n+\t\tif (isOverloaded(mth)) {\n+\t\t\tString overloadArgs = methodInfo.getArgumentsTypes().stream()\n+\t\t\t\t\t.map(this::parseArgType).collect(Collectors.joining(\", \"));\n+\t\t\toverload = \".overload(\" + overloadArgs + \")\";\n \t\t} else {\n-\t\t\tfunctionUntilImplementation = String.format(\"%s[\\\"%s\\\"].implementation\", shortClassName, methodName);\n+\t\t\toverload = \"\";\n \t\t}\n-\n-\t\tList<String> methodArgNames = collectMethodArgNames(javaMethod);\n-\n-\t\tString functionParametersString = String.join(\", \", methodArgNames);\n-\t\tString logParametersString =\n-\t\t\t\tmethodArgNames.stream().map(e -> String.format(\"'%s: ' + %s\", e, e)).collect(Collectors.joining(\" + ', ' + \"));\n-\t\tif (logParametersString.length() > 0) {\n-\t\t\tlogParametersString = \" + ', ' + \" + logParametersString;\n+\t\tList<String> argNames = collectMethodArgNames(jMth.getJavaMethod());\n+\t\tString args = String.join(\", \", argNames);\n+\t\tString logArgs;\n+\t\tif (argNames.isEmpty()) {\n+\t\t\tlogArgs = \"\";\n+\t\t} else {\n+\t\t\tString joinStr = \" + ', ' + \";\n+\t\t\tlogArgs = joinStr + argNames.stream().map(a -> \"'\" + a + \": ' + \" + a).collect(Collectors.joining(joinStr));\n \t\t}\n-\t\tString functionParameterAndBody = String.format(\n-\t\t\t\t\"%s = function (%s) {\\n\"\n-\t\t\t\t\t\t+ \"    console.log('%s is called'%s);\\n\"\n-\t\t\t\t\t\t+ \"    let ret = this.%s(%s);\\n\"\n-\t\t\t\t\t\t+ \"    console.log('%s ret value is ' + ret);\\n\"\n-\t\t\t\t\t\t+ \"    return ret;\\n\"\n-\t\t\t\t\t\t+ \"};\",\n-\t\t\t\tfunctionUntilImplementation, functionParametersString, methodName, logParametersString, callMethodName,\n-\t\t\t\tfunctionParametersString, methodName);\n-\n-\t\treturn generateClassSnippet(jMth.getJParent()) + \"\\n\" + functionParameterAndBody;\n+\t\tString shortClassName = mth.getParentClass().getShortName();\n+\t\tString classSnippet = generateClassSnippet(jMth.getJParent());\n+\t\tif (methodInfo.isConstructor() || methodInfo.getReturnType() == ArgType.VOID) {\n+\t\t\t// no return value\n+\t\t\treturn classSnippet + \"\\n\"\n+\t\t\t\t\t+ shortClassName + \"[\\\"\" + methodName + \"\\\"]\" + overload + \".implementation = function (\" + args + \") {\\n\"\n+\t\t\t\t\t+ \"    console.log('\" + shortClassName + \".\" + methodName + \" is called'\" + logArgs + \");\\n\"\n+\t\t\t\t\t+ \"    this[\\\"\" + methodName + \"\\\"](\" + args + \");\\n\"\n+\t\t\t\t\t+ \"};\";\n+\t\t}\n+\t\treturn classSnippet + \"\\n\"\n+\t\t\t\t+ shortClassName + \"[\\\"\" + methodName + \"\\\"]\" + overload + \".implementation = function (\" + args + \") {\\n\"\n+\t\t\t\t+ \"    console.log('\" + shortClassName + \".\" + methodName + \" is called'\" + logArgs + \");\\n\"\n+\t\t\t\t+ \"    let ret = this[\\\"\" + methodName + \"\\\"](\" + args + \");\\n\"\n+\t\t\t\t+ \"    console.log('\" + shortClassName + \".\" + methodName + \" return: ' + ret);\\n\"\n+\t\t\t\t+ \"    return ret;\\n\"\n+\t\t\t\t+ \"};\";\n \t}\n \n \tprivate List<String> collectMethodArgNames(JavaMethod javaMethod) {\n@@ -159,27 +161,24 @@ private String generateFieldSnippet(JField jf) {\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\n \t\tJClass jc = jf.getRootClass();\n \t\tString classSnippet = generateClassSnippet(jc);\n \t\treturn String.format(\"%s\\n%s = %s.%s.value;\", classSnippet, fieldName, jc.getName(), rawFieldName);\n \t}\n \n \tpublic Boolean isOverloaded(MethodNode methodNode) {\n-\t\tClassNode parentClass = methodNode.getParentClass();\n-\t\tList<MethodNode> methods = parentClass.getMethods();\n-\t\treturn methods.stream()\n+\t\treturn methodNode.getParentClass().getMethods().stream()\n \t\t\t\t.anyMatch(m -> m.getName().equals(methodNode.getName())\n \t\t\t\t\t\t&& !Objects.equals(methodNode.getMethodInfo().getShortId(), m.getMethodInfo().getShortId()));\n \t}\n \n \tprivate String parseArgType(ArgType x) {\n-\t\tStringBuilder parsedArgType = new StringBuilder(\"'\");\n+\t\tString typeStr;\n \t\tif (x.isArray()) {\n-\t\t\tparsedArgType.append(TypeGen.signature(x).replace(\"/\", \".\"));\n+\t\t\ttypeStr = TypeGen.signature(x).replace(\"/\", \".\");\n \t\t} else {\n-\t\t\tparsedArgType.append(x);\n+\t\t\ttypeStr = x.toString();\n \t\t}\n-\t\treturn parsedArgType.append(\"'\").toString();\n+\t\treturn \"'\" + typeStr + \"'\";\n \t}\n }",
    "output": "Add template for constructor and void methods to Frida snippet"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n@@ -79,12 +79,12 @@ private String generateMethodSnippet(JMethod jMth) {\n \t\tJavaMethod javaMethod = jMth.getJavaMethod();\n \t\tMethodInfo methodInfo = javaMethod.getMethodNode().getMethodInfo();\n \t\tString methodName = StringEscapeUtils.escapeEcmaScript(methodInfo.getName());\n-\t\tString callMethodName = methodName;\n \n \t\tif (methodInfo.isConstructor()) {\n \t\t\tmethodName = \"$init\";\n-\t\t\tcallMethodName = \"$new\";\n \t\t}\n+\n+\t\tString callMethodName = methodName;\n \t\tString shortClassName = javaMethod.getDeclaringClass().getName();\n \n \t\tString functionUntilImplementation;",
    "output": "Fix change callMethodName of constructors in Frida action"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/treenodes/SummaryNode.java b/jadx-gui/src/main/java/jadx/gui/ui/treenodes/SummaryNode.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/treenodes/SummaryNode.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/treenodes/SummaryNode.java\n@@ -2,6 +2,7 @@\n \n import java.io.File;\n import java.io.IOException;\n+import java.util.Comparator;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n@@ -75,7 +76,7 @@ private void writeInputSummary(StringEscapeUtils.Builder builder) throws IOExcep\n \t\tList<String> codeSources = classes.stream()\n \t\t\t\t.map(ClassNode::getInputFileName)\n \t\t\t\t.distinct()\n-\t\t\t\t.sorted()\n+\t\t\t\t.sorted(Comparator.naturalOrder())\n \t\t\t\t.collect(Collectors.toList());\n \t\tcodeSources.remove(\"synthetic\");\n \t\tint codeSourcesCount = codeSources.size();\n@@ -84,14 +85,10 @@ private void writeInputSummary(StringEscapeUtils.Builder builder) throws IOExcep\n \t\tif (codeSourcesCount != 1) {\n \t\t\tbuilder.append(\"<li>Count: \" + codeSourcesCount + \"</li>\");\n \t\t}\n-\t\t// dex files list\n-\t\tcodeSources.removeIf(f -> !f.endsWith(\".dex\"));\n-\t\tif (!codeSources.isEmpty()) {\n-\t\t\tfor (String input : codeSources) {\n-\t\t\t\tbuilder.append(\"<li>\");\n-\t\t\t\tbuilder.escape(input);\n-\t\t\t\tbuilder.append(\"</li>\");\n-\t\t\t}\n+\t\tfor (String input : codeSources) {\n+\t\t\tbuilder.append(\"<li>\");\n+\t\t\tbuilder.escape(input);\n+\t\t\tbuilder.append(\"</li>\");\n \t\t}\n \t\tbuilder.append(\"</ul>\");",
    "output": "Fix show all code sources in summary (remove dex filter)"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n@@ -2,6 +2,7 @@\n \n import java.awt.Component;\n import java.awt.Dimension;\n+import java.awt.Insets;\n import java.awt.Point;\n import java.awt.Rectangle;\n import java.awt.event.ActionEvent;\n@@ -396,4 +397,24 @@ public void dispose() {\n \t\t\tLOG.debug(\"Error on code area dispose\", e);\n \t\t}\n \t}\n+\n+\t@Override\n+\tpublic Dimension getPreferredSize() {\n+\t\ttry {\n+\t\t\treturn super.getPreferredSize();\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.warn(\"Failed to calculate preferred size for code area\", e);\n+\t\t\t// copied from javax.swing.JTextArea.getPreferredSize (super call above)\n+\t\t\t// as a fallback for returned null size\n+\t\t\tDimension d = new Dimension(400, 400);\n+\t\t\tInsets insets = getInsets();\n+\t\t\tif (getColumns() != 0) {\n+\t\t\t\td.width = Math.max(d.width, getColumns() * getColumnWidth() + insets.left + insets.right);\n+\t\t\t}\n+\t\t\tif (getRows() != 0) {\n+\t\t\t\td.height = Math.max(d.height, getRows() * getRowHeight() + insets.top + insets.bottom);\n+\t\t\t}\n+\t\t\treturn d;\n+\t\t}\n+\t}\n }",
    "output": "Fix try to handle exception in `RSTA.getPreferredSize()`"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n@@ -454,10 +454,10 @@ private void updateSelection(JTable table, Component comp, int column, boolean i\n \n \t\tprivate Component makeCell(JNode node, int column) {\n \t\t\tif (column == 0) {\n+\t\t\t\tlabel.disableHtml(node.disableHtml());\n \t\t\t\tlabel.setText(node.makeLongStringHtml());\n \t\t\t\tlabel.setToolTipText(node.getTooltip());\n \t\t\t\tlabel.setIcon(node.getIcon());\n-\t\t\t\tlabel.disableHtml(node.disableHtml());\n \t\t\t\treturn label;\n \t\t\t}\n \t\t\tif (!node.hasDescString()) {",
    "output": "Fix correct html disabling in search results"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/filedialog/CustomFileChooser.java\n@@ -12,6 +12,7 @@\n import javax.swing.JDialog;\n import javax.swing.JFileChooser;\n import javax.swing.JOptionPane;\n+import javax.swing.UIManager;\n import javax.swing.filechooser.FileNameExtensionFilter;\n \n import jadx.api.plugins.utils.CommonFileUtils;\n@@ -22,10 +23,16 @@\n \n class CustomFileChooser extends JFileChooser {\n \n+\tstatic {\n+\t\t// disable left shortcut panel, can crush in \"Win32ShellFolderManager2.getNetwork()\" or similar call\n+\t\tUIManager.put(\"FileChooser.noPlacesBar\", Boolean.TRUE);\n+\t}\n+\n \tprivate final FileDialogWrapper data;\n \n \tpublic CustomFileChooser(FileDialogWrapper data) {\n \t\tsuper(data.getCurrentDir() == null ? CommonFileUtils.CWD : data.getCurrentDir().toFile());\n+\t\tputClientProperty(\"FileChooser.useShellFolder\", Boolean.FALSE);\n \t\tthis.data = data;\n \t}",
    "output": "Fix disable `shell folders` in file open dialog"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/device/debugger/DebugController.java b/jadx-gui/src/main/java/jadx/gui/device/debugger/DebugController.java\n--- a/jadx-gui/src/main/java/jadx/gui/device/debugger/DebugController.java\n+++ b/jadx-gui/src/main/java/jadx/gui/device/debugger/DebugController.java\n@@ -44,11 +44,12 @@\n import jadx.gui.utils.NLS;\n \n public final class DebugController implements SmaliDebugger.SuspendListener, IDebugController {\n-\tprivate static final Logger LOG = LoggerFactory.getLogger(DebugController.class);\n \n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DebugController.class);\n \tprivate static final String ONCREATE_SIGNATURE = \"onCreate(Landroid/os/Bundle;)V\";\n \tprivate static final Map<String, RuntimeType> TYPE_MAP = new HashMap<>();\n \tprivate static final RuntimeType[] POSSIBLE_TYPES = { RuntimeType.OBJECT, RuntimeType.INT, RuntimeType.LONG };\n+\tprivate static final int DEFAULT_CACHE_SIZE = 512;\n \n \tprivate JDebuggerPanel debuggerPanel;\n \tprivate SmaliDebugger debugger;\n@@ -1115,7 +1116,7 @@ public class FrameNode implements IListElement {\n \t\tprivate long thisID;\n \n \t\tpublic FrameNode(long threadID, SmaliDebugger.Frame frame) {\n-\t\t\tcache = new StringBuilder(16);\n+\t\t\tcache = new StringBuilder(DEFAULT_CACHE_SIZE);\n \t\t\tthis.frame = frame;\n \t\t\tthis.threadID = threadID;\n \t\t\tregNodes = Collections.emptyList();\n@@ -1153,7 +1154,7 @@ public void setThisID(long thisID) {\n \t\tpublic void setSignatures(String clsSig, String mthSig) {\n \t\t\tthis.clsSig = clsSig;\n \t\t\tthis.mthSig = mthSig;\n-\t\t\tthis.cache.delete(0, this.cache.length());\n+\t\t\tresetCache();\n \t\t}\n \n \t\tpublic String getClsSig() {\n@@ -1167,7 +1168,7 @@ public String getMthSig() {\n \t\tpublic void updateCodeOffset(long codeOffset) {\n \t\t\tthis.codeOffset = codeOffset;\n \t\t\tif (this.codeOffset > -1) {\n-\t\t\t\tthis.cache.delete(0, this.cache.length());\n+\t\t\t\tresetCache();\n \t\t\t}\n \t\t}\n \n@@ -1209,27 +1210,34 @@ public void onSelected() {\n \t\t\t}\n \t\t}\n \n+\t\tprivate void resetCache() {\n+\t\t\t// Do not reuse thee existing cache instance as this can result in\n+\t\t\t// multi-threading access issues in case toString() method is active\n+\t\t\tthis.cache = new StringBuilder(DEFAULT_CACHE_SIZE);\n+\t\t}\n+\n \t\t@Override\n \t\tpublic String toString() {\n-\t\t\tif (cache.length() == 0) {\n+\t\t\tStringBuilder sbCache = cache;\n+\t\t\tif (sbCache.length() == 0) {\n \t\t\t\tlong off = getCodeOffset();\n \t\t\t\tif (off < 0) {\n-\t\t\t\t\tcache.append(String.format(\"index: %-4d \", off));\n+\t\t\t\t\tsbCache.append(String.format(\"index: %-4d \", off));\n \t\t\t\t} else {\n-\t\t\t\t\tcache.append(String.format(\"index: %04x \", off));\n+\t\t\t\t\tsbCache.append(String.format(\"index: %04x \", off));\n \t\t\t\t}\n \t\t\t\tif (clsSig == null) {\n-\t\t\t\t\tcache.append(\"clsID: \").append(frame.getClassID());\n+\t\t\t\t\tsbCache.append(\"clsID: \").append(frame.getClassID());\n \t\t\t\t} else {\n-\t\t\t\t\tcache.append(clsSig).append(\"->\");\n+\t\t\t\t\tsbCache.append(clsSig).append(\"->\");\n \t\t\t\t}\n \t\t\t\tif (mthSig == null) {\n-\t\t\t\t\tcache.append(\" mthID: \").append(frame.getMethodID());\n+\t\t\t\t\tsbCache.append(\" mthID: \").append(frame.getMethodID());\n \t\t\t\t} else {\n-\t\t\t\t\tcache.append(mthSig);\n+\t\t\t\t\tsbCache.append(mthSig);\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn cache.toString();\n+\t\t\treturn sbCache.toString();\n \t\t}\n \t}",
    "output": "Fix multi-threading issue in DebugController fixed"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n@@ -49,7 +49,7 @@ private void saveResources(ResContainer rc) {\n \tprivate void save(ResContainer rc, File outDir) {\n \t\tFile outFile = new File(outDir, rc.getFileName());\n \t\tif (!ZipSecurity.isInSubDirectory(outDir, outFile)) {\n-\t\t\tLOG.error(\"Path traversal attack detected, invalid resource name: {}\", outFile.getPath());\n+\t\t\tLOG.error(\"Invalid resource name or path traversal attack detected: {}\", outFile.getPath());\n \t\t\treturn;\n \t\t}\n \t\tsaveToFile(rc, outFile);\n\ndiff --git a/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/ZipSecurity.java b/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/ZipSecurity.java\n--- a/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/ZipSecurity.java\n+++ b/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/ZipSecurity.java\n@@ -53,10 +53,10 @@ public static boolean isValidZipEntryName(String entryName) {\n \t\t\tif (isInSubDirectoryInternal(currentPath, canonical)) {\n \t\t\t\treturn true;\n \t\t\t}\n-\t\t\tLOG.error(\"Path traversal attack detected, invalid name: {}\", entryName);\n+\t\t\tLOG.error(\"Invalid file name or path traversal attack detected: {}\", entryName);\n \t\t\treturn false;\n \t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Path traversal attack detected, invalid name: {}\", entryName);\n+\t\t\tLOG.error(\"Invalid file name or path traversal attack detected: {}\", entryName);\n \t\t\treturn false;\n \t\t}\n \t}",
    "output": "Fix improve logging messages for zip security errors"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -913,25 +913,20 @@ private boolean processIncompatiblePrimitives(MethodNode mth, SSAVar var) {\n \t\t}\n \n \t\tboolean fixed = false;\n-\t\tfor (ITypeBound bound : typeInfo.getBounds()) {\n-\t\t\tif (bound.getBound() == BoundEnum.USE\n-\t\t\t\t\t&& fixBooleanUsage(mth, bound)) {\n+\t\tfor (RegisterArg arg : new ArrayList<>(var.getUseList())) {\n+\t\t\tif (fixBooleanUsage(mth, arg)) {\n \t\t\t\tfixed = true;\n \t\t\t}\n \t\t}\n \t\treturn fixed;\n \t}\n \n-\tprivate boolean fixBooleanUsage(MethodNode mth, ITypeBound bound) {\n-\t\tArgType boundType = bound.getType();\n+\tprivate boolean fixBooleanUsage(MethodNode mth, RegisterArg boundArg) {\n+\t\tArgType boundType = boundArg.getInitType();\n \t\tif (boundType == ArgType.BOOLEAN\n \t\t\t\t|| (boundType.isTypeKnown() && !boundType.isPrimitive())) {\n \t\t\treturn false;\n \t\t}\n-\t\tRegisterArg boundArg = bound.getArg();\n-\t\tif (boundArg == null) {\n-\t\t\treturn false;\n-\t\t}\n \t\tInsnNode insn = boundArg.getParentInsn();\n \t\tif (insn == null || insn.getType() == InsnType.IF) {\n \t\t\treturn false;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToInt.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToInt.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToInt.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToInt.java\n@@ -6,6 +6,7 @@\n \n import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n \n+@SuppressWarnings(\"CommentedOutCode\")\n public class TestBooleanToInt extends SmaliTest {\n \n \t// @formatter:off\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToInt2.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToInt2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToInt2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToInt2.java\n@@ -0,0 +1,40 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+@SuppressWarnings(\"CommentedOutCode\")\n+public class TestBooleanToInt2 extends SmaliTest {\n+\n+\t// @formatter:off\n+\t/*\n+\t\tpublic static class TestCls {\n+\t\t\tpublic void test() {\n+\t\t\t\tboolean v = getValue();\n+\t\t\t\tuse1(Integer.valueOf(v));\n+\t\t\t\tuse2(v);\n+\t\t\t}\n+\n+\t\t\tprivate boolean getValue() {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tprivate void use1(Integer v) {\n+\t\t\t}\n+\n+\t\t\tprivate void use2(int v) {\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"use1(Integer.valueOf(value ? 1 : 0));\")\n+\t\t\t\t.containsOne(\"use2(value ? 1 : 0);\");\n+\t}\n+}",
    "output": "Fix correct fix for all use places of incompatible primitives"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -322,19 +322,25 @@ private boolean skipMethod(MethodNode mth) {\n \t\tif (inlineAttr == null || inlineAttr.notNeeded()) {\n \t\t\treturn false;\n \t\t}\n-\t\tif (mth.getUseIn().isEmpty()) {\n-\t\t\tmth.add(AFlag.DONT_GENERATE);\n-\t\t\treturn true;\n-\t\t}\n-\t\tList<MethodNode> useInCompleted = mth.getUseIn().stream()\n-\t\t\t\t.filter(m -> m.getTopParentClass().getState().isProcessComplete())\n-\t\t\t\t.collect(Collectors.toList());\n-\t\tif (useInCompleted.isEmpty()) {\n-\t\t\tmth.add(AFlag.DONT_GENERATE);\n-\t\t\treturn true;\n+\t\ttry {\n+\t\t\tif (mth.getUseIn().isEmpty()) {\n+\t\t\t\tmth.add(AFlag.DONT_GENERATE);\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tList<MethodNode> useInCompleted = mth.getUseIn().stream()\n+\t\t\t\t\t.filter(m -> m.getTopParentClass().getState().isProcessComplete())\n+\t\t\t\t\t.collect(Collectors.toList());\n+\t\t\tif (useInCompleted.isEmpty()) {\n+\t\t\t\tmth.add(AFlag.DONT_GENERATE);\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tmth.addDebugComment(\"Method not inlined, still used in: \" + useInCompleted);\n+\t\t\treturn false;\n+\t\t} catch (Exception e) {\n+\t\t\t// check failed => keep method\n+\t\t\tmth.addWarnComment(\"Failed to check method usage\", e);\n+\t\t\treturn false;\n \t\t}\n-\t\tmth.addDebugComment(\"Method not inlined, still used in: \" + useInCompleted);\n-\t\treturn false;\n \t}\n \n \tprivate boolean isMethodsPresents() {",
    "output": "Fix handle possible concurrent exception in method codegen"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -805,7 +805,9 @@ public void setCodegenDeps(List<ClassNode> codegenDeps) {\n \t}\n \n \tpublic void addCodegenDep(ClassNode dep) {\n-\t\tthis.codegenDeps = ListUtils.safeAdd(this.codegenDeps, dep);\n+\t\tif (!codegenDeps.contains(dep)) {\n+\t\t\tthis.codegenDeps = ListUtils.safeAdd(this.codegenDeps, dep);\n+\t\t}\n \t}\n \n \tpublic int getTotalDepsCount() {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessMethodsForInline.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessMethodsForInline.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessMethodsForInline.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessMethodsForInline.java\n@@ -1,12 +1,12 @@\n package jadx.core.dex.visitors;\n \n+import jadx.core.Consts;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.visitors.usage.UsageInfoVisitor;\n-import jadx.core.utils.ListUtils;\n import jadx.core.utils.exceptions.JadxException;\n \n @JadxVisitor(\n@@ -45,7 +45,14 @@ private static boolean canInline(MethodNode mth) {\n \t\t}\n \t\tAccessInfo accessFlags = mth.getAccessFlags();\n \t\tboolean isSynthetic = accessFlags.isSynthetic() || mth.getName().contains(\"$\");\n-\t\treturn isSynthetic && (accessFlags.isStatic() || mth.isConstructor());\n+\t\treturn isSynthetic && canInlineMethod(mth, accessFlags);\n+\t}\n+\n+\tprivate static boolean canInlineMethod(MethodNode mth, AccessInfo accessFlags) {\n+\t\tif (accessFlags.isStatic()) {\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn mth.isConstructor() && mth.root().getArgs().isInlineAnonymousClasses();\n \t}\n \n \tprivate static void fixClassDependencies(MethodNode mth) {\n@@ -54,8 +61,14 @@ private static void fixClassDependencies(MethodNode mth) {\n \t\t\t// remove possible cross dependency\n \t\t\t// to force class with inline method to be processed before its usage\n \t\t\tClassNode useTopCls = useInMth.getTopParentClass();\n-\t\t\tparentClass.setDependencies(ListUtils.safeRemoveAndTrim(parentClass.getDependencies(), useTopCls));\n-\t\t\tuseTopCls.addCodegenDep(parentClass);\n+\t\t\tif (useTopCls != parentClass) {\n+\t\t\t\tparentClass.removeDependency(useTopCls);\n+\t\t\t\tuseTopCls.addCodegenDep(parentClass);\n+\t\t\t\tif (Consts.DEBUG_USAGE) {\n+\t\t\t\t\tparentClass.addDebugComment(\"Remove dependency: \" + useTopCls + \" to inline \" + mth);\n+\t\t\t\t\tuseTopCls.addDebugComment(\"Add dependency: \" + parentClass + \" to inline \" + mth);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t}\n }",
    "output": "Fix don't mark constructor for inline if anonymous class inline is disabled"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java\n@@ -3,8 +3,10 @@\n import java.util.List;\n \n import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.nodes.IContainer;\n import jadx.core.dex.nodes.IRegion;\n+import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.regions.Region;\n import jadx.core.dex.regions.conditions.IfCondition;\n@@ -45,7 +47,7 @@ public boolean enterRegion(MethodNode mth, IRegion region) {\n \t\t}\n \t}\n \n-\t@SuppressWarnings(\"UnnecessaryReturnStatement\")\n+\t@SuppressWarnings({ \"UnnecessaryReturnStatement\", \"StatementWithEmptyBody\" })\n \tprivate static void orderBranches(MethodNode mth, IfRegion ifRegion) {\n \t\tif (RegionUtils.isEmpty(ifRegion.getElseRegion())) {\n \t\t\treturn;\n@@ -79,9 +81,15 @@ private static void orderBranches(MethodNode mth, IfRegion ifRegion) {\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tboolean lastRegion = ifRegion == RegionUtils.getLastRegion(mth.getRegion());\n+\t\t\tboolean lastRegion = RegionUtils.hasExitEdge(ifRegion);\n \t\t\tif (elseSize == 1 && lastRegion && mth.isVoidReturn()) {\n-\t\t\t\t// single return at method end will be removed later\n+\t\t\t\tInsnNode lastElseInsn = RegionUtils.getLastInsn(ifRegion.getElseRegion());\n+\t\t\t\tif (lastElseInsn != null && lastElseInsn.getType() == InsnType.THROW) {\n+\t\t\t\t\t// move `throw` into `then` block\n+\t\t\t\t\tinvertIfRegion(ifRegion);\n+\t\t\t\t} else {\n+\t\t\t\t\t// single return at method end will be removed later\n+\t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tif (!lastRegion) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java b/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java\n@@ -146,20 +146,6 @@ public static IBlock getLastBlock(IContainer container) {\n \t\t}\n \t}\n \n-\t@Nullable\n-\tpublic static IContainer getLastRegion(@Nullable IContainer container) {\n-\t\tif (container == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tif (container instanceof IBlock || container instanceof IBranchRegion) {\n-\t\t\treturn container;\n-\t\t}\n-\t\tif (container instanceof IRegion) {\n-\t\t\treturn getLastRegion(Utils.last(((IRegion) container).getSubBlocks()));\n-\t\t}\n-\t\tthrow new JadxRuntimeException(unknownContainerType(container));\n-\t}\n-\n \tpublic static boolean isExitBlock(MethodNode mth, IContainer container) {\n \t\tif (container instanceof BlockNode) {\n \t\t\treturn BlockUtils.isExitBlock(mth, (BlockNode) container);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestElseIfCodeStyle.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestElseIfCodeStyle.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestElseIfCodeStyle.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestElseIfCodeStyle.java\n@@ -0,0 +1,37 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.api.ICodeWriter;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestElseIfCodeStyle extends IntegrationTest {\n+\n+\t@SuppressWarnings(\"unused\")\n+\tpublic static class TestCls {\n+\n+\t\tpublic void test(String str) {\n+\t\t\tif (\"a\".equals(str)) {\n+\t\t\t\tcall(1);\n+\t\t\t} else if (\"b\".equals(str)) {\n+\t\t\t\tcall(2);\n+\t\t\t} else if (\"c\".equals(str)) {\n+\t\t\t\tcall(3);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void call(int i) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"!\\\"c\\\".equals(str)\")\n+\t\t\t\t.doesNotContain(\"{\" + ICodeWriter.NL + indent(2) + \"} else {\"); // no empty `then` block\n+\t}\n+}",
    "output": "Fix handle empty block at end of `else-if` chain"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n@@ -14,6 +14,9 @@\n import jadx.core.codegen.json.JsonMappingGen;\n import jadx.core.deobf.Deobfuscator;\n import jadx.core.deobf.NameMapper;\n+import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.attributes.nodes.MethodOverrideAttr;\n import jadx.core.dex.attributes.nodes.RenameReasonAttr;\n import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.info.FieldInfo;\n@@ -195,14 +198,31 @@ private static void checkMethods(Deobfuscator deobfuscator, ClassNode cls, JadxA\n \t\t\tSet<String> names = new HashSet<>(methods.size());\n \t\t\tfor (MethodNode mth : methods) {\n \t\t\t\tString signature = mth.getMethodInfo().makeSignature(true, false);\n-\t\t\t\tif (!names.add(signature)) {\n+\t\t\t\tif (!names.add(signature) && canRename(mth)) {\n \t\t\t\t\tdeobfuscator.forceRenameMethod(mth);\n \t\t\t\t\tmth.addAttr(new RenameReasonAttr(\"collision with other method in class\"));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n+\tprivate static boolean canRename(MethodNode mth) {\n+\t\tif (mth.contains(AFlag.DONT_RENAME)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tMethodOverrideAttr overrideAttr = mth.get(AType.METHOD_OVERRIDE);\n+\t\tif (overrideAttr != null) {\n+\t\t\tfor (MethodNode relatedMth : overrideAttr.getRelatedMthNodes()) {\n+\t\t\t\tif (relatedMth != mth && mth.getParentClass().equals(relatedMth.getParentClass())) {\n+\t\t\t\t\t// ignore rename if exists related method from same class (bridge method in most cases)\n+\t\t\t\t\t// such rename will also rename current method and will not help to resolve name collision\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n \tprivate static void processRootPackages(Deobfuscator deobfuscator, RootNode root, List<ClassNode> classes) {\n \t\tSet<String> rootPkgs = collectRootPkgs(classes);\n \t\troot.getCacheStorage().setRootPkgs(rootPkgs);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inline/TestSyntheticBridgeRename.java b/jadx-core/src/test/java/jadx/tests/integration/inline/TestSyntheticBridgeRename.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inline/TestSyntheticBridgeRename.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inline/TestSyntheticBridgeRename.java\n@@ -0,0 +1,47 @@\n+package jadx.tests.integration.inline;\n+\n+import org.assertj.core.api.Condition;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.extensions.profiles.TestProfile;\n+import jadx.tests.api.extensions.profiles.TestWithProfiles;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestSyntheticBridgeRename extends IntegrationTest {\n+\n+\t@SuppressWarnings(\"InnerClassMayBeStatic\")\n+\tpublic static class TestCls {\n+\t\tprivate abstract class Inner<V> {\n+\t\t\tpublic abstract V get(String value);\n+\t\t}\n+\n+\t\tpublic class IntInner extends Inner<Integer> {\n+\t\t\tpublic Integer get(String value) {\n+\t\t\t\treturn value.length();\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void test() {\n+\t\t\tIntInner inner = new IntInner();\n+\t\t\tcall(inner.get(\"a\"));\n+\t\t}\n+\n+\t\tprivate static void call(Integer value) {\n+\t\t}\n+\t}\n+\n+\t@TestWithProfiles({ TestProfile.DX_J8, TestProfile.JAVA8 })\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tassertThat(searchCls(cls.getInnerClasses(), \"IntInner\").getMethods())\n+\t\t\t\t.as(\"check that bridge method was generated by compiler\")\n+\t\t\t\t.haveAtLeastOne(new Condition<>(mth -> mth.getAccessFlags().isBridge(), \"bridge\"));\n+\n+\t\tassertThat(cls)\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"mo0get\")\n+\t\t\t\t.containsOne(\"call(inner.get(\\\"a\\\"));\");\n+\t}\n+}",
    "output": "Fix don't rename bridged overridden methods"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n@@ -28,9 +28,12 @@ protected ParserConstants() {\n \tprotected static final int RES_XML_LAST_CHUNK_TYPE = 0x017f;\n \tprotected static final int RES_XML_RESOURCE_MAP_TYPE = 0x0180;\n \n-\tprotected static final int RES_TABLE_PACKAGE_TYPE = 0x0200;\n-\tprotected static final int RES_TABLE_TYPE_TYPE = 0x0201;\n-\tprotected static final int RES_TABLE_TYPE_SPEC_TYPE = 0x0202;\n+\tprotected static final int RES_TABLE_PACKAGE_TYPE = 0x0200; // 512\n+\tprotected static final int RES_TABLE_TYPE_TYPE = 0x0201; // 513\n+\tprotected static final int RES_TABLE_TYPE_SPEC_TYPE = 0x0202; // 514\n+\tprotected static final int RES_TABLE_TYPE_LIBRARY = 0x0203; // 515\n+\tprotected static final int RES_TABLE_TYPE_OVERLAY = 0x0204; // 516\n+\tprotected static final int RES_TABLE_TYPE_STAGED_ALIAS = 0x0206; // 517\n \n \t/**\n \t * Type constants\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -153,13 +153,28 @@ private PackageChunk parsePackage() throws IOException {\n \t\twhile (is.getPos() < endPos) {\n \t\t\tlong chunkStart = is.getPos();\n \t\t\tint type = is.readInt16();\n-\t\t\tif (type == RES_NULL_TYPE) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tif (type == RES_TABLE_TYPE_SPEC_TYPE) {\n-\t\t\t\tparseTypeSpecChunk();\n-\t\t\t} else if (type == RES_TABLE_TYPE_TYPE) {\n-\t\t\t\tparseTypeChunk(chunkStart, pkg);\n+\t\t\tLOG.trace(\"res package chunk start at {} type {}\", chunkStart, type);\n+\t\t\tswitch (type) {\n+\t\t\t\tcase RES_NULL_TYPE:\n+\t\t\t\t\tLOG.info(\"Null chunk type encountered at offset {}\", chunkStart);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase RES_TABLE_TYPE_TYPE: // 0x0201\n+\t\t\t\t\tparseTypeChunk(chunkStart, pkg);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase RES_TABLE_TYPE_SPEC_TYPE: // 0x0202\n+\t\t\t\t\tparseTypeSpecChunk(chunkStart);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase RES_TABLE_TYPE_LIBRARY: // 0x0203\n+\t\t\t\t\tparseLibraryTypeChunk(chunkStart);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase RES_TABLE_TYPE_OVERLAY: // 0x0204\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tString.format(\"Encountered unsupported chunk type TYPE_OVERLAY at offset 0x%x \", chunkStart));\n+\t\t\t\tcase RES_TABLE_TYPE_STAGED_ALIAS: // 0x0206\n+\t\t\t\t\tthrow new IOException(\n+\t\t\t\t\t\t\tString.format(\"Encountered unsupported chunk type TYPE_STAGED_ALIAS at offset 0x%x \", chunkStart));\n+\t\t\t\tdefault:\n+\t\t\t\t\tLOG.warn(\"Unknown chunk type {} encountered at offset {}\", type, chunkStart);\n \t\t\t}\n \t\t}\n \t\treturn pkg;\n@@ -192,17 +207,39 @@ private String makeNewKeyName(int idx) {\n \t}\n \n \t@SuppressWarnings(\"unused\")\n-\tprivate void parseTypeSpecChunk() throws IOException {\n+\tprivate void parseTypeSpecChunk(long chunkStart) throws IOException {\n \t\tis.checkInt16(0x0010, \"Unexpected type spec header size\");\n-\t\t/* int size = */\n-\t\tis.readInt32();\n+\t\tint chunkSize = is.readInt32();\n+\t\tlong expectedEndPos = chunkStart + chunkSize;\n \n \t\tint id = is.readInt8();\n \t\tis.skip(3);\n \t\tint entryCount = is.readInt32();\n \t\tfor (int i = 0; i < entryCount; i++) {\n \t\t\tint entryFlag = is.readInt32();\n \t\t}\n+\t\tif (is.getPos() != expectedEndPos) {\n+\t\t\tthrow new IOException(String.format(\"Error reading type spec chunk at offset 0x%x\", chunkStart));\n+\t\t}\n+\t}\n+\n+\tprivate void parseLibraryTypeChunk(long chunkStart) throws IOException {\n+\t\tLOG.trace(\"parsing library type chunk starting at offset {}\", chunkStart);\n+\t\tis.checkInt16(12, \"Unexpected header size\");\n+\t\tint chunkSize = is.readInt32();\n+\t\tlong expectedEndPos = chunkStart + chunkSize;\n+\t\tint count = is.readInt32();\n+\t\tfor (int i = 0; i < count; i++) {\n+\t\t\tint packageId = is.readInt32();\n+\t\t\tString packageName = is.readString16Fixed(128);\n+\t\t\tLOG.info(\"Found resource shared library {}, pkgId: {}\", packageName, packageId);\n+\t\t\tif (is.getPos() > expectedEndPos) {\n+\t\t\t\tthrow new IOException(\"reading after chunk end\");\n+\t\t\t}\n+\t\t}\n+\t\tif (is.getPos() != expectedEndPos) {\n+\t\t\tthrow new IOException(String.format(\"Error reading library chunk at offset 0x%x\", chunkStart));\n+\t\t}\n \t}\n \n \tprivate void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n@@ -241,6 +278,13 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t\t\t\tparseEntry(pkg, id, i, config.getQualifiers());\n \t\t\t}\n \t\t}\n+\t\tif (chunkEnd > is.getPos()) {\n+\t\t\t// Skip remaining unknown data in this chunk (e.g. type 8 entries\")\n+\t\t\tlong skipSize = chunkEnd - is.getPos();\n+\t\t\tLOG.debug(\"Unknown data at the end of type chunk encountered, skipping {} bytes and continuing at offset {}\", skipSize,\n+\t\t\t\t\tchunkEnd);\n+\t\t\tis.skip(skipSize);\n+\t\t}\n \t}\n \n \tprivate void parseEntry(PackageChunk pkg, int typeId, int entryId, String config) throws IOException {",
    "output": "Fix implemented parsing RES_TABLE_TYPE_LIBRARY chunks * core: Implemented parsing RES_TABLE_TYPE_LIBRARY chunks * skip unknown data at the end of type chunk"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/LogViewerDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/LogViewerDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/LogViewerDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/LogViewerDialog.java\n@@ -2,11 +2,13 @@\n \n import java.awt.BorderLayout;\n import java.awt.Container;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n \n import javax.swing.BorderFactory;\n import javax.swing.JButton;\n import javax.swing.JComboBox;\n-import javax.swing.JDialog;\n+import javax.swing.JFrame;\n import javax.swing.JLabel;\n import javax.swing.JPanel;\n import javax.swing.JScrollPane;\n@@ -20,51 +22,72 @@\n import jadx.gui.ui.MainWindow;\n import jadx.gui.ui.codearea.AbstractCodeArea;\n import jadx.gui.utils.NLS;\n+import jadx.gui.utils.UiUtils;\n import jadx.gui.utils.logs.ILogListener;\n import jadx.gui.utils.logs.LogCollector;\n \n-public class LogViewerDialog extends JDialog {\n+public class LogViewerDialog extends JFrame {\n \tprivate static final long serialVersionUID = -2188700277429054641L;\n \tprivate static final Level[] LEVEL_ITEMS = { Level.DEBUG, Level.INFO, Level.WARN, Level.ERROR };\n \n \tprivate static Level level = Level.WARN;\n \n \tprivate final transient JadxSettings settings;\n \tprivate transient RSyntaxTextArea textPane;\n+\tprivate JComboBox<Level> levelCb;\n+\n+\tprivate static LogViewerDialog openLogDialog;\n \n \tpublic static void open(MainWindow mainWindow) {\n \t\topenWithLevel(mainWindow, level);\n \t}\n \n \tpublic static void openWithLevel(MainWindow mainWindow, Level newLevel) {\n \t\tlevel = newLevel;\n-\t\tnew LogViewerDialog(mainWindow).setVisible(true);\n+\t\tif (openLogDialog == null) {\n+\t\t\tLogViewerDialog newLogDialog = new LogViewerDialog(mainWindow);\n+\t\t\tnewLogDialog.setVisible(true);\n+\t\t\topenLogDialog = newLogDialog;\n+\t\t} else {\n+\t\t\tLogViewerDialog logDialog = openLogDialog;\n+\t\t\tlogDialog.levelCb.setSelectedItem(level);\n+\t\t\tlogDialog.setVisible(true);\n+\t\t\tlogDialog.toFront();\n+\t\t}\n \t}\n \n \tprivate LogViewerDialog(MainWindow mainWindow) {\n \t\tthis.settings = mainWindow.getSettings();\n \t\tinitUI(mainWindow);\n \t\tregisterLogListener();\n \t\tsettings.loadWindowPos(this);\n+\t\taddWindowListener(new WindowAdapter() {\n+\t\t\t@Override\n+\t\t\tpublic void windowClosing(WindowEvent e) {\n+\t\t\t\topenLogDialog = null;\n+\t\t\t}\n+\t\t});\n \t}\n \n \tpublic final void initUI(MainWindow mainWindow) {\n+\t\tUiUtils.setWindowIcons(this);\n+\n \t\ttextPane = AbstractCodeArea.getDefaultArea(mainWindow);\n \t\ttextPane.setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));\n \n \t\tJPanel controlPane = new JPanel();\n \t\tcontrolPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n-\t\tfinal JComboBox<Level> cb = new JComboBox<>(LEVEL_ITEMS);\n-\t\tcb.setSelectedItem(level);\n-\t\tcb.addActionListener(e -> {\n-\t\t\tint i = cb.getSelectedIndex();\n+\t\tlevelCb = new JComboBox<>(LEVEL_ITEMS);\n+\t\tlevelCb.setSelectedItem(level);\n+\t\tlevelCb.addActionListener(e -> {\n+\t\t\tint i = levelCb.getSelectedIndex();\n \t\t\tlevel = LEVEL_ITEMS[i];\n \t\t\tregisterLogListener();\n \t\t});\n \t\tJLabel levelLabel = new JLabel(NLS.str(\"log_viewer.log_level\"));\n-\t\tlevelLabel.setLabelFor(cb);\n+\t\tlevelLabel.setLabelFor(levelCb);\n \t\tcontrolPane.add(levelLabel);\n-\t\tcontrolPane.add(cb);\n+\t\tcontrolPane.add(levelCb);\n \n \t\tJScrollPane scrollPane = new JScrollPane(textPane);\n \n@@ -81,7 +104,6 @@ public final void initUI(MainWindow mainWindow) {\n \t\tpack();\n \t\tsetSize(800, 600);\n \t\tsetDefaultCloseOperation(DISPOSE_ON_CLOSE);\n-\t\tsetModalityType(ModalityType.MODELESS);\n \t\tsetLocationRelativeTo(null);\n \t}",
    "output": "Fix improve log viewer dialog"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n@@ -150,11 +150,16 @@ protected void openItem(JNode node) {\n \n \t@Nullable\n \tprivate JNode getSelectedNode() {\n-\t\tint selectedId = resultsTable.getSelectedRow();\n-\t\tif (selectedId == -1) {\n+\t\ttry {\n+\t\t\tint selectedId = resultsTable.getSelectedRow();\n+\t\t\tif (selectedId == -1 || selectedId >= resultsTable.getRowCount()) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn (JNode) resultsModel.getValueAt(selectedId, 0);\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"Failed to get results table selected object\", e);\n \t\t\treturn null;\n \t\t}\n-\t\treturn (JNode) resultsModel.getValueAt(selectedId, 0);\n \t}\n \n \t@Override",
    "output": "Fix additional checks on open search result"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n@@ -222,6 +222,10 @@ private static MethodNode checkUsage(ClassNode cls) {\n \t\t\t// exclude self usage\n \t\t\treturn null;\n \t\t}\n+\t\tif (ctrUseCls.getTopParentClass().equals(cls)) {\n+\t\t\t// exclude usage inside inner classes\n+\t\t\treturn null;\n+\t\t}\n \t\tfor (MethodNode mth : cls.getMethods()) {\n \t\t\tif (mth == ctr) {\n \t\t\t\tcontinue;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass20.java b/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass20.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass20.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass20.java\n@@ -0,0 +1,39 @@\n+package jadx.tests.integration.inner;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.api.JadxInternalAccess;\n+import jadx.api.JavaClass;\n+import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestAnonymousClass20 extends IntegrationTest {\n+\n+\t@SuppressWarnings({ \"unused\", \"checkstyle:TypeName\", \"Convert2Lambda\", \"Anonymous2MethodRef\" })\n+\tpublic static class Test$Cls {\n+\t\tpublic Runnable test() {\n+\t\t\treturn new Runnable() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void run() {\n+\t\t\t\t\tnew Test$Cls();\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(Test$Cls.class);\n+\t\tassertThat(cls.get(AType.ANONYMOUS_CLASS)).isNull();\n+\n+\t\tJavaClass javaClass = JadxInternalAccess.convertClassNode(jadxDecompiler, cls);\n+\t\tassertThat(javaClass.getTopParentClass()).isEqualTo(javaClass);\n+\n+\t\tassertThat(cls)\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"new TestAnonymousClass20$Test$Cls();\");\n+\t}\n+}",
    "output": "Fix don't inline anonymous in self inner class"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -469,6 +469,9 @@ public List<FieldNode> getFields() {\n \t}\n \n \tpublic void addField(FieldNode fld) {\n+\t\tif (fields == null || fields.isEmpty()) {\n+\t\t\tfields = new ArrayList<>(1);\n+\t\t}\n \t\tfields.add(fld);\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n@@ -129,7 +129,7 @@ private static void addResourceFields(ClassNode resCls, ResourceStorage resStora\n \t\t\t\tFieldNode newResField = new FieldNode(typeCls, rFieldInfo,\n \t\t\t\t\t\tAccessFlags.PUBLIC | AccessFlags.STATIC | AccessFlags.FINAL);\n \t\t\t\tnewResField.addAttr(new EncodedValue(EncodedType.ENCODED_INT, resource.getId()));\n-\t\t\t\ttypeCls.getFields().add(newResField);\n+\t\t\t\ttypeCls.addField(newResField);\n \t\t\t\tif (rClsExists) {\n \t\t\t\t\tnewResField.addInfoComment(\"Added by JADX\");\n \t\t\t\t}",
    "output": "Fix UnsupportedOperationException on adding a field"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -132,6 +132,7 @@\n import jadx.gui.update.data.Release;\n import jadx.gui.utils.CacheObject;\n import jadx.gui.utils.FontUtils;\n+import jadx.gui.utils.ILoadListener;\n import jadx.gui.utils.Icons;\n import jadx.gui.utils.LafManager;\n import jadx.gui.utils.Link;\n@@ -211,6 +212,9 @@ public class MainWindow extends JFrame {\n \tprivate JDebuggerPanel debuggerPanel;\n \tprivate JSplitPane verticalSplitter;\n \n+\tprivate List<ILoadListener> loadListeners = new ArrayList<>();\n+\tprivate boolean loaded;\n+\n \tpublic MainWindow(JadxSettings settings) {\n \t\tthis.settings = settings;\n \t\tthis.cacheObject = new CacheObject();\n@@ -488,6 +492,7 @@ private void saveAll() {\n \t}\n \n \tprivate void closeAll() {\n+\t\tnotifyLoadListeners(false);\n \t\tcancelBackgroundJobs();\n \t\tclearTree();\n \t\tresetCache();\n@@ -526,7 +531,10 @@ private void onOpen() {\n \n \t\tbackgroundExecutor.execute(NLS.str(\"progress.load\"),\n \t\t\t\tthis::restoreOpenTabs,\n-\t\t\t\tstatus -> runInitialBackgroundJobs());\n+\t\t\t\tstatus -> {\n+\t\t\t\t\trunInitialBackgroundJobs();\n+\t\t\t\t\tnotifyLoadListeners(true);\n+\t\t\t\t});\n \t}\n \n \tpublic void updateLiveReload(boolean state) {\n@@ -1210,6 +1218,22 @@ public void actionPerformed(ActionEvent e) {\n \t\ttoolbar.add(updateLink);\n \n \t\tmainPanel.add(toolbar, BorderLayout.NORTH);\n+\n+\t\taddLoadListener(loaded -> {\n+\t\t\ttextSearchAction.setEnabled(loaded);\n+\t\t\tclsSearchAction.setEnabled(loaded);\n+\t\t\tcommentSearchAction.setEnabled(loaded);\n+\t\t\tbackAction.setEnabled(loaded);\n+\t\t\tforwardAction.setEnabled(loaded);\n+\t\t\tsyncAction.setEnabled(loaded);\n+\t\t\tsaveAllAction.setEnabled(loaded);\n+\t\t\texportAction.setEnabled(loaded);\n+\t\t\tsaveProjectAsAction.setEnabled(loaded);\n+\t\t\treload.setEnabled(loaded);\n+\t\t\tdeobfAction.setEnabled(loaded);\n+\t\t\tquarkAction.setEnabled(loaded);\n+\t\t\treturn false;\n+\t\t});\n \t}\n \n \tprivate void initUI() {\n@@ -1499,6 +1523,17 @@ private void saveSplittersInfo() {\n \t\tsettings.setDebuggerVarTreeSplitterLoc(debuggerPanel.getRightSplitterLocation());\n \t}\n \n+\tpublic void addLoadListener(ILoadListener loadListener) {\n+\t\tthis.loadListeners.add(loadListener);\n+\t\t// set initial value\n+\t\tloadListener.update(loaded);\n+\t}\n+\n+\tpublic void notifyLoadListeners(boolean loaded) {\n+\t\tthis.loaded = loaded;\n+\t\tloadListeners.removeIf(listener -> listener.update(loaded));\n+\t}\n+\n \tpublic JadxWrapper getWrapper() {\n \t\treturn wrapper;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FindUsageAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FindUsageAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FindUsageAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FindUsageAction.java\n@@ -3,6 +3,7 @@\n import java.awt.event.KeyEvent;\n \n import jadx.gui.treemodel.JNode;\n+import jadx.gui.ui.MainWindow;\n import jadx.gui.ui.dialog.UsageDialog;\n import jadx.gui.utils.NLS;\n \n@@ -18,7 +19,15 @@ public FindUsageAction(CodeArea codeArea) {\n \n \t@Override\n \tpublic void runAction(JNode node) {\n-\t\tUsageDialog usageDialog = new UsageDialog(getCodeArea().getMainWindow(), node);\n+\t\tMainWindow mw = getCodeArea().getMainWindow();\n+\t\tUsageDialog usageDialog = new UsageDialog(mw, node);\n+\t\tmw.addLoadListener(loaded -> {\n+\t\t\tif (!loaded) {\n+\t\t\t\tusageDialog.dispose();\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n \t\tusageDialog.setVisible(true);\n \t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n@@ -81,17 +81,28 @@ public class SearchDialog extends CommonSearchDialog {\n \n \tpublic static void search(MainWindow window, SearchPreset preset) {\n \t\tSearchDialog searchDialog = new SearchDialog(window, preset, Collections.emptySet());\n-\t\tsearchDialog.setVisible(true);\n+\t\tshow(searchDialog, window);\n \t}\n \n \tpublic static void searchInActiveTab(MainWindow window, SearchPreset preset) {\n \t\tSearchDialog searchDialog = new SearchDialog(window, preset, EnumSet.of(SearchOptions.ACTIVE_TAB));\n-\t\tsearchDialog.setVisible(true);\n+\t\tshow(searchDialog, window);\n \t}\n \n \tpublic static void searchText(MainWindow window, String text) {\n \t\tSearchDialog searchDialog = new SearchDialog(window, SearchPreset.TEXT, Collections.emptySet());\n \t\tsearchDialog.initSearchText = text;\n+\t\tshow(searchDialog, window);\n+\t}\n+\n+\tprivate static void show(SearchDialog searchDialog, MainWindow mw) {\n+\t\tmw.addLoadListener(loaded -> {\n+\t\t\tif (!loaded) {\n+\t\t\t\tsearchDialog.dispose();\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t});\n \t\tsearchDialog.setVisible(true);\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/ILoadListener.java b/jadx-gui/src/main/java/jadx/gui/utils/ILoadListener.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/ILoadListener.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/ILoadListener.java\n@@ -0,0 +1,11 @@\n+package jadx.gui.utils;\n+\n+public interface ILoadListener {\n+\n+\t/**\n+\t * Update files/project loaded state\n+\t *\n+\t * @return true to remove listener\n+\t */\n+\tboolean update(boolean loaded);\n+}",
    "output": "Fix disable actions if files not loaded"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/CommonSearchDialog.java\n@@ -420,6 +420,9 @@ public ResultsTableCellRenderer() {\n \t\t@Override\n \t\tpublic Component getTableCellRendererComponent(JTable table, Object obj,\n \t\t\t\tboolean isSelected, boolean hasFocus, int row, int column) {\n+\t\t\tif (obj == null || table == null) {\n+\t\t\t\treturn emptyLabel;\n+\t\t\t}\n \t\t\tComponent comp = makeCell((JNode) obj, column);\n \t\t\tupdateSelection(table, comp, column, isSelected);\n \t\t\treturn comp;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n@@ -553,6 +553,7 @@ private void prepareForSearch() {\n \t}\n \n \tprivate void addSearchResult(JNode node) {\n+\t\tObjects.requireNonNull(node);\n \t\tsynchronized (pendingResults) {\n \t\t\tUiUtils.notUiThreadGuard();\n \t\t\tpendingResults.add(node);",
    "output": "Fix handle null value in TableCellRenderer"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n@@ -13,6 +13,7 @@\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n import java.security.MessageDigest;\n import java.util.ArrayList;\n import java.util.Comparator;\n@@ -228,7 +229,8 @@ public static void close(Closeable c) {\n \n \tpublic static void writeFile(Path file, String data) throws IOException {\n \t\tFileUtils.makeDirsForFile(file);\n-\t\tFiles.write(file, data.getBytes(StandardCharsets.UTF_8));\n+\t\tFiles.write(file, data.getBytes(StandardCharsets.UTF_8),\n+\t\t\t\tStandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n \t}\n \n \tpublic static String readFile(Path textFile) throws IOException {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java b/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java\n@@ -15,6 +15,7 @@\n import java.nio.file.Paths;\n import java.nio.file.attribute.FileTime;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -30,6 +31,7 @@\n import jadx.api.ICodeInfo;\n import jadx.api.JadxArgs;\n import jadx.core.Jadx;\n+import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n@@ -42,7 +44,7 @@\n public class DiskCodeCache implements ICodeCache {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(DiskCodeCache.class);\n \n-\tprivate static final int DATA_FORMAT_VERSION = 12;\n+\tprivate static final int DATA_FORMAT_VERSION = 13;\n \n \tprivate static final byte[] JADX_NAMES_MAP_HEADER = \"jadxnm\".getBytes(StandardCharsets.US_ASCII);\n \n@@ -55,6 +57,7 @@ public class DiskCodeCache implements ICodeCache {\n \tprivate final ExecutorService writePool;\n \tprivate final Map<String, ICodeInfo> writeOps = new ConcurrentHashMap<>();\n \tprivate final Map<String, Integer> namesMap = new ConcurrentHashMap<>();\n+\tprivate final Map<String, Integer> allClsIds;\n \n \tpublic DiskCodeCache(RootNode root, Path baseDir) {\n \t\tsrcDir = baseDir.resolve(\"sources\");\n@@ -65,6 +68,7 @@ public DiskCodeCache(RootNode root, Path baseDir) {\n \t\tcodeVersion = buildCodeVersion(args);\n \t\twritePool = Executors.newFixedThreadPool(args.getThreadsCount());\n \t\tcodeMetadataAdapter = new CodeMetadataAdapter(root);\n+\t\tallClsIds = buildClassIdsMap(root.getClasses());\n \t\tif (checkCodeVersion()) {\n \t\t\tloadNamesMap();\n \t\t} else {\n@@ -112,6 +116,7 @@ private void reset() {\n \tpublic void add(String clsFullName, ICodeInfo codeInfo) {\n \t\twriteOps.put(clsFullName, codeInfo);\n \t\tint clsId = getClsId(clsFullName);\n+\t\tnamesMap.put(clsFullName, clsId);\n \t\twritePool.execute(() -> {\n \t\t\ttry {\n \t\t\t\tFileUtils.writeFile(getJavaFile(clsId), codeInfo.getCodeStr());\n@@ -218,7 +223,11 @@ private String buildInputsHash(List<File> inputs) {\n \t}\n \n \tprivate int getClsId(String clsFullName) {\n-\t\treturn namesMap.computeIfAbsent(clsFullName, n -> namesMap.size());\n+\t\tInteger id = allClsIds.get(clsFullName);\n+\t\tif (id == null) {\n+\t\t\tthrow new JadxRuntimeException(\"Unknown class name: \" + clsFullName);\n+\t\t}\n+\t\treturn id;\n \t}\n \n \tprivate void saveNamesMap() {\n@@ -250,6 +259,13 @@ private void loadNamesMap() {\n \t\t\t\tString clsName = in.readUTF();\n \t\t\t\tint clsId = in.readInt();\n \t\t\t\tnamesMap.put(clsName, clsId);\n+\t\t\t\tInteger prevId = allClsIds.get(clsName);\n+\t\t\t\tif (prevId == null || prevId != clsId) {\n+\t\t\t\t\tLOG.debug(\"Unexpected class id, got: {}, expect: {}\", clsId, prevId);\n+\t\t\t\t\tLOG.warn(\"Inconsistent disk cache, resetting...\");\n+\t\t\t\t\treset();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n \t\t\t}\n \t\t\tLOG.info(\"Found {} classes in disk cache, dir: {}\", count, metaDir.getParent());\n \t\t} catch (Exception e) {\n@@ -271,6 +287,16 @@ private Path getPathForClsId(int clsId, String ext) {\n \t\treturn Paths.get(firstByte, FileUtils.intToHex(clsId) + ext);\n \t}\n \n+\tprivate Map<String, Integer> buildClassIdsMap(List<ClassNode> classes) {\n+\t\tint clsCount = classes.size();\n+\t\tMap<String, Integer> map = new HashMap<>(clsCount);\n+\t\tfor (int i = 0; i < clsCount; i++) {\n+\t\t\tClassNode cls = classes.get(i);\n+\t\t\tmap.put(cls.getRawName(), i);\n+\t\t}\n+\t\treturn map;\n+\t}\n+\n \t@SuppressWarnings(\"ResultOfMethodCallIgnored\")\n \t@Override\n \tpublic void close() throws IOException {",
    "output": "Fix handle possible classes overlap in disk cache"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LoopInfo.java b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LoopInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LoopInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LoopInfo.java\n@@ -91,6 +91,19 @@ public void setParentLoop(LoopInfo parentLoop) {\n \t\tthis.parentLoop = parentLoop;\n \t}\n \n+\tpublic boolean hasParent(LoopInfo searchLoop) {\n+\t\tLoopInfo parent = parentLoop;\n+\t\twhile (true) {\n+\t\t\tif (parent == null) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (parent == searchLoop) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tparent = parent.getParentLoop();\n+\t\t}\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn \"LOOP:\" + id + \": \" + start + \"->\" + end;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java\n--- a/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java\n@@ -49,6 +49,10 @@ public BlockNode getHeader() {\n \t\treturn header;\n \t}\n \n+\tpublic boolean isEndless() {\n+\t\treturn header == null;\n+\t}\n+\n \tpublic IRegion getBody() {\n \t\treturn body;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockSplitter.java\n@@ -391,7 +391,8 @@ private static boolean canRemoveBlock(BlockNode block) {\n \t\t\t\t&& block.getSuccessors().size() <= 1\n \t\t\t\t&& !block.getPredecessors().isEmpty()\n \t\t\t\t&& !block.contains(AFlag.MTH_ENTER_BLOCK)\n-\t\t\t\t&& !block.contains(AFlag.MTH_EXIT_BLOCK);\n+\t\t\t\t&& !block.contains(AFlag.MTH_EXIT_BLOCK)\n+\t\t\t\t&& !block.getSuccessors().contains(block); // no self loop\n \t}\n \n \tstatic void collectSuccessors(BlockNode startBlock, BlockNode methodEnterBlock, Set<BlockNode> toRemove) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java\n@@ -8,6 +8,7 @@\n import jadx.core.dex.nodes.IRegion;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.regions.Region;\n+import jadx.core.dex.regions.loops.LoopRegion;\n import jadx.core.dex.visitors.AbstractVisitor;\n \n public class CleanRegions extends AbstractVisitor {\n@@ -42,6 +43,13 @@ private static boolean canRemoveRegion(IContainer container) {\n \t\t\t\tBlockNode block = (BlockNode) container;\n \t\t\t\treturn block.getInstructions().isEmpty();\n \t\t\t}\n+\t\t\tif (container instanceof LoopRegion) {\n+\t\t\t\tLoopRegion loopRegion = (LoopRegion) container;\n+\t\t\t\tif (loopRegion.isEndless()) {\n+\t\t\t\t\t// keep empty endless loops\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tif (container instanceof IRegion) {\n \t\t\t\tList<IContainer> subBlocks = ((IRegion) container).getSubBlocks();\n \t\t\t\tfor (IContainer subBlock : subBlocks) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -464,7 +464,7 @@ private boolean insertLoopBreak(RegionStack stack, LoopInfo loop, BlockNode loop\n \t\tBlockNode exitEnd = BlockUtils.followEmptyPath(exit);\n \t\tList<LoopInfo> loops = exitEnd.getAll(AType.LOOP);\n \t\tfor (LoopInfo loopAtEnd : loops) {\n-\t\t\tif (loopAtEnd != loop) {\n+\t\t\tif (loopAtEnd != loop && loop.hasParent(loopAtEnd)) {\n \t\t\t\tinsertEdge = exitEdge;\n \t\t\t\tconfirm = true;\n \t\t\t\tbreak;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java b/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java\n@@ -22,6 +22,7 @@\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.regions.Region;\n+import jadx.core.dex.regions.loops.LoopRegion;\n import jadx.core.dex.trycatch.CatchAttr;\n import jadx.core.dex.trycatch.ExceptionHandler;\n import jadx.core.dex.trycatch.TryCatchBlockAttr;\n@@ -289,17 +290,20 @@ public static boolean notEmpty(@Nullable IContainer container) {\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn false;\n-\t\t} else if (container instanceof IRegion) {\n+\t\t}\n+\t\tif (container instanceof LoopRegion) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (container instanceof IRegion) {\n \t\t\tIRegion region = (IRegion) container;\n \t\t\tfor (IContainer block : region.getSubBlocks()) {\n \t\t\t\tif (notEmpty(block)) {\n \t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn false;\n-\t\t} else {\n-\t\t\tthrow new JadxRuntimeException(unknownContainerType(container));\n \t\t}\n+\t\tthrow new JadxRuntimeException(unknownContainerType(container));\n \t}\n \n \tpublic static void getAllRegionBlocks(IContainer container, Set<IBlock> blocks) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestEndlessLoop2.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestEndlessLoop2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestEndlessLoop2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestEndlessLoop2.java\n@@ -0,0 +1,20 @@\n+package jadx.tests.integration.loops;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+/**\n+ * Empty endless loop, issue #1611\n+ */\n+public class TestEndlessLoop2 extends SmaliTest {\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.countString(2, \"while (true) {\");\n+\t}\n+}",
    "output": "Fix handle empty endless loop"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n@@ -79,8 +79,11 @@ private String generateMethodSnippet(JMethod jMth) {\n \t\tJavaMethod javaMethod = jMth.getJavaMethod();\n \t\tMethodInfo methodInfo = javaMethod.getMethodNode().getMethodInfo();\n \t\tString methodName = StringEscapeUtils.escapeEcmaScript(methodInfo.getName());\n+\t\tString callMethodName = methodName;\n+\n \t\tif (methodInfo.isConstructor()) {\n \t\t\tmethodName = \"$init\";\n+\t\t\tcallMethodName = \"$new\";\n \t\t}\n \t\tString shortClassName = javaMethod.getDeclaringClass().getName();\n \n@@ -108,7 +111,7 @@ private String generateMethodSnippet(JMethod jMth) {\n \t\t\t\t\t\t+ \"    console.log('%s ret value is ' + ret);\\n\"\n \t\t\t\t\t\t+ \"    return ret;\\n\"\n \t\t\t\t\t\t+ \"};\",\n-\t\t\t\tfunctionUntilImplementation, functionParametersString, methodName, logParametersString, methodName,\n+\t\t\t\tfunctionUntilImplementation, functionParametersString, methodName, logParametersString, callMethodName,\n \t\t\t\tfunctionParametersString, methodName);\n \n \t\treturn generateClassSnippet(jMth.getJParent()) + \"\\n\" + functionParameterAndBody;",
    "output": "Fix correct Frida snippet for constructor"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java\n@@ -57,6 +57,10 @@ public boolean isStatic() {\n \t\treturn accFlags.isStatic();\n \t}\n \n+\tpublic boolean isInstance() {\n+\t\treturn !accFlags.isStatic();\n+\t}\n+\n \tpublic String getName() {\n \t\treturn fieldInfo.getName();\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n@@ -264,21 +264,6 @@ public boolean canReorder() {\n \t\t}\n \t}\n \n-\tpublic boolean canReorderRecursive() {\n-\t\tif (!canReorder()) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tfor (InsnArg arg : this.getArguments()) {\n-\t\t\tif (arg.isInsnWrap()) {\n-\t\t\t\tInsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();\n-\t\t\t\tif (!wrapInsn.canReorderRecursive()) {\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n \tpublic boolean containsWrappedInsn() {\n \t\tfor (InsnArg arg : this.getArguments()) {\n \t\t\tif (arg.isInsnWrap()) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n@@ -29,6 +29,7 @@\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n import jadx.core.utils.BlockUtils;\n import jadx.core.utils.InsnRemover;\n+import jadx.core.utils.ListUtils;\n import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxException;\n \n@@ -45,20 +46,22 @@ public boolean visit(ClassNode cls) throws JadxException {\n \t\tfor (ClassNode inner : cls.getInnerClasses()) {\n \t\t\tvisit(inner);\n \t\t}\n-\t\tmoveStaticFieldsInit(cls);\n-\t\tmoveCommonFieldsInit(cls);\n+\t\tif (!cls.getFields().isEmpty()) {\n+\t\t\tmoveStaticFieldsInit(cls);\n+\t\t\tmoveCommonFieldsInit(cls);\n+\t\t}\n \t\treturn false;\n \t}\n \n \tprivate static final class FieldInitInfo {\n \t\tfinal FieldNode fieldNode;\n \t\tfinal IndexInsnNode putInsn;\n-\t\tfinal boolean singlePath;\n+\t\tfinal boolean canMove;\n \n-\t\tpublic FieldInitInfo(FieldNode fieldNode, IndexInsnNode putInsn, boolean singlePath) {\n+\t\tpublic FieldInitInfo(FieldNode fieldNode, IndexInsnNode putInsn, boolean canMove) {\n \t\t\tthis.fieldNode = fieldNode;\n \t\t\tthis.putInsn = putInsn;\n-\t\t\tthis.singlePath = singlePath;\n+\t\t\tthis.canMove = canMove;\n \t\t}\n \t}\n \n@@ -80,6 +83,9 @@ private static void moveStaticFieldsInit(ClassNode cls) {\n \t\t\t\t|| classInitMth.getBasicBlocks() == null) {\n \t\t\treturn;\n \t\t}\n+\t\tif (ListUtils.noneMatch(cls.getFields(), FieldNode::isStatic)) {\n+\t\t\treturn;\n+\t\t}\n \t\twhile (processStaticFields(cls, classInitMth)) {\n \t\t\t// sometimes instructions moved to field init prevent from vars inline -> inline and try again\n \t\t\tCodeShrinkVisitor.shrinkMethod(classInitMth);\n@@ -116,15 +122,15 @@ private static boolean processStaticFields(ClassNode cls, MethodNode classInitMt\n \t}\n \n \tprivate static void moveCommonFieldsInit(ClassNode cls) {\n+\t\tif (ListUtils.noneMatch(cls.getFields(), FieldNode::isInstance)) {\n+\t\t\treturn;\n+\t\t}\n \t\tList<MethodNode> constructors = getConstructorsList(cls);\n \t\tif (constructors.isEmpty()) {\n \t\t\treturn;\n \t\t}\n \t\tList<ConstructorInitInfo> infoList = new ArrayList<>(constructors.size());\n \t\tfor (MethodNode constructorMth : constructors) {\n-\t\t\tif (constructorMth.isNoCode()) {\n-\t\t\t\treturn;\n-\t\t\t}\n \t\t\tList<FieldInitInfo> inits = collectFieldsInit(cls, constructorMth, InsnType.IPUT);\n \t\t\tfilterFieldsInit(inits);\n \t\t\tif (inits.isEmpty()) {\n@@ -168,19 +174,25 @@ private static List<FieldInitInfo> collectFieldsInit(ClassNode cls, MethodNode m\n \t\tSet<BlockNode> singlePathBlocks = new HashSet<>();\n \t\tBlockUtils.visitSinglePath(mth.getEnterBlock(), singlePathBlocks::add);\n \n+\t\tboolean canReorder = true;\n \t\tfor (BlockNode block : mth.getBasicBlocks()) {\n \t\t\tfor (InsnNode insn : block.getInstructions()) {\n+\t\t\t\tboolean fieldInsn = false;\n \t\t\t\tif (insn.getType() == putType) {\n \t\t\t\t\tIndexInsnNode putInsn = (IndexInsnNode) insn;\n \t\t\t\t\tFieldInfo field = (FieldInfo) putInsn.getIndex();\n \t\t\t\t\tif (field.getDeclClass().equals(cls.getClassInfo())) {\n \t\t\t\t\t\tFieldNode fn = cls.searchField(field);\n \t\t\t\t\t\tif (fn != null) {\n-\t\t\t\t\t\t\tboolean singlePath = singlePathBlocks.contains(block);\n-\t\t\t\t\t\t\tfieldsInit.add(new FieldInitInfo(fn, putInsn, singlePath));\n+\t\t\t\t\t\t\tboolean canMove = canReorder && singlePathBlocks.contains(block);\n+\t\t\t\t\t\t\tfieldsInit.add(new FieldInitInfo(fn, putInsn, canMove));\n+\t\t\t\t\t\t\tfieldInsn = true;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tif (!fieldInsn && canReorder && !insn.canReorder()) {\n+\t\t\t\t\tcanReorder = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn fieldsInit;\n@@ -226,14 +238,14 @@ private static void filterFieldsInit(List<FieldInitInfo> inits) {\n \t}\n \n \tprivate static boolean checkInsn(FieldInitInfo initInfo) {\n-\t\tif (!initInfo.singlePath) {\n+\t\tif (!initInfo.canMove) {\n \t\t\treturn false;\n \t\t}\n \t\tIndexInsnNode insn = initInfo.putInsn;\n \t\tInsnArg arg = insn.getArg(0);\n \t\tif (arg.isInsnWrap()) {\n \t\t\tInsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();\n-\t\t\tif (!wrapInsn.canReorderRecursive() && insn.contains(AType.EXC_CATCH)) {\n+\t\t\tif (!wrapInsn.canReorder() && insn.contains(AType.EXC_CATCH)) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t} else {\n@@ -364,7 +376,7 @@ private static List<MethodNode> getConstructorsList(ClassNode cls) {\n \t\t\tAccessInfo accFlags = mth.getAccessFlags();\n \t\t\tif (!accFlags.isStatic() && accFlags.isConstructor()) {\n \t\t\t\tlist.add(mth);\n-\t\t\t\tif (BlockUtils.isAllBlocksEmpty(mth.getBasicBlocks())) {\n+\t\t\t\tif (mth.isNoCode() || BlockUtils.isAllBlocksEmpty(mth.getBasicBlocks())) {\n \t\t\t\t\treturn Collections.emptyList();\n \t\t\t\t}\n \t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/ListUtils.java b/jadx-core/src/main/java/jadx/core/utils/ListUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/ListUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/ListUtils.java\n@@ -160,6 +160,10 @@ public static <T> boolean allMatch(Collection<T> list, Predicate<T> test) {\n \t\treturn true;\n \t}\n \n+\tpublic static <T> boolean noneMatch(Collection<T> list, Predicate<T> test) {\n+\t\treturn !anyMatch(list, test);\n+\t}\n+\n \tpublic static <T> boolean anyMatch(Collection<T> list, Predicate<T> test) {\n \t\tif (list == null || list.isEmpty()) {\n \t\t\treturn false;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/compiler/TestCompiler.java b/jadx-core/src/test/java/jadx/tests/api/compiler/TestCompiler.java\n--- a/jadx-core/src/test/java/jadx/tests/api/compiler/TestCompiler.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/compiler/TestCompiler.java\n@@ -113,7 +113,7 @@ public Object invoke(String clsFullName, String methodName, Class<?>[] types, Ob\n \t\t\tassertNotNull(mth, \"Failed to get method \" + methodName + '(' + Arrays.toString(types) + ')');\n \t\t\treturn mth.invoke(inst, args);\n \t\t} catch (Throwable e) {\n-\t\t\tIntegrationTest.rethrow(\"Invoke error\", e);\n+\t\t\tIntegrationTest.rethrow(\"Invoke error for method: \" + methodName, e);\n \t\t\treturn null;\n \t\t}\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitNegative.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitNegative.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitNegative.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitNegative.java\n@@ -0,0 +1,49 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+/**\n+ * Negative case for field initialization move (#1599).\n+ * Can't reorder with other instance methods.\n+ */\n+public class TestFieldInitNegative extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tStringBuilder sb;\n+\t\tint field;\n+\n+\t\tpublic TestCls() {\n+\t\t\tinitBuilder(new StringBuilder(\"sb\"));\n+\t\t\tthis.field = initField();\n+\t\t\tthis.sb.append(this.field);\n+\t\t}\n+\n+\t\tprivate void initBuilder(StringBuilder sb) {\n+\t\t\tthis.sb = sb;\n+\t\t}\n+\n+\t\tprivate int initField() {\n+\t\t\treturn sb.length();\n+\t\t}\n+\n+\t\tpublic String getStr() {\n+\t\t\treturn sb.toString();\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(new TestCls().getStr()).isEqualTo(\"sb2\"); // no NPE\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"int field = initField();\")\n+\t\t\t\t.containsOne(\"this.field = initField();\");\n+\t}\n+}",
    "output": "Fix checks for field init reorder"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n@@ -66,7 +66,7 @@ private JResource getHierarchyResources(List<ResourceFile> resources) {\n \t\t\t\t\tif (i != count - 1) {\n \t\t\t\t\t\tsubRF = new JResource(null, name, JResType.DIR);\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tsubRF = new JResource(rf, rf.getOriginalName(), name, JResType.FILE);\n+\t\t\t\t\t\tsubRF = new JResource(rf, rf.getDeobfName(), name, JResType.FILE);\n \t\t\t\t\t}\n \t\t\t\t\tcurRf.getFiles().add(subRF);\n \t\t\t\t}",
    "output": "Fix sort resources by deobfuscated name"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -428,7 +428,9 @@ private String makeClsPrefix(ClassNode cls) {\n \t\t\treturn \"Enum\";\n \t\t}\n \t\tString result = \"\";\n-\t\tif (cls.getAccessFlags().isAbstract()) {\n+\t\tif (cls.getAccessFlags().isInterface()) {\n+\t\t\tresult += \"Interface\";\n+\t\t} else if (cls.getAccessFlags().isAbstract()) {\n \t\t\tresult += \"Abstract\";\n \t\t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n@@ -168,11 +168,13 @@ private void addProtoItem(ICodeWriter cw, String itemTag, String typeName, Proto\n \tprivate void addItem(ICodeWriter cw, String itemTag, String typeName, RawNamedValue value) {\n \t\tString nameStr = vp.decodeNameRef(value.getNameRef());\n \t\tString valueStr = vp.decodeValue(value.getRawValue());\n+\t\tint dataType = value.getRawValue().getDataType();\n+\n \t\tif (!typeName.equals(\"attr\")) {\n-\t\t\tif (valueStr == null || valueStr.equals(\"0\")) {\n+\t\t\tif (dataType == ParserConstants.TYPE_REFERENCE && (valueStr == null || valueStr.equals(\"0\"))) {\n \t\t\t\tvalueStr = \"@null\";\n \t\t\t}\n-\t\t\tif (nameStr != null) {\n+\t\t\tif (dataType == ParserConstants.TYPE_INT_DEC && nameStr != null) {\n \t\t\t\ttry {\n \t\t\t\t\tint intVal = Integer.parseInt(valueStr);\n \t\t\t\t\tString newVal = ManifestAttributes.getInstance().decode(nameStr.replace(\"android:attr.\", \"\"), intVal);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -411,7 +411,7 @@ private boolean openSingleFile(Path singleFile, Runnable onFinish) {\n \t\t// check if project file already saved with default name\n \t\tPath projectPath = getProjectPathForFile(singleFile);\n \t\tif (Files.exists(projectPath)) {\n-\t\t\tLOG.info(\"Loading project for this file\");\n+\t\t\tLOG.info(\"Loading project {}\", projectPath);\n \t\t\topenProject(projectPath, onFinish);\n \t\t\treturn true;\n \t\t}",
    "output": "Fix XML \"@null\" decoding minor improvements"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Jadx.java b/jadx-core/src/main/java/jadx/core/Jadx.java\n--- a/jadx-core/src/main/java/jadx/core/Jadx.java\n+++ b/jadx-core/src/main/java/jadx/core/Jadx.java\n@@ -191,7 +191,6 @@ public static List<IDexTreeVisitor> getSimpleModePasses(JadxArgs args) {\n \t\tpasses.add(new ProcessInstructionsVisitor());\n \n \t\tpasses.add(new BlockSplitter());\n-\t\tpasses.add(new MethodVisitor(mth -> mth.add(AFlag.DISABLE_BLOCKS_LOCK)));\n \t\tif (args.isRawCFGOutput()) {\n \t\t\tpasses.add(DotGraphVisitor.dumpRaw());\n \t\t}\n@@ -215,9 +214,6 @@ public static List<IDexTreeVisitor> getSimpleModePasses(JadxArgs args) {\n \t\tpasses.add(new CodeShrinkVisitor());\n \t\tpasses.add(new SimplifyVisitor());\n \t\tpasses.add(new MethodVisitor(mth -> mth.remove(AFlag.DONT_GENERATE)));\n-\t\tif (args.isRawCFGOutput()) {\n-\t\t\tpasses.add(DotGraphVisitor.dumpRaw());\n-\t\t}\n \t\tif (args.isCfgOutput()) {\n \t\t\tpasses.add(DotGraphVisitor.dump());\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/SimpleModeHelper.java b/jadx-core/src/main/java/jadx/core/codegen/SimpleModeHelper.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/SimpleModeHelper.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/SimpleModeHelper.java\n@@ -53,7 +53,9 @@ public List<BlockNode> prepareBlocks() {\n \t\t\t\tstartLabel.set(block.getId());\n \t\t\t} else if (predsCount == 1 && prev != null) {\n \t\t\t\tif (!prev.equals(preds.get(0))) {\n-\t\t\t\t\tstartLabel.set(block.getId());\n+\t\t\t\t\tif (!block.contains(AFlag.EXC_BOTTOM_SPLITTER)) {\n+\t\t\t\t\t\tstartLabel.set(block.getId());\n+\t\t\t\t\t}\n \t\t\t\t\tif (prev.getSuccessors().size() == 1 && !mth.isPreExitBlocks(prev)) {\n \t\t\t\t\t\tendGoto.set(prev.getId());\n \t\t\t\t\t}",
    "output": "Fix hide unused label before exception handler in simple mode"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n@@ -83,6 +83,15 @@ private Map<JavaNode, List<JavaNode>> buildUsageQuery() {\n \t\t\tfor (JavaMethod mth : getMethodWithOverrides(javaMethod)) {\n \t\t\t\tmap.put(mth, mth.getUseIn());\n \t\t\t}\n+\t\t} else if (node instanceof JClass) {\n+\t\t\tJavaClass javaCls = ((JClass) node).getCls();\n+\t\t\tmap.put(javaCls, javaCls.getUseIn());\n+\t\t\t// add constructors usage into class usage\n+\t\t\tfor (JavaMethod javaMth : javaCls.getMethods()) {\n+\t\t\t\tif (javaMth.isConstructor()) {\n+\t\t\t\t\tmap.put(javaMth, javaMth.getUseIn());\n+\t\t\t\t}\n+\t\t\t}\n \t\t} else {\n \t\t\tJavaNode javaNode = node.getJavaNode();\n \t\t\tmap.put(javaNode, javaNode.getUseIn());",
    "output": "Add constructors usage into class usage"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -828,7 +828,11 @@ private void makeInvoke(InvokeNode insn, ICodeWriter code) throws CodegenExcepti\n \t\tif (insn.contains(AFlag.FORCE_RAW_NAME)) {\n \t\t\tcode.add(callMth.getName());\n \t\t} else {\n-\t\t\tcode.add(callMth.getAlias());\n+\t\t\tif (callMthNode != null) {\n+\t\t\t\tcode.add(callMthNode.getAlias());\n+\t\t\t} else {\n+\t\t\t\tcode.add(callMth.getAlias());\n+\t\t\t}\n \t\t}\n \t\tgenerateMethodArguments(code, insn, k, callMthNode);\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n@@ -555,7 +555,7 @@ protected void disableCompilation() {\n \n \tprotected void enableDeobfuscation() {\n \t\targs.setDeobfuscationOn(true);\n-\t\targs.setDeobfuscationMapFileMode(DeobfuscationMapFileMode.OVERWRITE);\n+\t\targs.setDeobfuscationMapFileMode(DeobfuscationMapFileMode.IGNORE);\n \t\targs.setDeobfuscationMinLength(2);\n \t\targs.setDeobfuscationMaxLength(64);\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/deobf/TestInheritedMethodRename.java b/jadx-core/src/test/java/jadx/tests/integration/deobf/TestInheritedMethodRename.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/deobf/TestInheritedMethodRename.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/deobf/TestInheritedMethodRename.java\n@@ -0,0 +1,41 @@\n+package jadx.tests.integration.deobf;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestInheritedMethodRename extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic static class A extends B {\n+\t\t}\n+\n+\t\tpublic static class B {\n+\t\t\tpublic void call() {\n+\t\t\t\tSystem.out.println(\"call\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void test(A a) {\n+\t\t\t// reference to A.call() not renamed,\n+\t\t\t// should be resolved to B.call() and use alias\n+\t\t\ta.call();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tenableDeobfuscation();\n+\t\tgetArgs().setDeobfuscationMinLength(99);\n+\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"public void m0call() {\")\n+\t\t\t\t.doesNotContain(\".call();\")\n+\t\t\t\t.containsOne(\".m0call();\");\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/TestClassNamesCollision2.java b/jadx-core/src/test/java/jadx/tests/integration/names/TestClassNamesCollision2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/TestClassNamesCollision2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestClassNamesCollision2.java\n@@ -1,7 +1,5 @@\n package jadx.tests.integration.names;\n \n-import java.util.List;\n-\n import org.junit.jupiter.api.Test;\n \n import jadx.api.CommentsLevel;",
    "output": "Fix resolve inherited method to use correct alias"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/metadata/annotations/NodeDeclareRef.java b/jadx-core/src/main/java/jadx/api/metadata/annotations/NodeDeclareRef.java\n--- a/jadx-core/src/main/java/jadx/api/metadata/annotations/NodeDeclareRef.java\n+++ b/jadx-core/src/main/java/jadx/api/metadata/annotations/NodeDeclareRef.java\n@@ -32,6 +32,22 @@ public AnnType getAnnType() {\n \t\treturn AnnType.DECLARATION;\n \t}\n \n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (!(o instanceof NodeDeclareRef)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn node.equals(((NodeDeclareRef) o).node);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn node.hashCode();\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn \"NodeDeclareRef{\" + node + '}';\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -26,6 +26,7 @@\n import jadx.core.dex.attributes.nodes.JadxError;\n import jadx.core.dex.attributes.nodes.JumpInfo;\n import jadx.core.dex.attributes.nodes.MethodOverrideAttr;\n+import jadx.core.dex.attributes.nodes.MethodReplaceAttr;\n import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.instructions.ConstStringNode;\n import jadx.core.dex.instructions.IfNode;\n@@ -144,8 +145,9 @@ public boolean addDefinition(ICodeWriter code) {\n \t\t} else {\n \t\t\tclassGen.useType(code, mth.getReturnType());\n \t\t\tcode.add(' ');\n-\t\t\tcode.attachDefinition(mth);\n-\t\t\tcode.add(mth.getAlias());\n+\t\t\tMethodNode defMth = getMethodForDefinition();\n+\t\t\tcode.attachDefinition(defMth);\n+\t\t\tcode.add(defMth.getAlias());\n \t\t}\n \t\tcode.add('(');\n \n@@ -178,6 +180,14 @@ public boolean addDefinition(ICodeWriter code) {\n \t\treturn true;\n \t}\n \n+\tprivate MethodNode getMethodForDefinition() {\n+\t\tMethodReplaceAttr replaceAttr = mth.get(AType.METHOD_REPLACE);\n+\t\tif (replaceAttr != null) {\n+\t\t\treturn replaceAttr.getReplaceMth();\n+\t\t}\n+\t\treturn mth;\n+\t}\n+\n \tprivate void addOverrideAnnotation(ICodeWriter code, MethodNode mth) {\n \t\tMethodOverrideAttr overrideAttr = mth.get(AType.METHOD_OVERRIDE);\n \t\tif (overrideAttr == null) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n@@ -10,6 +10,7 @@\n import jadx.api.plugins.input.data.AccessFlags;\n import jadx.core.Consts;\n import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.FieldReplaceAttr;\n import jadx.core.dex.attributes.nodes.MethodReplaceAttr;\n import jadx.core.dex.attributes.nodes.SkipMethodArgsAttr;\n@@ -281,6 +282,9 @@ private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {\n \t\tif (!Objects.equals(wrappedMth.getAlias(), alias)) {\n \t\t\twrappedMth.getMethodInfo().setAlias(alias);\n \t\t}\n+\t\twrappedMth.addAttr(new MethodReplaceAttr(mth));\n+\t\twrappedMth.copyAttributeFrom(mth, AType.METHOD_OVERRIDE);\n+\t\twrappedMth.addDebugComment(\"Method merged with bridge method\");\n \t\treturn true;\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java\n--- a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java\n@@ -8,7 +8,6 @@\n import jadx.api.ICodeInfo;\n import jadx.api.metadata.ICodeAnnotation;\n import jadx.core.dex.nodes.ClassNode;\n-import jadx.core.dex.nodes.ICodeNode;\n import jadx.tests.api.IntegrationTest;\n \n import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n@@ -58,21 +57,23 @@ public JadxClassNodeAssertions runDecompiledAutoCheck(IntegrationTest testInstan\n \t\treturn this;\n \t}\n \n-\tpublic void checkCodeAnnotationFor(String refStr, ICodeNode node) {\n+\tpublic JadxClassNodeAssertions checkCodeAnnotationFor(String refStr, ICodeAnnotation node) {\n \t\tcheckCodeAnnotationFor(refStr, 0, node);\n+\t\treturn this;\n \t}\n \n-\tpublic void checkCodeAnnotationFor(String refStr, int refOffset, ICodeNode node) {\n+\tpublic JadxClassNodeAssertions checkCodeAnnotationFor(String refStr, int refOffset, ICodeAnnotation node) {\n \t\tICodeInfo code = actual.getCode();\n \t\tint codePos = code.getCodeStr().indexOf(refStr);\n \t\tassertThat(codePos).describedAs(\"String '%s' not found\", refStr).isNotEqualTo(-1);\n \t\tint refPos = codePos + refOffset;\n \t\tfor (Map.Entry<Integer, ICodeAnnotation> entry : code.getCodeMetadata().getAsMap().entrySet()) {\n \t\t\tif (entry.getKey() == refPos) {\n \t\t\t\tAssertions.assertThat(entry.getValue()).isEqualTo(node);\n-\t\t\t\treturn;\n+\t\t\t\treturn this;\n \t\t\t}\n \t\t}\n \t\tfail(\"Annotation for reference string: '%s' at position %d not found\", refStr, refPos);\n+\t\treturn this;\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenericsMthOverride.java b/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenericsMthOverride.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenericsMthOverride.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenericsMthOverride.java\n@@ -56,8 +56,6 @@ public void test() {\n \t\tassertThat(code, containsOne(\"public Y method(Exception x) {\"));\n \t\tassertThat(code, containsOne(\"public Object method(Object x) {\"));\n \n-\t\tassertThat(code, countString(3, \"@Override\"));\n-\t\t// TODO: @Override missing for class C\n-\t\t// assertThat(code, countString(4, \"@Override\"));\n+\t\tassertThat(code, countString(4, \"@Override\"));\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inline/TestOverrideBridgeMerge.java b/jadx-core/src/test/java/jadx/tests/integration/inline/TestOverrideBridgeMerge.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inline/TestOverrideBridgeMerge.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inline/TestOverrideBridgeMerge.java\n@@ -0,0 +1,45 @@\n+package jadx.tests.integration.inline;\n+\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.api.metadata.ICodeAnnotation;\n+import jadx.api.metadata.annotations.NodeDeclareRef;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestOverrideBridgeMerge extends SmaliTest {\n+\n+\tpublic static class TestCls implements Function<String, Integer> {\n+\t\t@Override\n+\t\tpublic /* bridge */ /* synthetic */ Integer apply(String str) {\n+\t\t\treturn test(str);\n+\t\t}\n+\n+\t\tpublic Integer test(String str) {\n+\t\t\treturn str.length();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"Integer test(String str) {\"); // not inlined\n+\t}\n+\n+\t@Test\n+\tpublic void testSmali() {\n+\t\tClassNode cls = getClassNodeFromSmali();\n+\t\tICodeAnnotation mthDef = new NodeDeclareRef(getMethod(cls, \"apply\"));\n+\t\tassertThat(cls)\n+\t\t\t\t.checkCodeAnnotationFor(\"apply(String str) {\", mthDef)\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"@Override\")\n+\t\t\t\t.containsOne(\"public Integer apply(String str) {\")\n+\t\t\t\t.doesNotContain(\"test(String str)\");\n+\t}\n+}",
    "output": "Fix correct inline/merge with overriden bridge method"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n@@ -3,6 +3,7 @@\n import java.awt.BorderLayout;\n import java.awt.Container;\n import java.awt.FlowLayout;\n+import java.awt.Font;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n@@ -22,6 +23,7 @@\n import jadx.api.utils.CodeUtils;\n import jadx.gui.JadxWrapper;\n import jadx.gui.jobs.TaskStatus;\n+import jadx.gui.settings.JadxSettings;\n import jadx.gui.treemodel.CodeNode;\n import jadx.gui.treemodel.JClass;\n import jadx.gui.treemodel.JMethod;\n@@ -134,8 +136,12 @@ protected void loadStart() {\n \t}\n \n \tprivate void initUI() {\n+\t\tJadxSettings settings = mainWindow.getSettings();\n+\t\tFont codeFont = settings.getFont();\n \t\tJLabel lbl = new JLabel(NLS.str(\"usage_dialog.label\"));\n+\t\tlbl.setFont(codeFont);\n \t\tJLabel nodeLabel = new JLabel(this.node.makeLongStringHtml(), this.node.getIcon(), SwingConstants.LEFT);\n+\t\tnodeLabel.setFont(codeFont);\n \t\tlbl.setLabelFor(nodeLabel);\n \n \t\tJPanel searchPane = new JPanel();",
    "output": "Use editor font for usage label"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n@@ -113,7 +113,12 @@ private JNode replaceNode(JNode node) {\n \t}\n \n \tprivate boolean checkNewName() {\n-\t\tboolean valid = NameMapper.isValidIdentifier(renameField.getText());\n+\t\tString newName = renameField.getText();\n+\t\tif (newName.isEmpty()) {\n+\t\t\t// use empty name to reset rename (revert to original)\n+\t\t\treturn true;\n+\t\t}\n+\t\tboolean valid = NameMapper.isValidIdentifier(newName);\n \t\tif (renameBtn.isEnabled() != valid) {\n \t\t\trenameBtn.setEnabled(valid);\n \t\t\trenameField.putClientProperty(\"JComponent.outline\", valid ? \"\" : \"error\");",
    "output": "Fix allow to use empty name to reset rename"
  },
  {
    "input": "diff --git a/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java\n@@ -19,10 +19,15 @@\n \n public abstract class SmaliTest extends IntegrationTest {\n \n-\tprivate static final String SMALI_TESTS_PROJECT = \"jadx-core\";\n \tprivate static final String SMALI_TESTS_DIR = \"src/test/smali\";\n \tprivate static final String SMALI_TESTS_EXT = \".smali\";\n \n+\tprivate String currentProject = \"jadx-core\";\n+\n+\tpublic void setCurrentProject(String currentProject) {\n+\t\tthis.currentProject = currentProject;\n+\t}\n+\n \t@BeforeEach\n \tpublic void init() {\n \t\tAssumptions.assumeFalse(USE_JAVA_INPUT, \"skip smali test for java input tests\");\n@@ -89,24 +94,24 @@ private List<File> collectSmaliFiles(String pkg, @Nullable String testDir) {\n \t\t\t\t.collect(Collectors.toList());\n \t}\n \n-\tprivate static File getSmaliFile(String baseName) {\n+\tprivate File getSmaliFile(String baseName) {\n \t\tFile smaliFile = new File(SMALI_TESTS_DIR, baseName + SMALI_TESTS_EXT);\n \t\tif (smaliFile.exists()) {\n \t\t\treturn smaliFile;\n \t\t}\n-\t\tFile pathFromRoot = new File(SMALI_TESTS_PROJECT, smaliFile.getPath());\n+\t\tFile pathFromRoot = new File(currentProject, smaliFile.getPath());\n \t\tif (pathFromRoot.exists()) {\n \t\t\treturn pathFromRoot;\n \t\t}\n \t\tthrow new AssertionError(\"Smali file not found: \" + smaliFile.getPath());\n \t}\n \n-\tprivate static File getSmaliDir(String baseName) {\n+\tprivate File getSmaliDir(String baseName) {\n \t\tFile smaliDir = new File(SMALI_TESTS_DIR, baseName);\n \t\tif (smaliDir.exists()) {\n \t\t\treturn smaliDir;\n \t\t}\n-\t\tFile pathFromRoot = new File(SMALI_TESTS_PROJECT, smaliDir.getPath());\n+\t\tFile pathFromRoot = new File(currentProject, smaliDir.getPath());\n \t\tif (pathFromRoot.exists()) {\n \t\t\treturn pathFromRoot;\n \t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java b/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java\n--- a/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java\n+++ b/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java\n@@ -46,6 +46,7 @@\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n \n import static jadx.api.plugins.input.data.AccessFlagsScope.FIELD;\n import static jadx.api.plugins.input.data.AccessFlagsScope.METHOD;\n@@ -60,7 +61,9 @@\n import static jadx.api.plugins.input.insns.Opcode.INVOKE_CUSTOM_RANGE;\n import static jadx.api.plugins.input.insns.Opcode.INVOKE_POLYMORPHIC;\n import static jadx.api.plugins.input.insns.Opcode.INVOKE_POLYMORPHIC_RANGE;\n+import static jadx.api.plugins.input.insns.Opcode.PACKED_SWITCH;\n import static jadx.api.plugins.input.insns.Opcode.PACKED_SWITCH_PAYLOAD;\n+import static jadx.api.plugins.input.insns.Opcode.SPARSE_SWITCH;\n import static jadx.api.plugins.input.insns.Opcode.SPARSE_SWITCH_PAYLOAD;\n \n public class Smali {\n@@ -288,6 +291,14 @@ private void writeMethod(SmaliWriter smali, MethodNode methodNode, IMethodData m\n \t\t\tif (codeReader.getDebugInfo() != null) {\n \t\t\t\tformatDbgInfo(codeReader.getDebugInfo(), line);\n \t\t\t}\n+\t\t\t// first pass to fill payload offsets for switch instructions\n+\t\t\tcodeReader.visitInstructions(insn -> {\n+\t\t\t\tOpcode opcode = insn.getOpcode();\n+\t\t\t\tif (opcode == PACKED_SWITCH || opcode == SPARSE_SWITCH) {\n+\t\t\t\t\tinsn.decode();\n+\t\t\t\t\tline.addPayloadOffset(insn.getOffset(), insn.getTarget());\n+\t\t\t\t}\n+\t\t\t});\n \t\t\tcodeReader.visitInstructions(insn -> {\n \t\t\t\tInsnNode node = decodeInsn(insn, line);\n \t\t\t\tnodes.put((long) insn.getOffset(), node);\n@@ -404,7 +415,6 @@ private boolean tryFormatTargetIns(InsnData insn, InsnType insnType, LineInfo li\n \t\t\t\t\tline.addTip(target, String.format(FMT_S_SWITCH_TAG, target), \"\");\n \t\t\t\t\tline.getLineWriter().append(\", \").append(String.format(FMT_S_SWITCH, target));\n \t\t\t\t}\n-\t\t\t\tline.addPayloadOffset(insn.getOffset(), target);\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}\n@@ -733,7 +743,7 @@ private boolean fmtPayloadInsn(InsnData insn, LineInfo line) {\n \n \t\t\tISwitchPayload payload = (ISwitchPayload) insn.getPayload();\n \t\t\tif (payload != null) {\n-\t\t\t\tfmtSwitchPayload(insn, FMT_P_SWITCH_CASE, FMT_P_SWITCH_CASE_TAG, line, payload, insn.getOffset());\n+\t\t\t\tfmtSwitchPayload(insn, FMT_P_SWITCH_CASE, FMT_P_SWITCH_CASE_TAG, line, payload);\n \t\t\t}\n \t\t\treturn true;\n \t\t}\n@@ -743,7 +753,7 @@ private boolean fmtPayloadInsn(InsnData insn, LineInfo line) {\n \n \t\t\tISwitchPayload payload = (ISwitchPayload) insn.getPayload();\n \t\t\tif (payload != null) {\n-\t\t\t\tfmtSwitchPayload(insn, FMT_S_SWITCH_CASE, FMT_S_SWITCH_CASE_TAG, line, payload, insn.getOffset());\n+\t\t\t\tfmtSwitchPayload(insn, FMT_S_SWITCH_CASE, FMT_S_SWITCH_CASE_TAG, line, payload);\n \t\t\t}\n \t\t\treturn true;\n \t\t}\n@@ -755,17 +765,19 @@ private boolean fmtPayloadInsn(InsnData insn, LineInfo line) {\n \t\treturn false;\n \t}\n \n-\tprivate void fmtSwitchPayload(InsnData insn, String fmtTarget, String fmtTag, LineInfo line,\n-\t\t\tISwitchPayload payload, int curOffset) {\n+\tprivate void fmtSwitchPayload(InsnData insn, String fmtTarget, String fmtTag, LineInfo line, ISwitchPayload payload) {\n \t\tint lineStart = getInsnColStart();\n \t\tlineStart += CODE_OFFSET_COLUMN_WIDTH + 1 + 1; // plus 1s for space and the ':'\n \t\tString basicIndent = new String(new byte[lineStart]).replace(\"\\0\", \" \");\n \t\tString indent = SmaliWriter.INDENT_STR + basicIndent;\n \t\tint[] keys = payload.getKeys();\n \t\tint[] targets = payload.getTargets();\n-\t\tint opcodeOffset = line.payloadOffsetMap.get(curOffset);\n+\t\tInteger switchOffset = line.payloadOffsetMap.get(insn.getOffset());\n+\t\tif (switchOffset == null) {\n+\t\t\tthrow new JadxRuntimeException(\"Unknown switch insn for payload at \" + insn.getOffset());\n+\t\t}\n \t\tfor (int i = 0; i < keys.length; i++) {\n-\t\t\tint target = opcodeOffset + targets[i];\n+\t\t\tint target = switchOffset + targets[i];\n \t\t\tline.addInsnLine(insn.getOffset(),\n \t\t\t\t\tString.format(\"%scase %d: -> \" + fmtTarget, indent, keys[i], target));\n \t\t\tline.addTip(target,\n\ndiff --git a/jadx-gui/src/test/java/jadx/gui/device/debugger/smali/DbgSmaliTest.java b/jadx-gui/src/test/java/jadx/gui/device/debugger/smali/DbgSmaliTest.java\n--- a/jadx-gui/src/test/java/jadx/gui/device/debugger/smali/DbgSmaliTest.java\n+++ b/jadx-gui/src/test/java/jadx/gui/device/debugger/smali/DbgSmaliTest.java\n@@ -0,0 +1,26 @@\n+package jadx.gui.device.debugger.smali;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+class DbgSmaliTest extends SmaliTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DbgSmaliTest.class);\n+\n+\t@BeforeEach\n+\tpublic void initProject() {\n+\t\tsetCurrentProject(\"jadx-gui\");\n+\t}\n+\n+\t@Test\n+\tvoid test() {\n+\t\tdisableCompilation();\n+\t\tClassNode cls = getClassNodeFromSmali(\"switch\", \"SwitchTest\");\n+\t\tSmali disasm = Smali.disassemble(cls);\n+\t\tLOG.debug(\"{}\", disasm.getCode());\n+\t}\n+}",
    "output": "Fix resolve payload offset for switch insns in debug smali code"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -356,8 +356,9 @@ private void appendSourcesSave(List<Runnable> tasks, File outDir) {\n \t\t\ttasks.add(() -> {\n \t\t\t\tfor (JavaClass cls : decompileBatch) {\n \t\t\t\t\ttry {\n-\t\t\t\t\t\tICodeInfo code = cls.getCodeInfo();\n-\t\t\t\t\t\tSaveCode.save(outDir, cls.getClassNode(), code);\n+\t\t\t\t\t\tClassNode clsNode = cls.getClassNode();\n+\t\t\t\t\t\tICodeInfo code = clsNode.getCode();\n+\t\t\t\t\t\tSaveCode.save(outDir, clsNode, code);\n \t\t\t\t\t} catch (Exception e) {\n \t\t\t\t\t\tLOG.error(\"Error saving class: {}\", cls, e);\n \t\t\t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JavaClass.java b/jadx-core/src/main/java/jadx/api/JavaClass.java\n--- a/jadx-core/src/main/java/jadx/api/JavaClass.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java\n@@ -58,7 +58,10 @@ public String getCode() {\n \t}\n \n \tpublic @NotNull ICodeInfo getCodeInfo() {\n-\t\tload();\n+\t\tICodeInfo code = load();\n+\t\tif (code != null) {\n+\t\t\treturn code;\n+\t\t}\n \t\treturn cls.decompile();\n \t}\n \n@@ -107,19 +110,24 @@ public ClassNode getClassNode() {\n \t/**\n \t * Decompile class and loads internal lists of fields, methods, etc.\n \t * Do nothing if already loaded.\n+\t *\n+\t * @return code info if decompilation was executed, null otherwise\n \t */\n-\t@Nullable\n-\tprivate synchronized void load() {\n+\tprivate synchronized @Nullable ICodeInfo load() {\n \t\tif (listsLoaded) {\n-\t\t\treturn;\n+\t\t\treturn null;\n \t\t}\n \t\tlistsLoaded = true;\n-\t\tJadxDecompiler rootDecompiler = getRootDecompiler();\n-\t\tICodeCache codeCache = rootDecompiler.getArgs().getCodeCache();\n-\t\tif (!codeCache.contains(cls.getRawName())) {\n-\t\t\tcls.decompile();\n+\n+\t\tICodeInfo code;\n+\t\tif (cls.getState().isProcessComplete()) {\n+\t\t\t// already decompiled -> class internals loaded\n+\t\t\tcode = null;\n+\t\t} else {\n+\t\t\tcode = cls.decompile();\n \t\t}\n \n+\t\tJadxDecompiler rootDecompiler = getRootDecompiler();\n \t\tint inClsCount = cls.getInnerClasses().size();\n \t\tif (inClsCount != 0) {\n \t\t\tList<JavaClass> list = new ArrayList<>(inClsCount);\n@@ -165,6 +173,7 @@ private synchronized void load() {\n \t\t\tmths.sort(Comparator.comparing(JavaMethod::getName));\n \t\t\tthis.methods = Collections.unmodifiableList(mths);\n \t\t}\n+\t\treturn code;\n \t}\n \n \tJadxDecompiler getRootDecompiler() {",
    "output": "Fix resolve possible decompilation double execution"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -42,7 +42,8 @@\n import jadx.core.utils.Utils;\n import jadx.core.utils.android.AndroidResourcesUtils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n-import jadx.core.xmlgen.ResTableParser;\n+import jadx.core.xmlgen.IResParser;\n+import jadx.core.xmlgen.ResDecoder;\n import jadx.core.xmlgen.ResourceStorage;\n import jadx.core.xmlgen.entry.ResourceEntry;\n import jadx.core.xmlgen.entry.ValuesParser;\n@@ -163,23 +164,13 @@ public void addClassNode(ClassNode clsNode) {\n \t}\n \n \tpublic void loadResources(List<ResourceFile> resources) {\n-\t\tResourceFile arsc = null;\n-\t\tfor (ResourceFile rf : resources) {\n-\t\t\tif (rf.getType() == ResourceType.ARSC) {\n-\t\t\t\tarsc = rf;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n+\t\tResourceFile arsc = getResourceFile(resources);\n \t\tif (arsc == null) {\n \t\t\tLOG.debug(\"'.arsc' file not found\");\n \t\t\treturn;\n \t\t}\n \t\ttry {\n-\t\t\tResTableParser parser = ResourcesLoader.decodeStream(arsc, (size, is) -> {\n-\t\t\t\tResTableParser tableParser = new ResTableParser(this);\n-\t\t\t\ttableParser.decode(is);\n-\t\t\t\treturn tableParser;\n-\t\t\t});\n+\t\t\tIResParser parser = ResourcesLoader.decodeStream(arsc, (size, is) -> ResDecoder.decode(this, arsc, is));\n \t\t\tif (parser != null) {\n \t\t\t\tprocessResources(parser.getResStorage());\n \t\t\t\tupdateObfuscatedFiles(parser, resources);\n@@ -189,6 +180,15 @@ public void loadResources(List<ResourceFile> resources) {\n \t\t}\n \t}\n \n+\tprivate @Nullable ResourceFile getResourceFile(List<ResourceFile> resources) {\n+\t\tfor (ResourceFile rf : resources) {\n+\t\t\tif (rf.getType() == ResourceType.ARSC) {\n+\t\t\t\treturn rf;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \tpublic void processResources(ResourceStorage resStorage) {\n \t\tconstValues.setResourcesNames(resStorage.getResourcesNames());\n \t\tappPackage = resStorage.getAppPackage();\n@@ -209,7 +209,7 @@ public void initClassPath() {\n \t\t}\n \t}\n \n-\tprivate void updateObfuscatedFiles(ResTableParser parser, List<ResourceFile> resources) {\n+\tprivate void updateObfuscatedFiles(IResParser parser, List<ResourceFile> resources) {\n \t\tif (args.isSkipResources()) {\n \t\t\treturn;\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/IResParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/IResParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/IResParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/IResParser.java\n@@ -0,0 +1,13 @@\n+package jadx.core.xmlgen;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+public interface IResParser {\n+\n+\tvoid decode(InputStream inputStream) throws IOException;\n+\n+\tResourceStorage getResStorage();\n+\n+\tString[] getStrings();\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResDecoder.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResDecoder.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResDecoder.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResDecoder.java\n@@ -0,0 +1,31 @@\n+package jadx.core.xmlgen;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import jadx.api.ResourceFile;\n+import jadx.api.ResourceType;\n+import jadx.core.dex.nodes.RootNode;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n+\n+public class ResDecoder {\n+\n+\tpublic static IResParser decode(RootNode root, ResourceFile resFile, InputStream is) throws IOException {\n+\t\tif (resFile.getType() != ResourceType.ARSC) {\n+\t\t\tthrow new IllegalArgumentException(\"Unexpected resource type for decode: \" + resFile.getType() + \", expect ARSC\");\n+\t\t}\n+\t\tIResParser parser = null;\n+\t\tString fileName = resFile.getOriginalName();\n+\t\tif (fileName.endsWith(\".arsc\")) {\n+\t\t\tparser = new ResTableParser(root);\n+\t\t}\n+\t\tif (fileName.endsWith(\".pb\")) {\n+\t\t\tparser = new ResProtoParser(root);\n+\t\t}\n+\t\tif (parser == null) {\n+\t\t\tthrow new JadxRuntimeException(\"Unknown type of resource file: \" + fileName);\n+\t\t}\n+\t\tparser.decode(is);\n+\t\treturn parser;\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResProtoParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResProtoParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResProtoParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResProtoParser.java\n@@ -20,16 +20,16 @@\n import com.android.aapt.Resources.Styleable;\n import com.android.aapt.Resources.Type;\n import com.android.aapt.Resources.Value;\n-import com.google.protobuf.InvalidProtocolBufferException;\n \n import jadx.api.ICodeInfo;\n import jadx.core.dex.nodes.RootNode;\n+import jadx.core.utils.files.FileUtils;\n import jadx.core.xmlgen.entry.EntryConfig;\n import jadx.core.xmlgen.entry.ProtoValue;\n import jadx.core.xmlgen.entry.ResourceEntry;\n import jadx.core.xmlgen.entry.ValuesParser;\n \n-public class ResProtoParser {\n+public class ResProtoParser implements IResParser {\n \tprivate final RootNode root;\n \tprivate final ResourceStorage resStorage = new ResourceStorage();\n \n@@ -38,18 +38,23 @@ public ResProtoParser(RootNode root) {\n \t}\n \n \tpublic ResContainer decodeFiles(InputStream inputStream) throws IOException {\n-\t\tResourceTable table = decodeProto(inputStream);\n-\t\tfor (Package p : table.getPackageList()) {\n-\t\t\tparse(p);\n-\t\t}\n-\t\tresStorage.finish();\n+\t\tdecode(inputStream);\n \t\tValuesParser vp = new ValuesParser(new String[0], resStorage.getResourcesNames());\n \t\tResXmlGen resGen = new ResXmlGen(resStorage, vp);\n \t\tICodeInfo content = XmlGenUtils.makeXmlDump(root.makeCodeWriter(), resStorage);\n \t\tList<ResContainer> xmlFiles = resGen.makeResourcesXml();\n \t\treturn ResContainer.resourceTable(\"res\", xmlFiles, content);\n \t}\n \n+\t@Override\n+\tpublic void decode(InputStream inputStream) throws IOException {\n+\t\tResourceTable table = ResourceTable.parseFrom(FileUtils.streamToByteArray(inputStream));\n+\t\tfor (Package p : table.getPackageList()) {\n+\t\t\tparse(p);\n+\t\t}\n+\t\tresStorage.finish();\n+\t}\n+\n \tprivate void parse(Package p) {\n \t\tString name = p.getPackageName();\n \t\tresStorage.setAppPackage(name);\n@@ -241,8 +246,13 @@ private String parse(Item i) {\n \t\treturn \"\";\n \t}\n \n-\tprivate ResourceTable decodeProto(InputStream inputStream)\n-\t\t\tthrows InvalidProtocolBufferException, IOException {\n-\t\treturn ResourceTable.parseFrom(XmlGenUtils.readData(inputStream));\n+\t@Override\n+\tpublic ResourceStorage getResStorage() {\n+\t\treturn resStorage;\n+\t}\n+\n+\t@Override\n+\tpublic String[] getStrings() {\n+\t\treturn new String[0];\n \t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -24,7 +24,7 @@\n import jadx.core.xmlgen.entry.ResourceEntry;\n import jadx.core.xmlgen.entry.ValuesParser;\n \n-public class ResTableParser extends CommonBinaryParser {\n+public class ResTableParser extends CommonBinaryParser implements IResParser {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ResTableParser.class);\n \n \tprivate static final Pattern VALID_RES_KEY_PATTERN = Pattern.compile(\"[\\\\w\\\\d_]+\");\n@@ -76,6 +76,7 @@ public ResTableParser(RootNode root, boolean useRawResNames) {\n \t\tthis.useRawResName = useRawResNames;\n \t}\n \n+\t@Override\n \tpublic void decode(InputStream inputStream) throws IOException {\n \t\tis = new ParserStream(inputStream);\n \t\tdecodeTableChunk();\n@@ -93,14 +94,6 @@ public ResContainer decodeFiles(InputStream inputStream) throws IOException {\n \t\treturn ResContainer.resourceTable(\"res\", xmlFiles, content);\n \t}\n \n-\tpublic ResourceStorage getResStorage() {\n-\t\treturn resStorage;\n-\t}\n-\n-\tpublic String[] getStrings() {\n-\t\treturn strings;\n-\t}\n-\n \tvoid decodeTableChunk() throws IOException {\n \t\tis.checkInt16(RES_TABLE_TYPE, \"Not a table chunk\");\n \t\tis.checkInt16(0x000c, \"Unexpected table header size\");\n@@ -434,4 +427,14 @@ private String readScriptOrVariantChar(int length) throws IOException {\n \t\tis.skipToPos(start + length, \"readScriptOrVariantChar\");\n \t\treturn sb.toString();\n \t}\n+\n+\t@Override\n+\tpublic ResourceStorage getResStorage() {\n+\t\treturn resStorage;\n+\t}\n+\n+\t@Override\n+\tpublic String[] getStrings() {\n+\t\treturn strings;\n+\t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n@@ -226,6 +226,7 @@ public String getSyntaxName() {\n \n \t\t\tcase MANIFEST:\n \t\t\tcase XML:\n+\t\t\tcase ARSC:\n \t\t\t\treturn SyntaxConstants.SYNTAX_STYLE_XML;\n \n \t\t\tdefault:\n@@ -249,8 +250,7 @@ public String getSyntaxName() {\n \t\t\t\"yaml\", SyntaxConstants.SYNTAX_STYLE_YAML,\n \t\t\t\"properties\", SyntaxConstants.SYNTAX_STYLE_PROPERTIES_FILE,\n \t\t\t\"ini\", SyntaxConstants.SYNTAX_STYLE_INI,\n-\t\t\t\"sql\", SyntaxConstants.SYNTAX_STYLE_SQL,\n-\t\t\t\"arsc\", SyntaxConstants.SYNTAX_STYLE_XML);\n+\t\t\t\"sql\", SyntaxConstants.SYNTAX_STYLE_SQL);\n \n \tprivate String getSyntaxByExtension(String name) {\n \t\tint dot = name.lastIndexOf('.');",
    "output": "Fix update deps and fix proto resource loading (AAB)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -37,8 +37,6 @@\n import jadx.api.plugins.options.JadxPluginOptions;\n import jadx.core.Jadx;\n import jadx.core.dex.attributes.AFlag;\n-import jadx.core.dex.attributes.AType;\n-import jadx.core.dex.attributes.nodes.InlinedAttr;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.FieldNode;\n import jadx.core.dex.nodes.MethodNode;\n@@ -496,25 +494,11 @@ JavaField convertFieldNode(FieldNode field) {\n \t@ApiStatus.Internal\n \tJavaMethod convertMethodNode(MethodNode method) {\n \t\treturn methodsMap.computeIfAbsent(method, mthNode -> {\n-\t\t\tClassNode codeCls = getCodeParentClass(mthNode.getParentClass());\n-\t\t\treturn new JavaMethod(convertClassNode(codeCls), mthNode);\n+\t\t\tClassNode parentCls = mthNode.getParentClass();\n+\t\t\treturn new JavaMethod(convertClassNode(parentCls), mthNode);\n \t\t});\n \t}\n \n-\tprivate static ClassNode getCodeParentClass(ClassNode cls) {\n-\t\tClassNode codeCls;\n-\t\tInlinedAttr inlinedAttr = cls.get(AType.INLINED);\n-\t\tif (inlinedAttr != null) {\n-\t\t\tcodeCls = inlinedAttr.getInlineCls().getTopParentClass();\n-\t\t} else {\n-\t\t\tcodeCls = cls.getTopParentClass();\n-\t\t}\n-\t\tif (codeCls == cls) {\n-\t\t\treturn codeCls;\n-\t\t}\n-\t\treturn getCodeParentClass(codeCls);\n-\t}\n-\n \t@Nullable\n \tpublic JavaClass searchJavaClassByOrigFullName(String fullName) {\n \t\treturn getRoot().getClasses().stream()\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JavaClass.java b/jadx-core/src/main/java/jadx/api/JavaClass.java\n--- a/jadx-core/src/main/java/jadx/api/JavaClass.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java\n@@ -18,6 +18,7 @@\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.AnonymousClassAttr;\n+import jadx.core.dex.attributes.nodes.InlinedAttr;\n import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.FieldNode;\n@@ -242,19 +243,37 @@ public JavaClass getDeclaringClass() {\n \t\treturn parent;\n \t}\n \n+\tpublic JavaClass getOriginalTopParentClass() {\n+\t\treturn parent == null ? this : parent.getOriginalTopParentClass();\n+\t}\n+\n+\t/**\n+\t * Return top parent class which contains code of this class.\n+\t * Code parent can be different from original parent after move or inline\n+\t *\n+\t * @return this if already a top class\n+\t */\n \t@Override\n \tpublic JavaClass getTopParentClass() {\n-\t\tif (cls.contains(AType.ANONYMOUS_CLASS)) {\n-\t\t\t// moved to usage class\n-\t\t\treturn getParentForAnonymousClass();\n-\t\t}\n-\t\treturn parent == null ? this : parent.getTopParentClass();\n+\t\tJavaClass codeParent = getCodeParent();\n+\t\treturn codeParent == null ? this : codeParent.getTopParentClass();\n \t}\n \n-\tprivate JavaClass getParentForAnonymousClass() {\n-\t\tAnonymousClassAttr attr = cls.get(AType.ANONYMOUS_CLASS);\n-\t\tClassNode topParentClass = attr.getOuterCls().getTopParentClass();\n-\t\treturn getRootDecompiler().convertClassNode(topParentClass);\n+\t/**\n+\t * Return parent class which contains code of this class.\n+\t * Code parent can be different for original parent after move or inline\n+\t */\n+\tpublic @Nullable JavaClass getCodeParent() {\n+\t\tAnonymousClassAttr anonymousClsAttr = cls.get(AType.ANONYMOUS_CLASS);\n+\t\tif (anonymousClsAttr != null) {\n+\t\t\t// moved to usage class\n+\t\t\treturn getRootDecompiler().convertClassNode(anonymousClsAttr.getOuterCls());\n+\t\t}\n+\t\tInlinedAttr inlinedAttr = cls.get(AType.INLINED);\n+\t\tif (inlinedAttr != null) {\n+\t\t\treturn getRootDecompiler().convertClassNode(inlinedAttr.getInlineCls());\n+\t\t}\n+\t\treturn parent;\n \t}\n \n \tpublic AccessInfo getAccessInfo() {",
    "output": "Fix handle parent of inlined/moved classes"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java b/jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java\n@@ -82,5 +82,6 @@ public JumpPosition getNext() {\n \n \tpublic void reset() {\n \t\tlist.clear();\n+\t\tcurrentPos = 0;\n \t}\n }",
    "output": "Fix IndexOutOfBoundsException in JumpManager"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -21,6 +21,7 @@\n import jadx.api.ICodeInfo;\n import jadx.api.ICodeWriter;\n import jadx.api.JadxArgs;\n+import jadx.api.impl.SimpleCodeInfo;\n import jadx.api.plugins.input.data.IClassData;\n import jadx.api.plugins.input.data.IFieldData;\n import jadx.api.plugins.input.data.IMethodData;\n@@ -378,7 +379,13 @@ private synchronized ICodeInfo decompile(boolean searchInCache) {\n \t\t\t\treturn code;\n \t\t\t}\n \t\t}\n-\t\tICodeInfo codeInfo = root.getProcessClasses().generateCode(this);\n+\t\tICodeInfo codeInfo;\n+\t\ttry {\n+\t\t\tcodeInfo = root.getProcessClasses().generateCode(this);\n+\t\t} catch (Throwable e) {\n+\t\t\taddError(\"Code generation failed\", e);\n+\t\t\tcodeInfo = new SimpleCodeInfo(Utils.getStackTrace(e));\n+\t\t}\n \t\tif (codeInfo != ICodeInfo.EMPTY) {\n \t\t\tcodeCache.add(clsRawName, codeInfo);\n \t\t}",
    "output": "Fix save classes with code generation error into cache"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/search/SearchTask.java b/jadx-gui/src/main/java/jadx/gui/search/SearchTask.java\n--- a/jadx-gui/src/main/java/jadx/gui/search/SearchTask.java\n+++ b/jadx-gui/src/main/java/jadx/gui/search/SearchTask.java\n@@ -3,6 +3,7 @@\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Consumer;\n@@ -65,6 +66,10 @@ public synchronized void fetchResults() {\n \t}\n \n \tpublic synchronized boolean addResult(JNode resultNode) {\n+\t\tif (isCanceled()) {\n+\t\t\t// ignore new results after cancel\n+\t\t\treturn true;\n+\t\t}\n \t\tthis.results.accept(resultNode);\n \t\tif (resultsLimit != 0 && resultsCount.incrementAndGet() >= resultsLimit) {\n \t\t\tcancel();\n@@ -76,9 +81,9 @@ public synchronized boolean addResult(JNode resultNode) {\n \tpublic synchronized void waitTask() {\n \t\tif (future != null) {\n \t\t\ttry {\n-\t\t\t\tfuture.get();\n+\t\t\t\tfuture.get(2, TimeUnit.SECONDS);\n \t\t\t} catch (Exception e) {\n-\t\t\t\tLOG.error(\"Wait search task failed\", e);\n+\t\t\t\tLOG.warn(\"Wait search task failed\", e);\n \t\t\t} finally {\n \t\t\t\tfuture.cancel(true);\n \t\t\t\tfuture = null;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n@@ -406,7 +406,6 @@ private boolean buildSearch(String text, SearchSettings searchSettings) {\n \tprivate synchronized void stopSearchTask() {\n \t\tif (searchTask != null) {\n \t\t\tsearchTask.cancel();\n-\t\t\tsearchTask.waitTask();\n \t\t\tsearchTask = null;\n \t\t}\n \t}",
    "output": "Fix ignore/limit waiting of canceled search task"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n@@ -225,7 +225,7 @@ private static void modifySyntheticMethod(ClassNode cls, MethodNode mth, InsnNod\n \t}\n \n \tprivate static boolean removeBridgeMethod(ClassNode cls, MethodNode mth) {\n-\t\tif (cls.root().getArgs().isRenameValid()) {\n+\t\tif (cls.root().getArgs().isInlineMethods()) { // simple wrapper remove is same as inline\n \t\t\tList<InsnNode> allInsns = BlockUtils.collectAllInsns(mth.getBasicBlocks());\n \t\t\tif (allInsns.size() == 1) {\n \t\t\t\tInsnNode wrappedInsn = allInsns.get(0);\n@@ -235,12 +235,10 @@ private static boolean removeBridgeMethod(ClassNode cls, MethodNode mth) {\n \t\t\t\t\t\twrappedInsn = ((InsnWrapArg) arg).getWrapInsn();\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tif (checkSyntheticWrapper(mth, wrappedInsn)) {\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n+\t\t\t\treturn checkSyntheticWrapper(mth, wrappedInsn);\n \t\t\t}\n \t\t}\n-\t\treturn !isMethodUnique(cls, mth);\n+\t\treturn false;\n \t}\n \n \tprivate static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {\n@@ -299,20 +297,6 @@ private static boolean registersAndCastsOnly(InsnArg arg) {\n \t\treturn false;\n \t}\n \n-\tprivate static boolean isMethodUnique(ClassNode cls, MethodNode mth) {\n-\t\tMethodInfo mi = mth.getMethodInfo();\n-\t\tfor (MethodNode otherMth : cls.getMethods()) {\n-\t\t\tif (otherMth != mth) {\n-\t\t\t\tMethodInfo omi = otherMth.getMethodInfo();\n-\t\t\t\tif (omi.getName().equals(mi.getName())\n-\t\t\t\t\t\t&& Objects.equals(omi.getArgumentsTypes(), mi.getArgumentsTypes())) {\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n \t/**\n \t * Remove public empty constructors (static or default)\n \t */\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n@@ -14,9 +14,7 @@\n import jadx.core.codegen.json.JsonMappingGen;\n import jadx.core.deobf.Deobfuscator;\n import jadx.core.deobf.NameMapper;\n-import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.nodes.RenameReasonAttr;\n-import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.nodes.ClassNode;\n@@ -196,11 +194,6 @@ private static void checkMethods(Deobfuscator deobfuscator, ClassNode cls, JadxA\n \t\tif (args.isRenameValid()) {\n \t\t\tSet<String> names = new HashSet<>(methods.size());\n \t\t\tfor (MethodNode mth : methods) {\n-\t\t\t\tAccessInfo accessFlags = mth.getAccessFlags();\n-\t\t\t\tif (accessFlags.isBridge() || accessFlags.isSynthetic()\n-\t\t\t\t\t\t|| mth.contains(AFlag.DONT_GENERATE) /* this flag not set yet */) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n \t\t\t\tString signature = mth.getMethodInfo().makeSignature(true, false);\n \t\t\t\tif (!names.add(signature)) {\n \t\t\t\t\tdeobfuscator.forceRenameMethod(mth);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inline/TestOverlapSyntheticMethods.java b/jadx-core/src/test/java/jadx/tests/integration/inline/TestOverlapSyntheticMethods.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inline/TestOverlapSyntheticMethods.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inline/TestOverlapSyntheticMethods.java\n@@ -0,0 +1,47 @@\n+package jadx.tests.integration.inline;\n+\n+import java.util.Collections;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+@SuppressWarnings(\"CommentedOutCode\")\n+public class TestOverlapSyntheticMethods extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tpublic String test(int i) {\n+\t\t\treturn a(i) + \"|\" + a(i);\n+\t\t}\n+\n+\t\tpublic int a(int i) {\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\tpublic String a(int i) {\n+\t\t\treturn \"i:\" + i;\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void testSmali() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"int a(int i) {\")\n+\t\t\t\t.containsOne(\"String m0a(int i) {\");\n+\t}\n+\n+\t@Test\n+\tpublic void testSmaliNoRename() {\n+\t\tgetArgs().setRenameFlags(Collections.emptySet());\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"int a(int i) {\")\n+\t\t\t\t.containsOne(\"String a(int i) {\")\n+\t\t\t\t.containsOne(\"return a(i) + \\\"|\\\" + a(i);\");\n+\t}\n+}",
    "output": "Fix check synthetic methods before remove/inline"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n@@ -45,8 +45,8 @@ private void process(RootNode root) {\n \t\t\tdeobfuscator.execute();\n \t\t}\n \n-\t\tcheckClasses(deobfuscator, root, args);\n \t\tUserRenames.applyForNodes(root);\n+\t\tcheckClasses(deobfuscator, root, args);\n \n \t\tif (args.isDeobfuscationOn() || !args.isJsonOutput()) {\n \t\t\tdeobfuscator.savePresets();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n@@ -38,6 +38,7 @@\n import jadx.api.data.impl.JadxCodeRef;\n import jadx.api.data.impl.JadxCodeRename;\n import jadx.api.data.impl.JadxNodeRef;\n+import jadx.core.deobf.NameMapper;\n import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.jobs.TaskStatus;\n@@ -58,6 +59,7 @@\n import jadx.gui.utils.NLS;\n import jadx.gui.utils.TextStandardActions;\n import jadx.gui.utils.UiUtils;\n+import jadx.gui.utils.ui.DocumentUpdateListener;\n \n public class RenameDialog extends JDialog {\n \tprivate static final long serialVersionUID = -3269715644416902410L;\n@@ -69,14 +71,16 @@ public class RenameDialog extends JDialog {\n \tprivate final transient JNode source;\n \tprivate final transient JNode node;\n \tprivate transient JTextField renameField;\n+\tprivate transient JButton renameBtn;\n \n \tpublic static boolean rename(MainWindow mainWindow, JNode node) {\n \t\treturn rename(mainWindow, node, node);\n \t}\n \n \tpublic static boolean rename(MainWindow mainWindow, JNode source, JNode node) {\n \t\tRenameDialog renameDialog = new RenameDialog(mainWindow, source, node);\n-\t\trenameDialog.setVisible(true);\n+\t\tUiUtils.uiRun(() -> renameDialog.setVisible(true));\n+\t\tUiUtils.uiRun(renameDialog::initRenameField); // wait for UI events to propagate\n \t\treturn true;\n \t}\n \n@@ -89,6 +93,11 @@ private RenameDialog(MainWindow mainWindow, JNode source, JNode node) {\n \t\tinitUI();\n \t}\n \n+\tprivate void initRenameField() {\n+\t\trenameField.setText(node.getName());\n+\t\trenameField.selectAll();\n+\t}\n+\n \tprivate JNode replaceNode(JNode node) {\n \t\tif (node instanceof JMethod) {\n \t\t\tJavaMethod javaMethod = ((JMethod) node).getJavaMethod();\n@@ -103,7 +112,19 @@ private JNode replaceNode(JNode node) {\n \t\treturn node;\n \t}\n \n+\tprivate boolean checkNewName() {\n+\t\tboolean valid = NameMapper.isValidIdentifier(renameField.getText());\n+\t\tif (renameBtn.isEnabled() != valid) {\n+\t\t\trenameBtn.setEnabled(valid);\n+\t\t\trenameField.putClientProperty(\"JComponent.outline\", valid ? \"\" : \"error\");\n+\t\t}\n+\t\treturn valid;\n+\t}\n+\n \tprivate void rename() {\n+\t\tif (!checkNewName()) {\n+\t\t\treturn;\n+\t\t}\n \t\ttry {\n \t\t\tupdateCodeRenames(set -> processRename(node, renameField.getText(), set));\n \t\t\trefreshState();\n@@ -270,7 +291,7 @@ private void refreshTabs(TabbedPane tabbedPane, Set<JClass> updatedClasses) {\n \tprotected JPanel initButtonsPanel() {\n \t\tJButton cancelButton = new JButton(NLS.str(\"search_dialog.cancel\"));\n \t\tcancelButton.addActionListener(event -> dispose());\n-\t\tJButton renameBtn = new JButton(NLS.str(\"common_dialog.ok\"));\n+\t\trenameBtn = new JButton(NLS.str(\"common_dialog.ok\"));\n \t\trenameBtn.addActionListener(event -> rename());\n \t\tgetRootPane().setDefaultButton(renameBtn);\n \n@@ -291,9 +312,8 @@ private void initUI() {\n \t\tlbl.setLabelFor(nodeLabel);\n \n \t\trenameField = new JTextField(40);\n+\t\trenameField.getDocument().addDocumentListener(new DocumentUpdateListener(ev -> checkNewName()));\n \t\trenameField.addActionListener(e -> rename());\n-\t\trenameField.setText(node.getName());\n-\t\trenameField.selectAll();\n \t\tnew TextStandardActions(renameField);\n \n \t\tJPanel renamePane = new JPanel();",
    "output": "Fix check user renames"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JavaVariable.java b/jadx-core/src/main/java/jadx/api/JavaVariable.java\n--- a/jadx-core/src/main/java/jadx/api/JavaVariable.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaVariable.java\n@@ -4,6 +4,7 @@\n import java.util.List;\n \n import org.jetbrains.annotations.ApiStatus;\n+import org.jetbrains.annotations.Nullable;\n \n import jadx.api.metadata.ICodeAnnotation;\n import jadx.api.metadata.annotations.VarNode;\n@@ -32,7 +33,7 @@ public int getSsa() {\n \t}\n \n \t@Override\n-\tpublic String getName() {\n+\tpublic @Nullable String getName() {\n \t\treturn varNode.getName();\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java\n@@ -70,6 +70,6 @@ public String getTooltip() {\n \n \t@Override\n \tpublic boolean canRename() {\n-\t\treturn true;\n+\t\treturn var.getName() != null;\n \t}\n }",
    "output": "Fix forbid rename method args in fallback mode"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/FileDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/FileDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/FileDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/FileDialog.java\n@@ -18,6 +18,7 @@\n \n import org.jetbrains.annotations.Nullable;\n \n+import jadx.api.plugins.utils.CommonFileUtils;\n import jadx.core.utils.Utils;\n import jadx.core.utils.files.FileUtils;\n import jadx.gui.settings.JadxProject;\n@@ -134,7 +135,7 @@ private void initForMode(OpenMode mode) {\n \t}\n \n \tprivate FileChooser buildFileChooser() {\n-\t\tFileChooser fileChooser = new FileChooser();\n+\t\tFileChooser fileChooser = new FileChooser(currentDir);\n \t\tfileChooser.setToolTipText(title);\n \t\tfileChooser.setFileSelectionMode(selectionMode);\n \t\tfileChooser.setMultiSelectionEnabled(isOpen);\n@@ -143,16 +144,18 @@ private FileChooser buildFileChooser() {\n \t\t\tString description = NLS.str(\"file_dialog.supported_files\") + \": (\" + Utils.listToString(fileExtList) + ')';\n \t\t\tfileChooser.setFileFilter(new FileNameExtensionFilter(description, fileExtList.toArray(new String[0])));\n \t\t}\n-\t\tif (currentDir != null) {\n-\t\t\tfileChooser.setCurrentDirectory(currentDir.toFile());\n-\t\t}\n \t\tif (selectedFile != null) {\n \t\t\tfileChooser.setSelectedFile(selectedFile.toFile());\n \t\t}\n \t\treturn fileChooser;\n \t}\n \n \tprivate class FileChooser extends JFileChooser {\n+\n+\t\tpublic FileChooser(@Nullable Path currentDirectory) {\n+\t\t\tsuper(currentDirectory == null ? CommonFileUtils.CWD : currentDirectory.toFile());\n+\t\t}\n+\n \t\t@Override\n \t\tprotected JDialog createDialog(Component parent) throws HeadlessException {\n \t\t\tJDialog dialog = super.createDialog(parent);",
    "output": "Fix set current dir directly in file chooser constructor"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n@@ -367,29 +367,33 @@ public void dispose() {\n \t\tcontentPanel = null;\n \n \t\t// also clear internals\n-\t\tsetIgnoreRepaint(true);\n-\t\tsetText(\"\");\n-\t\tsetEnabled(false);\n-\t\tsetSyntaxEditingStyle(SYNTAX_STYLE_NONE);\n-\t\tsetLinkGenerator(null);\n-\t\tfor (MouseListener mouseListener : getMouseListeners()) {\n-\t\t\tremoveMouseListener(mouseListener);\n-\t\t}\n-\t\tfor (MouseMotionListener mouseMotionListener : getMouseMotionListeners()) {\n-\t\t\tremoveMouseMotionListener(mouseMotionListener);\n-\t\t}\n-\t\tJPopupMenu popupMenu = getPopupMenu();\n-\t\tfor (PopupMenuListener popupMenuListener : popupMenu.getPopupMenuListeners()) {\n-\t\t\tpopupMenu.removePopupMenuListener(popupMenuListener);\n-\t\t}\n-\t\tfor (Component component : popupMenu.getComponents()) {\n-\t\t\tif (component instanceof JMenuItem) {\n-\t\t\t\tAction action = ((JMenuItem) component).getAction();\n-\t\t\t\tif (action instanceof JNodeAction) {\n-\t\t\t\t\t((JNodeAction) action).dispose();\n+\t\ttry {\n+\t\t\tsetIgnoreRepaint(true);\n+\t\t\tsetText(\"\");\n+\t\t\tsetEnabled(false);\n+\t\t\tsetSyntaxEditingStyle(SYNTAX_STYLE_NONE);\n+\t\t\tsetLinkGenerator(null);\n+\t\t\tfor (MouseListener mouseListener : getMouseListeners()) {\n+\t\t\t\tremoveMouseListener(mouseListener);\n+\t\t\t}\n+\t\t\tfor (MouseMotionListener mouseMotionListener : getMouseMotionListeners()) {\n+\t\t\t\tremoveMouseMotionListener(mouseMotionListener);\n+\t\t\t}\n+\t\t\tJPopupMenu popupMenu = getPopupMenu();\n+\t\t\tfor (PopupMenuListener popupMenuListener : popupMenu.getPopupMenuListeners()) {\n+\t\t\t\tpopupMenu.removePopupMenuListener(popupMenuListener);\n+\t\t\t}\n+\t\t\tfor (Component component : popupMenu.getComponents()) {\n+\t\t\t\tif (component instanceof JMenuItem) {\n+\t\t\t\t\tAction action = ((JMenuItem) component).getAction();\n+\t\t\t\t\tif (action instanceof JNodeAction) {\n+\t\t\t\t\t\t((JNodeAction) action).dispose();\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tpopupMenu.removeAll();\n+\t\t} catch (Throwable e) {\n+\t\t\tLOG.debug(\"Error on code area dispose\", e);\n \t\t}\n-\t\tpopupMenu.removeAll();\n \t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/SmaliArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/SmaliArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/SmaliArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/SmaliArea.java\n@@ -136,15 +136,15 @@ public void scrollToDebugPos(int pos) {\n \n \t@Override\n \tpublic Font getFont() {\n-\t\tif (model == null) {\n+\t\tif (model == null || isDisposed()) {\n \t\t\treturn super.getFont();\n \t\t}\n \t\treturn model.getFont();\n \t}\n \n \t@Override\n \tpublic Font getFontForTokenType(int type) {\n-\t\treturn model.getFont();\n+\t\treturn getFont();\n \t}\n \n \tprivate boolean shouldUseSmaliPrinterV2() {",
    "output": "Fix ignore errors on code area dispose"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java\n@@ -10,6 +10,7 @@\n \n @SuppressWarnings(\"MemberName\")\n public class QuarkReportData {\n+\n \tpublic static class Crime {\n \t\tpublic String crime;\n \t\tpublic String confidence;\n@@ -18,6 +19,23 @@ public static class Crime {\n \t\tList<Method> native_api;\n \t\tList<JsonElement> combination;\n \t\tList<Map<String, InvokePlace>> register;\n+\n+\t\tpublic int parseConfidence() {\n+\t\t\treturn Integer.parseInt(confidence.replace(\"%\", \"\"));\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tfinal StringBuffer sb = new StringBuffer(\"Crime{\");\n+\t\t\tsb.append(\"crime='\").append(crime).append('\\'');\n+\t\t\tsb.append(\", confidence='\").append(confidence).append('\\'');\n+\t\t\tsb.append(\", permissions=\").append(permissions);\n+\t\t\tsb.append(\", native_api=\").append(native_api);\n+\t\t\tsb.append(\", combination=\").append(combination);\n+\t\t\tsb.append(\", register=\").append(register);\n+\t\t\tsb.append('}');\n+\t\t\treturn sb.toString();\n+\t\t}\n \t}\n \n \tpublic static class Method {\n@@ -46,4 +64,22 @@ public static class InvokePlace {\n \tString threat_level;\n \tint total_score;\n \tList<Crime> crimes;\n+\n+\tpublic void validate() {\n+\t\tif (crimes == null) {\n+\t\t\tthrow new RuntimeException(\"Invalid data: \\\"crimes\\\" list missing\");\n+\t\t}\n+\t\tfor (Crime crime : crimes) {\n+\t\t\tif (crime.confidence == null) {\n+\t\t\t\tthrow new RuntimeException(\"Confidence value missing: \" + crime);\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\tcrime.parseConfidence();\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tthrow new RuntimeException(\"Invalid crime entry: \" + crime);\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportNode.java b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportNode.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportNode.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportNode.java\n@@ -1,5 +1,6 @@\n package jadx.gui.plugins.quark;\n \n+import java.io.BufferedReader;\n import java.nio.file.Files;\n import java.nio.file.Path;\n \n@@ -33,12 +34,12 @@ public class QuarkReportNode extends JNode {\n \n \tprivate static final ImageIcon ICON = UiUtils.openSvgIcon(\"ui/quark\");\n \n-\tprivate final Path apkFile;\n+\tprivate final Path reportFile;\n \n \tprivate ICodeInfo errorContent;\n \n-\tpublic QuarkReportNode(Path apkFile) {\n-\t\tthis.apkFile = apkFile;\n+\tpublic QuarkReportNode(Path reportFile) {\n+\t\tthis.reportFile = reportFile;\n \t}\n \n \t@Override\n@@ -59,7 +60,11 @@ public String makeString() {\n \t@Override\n \tpublic ContentPanel getContentPanel(TabbedPane tabbedPane) {\n \t\ttry {\n-\t\t\tQuarkReportData data = GSON.fromJson(Files.newBufferedReader(apkFile), QuarkReportData.class);\n+\t\t\tQuarkReportData data;\n+\t\t\ttry (BufferedReader reader = Files.newBufferedReader(reportFile)) {\n+\t\t\t\tdata = GSON.fromJson(reader, QuarkReportData.class);\n+\t\t\t}\n+\t\t\tdata.validate();\n \t\t\treturn new QuarkReportPanel(tabbedPane, this, data);\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Quark report parse error\", e);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java\n@@ -70,7 +70,7 @@ protected QuarkReportPanel(TabbedPane panel, QuarkReportNode node, QuarkReportDa\n \t}\n \n \tprivate void prepareData() {\n-\t\tdata.crimes.sort(Comparator.comparingInt(c -> -Integer.parseInt(c.confidence.replace(\"%\", \"\"))));\n+\t\tdata.crimes.sort(Comparator.comparingInt(c -> -c.parseConfidence()));\n \t}\n \n \tprivate void initUI() {\n@@ -290,7 +290,7 @@ public MutableTreeNode resolveMethod(String descr) {\n \t\t\t}\n \t\t\treturn new MethodTreeNode(javaMethod);\n \t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Failed to parse method descriptor string\", e);\n+\t\t\tLOG.error(\"Failed to parse method descriptor string: {}\", descr, e);\n \t\t\treturn new TextTreeNode(descr);\n \t\t}\n \t}",
    "output": "Fix QuarkReport data validation added and other minor improvements"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n@@ -57,6 +57,18 @@ public JadxProject(MainWindow mainWindow) {\n \t\tthis.mainWindow = mainWindow;\n \t}\n \n+\tpublic @Nullable Path getWorkingDir() {\n+\t\tif (projectPath != null) {\n+\t\t\treturn projectPath.toAbsolutePath().getParent();\n+\t\t}\n+\t\tList<Path> files = data.getFiles();\n+\t\tif (!files.isEmpty()) {\n+\t\t\tPath path = files.get(0);\n+\t\t\treturn path.toAbsolutePath().getParent();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \t@Nullable\n \tpublic Path getProjectPath() {\n \t\treturn projectPath;\n@@ -166,7 +178,7 @@ private Path buildCacheDir() {\n \t\t\tPath path = files.get(0);\n \t\t\treturn path.resolveSibling(path.getFileName() + \".cache\");\n \t\t}\n-\t\tthrow new JadxRuntimeException(\"Can't get working dir\");\n+\t\tthrow new JadxRuntimeException(\"Failed to build cache dir\");\n \t}\n \n \tpublic boolean isEnableLiveReload() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -44,6 +44,7 @@\n import javax.swing.Box;\n import javax.swing.ImageIcon;\n import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JFileChooser;\n import javax.swing.JFrame;\n import javax.swing.JMenu;\n import javax.swing.JMenuBar;\n@@ -85,7 +86,6 @@\n import jadx.api.ResourceFile;\n import jadx.api.plugins.utils.CommonFileUtils;\n import jadx.core.Jadx;\n-import jadx.core.dex.nodes.RootNode;\n import jadx.core.utils.ListUtils;\n import jadx.core.utils.StringUtils;\n import jadx.core.utils.files.FileUtils;\n@@ -362,17 +362,28 @@ private void saveProjectAs() {\n \t}\n \n \tprivate void exportMappings(MappingFormat mappingFormat) {\n-\t\tRootNode rootNode = wrapper.getDecompiler().getRoot();\n-\n-\t\tThread exportThread = new Thread(() -> {\n-\t\t\tnew MappingExporter(rootNode).exportMappings(\n-\t\t\t\t\tPaths.get(project.getProjectPath().getParent().toString(),\n-\t\t\t\t\t\t\t\"mappings\" + (mappingFormat.hasSingleFile() ? \".\" + mappingFormat.fileExt : \"\")),\n-\t\t\t\t\tproject.getCodeData(), mappingFormat);\n-\t\t});\n-\n-\t\tbackgroundExecutor.execute(NLS.str(\"progress.export_mappings\"), exportThread);\n-\t\tupdate();\n+\t\tFileDialog fileDialog = new FileDialog(this, FileDialog.OpenMode.CUSTOM_SAVE);\n+\t\tfileDialog.setTitle(NLS.str(\"file.export_mappings_as\"));\n+\t\tPath workingDir = project.getWorkingDir();\n+\t\tPath baseDir = workingDir != null ? workingDir : settings.getLastSaveFilePath();\n+\t\tif (mappingFormat.hasSingleFile()) {\n+\t\t\tfileDialog.setSelectedFile(baseDir.resolve(\"mappings.\" + mappingFormat.fileExt));\n+\t\t\tfileDialog.setFileExtList(Collections.singletonList(mappingFormat.fileExt));\n+\t\t\tfileDialog.setSelectionMode(JFileChooser.FILES_ONLY);\n+\t\t} else {\n+\t\t\tfileDialog.setCurrentDir(baseDir);\n+\t\t\tfileDialog.setSelectionMode(JFileChooser.DIRECTORIES_ONLY);\n+\t\t}\n+\t\tList<Path> paths = fileDialog.show();\n+\t\tif (paths.size() != 1) {\n+\t\t\treturn;\n+\t\t}\n+\t\tPath savePath = paths.get(0);\n+\t\tLOG.info(\"Export mappings to: {}\", savePath.toAbsolutePath());\n+\t\tbackgroundExecutor.execute(NLS.str(\"progress.export_mappings\"),\n+\t\t\t\t() -> new MappingExporter(wrapper.getDecompiler().getRoot())\n+\t\t\t\t\t\t.exportMappings(savePath, project.getCodeData(), mappingFormat),\n+\t\t\t\ts -> update());\n \t}\n \n \tvoid open(List<Path> paths) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/FileDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/FileDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/FileDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/FileDialog.java\n@@ -27,7 +27,12 @@\n public class FileDialog {\n \n \tpublic enum OpenMode {\n-\t\tOPEN, ADD, SAVE_PROJECT, EXPORT\n+\t\tOPEN,\n+\t\tADD,\n+\t\tSAVE_PROJECT,\n+\t\tEXPORT,\n+\t\tCUSTOM_SAVE,\n+\t\tCUSTOM_OPEN\n \t}\n \n \tprivate final MainWindow mainWindow;\n@@ -44,6 +49,26 @@ public FileDialog(MainWindow mainWindow, OpenMode mode) {\n \t\tinitForMode(mode);\n \t}\n \n+\tpublic void setTitle(String title) {\n+\t\tthis.title = title;\n+\t}\n+\n+\tpublic void setFileExtList(List<String> fileExtList) {\n+\t\tthis.fileExtList = fileExtList;\n+\t}\n+\n+\tpublic void setSelectionMode(int selectionMode) {\n+\t\tthis.selectionMode = selectionMode;\n+\t}\n+\n+\tpublic void setSelectedFile(Path path) {\n+\t\tthis.selectedFile = path;\n+\t}\n+\n+\tpublic void setCurrentDir(Path currentDir) {\n+\t\tthis.currentDir = currentDir;\n+\t}\n+\n \tpublic List<Path> show() {\n \t\tFileChooser fileChooser = buildFileChooser();\n \t\tint ret = isOpen ? fileChooser.showOpenDialog(mainWindow) : fileChooser.showSaveDialog(mainWindow);\n@@ -66,10 +91,6 @@ public Path getCurrentDir() {\n \t\treturn currentDir;\n \t}\n \n-\tpublic void setSelectedFile(Path path) {\n-\t\tthis.selectedFile = path;\n-\t}\n-\n \tprivate void initForMode(OpenMode mode) {\n \t\tswitch (mode) {\n \t\t\tcase OPEN:\n@@ -101,6 +122,14 @@ private void initForMode(OpenMode mode) {\n \t\t\t\tcurrentDir = mainWindow.getSettings().getLastSaveFilePath();\n \t\t\t\tisOpen = false;\n \t\t\t\tbreak;\n+\n+\t\t\tcase CUSTOM_SAVE:\n+\t\t\t\tisOpen = false;\n+\t\t\t\tbreak;\n+\n+\t\t\tcase CUSTOM_OPEN:\n+\t\t\t\tisOpen = true;\n+\t\t\t\tbreak;\n \t\t}\n \t}\n \n@@ -110,7 +139,7 @@ private FileChooser buildFileChooser() {\n \t\tfileChooser.setFileSelectionMode(selectionMode);\n \t\tfileChooser.setMultiSelectionEnabled(isOpen);\n \t\tfileChooser.setAcceptAllFileFilterUsed(true);\n-\t\tif (!fileExtList.isEmpty()) {\n+\t\tif (Utils.notEmpty(fileExtList)) {\n \t\t\tString description = NLS.str(\"file_dialog.supported_files\") + \": (\" + Utils.listToString(fileExtList) + ')';\n \t\t\tfileChooser.setFileFilter(new FileNameExtensionFilter(description, fileExtList.toArray(new String[0])));\n \t\t}",
    "output": "Fix allow to select file on mapping export"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n--- a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n+++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n@@ -145,11 +145,12 @@ protected TaskStatus doInBackground() throws Exception {\n \t\t\t\t\ttask.onDone(this);\n \t\t\t\t\t// treat UI task operations as part of the task to not mix with others\n \t\t\t\t\tUiUtils.uiRunAndWait(() -> {\n-\t\t\t\t\t\tprogressPane.setVisible(false);\n \t\t\t\t\t\ttask.onFinish(this);\n+\t\t\t\t\t\tprogressPane.setVisible(false);\n \t\t\t\t\t});\n \t\t\t\t} finally {\n \t\t\t\t\ttaskComplete(id);\n+\t\t\t\t\tprogressPane.changeVisibility(this, false);\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn status;\n@@ -230,13 +231,13 @@ private void performCancel(ThreadPoolExecutor executor) throws InterruptedExcept\n \t\t\t// force termination\n \t\t\ttask.cancel();\n \t\t\texecutor.shutdown();\n-\t\t\tif (executor.awaitTermination(5, TimeUnit.SECONDS)) {\n+\t\t\tif (executor.awaitTermination(2, TimeUnit.SECONDS)) {\n \t\t\t\tLOG.debug(\"Task cancel complete\");\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tLOG.debug(\"Forcing tasks cancel\");\n \t\t\texecutor.shutdownNow();\n-\t\t\tboolean complete = executor.awaitTermination(30, TimeUnit.SECONDS);\n+\t\t\tboolean complete = executor.awaitTermination(5, TimeUnit.SECONDS);\n \t\t\tLOG.debug(\"Forced task cancel status: {}\",\n \t\t\t\t\tcomplete ? \"success\" : \"fail, still active: \" + executor.getActiveCount());\n \t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n@@ -356,13 +356,21 @@ public JClass getJClass() {\n \t\treturn null;\n \t}\n \n+\tpublic boolean isDisposed() {\n+\t\treturn node == null;\n+\t}\n+\n \tpublic void dispose() {\n \t\t// code area reference can still be used somewhere in UI objects,\n \t\t// reset node reference to allow to GC jadx objects tree\n \t\tnode = null;\n \t\tcontentPanel = null;\n \n \t\t// also clear internals\n+\t\tsetIgnoreRepaint(true);\n+\t\tsetText(\"\");\n+\t\tsetEnabled(false);\n+\t\tsetSyntaxEditingStyle(SYNTAX_STYLE_NONE);\n \t\tsetLinkGenerator(null);\n \t\tfor (MouseListener mouseListener : getMouseListeners()) {\n \t\t\tremoveMouseListener(mouseListener);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/ClassCodeContentPanel.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/ClassCodeContentPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/ClassCodeContentPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/ClassCodeContentPanel.java\n@@ -165,10 +165,15 @@ public void restoreEditorViewState(EditorViewState viewState) {\n \t\t} catch (Exception e) {\n \t\t\tLOG.debug(\"Failed to restore view position: {}\", viewState.getViewPoint(), e);\n \t\t}\n+\t\tint caretPos = viewState.getCaretPos();\n \t\ttry {\n-\t\t\tactivePanel.getCodeArea().setCaretPosition(viewState.getCaretPos());\n+\t\t\tAbstractCodeArea codeArea = activePanel.getCodeArea();\n+\t\t\tint codeLen = codeArea.getDocument().getLength();\n+\t\t\tif (caretPos >= 0 && caretPos < codeLen) {\n+\t\t\t\tcodeArea.setCaretPosition(caretPos);\n+\t\t\t}\n \t\t} catch (Exception e) {\n-\t\t\tLOG.debug(\"Failed to restore caret position: {}\", viewState.getCaretPos(), e);\n+\t\t\tLOG.debug(\"Failed to restore caret position: {}\", caretPos, e);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n@@ -85,6 +85,10 @@ private void navToDecl(Point point, CodeLinkGenerator codeLinkGenerator) {\n \t@Override\n \tpublic ICodeInfo getCodeInfo() {\n \t\tif (cachedCodeInfo == null) {\n+\t\t\tif (isDisposed()) {\n+\t\t\t\tLOG.debug(\"CodeArea used after dispose!\");\n+\t\t\t\treturn ICodeInfo.EMPTY;\n+\t\t\t}\n \t\t\tcachedCodeInfo = Objects.requireNonNull(node.getCodeInfo());\n \t\t}\n \t\treturn cachedCodeInfo;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/JadxTokenMaker.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/JadxTokenMaker.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/JadxTokenMaker.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/JadxTokenMaker.java\n@@ -29,9 +29,12 @@ public JadxTokenMaker(CodeArea codeArea) {\n \n \t@Override\n \tpublic Token getTokenList(Segment text, int initialTokenType, int startOffset) {\n+\t\tif (codeArea.isDisposed()) {\n+\t\t\treturn new TokenImpl();\n+\t\t}\n \t\ttry {\n \t\t\tToken tokens = super.getTokenList(text, initialTokenType, startOffset);\n-\t\t\tif (tokens.getType() != TokenTypes.NULL) {\n+\t\t\tif (tokens != null && tokens.getType() != TokenTypes.NULL) {\n \t\t\t\tprocessTokens(tokens);\n \t\t\t}\n \t\t\treturn tokens;",
    "output": "Fix resolve various minor issues"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n@@ -307,7 +307,7 @@ private void searchFieldSubscribe() {\n \t\tFlowable<String> textChanges = onTextFieldChanges(searchField);\n \t\tFlowable<String> searchEvents = Flowable.merge(textChanges, searchEmitter.getFlowable());\n \t\tsearchDisposable = searchEvents\n-\t\t\t\t.debounce(100, TimeUnit.MILLISECONDS)\n+\t\t\t\t.debounce(500, TimeUnit.MILLISECONDS)\n \t\t\t\t.observeOn(SwingSchedulers.edt())\n \t\t\t\t.subscribe(this::search);\n \t}\n@@ -342,6 +342,7 @@ private synchronized void search(String text) {\n \t\t\treturn;\n \t\t}\n \n+\t\tupdateTableHighlight();\n \t\tstartSearch();\n \t\tsearchTask.setResultsLimit(100);\n \t\tsearchTask.setProgressListener(this::updateProgress);\n@@ -476,7 +477,6 @@ private void updateProgress(ITaskProgress progress) {\n \tprivate synchronized void searchComplete() {\n \t\tUiUtils.uiThreadGuard();\n \t\tLOG.debug(\"Search complete\");\n-\t\tupdateTableHighlight();\n \t\tupdateTable();\n \n \t\tboolean complete = searchTask == null || searchTask.isSearchComplete();",
    "output": "Fix correct set highlighted text in search"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Jadx.java b/jadx-core/src/main/java/jadx/core/Jadx.java\n--- a/jadx-core/src/main/java/jadx/core/Jadx.java\n+++ b/jadx-core/src/main/java/jadx/core/Jadx.java\n@@ -244,6 +244,10 @@ public static String getVersion() {\n \t\treturn version;\n \t}\n \n+\tpublic static boolean isDevVersion() {\n+\t\treturn getVersion().equals(VERSION_DEV);\n+\t}\n+\n \tprivate static String searchJadxVersion() {\n \t\ttry {\n \t\t\tClassLoader classLoader = Jadx.class.getClassLoader();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -45,7 +45,7 @@ public class JadxSettings extends JadxCLIArgs {\n \n \tprivate static final Path USER_HOME = Paths.get(System.getProperty(\"user.home\"));\n \tprivate static final int RECENT_PROJECTS_COUNT = 15;\n-\tprivate static final int CURRENT_SETTINGS_VERSION = 17;\n+\tprivate static final int CURRENT_SETTINGS_VERSION = 18;\n \n \tprivate static final Font DEFAULT_FONT = new RSyntaxTextArea().getFont();\n \n@@ -59,7 +59,7 @@ public class JadxSettings extends JadxCLIArgs {\n \tprivate Path lastOpenFilePath = USER_HOME;\n \tprivate Path lastSaveFilePath = USER_HOME;\n \tprivate boolean flattenPackage = false;\n-\tprivate boolean checkForUpdates = false;\n+\tprivate boolean checkForUpdates = true;\n \tprivate List<Path> recentProjects = new ArrayList<>();\n \tprivate String fontStr = \"\";\n \tprivate String smaliFontStr = \"\";\n@@ -715,6 +715,10 @@ private void upgradeSettings(int fromVersion) {\n \t\t\t}\n \t\t\tfromVersion++;\n \t\t}\n+\t\tif (fromVersion == 17) {\n+\t\t\tcheckForUpdates = true;\n+\t\t\tfromVersion++;\n+\t\t}\n \t\tif (fromVersion != CURRENT_SETTINGS_VERSION) {\n \t\t\tLOG.warn(\"Incorrect settings upgrade. Expected version: {}, got: {}\", CURRENT_SETTINGS_VERSION, fromVersion);\n \t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -814,7 +814,6 @@ public void syncWithEditor() {\n \t}\n \n \tprivate void initMenuAndToolbar() {\n-\t\tfinal boolean devVersion = (Jadx.VERSION_DEV.equals(Jadx.getVersion()));\n \t\tAction openAction = new AbstractAction(NLS.str(\"file.open_action\"), ICON_OPEN) {\n \t\t\t@Override\n \t\t\tpublic void actionPerformed(ActionEvent e) {\n@@ -1124,7 +1123,7 @@ public void actionPerformed(ActionEvent e) {\n \t\tJMenu help = new JMenu(NLS.str(\"menu.help\"));\n \t\thelp.setMnemonic(KeyEvent.VK_H);\n \t\thelp.add(logAction);\n-\t\tif (devVersion) {\n+\t\tif (Jadx.isDevVersion()) {\n \t\t\thelp.add(new AbstractAction(\"Show sample error report\") {\n \t\t\t\t@Override\n \t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java b/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java\n--- a/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java\n+++ b/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java\n@@ -15,6 +15,7 @@\n import com.google.gson.reflect.TypeToken;\n \n import jadx.api.JadxDecompiler;\n+import jadx.core.Jadx;\n import jadx.gui.update.data.Release;\n \n @SuppressWarnings(\"SameParameterValue\")\n@@ -56,20 +57,20 @@ public static void check(final IUpdateCallback callback) {\n \t}\n \n \tprivate static Release checkForNewRelease() throws IOException {\n-\t\tString version = JadxDecompiler.getVersion();\n-\t\tif (version.contains(\"dev\")) {\n+\t\tif (Jadx.isDevVersion()) {\n \t\t\tLOG.debug(\"Ignore check for update: development version\");\n \t\t\treturn null;\n \t\t}\n \t\tRelease latest = get(GITHUB_LATEST_RELEASE_URL, RELEASE_TYPE);\n \t\tif (latest == null) {\n \t\t\treturn null;\n \t\t}\n+\t\tString currentVersion = JadxDecompiler.getVersion();\n \t\tString latestName = latest.getName();\n-\t\tif (latestName.equalsIgnoreCase(version)) {\n+\t\tif (latestName.equalsIgnoreCase(currentVersion)) {\n \t\t\treturn null;\n \t\t}\n-\t\tif (VersionComparator.checkAndCompare(version, latestName) >= 0) {\n+\t\tif (VersionComparator.checkAndCompare(currentVersion, latestName) >= 0) {\n \t\t\treturn null;\n \t\t}\n \t\tLOG.info(\"Found new jadx version: {}\", latest);",
    "output": "Fix force jadx new version check by default"
  },
  {
    "input": "diff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver22.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver22.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver22.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver22.java\n@@ -0,0 +1,29 @@\n+package jadx.tests.integration.types;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.extensions.profiles.TestProfile;\n+import jadx.tests.api.extensions.profiles.TestWithProfiles;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestTypeResolver22 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic void test(InputStream input, long count) throws IOException {\n+\t\t\tlong pos = input.skip(count);\n+\t\t\twhile (pos < count) {\n+\t\t\t\tpos += input.skip(count - pos);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@TestWithProfiles({ TestProfile.JAVA8, TestProfile.DX_J8 })\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"long pos = \");\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver23.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver23.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver23.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver23.java\n@@ -0,0 +1,30 @@\n+package jadx.tests.integration.types;\n+\n+import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.extensions.profiles.TestProfile;\n+import jadx.tests.api.extensions.profiles.TestWithProfiles;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestTypeResolver23 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic long test(int a) {\n+\t\t\tlong v = 1L;\n+\t\t\tif (a == 2) {\n+\t\t\t\tv = 2L;\n+\t\t\t} else if (a == 3) {\n+\t\t\t\tv = 3L;\n+\t\t\t}\n+\t\t\tSystem.out.println(v);\n+\t\t\treturn v;\n+\t\t}\n+\t}\n+\n+\t@TestWithProfiles({ TestProfile.JAVA8, TestProfile.DX_J8 })\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"long v\");\n+\t}\n+}\n\ndiff --git a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaInsnsRegister.java b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaInsnsRegister.java\n--- a/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaInsnsRegister.java\n+++ b/jadx-plugins/jadx-java-input/src/main/java/jadx/plugins/input/java/data/code/JavaInsnsRegister.java\n@@ -59,30 +59,30 @@ public class JavaInsnsRegister {\n \t\tloadConst(arr, 0x14, \"ldc2_w\", true);\n \n \t\tregister(arr, 0x15, \"iload\", 1, 2, Opcode.MOVE, s -> s.local(1, s.u1()).push(0));\n-\t\tregister(arr, 0x16, \"lload\", 1, 2, Opcode.MOVE, s -> s.local(1, s.u1()).pushWide(0));\n+\t\tregister(arr, 0x16, \"lload\", 1, 2, Opcode.MOVE_WIDE, s -> s.local(1, s.u1()).pushWide(0));\n \t\tregister(arr, 0x17, \"fload\", 1, 2, Opcode.MOVE, s -> s.local(1, s.u1()).push(0));\n-\t\tregister(arr, 0x18, \"dload\", 1, 2, Opcode.MOVE, s -> s.local(1, s.u1()).pushWide(0));\n+\t\tregister(arr, 0x18, \"dload\", 1, 2, Opcode.MOVE_WIDE, s -> s.local(1, s.u1()).pushWide(0));\n \t\tregister(arr, 0x19, \"aload\", 1, 2, Opcode.MOVE, s -> s.local(1, s.u1()).push(0));\n \n \t\tregister(arr, 0x1a, \"iload_0\", 0, 2, Opcode.MOVE, s -> s.local(1, 0).push(0));\n \t\tregister(arr, 0x1b, \"iload_1\", 0, 2, Opcode.MOVE, s -> s.local(1, 1).push(0));\n \t\tregister(arr, 0x1c, \"iload_2\", 0, 2, Opcode.MOVE, s -> s.local(1, 2).push(0));\n \t\tregister(arr, 0x1d, \"iload_3\", 0, 2, Opcode.MOVE, s -> s.local(1, 3).push(0));\n \n-\t\tregister(arr, 0x1e, \"lload_0\", 0, 2, Opcode.MOVE, s -> s.local(1, 0).pushWide(0));\n-\t\tregister(arr, 0x1f, \"lload_1\", 0, 2, Opcode.MOVE, s -> s.local(1, 1).pushWide(0));\n-\t\tregister(arr, 0x20, \"lload_2\", 0, 2, Opcode.MOVE, s -> s.local(1, 2).pushWide(0));\n-\t\tregister(arr, 0x21, \"lload_3\", 0, 2, Opcode.MOVE, s -> s.local(1, 3).pushWide(0));\n+\t\tregister(arr, 0x1e, \"lload_0\", 0, 2, Opcode.MOVE_WIDE, s -> s.local(1, 0).pushWide(0));\n+\t\tregister(arr, 0x1f, \"lload_1\", 0, 2, Opcode.MOVE_WIDE, s -> s.local(1, 1).pushWide(0));\n+\t\tregister(arr, 0x20, \"lload_2\", 0, 2, Opcode.MOVE_WIDE, s -> s.local(1, 2).pushWide(0));\n+\t\tregister(arr, 0x21, \"lload_3\", 0, 2, Opcode.MOVE_WIDE, s -> s.local(1, 3).pushWide(0));\n \n \t\tregister(arr, 0x22, \"fload_0\", 0, 2, Opcode.MOVE, s -> s.local(1, 0).push(0));\n \t\tregister(arr, 0x23, \"fload_1\", 0, 2, Opcode.MOVE, s -> s.local(1, 1).push(0));\n \t\tregister(arr, 0x24, \"fload_2\", 0, 2, Opcode.MOVE, s -> s.local(1, 2).push(0));\n \t\tregister(arr, 0x25, \"fload_3\", 0, 2, Opcode.MOVE, s -> s.local(1, 3).push(0));\n \n-\t\tregister(arr, 0x26, \"dload_0\", 0, 2, Opcode.MOVE, s -> s.local(1, 0).pushWide(0));\n-\t\tregister(arr, 0x27, \"dload_1\", 0, 2, Opcode.MOVE, s -> s.local(1, 1).pushWide(0));\n-\t\tregister(arr, 0x28, \"dload_2\", 0, 2, Opcode.MOVE, s -> s.local(1, 2).pushWide(0));\n-\t\tregister(arr, 0x29, \"dload_3\", 0, 2, Opcode.MOVE, s -> s.local(1, 3).pushWide(0));\n+\t\tregister(arr, 0x26, \"dload_0\", 0, 2, Opcode.MOVE_WIDE, s -> s.local(1, 0).pushWide(0));\n+\t\tregister(arr, 0x27, \"dload_1\", 0, 2, Opcode.MOVE_WIDE, s -> s.local(1, 1).pushWide(0));\n+\t\tregister(arr, 0x28, \"dload_2\", 0, 2, Opcode.MOVE_WIDE, s -> s.local(1, 2).pushWide(0));\n+\t\tregister(arr, 0x29, \"dload_3\", 0, 2, Opcode.MOVE_WIDE, s -> s.local(1, 3).pushWide(0));\n \n \t\tregister(arr, 0x2a, \"aload_0\", 0, 2, Opcode.MOVE, s -> s.local(1, 0).push(0));\n \t\tregister(arr, 0x2b, \"aload_1\", 0, 2, Opcode.MOVE, s -> s.local(1, 1).push(0));\n@@ -99,30 +99,30 @@ public class JavaInsnsRegister {\n \t\tregister(arr, 0x35, \"saload\", 0, 3, Opcode.AGET_SHORT, aget());\n \n \t\tregister(arr, 0x36, \"istore\", 1, 2, Opcode.MOVE, s -> s.pop(1).local(0, s.u1()));\n-\t\tregister(arr, 0x37, \"lstore\", 1, 2, Opcode.MOVE, s -> s.pop(1).local(0, s.u1()));\n+\t\tregister(arr, 0x37, \"lstore\", 1, 2, Opcode.MOVE_WIDE, s -> s.pop(1).local(0, s.u1()));\n \t\tregister(arr, 0x38, \"fstore\", 1, 2, Opcode.MOVE, s -> s.pop(1).local(0, s.u1()));\n-\t\tregister(arr, 0x39, \"dstore\", 1, 2, Opcode.MOVE, s -> s.pop(1).local(0, s.u1()));\n+\t\tregister(arr, 0x39, \"dstore\", 1, 2, Opcode.MOVE_WIDE, s -> s.pop(1).local(0, s.u1()));\n \t\tregister(arr, 0x3a, \"astore\", 1, 2, Opcode.MOVE, s -> s.pop(1).local(0, s.u1()));\n \n \t\tregister(arr, 0x3b, \"istore_0\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 0));\n \t\tregister(arr, 0x3c, \"istore_1\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 1));\n \t\tregister(arr, 0x3d, \"istore_2\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 2));\n \t\tregister(arr, 0x3e, \"istore_3\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 3));\n \n-\t\tregister(arr, 0x3f, \"lstore_0\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 0));\n-\t\tregister(arr, 0x40, \"lstore_1\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 1));\n-\t\tregister(arr, 0x41, \"lstore_2\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 2));\n-\t\tregister(arr, 0x42, \"lstore_3\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 3));\n+\t\tregister(arr, 0x3f, \"lstore_0\", 0, 2, Opcode.MOVE_WIDE, s -> s.pop(1).local(0, 0));\n+\t\tregister(arr, 0x40, \"lstore_1\", 0, 2, Opcode.MOVE_WIDE, s -> s.pop(1).local(0, 1));\n+\t\tregister(arr, 0x41, \"lstore_2\", 0, 2, Opcode.MOVE_WIDE, s -> s.pop(1).local(0, 2));\n+\t\tregister(arr, 0x42, \"lstore_3\", 0, 2, Opcode.MOVE_WIDE, s -> s.pop(1).local(0, 3));\n \n \t\tregister(arr, 0x43, \"fstore_0\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 0));\n \t\tregister(arr, 0x44, \"fstore_1\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 1));\n \t\tregister(arr, 0x45, \"fstore_2\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 2));\n \t\tregister(arr, 0x46, \"fstore_3\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 3));\n \n-\t\tregister(arr, 0x47, \"dstore_0\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 0));\n-\t\tregister(arr, 0x48, \"dstore_1\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 1));\n-\t\tregister(arr, 0x49, \"dstore_2\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 2));\n-\t\tregister(arr, 0x4a, \"dstore_3\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 3));\n+\t\tregister(arr, 0x47, \"dstore_0\", 0, 2, Opcode.MOVE_WIDE, s -> s.pop(1).local(0, 0));\n+\t\tregister(arr, 0x48, \"dstore_1\", 0, 2, Opcode.MOVE_WIDE, s -> s.pop(1).local(0, 1));\n+\t\tregister(arr, 0x49, \"dstore_2\", 0, 2, Opcode.MOVE_WIDE, s -> s.pop(1).local(0, 2));\n+\t\tregister(arr, 0x4a, \"dstore_3\", 0, 2, Opcode.MOVE_WIDE, s -> s.pop(1).local(0, 3));\n \n \t\tregister(arr, 0x4b, \"astore_0\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 0));\n \t\tregister(arr, 0x4c, \"astore_1\", 0, 2, Opcode.MOVE, s -> s.pop(1).local(0, 1));",
    "output": "Use wide move for long/double store/load java opcodes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -614,21 +614,23 @@ private String useClassInternal(ClassInfo useCls, ClassInfo extClsInfo) {\n \t\tif (useCls.equals(extClsInfo)) {\n \t\t\treturn shortName;\n \t\t}\n-\t\tif (extClsInfo.getPackage().equals(\"java.lang\") && extClsInfo.getParentClass() == null) {\n-\t\t\treturn shortName;\n-\t\t}\n \t\tif (isClassInnerFor(useCls, extClsInfo)) {\n \t\t\treturn shortName;\n \t\t}\n \t\tif (extClsInfo.isInner()) {\n \t\t\treturn expandInnerClassName(useCls, extClsInfo);\n \t\t}\n-\t\tif (searchCollision(cls.root(), useCls, extClsInfo)) {\n+\t\tif (checkInnerCollision(cls.root(), useCls, extClsInfo)\n+\t\t\t\t|| checkInPackageCollision(cls.root(), useCls, extClsInfo)) {\n \t\t\treturn fullName;\n \t\t}\n \t\tif (isBothClassesInOneTopClass(useCls, extClsInfo)) {\n \t\t\treturn shortName;\n \t\t}\n+\t\t// don't add import for top classes from 'java.lang' package (subpackages excluded)\n+\t\tif (extClsInfo.getPackage().equals(\"java.lang\") && extClsInfo.getParentClass() == null) {\n+\t\t\treturn shortName;\n+\t\t}\n \t\t// don't add import if this class from same package\n \t\tif (extClsInfo.getPackage().equals(useCls.getPackage()) && !extClsInfo.isInner()) {\n \t\t\treturn shortName;\n@@ -709,7 +711,7 @@ private static boolean isClassInnerFor(ClassInfo inner, ClassInfo parent) {\n \t\treturn false;\n \t}\n \n-\tprivate static boolean searchCollision(RootNode root, ClassInfo useCls, ClassInfo searchCls) {\n+\tprivate static boolean checkInnerCollision(RootNode root, @Nullable ClassInfo useCls, ClassInfo searchCls) {\n \t\tif (useCls == null) {\n \t\t\treturn false;\n \t\t}\n@@ -726,7 +728,20 @@ private static boolean searchCollision(RootNode root, ClassInfo useCls, ClassInf\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\treturn searchCollision(root, useCls.getParentClass(), searchCls);\n+\t\treturn checkInnerCollision(root, useCls.getParentClass(), searchCls);\n+\t}\n+\n+\t/**\n+\t * Check if class with same name exists in current package\n+\t */\n+\tprivate static boolean checkInPackageCollision(RootNode root, ClassInfo useCls, ClassInfo searchCls) {\n+\t\tString currentPkg = useCls.getAliasPkg();\n+\t\tif (currentPkg.equals(searchCls.getAliasPkg())) {\n+\t\t\t// search class already from current package\n+\t\t\treturn false;\n+\t\t}\n+\t\tString shortName = searchCls.getAliasShortName();\n+\t\treturn root.getClsp().isClsKnown(currentPkg + '.' + shortName);\n \t}\n \n \tprivate void insertRenameInfo(ICodeWriter code, ClassNode cls) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/TestCollisionWithJavaLangClasses.java b/jadx-core/src/test/java/jadx/tests/integration/names/TestCollisionWithJavaLangClasses.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/TestCollisionWithJavaLangClasses.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestCollisionWithJavaLangClasses.java\n@@ -0,0 +1,59 @@\n+package jadx.tests.integration.names;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestCollisionWithJavaLangClasses extends IntegrationTest {\n+\n+\tpublic static class TestCls1 {\n+\t\tpublic static class System {\n+\t\t\tpublic static void main(String[] args) {\n+\t\t\t\tjava.lang.System.out.println(\"Hello world\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test1() {\n+\t\tassertThat(getClassNode(TestCls1.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"java.lang.System.out.println\");\n+\t}\n+\n+\tpublic static class TestCls2 {\n+\t\tpublic void doSomething() {\n+\t\t\tSystem.doSomething();\n+\t\t\tjava.lang.System.out.println(\"Hello World\");\n+\t\t}\n+\n+\t\tpublic static class System {\n+\t\t\tpublic static void doSomething() {\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test2() {\n+\t\tassertThat(getClassNode(TestCls2.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsLine(2, \"System.doSomething();\")\n+\t\t\t\t.containsOne(\"java.lang.System.out.println\");\n+\t}\n+\n+\t@Test\n+\tpublic void test3() {\n+\t\tList<ClassNode> classes = getClassNodes(\n+\t\t\t\tjadx.tests.integration.names.pkg2.System.class,\n+\t\t\t\tjadx.tests.integration.names.pkg2.TestCls.class);\n+\t\tassertThat(searchCls(classes, \"TestCls\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsLine(2, \"System.doSomething();\")\n+\t\t\t\t.containsOne(\"java.lang.System.out.println\");\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/pkg2/System.java b/jadx-core/src/test/java/jadx/tests/integration/names/pkg2/System.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/pkg2/System.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/pkg2/System.java\n@@ -0,0 +1,6 @@\n+package jadx.tests.integration.names.pkg2;\n+\n+public class System {\n+\tpublic static void doSomething() {\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/pkg2/TestCls.java b/jadx-core/src/test/java/jadx/tests/integration/names/pkg2/TestCls.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/pkg2/TestCls.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/pkg2/TestCls.java\n@@ -0,0 +1,8 @@\n+package jadx.tests.integration.names.pkg2;\n+\n+public class TestCls {\n+\tpublic void doSomething() {\n+\t\tSystem.doSomething();\n+\t\tjava.lang.System.out.println(\"Hello World\");\n+\t}\n+}",
    "output": "Fix check class name collisions"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n@@ -362,31 +362,41 @@ private static boolean checkArrSizes(MethodNode mth, NewArrayNode newArrInsn, Fi\n \tprivate static void removeCheckCast(MethodNode mth, BlockNode block, int i, IndexInsnNode insn) {\n \t\tInsnArg castArg = insn.getArg(0);\n \t\tArgType castType = (ArgType) insn.getIndex();\n-\t\tif (!ArgType.isCastNeeded(mth.root(), castArg.getType(), castType)\n-\t\t\t\t|| isCastDuplicate(insn)) {\n+\t\tif (!ArgType.isCastNeeded(mth.root(), castArg.getType(), castType)) {\n \t\t\tRegisterArg result = insn.getResult();\n \t\t\tresult.setType(castArg.getType());\n \n \t\t\tInsnNode move = new InsnNode(InsnType.MOVE, 1);\n \t\t\tmove.setResult(result);\n \t\t\tmove.addArg(castArg);\n \t\t\treplaceInsn(mth, block, i, move);\n+\t\t\treturn;\n+\t\t}\n+\t\tInsnNode prevCast = isCastDuplicate(insn);\n+\t\tif (prevCast != null) {\n+\t\t\t// replace previous cast with move\n+\t\t\tInsnNode move = new InsnNode(InsnType.MOVE, 1);\n+\t\t\tmove.setResult(prevCast.getResult());\n+\t\t\tmove.addArg(prevCast.getArg(0));\n+\t\t\treplaceInsn(mth, block, prevCast, move);\n \t\t}\n \t}\n \n-\tprivate static boolean isCastDuplicate(IndexInsnNode castInsn) {\n+\tprivate static @Nullable InsnNode isCastDuplicate(IndexInsnNode castInsn) {\n \t\tInsnArg arg = castInsn.getArg(0);\n \t\tif (arg.isRegister()) {\n \t\t\tSSAVar sVar = ((RegisterArg) arg).getSVar();\n \t\t\tif (sVar != null && sVar.getUseCount() == 1 && !sVar.isUsedInPhi()) {\n \t\t\t\tInsnNode assignInsn = sVar.getAssign().getParentInsn();\n \t\t\t\tif (assignInsn != null && assignInsn.getType() == InsnType.CHECK_CAST) {\n \t\t\t\t\tArgType assignCastType = (ArgType) ((IndexInsnNode) assignInsn).getIndex();\n-\t\t\t\t\treturn assignCastType.equals(castInsn.getIndex());\n+\t\t\t\t\tif (assignCastType.equals(castInsn.getIndex())) {\n+\t\t\t\t\t\treturn assignInsn;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\treturn false;\n+\t\treturn null;\n \t}\n \n \t/**\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver21.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver21.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver21.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver21.java\n@@ -0,0 +1,29 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+/**\n+ * Issue 1527\n+ */\n+@SuppressWarnings(\"CommentedOutCode\")\n+public class TestTypeResolver21 extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tpublic Number test(Object objectArray) {\n+\t\t\tObject[] arr = (Object[]) objectArray;\n+\t\t\treturn (Number) arr[0];\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"Object[] arr = (Object[]) objectArray;\");\n+\t}\n+}",
    "output": "Fix keep types on duplicate cast remove"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n@@ -66,8 +66,14 @@ private static int processAndSave(JadxCLIArgs cliArgs) {\n \n \tprivate static boolean checkForErrors(JadxDecompiler jadx) {\n \t\tif (jadx.getRoot().getClasses().isEmpty()) {\n-\t\t\tLOG.error(\"Load failed! No classes for decompile!\");\n-\t\t\treturn true;\n+\t\t\tif (jadx.getArgs().isSkipResources()) {\n+\t\t\t\tLOG.error(\"Load failed! No classes for decompile!\");\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (!jadx.getArgs().isSkipSources()) {\n+\t\t\t\tLOG.warn(\"No classes to decompile; decoding resources only\");\n+\t\t\t\tjadx.getArgs().setSkipSources(true);\n+\t\t\t}\n \t\t}\n \t\tif (jadx.getErrorsCount() > 0) {\n \t\t\tLOG.error(\"Load with errors! Check log for details\");\n\ndiff --git a/jadx-cli/src/test/java/jadx/cli/TestInput.java b/jadx-cli/src/test/java/jadx/cli/TestInput.java\n--- a/jadx-cli/src/test/java/jadx/cli/TestInput.java\n+++ b/jadx-cli/src/test/java/jadx/cli/TestInput.java\n@@ -44,6 +44,33 @@ public void testMultipleInput() throws Exception {\n \t\tdecompile(\"multi\", \"samples/hello.dex\", \"samples/HelloWorld.smali\");\n \t}\n \n+\t@Test\n+\tpublic void testResourceOnly() throws Exception {\n+\t\tdecode(\"resourceOnly\", \"samples/resources-only.apk\");\n+\t}\n+\n+\tprivate void decode(String tmpDirName, String apkSample) throws URISyntaxException, IOException {\n+\t\tList<String> args = new ArrayList<>();\n+\t\tPath tempDir = FileUtils.createTempDir(tmpDirName);\n+\t\targs.add(\"-v\");\n+\t\targs.add(\"-d\");\n+\t\targs.add(tempDir.toAbsolutePath().toString());\n+\n+\t\tURL resource = getClass().getClassLoader().getResource(apkSample);\n+\t\tassertThat(resource).isNotNull();\n+\t\tString sampleFile = resource.toURI().getRawPath();\n+\t\targs.add(sampleFile);\n+\n+\t\tint result = JadxCLI.execute(args.toArray(new String[0]));\n+\t\tassertThat(result).isEqualTo(0);\n+\t\tList<Path> files = Files.find(\n+\t\t\t\ttempDir,\n+\t\t\t\t3,\n+\t\t\t\t(file, attr) -> file.getFileName().toString().equalsIgnoreCase(\"AndroidManifest.xml\"))\n+\t\t\t\t.collect(Collectors.toList());\n+\t\tassertThat(files.isEmpty()).isFalse();\n+\t}\n+\n \tprivate void decompile(String tmpDirName, String... inputSamples) throws URISyntaxException, IOException {\n \t\tList<String> args = new ArrayList<>();\n \t\tPath tempDir = FileUtils.createTempDir(tmpDirName);",
    "output": "Fix allow decoding resource-only APKs * Process resource-only inputs * Fix error, add testing"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n@@ -39,11 +39,14 @@\n import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;\n import static jadx.core.dex.nodes.ProcessState.PROCESS_COMPLETE;\n \n+@SuppressWarnings(\"ConstantConditions\")\n public class JadxWrapper {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(JadxWrapper.class);\n \n+\tprivate static final Object DECOMPILER_UPDATE_SYNC = new Object();\n+\n \tprivate final MainWindow mainWindow;\n-\tprivate @Nullable JadxDecompiler decompiler;\n+\tprivate volatile @Nullable JadxDecompiler decompiler;\n \n \tpublic JadxWrapper(MainWindow mainWindow) {\n \t\tthis.mainWindow = mainWindow;\n@@ -52,14 +55,16 @@ public JadxWrapper(MainWindow mainWindow) {\n \tpublic void open() {\n \t\tclose();\n \t\ttry {\n-\t\t\tJadxProject project = getProject();\n-\t\t\tJadxArgs jadxArgs = getSettings().toJadxArgs();\n-\t\t\tjadxArgs.setInputFiles(FileUtils.toFiles(project.getFilePaths()));\n-\t\t\tjadxArgs.setCodeData(project.getCodeData());\n-\n-\t\t\tthis.decompiler = new JadxDecompiler(jadxArgs);\n-\t\t\tthis.decompiler.load();\n-\t\t\tinitCodeCache();\n+\t\t\tsynchronized (DECOMPILER_UPDATE_SYNC) {\n+\t\t\t\tJadxProject project = getProject();\n+\t\t\t\tJadxArgs jadxArgs = getSettings().toJadxArgs();\n+\t\t\t\tjadxArgs.setInputFiles(FileUtils.toFiles(project.getFilePaths()));\n+\t\t\t\tjadxArgs.setCodeData(project.getCodeData());\n+\n+\t\t\t\tthis.decompiler = new JadxDecompiler(jadxArgs);\n+\t\t\t\tthis.decompiler.load();\n+\t\t\t\tinitCodeCache();\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Jadx decompiler wrapper init error\", e);\n \t\t\tclose();\n@@ -77,13 +82,15 @@ public void unloadClasses() {\n \n \tpublic void close() {\n \t\ttry {\n-\t\t\tif (decompiler != null) {\n-\t\t\t\tdecompiler.close();\n+\t\t\tsynchronized (DECOMPILER_UPDATE_SYNC) {\n+\t\t\t\tif (decompiler != null) {\n+\t\t\t\t\tdecompiler.close();\n+\t\t\t\t\tdecompiler = null;\n+\t\t\t\t}\n \t\t\t}\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Jadx decompiler close error\", e);\n \t\t} finally {\n-\t\t\tdecompiler = null;\n \t\t\tmainWindow.getCacheObject().reset();\n \t\t}\n \t}",
    "output": "Add volatile and update sync for decompiler field in wrapper"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n@@ -123,9 +123,6 @@ public class JadxCLIArgs {\n \t)\n \tprotected DeobfuscationMapFileMode deobfuscationMapFileMode = DeobfuscationMapFileMode.READ;\n \n-\t@Parameter(names = { \"--deobf-rewrite-cfg\" }, description = \"set '--deobf-cfg-file-mode' to 'overwrite' (deprecated)\")\n-\tprotected boolean deobfuscationForceSave = false;\n-\n \t@Parameter(names = { \"--deobf-use-sourcename\" }, description = \"use source file name as class name alias\")\n \tprotected boolean deobfuscationUseSourceNameAsAlias = false;\n \n@@ -259,11 +256,7 @@ public JadxArgs toJadxArgs() {\n \t\targs.setReplaceConsts(replaceConsts);\n \t\targs.setDeobfuscationOn(deobfuscationOn);\n \t\targs.setDeobfuscationMapFile(FileUtils.toFile(deobfuscationMapFile));\n-\t\tif (deobfuscationForceSave) {\n-\t\t\targs.setDeobfuscationMapFileMode(DeobfuscationMapFileMode.OVERWRITE);\n-\t\t} else {\n-\t\t\targs.setDeobfuscationMapFileMode(deobfuscationMapFileMode);\n-\t\t}\n+\t\targs.setDeobfuscationMapFileMode(deobfuscationMapFileMode);\n \t\targs.setDeobfuscationMinLength(deobfuscationMinLength);\n \t\targs.setDeobfuscationMaxLength(deobfuscationMaxLength);\n \t\targs.setUseSourceNameAsClassAlias(deobfuscationUseSourceNameAsAlias);\n@@ -377,10 +370,6 @@ public DeobfuscationMapFileMode getDeobfuscationMapFileMode() {\n \t\treturn deobfuscationMapFileMode;\n \t}\n \n-\tpublic boolean isDeobfuscationForceSave() {\n-\t\treturn deobfuscationForceSave;\n-\t}\n-\n \tpublic boolean isDeobfuscationUseSourceNameAsAlias() {\n \t\treturn deobfuscationUseSourceNameAsAlias;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -695,11 +695,7 @@ private void upgradeSettings(int fromVersion) {\n \t\t\tfromVersion++;\n \t\t}\n \t\tif (fromVersion == 15) {\n-\t\t\tif (deobfuscationForceSave) {\n-\t\t\t\tdeobfuscationMapFileMode = DeobfuscationMapFileMode.OVERWRITE;\n-\t\t\t} else {\n-\t\t\t\tdeobfuscationMapFileMode = DeobfuscationMapFileMode.READ;\n-\t\t\t}\n+\t\t\tdeobfuscationMapFileMode = DeobfuscationMapFileMode.READ;\n \t\t\tfromVersion++;\n \t\t}\n \t\tif (fromVersion == 16) {",
    "output": "Remove deprecated `--deobf-rewrite-cfg`"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java\n--- a/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java\n+++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java\n@@ -203,6 +203,9 @@ private void addSuperTypes(ClspClass cls, Set<String> result) {\n \t\t\t\tif (isNew) {\n \t\t\t\t\taddSuperTypes(parentCls, result);\n \t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// parent type is unknown\n+\t\t\t\tresult.add(parentType.getObject());\n \t\t\t}\n \t\t}\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -807,14 +807,9 @@ private void makeInvoke(InvokeNode insn, ICodeWriter code) throws CodegenExcepti\n \t\t\t\tbreak;\n \n \t\t\tcase SUPER:\n-\t\t\t\tClassInfo superCallCls = getClassForSuperCall(code, callMth);\n-\t\t\t\tif (superCallCls != null) {\n-\t\t\t\t\tuseClass(code, superCallCls);\n-\t\t\t\t\tcode.add('.');\n-\t\t\t\t}\n-\t\t\t\t// use 'super' instead 'this' in 0 arg\n-\t\t\t\tcode.add(\"super\").add('.');\n-\t\t\t\tk++;\n+\t\t\t\tcallSuper(code, callMth);\n+\t\t\t\tk++; // use 'super' instead 'this' in 0 arg\n+\t\t\t\tcode.add('.');\n \t\t\t\tbreak;\n \n \t\t\tcase STATIC:\n@@ -965,34 +960,43 @@ private void makeInlinedLambdaMethod(ICodeWriter code, InvokeCustomNode customNo\n \t\tcode.startLine('}');\n \t}\n \n-\t@Nullable\n-\tprivate ClassInfo getClassForSuperCall(ICodeWriter code, MethodInfo callMth) {\n-\t\tClassNode useCls = mth.getParentClass();\n-\t\tClassInfo insnCls = useCls.getClassInfo();\n-\t\tClassInfo declClass = callMth.getDeclClass();\n-\t\tif (insnCls.equals(declClass)) {\n-\t\t\treturn null;\n+\tprivate void callSuper(ICodeWriter code, MethodInfo callMth) {\n+\t\tClassInfo superCallCls = getClassForSuperCall(callMth);\n+\t\tif (superCallCls == null) {\n+\t\t\t// unknown class, add comment to keep that info\n+\t\t\tcode.add(\"super/*\").add(callMth.getDeclClass().getFullName()).add(\"*/\");\n+\t\t\treturn;\n \t\t}\n-\t\tClassNode topClass = useCls.getTopParentClass();\n-\t\tif (topClass.getClassInfo().equals(declClass)) {\n-\t\t\treturn declClass;\n+\t\tClassInfo curClass = mth.getParentClass().getClassInfo();\n+\t\tif (superCallCls.equals(curClass)) {\n+\t\t\tcode.add(\"super\");\n+\t\t\treturn;\n \t\t}\n-\t\t// search call class\n-\t\tClassNode nextParent = useCls;\n-\t\tdo {\n-\t\t\tClassInfo nextClsInfo = nextParent.getClassInfo();\n-\t\t\tif (nextClsInfo.equals(declClass)\n-\t\t\t\t\t|| ArgType.isInstanceOf(mth.root(), nextClsInfo.getType(), declClass.getType())) {\n-\t\t\t\tif (nextParent == useCls) {\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\t\t\t\treturn nextClsInfo;\n-\t\t\t}\n-\t\t\tnextParent = nextParent.getParentClass();\n-\t\t} while (nextParent != null && nextParent != topClass);\n+\t\t// use custom class\n+\t\tuseClass(code, superCallCls);\n+\t\tcode.add(\".super\");\n+\t}\n \n-\t\t// search failed, just return parent class\n-\t\treturn useCls.getParentClass().getClassInfo();\n+\t/**\n+\t * Search call class in super types of this\n+\t * and all parent classes (needed for inlined synthetic calls)\n+\t */\n+\t@Nullable\n+\tprivate ClassInfo getClassForSuperCall(MethodInfo callMth) {\n+\t\tArgType declClsType = callMth.getDeclClass().getType();\n+\t\tClassNode parentNode = mth.getParentClass();\n+\t\twhile (true) {\n+\t\t\tClassInfo parentCls = parentNode.getClassInfo();\n+\t\t\tif (ArgType.isInstanceOf(root, parentCls.getType(), declClsType)) {\n+\t\t\t\treturn parentCls;\n+\t\t\t}\n+\t\t\tClassNode nextParent = parentNode.getParentClass();\n+\t\t\tif (nextParent == parentNode) {\n+\t\t\t\t// no parent, class not found\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tparentNode = nextParent;\n+\t\t}\n \t}\n \n \tvoid generateMethodArguments(ICodeWriter code, BaseInvokeNode insn, int startArgNum,\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/compiler/TestCompiler.java b/jadx-core/src/test/java/jadx/tests/api/compiler/TestCompiler.java\n--- a/jadx-core/src/test/java/jadx/tests/api/compiler/TestCompiler.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/compiler/TestCompiler.java\n@@ -11,7 +11,6 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n-import java.util.Locale;\n \n import javax.tools.DiagnosticListener;\n import javax.tools.JavaCompiler;\n@@ -82,7 +81,7 @@ private void compile(List<JavaFileObject> jfObjects) {\n \t\targuments.addAll(options.getArguments());\n \n \t\tDiagnosticListener<? super JavaFileObject> diagnostic =\n-\t\t\t\tdiagObj -> System.out.println(\"Compiler diagnostic: \" + diagObj.getMessage(Locale.ROOT));\n+\t\t\t\tdiagObj -> System.out.println(\"Compiler diagnostic: \" + diagObj);\n \t\tWriter out = new PrintWriter(System.out);\n \t\tCompilationTask compilerTask = compiler.getTask(out, fileManager, diagnostic, arguments, null, jfObjects);\n \t\tif (Boolean.FALSE.equals(compilerTask.call())) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvokeUnknown.java b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvokeUnknown.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvokeUnknown.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvokeUnknown.java\n@@ -0,0 +1,42 @@\n+package jadx.tests.integration.invoke;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestSuperInvokeUnknown extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic static class BaseClass {\n+\t\t\tpublic int doSomething() {\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic static class NestedClass extends BaseClass {\n+\t\t\t@Override\n+\t\t\tpublic int doSomething() {\n+\t\t\t\treturn super.doSomething();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.NestedClass.class)) // BaseClass unknown\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"return super.doSomething();\");\n+\t}\n+\n+\t@Test\n+\tpublic void testTopCls() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"return super.doSomething();\");\n+\t}\n+}",
    "output": "Fix improve class search for super call"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxArgs.java b/jadx-core/src/main/java/jadx/api/JadxArgs.java\n--- a/jadx-core/src/main/java/jadx/api/JadxArgs.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java\n@@ -128,7 +128,7 @@ public void setRootDir(File rootDir) {\n \n \tpublic void close() {\n \t\ttry {\n-\t\t\tinputFiles.clear();\n+\t\t\tinputFiles = null;\n \t\t\tif (codeCache != null) {\n \t\t\t\tcodeCache.close();\n \t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/Jadx.java b/jadx-core/src/main/java/jadx/core/Jadx.java\n--- a/jadx-core/src/main/java/jadx/core/Jadx.java\n+++ b/jadx-core/src/main/java/jadx/core/Jadx.java\n@@ -238,9 +238,13 @@ public static List<IDexTreeVisitor> getFallbackPassesList() {\n \tprivate static String version;\n \n \tpublic static String getVersion() {\n-\t\tif (version != null) {\n-\t\t\treturn version;\n+\t\tif (version == null) {\n+\t\t\tversion = searchJadxVersion();\n \t\t}\n+\t\treturn version;\n+\t}\n+\n+\tprivate static String searchJadxVersion() {\n \t\ttry {\n \t\t\tClassLoader classLoader = Jadx.class.getClassLoader();\n \t\t\tif (classLoader != null) {\n@@ -250,7 +254,6 @@ public static String getVersion() {\n \t\t\t\t\t\tManifest manifest = new Manifest(is);\n \t\t\t\t\t\tString ver = manifest.getMainAttributes().getValue(\"jadx-version\");\n \t\t\t\t\t\tif (ver != null) {\n-\t\t\t\t\t\t\tversion = ver;\n \t\t\t\t\t\t\treturn ver;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java b/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java\n@@ -29,6 +29,7 @@\n import jadx.api.ICodeCache;\n import jadx.api.ICodeInfo;\n import jadx.api.JadxArgs;\n+import jadx.core.Jadx;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n@@ -190,6 +191,7 @@ public void remove(String clsFullName) {\n \n \tprivate String buildCodeVersion(JadxArgs args) {\n \t\treturn DATA_FORMAT_VERSION\n+\t\t\t\t+ \":\" + Jadx.getVersion()\n \t\t\t\t+ \":\" + args.makeCodeArgsHash()\n \t\t\t\t+ \":\" + buildInputsHash(args.getInputFiles());\n \t}",
    "output": "Fix reset disk cache on new jadx version"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java b/jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java\n--- a/jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java\n@@ -14,9 +14,9 @@\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.nodes.BlockNode;\n import jadx.core.dex.nodes.IContainer;\n+import jadx.core.dex.nodes.MethodNode;\n import jadx.core.utils.InsnUtils;\n import jadx.core.utils.Utils;\n-import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public class ExceptionHandler {\n \n@@ -33,32 +33,39 @@ public class ExceptionHandler {\n \n \tprivate boolean removed = false;\n \n-\tpublic ExceptionHandler(int addr, @Nullable ClassInfo type) {\n+\tpublic static ExceptionHandler build(MethodNode mth, int addr, @Nullable ClassInfo type) {\n+\t\tExceptionHandler eh = new ExceptionHandler(addr);\n+\t\teh.addCatchType(mth, type);\n+\t\treturn eh;\n+\t}\n+\n+\tprivate ExceptionHandler(int addr) {\n \t\tthis.handlerOffset = addr;\n-\t\taddCatchType(type);\n \t}\n \n \t/**\n \t * Add exception type to catch block\n \t *\n \t * @param type - null for 'all' or 'Throwable' handler\n \t */\n-\tpublic boolean addCatchType(@Nullable ClassInfo type) {\n+\tpublic boolean addCatchType(MethodNode mth, @Nullable ClassInfo type) {\n \t\tif (type != null) {\n \t\t\tif (catchTypes.contains(type)) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\treturn catchTypes.add(type);\n \t\t}\n \t\tif (!this.catchTypes.isEmpty()) {\n-\t\t\tthrow new JadxRuntimeException(\"Null type added to not empty exception handler: \" + this);\n+\t\t\tmth.addDebugComment(\"Throwable added to exception handler: '\" + catchTypeStr() + \"', keep only Throwable\");\n+\t\t\tcatchTypes.clear();\n+\t\t\treturn true;\n \t\t}\n \t\treturn false;\n \t}\n \n-\tpublic void addCatchTypes(Collection<ClassInfo> types) {\n+\tpublic void addCatchTypes(MethodNode mth, Collection<ClassInfo> types) {\n \t\tfor (ClassInfo type : types) {\n-\t\t\taddCatchType(type);\n+\t\t\taddCatchType(mth, type);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java\n@@ -133,7 +133,7 @@ private static ExceptionHandler createHandler(MethodNode mth, InsnNode[] insnByO\n \t\t\tExcHandlerAttr excHandlerAttr = insn.get(AType.EXC_HANDLER);\n \t\t\tif (excHandlerAttr != null) {\n \t\t\t\tExceptionHandler handler = excHandlerAttr.getHandler();\n-\t\t\t\tif (handler.addCatchType(type)) {\n+\t\t\t\tif (handler.addCatchType(mth, type)) {\n \t\t\t\t\t// exist handler updated (assume from same try block) - don't add again\n \t\t\t\t\treturn null;\n \t\t\t\t}\n@@ -143,7 +143,7 @@ private static ExceptionHandler createHandler(MethodNode mth, InsnNode[] insnByO\n \t\t} else {\n \t\t\tinsn = insertNOP(insnByOffset, handlerOffset);\n \t\t}\n-\t\tExceptionHandler handler = new ExceptionHandler(handlerOffset, type);\n+\t\tExceptionHandler handler = ExceptionHandler.build(mth, handlerOffset, type);\n \t\tmth.addExceptionHandler(handler);\n \t\tinsn.addAttr(new ExcHandlerAttr(handler));\n \t\treturn handler;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n@@ -549,7 +549,7 @@ private static boolean mergeMultiCatch(MethodNode mth, TryCatchBlockAttr tryCatc\n \t\t\tif (handler == resultHandler) {\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tresultHandler.addCatchTypes(handler.getCatchTypes());\n+\t\t\tresultHandler.addCatchTypes(mth, handler.getCatchTypes());\n \t\t\thandler.markForRemove();\n \t\t\treturn true;\n \t\t});\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchMultiException.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchMultiException.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchMultiException.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchMultiException.java\n@@ -25,8 +25,6 @@ public void test() {\n \n \t@Test\n \tpublic void test() {\n-\t\t// printDisassemble();\n-\t\t// setFallback();\n \t\tnoDebugInfo();\n \t\tClassNode cls = getClassNode(TestCls.class);\n \t\tString code = cls.getCode().toString();\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchMultiException2.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchMultiException2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchMultiException2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchMultiException2.java\n@@ -0,0 +1,33 @@\n+package jadx.tests.integration.trycatch;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+@SuppressWarnings(\"CommentedOutCode\")\n+public class TestTryCatchMultiException2 extends SmaliTest {\n+\n+\t// @formatter:off\n+\t/*\n+    public static boolean test() {\n+        try {\n+            Class<?> cls = Class.forName(\"c\");\n+            return ((Boolean) cls.getMethod(\"b\", new Class[0]).invoke(cls, new Object[0])).booleanValue();\n+        } catch (ClassNotFoundException | NoSuchMethodException | Exception | Throwable unused) {\n+        \t// java compiler don't allow shadow subclasses in multi-catch\n+        \t// in this case leave only Throwable\n+            return false;\n+        }\n+    }\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"} catch (Throwable unused) {\");\n+\t}\n+}",
    "output": "Fix support all-catch in multi-catch"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -219,29 +219,22 @@ public boolean loadWindowPos(Window window) {\n \t\tif (pos == null || pos.getBounds() == null) {\n \t\t\treturn false;\n \t\t}\n-\t\tif (window instanceof MainWindow) {\n-\t\t\tint extendedState = getMainWindowExtendedState();\n-\t\t\tif (extendedState != JFrame.NORMAL) {\n-\t\t\t\t((JFrame) window).setExtendedState(extendedState);\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (!isContainedInAnyScreen(pos)) {\n+\t\tif (!isAccessibleInAnyScreen(pos)) {\n \t\t\treturn false;\n \t\t}\n-\n \t\twindow.setBounds(pos.getBounds());\n+\t\tif (window instanceof MainWindow) {\n+\t\t\t((JFrame) window).setExtendedState(getMainWindowExtendedState());\n+\t\t}\n \t\treturn true;\n \t}\n \n-\tprivate static boolean isContainedInAnyScreen(WindowLocation pos) {\n-\t\tRectangle bounds = pos.getBounds();\n-\t\tif (bounds.getX() > 0 && bounds.getY() > 0) {\n-\t\t\tfor (GraphicsDevice gd : GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices()) {\n-\t\t\t\tif (gd.getDefaultConfiguration().getBounds().contains(bounds)) {\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n+\tprivate static boolean isAccessibleInAnyScreen(WindowLocation pos) {\n+\t\tRectangle windowBounds = pos.getBounds();\n+\t\tfor (GraphicsDevice gd : GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices()) {\n+\t\t\tRectangle screenBounds = gd.getDefaultConfiguration().getBounds();\n+\t\t\tif (screenBounds.intersects(windowBounds)) {\n+\t\t\t\treturn true;\n \t\t\t}\n \t\t}\n \t\tLOG.debug(\"Window saved position was ignored: {}\", pos);",
    "output": "Fix improve restoration of windows saved state"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -437,6 +437,7 @@ private void closeAll() {\n \t\tLogCollector.getInstance().reset();\n \t\twrapper.close();\n \t\ttabbedPane.closeAllTabs();\n+\t\tUiUtils.resetClipboardOwner();\n \t\tSystem.gc();\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n@@ -373,49 +373,56 @@ public void reset() {\n \t\tjumps.reset();\n \t\tcurTab = null;\n \t\tlastTab = null;\n+\t\tFocusManager.reset();\n \t}\n \n \t@Nullable\n \tpublic Component getFocusedComp() {\n-\t\treturn FocusManager.isActive() ? FocusManager.focusedComp : null;\n+\t\treturn FocusManager.getFocusedComp();\n \t}\n \n \tprivate static class FocusManager implements FocusListener {\n-\t\tstatic boolean active = false;\n-\t\tstatic FocusManager listener = new FocusManager();\n-\t\tstatic Component focusedComp;\n+\t\tprivate static final FocusManager INSTANCE = new FocusManager();\n+\t\tprivate static @Nullable Component focusedComp;\n \n \t\tstatic boolean isActive() {\n-\t\t\treturn active;\n+\t\t\treturn focusedComp != null;\n+\t\t}\n+\n+\t\tstatic void reset() {\n+\t\t\tfocusedComp = null;\n+\t\t}\n+\n+\t\tstatic Component getFocusedComp() {\n+\t\t\treturn focusedComp;\n \t\t}\n \n \t\t@Override\n \t\tpublic void focusGained(FocusEvent e) {\n-\t\t\tactive = true;\n \t\t\tfocusedComp = (Component) e.getSource();\n \t\t}\n \n \t\t@Override\n \t\tpublic void focusLost(FocusEvent e) {\n-\t\t\tactive = false;\n+\t\t\tfocusedComp = null;\n \t\t}\n \n \t\tstatic void listen(ContentPanel pane) {\n \t\t\tif (pane instanceof ClassCodeContentPanel) {\n-\t\t\t\t((ClassCodeContentPanel) pane).getCodeArea().addFocusListener(listener);\n-\t\t\t\t((ClassCodeContentPanel) pane).getSmaliCodeArea().addFocusListener(listener);\n+\t\t\t\t((ClassCodeContentPanel) pane).getCodeArea().addFocusListener(INSTANCE);\n+\t\t\t\t((ClassCodeContentPanel) pane).getSmaliCodeArea().addFocusListener(INSTANCE);\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tif (pane instanceof AbstractCodeContentPanel) {\n-\t\t\t\t((AbstractCodeContentPanel) pane).getCodeArea().addFocusListener(listener);\n+\t\t\t\t((AbstractCodeContentPanel) pane).getCodeArea().addFocusListener(INSTANCE);\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tif (pane instanceof HtmlPanel) {\n-\t\t\t\t((HtmlPanel) pane).getHtmlArea().addFocusListener(listener);\n+\t\t\t\t((HtmlPanel) pane).getHtmlArea().addFocusListener(INSTANCE);\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tif (pane instanceof ImagePanel) {\n-\t\t\t\tpane.addFocusListener(listener);\n+\t\t\t\tpane.addFocusListener(INSTANCE);\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t// throw new JadxRuntimeException(\"Add the new ContentPanel to TabbedPane.FocusManager: \" + pane);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/SearchDialog.java\n@@ -147,6 +147,7 @@ public void dispose() {\n \t\tif (searchDisposable != null && !searchDisposable.isDisposed()) {\n \t\t\tsearchDisposable.dispose();\n \t\t}\n+\t\tresultsModel.clear();\n \t\tremoveActiveTabListener();\n \t\tsuper.dispose();\n \t}\n@@ -399,6 +400,7 @@ private synchronized void stopSearchTask() {\n \t\tif (searchTask != null) {\n \t\t\tsearchTask.cancel();\n \t\t\tsearchTask.waitTask();\n+\t\t\tsearchTask = null;\n \t\t}\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n@@ -329,6 +329,23 @@ public static void copyToClipboard(String text) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Owner field in Clipboard class can store reference to CodeArea.\n+\t * This prevents from garbage collection whole jadx object tree and cause memory leak.\n+\t * Trying to lost ownership by new empty selection.\n+\t */\n+\tpublic static void resetClipboardOwner() {\n+\t\ttry {\n+\t\t\tClipboard clipboard = Toolkit.getDefaultToolkit().getSystemSelection();\n+\t\t\tif (clipboard != null) {\n+\t\t\t\tStringSelection selection = new StringSelection(\"\");\n+\t\t\t\tclipboard.setContents(selection, selection);\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"Failed to reset clipboard owner\", e);\n+\t\t}\n+\t}\n+\n \tpublic static int calcProgress(ITaskProgress taskProgress) {\n \t\treturn calcProgress(taskProgress.progress(), taskProgress.total());\n \t}",
    "output": "Fix try to resolve some causes of memory leak"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -89,7 +89,8 @@ private boolean isBinaryXml() throws IOException {\n \t\tis.mark(4);\n \t\tint v = is.readInt16(); // version\n \t\tint h = is.readInt16(); // header size\n-\t\tif (v == 0x0003 && h == 0x0008) {\n+\t\t// Some APK Manifest.xml the version is 0\n+\t\tif (h == 0x0008) {\n \t\t\treturn true;\n \t\t}\n \t\tis.reset();",
    "output": "Fix ignore version in AndroidManifest.xml"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxArgs.java b/jadx-core/src/main/java/jadx/api/JadxArgs.java\n--- a/jadx-core/src/main/java/jadx/api/JadxArgs.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java\n@@ -12,13 +12,17 @@\n import java.util.function.Function;\n import java.util.function.Predicate;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import jadx.api.args.DeobfuscationMapFileMode;\n import jadx.api.data.ICodeData;\n import jadx.api.impl.AnnotatedCodeWriter;\n import jadx.api.impl.InMemoryCodeCache;\n import jadx.core.utils.files.FileUtils;\n \n public class JadxArgs {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(JadxArgs.class);\n \n \tpublic static final int DEFAULT_THREADS_COUNT = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);\n \n@@ -122,6 +126,19 @@ public void setRootDir(File rootDir) {\n \t\tsetOutDirRes(new File(rootDir, DEFAULT_RES_DIR));\n \t}\n \n+\tpublic void close() {\n+\t\ttry {\n+\t\t\tinputFiles.clear();\n+\t\t\tif (codeCache != null) {\n+\t\t\t\tcodeCache.close();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"Failed to close JadxArgs\", e);\n+\t\t} finally {\n+\t\t\tcodeCache = null;\n+\t\t}\n+\t}\n+\n \tpublic List<File> getInputFiles() {\n \t\treturn inputFiles;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -161,8 +161,13 @@ private void reset() {\n \t\tclassesMap.clear();\n \t\tmethodsMap.clear();\n \t\tfieldsMap.clear();\n+\t}\n \n+\t@Override\n+\tpublic void close() {\n+\t\treset();\n \t\tcloseInputs();\n+\t\targs.close();\n \t}\n \n \tprivate void closeInputs() {\n@@ -176,11 +181,6 @@ private void closeInputs() {\n \t\tloadedInputs.clear();\n \t}\n \n-\t@Override\n-\tpublic void close() {\n-\t\treset();\n-\t}\n-\n \tprivate void loadPlugins(JadxArgs args) {\n \t\tpluginManager.providesSuggestion(\"java-input\", args.isUseDxInput() ? \"java-convert\" : \"java-input\");\n \t\tpluginManager.load();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n@@ -10,7 +10,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import jadx.api.ICodeCache;\n import jadx.api.JadxArgs;\n import jadx.api.JadxDecompiler;\n import jadx.api.JavaClass;\n@@ -19,7 +18,6 @@\n import jadx.api.impl.InMemoryCodeCache;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.ProcessState;\n-import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.core.utils.files.FileUtils;\n import jadx.gui.settings.JadxProject;\n import jadx.gui.settings.JadxSettings;\n@@ -40,7 +38,6 @@ public class JadxWrapper {\n \n \tpublic JadxWrapper(MainWindow mainWindow) {\n \t\tthis.mainWindow = mainWindow;\n-\t\tthis.decompiler = new JadxDecompiler(new JadxArgs());\n \t}\n \n \tpublic void open() {\n@@ -53,7 +50,7 @@ public void open() {\n \n \t\t\tthis.decompiler = new JadxDecompiler(jadxArgs);\n \t\t\tthis.decompiler.load();\n-\t\t\tinitCodeCache(jadxArgs);\n+\t\t\tinitCodeCache();\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Jadx init error\", e);\n \t\t\tclose();\n@@ -71,23 +68,27 @@ public void unloadClasses() {\n \n \tpublic void close() {\n \t\ttry {\n-\t\t\tdecompiler.close();\n-\t\t\tcloseCodeCache();\n+\t\t\tif (decompiler != null) {\n+\t\t\t\tdecompiler.close();\n+\t\t\t\tmainWindow.getCacheObject().reset();\n+\t\t\t}\n \t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"jadx decompiler close error\", e);\n+\t\t\tLOG.error(\"Jadx decompiler close error\", e);\n+\t\t} finally {\n+\t\t\tdecompiler = null;\n \t\t}\n \t}\n \n-\tprivate void initCodeCache(JadxArgs jadxArgs) {\n+\tprivate void initCodeCache() {\n \t\tswitch (getSettings().getCodeCacheMode()) {\n \t\t\tcase MEMORY:\n-\t\t\t\tjadxArgs.setCodeCache(new InMemoryCodeCache());\n+\t\t\t\tgetArgs().setCodeCache(new InMemoryCodeCache());\n \t\t\t\tbreak;\n \t\t\tcase DISK_WITH_CACHE:\n-\t\t\t\tjadxArgs.setCodeCache(new CodeStringCache(buildBufferedDiskCache()));\n+\t\t\t\tgetArgs().setCodeCache(new CodeStringCache(buildBufferedDiskCache()));\n \t\t\t\tbreak;\n \t\t\tcase DISK:\n-\t\t\t\tjadxArgs.setCodeCache(buildBufferedDiskCache());\n+\t\t\t\tgetArgs().setCodeCache(buildBufferedDiskCache());\n \t\t\t\tbreak;\n \t\t}\n \t}\n@@ -97,17 +98,6 @@ private BufferCodeCache buildBufferedDiskCache() {\n \t\treturn new BufferCodeCache(diskCache);\n \t}\n \n-\tpublic void closeCodeCache() {\n-\t\tICodeCache codeCache = getArgs().getCodeCache();\n-\t\tif (codeCache != null) {\n-\t\t\ttry {\n-\t\t\t\tcodeCache.close();\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tthrow new JadxRuntimeException(\"Error on cache close\", e);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n \t/**\n \t * Get the complete list of classes\n \t */\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -387,6 +387,8 @@ private static Path getProjectPathForFile(Path loadedFile) {\n \t}\n \n \tpublic void reopen() {\n+\t\tsaveAll();\n+\t\tcloseAll();\n \t\tloadFiles(EMPTY_RUNNABLE);\n \t}\n \n@@ -431,6 +433,7 @@ private void saveAll() {\n \tprivate void closeAll() {\n \t\tcancelBackgroundJobs();\n \t\tclearTree();\n+\t\tresetCache();\n \t\tLogCollector.getInstance().reset();\n \t\twrapper.close();\n \t\ttabbedPane.closeAllTabs();\n@@ -606,7 +609,6 @@ public void initTree() {\n \n \tprivate void clearTree() {\n \t\ttabbedPane.reset();\n-\t\tresetCache();\n \t\ttreeRoot = null;\n \t\ttreeModel.setRoot(null);\n \t\ttreeModel.reload();\n@@ -1329,7 +1331,7 @@ public void loadSettings() {\n \t}\n \n \tprivate void closeWindow() {\n-\t\tsaveOpenTabs();\n+\t\tsaveAll();\n \t\tif (!ensureProjectIsSaved()) {\n \t\t\treturn;\n \t\t}\n@@ -1339,13 +1341,11 @@ private void closeWindow() {\n \t\tif (debuggerPanel != null) {\n \t\t\tsaveSplittersInfo();\n \t\t}\n-\t\tcancelBackgroundJobs();\n-\t\twrapper.close();\n \t\theapUsageBar.reset();\n-\t\tdispose();\n+\t\tcloseAll();\n \n-\t\tBreakpointManager.saveAndExit();\n \t\tFileUtils.deleteTempRootDir();\n+\t\tdispose();\n \t\tSystem.exit(0);\n \t}",
    "output": "Fix correct close and reopen for decompiler and cache"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -115,21 +115,25 @@ public void loadClasses(List<ILoadResult> loadedInputs) {\n \t}\n \n \tprivate void addDummyClass(IClassData classData, Exception exc) {\n-\t\tString typeStr = classData.getType();\n-\t\tString name = null;\n \t\ttry {\n-\t\t\tClassInfo clsInfo = ClassInfo.fromName(this, typeStr);\n-\t\t\tif (clsInfo != null) {\n-\t\t\t\tname = clsInfo.getShortName();\n+\t\t\tString typeStr = classData.getType();\n+\t\t\tString name = null;\n+\t\t\ttry {\n+\t\t\t\tClassInfo clsInfo = ClassInfo.fromName(this, typeStr);\n+\t\t\t\tif (clsInfo != null) {\n+\t\t\t\t\tname = clsInfo.getShortName();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tLOG.error(\"Failed to get name for class with type {}\", typeStr, e);\n \t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Failed to get name for class with type {}\", typeStr, e);\n-\t\t}\n-\t\tif (name == null || name.isEmpty()) {\n-\t\t\tname = \"CLASS_\" + typeStr;\n+\t\t\tif (name == null || name.isEmpty()) {\n+\t\t\t\tname = \"CLASS_\" + typeStr;\n+\t\t\t}\n+\t\t\tClassNode clsNode = ClassNode.addSyntheticClass(this, name, classData.getAccessFlags());\n+\t\t\tErrorsCounter.error(clsNode, \"Load error\", exc);\n+\t\t} catch (Exception innerExc) {\n+\t\t\tLOG.error(\"Failed to load class from file: {}\", classData.getInputFileName(), exc);\n \t\t}\n-\t\tClassNode clsNode = ClassNode.addSyntheticClass(this, name, classData.getAccessFlags());\n-\t\tErrorsCounter.error(clsNode, \"Load error\", exc);\n \t}\n \n \tprivate static void markDuplicatedClasses(List<ClassNode> classes) {",
    "output": "Fix skip dex files with parsing errors"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n@@ -115,17 +115,22 @@ public static boolean deleteDir(File dir) {\n \n \tpublic static void deleteDirIfExists(Path dir) {\n \t\tif (Files.exists(dir)) {\n-\t\t\tdeleteDir(dir);\n+\t\t\ttry {\n+\t\t\t\tdeleteDir(dir);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tLOG.error(\"Failed to delete dir: \" + dir.toAbsolutePath(), e);\n+\t\t\t}\n \t\t}\n \t}\n \n-\tpublic static void deleteDir(Path dir) {\n+\tprivate static void deleteDir(Path dir) {\n \t\ttry (Stream<Path> pathStream = Files.walk(dir)) {\n \t\t\tpathStream.sorted(Comparator.reverseOrder())\n-\t\t\t\t\t.map(Path::toFile)\n-\t\t\t\t\t.forEach(file -> {\n-\t\t\t\t\t\tif (!file.delete()) {\n-\t\t\t\t\t\t\tLOG.warn(\"Failed to remove file: {}\", file.getAbsolutePath());\n+\t\t\t\t\t.forEach(path -> {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tFiles.delete(path);\n+\t\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\t\tthrow new JadxRuntimeException(\"Failed to delete path: \" + path.toAbsolutePath(), e);\n \t\t\t\t\t\t}\n \t\t\t\t\t});\n \t\t} catch (Exception e) {\n@@ -152,11 +157,11 @@ private static Path createTempRootDir() {\n \t}\n \n \tpublic static void deleteTempRootDir() {\n-\t\tdeleteDir(TEMP_ROOT_DIR);\n+\t\tdeleteDirIfExists(TEMP_ROOT_DIR);\n \t}\n \n \tpublic static void clearTempRootDir() {\n-\t\tdeleteDir(TEMP_ROOT_DIR);\n+\t\tdeleteDirIfExists(TEMP_ROOT_DIR);\n \t\tmakeDirs(TEMP_ROOT_DIR);\n \t}",
    "output": "Fix check if directory exists before delete"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n--- a/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n@@ -8,6 +8,7 @@\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n+import java.util.function.Supplier;\n \n import org.jetbrains.annotations.Nullable;\n \n@@ -22,6 +23,7 @@\n import jadx.api.plugins.JadxPluginManager;\n import jadx.api.plugins.options.JadxPluginOptions;\n import jadx.api.plugins.options.OptionDescription;\n+import jadx.core.utils.Utils;\n \n public class JCommanderWrapper<T> {\n \tprivate final JCommander jc;\n@@ -50,12 +52,24 @@ public void overrideProvided(T obj) {\n \t\t\tif (parameter.isAssigned()) {\n \t\t\t\t// copy assigned field value to obj\n \t\t\t\tParameterized parameterized = parameter.getParameterized();\n-\t\t\t\tObject val = parameterized.get(parameter.getObject());\n-\t\t\t\tparameterized.set(obj, val);\n+\t\t\t\tObject providedValue = parameterized.get(parameter.getObject());\n+\t\t\t\tObject newValue = mergeValues(parameterized.getType(), providedValue, () -> parameterized.get(obj));\n+\t\t\t\tparameterized.set(obj, newValue);\n \t\t\t}\n \t\t}\n \t}\n \n+\t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+\tprivate static Object mergeValues(Class<?> type, Object value, Supplier<Object> prevValueProvider) {\n+\t\tif (type.isAssignableFrom(Map.class)) {\n+\t\t\t// merge maps instead replacing whole map\n+\t\t\tMap prevMap = (Map) prevValueProvider.get();\n+\t\t\treturn Utils.mergeMaps(prevMap, (Map) value); // value map will override keys in prevMap\n+\t\t}\n+\t\t// simple override\n+\t\treturn value;\n+\t}\n+\n \tpublic void printUsage() {\n \t\t// print usage in not sorted fields order (by default its sorted by description)\n \t\tPrintStream out = System.out;\n\ndiff --git a/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java\n--- a/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java\n+++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java\n@@ -1,9 +1,14 @@\n package jadx.cli;\n \n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.hamcrest.Matchers;\n import org.junit.jupiter.api.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static jadx.core.utils.Utils.newConstStringMap;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n \n@@ -47,6 +52,40 @@ public void testOptionsOverride() {\n \t\tassertThat(override(args, \"\").isUseImports(), is(false));\n \t}\n \n+\t@Test\n+\tpublic void testPluginOptionsOverride() {\n+\t\t// add key to empty base map\n+\t\tcheckPluginOptionsMerge(\n+\t\t\t\tCollections.emptyMap(),\n+\t\t\t\t\"-Poption=otherValue\",\n+\t\t\t\tnewConstStringMap(\"option\", \"otherValue\"));\n+\n+\t\t// override one key\n+\t\tcheckPluginOptionsMerge(\n+\t\t\t\tnewConstStringMap(\"option\", \"value\"),\n+\t\t\t\t\"-Poption=otherValue\",\n+\t\t\t\tnewConstStringMap(\"option\", \"otherValue\"));\n+\n+\t\t// merge different keys\n+\t\tcheckPluginOptionsMerge(\n+\t\t\t\tCollections.singletonMap(\"option1\", \"value1\"),\n+\t\t\t\t\"-Poption2=otherValue2\",\n+\t\t\t\tnewConstStringMap(\"option1\", \"value1\", \"option2\", \"otherValue2\"));\n+\n+\t\t// merge and override\n+\t\tcheckPluginOptionsMerge(\n+\t\t\t\tnewConstStringMap(\"option1\", \"value1\", \"option2\", \"value2\"),\n+\t\t\t\t\"-Poption2=otherValue2\",\n+\t\t\t\tnewConstStringMap(\"option1\", \"value1\", \"option2\", \"otherValue2\"));\n+\t}\n+\n+\tprivate void checkPluginOptionsMerge(Map<String, String> baseMap, String providedArgs, Map<String, String> expectedMap) {\n+\t\tJadxCLIArgs args = new JadxCLIArgs();\n+\t\targs.pluginOptions = baseMap;\n+\t\tMap<String, String> resultMap = override(args, providedArgs).getPluginOptions();\n+\t\tassertThat(resultMap, Matchers.equalTo(expectedMap));\n+\t}\n+\n \tprivate JadxCLIArgs parse(String... args) {\n \t\treturn parse(new JadxCLIArgs(), args);\n \t}",
    "output": "Fix correct merge for plugin options from command line"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java b/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java\n@@ -37,7 +37,7 @@\n public class DiskCodeCache implements ICodeCache {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(DiskCodeCache.class);\n \n-\tprivate static final int DATA_FORMAT_VERSION = 9;\n+\tprivate static final int DATA_FORMAT_VERSION = 10;\n \n \tprivate final Path srcDir;\n \tprivate final Path metaDir;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/adapters/ArgTypeAdapter.java b/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/adapters/ArgTypeAdapter.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/adapters/ArgTypeAdapter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/adapters/ArgTypeAdapter.java\n@@ -3,37 +3,155 @@\n import java.io.DataInput;\n import java.io.DataOutput;\n import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n \n-import jadx.core.codegen.TypeGen;\n import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public class ArgTypeAdapter implements DataAdapter<ArgType> {\n \n \tpublic static final ArgTypeAdapter INSTANCE = new ArgTypeAdapter();\n \n+\tprivate enum Types {\n+\t\tNULL,\n+\t\tUNKNOWN,\n+\t\tPRIMITIVE,\n+\t\tARRAY,\n+\t\tOBJECT,\n+\t\tWILDCARD,\n+\t\tGENERIC,\n+\t\tTYPE_VARIABLE,\n+\t\tOUTER_GENERIC\n+\t}\n+\n \t@Override\n \tpublic void write(DataOutput out, ArgType value) throws IOException {\n \t\tif (value == null) {\n-\t\t\tout.writeByte(0);\n-\t\t} else if (!value.isTypeKnown()) {\n-\t\t\tout.write(1);\n-\t\t} else {\n-\t\t\tout.writeByte(2);\n-\t\t\tout.writeUTF(TypeGen.signature(value));\n+\t\t\twriteType(out, Types.NULL);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (!value.isTypeKnown()) {\n+\t\t\twriteType(out, Types.UNKNOWN);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (value.isPrimitive()) {\n+\t\t\twriteType(out, Types.PRIMITIVE);\n+\t\t\tout.writeByte(value.getPrimitiveType().getShortName().charAt(0));\n+\t\t\treturn;\n+\t\t}\n+\t\tif (value.getOuterType() != null) {\n+\t\t\twriteType(out, Types.OUTER_GENERIC);\n+\t\t\twrite(out, value.getOuterType());\n+\t\t\twrite(out, value.getInnerType());\n+\t\t\treturn;\n+\t\t}\n+\t\tif (value.getWildcardType() != null) {\n+\t\t\twriteType(out, Types.WILDCARD);\n+\t\t\tArgType.WildcardBound bound = value.getWildcardBound();\n+\t\t\tout.writeByte(bound.getNum());\n+\t\t\tif (bound != ArgType.WildcardBound.UNBOUND) {\n+\t\t\t\twrite(out, value.getWildcardType());\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tif (value.isGeneric()) {\n+\t\t\twriteType(out, Types.GENERIC);\n+\t\t\tout.writeUTF(value.getObject());\n+\t\t\twriteTypesList(out, value.getGenericTypes());\n+\t\t\treturn;\n \t\t}\n+\t\tif (value.isGenericType()) {\n+\t\t\twriteType(out, Types.TYPE_VARIABLE);\n+\t\t\tout.writeUTF(value.getObject());\n+\t\t\twriteTypesList(out, value.getExtendTypes());\n+\t\t\treturn;\n+\t\t}\n+\t\tif (value.isObject()) {\n+\t\t\twriteType(out, Types.OBJECT);\n+\t\t\tout.writeUTF(value.getObject());\n+\t\t\treturn;\n+\t\t}\n+\t\tif (value.isArray()) {\n+\t\t\twriteType(out, Types.ARRAY);\n+\t\t\tout.writeByte(value.getArrayDimension());\n+\t\t\twrite(out, value.getArrayRootElement());\n+\t\t\treturn;\n+\t\t}\n+\t\tthrow new JadxRuntimeException(\"Cannot save type: \" + value + \", cls: \" + value.getClass());\n+\t}\n+\n+\tprivate void writeType(DataOutput out, Types type) throws IOException {\n+\t\tout.writeByte(type.ordinal());\n \t}\n \n \t@Override\n \tpublic ArgType read(DataInput in) throws IOException {\n-\t\tswitch (in.readByte()) {\n-\t\t\tcase 0:\n+\t\tbyte typeOrdinal = in.readByte();\n+\t\tTypes type = Types.values()[typeOrdinal];\n+\t\tswitch (type) {\n+\t\t\tcase NULL:\n \t\t\t\treturn null;\n-\t\t\tcase 1:\n+\n+\t\t\tcase UNKNOWN:\n \t\t\t\treturn ArgType.UNKNOWN;\n-\t\t\tcase 2:\n-\t\t\t\treturn ArgType.parse(in.readUTF());\n+\n+\t\t\tcase PRIMITIVE:\n+\t\t\t\tchar shortName = (char) in.readByte();\n+\t\t\t\treturn ArgType.parse(shortName);\n+\n+\t\t\tcase OUTER_GENERIC:\n+\t\t\t\tArgType outerType = read(in);\n+\t\t\t\tArgType innerType = read(in);\n+\t\t\t\treturn ArgType.outerGeneric(outerType, innerType);\n+\n+\t\t\tcase WILDCARD:\n+\t\t\t\tArgType.WildcardBound bound = ArgType.WildcardBound.getByNum(in.readByte());\n+\t\t\t\tif (bound == ArgType.WildcardBound.UNBOUND) {\n+\t\t\t\t\treturn ArgType.WILDCARD;\n+\t\t\t\t}\n+\t\t\t\tArgType objType = read(in);\n+\t\t\t\treturn ArgType.wildcard(objType, bound);\n+\n+\t\t\tcase GENERIC:\n+\t\t\t\tString clsType = in.readUTF();\n+\t\t\t\treturn ArgType.generic(clsType, readTypesList(in));\n+\n+\t\t\tcase TYPE_VARIABLE:\n+\t\t\t\tString typeVar = in.readUTF();\n+\t\t\t\tList<ArgType> extendTypes = readTypesList(in);\n+\t\t\t\treturn ArgType.genericType(typeVar, extendTypes);\n+\n+\t\t\tcase OBJECT:\n+\t\t\t\treturn ArgType.object(in.readUTF());\n+\n+\t\t\tcase ARRAY:\n+\t\t\t\tint dim = in.readByte();\n+\t\t\t\tArgType rootType = read(in);\n+\t\t\t\treturn ArgType.array(rootType, dim);\n+\n \t\t\tdefault:\n-\t\t\t\tthrow new RuntimeException(\"Unexpected arg type tag\");\n+\t\t\t\tthrow new RuntimeException(\"Unexpected arg type: \" + type);\n+\t\t}\n+\t}\n+\n+\tprivate void writeTypesList(DataOutput out, List<ArgType> types) throws IOException {\n+\t\tout.writeByte(types.size());\n+\t\tfor (ArgType type : types) {\n+\t\t\twrite(out, type);\n+\t\t}\n+\t}\n+\n+\tprivate List<ArgType> readTypesList(DataInput in) throws IOException {\n+\t\tbyte size = in.readByte();\n+\t\tif (size == 0) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tList<ArgType> list = new ArrayList<>(size);\n+\t\tfor (int i = 0; i < size; i++) {\n+\t\t\tlist.add(read(in));\n \t\t}\n+\t\treturn list;\n \t}\n }",
    "output": "Fix save full type info in metadata"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JavaVariable.java b/jadx-core/src/main/java/jadx/api/JavaVariable.java\n--- a/jadx-core/src/main/java/jadx/api/JavaVariable.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaVariable.java\n@@ -6,6 +6,7 @@\n import org.jetbrains.annotations.ApiStatus;\n \n import jadx.api.metadata.annotations.VarNode;\n+import jadx.core.dex.instructions.args.ArgType;\n \n public class JavaVariable implements JavaNode {\n \tprivate final JavaMethod mth;\n@@ -43,6 +44,10 @@ public String getFullName() {\n \t\treturn varNode.getType() + \" \" + varNode.getName() + \" (r\" + varNode.getReg() + \"v\" + varNode.getSsa() + \")\";\n \t}\n \n+\tpublic ArgType getType() {\n+\t\treturn ArgType.tryToResolveClassAlias(mth.getMethodNode().root(), varNode.getType());\n+\t}\n+\n \t@Override\n \tpublic JavaClass getDeclaringClass() {\n \t\treturn mth.getDeclaringClass();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -168,10 +168,11 @@ public void declareVar(ICodeWriter code, CodeVar codeVar) {\n \t * Variable definition without type, only var name\n \t */\n \tprivate void defVar(ICodeWriter code, CodeVar codeVar) {\n+\t\tString varName = mgen.getNameGen().assignArg(codeVar);\n \t\tif (code.isMetadataSupported()) {\n \t\t\tcode.attachDefinition(VarNode.get(mth, codeVar));\n \t\t}\n-\t\tcode.add(mgen.getNameGen().assignArg(codeVar));\n+\t\tcode.add(varName);\n \t}\n \n \tprivate String lit(LiteralArg arg) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JField.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JField.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JField.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JField.java\n@@ -86,6 +86,12 @@ public String makeLongStringHtml() {\n \t\treturn UiUtils.typeFormatHtml(field.getFullName(), field.getType());\n \t}\n \n+\t@Override\n+\tpublic String getTooltip() {\n+\t\tString fullType = UiUtils.escapeHtml(field.getType().toString());\n+\t\treturn UiUtils.wrapHtml(fullType + ' ' + UiUtils.escapeHtml(field.getName()));\n+\t}\n+\n \t@Override\n \tpublic String makeDescString() {\n \t\treturn UiUtils.typeStr(field.getType()) + \" \" + field.getName();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JVariable.java\n@@ -4,6 +4,7 @@\n \n import jadx.api.JavaNode;\n import jadx.api.JavaVariable;\n+import jadx.gui.utils.UiUtils;\n \n public class JVariable extends JNode {\n \tprivate static final long serialVersionUID = -3002100457834453783L;\n@@ -55,6 +56,18 @@ public String makeLongString() {\n \t\treturn var.getFullName();\n \t}\n \n+\t@Override\n+\tpublic String makeLongStringHtml() {\n+\t\treturn UiUtils.typeFormatHtml(var.getName(), var.getType());\n+\t}\n+\n+\t@Override\n+\tpublic String getTooltip() {\n+\t\tString name = var.getName() + \" (r\" + var.getReg() + \"v\" + var.getSsa() + \")\";\n+\t\tString fullType = UiUtils.escapeHtml(var.getType().toString());\n+\t\treturn UiUtils.wrapHtml(fullType + ' ' + UiUtils.escapeHtml(name));\n+\t}\n+\n \t@Override\n \tpublic boolean canRename() {\n \t\treturn true;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n@@ -120,9 +120,15 @@ public static String typeFormat(String name, ArgType type) {\n \t}\n \n \tpublic static String typeFormatHtml(String name, ArgType type) {\n-\t\treturn \"<html><body><nobr>\" + escapeHtml(name)\n-\t\t\t\t+ \"<span style='color:#888888;'> \" + escapeHtml(typeStr(type)) + \"</span>\"\n-\t\t\t\t+ \"</nobr></body></html>\";\n+\t\treturn wrapHtml(escapeHtml(name) + ' ' + fadeHtml(escapeHtml(typeStr(type))));\n+\t}\n+\n+\tpublic static String fadeHtml(String htmlStr) {\n+\t\treturn \"<span style='color:#888888;'>\" + htmlStr + \"</span>\"; // TODO: get color from theme\n+\t}\n+\n+\tpublic static String wrapHtml(String htmlStr) {\n+\t\treturn \"<html><body><nobr>\" + htmlStr + \"</nobr></body></html>\";\n \t}\n \n \tpublic static String escapeHtml(String str) {",
    "output": "Fix save variable name to show in tooltip"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -683,10 +683,13 @@ private JavaVariable resolveVarRef(ICodeInfo codeInfo, VarRef varRef) {\n \t\t\tthrow new JadxRuntimeException(\"Missing code info for resolve VarRef: \" + varRef);\n \t\t}\n \t\tICodeAnnotation varNodeAnn = codeInfo.getCodeMetadata().getAt(varRef.getRefPos());\n-\t\tif (varNodeAnn == null) {\n-\t\t\treturn null;\n+\t\tif (varNodeAnn != null && varNodeAnn.getAnnType() == ICodeAnnotation.AnnType.DECLARATION) {\n+\t\t\tICodeNodeRef nodeRef = ((NodeDeclareRef) varNodeAnn).getNode();\n+\t\t\tif (nodeRef.getAnnType() == ICodeAnnotation.AnnType.VAR) {\n+\t\t\t\treturn resolveVarNode((VarNode) nodeRef);\n+\t\t\t}\n \t\t}\n-\t\treturn (JavaVariable) getJavaNodeByCodeAnnotation(codeInfo, varNodeAnn);\n+\t\treturn null;\n \t}\n \n \tList<JavaNode> convertNodes(Collection<? extends ICodeNodeRef> nodesList) {\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JavaClass.java b/jadx-core/src/main/java/jadx/api/JavaClass.java\n--- a/jadx-core/src/main/java/jadx/api/JavaClass.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java\n@@ -6,12 +6,16 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n \n import org.jetbrains.annotations.ApiStatus;\n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import jadx.api.metadata.ICodeAnnotation;\n+import jadx.api.metadata.ICodeAnnotation.AnnType;\n import jadx.api.metadata.ICodeNodeRef;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n@@ -22,6 +26,7 @@\n import jadx.core.dex.nodes.MethodNode;\n \n public final class JavaClass implements JavaNode {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(JavaClass.class);\n \n \tprivate final JadxDecompiler decompiler;\n \tprivate final ClassNode cls;\n@@ -196,12 +201,17 @@ public List<Integer> getUsePlacesFor(ICodeInfo codeInfo, JavaNode javaNode) {\n \t\tList<Integer> result = new ArrayList<>();\n \t\tfor (Map.Entry<Integer, ICodeAnnotation> entry : map.entrySet()) {\n \t\t\tICodeAnnotation ann = entry.getValue();\n-\t\t\tif (ann.getAnnType() == ICodeAnnotation.AnnType.DECLARATION) {\n-\t\t\t\t// ignore declarations\n+\t\t\tAnnType annType = ann.getAnnType();\n+\t\t\tif (annType == AnnType.DECLARATION || annType == AnnType.OFFSET) {\n+\t\t\t\t// ignore declarations and offset annotations\n \t\t\t\tcontinue;\n \t\t\t}\n+\t\t\t// ignore declarations\n \t\t\tJavaNode annNode = rootDec.getJavaNodeByCodeAnnotation(codeInfo, ann);\n-\t\t\tif (javaNode.equals(annNode)) {\n+\t\t\tif (annNode == null && LOG.isDebugEnabled()) {\n+\t\t\t\tLOG.debug(\"Failed to resolve code annotation, cls: {}, pos: {}, ann: {}\", this, entry.getKey(), ann);\n+\t\t\t}\n+\t\t\tif (Objects.equals(annNode, javaNode)) {\n \t\t\t\tresult.add(entry.getKey());\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n@@ -100,10 +100,6 @@ private void processUsage(JavaNode searchNode, JavaClass topUseClass) {\n \t\tJadxDecompiler decompiler = mainWindow.getWrapper().getDecompiler();\n \t\tList<Integer> usePositions = topUseClass.getUsePlacesFor(codeInfo, searchNode);\n \t\tfor (int pos : usePositions) {\n-\t\t\tif (searchNode.getTopParentClass().equals(topUseClass) && pos == searchNode.getDefPos()) {\n-\t\t\t\t// skip declaration\n-\t\t\t\tcontinue;\n-\t\t\t}\n \t\t\tString line = CodeUtils.getLineForPos(code, pos);\n \t\t\tif (line.startsWith(\"import \")) {\n \t\t\t\tcontinue;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java b/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/DiskCodeCache.java\n@@ -37,7 +37,7 @@\n public class DiskCodeCache implements ICodeCache {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(DiskCodeCache.class);\n \n-\tprivate static final int DATA_FORMAT_VERSION = 7;\n+\tprivate static final int DATA_FORMAT_VERSION = 8;\n \n \tprivate final Path srcDir;\n \tprivate final Path metaDir;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/adapters/VarRefAdapter.java b/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/adapters/VarRefAdapter.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/adapters/VarRefAdapter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/codecache/disk/adapters/VarRefAdapter.java\n@@ -13,14 +13,14 @@ public class VarRefAdapter extends BaseDataAdapter<VarRef> {\n \t@Override\n \tpublic void write(DataOutput out, VarRef value) throws IOException {\n \t\tint refPos = value.getRefPos();\n-\t\tif (refPos == 0) {\n-\t\t\tthrow new RuntimeException(\"Variable refPos is zero: \" + value);\n+\t\tif (refPos <= 0) {\n+\t\t\tthrow new RuntimeException(\"Variable refPos is invalid: \" + value);\n \t\t}\n-\t\tout.writeShort(refPos);\n+\t\tout.writeInt(refPos);\n \t}\n \n \t@Override\n \tpublic VarRef read(DataInput in) throws IOException {\n-\t\treturn VarRef.fromPos(in.readShort());\n+\t\treturn VarRef.fromPos(in.readInt());\n \t}\n }",
    "output": "Fix resolve cast exception for variable reference"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/FileDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/FileDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/FileDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/FileDialog.java\n@@ -51,7 +51,15 @@ public List<Path> show() {\n \t\t\treturn Collections.emptyList();\n \t\t}\n \t\tcurrentDir = fileChooser.getCurrentDirectory().toPath();\n-\t\treturn FileUtils.toPaths(fileChooser.getSelectedFiles());\n+\t\tFile[] selectedFiles = fileChooser.getSelectedFiles();\n+\t\tif (selectedFiles.length != 0) {\n+\t\t\treturn FileUtils.toPaths(selectedFiles);\n+\t\t}\n+\t\tFile chosenFile = fileChooser.getSelectedFile();\n+\t\tif (chosenFile != null) {\n+\t\t\treturn Collections.singletonList(chosenFile.toPath());\n+\t\t}\n+\t\treturn Collections.emptyList();\n \t}\n \n \tpublic Path getCurrentDir() {",
    "output": "Fix correct handle of selected file in save dialog"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n@@ -12,9 +12,9 @@\n \n import jadx.core.Consts;\n import jadx.core.dex.info.ClassInfo;\n-import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.visitors.typeinference.TypeCompareEnum;\n+import jadx.core.utils.ListUtils;\n import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n@@ -874,28 +874,37 @@ public <R> R visitTypes(Function<ArgType, R> visitor) {\n \t}\n \n \tpublic static ArgType tryToResolveClassAlias(RootNode root, ArgType type) {\n-\t\tif (!type.isObject() || type.isGenericType()) {\n+\t\tif (type.isGenericType()) {\n \t\t\treturn type;\n \t\t}\n-\n-\t\tClassNode cls = root.resolveClass(type);\n-\t\tif (cls == null) {\n-\t\t\treturn type;\n-\t\t}\n-\t\tClassInfo clsInfo = cls.getClassInfo();\n-\t\tif (!clsInfo.hasAlias()) {\n-\t\t\treturn type;\n+\t\tif (type.isArray()) {\n+\t\t\tArgType rootType = type.getArrayRootElement();\n+\t\t\tArgType aliasType = tryToResolveClassAlias(root, rootType);\n+\t\t\tif (aliasType == rootType) {\n+\t\t\t\treturn type;\n+\t\t\t}\n+\t\t\treturn ArgType.array(aliasType, type.getArrayDimension());\n \t\t}\n-\t\tString aliasFullName = clsInfo.getAliasFullName();\n-\t\tif (type.isGeneric()) {\n-\t\t\tif (type instanceof GenericObject) {\n-\t\t\t\treturn new GenericObject(aliasFullName, type.getGenericTypes());\n+\t\tif (type.isObject()) {\n+\t\t\tArgType wildcardType = type.getWildcardType();\n+\t\t\tif (wildcardType != null) {\n+\t\t\t\treturn new WildcardType(tryToResolveClassAlias(root, wildcardType), type.getWildcardBound());\n \t\t\t}\n-\t\t\tif (type instanceof WildcardType) {\n-\t\t\t\treturn new WildcardType(ArgType.object(aliasFullName), type.getWildcardBound());\n+\t\t\tClassInfo clsInfo = ClassInfo.fromName(root, type.getObject());\n+\t\t\tArgType baseType = clsInfo.hasAlias() ? ArgType.object(clsInfo.getAliasFullName()) : type;\n+\t\t\tif (!type.isGeneric()) {\n+\t\t\t\treturn baseType;\n+\t\t\t}\n+\t\t\tList<ArgType> genericTypes = type.getGenericTypes();\n+\t\t\tif (genericTypes != null) {\n+\t\t\t\treturn new GenericObject(baseType.getObject(), tryToResolveClassAlias(root, genericTypes));\n \t\t\t}\n \t\t}\n-\t\treturn ArgType.object(aliasFullName);\n+\t\treturn type;\n+\t}\n+\n+\tpublic static List<ArgType> tryToResolveClassAlias(RootNode root, List<ArgType> types) {\n+\t\treturn ListUtils.map(types, t -> tryToResolveClassAlias(root, t));\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n@@ -90,7 +90,7 @@ public int getPos() {\n \t}\n \n \tpublic String getTooltip() {\n-\t\treturn null;\n+\t\treturn makeLongStringHtml();\n \t}\n \n \tprivate static final Comparator<JNode> COMPARATOR = Comparator\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java\n@@ -83,6 +83,6 @@ private void updateToolTip(JavaNode node) {\n \t\t}\n \t\tJNodeCache nodeCache = codeArea.getMainWindow().getCacheObject().getNodeCache();\n \t\tJNode jNode = nodeCache.makeFrom(node);\n-\t\tcodeArea.setToolTipText(jNode.makeLongString());\n+\t\tcodeArea.setToolTipText(jNode.getTooltip());\n \t}\n }",
    "output": "Use alias for types in tooltips"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/NameGen.java b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n@@ -7,6 +7,7 @@\n \n import jadx.core.Consts;\n import jadx.core.deobf.NameMapper;\n+import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.nodes.LoopLabelAttr;\n import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.info.MethodInfo;\n@@ -173,18 +174,14 @@ private String guessName(CodeVar var) {\n \n \tprivate String makeNameForType(ArgType type) {\n \t\tif (type.isPrimitive()) {\n-\t\t\treturn makeNameForPrimitive(type);\n+\t\t\treturn type.getPrimitiveType().getShortName().toLowerCase();\n \t\t}\n \t\tif (type.isArray()) {\n \t\t\treturn makeNameForType(type.getArrayRootElement()) + \"Arr\";\n \t\t}\n \t\treturn makeNameForObject(type);\n \t}\n \n-\tprivate static String makeNameForPrimitive(ArgType type) {\n-\t\treturn type.getPrimitiveType().getShortName().toLowerCase();\n-\t}\n-\n \tprivate String makeNameForObject(ArgType type) {\n \t\tif (type.isGenericType()) {\n \t\t\treturn StringUtils.escape(type.getObject().toLowerCase());\n@@ -194,23 +191,32 @@ private String makeNameForObject(ArgType type) {\n \t\t\tif (alias != null) {\n \t\t\t\treturn alias;\n \t\t\t}\n-\t\t\tClassInfo extClsInfo = ClassInfo.fromType(mth.root(), type);\n-\t\t\tString shortName = extClsInfo.getShortName();\n-\t\t\tString vName = fromName(shortName);\n-\t\t\tif (vName != null) {\n-\t\t\t\treturn vName;\n-\t\t\t}\n-\t\t\tif (shortName != null) {\n-\t\t\t\tString lower = StringUtils.escape(shortName.toLowerCase());\n-\t\t\t\tif (shortName.equals(lower)) {\n-\t\t\t\t\treturn lower + \"Var\";\n-\t\t\t\t}\n-\t\t\t\treturn lower;\n-\t\t\t}\n+\t\t\treturn makeNameForCheckedClass(ClassInfo.fromType(mth.root(), type));\n \t\t}\n \t\treturn StringUtils.escape(type.toString());\n \t}\n \n+\tprivate String makeNameForCheckedClass(ClassInfo classInfo) {\n+\t\tString shortName = classInfo.getAliasShortName();\n+\t\tString vName = fromName(shortName);\n+\t\tif (vName != null) {\n+\t\t\treturn vName;\n+\t\t}\n+\t\tString lower = StringUtils.escape(shortName.toLowerCase());\n+\t\tif (shortName.equals(lower)) {\n+\t\t\treturn lower + \"Var\";\n+\t\t}\n+\t\treturn lower;\n+\t}\n+\n+\tprivate String makeNameForClass(ClassInfo classInfo) {\n+\t\tString alias = getAliasForObject(classInfo.getFullName());\n+\t\tif (alias != null) {\n+\t\t\treturn alias;\n+\t\t}\n+\t\treturn makeNameForCheckedClass(classInfo);\n+\t}\n+\n \tprivate static String fromName(String name) {\n \t\tif (name == null || name.isEmpty()) {\n \t\t\treturn null;\n@@ -241,7 +247,12 @@ private String makeNameFromInsn(InsnNode insn) {\n \n \t\t\tcase CONSTRUCTOR:\n \t\t\t\tConstructorInsn co = (ConstructorInsn) insn;\n-\t\t\t\treturn makeNameForObject(co.getClassType().getType());\n+\t\t\t\tMethodNode callMth = mth.root().getMethodUtils().resolveMethod(co);\n+\t\t\t\tif (callMth != null && callMth.contains(AFlag.ANONYMOUS_CONSTRUCTOR)) {\n+\t\t\t\t\t// don't use name of anonymous class\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\treturn makeNameForClass(co.getClassType());\n \n \t\t\tcase ARRAY_LENGTH:\n \t\t\t\treturn \"length\";\n@@ -267,11 +278,11 @@ private String makeNameFromInsn(InsnNode insn) {\n \t}\n \n \tprivate String makeNameFromInvoke(MethodInfo callMth) {\n-\t\tString name = callMth.getName();\n-\t\tArgType declType = callMth.getDeclClass().getType();\n+\t\tString name = callMth.getAlias();\n+\t\tClassInfo declClass = callMth.getDeclClass();\n \t\tif (\"getInstance\".equals(name)) {\n \t\t\t// e.g. Cipher.getInstance\n-\t\t\treturn makeNameForType(declType);\n+\t\t\treturn makeNameForClass(declClass);\n \t\t}\n \t\tif (name.startsWith(\"get\") || name.startsWith(\"set\")) {\n \t\t\treturn fromName(name.substring(3));\n@@ -280,9 +291,9 @@ private String makeNameFromInvoke(MethodInfo callMth) {\n \t\t\treturn \"it\";\n \t\t}\n \t\tif (\"toString\".equals(name)) {\n-\t\t\treturn makeNameForType(declType);\n+\t\t\treturn makeNameForClass(declClass);\n \t\t}\n-\t\tif (\"forName\".equals(name) && declType.equals(ArgType.CLASS)) {\n+\t\tif (\"forName\".equals(name) && declClass.getType().equals(ArgType.CLASS)) {\n \t\t\treturn OBJ_ALIAS.get(Consts.CLASS_CLASS);\n \t\t}\n \t\tif (name.startsWith(\"to\")) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java\n@@ -45,6 +45,15 @@ public IMethodDetails getMethodDetails(MethodInfo callMth) {\n \t\treturn root.getClsp().getMethodDetails(callMth);\n \t}\n \n+\t@Nullable\n+\tpublic MethodNode resolveMethod(BaseInvokeNode invokeNode) {\n+\t\tIMethodDetails methodDetails = getMethodDetails(invokeNode);\n+\t\tif (methodDetails instanceof MethodNode) {\n+\t\t\treturn ((MethodNode) methodDetails);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \t/**\n \t * Search methods with same name and args count in class hierarchy starting from {@code startCls}\n \t * Beware {@code startCls} can be different from {@code mthInfo.getDeclClass()}",
    "output": "Use alias for variable names"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -322,6 +322,10 @@ public void setVerbose(boolean verbose) {\n \t\tthis.verbose = verbose;\n \t}\n \n+\tpublic void setDebugInfo(boolean useDebugInfo) {\n+\t\tthis.debugInfo = useDebugInfo;\n+\t}\n+\n \tpublic void setDeobfuscationOn(boolean deobfuscationOn) {\n \t\tthis.deobfuscationOn = deobfuscationOn;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -513,6 +513,13 @@ private SettingsGroup makeDecompilationGroup() {\n \t\t\tneedReload();\n \t\t});\n \n+\t\tJCheckBox useDebugInfo = new JCheckBox();\n+\t\tuseDebugInfo.setSelected(settings.isDebugInfo());\n+\t\tuseDebugInfo.addItemListener(e -> {\n+\t\t\tsettings.setDebugInfo(e.getStateChange() == ItemEvent.SELECTED);\n+\t\t\tneedReload();\n+\t\t});\n+\n \t\tJCheckBox inlineAnonymous = new JCheckBox();\n \t\tinlineAnonymous.setSelected(settings.isInlineAnonymousClasses());\n \t\tinlineAnonymous.addItemListener(e -> {\n@@ -560,6 +567,7 @@ private SettingsGroup makeDecompilationGroup() {\n \t\tother.addRow(NLS.str(\"preferences.replaceConsts\"), replaceConsts);\n \t\tother.addRow(NLS.str(\"preferences.respectBytecodeAccessModifiers\"), respectBytecodeAccessModifiers);\n \t\tother.addRow(NLS.str(\"preferences.useImports\"), useImports);\n+\t\tother.addRow(NLS.str(\"preferences.useDebugInfo\"), useDebugInfo);\n \t\tother.addRow(NLS.str(\"preferences.inlineAnonymous\"), inlineAnonymous);\n \t\tother.addRow(NLS.str(\"preferences.inlineMethods\"), inlineMethods);\n \t\tother.addRow(NLS.str(\"preferences.fsCaseSensitive\"), fsCaseSensitive);",
    "output": "Add missing `Use debug info` option"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n@@ -21,7 +21,7 @@ public static void main(String[] args) {\n \t\t} catch (JadxArgsValidateException e) {\n \t\t\tLOG.error(\"Incorrect arguments: {}\", e.getMessage());\n \t\t\tresult = 1;\n-\t\t} catch (Exception e) {\n+\t\t} catch (Throwable e) {\n \t\t\tLOG.error(\"Process error:\", e);\n \t\t\tresult = 1;\n \t\t} finally {",
    "output": "Fix don't ignore critical errors Thrown java.lang.Error was ignored and not logged."
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FridaAction.java\n@@ -8,6 +8,7 @@\n \n import javax.swing.JOptionPane;\n \n+import org.apache.commons.text.StringEscapeUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -73,7 +74,7 @@ private String generateFridaSnippet(JNode node) {\n \tprivate String generateMethodSnippet(JMethod jMth) {\n \t\tJavaMethod javaMethod = jMth.getJavaMethod();\n \t\tMethodInfo methodInfo = javaMethod.getMethodNode().getMethodInfo();\n-\t\tString methodName = methodInfo.getName();\n+\t\tString methodName = StringEscapeUtils.escapeEcmaScript(methodInfo.getName());\n \t\tif (methodInfo.isConstructor()) {\n \t\t\tmethodName = \"$init\";\n \t\t}\n@@ -83,9 +84,9 @@ private String generateMethodSnippet(JMethod jMth) {\n \t\tif (isOverloaded(javaMethod.getMethodNode())) {\n \t\t\tList<ArgType> methodArgs = methodInfo.getArgumentsTypes();\n \t\t\tString overloadStr = methodArgs.stream().map(this::parseArgType).collect(Collectors.joining(\", \"));\n-\t\t\tfunctionUntilImplementation = String.format(\"%s.%s.overload(%s).implementation\", shortClassName, methodName, overloadStr);\n+\t\t\tfunctionUntilImplementation = String.format(\"%s[\\\"%s\\\"].overload(%s).implementation\", shortClassName, methodName, overloadStr);\n \t\t} else {\n-\t\t\tfunctionUntilImplementation = String.format(\"%s.%s.implementation\", shortClassName, methodName);\n+\t\t\tfunctionUntilImplementation = String.format(\"%s[\\\"%s\\\"].implementation\", shortClassName, methodName);\n \t\t}\n \n \t\tString functionParametersString =\n@@ -109,14 +110,14 @@ private String generateMethodSnippet(JMethod jMth) {\n \n \tprivate String generateClassSnippet(JClass jc) {\n \t\tJavaClass javaClass = jc.getCls();\n-\t\tString rawClassName = javaClass.getRawName();\n+\t\tString rawClassName = StringEscapeUtils.escapeEcmaScript(javaClass.getRawName());\n \t\tString shortClassName = javaClass.getName();\n \t\treturn String.format(\"let %s = Java.use(\\\"%s\\\");\", shortClassName, rawClassName);\n \t}\n \n \tprivate String generateFieldSnippet(JField jf) {\n \t\tJavaField javaField = jf.getJavaField();\n-\t\tString rawFieldName = javaField.getRawName();\n+\t\tString rawFieldName = StringEscapeUtils.escapeEcmaScript(javaField.getRawName());\n \t\tString fieldName = javaField.getName();\n \n \t\tList<MethodNode> methodNodes = javaField.getFieldNode().getParentClass().getMethods();",
    "output": "Fix escape class- method and field names in frida code snippet"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -443,7 +443,7 @@ private boolean ensureProjectIsSaved() {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\tif (res == JOptionPane.YES_OPTION) {\n-\t\t\t\tproject.save();\n+\t\t\t\tsaveProject();\n \t\t\t}\n \t\t}\n \t\treturn true;",
    "output": "Fix ask for project file path on exit"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -22,10 +22,11 @@\n import java.awt.event.MouseEvent;\n import java.awt.event.WindowAdapter;\n import java.awt.event.WindowEvent;\n-import java.io.FileInputStream;\n import java.io.InputStream;\n+import java.net.URL;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.Paths;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -71,6 +72,7 @@\n import javax.swing.tree.TreePath;\n import javax.swing.tree.TreeSelectionModel;\n \n+import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;\n import org.fife.ui.rsyntaxtextarea.Theme;\n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n@@ -112,6 +114,7 @@\n import jadx.gui.treemodel.JRoot;\n import jadx.gui.ui.codearea.AbstractCodeArea;\n import jadx.gui.ui.codearea.AbstractCodeContentPanel;\n+import jadx.gui.ui.codearea.EditorTheme;\n import jadx.gui.ui.codearea.EditorViewState;\n import jadx.gui.ui.dialog.ADBDialog;\n import jadx.gui.ui.dialog.AboutDialog;\n@@ -1298,15 +1301,32 @@ public void setLocationAndPosition() {\n \t}\n \n \tprivate void setEditorTheme(String editorThemePath) {\n+\t\ttry {\n+\t\t\tURL themeUrl = getClass().getResource(editorThemePath);\n+\t\t\tif (themeUrl != null) {\n+\t\t\t\ttry (InputStream is = themeUrl.openStream()) {\n+\t\t\t\t\teditorTheme = Theme.load(is);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tPath themePath = Paths.get(editorThemePath);\n+\t\t\tif (Files.isRegularFile(themePath)) {\n+\t\t\t\ttry (InputStream is = Files.newInputStream(themePath)) {\n+\t\t\t\t\teditorTheme = Theme.load(is);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"Failed to load editor theme: {}\", editorThemePath, e);\n+\t\t}\n+\t\tLOG.warn(\"Falling back to default editor theme: {}\", editorThemePath);\n+\t\teditorThemePath = EditorTheme.getDefaultTheme().getPath();\n \t\ttry (InputStream is = getClass().getResourceAsStream(editorThemePath)) {\n \t\t\teditorTheme = Theme.load(is);\n+\t\t\treturn;\n \t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Can't load editor theme from classpath: {}\", editorThemePath);\n-\t\t\ttry (InputStream is = new FileInputStream(editorThemePath)) {\n-\t\t\t\teditorTheme = Theme.load(is);\n-\t\t\t} catch (Exception ex) {\n-\t\t\t\tLOG.error(\"Can't load editor theme from file: {}\", editorThemePath);\n-\t\t\t}\n+\t\t\tLOG.error(\"Failed to load default editor theme: {}\", editorThemePath, e);\n+\t\t\teditorTheme = new Theme(new RSyntaxTextArea());\n \t\t}\n \t}",
    "output": "Fix editor theme loading and error/fallback handling improved"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java\n@@ -61,7 +61,9 @@ private static boolean processMove(MethodNode mth, InsnNode move) {\n \t\t}\n \t\tSSAVar ssaVar = resultArg.getSVar();\n \t\tif (ssaVar.isUsedInPhi()) {\n-\t\t\treturn deleteMove(mth, move);\n+\t\t\treturn false;\n+\t\t\t// TODO: review conditions of 'up' move inline (test TestMoveInline)\n+\t\t\t// return deleteMove(mth, move);\n \t\t}\n \t\tRegDebugInfoAttr debugInfo = moveArg.get(AType.REG_DEBUG_INFO);\n \t\tfor (RegisterArg useArg : ssaVar.getUseList()) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestMoveInline.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestMoveInline.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestMoveInline.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestMoveInline.java\n@@ -0,0 +1,37 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+@SuppressWarnings(\"CommentedOutCode\")\n+public class TestMoveInline extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tpublic final void Y(int i) throws k {\n+\t\t\tint i2 = 0;\n+\t\t\twhile ((i & (-128)) != 0) {\n+\t\t\t\tthis.h[i2] = (byte) ((i & 127) | 128);\n+\t\t\t\ti >>>= 7;\n+\t\t\t\ti2++;\n+\t\t\t}\n+\t\t\tbyte[] bArr = this.h;\n+\t\t\tbArr[i2] = (byte) i;\n+\t\t\tthis.a.k(bArr, 0, i2 + 1);\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tgetArgs().setRawCFGOutput(true);\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t// check operations order\n+\t\t\t\t.containsLines(3,\n+\t\t\t\t\t\t\"i >>>= 7;\",\n+\t\t\t\t\t\t\"i2++;\");\n+\t}\n+}",
    "output": "Fix workaround to prevent incorrect order after `move` inline"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n@@ -54,20 +54,26 @@ public class TabbedPane extends JTabbedPane {\n \n \t\tsetTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);\n \n-\t\taddMouseWheelListener(e -> {\n-\t\t\tif (openTabs.isEmpty()) {\n+\t\taddMouseWheelListener(event -> {\n+\t\t\tint direction = event.getWheelRotation();\n+\t\t\tif (openTabs.isEmpty() || direction == 0) {\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\tint direction = e.getWheelRotation();\n+\t\t\tdirection = (direction < 0) ? -1 : 1; // normalize direction\n \t\t\tint index = getSelectedIndex();\n \t\t\tint maxIndex = getTabCount() - 1;\n-\t\t\tif ((index == 0 && direction < 0)\n-\t\t\t\t\t|| (index == maxIndex && direction > 0)) {\n-\t\t\t\tindex = maxIndex - index;\n-\t\t\t} else {\n-\t\t\t\tindex += direction;\n+\t\t\tindex += direction;\n+\t\t\t// switch between first tab <-> last tab\n+\t\t\tif (index < 0) {\n+\t\t\t\tindex = maxIndex;\n+\t\t\t} else if (index > maxIndex) {\n+\t\t\t\tindex = 0;\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\tsetSelectedIndex(index);\n+\t\t\t} catch (IndexOutOfBoundsException e) {\n+\t\t\t\t// ignore error\n \t\t\t}\n-\t\t\tsetSelectedIndex(index);\n \t\t});\n \t\tinterceptTabKey();\n \t\tenableSwitchingTabs();",
    "output": "Fix IndexOutOfBoundsException when switching between tabs via mouse wheel"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/data/ProjectData.java b/jadx-gui/src/main/java/jadx/gui/settings/data/ProjectData.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/data/ProjectData.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/data/ProjectData.java\n@@ -4,13 +4,14 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Objects;\n \n import jadx.api.data.impl.JadxCodeData;\n \n public class ProjectData {\n \n \tprivate int projectVersion = 1;\n-\tprivate List<Path> files;\n+\tprivate List<Path> files = new ArrayList<>();\n \tprivate List<String[]> treeExpansions = new ArrayList<>();\n \tprivate JadxCodeData codeData = new JadxCodeData();\n \tprivate List<TabViewState> openTabs = Collections.emptyList();\n@@ -21,7 +22,7 @@ public List<Path> getFiles() {\n \t}\n \n \tpublic void setFiles(List<Path> files) {\n-\t\tthis.files = files;\n+\t\tthis.files = Objects.requireNonNull(files);\n \t}\n \n \tpublic List<String[]> getTreeExpansions() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -76,6 +76,7 @@\n import javax.swing.tree.TreeSelectionModel;\n \n import org.fife.ui.rsyntaxtextarea.Theme;\n+import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -178,7 +179,8 @@ public class MainWindow extends JFrame {\n \tprivate final transient JadxSettings settings;\n \tprivate final transient CacheObject cacheObject;\n \tprivate final transient BackgroundExecutor backgroundExecutor;\n-\tprivate transient JadxProject project;\n+\t@NotNull\n+\tprivate transient JadxProject project = new JadxProject();\n \tprivate transient Action newProjectAction;\n \tprivate transient Action saveProjectAction;\n \n@@ -516,7 +518,7 @@ private List<Path> openProject(Path path) {\n \t\treturn jadxProject.getFilePaths();\n \t}\n \n-\tpublic void updateProject(JadxProject jadxProject) {\n+\tpublic void updateProject(@NotNull JadxProject jadxProject) {\n \t\tjadxProject.setSettings(settings);\n \t\tjadxProject.setMainWindow(this);\n \t\tthis.project = jadxProject;",
    "output": "Fix resolve NPE on project save"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n@@ -192,6 +192,11 @@ public List<PhiInsn> getPhiList() {\n \t\treturn usedInPhi;\n \t}\n \n+\tpublic boolean isAssignInPhi() {\n+\t\tInsnNode assignInsn = getAssignInsn();\n+\t\treturn assignInsn != null && assignInsn.getType() == InsnType.PHI;\n+\t}\n+\n \tpublic boolean isUsedInPhi() {\n \t\treturn usedInPhi != null && !usedInPhi.isEmpty();\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java\n@@ -52,6 +52,13 @@ private static boolean processMove(MethodNode mth, InsnNode move) {\n \t\tif (resultArg.sameRegAndSVar(moveArg)) {\n \t\t\treturn true;\n \t\t}\n+\t\tif (moveArg.isRegister()) {\n+\t\t\tRegisterArg moveReg = (RegisterArg) moveArg;\n+\t\t\tif (moveReg.getSVar().isAssignInPhi()) {\n+\t\t\t\t// don't mix already merged variables\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n \t\tSSAVar ssaVar = resultArg.getSVar();\n \t\tif (ssaVar.isUsedInPhi()) {\n \t\t\treturn deleteMove(mth, move);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundCheckCastAssign.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundCheckCastAssign.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundCheckCastAssign.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundCheckCastAssign.java\n@@ -46,6 +46,10 @@ private ArgType getReturnType(ArgType argType) {\n \t\treturn insn.getResult();\n \t}\n \n+\tpublic IndexInsnNode getInsn() {\n+\t\treturn insn;\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn \"CHECK_CAST_ASSIGN{(\" + insn.getIndex() + \") \" + insn.getArg(0).getType() + \"}\";\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundInvokeAssign.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundInvokeAssign.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundInvokeAssign.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundInvokeAssign.java\n@@ -1,5 +1,7 @@\n package jadx.core.dex.visitors.typeinference;\n \n+import org.jetbrains.annotations.Nullable;\n+\n import jadx.core.dex.instructions.InvokeNode;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n@@ -48,12 +50,24 @@ private ArgType getReturnType(ArgType instanceType) {\n \t\t\tmthDeclType = instanceType;\n \t\t}\n \t\tArgType resultGeneric = root.getTypeUtils().replaceClassGenerics(instanceType, mthDeclType, genericReturnType);\n-\t\tif (resultGeneric != null && !resultGeneric.isWildcard()) {\n-\t\t\treturn resultGeneric;\n+\t\tArgType result = processResultType(resultGeneric);\n+\t\tif (result != null) {\n+\t\t\treturn result;\n \t\t}\n \t\treturn invokeNode.getCallMth().getReturnType();\n \t}\n \n+\t@Nullable\n+\tprivate ArgType processResultType(@Nullable ArgType resultGeneric) {\n+\t\tif (resultGeneric == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tif (!resultGeneric.isWildcard()) {\n+\t\t\treturn resultGeneric;\n+\t\t}\n+\t\treturn resultGeneric.getWildcardType();\n+\t}\n+\n \tprivate InsnArg getInstanceArg() {\n \t\treturn invokeNode.getArg(0);\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -57,6 +57,7 @@\n import jadx.core.utils.BlockUtils;\n import jadx.core.utils.InsnList;\n import jadx.core.utils.InsnUtils;\n+import jadx.core.utils.ListUtils;\n import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxOverflowException;\n \n@@ -83,6 +84,7 @@ public void init(RootNode root) {\n \t\tthis.resolvers = Arrays.asList(\n \t\t\t\tthis::initTypeBounds,\n \t\t\t\tthis::runTypePropagation,\n+\t\t\t\tthis::tryRestoreTypeVarCasts,\n \t\t\t\tthis::tryInsertCasts,\n \t\t\t\tthis::tryDeduceTypes,\n \t\t\t\tthis::trySplitConstInsns,\n@@ -520,7 +522,60 @@ private boolean checkRawType(MethodNode mth, SSAVar var, ArgType objType) {\n \t\treturn false;\n \t}\n \n-\t@SuppressWarnings(\"ForLoopReplaceableByWhile\")\n+\t/**\n+\t * Fix check casts to type var extend type:\n+\t * <br>\n+\t * {@code <T extends Comparable> T var = (Comparable) obj; => T var = (T) obj; }\n+\t */\n+\tprivate boolean tryRestoreTypeVarCasts(MethodNode mth) {\n+\t\tint changed = 0;\n+\t\tList<SSAVar> mthSVars = mth.getSVars();\n+\t\tfor (SSAVar var : mthSVars) {\n+\t\t\tchanged += restoreTypeVarCasts(var);\n+\t\t}\n+\t\tif (changed == 0) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (Consts.DEBUG_TYPE_INFERENCE) {\n+\t\t\tmth.addDebugComment(\"Restore \" + changed + \" type vars casts\");\n+\t\t}\n+\t\tinitTypeBounds(mth);\n+\t\treturn runTypePropagation(mth);\n+\t}\n+\n+\tprivate int restoreTypeVarCasts(SSAVar var) {\n+\t\tTypeInfo typeInfo = var.getTypeInfo();\n+\t\tSet<ITypeBound> bounds = typeInfo.getBounds();\n+\t\tif (!ListUtils.anyMatch(bounds, t -> t.getType().isGenericType())) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tList<ITypeBound> casts = ListUtils.filter(bounds, TypeBoundCheckCastAssign.class::isInstance);\n+\t\tif (casts.isEmpty()) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tArgType bestType = selectBestTypeFromBounds(bounds).orElse(ArgType.UNKNOWN);\n+\t\tif (!bestType.isGenericType()) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tList<ArgType> extendTypes = bestType.getExtendTypes();\n+\t\tif (extendTypes.size() != 1) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tint fixed = 0;\n+\t\tArgType extendType = extendTypes.get(0);\n+\t\tfor (ITypeBound bound : casts) {\n+\t\t\tTypeBoundCheckCastAssign cast = (TypeBoundCheckCastAssign) bound;\n+\t\t\tArgType castType = cast.getType();\n+\t\t\tTypeCompareEnum result = typeUpdate.getTypeCompare().compareTypes(extendType, castType);\n+\t\t\tif (result.isEqual() || result == TypeCompareEnum.NARROW_BY_GENERIC) {\n+\t\t\t\tcast.getInsn().updateIndex(bestType);\n+\t\t\t\tfixed++;\n+\t\t\t}\n+\t\t}\n+\t\treturn fixed;\n+\t}\n+\n+\t@SuppressWarnings({ \"ForLoopReplaceableByWhile\", \"ForLoopReplaceableByForEach\" })\n \tprivate boolean tryInsertCasts(MethodNode mth) {\n \t\tint added = 0;\n \t\tList<SSAVar> mthSVars = mth.getSVars();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/ListUtils.java b/jadx-core/src/main/java/jadx/core/utils/ListUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/ListUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/ListUtils.java\n@@ -112,7 +112,7 @@ public static <T> List<T> safeAdd(List<T> list, T obj) {\n \t\treturn list;\n \t}\n \n-\tpublic static <T> List<T> filter(List<T> list, Predicate<T> filter) {\n+\tpublic static <T> List<T> filter(Collection<T> list, Predicate<T> filter) {\n \t\tif (list == null || list.isEmpty()) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n@@ -148,7 +148,7 @@ public static <T> T filterOnlyOne(List<T> list, Predicate<T> filter) {\n \t\treturn found;\n \t}\n \n-\tpublic static <T> boolean allMatch(List<T> list, Predicate<T> test) {\n+\tpublic static <T> boolean allMatch(Collection<T> list, Predicate<T> test) {\n \t\tif (list == null || list.isEmpty()) {\n \t\t\treturn false;\n \t\t}\n@@ -160,7 +160,7 @@ public static <T> boolean allMatch(List<T> list, Predicate<T> test) {\n \t\treturn true;\n \t}\n \n-\tpublic static <T> boolean anyMatch(List<T> list, Predicate<T> test) {\n+\tpublic static <T> boolean anyMatch(Collection<T> list, Predicate<T> test) {\n \t\tif (list == null || list.isEmpty()) {\n \t\t\treturn false;\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver20.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver20.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver20.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver20.java\n@@ -0,0 +1,75 @@\n+package jadx.tests.integration.types;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+import jadx.tests.api.extensions.profiles.TestProfile;\n+import jadx.tests.api.extensions.profiles.TestWithProfiles;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+/**\n+ * Issue 1238\n+ */\n+public class TestTypeResolver20 extends SmaliTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic interface Sequence<T> {\n+\t\t\tIterator<T> iterator();\n+\t\t}\n+\n+\t\tpublic static <T extends Comparable<? super T>> T max(Sequence<? extends T> seq) {\n+\t\t\tIterator<? extends T> it = seq.iterator();\n+\t\t\tif (!it.hasNext()) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tT t = it.next();\n+\t\t\twhile (it.hasNext()) {\n+\t\t\t\tT next = it.next();\n+\t\t\t\tif (t.compareTo(next) < 0) {\n+\t\t\t\t\tt = next;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn t;\n+\t\t}\n+\n+\t\tprivate static class ArraySeq<T> implements Sequence<T> {\n+\t\t\tprivate final List<T> list;\n+\n+\t\t\t@SafeVarargs\n+\t\t\tpublic ArraySeq(T... arr) {\n+\t\t\t\tthis.list = Arrays.asList(arr);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Iterator<T> iterator() {\n+\t\t\t\treturn list.iterator();\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(max(new ArraySeq<>(2, 5, 3, 4))).isEqualTo(5);\n+\t\t}\n+\t}\n+\n+\t@TestWithProfiles({ TestProfile.DX_J8, TestProfile.JAVA8 })\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"next = next;\")\n+\t\t\t\t.containsOne(\"T next = it.next();\");\n+\t}\n+\n+\t@Test\n+\tpublic void testSmali() {\n+\t\tassertThat(getClassNodeFromSmaliFiles())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"T next = it.next();\")\n+\t\t\t\t.containsOne(\"T next2 = it.next();\");\n+\t}\n+}",
    "output": "Fix handle wildcard in invoke type resolver"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Jadx.java b/jadx-core/src/main/java/jadx/core/Jadx.java\n--- a/jadx-core/src/main/java/jadx/core/Jadx.java\n+++ b/jadx-core/src/main/java/jadx/core/Jadx.java\n@@ -62,6 +62,7 @@\n import jadx.core.dex.visitors.rename.RenameVisitor;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n import jadx.core.dex.visitors.ssa.SSATransform;\n+import jadx.core.dex.visitors.typeinference.FinishTypeInference;\n import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;\n import jadx.core.dex.visitors.usage.UsageInfoVisitor;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n@@ -130,6 +131,7 @@ public static List<IDexTreeVisitor> getRegionsModePasses(JadxArgs args) {\n \t\tif (args.isDebugInfo()) {\n \t\t\tpasses.add(new DebugInfoApplyVisitor());\n \t\t}\n+\t\tpasses.add(new FinishTypeInference());\n \t\tif (args.getUseKotlinMethodsForVarNames() != JadxArgs.UseKotlinMethodsForVarNames.DISABLE) {\n \t\t\tpasses.add(new ProcessKotlinInternals());\n \t\t}\n@@ -204,6 +206,7 @@ public static List<IDexTreeVisitor> getSimpleModePasses(JadxArgs args) {\n \t\tif (args.isDebugInfo()) {\n \t\t\tpasses.add(new DebugInfoApplyVisitor());\n \t\t}\n+\t\tpasses.add(new FinishTypeInference());\n \t\tpasses.add(new CodeRenameVisitor());\n \t\tpasses.add(new DeboxingVisitor());\n \t\tpasses.add(new ModVisitor());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java\n@@ -56,24 +56,11 @@ public void visit(MethodNode mth) throws JadxException {\n \t\t\t\tmth.remove(AType.LOCAL_VARS_DEBUG_INFO);\n \t\t\t}\n \t\t\tprocessMethodParametersAttribute(mth);\n-\t\t\tcheckTypes(mth);\n \t\t} catch (Exception e) {\n \t\t\tmth.addWarnComment(\"Failed to apply debug info\", e);\n \t\t}\n \t}\n \n-\tprivate static void checkTypes(MethodNode mth) {\n-\t\tif (mth.isNoCode() || mth.getSVars().isEmpty()) {\n-\t\t\treturn;\n-\t\t}\n-\t\tmth.getSVars().forEach(var -> {\n-\t\t\tArgType type = var.getTypeInfo().getType();\n-\t\t\tif (!type.isTypeKnown()) {\n-\t\t\t\tmth.addWarnComment(\"Type inference failed for: \" + var.getDetailedVarInfo(mth));\n-\t\t\t}\n-\t\t});\n-\t}\n-\n \tprivate static void applyDebugInfo(MethodNode mth) {\n \t\tif (Consts.DEBUG_TYPE_INFERENCE) {\n \t\t\tLOG.info(\"Apply debug info for method: {}\", mth);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/FinishTypeInference.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/FinishTypeInference.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/FinishTypeInference.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/FinishTypeInference.java\n@@ -0,0 +1,33 @@\n+package jadx.core.dex.visitors.typeinference;\n+\n+import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.dex.visitors.AbstractVisitor;\n+import jadx.core.dex.visitors.JadxVisitor;\n+\n+@JadxVisitor(\n+\t\tname = \"Finish Type Inference\",\n+\t\tdesc = \"Check used types\",\n+\t\trunAfter = {\n+\t\t\t\tTypeInferenceVisitor.class\n+\t\t}\n+)\n+public final class FinishTypeInference extends AbstractVisitor {\n+\n+\t@Override\n+\tpublic void visit(MethodNode mth) {\n+\t\tif (mth.isNoCode() || mth.getSVars().isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tmth.getSVars().forEach(var -> {\n+\t\t\tArgType type = var.getTypeInfo().getType();\n+\t\t\tif (!type.isTypeKnown()) {\n+\t\t\t\tmth.addWarnComment(\"Type inference failed for: \" + var.getDetailedVarInfo(mth));\n+\t\t\t}\n+\t\t\tArgType codeVarType = var.getCodeVar().getType();\n+\t\t\tif (codeVarType == null) {\n+\t\t\t\tvar.getCodeVar().setType(ArgType.UNKNOWN);\n+\t\t\t}\n+\t\t});\n+\t}\n+}",
    "output": "Fix prevent null type in code variables"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java\n@@ -103,6 +103,9 @@ public String getSyntaxName() {\n \n \t@Override\n \tpublic boolean canRename() {\n+\t\tif (mth.isClassInit()) {\n+\t\t\treturn false;\n+\t\t}\n \t\treturn !mth.getMethodNode().contains(AFlag.DONT_RENAME);\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n@@ -87,10 +87,24 @@ private RenameDialog(MainWindow mainWindow, JNode source, JNode node) {\n \t\tthis.mainWindow = mainWindow;\n \t\tthis.cache = mainWindow.getCacheObject();\n \t\tthis.source = source;\n-\t\tthis.node = node;\n+\t\tthis.node = replaceNode(node);\n \t\tinitUI();\n \t}\n \n+\tprivate JNode replaceNode(JNode node) {\n+\t\tif (node instanceof JMethod) {\n+\t\t\tJavaMethod javaMethod = ((JMethod) node).getJavaMethod();\n+\t\t\tif (javaMethod.isClassInit()) {\n+\t\t\t\tthrow new JadxRuntimeException(\"Can't rename class init method: \" + node);\n+\t\t\t}\n+\t\t\tif (javaMethod.isConstructor()) {\n+\t\t\t\t// rename class instead constructor\n+\t\t\t\treturn node.getJParent();\n+\t\t\t}\n+\t\t}\n+\t\treturn node;\n+\t}\n+\n \tprivate void rename() {\n \t\ttry {\n \t\t\tupdateCodeRenames(set -> processRename(node, renameField.getText(), set));",
    "output": "Fix rename class while rename constructor"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n--- a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n+++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n@@ -195,7 +195,11 @@ private Supplier<TaskStatus> buildCancelCheck(long startTime) {\n \t\t\t\t\t// reduce thread count and continue\n \t\t\t\t\texecutor.setCorePoolSize(1);\n \t\t\t\t\tSystem.gc();\n-\t\t\t\t\tUiUtils.sleep(500); // wait GC\n+\t\t\t\t\tUiUtils.sleep(1000); // wait GC\n+\t\t\t\t\tif (!UiUtils.isFreeMemoryAvailable()) {\n+\t\t\t\t\t\tLOG.error(\"Task '{}' memory limit reached (after GC), force cancel\", task.getTitle());\n+\t\t\t\t\t\treturn TaskStatus.CANCEL_BY_MEMORY;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\treturn null;\n \t\t\t};",
    "output": "Fix check free memory after GC attempt"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -212,7 +212,8 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t\t/* int headerSize = */\n \t\tis.readInt16();\n \t\t/* int size = */\n-\t\tis.readInt32();\n+\t\tlong chunkSize = is.readUInt32();\n+\t\tlong chunkEnd = start + chunkSize;\n \n \t\tint id = is.readInt8();\n \t\tis.checkInt8(0, \"type chunk, res0\");\n@@ -231,10 +232,15 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t\tfor (int i = 0; i < entryCount; i++) {\n \t\t\tentryIndexes[i] = is.readInt32();\n \t\t}\n-\n \t\tis.checkPos(entriesStart, \"Expected entry start\");\n \t\tfor (int i = 0; i < entryCount; i++) {\n \t\t\tif (entryIndexes[i] != NO_ENTRY) {\n+\t\t\t\tif (is.getPos() >= chunkEnd) {\n+\t\t\t\t\t// Certain resource obfuscated apps like com.facebook.orca have more entries defined\n+\t\t\t\t\t// than actually fit into the chunk size -> ignore the remaining entries\n+\t\t\t\t\tLOG.warn(\"End of chunk reached - ignoring remaining {} entries\", entryCount - i);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tparseEntry(pkg, id, i, config.getQualifiers());\n \t\t\t}\n \t\t}",
    "output": "Fix ignore resource chunk entries that are located after the resource chunk end"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n@@ -66,7 +66,7 @@ public class JadxCLIArgs {\n \t\t\t\t\t+ \"\\n 'restructure' - restore code structure (normal java code)\"\n \t\t\t\t\t+ \"\\n 'simple' - simplified instructions (linear, with goto's)\"\n \t\t\t\t\t+ \"\\n 'fallback' - raw instructions without modifications\",\n-\t\t\tconverter = RenameConverter.class\n+\t\t\tconverter = DecompilationModeConverter.class\n \t)\n \tprotected DecompilationMode decompilationMode = DecompilationMode.AUTO;",
    "output": "Use correct converter for \"--decompilation-mode\" option"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -132,7 +132,7 @@ private void fillDeobfPresets() {\n \t\t\tfor (MethodNode mth : cls.getMethods()) {\n \t\t\t\tMethodInfo methodInfo = mth.getMethodInfo();\n \t\t\t\tif (methodInfo.hasAlias()) {\n-\t\t\t\t\tdeobfPresets.getFldPresetMap().put(methodInfo.getRawFullId(), methodInfo.getAlias());\n+\t\t\t\t\tdeobfPresets.getMthPresetMap().put(methodInfo.getRawFullId(), methodInfo.getAlias());\n \t\t\t\t}\n \t\t\t}\n \t\t}",
    "output": "Fix writing method mappings as fields entries"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n@@ -25,6 +25,7 @@\n import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;\n import org.fife.ui.rsyntaxtextarea.Token;\n import org.fife.ui.rsyntaxtextarea.TokenMakerFactory;\n+import org.fife.ui.rsyntaxtextarea.TokenTypes;\n import org.fife.ui.rtextarea.SearchContext;\n import org.fife.ui.rtextarea.SearchEngine;\n import org.jetbrains.annotations.Nullable;\n@@ -196,13 +197,37 @@ public String getWordUnderCaret() {\n \tpublic String getWordByPosition(int pos) {\n \t\ttry {\n \t\t\tToken token = modelToToken(pos);\n-\t\t\tif (token != null) {\n-\t\t\t\treturn token.getLexeme();\n-\t\t\t}\n+\t\t\treturn getWordFromToken(token);\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Failed to get word at pos: {}\", pos, e);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t@Nullable\n+\tprivate static String getWordFromToken(@Nullable Token token) {\n+\t\tif (token == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tswitch (token.getType()) {\n+\t\t\tcase TokenTypes.NULL:\n+\t\t\tcase TokenTypes.WHITESPACE:\n+\t\t\tcase TokenTypes.SEPARATOR:\n+\t\t\tcase TokenTypes.OPERATOR:\n+\t\t\t\treturn null;\n+\n+\t\t\tcase TokenTypes.IDENTIFIER:\n+\t\t\t\tif (token.length() == 1) {\n+\t\t\t\t\tchar ch = token.charAt(0);\n+\t\t\t\t\tif (ch == ';' || ch == '.') {\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn token.getLexeme();\n+\n+\t\t\tdefault:\n+\t\t\t\treturn token.getLexeme();\n \t\t}\n-\t\treturn null;\n \t}\n \n \t/**",
    "output": "Fix don't highlight whitespaces and special symbols"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -403,15 +403,22 @@ void open(List<Path> paths) {\n \t}\n \n \tvoid open(List<Path> paths, Runnable onFinish) {\n+\t\tcloseAll();\n \t\tif (paths.size() == 1) {\n \t\t\tPath singleFile = paths.get(0);\n \t\t\tString fileExtension = CommonFileUtils.getFileExtension(singleFile.getFileName().toString());\n \t\t\tif (fileExtension != null && fileExtension.equalsIgnoreCase(JadxProject.PROJECT_EXTENSION)) {\n-\t\t\t\topenProject(singleFile, onFinish);\n+\t\t\t\tList<Path> projectFiles = openProject(singleFile);\n+\t\t\t\tif (!Utils.isEmpty(projectFiles)) {\n+\t\t\t\t\topenFiles(projectFiles, onFinish);\n+\t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n-\t\tcloseAll();\n+\t\topenFiles(paths, onFinish);\n+\t}\n+\n+\tprivate void openFiles(List<Path> paths, Runnable onFinish) {\n \t\tproject.setFilePath(paths);\n \t\tif (paths.isEmpty()) {\n \t\t\treturn;\n@@ -491,9 +498,9 @@ private boolean ensureProjectIsSaved() {\n \t\treturn true;\n \t}\n \n-\tprivate void openProject(Path path, Runnable onFinish) {\n+\tprivate List<Path> openProject(Path path) {\n \t\tif (!ensureProjectIsSaved()) {\n-\t\t\treturn;\n+\t\t\treturn Collections.emptyList();\n \t\t}\n \t\tJadxProject jadxProject = JadxProject.from(path);\n \t\tif (jadxProject == null) {\n@@ -506,12 +513,7 @@ private void openProject(Path path, Runnable onFinish) {\n \t\t}\n \t\tupdateProject(jadxProject);\n \t\tsettings.addRecentProject(path);\n-\t\tList<Path> filePaths = jadxProject.getFilePaths();\n-\t\tif (filePaths == null) {\n-\t\t\tcloseAll();\n-\t\t} else {\n-\t\t\topen(filePaths, onFinish);\n-\t\t}\n+\t\treturn jadxProject.getFilePaths();\n \t}\n \n \tpublic void updateProject(JadxProject jadxProject) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n@@ -35,6 +35,7 @@\n import jadx.gui.ui.panel.ImagePanel;\n import jadx.gui.utils.JumpManager;\n import jadx.gui.utils.JumpPosition;\n+import jadx.gui.utils.NLS;\n \n public class TabbedPane extends JTabbedPane {\n \tprivate static final long serialVersionUID = -8833600618794570904L;\n@@ -165,42 +166,49 @@ private void showCode(final JumpPosition jumpPos) {\n \t\tJNode jumpNode = jumpPos.getNode();\n \t\tObjects.requireNonNull(jumpNode, \"Null node in JumpPosition\");\n \n-\t\tfinal AbstractCodeContentPanel contentPanel = (AbstractCodeContentPanel) getContentPanel(jumpNode);\n-\t\tif (contentPanel == null) {\n-\t\t\treturn;\n-\t\t}\n-\t\tSwingUtilities.invokeLater(() -> {\n-\t\t\tselectTab(contentPanel);\n-\t\t\tAbstractCodeArea codeArea = contentPanel.getCodeArea();\n-\t\t\tint pos = jumpPos.getPos();\n-\t\t\tif (pos > 0) {\n-\t\t\t\tcodeArea.scrollToPos(pos);\n-\t\t\t} else {\n-\t\t\t\tint line = jumpPos.getLine();\n-\t\t\t\tif (line < 0) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tline = 1 + codeArea.getLineOfOffset(-line);\n-\t\t\t\t\t} catch (BadLocationException e) {\n-\t\t\t\t\t\tLOG.error(\"Can't get line for: {}\", jumpPos, e);\n-\t\t\t\t\t\tline = jumpNode.getLine();\n+\t\tmainWindow.getBackgroundExecutor().execute(\n+\t\t\t\tNLS.str(\"progress.load\"),\n+\t\t\t\tjumpNode::getContent, // run heavy loading in background\n+\t\t\t\tstatus -> {\n+\t\t\t\t\t// show the code in UI thread\n+\t\t\t\t\tAbstractCodeContentPanel contentPanel = (AbstractCodeContentPanel) getContentPanel(jumpNode);\n+\t\t\t\t\tif (contentPanel != null) {\n+\t\t\t\t\t\tscrollToPos(contentPanel, jumpPos);\n+\t\t\t\t\t\tselectTab(contentPanel);\n \t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tint lineNum = Math.max(0, line - 1);\n+\t\t\t\t});\n+\t}\n+\n+\tprivate void scrollToPos(AbstractCodeContentPanel contentPanel, JumpPosition jumpPos) {\n+\t\tAbstractCodeArea codeArea = contentPanel.getCodeArea();\n+\t\tint pos = jumpPos.getPos();\n+\t\tif (pos > 0) {\n+\t\t\tcodeArea.scrollToPos(pos);\n+\t\t} else {\n+\t\t\tint line = jumpPos.getLine();\n+\t\t\tif (line < 0) {\n \t\t\t\ttry {\n-\t\t\t\t\tint offs = codeArea.getLineStartOffset(lineNum);\n-\t\t\t\t\twhile (StringUtils.isWhite(codeArea.getText(offs, 1).charAt(0))) {\n-\t\t\t\t\t\toffs += 1;\n-\t\t\t\t\t}\n-\t\t\t\t\toffs += pos;\n-\t\t\t\t\tjumpPos.setPos(offs);\n-\t\t\t\t\tcodeArea.scrollToPos(offs);\n+\t\t\t\t\tline = 1 + codeArea.getLineOfOffset(-line);\n \t\t\t\t} catch (BadLocationException e) {\n-\t\t\t\t\tLOG.error(\"Failed to jump to position: {}\", pos, e);\n-\t\t\t\t\tcodeArea.scrollToLine(line);\n+\t\t\t\t\tLOG.error(\"Can't get line for: {}\", jumpPos, e);\n+\t\t\t\t\tline = jumpPos.getNode().getLine();\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcodeArea.requestFocus();\n-\t\t});\n+\t\t\tint lineNum = Math.max(0, line - 1);\n+\t\t\ttry {\n+\t\t\t\tint offs = codeArea.getLineStartOffset(lineNum);\n+\t\t\t\twhile (StringUtils.isWhite(codeArea.getText(offs, 1).charAt(0))) {\n+\t\t\t\t\toffs += 1;\n+\t\t\t\t}\n+\t\t\t\toffs += pos;\n+\t\t\t\tjumpPos.setPos(offs);\n+\t\t\t\tcodeArea.scrollToPos(offs);\n+\t\t\t} catch (BadLocationException e) {\n+\t\t\t\tLOG.error(\"Failed to jump to position: {}\", pos, e);\n+\t\t\t\tcodeArea.scrollToLine(line);\n+\t\t\t}\n+\t\t}\n+\t\tcodeArea.requestFocus();\n \t}\n \n \tpublic boolean showNode(JNode node) {",
    "output": "Fix restore open tabs on project load (regression fix)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -33,6 +33,8 @@\n import jadx.api.plugins.options.JadxPluginOptions;\n import jadx.core.Jadx;\n import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.attributes.nodes.InlinedAttr;\n import jadx.core.dex.attributes.nodes.LineAttrNode;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.FieldNode;\n@@ -483,12 +485,12 @@ public JavaClass getJavaClassByNode(ClassNode cls) {\n \t\tif (parentClass.contains(AFlag.DONT_GENERATE)) {\n \t\t\treturn null;\n \t\t}\n-\t\tif (parentClass != cls) {\n-\t\t\tJavaClass parentJavaClass = classesMap.get(parentClass);\n-\t\t\tif (parentJavaClass == null) {\n-\t\t\t\tgetClasses();\n-\t\t\t\tparentJavaClass = classesMap.get(parentClass);\n-\t\t\t}\n+\t\tJavaClass parentJavaClass = classesMap.get(parentClass);\n+\t\tif (parentJavaClass == null) {\n+\t\t\tgetClasses();\n+\t\t\tparentJavaClass = classesMap.get(parentClass);\n+\t\t}\n+\t\tif (parentJavaClass != null) {\n \t\t\tloadJavaClass(parentJavaClass);\n \t\t\tjavaClass = classesMap.get(cls);\n \t\t\tif (javaClass != null) {\n@@ -512,7 +514,9 @@ private JavaMethod getJavaMethodByNode(MethodNode mth) {\n \t\t\treturn null;\n \t\t}\n \t\t// parent class not loaded yet\n-\t\tJavaClass javaClass = getJavaClassByNode(mth.getParentClass().getTopParentClass());\n+\t\tClassNode parentClass = mth.getParentClass();\n+\t\tClassNode codeCls = getCodeParentClass(parentClass);\n+\t\tJavaClass javaClass = getJavaClassByNode(codeCls);\n \t\tif (javaClass == null) {\n \t\t\treturn null;\n \t\t}\n@@ -521,12 +525,26 @@ private JavaMethod getJavaMethodByNode(MethodNode mth) {\n \t\tif (javaMethod != null) {\n \t\t\treturn javaMethod;\n \t\t}\n-\t\tif (mth.getParentClass().hasNotGeneratedParent()) {\n+\t\tif (parentClass.hasNotGeneratedParent()) {\n \t\t\treturn null;\n \t\t}\n \t\tthrow new JadxRuntimeException(\"JavaMethod not found by MethodNode: \" + mth);\n \t}\n \n+\tprivate ClassNode getCodeParentClass(ClassNode cls) {\n+\t\tClassNode codeCls;\n+\t\tInlinedAttr inlinedAttr = cls.get(AType.INLINED);\n+\t\tif (inlinedAttr != null) {\n+\t\t\tcodeCls = inlinedAttr.getInlineCls().getTopParentClass();\n+\t\t} else {\n+\t\t\tcodeCls = cls.getTopParentClass();\n+\t\t}\n+\t\tif (codeCls == cls) {\n+\t\t\treturn codeCls;\n+\t\t}\n+\t\treturn getCodeParentClass(codeCls);\n+\t}\n+\n \t@Nullable\n \tprivate JavaField getJavaFieldByNode(FieldNode fld) {\n \t\tJavaField javaField = fieldsMap.get(fld);\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JavaMethod.java b/jadx-core/src/main/java/jadx/api/JavaMethod.java\n--- a/jadx-core/src/main/java/jadx/api/JavaMethod.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java\n@@ -2,9 +2,12 @@\n \n import java.util.Collections;\n import java.util.List;\n+import java.util.Objects;\n import java.util.stream.Collectors;\n \n import org.jetbrains.annotations.ApiStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.MethodOverrideAttr;\n@@ -14,6 +17,7 @@\n import jadx.core.utils.Utils;\n \n public final class JavaMethod implements JavaNode {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(JavaMethod.class);\n \tprivate final MethodNode mth;\n \tprivate final JavaClass parent;\n \n@@ -73,7 +77,14 @@ public List<JavaMethod> getOverrideRelatedMethods() {\n \t\t}\n \t\tJadxDecompiler decompiler = getDeclaringClass().getRootDecompiler();\n \t\treturn ovrdAttr.getRelatedMthNodes().stream()\n-\t\t\t\t.map(m -> ((JavaMethod) decompiler.convertNode(m)))\n+\t\t\t\t.map(m -> {\n+\t\t\t\t\tJavaMethod javaMth = (JavaMethod) decompiler.convertNode(m);\n+\t\t\t\t\tif (javaMth == null) {\n+\t\t\t\t\t\tLOG.warn(\"Failed convert to java method: {}\", m);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn javaMth;\n+\t\t\t\t})\n+\t\t\t\t.filter(Objects::nonNull)\n \t\t\t\t.collect(Collectors.toList());\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java\n@@ -11,6 +11,7 @@\n import jadx.core.dex.attributes.nodes.FieldReplaceAttr;\n import jadx.core.dex.attributes.nodes.ForceReturnAttr;\n import jadx.core.dex.attributes.nodes.GenericInfoAttr;\n+import jadx.core.dex.attributes.nodes.InlinedAttr;\n import jadx.core.dex.attributes.nodes.JadxCommentsAttr;\n import jadx.core.dex.attributes.nodes.JadxError;\n import jadx.core.dex.attributes.nodes.JumpInfo;\n@@ -55,6 +56,7 @@ public final class AType<T extends IJadxAttribute> implements IJadxAttrType<T> {\n \tpublic static final AType<EnumMapAttr> ENUM_MAP = new AType<>();\n \tpublic static final AType<ClassTypeVarsAttr> CLASS_TYPE_VARS = new AType<>();\n \tpublic static final AType<AnonymousClassAttr> ANONYMOUS_CLASS = new AType<>();\n+\tpublic static final AType<InlinedAttr> INLINED = new AType<>();\n \n \t// field\n \tpublic static final AType<FieldInitInsnAttr> FIELD_INIT_INSN = new AType<>();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/InlinedAttr.java b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/InlinedAttr.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/InlinedAttr.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/InlinedAttr.java\n@@ -0,0 +1,29 @@\n+package jadx.core.dex.attributes.nodes;\n+\n+import jadx.api.plugins.input.data.attributes.IJadxAttrType;\n+import jadx.api.plugins.input.data.attributes.IJadxAttribute;\n+import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.nodes.ClassNode;\n+\n+public class InlinedAttr implements IJadxAttribute {\n+\n+\tprivate final ClassNode inlineCls;\n+\n+\tpublic InlinedAttr(ClassNode inlineCls) {\n+\t\tthis.inlineCls = inlineCls;\n+\t}\n+\n+\tpublic ClassNode getInlineCls() {\n+\t\treturn inlineCls;\n+\t}\n+\n+\t@Override\n+\tpublic IJadxAttrType<InlinedAttr> getAttrType() {\n+\t\treturn AType.INLINED;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"INLINED: \" + inlineCls;\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -36,6 +36,7 @@\n import jadx.core.ProcessClass;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.attributes.nodes.InlinedAttr;\n import jadx.core.dex.attributes.nodes.NotificationAttrNode;\n import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.info.AccessInfo.AFType;\n@@ -633,6 +634,7 @@ public void addInlinedClass(ClassNode cls) {\n \t\tif (inlinedClasses.isEmpty()) {\n \t\t\tinlinedClasses = new ArrayList<>(5);\n \t\t}\n+\t\tcls.addAttr(new InlinedAttr(this));\n \t\tinlinedClasses.add(cls);\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n@@ -73,6 +73,7 @@ private static void markAnonymousClass(ClassNode cls) {\n \t\t\treturn;\n \t\t}\n \t\tClassNode outerCls = anonymousConstructor.getUseIn().get(0).getParentClass();\n+\t\touterCls.addInlinedClass(cls);\n \t\tcls.addAttr(new AnonymousClassAttr(outerCls, baseType));\n \t\tcls.add(AFlag.DONT_GENERATE);\n \t\tanonymousConstructor.add(AFlag.ANONYMOUS_CONSTRUCTOR);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n@@ -74,8 +74,11 @@ private void collectUsageData() {\n \tprivate List<JavaNode> getMethodUseIn() {\n \t\tif (node instanceof JMethod) {\n \t\t\tJavaMethod method = ((JMethod) node).getJavaMethod();\n-\t\t\tif (null != method.getMethodNode().get(AType.METHOD_OVERRIDE)) {\n-\t\t\t\treturn method.getOverrideRelatedMethods().stream().flatMap(m -> m.getUseIn().stream()).collect(Collectors.toList());\n+\t\t\tif (method.getMethodNode().contains(AType.METHOD_OVERRIDE)) {\n+\t\t\t\treturn method.getOverrideRelatedMethods()\n+\t\t\t\t\t\t.stream()\n+\t\t\t\t\t\t.flatMap(m -> m.getUseIn().stream())\n+\t\t\t\t\t\t.collect(Collectors.toList());\n \t\t\t}\n \t\t}\n \t\treturn node.getJavaNode().getUseIn();",
    "output": "Fix handle inlined classes while collecting override related methods"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/device/debugger/SmaliDebugger.java b/jadx-gui/src/main/java/jadx/gui/device/debugger/SmaliDebugger.java\n--- a/jadx-gui/src/main/java/jadx/gui/device/debugger/SmaliDebugger.java\n+++ b/jadx-gui/src/main/java/jadx/gui/device/debugger/SmaliDebugger.java\n@@ -632,17 +632,16 @@ private static JDWP initJDWP(OutputStream outputStream, InputStream inputStream)\n \t\tthrow new SmaliDebuggerException(\"Failed to init JDWP.\");\n \t}\n \n-\t@SuppressWarnings(\"ResultOfMethodCallIgnored\")\n \tprivate static void handShake(OutputStream outputStream, InputStream inputStream) throws SmaliDebuggerException {\n-\t\tbyte[] buf = new byte[14];\n+\t\tbyte[] buf;\n \t\ttry {\n \t\t\toutputStream.write(JDWP.encodeHandShakePacket());\n-\t\t\tinputStream.read(buf);\n+\t\t\tbuf = readBytes(inputStream, 14);\n \t\t} catch (Exception e) {\n \t\t\tthrow new SmaliDebuggerException(\"jdwp handshake failed\", e);\n \t\t}\n-\t\tif (!JDWP.decodeHandShakePacket(buf)) {\n-\t\t\tthrow new SmaliDebuggerException(\"jdwp handshake failed.\");\n+\t\tif (buf == null || !JDWP.decodeHandShakePacket(buf)) {\n+\t\t\tthrow new SmaliDebuggerException(\"jdwp handshake bad reply\");\n \t\t}\n \t}\n \n@@ -1170,7 +1169,10 @@ private static byte[] concatBytes(byte[] buf1, byte[] buf2) {\n \t\treturn tempBuf;\n \t}\n \n-\tprivate static void tryThrowError(Packet res) throws SmaliDebuggerException {\n+\tprivate static void tryThrowError(@Nullable Packet res) throws SmaliDebuggerException {\n+\t\tif (res == null) {\n+\t\t\tthrow new SmaliDebuggerException(\"Stream ended\");\n+\t\t}\n \t\tif (res.isError()) {\n \t\t\tthrow new SmaliDebuggerException(\"(JDWP Error Code:\" + res.getErrorCode() + \") \"\n \t\t\t\t\t+ res.getErrorText(), res.getErrorCode());",
    "output": "Fix small improve for jdwp handshake"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/device/debugger/SmaliDebugger.java b/jadx-gui/src/main/java/jadx/gui/device/debugger/SmaliDebugger.java\n--- a/jadx-gui/src/main/java/jadx/gui/device/debugger/SmaliDebugger.java\n+++ b/jadx-gui/src/main/java/jadx/gui/device/debugger/SmaliDebugger.java\n@@ -17,6 +17,7 @@\n import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.atomic.AtomicInteger;\n \n+import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -71,7 +72,6 @@\n import io.github.hqktech.JDWP.VirtualMachine.AllThreads.AllThreadsReplyDataThreads;\n import io.github.hqktech.JDWP.VirtualMachine.CreateString.CreateStringReplyData;\n import io.reactivex.annotations.NonNull;\n-import io.reactivex.annotations.Nullable;\n \n import jadx.api.plugins.input.data.AccessFlags;\n import jadx.gui.device.debugger.smali.RegisterInfo;\n@@ -152,7 +152,7 @@ public static SmaliDebugger attach(String host, int port, SuspendListener suspen\n \t\t\tdebugger.initPools();\n \t\t\treturn debugger;\n \t\t} catch (IOException e) {\n-\t\t\tthrow new SmaliDebuggerException(e);\n+\t\t\tthrow new SmaliDebuggerException(\"Attach failed\", e);\n \t\t}\n \t}\n \n@@ -617,8 +617,8 @@ private static JDWP initJDWP(OutputStream outputStream, InputStream inputStream)\n \t\t\tPacket res = readPacket(inputStream);\n \t\t\ttryThrowError(res);\n \t\t\tif (res.isReplyPacket() && res.getID() == 1) {\n-\t\t\t\toutputStream.write(JDWP.IDSizes.encode().setPacketID(1).getBytes()); // get id sizes for decoding & encoding of jdwp\n-\t\t\t\t// packets.\n+\t\t\t\t// get id sizes for decoding & encoding of jdwp packets.\n+\t\t\t\toutputStream.write(JDWP.IDSizes.encode().setPacketID(1).getBytes());\n \t\t\t\tres = readPacket(inputStream);\n \t\t\t\ttryThrowError(res);\n \t\t\t\tif (res.isReplyPacket() && res.getID() == 1) {\n@@ -632,13 +632,14 @@ private static JDWP initJDWP(OutputStream outputStream, InputStream inputStream)\n \t\tthrow new SmaliDebuggerException(\"Failed to init JDWP.\");\n \t}\n \n+\t@SuppressWarnings(\"ResultOfMethodCallIgnored\")\n \tprivate static void handShake(OutputStream outputStream, InputStream inputStream) throws SmaliDebuggerException {\n \t\tbyte[] buf = new byte[14];\n \t\ttry {\n \t\t\toutputStream.write(JDWP.encodeHandShakePacket());\n-\t\t\tinputStream.read(buf, 0, 14);\n+\t\t\tinputStream.read(buf);\n \t\t} catch (Exception e) {\n-\t\t\tthrow new SmaliDebuggerException(\"jdwp handshake failed, \" + e.getMessage());\n+\t\t\tthrow new SmaliDebuggerException(\"jdwp handshake failed\", e);\n \t\t}\n \t\tif (!JDWP.decodeHandShakePacket(buf)) {\n \t\t\tthrow new SmaliDebuggerException(\"jdwp handshake failed.\");\n@@ -661,23 +662,19 @@ private int genID() {\n \t\treturn idGenerator.getAndAdd(1);\n \t}\n \n-\tprivate static byte[] appendBytes(byte[] buf1, byte[] buf2) {\n-\t\tbyte[] tempBuf = new byte[buf1.length + buf2.length];\n-\t\tSystem.arraycopy(buf1, 0, tempBuf, 0, buf1.length);\n-\t\tSystem.arraycopy(buf2, 0, tempBuf, buf1.length, buf2.length);\n-\t\treturn tempBuf;\n-\t}\n-\n \t/**\n \t * Read & decode packets from Socket connection\n \t */\n \tprivate void decodingLoop() {\n \t\tExecutors.newSingleThreadExecutor().execute(() -> {\n \t\t\tboolean errFromCallback;\n-\t\t\tfor (;;) {\n+\t\t\twhile (true) {\n \t\t\t\terrFromCallback = false;\n \t\t\t\ttry {\n \t\t\t\t\tPacket res = readPacket(inputStream);\n+\t\t\t\t\tif (res == null) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t\tsuspendInfo.nextRound();\n \t\t\t\t\tICommandResult callback = callbackMap.remove(res.getID());\n \t\t\t\t\tif (callback != null) {\n@@ -1129,28 +1126,48 @@ void onClassUnload(ClassUnloadEvent event) {\n \t/**\n \t * Reads a JDWP packet.\n \t */\n+\t@Nullable\n \tprivate static Packet readPacket(InputStream inputStream) throws SmaliDebuggerException {\n-\t\tbyte[] bytes = new byte[JDWP.PACKET_HEADER_SIZE];\n \t\ttry {\n-\t\t\tif (inputStream.read(bytes, 0, bytes.length) == bytes.length) {\n-\t\t\t\tint len = JDWP.getPacketLength(bytes, 0) - JDWP.PACKET_HEADER_SIZE;\n-\t\t\t\tif (len > 0) {\n-\t\t\t\t\tbyte[] payload = new byte[len];\n-\t\t\t\t\tint readSize = 0;\n-\t\t\t\t\tdo {\n-\t\t\t\t\t\treadSize += inputStream.read(payload, readSize, len - readSize);\n-\t\t\t\t\t\tif (readSize == len) {\n-\t\t\t\t\t\t\tbytes = appendBytes(bytes, payload);\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} while (true);\n-\t\t\t\t}\n-\t\t\t\treturn Packet.make(bytes);\n+\t\t\tbyte[] header = readBytes(inputStream, JDWP.PACKET_HEADER_SIZE);\n+\t\t\tif (header == null) {\n+\t\t\t\t// stream ended\n+\t\t\t\treturn null;\n \t\t\t}\n+\t\t\tint bodyLength = JDWP.getPacketLength(header, 0) - JDWP.PACKET_HEADER_SIZE;\n+\t\t\tif (bodyLength <= 0) {\n+\t\t\t\treturn Packet.make(header);\n+\t\t\t}\n+\t\t\tbyte[] body = readBytes(inputStream, bodyLength);\n+\t\t\tif (body == null) {\n+\t\t\t\tthrow new SmaliDebuggerException(\"Stream truncated\");\n+\t\t\t}\n+\t\t\treturn Packet.make(concatBytes(header, body));\n \t\t} catch (IOException e) {\n-\t\t\tthrow new SmaliDebuggerException(e);\n+\t\t\tthrow new SmaliDebuggerException(\"Read packer error\", e);\n \t\t}\n-\t\tthrow new SmaliDebuggerException(\"read packet failed.\");\n+\t}\n+\n+\tprivate static byte[] readBytes(InputStream inputStream, int len) throws IOException {\n+\t\tbyte[] payload = new byte[len];\n+\t\tint readSize = 0;\n+\t\twhile (true) {\n+\t\t\tint read = inputStream.read(payload, readSize, len - readSize);\n+\t\t\tif (read == -1) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treadSize += read;\n+\t\t\tif (readSize == len) {\n+\t\t\t\treturn payload;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static byte[] concatBytes(byte[] buf1, byte[] buf2) {\n+\t\tbyte[] tempBuf = new byte[buf1.length + buf2.length];\n+\t\tSystem.arraycopy(buf1, 0, tempBuf, 0, buf1.length);\n+\t\tSystem.arraycopy(buf2, 0, tempBuf, buf1.length, buf2.length);\n+\t\treturn tempBuf;\n \t}\n \n \tprivate static void tryThrowError(Packet res) throws SmaliDebuggerException {\n@@ -1498,6 +1515,11 @@ public SmaliDebuggerException(String msg) {\n \t\t\tthis.errCode = -1;\n \t\t}\n \n+\t\tpublic SmaliDebuggerException(String message, Throwable cause) {\n+\t\t\tsuper(message, cause);\n+\t\t\tthis.errCode = -1;\n+\t\t}\n+\n \t\tpublic SmaliDebuggerException(String msg, int errCode) {\n \t\t\tsuper(msg);\n \t\t\tthis.errCode = errCode;",
    "output": "Fix handle stream end and partial reads"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n@@ -16,9 +16,14 @@\n import jadx.api.JavaClass;\n import jadx.api.JavaPackage;\n import jadx.api.ResourceFile;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.core.dex.nodes.ProcessState;\n import jadx.gui.settings.JadxProject;\n import jadx.gui.settings.JadxSettings;\n \n+import static jadx.core.dex.nodes.ProcessState.GENERATED_AND_UNLOADED;\n+import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;\n+import static jadx.core.dex.nodes.ProcessState.PROCESS_COMPLETE;\n import static jadx.gui.utils.FileUtils.toFiles;\n \n public class JadxWrapper {\n@@ -51,6 +56,15 @@ public void openFile(List<Path> paths) {\n \t\t}\n \t}\n \n+\t// TODO: check and move into core package\n+\tpublic void unloadClasses() {\n+\t\tfor (ClassNode cls : decompiler.getRoot().getClasses()) {\n+\t\t\tProcessState clsState = cls.getState();\n+\t\t\tcls.unload();\n+\t\t\tcls.setState(clsState == PROCESS_COMPLETE ? GENERATED_AND_UNLOADED : NOT_LOADED);\n+\t\t}\n+\t}\n+\n \tpublic void close() {\n \t\ttry {\n \t\t\tdecompiler.close();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n--- a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n+++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n@@ -76,8 +76,8 @@ public void execute(String title, Runnable backgroundRunnable, Consumer<TaskStat\n \t\texecute(new SimpleTask(title, Collections.singletonList(backgroundRunnable), onFinishUiRunnable));\n \t}\n \n-\tpublic void execute(String title, Runnable backgroundRunnable) {\n-\t\texecute(new SimpleTask(title, Collections.singletonList(backgroundRunnable), null));\n+\tpublic Future<TaskStatus> execute(String title, Runnable backgroundRunnable) {\n+\t\treturn execute(new SimpleTask(title, Collections.singletonList(backgroundRunnable), null));\n \t}\n \n \tprivate ThreadPoolExecutor makeTaskQueueExecutor() {\n@@ -86,6 +86,7 @@ private ThreadPoolExecutor makeTaskQueueExecutor() {\n \n \tprivate final class TaskWorker extends SwingWorker<TaskStatus, Void> implements ITaskInfo {\n \t\tprivate final IBackgroundTask task;\n+\t\tprivate ThreadPoolExecutor executor;\n \t\tprivate TaskStatus status = TaskStatus.WAIT;\n \t\tprivate long jobsCount;\n \t\tprivate long jobsComplete;\n@@ -117,7 +118,7 @@ private void runJobs() throws InterruptedException {\n \t\t\t\t\ttask.getTitle(), jobsCount, task.timeLimit(), task.checkMemoryUsage());\n \t\t\tstatus = TaskStatus.STARTED;\n \t\t\tint threadsCount = mainWindow.getSettings().getThreadsCount();\n-\t\t\tThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(threadsCount);\n+\t\t\texecutor = (ThreadPoolExecutor) Executors.newFixedThreadPool(threadsCount);\n \t\t\tfor (Runnable job : jobs) {\n \t\t\t\texecutor.execute(job);\n \t\t\t}\n@@ -174,14 +175,22 @@ private Supplier<TaskStatus> buildCancelCheck(long startTime) {\n \t\t\t\t\tLOG.error(\"Task '{}' execution timeout, force cancel\", task.getTitle());\n \t\t\t\t\treturn TaskStatus.CANCEL_BY_TIMEOUT;\n \t\t\t\t}\n-\t\t\t\tif (checkMemoryUsage && !UiUtils.isFreeMemoryAvailable()) {\n-\t\t\t\t\tLOG.error(\"Task '{}' memory limit reached, force cancel\", task.getTitle());\n-\t\t\t\t\treturn TaskStatus.CANCEL_BY_MEMORY;\n-\t\t\t\t}\n \t\t\t\tif (isCancelled() || Thread.currentThread().isInterrupted()) {\n \t\t\t\t\tLOG.warn(\"Task '{}' canceled\", task.getTitle());\n \t\t\t\t\treturn TaskStatus.CANCEL_BY_USER;\n \t\t\t\t}\n+\t\t\t\tif (checkMemoryUsage && !UiUtils.isFreeMemoryAvailable()) {\n+\t\t\t\t\tLOG.info(\"Memory usage: {}\", UiUtils.memoryInfo());\n+\t\t\t\t\tif (executor.getCorePoolSize() == 1) {\n+\t\t\t\t\t\tLOG.error(\"Task '{}' memory limit reached, force cancel\", task.getTitle());\n+\t\t\t\t\t\treturn TaskStatus.CANCEL_BY_MEMORY;\n+\t\t\t\t\t}\n+\t\t\t\t\tLOG.warn(\"Low memory, reduce processing threads count to 1\");\n+\t\t\t\t\t// reduce thread count and continue\n+\t\t\t\t\texecutor.setCorePoolSize(1);\n+\t\t\t\t\tSystem.gc();\n+\t\t\t\t\tUiUtils.sleep(500); // wait GC\n+\t\t\t\t}\n \t\t\t\treturn null;\n \t\t\t};\n \t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -85,6 +85,7 @@\n import jadx.api.JadxArgs;\n import jadx.api.JavaNode;\n import jadx.api.ResourceFile;\n+import jadx.api.plugins.utils.CommonFileUtils;\n import jadx.core.Jadx;\n import jadx.core.utils.StringUtils;\n import jadx.core.utils.Utils;\n@@ -342,9 +343,7 @@ private void newProject() {\n \t\tif (!ensureProjectIsSaved()) {\n \t\t\treturn;\n \t\t}\n-\t\tcancelBackgroundJobs();\n-\t\tclearTree();\n-\t\twrapper.close();\n+\t\tcloseAll();\n \t\tupdateProject(new JadxProject());\n \t}\n \n@@ -406,16 +405,14 @@ void open(List<Path> paths) {\n \tvoid open(List<Path> paths, Runnable onFinish) {\n \t\tif (paths.size() == 1) {\n \t\t\tPath singleFile = paths.get(0);\n-\t\t\tif (singleFile.getFileName().toString().toLowerCase(Locale.ROOT).endsWith(JadxProject.PROJECT_EXTENSION)) {\n-\t\t\t\topenProject(singleFile);\n-\t\t\t\tonFinish.run();\n+\t\t\tString fileExtension = CommonFileUtils.getFileExtension(singleFile.getFileName().toString());\n+\t\t\tif (fileExtension != null && fileExtension.equalsIgnoreCase(JadxProject.PROJECT_EXTENSION)) {\n+\t\t\t\topenProject(singleFile, onFinish);\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n+\t\tcloseAll();\n \t\tproject.setFilePath(paths);\n-\t\tclearTree();\n-\t\tBreakpointManager.saveAndExit();\n-\t\tLogCollector.getInstance().reset();\n \t\tif (paths.isEmpty()) {\n \t\t\treturn;\n \t\t}\n@@ -433,6 +430,17 @@ void open(List<Path> paths, Runnable onFinish) {\n \t\t\t\t});\n \t}\n \n+\tprivate void closeAll() {\n+\t\tcancelBackgroundJobs();\n+\t\tsaveOpenTabs();\n+\t\tclearTree();\n+\t\tBreakpointManager.saveAndExit();\n+\t\tLogCollector.getInstance().reset();\n+\t\twrapper.close();\n+\t\ttabbedPane.closeAllTabs();\n+\t\tSystem.gc();\n+\t}\n+\n \tprivate void checkLoadedStatus() {\n \t\tif (!wrapper.getClasses().isEmpty()) {\n \t\t\treturn;\n@@ -483,7 +491,7 @@ private boolean ensureProjectIsSaved() {\n \t\treturn true;\n \t}\n \n-\tprivate void openProject(Path path) {\n+\tprivate void openProject(Path path, Runnable onFinish) {\n \t\tif (!ensureProjectIsSaved()) {\n \t\t\treturn;\n \t\t}\n@@ -500,9 +508,9 @@ private void openProject(Path path) {\n \t\tsettings.addRecentProject(path);\n \t\tList<Path> filePaths = jadxProject.getFilePaths();\n \t\tif (filePaths == null) {\n-\t\t\tclearTree();\n+\t\t\tcloseAll();\n \t\t} else {\n-\t\t\topen(filePaths);\n+\t\t\topen(filePaths, onFinish);\n \t\t}\n \t}\n \n@@ -561,10 +569,14 @@ public void waitDecompileTask() {\n \t\t\t\tDecompileTask decompileTask = new DecompileTask(this, wrapper);\n \t\t\t\tbackgroundExecutor.executeAndWait(decompileTask);\n \n+\t\t\t\tbackgroundExecutor.execute(decompileTask.getTitle(), wrapper::unloadClasses).get();\n+\t\t\t\tSystem.gc();\n+\n \t\t\t\tIndexTask indexTask = new IndexTask(this, wrapper);\n \t\t\t\tbackgroundExecutor.executeAndWait(indexTask);\n \n \t\t\t\tprocessDecompilationResults(decompileTask.getResult(), indexTask.getResult());\n+\t\t\t\tSystem.gc();\n \t\t\t} catch (Exception e) {\n \t\t\t\tLOG.error(\"Decompile task execution failed\", e);\n \t\t\t}\n@@ -1395,7 +1407,9 @@ private void closeWindow() {\n \t}\n \n \tprivate void saveOpenTabs() {\n-\t\tproject.saveOpenTabs(tabbedPane.getEditorViewStates(), tabbedPane.getSelectedIndex());\n+\t\tif (project != null) {\n+\t\t\tproject.saveOpenTabs(tabbedPane.getEditorViewStates(), tabbedPane.getSelectedIndex());\n+\t\t}\n \t}\n \n \tprivate void restoreOpenTabs() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n@@ -314,4 +314,12 @@ public static void copyToClipboard(String text) {\n \t\t\tLOG.error(\"Failed copy text to clipboard\", e);\n \t\t}\n \t}\n+\n+\tpublic static void sleep(int ms) {\n+\t\ttry {\n+\t\t\tThread.sleep(ms);\n+\t\t} catch (InterruptedException e) {\n+\t\t\t// ignore\n+\t\t}\n+\t}\n }",
    "output": "Fix reduce threads count on low memory, other tweaks"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n@@ -389,11 +389,11 @@ protected InsnNode decode(InsnData insn) throws DecodeException {\n \t\t\t\treturn arrLenInsn;\n \n \t\t\tcase AGET:\n-\t\t\t\treturn arrayGet(insn, ArgType.INT_FLOAT);\n+\t\t\t\treturn arrayGet(insn, ArgType.INT_FLOAT, ArgType.NARROW_NUMBERS_NO_BOOL);\n \t\t\tcase AGET_BOOLEAN:\n \t\t\t\treturn arrayGet(insn, ArgType.BOOLEAN);\n \t\t\tcase AGET_BYTE:\n-\t\t\t\treturn arrayGet(insn, ArgType.BYTE);\n+\t\t\t\treturn arrayGet(insn, ArgType.BYTE, ArgType.NARROW_INTEGRAL);\n \t\t\tcase AGET_BYTE_BOOLEAN:\n \t\t\t\treturn arrayGet(insn, ArgType.BYTE_BOOLEAN);\n \t\t\tcase AGET_CHAR:\n@@ -406,7 +406,7 @@ protected InsnNode decode(InsnData insn) throws DecodeException {\n \t\t\t\treturn arrayGet(insn, ArgType.UNKNOWN_OBJECT);\n \n \t\t\tcase APUT:\n-\t\t\t\treturn arrayPut(insn, ArgType.INT_FLOAT);\n+\t\t\t\treturn arrayPut(insn, ArgType.INT_FLOAT, ArgType.NARROW_NUMBERS_NO_BOOL);\n \t\t\tcase APUT_BOOLEAN:\n \t\t\t\treturn arrayPut(insn, ArgType.BOOLEAN);\n \t\t\tcase APUT_BYTE:\n@@ -607,16 +607,24 @@ private InsnNode invoke(InsnData insn, InvokeType type, boolean isRange) {\n \t}\n \n \tprivate InsnNode arrayGet(InsnData insn, ArgType argType) {\n+\t\treturn arrayGet(insn, argType, argType);\n+\t}\n+\n+\tprivate InsnNode arrayGet(InsnData insn, ArgType arrElemType, ArgType resType) {\n \t\tInsnNode inode = new InsnNode(InsnType.AGET, 2);\n-\t\tinode.setResult(InsnArg.typeImmutableIfKnownReg(insn, 0, argType));\n-\t\tinode.addArg(InsnArg.typeImmutableIfKnownReg(insn, 1, ArgType.array(argType)));\n+\t\tinode.setResult(InsnArg.typeImmutableIfKnownReg(insn, 0, resType));\n+\t\tinode.addArg(InsnArg.typeImmutableIfKnownReg(insn, 1, ArgType.array(arrElemType)));\n \t\tinode.addArg(InsnArg.reg(insn, 2, ArgType.NARROW_INTEGRAL));\n \t\treturn inode;\n \t}\n \n \tprivate InsnNode arrayPut(InsnData insn, ArgType argType) {\n+\t\treturn arrayPut(insn, argType, argType);\n+\t}\n+\n+\tprivate InsnNode arrayPut(InsnData insn, ArgType arrElemType, ArgType argType) {\n \t\tInsnNode inode = new InsnNode(InsnType.APUT, 3);\n-\t\tinode.addArg(InsnArg.typeImmutableIfKnownReg(insn, 1, ArgType.array(argType)));\n+\t\tinode.addArg(InsnArg.typeImmutableIfKnownReg(insn, 1, ArgType.array(arrElemType)));\n \t\tinode.addArg(InsnArg.reg(insn, 2, ArgType.NARROW_INTEGRAL));\n \t\tinode.addArg(InsnArg.typeImmutableIfKnownReg(insn, 0, argType));\n \t\treturn inode;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -87,6 +87,7 @@ public void init(RootNode root) {\n \t\t\t\tthis::tryDeduceTypes,\n \t\t\t\tthis::trySplitConstInsns,\n \t\t\t\tthis::tryToFixIncompatiblePrimitives,\n+\t\t\t\tthis::tryToForceImmutableTypes,\n \t\t\t\tthis::tryInsertAdditionalMove,\n \t\t\t\tthis::runMultiVariableSearch,\n \t\t\t\tthis::tryRemoveGenerics);\n@@ -835,13 +836,15 @@ private boolean processIncompatiblePrimitives(MethodNode mth, SSAVar var) {\n \t\tif (typeInfo.getType().isTypeKnown()) {\n \t\t\treturn false;\n \t\t}\n+\t\tboolean assigned = false;\n \t\tfor (ITypeBound bound : typeInfo.getBounds()) {\n \t\t\tArgType boundType = bound.getType();\n \t\t\tswitch (bound.getBound()) {\n \t\t\t\tcase ASSIGN:\n \t\t\t\t\tif (!boundType.contains(PrimitiveType.BOOLEAN)) {\n \t\t\t\t\t\treturn false;\n \t\t\t\t\t}\n+\t\t\t\t\tassigned = true;\n \t\t\t\t\tbreak;\n \t\t\t\tcase USE:\n \t\t\t\t\tif (!boundType.canBeAnyNumber()) {\n@@ -850,6 +853,9 @@ private boolean processIncompatiblePrimitives(MethodNode mth, SSAVar var) {\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n+\t\tif (!assigned) {\n+\t\t\treturn false;\n+\t\t}\n \n \t\tboolean fixed = false;\n \t\tfor (ITypeBound bound : typeInfo.getBounds()) {\n@@ -932,6 +938,36 @@ private TernaryInsn prepareBooleanConvertInsn(RegisterArg resultArg, RegisterArg\n \t\treturn convertInsn;\n \t}\n \n+\tprivate boolean tryToForceImmutableTypes(MethodNode mth) {\n+\t\tboolean fixed = false;\n+\t\tfor (SSAVar ssaVar : mth.getSVars()) {\n+\t\t\tArgType type = ssaVar.getTypeInfo().getType();\n+\t\t\tif (!type.isTypeKnown() && ssaVar.isTypeImmutable()) {\n+\t\t\t\tif (forceImmutableType(ssaVar)) {\n+\t\t\t\t\tfixed = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (!fixed) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn runTypePropagation(mth);\n+\t}\n+\n+\tprivate boolean forceImmutableType(SSAVar ssaVar) {\n+\t\tfor (RegisterArg useArg : ssaVar.getUseList()) {\n+\t\t\tInsnNode parentInsn = useArg.getParentInsn();\n+\t\t\tif (parentInsn != null) {\n+\t\t\t\tInsnType insnType = parentInsn.getType();\n+\t\t\t\tif (insnType == InsnType.AGET || insnType == InsnType.APUT) {\n+\t\t\t\t\tssaVar.setType(ssaVar.getImmutableType());\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tprivate static void assignImmutableTypes(MethodNode mth) {\n \t\tfor (SSAVar ssaVar : mth.getSVars()) {\n \t\t\tArgType immutableType = getSsaImmutableType(ssaVar);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n@@ -513,15 +513,37 @@ private TypeUpdateResult checkCastListener(TypeUpdateInfo updateInfo, InsnNode i\n \n \tprivate TypeUpdateResult arrayGetListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {\n \t\tif (isAssign(insn, arg)) {\n-\t\t\treturn updateTypeChecked(updateInfo, insn.getArg(0), ArgType.array(candidateType));\n+\t\t\tTypeUpdateResult result = updateTypeChecked(updateInfo, insn.getArg(0), ArgType.array(candidateType));\n+\t\t\tif (result == REJECT) {\n+\t\t\t\tArgType arrType = insn.getArg(0).getType();\n+\t\t\t\tif (arrType.isTypeKnown() && arrType.isArray() && arrType.getArrayElement().isPrimitive()) {\n+\t\t\t\t\tTypeCompareEnum compResult = comparator.compareTypes(candidateType, arrType.getArrayElement());\n+\t\t\t\t\tif (compResult == TypeCompareEnum.WIDER) {\n+\t\t\t\t\t\t// allow implicit upcast for primitive types (int a = byteArr[n])\n+\t\t\t\t\t\treturn CHANGED;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn result;\n \t\t}\n \t\tInsnArg arrArg = insn.getArg(0);\n \t\tif (arrArg == arg) {\n \t\t\tArgType arrayElement = candidateType.getArrayElement();\n \t\t\tif (arrayElement == null) {\n \t\t\t\treturn REJECT;\n \t\t\t}\n-\t\t\treturn updateTypeChecked(updateInfo, insn.getResult(), arrayElement);\n+\t\t\tTypeUpdateResult result = updateTypeChecked(updateInfo, insn.getResult(), arrayElement);\n+\t\t\tif (result == REJECT) {\n+\t\t\t\tArgType resType = insn.getResult().getType();\n+\t\t\t\tif (resType.isTypeKnown() && resType.isPrimitive()) {\n+\t\t\t\t\tTypeCompareEnum compResult = comparator.compareTypes(resType, arrayElement);\n+\t\t\t\t\tif (compResult == TypeCompareEnum.WIDER) {\n+\t\t\t\t\t\t// allow implicit upcast for primitive types (int a = byteArr[n])\n+\t\t\t\t\t\treturn CHANGED;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn result;\n \t\t}\n \t\t// index argument\n \t\treturn SAME;\n@@ -538,10 +560,10 @@ private TypeUpdateResult arrayPutListener(TypeUpdateInfo updateInfo, InsnNode in\n \t\t\tTypeUpdateResult result = updateTypeChecked(updateInfo, putArg, arrayElement);\n \t\t\tif (result == REJECT) {\n \t\t\t\tArgType putType = putArg.getType();\n-\t\t\t\tif (putType.isTypeKnown() && !putType.isPrimitive()) {\n+\t\t\t\tif (putType.isTypeKnown()) {\n \t\t\t\t\tTypeCompareEnum compResult = comparator.compareTypes(arrayElement, putType);\n \t\t\t\t\tif (compResult == TypeCompareEnum.WIDER || compResult == TypeCompareEnum.WIDER_BY_GENERIC) {\n-\t\t\t\t\t\t// allow wider result (i.e allow put in Object[] any objects)\n+\t\t\t\t\t\t// allow wider result (i.e. allow put any objects in Object[] or byte in int[])\n \t\t\t\t\t\treturn CHANGED;\n \t\t\t\t\t}\n \t\t\t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver19.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver19.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver19.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver19.java\n@@ -0,0 +1,44 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+/**\n+ * Issue 1407\n+ */\n+public class TestTypeResolver19 extends SmaliTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic static int[] test(byte[] bArr) {\n+\t\t\tint[] iArr = new int[bArr.length];\n+\t\t\tfor (int i = 0; i < bArr.length; i++) {\n+\t\t\t\tiArr[i] = bArr[i];\n+\t\t\t}\n+\t\t\treturn iArr;\n+\t\t}\n+\n+\t\tpublic static int[] test2(byte[] bArr) {\n+\t\t\tint[] iArr = new int[bArr.length];\n+\t\t\tfor (int i = 0; i < bArr.length; i++) {\n+\t\t\t\tint i2 = bArr[i];\n+\t\t\t\tif (i2 < 0) {\n+\t\t\t\t\ti2 = (int) ((long) i2 & 0xFFFF_FFFFL);\n+\t\t\t\t}\n+\t\t\t\tiArr[i] = i2;\n+\t\t\t}\n+\t\t\treturn iArr;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"iArr[i] = bArr[i];\")\n+\t\t\t\t.containsOne(\"iArr[i] = i2;\");\n+\t}\n+}",
    "output": "Fix allow implicit type cast for array operations"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/device/debugger/BreakpointManager.java b/jadx-gui/src/main/java/jadx/gui/device/debugger/BreakpointManager.java\n--- a/jadx-gui/src/main/java/jadx/gui/device/debugger/BreakpointManager.java\n+++ b/jadx-gui/src/main/java/jadx/gui/device/debugger/BreakpointManager.java\n@@ -1,9 +1,11 @@\n package jadx.gui.device.debugger;\n \n+import java.io.Reader;\n import java.lang.reflect.Type;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.Paths;\n import java.util.AbstractMap.SimpleEntry;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -14,6 +16,8 @@\n import java.util.Map.Entry;\n import java.util.Objects;\n \n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -28,52 +32,39 @@\n public class BreakpointManager {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(BreakpointManager.class);\n \n-\tprivate static Gson gson = null;\n+\tprivate static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n \tprivate static final Type TYPE_TOKEN = new TypeToken<Map<String, List<FileBreakpoint>>>() {\n \t}.getType();\n \n-\tprivate static Map<String, List<FileBreakpoint>> bpm;\n-\tprivate static Path savePath;\n+\tprivate static @NotNull Map<String, List<FileBreakpoint>> bpm = Collections.emptyMap();\n+\tprivate static @Nullable Path savePath;\n \tprivate static DebugController debugController;\n \tprivate static Map<String, Entry<ClassNode, Listener>> listeners = Collections.emptyMap(); // class full name as key\n \n \tpublic static void saveAndExit() {\n-\t\tif (bpm != null) {\n-\t\t\tif (bpm.size() == 0 && !Files.exists(savePath)) {\n-\t\t\t\treturn; // user didn't do anything with breakpoint so don't output breakpoint file.\n-\t\t\t}\n-\t\t\tsync();\n-\t\t\tbpm = null;\n-\t\t\tsavePath = null;\n-\t\t\tlisteners = Collections.emptyMap();\n-\t\t}\n+\t\tsync();\n+\t\tbpm = Collections.emptyMap();\n+\t\tsavePath = null;\n+\t\tlisteners = Collections.emptyMap();\n \t}\n \n-\tpublic static void init(Path dirPath) {\n-\t\tif (gson == null) {\n-\t\t\tgson = new GsonBuilder()\n-\t\t\t\t\t.setPrettyPrinting()\n-\t\t\t\t\t.create();\n-\t\t}\n-\t\tsavePath = dirPath.resolve(\"breakpoints.json\");\n+\tpublic static void init(@Nullable Path baseDir) {\n+\t\tPath saveDir = baseDir != null ? baseDir : Paths.get(\".\");\n+\t\tsavePath = saveDir.resolve(\"breakpoints.json\"); // TODO: move into project file or same dir as project file\n \t\tif (Files.exists(savePath)) {\n-\t\t\ttry {\n-\t\t\t\tbyte[] bytes = Files.readAllBytes(savePath);\n-\t\t\t\tbpm = gson.fromJson(new String(bytes, StandardCharsets.UTF_8), TYPE_TOKEN);\n+\t\t\ttry (Reader reader = Files.newBufferedReader(savePath, StandardCharsets.UTF_8)) {\n+\t\t\t\tbpm = GSON.fromJson(reader, TYPE_TOKEN);\n \t\t\t} catch (Exception e) {\n \t\t\t\tLOG.error(\"Failed to read breakpoints config: {}\", savePath, e);\n \t\t\t}\n \t\t}\n-\t\tif (bpm == null) {\n-\t\t\tbpm = Collections.emptyMap();\n-\t\t}\n \t}\n \n \t/**\n \t * @param listener When breakpoint is failed to set during debugging, this listener will be called.\n \t */\n \tpublic static void addListener(JClass topCls, Listener listener) {\n-\t\tif (listeners == Collections.EMPTY_MAP) {\n+\t\tif (listeners.isEmpty()) {\n \t\t\tlisteners = new HashMap<>();\n \t\t}\n \t\tlisteners.put(DbgUtils.getRawFullName(topCls),\n@@ -149,8 +140,15 @@ public static boolean remove(JClass topCls, int line) {\n \t}\n \n \tprivate static void sync() {\n+\t\tif (savePath == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\tif (bpm.isEmpty() && !Files.exists(savePath)) {\n+\t\t\t// user didn't do anything with breakpoint so don't output breakpoint file.\n+\t\t\treturn;\n+\t\t}\n \t\ttry {\n-\t\t\tFiles.write(savePath, gson.toJson(bpm).getBytes(StandardCharsets.UTF_8));\n+\t\t\tFiles.write(savePath, GSON.toJson(bpm).getBytes(StandardCharsets.UTF_8));\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Failed to write breakpoints config: {}\", savePath, e);\n \t\t}",
    "output": "Fix resolve NPE and fix code style in BreakpointManager"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java b/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java\n--- a/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java\n+++ b/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java\n@@ -7,8 +7,6 @@\n import java.net.HttpURLConnection;\n import java.net.URL;\n import java.nio.charset.StandardCharsets;\n-import java.util.Comparator;\n-import java.util.List;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -19,21 +17,20 @@\n import jadx.api.JadxDecompiler;\n import jadx.gui.update.data.Release;\n \n+@SuppressWarnings(\"SameParameterValue\")\n public class JadxUpdate {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(JadxUpdate.class);\n \n \tpublic static final String JADX_RELEASES_URL = \"https://github.com/skylot/jadx/releases\";\n \n \tprivate static final String GITHUB_API_URL = \"https://api.github.com/\";\n-\tprivate static final String GITHUB_RELEASES_URL = GITHUB_API_URL + \"repos/skylot/jadx/releases\";\n+\tprivate static final String GITHUB_LATEST_RELEASE_URL = GITHUB_API_URL + \"repos/skylot/jadx/releases/latest\";\n \n \tprivate static final Gson GSON = new Gson();\n \n-\tprivate static final Type RELEASES_LIST_TYPE = new TypeToken<List<Release>>() {\n+\tprivate static final Type RELEASE_TYPE = new TypeToken<Release>() {\n \t}.getType();\n \n-\tprivate static final Comparator<Release> RELEASE_COMPARATOR = (o1, o2) -> VersionComparator.checkAndCompare(o1.getName(), o2.getName());\n-\n \tpublic interface IUpdateCallback {\n \t\tvoid onUpdate(Release r);\n \t}\n@@ -64,18 +61,15 @@ private static Release checkForNewRelease() throws IOException {\n \t\t\tLOG.debug(\"Ignore check for update: development version\");\n \t\t\treturn null;\n \t\t}\n-\n-\t\tList<Release> list = get(GITHUB_RELEASES_URL, RELEASES_LIST_TYPE);\n-\t\tif (list == null) {\n+\t\tRelease latest = get(GITHUB_LATEST_RELEASE_URL, RELEASE_TYPE);\n+\t\tif (latest == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tlist.removeIf(release -> release.getName().equalsIgnoreCase(version) || release.isPreRelease());\n-\t\tif (list.isEmpty()) {\n+\t\tString latestName = latest.getName();\n+\t\tif (latestName.equalsIgnoreCase(version)) {\n \t\t\treturn null;\n \t\t}\n-\t\tlist.sort(RELEASE_COMPARATOR);\n-\t\tRelease latest = list.get(list.size() - 1);\n-\t\tif (VersionComparator.checkAndCompare(version, latest.getName()) >= 0) {\n+\t\tif (VersionComparator.checkAndCompare(version, latestName) >= 0) {\n \t\t\treturn null;\n \t\t}\n \t\tLOG.info(\"Found new jadx version: {}\", latest);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/update/data/Release.java b/jadx-gui/src/main/java/jadx/gui/update/data/Release.java\n--- a/jadx-gui/src/main/java/jadx/gui/update/data/Release.java\n+++ b/jadx-gui/src/main/java/jadx/gui/update/data/Release.java\n@@ -2,15 +2,9 @@\n \n import java.util.List;\n \n-import com.google.gson.annotations.SerializedName;\n-\n public class Release {\n \tprivate int id;\n \tprivate String name;\n-\n-\t@SerializedName(\"prerelease\")\n-\tprivate boolean preRelease;\n-\n \tprivate List<Asset> assets;\n \n \tpublic String getName() {\n@@ -29,14 +23,6 @@ public void setId(int id) {\n \t\tthis.id = id;\n \t}\n \n-\tpublic boolean isPreRelease() {\n-\t\treturn preRelease;\n-\t}\n-\n-\tpublic void setPreRelease(boolean preRelease) {\n-\t\tthis.preRelease = preRelease;\n-\t}\n-\n \tpublic List<Asset> getAssets() {\n \t\treturn assets;\n \t}",
    "output": "Fix download only latest version info for jadx update"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/Link.java b/jadx-gui/src/main/java/jadx/gui/utils/Link.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/Link.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/Link.java\n@@ -1,10 +1,9 @@\n package jadx.gui.utils;\n \n-import java.awt.Color;\n import java.awt.Cursor;\n import java.awt.Desktop;\n+import java.awt.event.MouseAdapter;\n import java.awt.event.MouseEvent;\n-import java.awt.event.MouseListener;\n import java.util.Map;\n \n import javax.swing.JLabel;\n@@ -16,7 +15,7 @@\n \n import static java.awt.Desktop.Action;\n \n-public class Link extends JLabel implements MouseListener {\n+public class Link extends JLabel {\n \tprivate static final long serialVersionUID = 3655322136444908178L;\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(Link.class);\n@@ -26,34 +25,15 @@ public class Link extends JLabel implements MouseListener {\n \tpublic Link(String text, String url) {\n \t\tsuper(text);\n \t\tthis.url = url;\n-\t\tthis.setToolTipText(\"Open \" + url + \" in your browser\");\n-\t\tthis.addMouseListener(this);\n-\t\tthis.setForeground(Color.BLUE);\n-\t}\n-\n-\t@Override\n-\tpublic void mouseClicked(MouseEvent arg0) {\n-\t\tbrowse();\n-\t}\n-\n-\t@Override\n-\tpublic void mouseEntered(MouseEvent arg0) {\n-\t\tsetCursor(new Cursor(Cursor.HAND_CURSOR));\n-\t}\n-\n-\t@Override\n-\tpublic void mouseExited(MouseEvent arg0) {\n-\t\tsetCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n-\t}\n-\n-\t@Override\n-\tpublic void mousePressed(MouseEvent arg0) {\n-\t\t// ignore\n-\t}\n-\n-\t@Override\n-\tpublic void mouseReleased(MouseEvent arg0) {\n-\t\t// ignore\n+\t\tsetText(text);\n+\t\tsetToolTipText(\"Open \" + url + \" in your browser\");\n+\t\tsetCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n+\t\tthis.addMouseListener(new MouseAdapter() {\n+\t\t\t@Override\n+\t\t\tpublic void mouseClicked(MouseEvent e) {\n+\t\t\t\tbrowse();\n+\t\t\t}\n+\t\t});\n \t}\n \n \tprivate void browse() {\n@@ -69,14 +49,13 @@ private void browse() {\n \t\t\t}\n \t\t}\n \t\ttry {\n-\t\t\tString os = System.getProperty(\"os.name\").toLowerCase();\n-\t\t\tif (os.contains(\"win\")) {\n+\t\t\tif (SystemInfo.IS_WINDOWS) {\n \t\t\t\tnew ProcessBuilder()\n \t\t\t\t\t\t.command(new String[] { \"rundll32\", \"url.dll,FileProtocolHandler\", url })\n \t\t\t\t\t\t.start();\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\tif (os.contains(\"mac\")) {\n+\t\t\tif (SystemInfo.IS_MAC) {\n \t\t\t\tnew ProcessBuilder()\n \t\t\t\t\t\t.command(new String[] { \"open\", url })\n \t\t\t\t\t\t.start();",
    "output": "Fix don't use hardcoded color for link component"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/update/VersionComparator.java b/jadx-gui/src/main/java/jadx/gui/update/VersionComparator.java\n--- a/jadx-gui/src/main/java/jadx/gui/update/VersionComparator.java\n+++ b/jadx-gui/src/main/java/jadx/gui/update/VersionComparator.java\n@@ -6,22 +6,23 @@ private VersionComparator() {\n \t}\n \n \tpublic static int checkAndCompare(String str1, String str2) {\n-\t\ttry {\n-\t\t\treturn compare(clean(str1), clean(str2));\n-\t\t} catch (NumberFormatException e) {\n-\t\t\treturn -2;\n-\t\t}\n+\t\treturn compare(clean(str1), clean(str2));\n \t}\n \n \tprivate static String clean(String str) {\n+\t\tif (str == null || str.isEmpty()) {\n+\t\t\treturn \"\";\n+\t\t}\n \t\tString result = str.trim().toLowerCase();\n \t\tif (result.charAt(0) == 'v') {\n \t\t\tresult = result.substring(1);\n \t\t}\n+\t\t// treat package version as part of version\n+\t\tresult = result.replace('-', '.');\n \t\treturn result;\n \t}\n \n-\tpublic static int compare(String str1, String str2) {\n+\tprivate static int compare(String str1, String str2) {\n \t\tString[] s1 = str1.split(\"\\\\.\");\n \t\tint l1 = s1.length;\n \t\tString[] s2 = str2.split(\"\\\\.\");\n\ndiff --git a/jadx-gui/src/test/java/jadx/gui/update/VersionComparatorTest.java b/jadx-gui/src/test/java/jadx/gui/update/VersionComparatorTest.java\n--- a/jadx-gui/src/test/java/jadx/gui/update/VersionComparatorTest.java\n+++ b/jadx-gui/src/test/java/jadx/gui/update/VersionComparatorTest.java\n@@ -2,8 +2,7 @@\n \n import org.junit.jupiter.api.Test;\n \n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.is;\n+import static org.assertj.core.api.Assertions.assertThat;\n \n class VersionComparatorTest {\n \n@@ -24,10 +23,17 @@ public void testCompare() {\n \t\tcheckCompare(\"0.4.8\", \"0.5\", -1);\n \t\tcheckCompare(\"0.4.8\", \"0.5.0\", -1);\n \t\tcheckCompare(\"0.4.8\", \"0.6\", -1);\n+\t\tcheckCompare(\"1.3.3.1\", \"1.3.3\", 1);\n+\t\tcheckCompare(\"1.3.3-1\", \"1.3.3\", 1);\n+\t\tcheckCompare(\"1.3.3.1-1\", \"1.3.3\", 1);\n \t}\n \n \tprivate static void checkCompare(String a, String b, int result) {\n-\t\tassertThat(VersionComparator.compare(a, b), is(result));\n-\t\tassertThat(VersionComparator.compare(b, a), is(-result));\n+\t\tassertThat(VersionComparator.checkAndCompare(a, b))\n+\t\t\t\t.as(\"Compare %s and %s expect %d\", a, b, result)\n+\t\t\t\t.isEqualTo(result);\n+\t\tassertThat(VersionComparator.checkAndCompare(b, a))\n+\t\t\t\t.as(\"Compare %s and %s expect %d\", b, a, -result)\n+\t\t\t\t.isEqualTo(-result);\n \t}\n }",
    "output": "Fix handle package version in update check"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n@@ -1,10 +1,10 @@\n package jadx.core.dex.visitors;\n \n-import java.util.Comparator;\n import java.util.HashSet;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.stream.Collectors;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n \n import org.jetbrains.annotations.Nullable;\n \n@@ -34,7 +34,6 @@\n import jadx.core.utils.InsnList;\n import jadx.core.utils.InsnRemover;\n import jadx.core.utils.InsnUtils;\n-import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxException;\n \n @JadxVisitor(\n@@ -87,7 +86,7 @@ private static boolean process(MethodNode mth, List<InsnNode> instructions, int\n \t\t}\n \t\tswitch (insn.getType()) {\n \t\t\tcase NEW_ARRAY:\n-\t\t\t\treturn processNewArray(mth, (NewArrayNode) insn, instructions, i, remover);\n+\t\t\t\treturn processNewArray(mth, (NewArrayNode) insn, instructions, remover);\n \n \t\t\tcase SWITCH:\n \t\t\t\treturn processEnumSwitch(mth, (SwitchInsn) insn);\n@@ -100,8 +99,7 @@ private static boolean process(MethodNode mth, List<InsnNode> instructions, int\n \t/**\n \t * Replace new-array and sequence of array-put to new filled-array instruction.\n \t */\n-\tprivate static boolean processNewArray(MethodNode mth, NewArrayNode newArrayInsn,\n-\t\t\tList<InsnNode> instructions, int i, InsnRemover remover) {\n+\tprivate static boolean processNewArray(MethodNode mth, NewArrayNode newArrayInsn, List<InsnNode> instructions, InsnRemover remover) {\n \t\tObject arrayLenConst = InsnUtils.getConstValueByArg(mth.root(), newArrayInsn.getArg(0));\n \t\tif (!(arrayLenConst instanceof LiteralArg)) {\n \t\t\treturn false;\n@@ -110,50 +108,81 @@ private static boolean processNewArray(MethodNode mth, NewArrayNode newArrayInsn\n \t\tif (len == 0) {\n \t\t\treturn false;\n \t\t}\n+\t\tArgType arrType = newArrayInsn.getArrayType();\n+\t\tArgType elemType = arrType.getArrayElement();\n+\t\tboolean allowMissingKeys = arrType.getArrayDimension() == 1 && elemType.isPrimitive();\n+\t\tint minLen = allowMissingKeys ? len / 2 : len;\n+\n \t\tRegisterArg arrArg = newArrayInsn.getResult();\n \t\tList<RegisterArg> useList = arrArg.getSVar().getUseList();\n-\t\tif (useList.size() < len) {\n+\t\tif (useList.size() < minLen) {\n \t\t\treturn false;\n \t\t}\n-\t\tList<InsnNode> arrPuts = useList.stream()\n-\t\t\t\t.map(InsnArg::getParentInsn)\n-\t\t\t\t.filter(Objects::nonNull)\n-\t\t\t\t.filter(insn -> insn.getType() == InsnType.APUT)\n-\t\t\t\t.sorted(Comparator.comparingLong(insn -> {\n-\t\t\t\t\tObject constVal = InsnUtils.getConstValueByArg(mth.root(), insn.getArg(1));\n-\t\t\t\t\tif (constVal instanceof LiteralArg) {\n-\t\t\t\t\t\treturn ((LiteralArg) constVal).getLiteral();\n-\t\t\t\t\t}\n-\t\t\t\t\treturn -1; // bad value, put at top to fail fast next check\n-\t\t\t\t}))\n-\t\t\t\t.collect(Collectors.toList());\n-\t\tif (arrPuts.size() != len) {\n-\t\t\treturn false;\n+\t\t// quick check if APUT is used\n+\t\tboolean foundPut = false;\n+\t\tfor (RegisterArg registerArg : useList) {\n+\t\t\tInsnNode parentInsn = registerArg.getParentInsn();\n+\t\t\tif (parentInsn != null && parentInsn.getType() == InsnType.APUT) {\n+\t\t\t\tfoundPut = true;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n-\t\t// expect all puts to be in same block\n-\t\tif (!new HashSet<>(instructions).containsAll(arrPuts)) {\n+\t\tif (!foundPut) {\n \t\t\treturn false;\n \t\t}\n-\n-\t\tfor (int j = 0; j < len; j++) {\n-\t\t\tInsnNode insn = arrPuts.get(j);\n-\t\t\tif (!checkPutInsn(mth, insn, arrArg, j)) {\n+\t\t// collect put instructions sorted by array index\n+\t\tSortedMap<Long, InsnNode> arrPuts = new TreeMap<>();\n+\t\tfor (RegisterArg registerArg : useList) {\n+\t\t\tInsnNode parentInsn = registerArg.getParentInsn();\n+\t\t\tif (parentInsn == null || parentInsn.getType() != InsnType.APUT) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (!arrArg.sameRegAndSVar(parentInsn.getArg(0))) {\n \t\t\t\treturn false;\n \t\t\t}\n+\t\t\tObject constVal = InsnUtils.getConstValueByArg(mth.root(), parentInsn.getArg(1));\n+\t\t\tif (!(constVal instanceof LiteralArg)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tlong index = ((LiteralArg) constVal).getLiteral();\n+\t\t\tif (index >= len) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (arrPuts.containsKey(index)) {\n+\t\t\t\t// stop on index rewrite\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tarrPuts.put(index, parentInsn);\n+\t\t}\n+\t\tif (arrPuts.size() < minLen) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// expect all puts to be in same block\n+\t\tif (!new HashSet<>(instructions).containsAll(arrPuts.values())) {\n+\t\t\treturn false;\n \t\t}\n \n \t\t// checks complete, apply\n-\t\tArgType arrType = newArrayInsn.getArrayType();\n-\t\tInsnNode filledArr = new FilledNewArrayNode(arrType.getArrayElement(), len);\n+\t\tInsnNode filledArr = new FilledNewArrayNode(elemType, len);\n \t\tfilledArr.setResult(arrArg.duplicate());\n \n-\t\tfor (InsnNode put : arrPuts) {\n+\t\tlong prevIndex = -1;\n+\t\tfor (Map.Entry<Long, InsnNode> entry : arrPuts.entrySet()) {\n+\t\t\tlong index = entry.getKey();\n+\t\t\tif (index != prevIndex) {\n+\t\t\t\t// use zero for missing keys\n+\t\t\t\tfor (long i = prevIndex + 1; i < index; i++) {\n+\t\t\t\t\tfilledArr.addArg(InsnArg.lit(0, elemType));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tInsnNode put = entry.getValue();\n \t\t\tfilledArr.addArg(replaceConstInArg(mth, put.getArg(2)));\n \t\t\tremover.addAndUnbind(put);\n+\t\t\tprevIndex = index;\n \t\t}\n \t\tremover.addAndUnbind(newArrayInsn);\n \n-\t\tInsnNode lastPut = Utils.last(arrPuts);\n+\t\tInsnNode lastPut = arrPuts.get(arrPuts.lastKey());\n \t\tint replaceIndex = InsnList.getIndex(instructions, lastPut);\n \t\tinstructions.set(replaceIndex, filledArr);\n \t\treturn true;\n@@ -172,22 +201,6 @@ private static InsnArg replaceConstInArg(MethodNode mth, InsnArg valueArg) {\n \t\treturn valueArg.duplicate();\n \t}\n \n-\tprivate static boolean checkPutInsn(MethodNode mth, InsnNode insn, RegisterArg arrArg, int putIndex) {\n-\t\tif (insn == null || insn.getType() != InsnType.APUT) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!arrArg.sameRegAndSVar(insn.getArg(0))) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tInsnArg indexArg = insn.getArg(1);\n-\t\tObject value = InsnUtils.getConstValueByArg(mth.root(), indexArg);\n-\t\tif (value instanceof LiteralArg) {\n-\t\t\tint index = (int) ((LiteralArg) value).getLiteral();\n-\t\t\treturn index == putIndex;\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n \tprivate static boolean processEnumSwitch(MethodNode mth, SwitchInsn insn) {\n \t\tInsnArg arg = insn.getArg(0);\n \t\tif (!arg.isInsnWrap()) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayFill3.java b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayFill3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayFill3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayFill3.java\n@@ -1,30 +1,23 @@\n package jadx.tests.integration.arrays;\n \n-import org.junit.jupiter.api.Test;\n-\n-import jadx.NotYetImplemented;\n-import jadx.core.dex.nodes.ClassNode;\n import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.extensions.profiles.TestProfile;\n+import jadx.tests.api.extensions.profiles.TestWithProfiles;\n \n-import static org.hamcrest.CoreMatchers.containsString;\n-import static org.hamcrest.MatcherAssert.assertThat;\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n \n public class TestArrayFill3 extends IntegrationTest {\n \n \tpublic static class TestCls {\n-\n-\t\tpublic byte[] test(int a) {\n+\t\tpublic byte[] test() {\n \t\t\treturn new byte[] { 0, 1, 2 };\n \t\t}\n \t}\n \n-\t@Test\n-\t@NotYetImplemented\n+\t@TestWithProfiles({ TestProfile.ECJ_J8, TestProfile.ECJ_DX_J8 })\n \tpublic void test() {\n-\t\tuseEclipseCompiler();\n-\t\tClassNode cls = getClassNode(TestCls.class);\n-\t\tString code = cls.getCode().toString();\n-\n-\t\tassertThat(code, containsString(\"return new byte[]{0, 1, 2}\"));\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"return new byte[]{0, 1, 2}\");\n \t}\n }",
    "output": "Fix allow zero skips for restore new filled array"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/ClsAliasPair.java b/jadx-core/src/main/java/jadx/core/deobf/ClsAliasPair.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/ClsAliasPair.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/ClsAliasPair.java\n@@ -0,0 +1,24 @@\n+package jadx.core.deobf;\n+\n+public class ClsAliasPair {\n+\tprivate final String pkg;\n+\tprivate final String name;\n+\n+\tpublic ClsAliasPair(String pkg, String name) {\n+\t\tthis.pkg = pkg;\n+\t\tthis.name = name;\n+\t}\n+\n+\tpublic String getPkg() {\n+\t\treturn pkg;\n+\t}\n+\n+\tpublic String getName() {\n+\t\treturn name;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn pkg + '.' + name;\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -386,10 +386,10 @@ private String makeClsAlias(ClassNode cls, boolean badName) {\n \t\tString alias = null;\n \t\tString pkgName = null;\n \t\tif (this.parseKotlinMetadata) {\n-\t\t\tClassInfo kotlinCls = KotlinMetadataUtils.getClassName(cls);\n+\t\t\tClsAliasPair kotlinCls = KotlinMetadataUtils.getClassAlias(cls);\n \t\t\tif (kotlinCls != null) {\n-\t\t\t\talias = prepareNameFull(kotlinCls.getShortName(), \"C\");\n-\t\t\t\tpkgName = kotlinCls.getPackage();\n+\t\t\t\talias = kotlinCls.getName();\n+\t\t\t\tpkgName = kotlinCls.getPkg();\n \t\t\t}\n \t\t}\n \t\tif (alias == null && this.useSourceNameAsAlias) {\n@@ -601,20 +601,6 @@ private String prepareNamePart(String name) {\n \t\treturn NameMapper.removeInvalidCharsMiddle(name);\n \t}\n \n-\tprivate String prepareNameFull(String name, String prefix) {\n-\t\tif (name.length() > maxLength) {\n-\t\t\treturn makeHashName(name, prefix);\n-\t\t}\n-\t\tString result = NameMapper.removeInvalidChars(name, prefix);\n-\t\tif (result.isEmpty()) {\n-\t\t\treturn makeHashName(name, prefix);\n-\t\t}\n-\t\tif (NameMapper.isReserved(result)) {\n-\t\t\treturn pre+ result;\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n \tprivate static String makeHashName(String name, String invalidPrefix) {\n \t\treturn invalidPrefix + 'x' + Integer.toHexString(name.hashCode());\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/RenameReasonAttr.java b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/RenameReasonAttr.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/RenameReasonAttr.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/RenameReasonAttr.java\n@@ -6,6 +6,16 @@\n \n public class RenameReasonAttr implements IJadxAttribute {\n \n+\tpublic static RenameReasonAttr forNode(AttrNode node) {\n+\t\tRenameReasonAttr renameReasonAttr = node.get(AType.RENAME_REASON);\n+\t\tif (renameReasonAttr != null) {\n+\t\t\treturn renameReasonAttr;\n+\t\t}\n+\t\tRenameReasonAttr newAttr = new RenameReasonAttr();\n+\t\tnode.addAttr(newAttr);\n+\t\treturn newAttr;\n+\t}\n+\n \tprivate String description;\n \n \tpublic RenameReasonAttr() {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/kotlin/KotlinMetadataUtils.java b/jadx-core/src/main/java/jadx/core/utils/kotlin/KotlinMetadataUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/kotlin/KotlinMetadataUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/kotlin/KotlinMetadataUtils.java\n@@ -9,22 +9,25 @@\n import jadx.api.plugins.input.data.annotations.EncodedType;\n import jadx.api.plugins.input.data.annotations.EncodedValue;\n import jadx.api.plugins.input.data.annotations.IAnnotation;\n+import jadx.core.deobf.ClsAliasPair;\n+import jadx.core.deobf.NameMapper;\n+import jadx.core.dex.attributes.nodes.RenameReasonAttr;\n import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.nodes.ClassNode;\n+import jadx.core.utils.Utils;\n \n // TODO: parse data from d1 (protobuf encoded) to get original method names and other useful info\n public class KotlinMetadataUtils {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(KotlinMetadataUtils.class);\n \n \tprivate static final String KOTLIN_METADATA_ANNOTATION = \"Lkotlin/Metadata;\";\n \tprivate static final String KOTLIN_METADATA_D2_PARAMETER = \"d2\";\n-\tprivate static final String KOTLIN_METADATA_CLASSNAME_REGEX = \"(L.*;)\";\n \n \t/**\n \t * Try to get class info from Kotlin Metadata annotation\n \t */\n \t@Nullable\n-\tpublic static ClassInfo getClassName(ClassNode cls) {\n+\tpublic static ClsAliasPair getClassAlias(ClassNode cls) {\n \t\tIAnnotation metadataAnnotation = cls.getAnnotation(KOTLIN_METADATA_ANNOTATION);\n \t\tList<EncodedValue> d2Param = getParamAsList(metadataAnnotation, KOTLIN_METADATA_D2_PARAMETER);\n \t\tif (d2Param == null || d2Param.isEmpty()) {\n@@ -36,15 +39,69 @@ public static ClassInfo getClassName(ClassNode cls) {\n \t\t}\n \t\ttry {\n \t\t\tString rawClassName = ((String) firstValue.getValue()).trim();\n-\t\t\tif (rawClassName.matches(KOTLIN_METADATA_CLASSNAME_REGEX)) {\n-\t\t\t\treturn ClassInfo.fromName(cls.root(), rawClassName);\n+\t\t\tif (rawClassName.isEmpty()) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tString clsName = Utils.cleanObjectName(rawClassName);\n+\t\t\tClsAliasPair alias = splitAndCheckClsName(cls, clsName);\n+\t\t\tif (alias != null) {\n+\t\t\t\tRenameReasonAttr.forNode(cls).append(\"from Kotlin metadata\");\n+\t\t\t\treturn alias;\n \t\t\t}\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Failed to parse kotlin metadata\", e);\n \t\t}\n \t\treturn null;\n \t}\n \n+\t// Don't use ClassInfo facility to not pollute class into cache\n+\tprivate static ClsAliasPair splitAndCheckClsName(ClassNode originCls, String fullClsName) {\n+\t\tif (!NameMapper.isValidFullIdentifier(fullClsName)) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tString pkg;\n+\t\tString name;\n+\t\tint dot = fullClsName.lastIndexOf('.');\n+\t\tif (dot == -1) {\n+\t\t\tpkg = \"\";\n+\t\t\tname = fullClsName;\n+\t\t} else {\n+\t\t\tpkg = fullClsName.substring(0, dot);\n+\t\t\tname = fullClsName.substring(dot + 1);\n+\t\t}\n+\t\tClassInfo originClsInfo = originCls.getClassInfo();\n+\t\tString originName = originClsInfo.getShortName();\n+\t\tif (originName.equals(name)\n+\t\t\t\t|| name.contains(\"$\")\n+\t\t\t\t|| !NameMapper.isValidIdentifier(name)\n+\t\t\t\t|| countPkgParts(originClsInfo.getPackage()) != countPkgParts(pkg)\n+\t\t\t\t|| pkg.startsWith(\"java.\")) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tClassNode newClsNode = originCls.root().resolveClass(fullClsName);\n+\t\tif (newClsNode != null) {\n+\t\t\t// class with alias name already exist\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn new ClsAliasPair(pkg, name);\n+\t}\n+\n+\tprivate static int countPkgParts(String pkg) {\n+\t\tif (pkg.isEmpty()) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tint count = 1;\n+\t\tint pos = 0;\n+\t\twhile (true) {\n+\t\t\tpos = pkg.indexOf('.', pos);\n+\t\t\tif (pos == -1) {\n+\t\t\t\treturn count;\n+\t\t\t}\n+\t\t\tpos++;\n+\t\t\tcount++;\n+\t\t}\n+\t}\n+\n \t@SuppressWarnings(\"unchecked\")\n \tprivate static List<EncodedValue> getParamAsList(IAnnotation annotation, String paramName) {\n \t\tif (annotation == null) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/deobf/TestKotlinMetadata.java b/jadx-core/src/test/java/jadx/tests/integration/deobf/TestKotlinMetadata.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/deobf/TestKotlinMetadata.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/deobf/TestKotlinMetadata.java\n@@ -28,7 +28,8 @@ public void test() {\n \t\tprepareArgs(true);\n \t\tassertThat(getClassNodeFromSmali())\n \t\t\t\t.code()\n-\t\t\t\t.containsOne(\"class TestMetaData {\");\n+\t\t\t\t.containsOne(\"class TestMetaData {\")\n+\t\t\t\t.containsOne(\"reason: from Kotlin metadata\");\n \t}\n \n \t@Test\n@@ -42,6 +43,7 @@ public void testIgnoreMetadata() {\n \tprivate void prepareArgs(boolean parseKotlinMetadata) {\n \t\tenableDeobfuscation();\n \t\targs.setDeobfuscationMinLength(100); // rename everything\n+\t\targs.setDeobfuscationForceSave(true);\n \t\tgetArgs().setParseKotlinMetadata(parseKotlinMetadata);\n \t\tdisableCompilation();\n \t}",
    "output": "Fix check names from Kotlin metadata before use"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/XmlDeobf.java b/jadx-core/src/main/java/jadx/core/xmlgen/XmlDeobf.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/XmlDeobf.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/XmlDeobf.java\n@@ -1,46 +1,33 @@\n package jadx.core.xmlgen;\n \n-import java.util.HashMap;\n-import java.util.Map;\n-\n import org.jetbrains.annotations.Nullable;\n \n import jadx.core.dex.info.ClassInfo;\n-import jadx.core.dex.nodes.ClassNode;\n+import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.nodes.RootNode;\n \n /*\n- * modifies android:name attributes and xml tags which are old class names\n- * but were changed during deobfuscation\n+ * Modifies android:name attributes and xml tags which were changed during deobfuscation\n  */\n public class XmlDeobf {\n-\tprivate static final Map<String, String> DEOBF_MAP = new HashMap<>();\n \n \tprivate XmlDeobf() {\n \t}\n \n \t@Nullable\n-\tpublic static String deobfClassName(RootNode rootNode, String potencialClassName, String packageName) {\n-\t\tpotencialClassName = potencialClassName.replace('$', '.');\n-\t\tif (packageName != null && potencialClassName.startsWith(\".\")) {\n-\t\t\tpotencialClassName = packageName + potencialClassName;\n+\tpublic static String deobfClassName(RootNode root, String potentialClassName, String packageName) {\n+\t\tif (potentialClassName.indexOf('.') == -1) {\n+\t\t\treturn null;\n \t\t}\n-\t\treturn getNewClassName(rootNode, potencialClassName);\n-\t}\n-\n-\tprivate static String getNewClassName(RootNode rootNode, String old) {\n-\t\tif (DEOBF_MAP.isEmpty()) {\n-\t\t\tfor (ClassNode classNode : rootNode.getClasses(true)) {\n-\t\t\t\tClassInfo classInfo = classNode.getClassInfo();\n-\t\t\t\tif (classInfo.hasAlias()) {\n-\t\t\t\t\tString oldName = classInfo.getFullName();\n-\t\t\t\t\tString newName = classInfo.getAliasFullName();\n-\t\t\t\t\tif (!oldName.equals(newName)) {\n-\t\t\t\t\t\tDEOBF_MAP.put(oldName, newName);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n+\t\tif (packageName != null && potentialClassName.startsWith(\".\")) {\n+\t\t\tpotentialClassName = packageName + potentialClassName;\n+\t\t}\n+\t\tArgType clsType = ArgType.object(potentialClassName);\n+\t\tClassInfo classInfo = root.getInfoStorage().getCls(clsType);\n+\t\tif (classInfo == null) {\n+\t\t\t// unknown class reference\n+\t\t\treturn null;\n \t\t}\n-\t\treturn DEOBF_MAP.get(old);\n+\t\treturn classInfo.getAliasFullName();\n \t}\n }",
    "output": "Remove static caching map for xml renames"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n--- a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n@@ -126,8 +126,9 @@ private static ResContainer decodeImage(ResourceFile rf, InputStream inputStream\n \t\tif (name.endsWith(\".9.png\")) {\n \t\t\ttry (ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n \t\t\t\tRes9patchStreamDecoder decoder = new Res9patchStreamDecoder();\n-\t\t\t\tdecoder.decode(inputStream, os);\n-\t\t\t\treturn ResContainer.decodedData(rf.getDeobfName(), os.toByteArray());\n+\t\t\t\tif (decoder.decode(inputStream, os)) {\n+\t\t\t\t\treturn ResContainer.decodedData(rf.getDeobfName(), os.toByteArray());\n+\t\t\t\t}\n \t\t\t} catch (Exception e) {\n \t\t\t\tLOG.error(\"Failed to decode 9-patch png image, path: {}\", name, e);\n \t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/android/Res9patchStreamDecoder.java b/jadx-core/src/main/java/jadx/core/utils/android/Res9patchStreamDecoder.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/Res9patchStreamDecoder.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/Res9patchStreamDecoder.java\n@@ -24,23 +24,28 @@\n \n import javax.imageio.ImageIO;\n \n+import org.jetbrains.annotations.Nullable;\n+\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n /**\n  * @author Ryszard Wiśniewski \"brut.alll@gmail.com\"\n  */\n public class Res9patchStreamDecoder {\n \n-\tpublic void decode(InputStream in, OutputStream out) {\n+\tpublic boolean decode(InputStream in, OutputStream out) {\n \t\ttry {\n \t\t\tBufferedImage im = ImageIO.read(in);\n+\t\t\tNinePatch np = getNinePatch(in);\n+\t\t\tif (np == null) {\n+\t\t\t\treturn false;\n+\t\t\t}\n \t\t\tint w = im.getWidth();\n \t\t\tint h = im.getHeight();\n \n \t\t\tBufferedImage im2 = new BufferedImage(w + 2, h + 2, BufferedImage.TYPE_INT_ARGB);\n \t\t\tim2.createGraphics().drawImage(im, 1, 1, w, h, null);\n \n-\t\t\tNinePatch np = getNinePatch(in);\n \t\t\tdrawHLine(im2, h + 1, np.padLeft + 1, w - np.padRight);\n \t\t\tdrawVLine(im2, w + 1, np.padTop + 1, h - np.padBottom);\n \n@@ -55,28 +60,32 @@ public void decode(InputStream in, OutputStream out) {\n \t\t\t}\n \n \t\t\tImageIO.write(im2, \"png\", out);\n+\t\t\treturn true;\n \t\t} catch (Exception e) {\n \t\t\tthrow new JadxRuntimeException(\"9patch image decode error\", e);\n \t\t}\n \t}\n \n+\t@Nullable\n \tprivate NinePatch getNinePatch(InputStream in) throws IOException {\n \t\tExtDataInput di = new ExtDataInput(in);\n-\t\tfind9patchChunk(di);\n+\t\tif (!find9patchChunk(di)) {\n+\t\t\treturn null;\n+\t\t}\n \t\treturn NinePatch.decode(di);\n \t}\n \n-\tprivate void find9patchChunk(DataInput di) throws IOException {\n+\tprivate boolean find9patchChunk(DataInput di) throws IOException {\n \t\tdi.skipBytes(8);\n \t\twhile (true) {\n \t\t\tint size;\n \t\t\ttry {\n \t\t\t\tsize = di.readInt();\n \t\t\t} catch (IOException ex) {\n-\t\t\t\tthrow new JadxRuntimeException(\"Cant find nine patch chunk\", ex);\n+\t\t\t\treturn false;\n \t\t\t}\n \t\t\tif (di.readInt() == NP_CHUNK_TYPE) {\n-\t\t\t\treturn;\n+\t\t\t\treturn true;\n \t\t\t}\n \t\t\tdi.skipBytes(size + 4);\n \t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java b/jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java\n@@ -203,7 +203,7 @@ private void filter(JResource resNode, ZipFile zip) {\n \t\t\t\t\tresNodes.add(resNode);\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tLOG.debug(\"Resource skipped because of size limit: {} res size {} bytes\", resNode, size);\n+\t\t\t\tLOG.debug(\"Resource index skipped because of size limit: {} res size {} bytes\", resNode, size);\n \t\t\t}\n \t\t}\n \t}",
    "output": "Fix skip '.9.png' decode if patch data not found"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/DecompilerScheduler.java b/jadx-core/src/main/java/jadx/core/utils/DecompilerScheduler.java\n--- a/jadx-core/src/main/java/jadx/core/utils/DecompilerScheduler.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/DecompilerScheduler.java\n@@ -17,12 +17,13 @@\n import jadx.api.JadxDecompiler;\n import jadx.api.JavaClass;\n import jadx.core.dex.nodes.ClassNode;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public class DecompilerScheduler implements IDecompileScheduler {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(DecompilerScheduler.class);\n \n \tprivate static final int MERGED_BATCH_SIZE = 16;\n-\tprivate static final boolean DUMP_STATS = false;\n+\tprivate static final boolean DEBUG_BATCHES = false;\n \n \tprivate final JadxDecompiler decompiler;\n \n@@ -38,6 +39,9 @@ public List<List<JavaClass>> buildBatches(List<JavaClass> classes) {\n \t\tif (LOG.isDebugEnabled()) {\n \t\t\tLOG.debug(\"Build decompilation batches in {}ms\", System.currentTimeMillis() - start);\n \t\t}\n+\t\tif (DEBUG_BATCHES) {\n+\t\t\tcheck(result, classes);\n+\t\t}\n \t\treturn result;\n \t}\n \n@@ -61,11 +65,13 @@ public List<List<ClassNode>> internalBatches(List<ClassNode> classes) {\n \t\tList<ClassNode> mergedBatch = new ArrayList<>(MERGED_BATCH_SIZE);\n \t\tfor (DepInfo depInfo : deps) {\n \t\t\tClassNode cls = depInfo.getCls();\n+\t\t\tif (!added.add(cls)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tint depsSize = cls.getDependencies().size();\n \t\t\tif (depsSize == 0) {\n \t\t\t\t// add classes without dependencies in merged batch\n \t\t\t\tmergedBatch.add(cls);\n-\t\t\t\tadded.add(cls);\n \t\t\t\tif (mergedBatch.size() >= MERGED_BATCH_SIZE) {\n \t\t\t\t\tresult.add(mergedBatch);\n \t\t\t\t\tmergedBatch = new ArrayList<>(MERGED_BATCH_SIZE);\n@@ -76,18 +82,18 @@ public List<List<ClassNode>> internalBatches(List<ClassNode> classes) {\n \t\t\t\t\tClassNode topDep = dep.getTopParentClass();\n \t\t\t\t\tif (!added.contains(topDep)) {\n \t\t\t\t\t\tbatch.add(topDep);\n+\t\t\t\t\t\tadded.add(topDep);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tbatch.sort(cmpDepSize);\n \t\t\t\tbatch.add(cls);\n-\t\t\t\tadded.addAll(batch);\n \t\t\t\tresult.add(batch);\n \t\t\t}\n \t\t}\n \t\tif (mergedBatch.size() > 0) {\n \t\t\tresult.add(mergedBatch);\n \t\t}\n-\t\tif (DUMP_STATS) {\n+\t\tif (DEBUG_BATCHES) {\n \t\t\tdumpBatchesStats(classes, result, deps);\n \t\t}\n \t\treturn result;\n@@ -140,8 +146,16 @@ private void dumpBatchesStats(List<ClassNode> classes, List<List<ClassNode>> res\n \t\tLOG.info(\"Batches stats:\"\n \t\t\t\t+ \"\\n input classes: \" + classes.size()\n \t\t\t\t+ \",\\n batches: \" + result.size()\n-\t\t\t\t+ \",\\n average batch size: \" + avg\n+\t\t\t\t+ \",\\n average batch size: \" + String.format(\"%.2f\", avg)\n \t\t\t\t+ \",\\n max single deps count: \" + maxSingleDeps\n \t\t\t\t+ \",\\n max recursive deps count: \" + maxRecursiveDeps);\n \t}\n+\n+\tprivate static void check(List<List<JavaClass>> result, List<JavaClass> classes) {\n+\t\tint classInBatches = result.stream().mapToInt(List::size).sum();\n+\t\tif (classes.size() != classInBatches) {\n+\t\t\tthrow new JadxRuntimeException(\n+\t\t\t\t\t\"Incorrect number of classes in result batch: \" + classInBatches + \", expected: \" + classes.size());\n+\t\t}\n+\t}\n }",
    "output": "Remove duplicate classes from decompilation batches"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java b/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java\n@@ -74,12 +74,22 @@ public boolean hasDescString() {\n \n \t@Override\n \tpublic String makeString() {\n-\t\treturn jNode.makeLongString();\n+\t\treturn jNode.makeString();\n+\t}\n+\n+\t@Override\n+\tpublic String makeStringHtml() {\n+\t\treturn jNode.makeStringHtml();\n \t}\n \n \t@Override\n \tpublic String makeLongString() {\n-\t\treturn makeString();\n+\t\treturn jNode.makeLongString();\n+\t}\n+\n+\t@Override\n+\tpublic String makeLongStringHtml() {\n+\t\treturn jNode.makeLongStringHtml();\n \t}\n \n \t@Override",
    "output": "Fix missing icons and html decorations in usage dialog"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/LogHelper.java b/jadx-cli/src/main/java/jadx/cli/LogHelper.java\n--- a/jadx-cli/src/main/java/jadx/cli/LogHelper.java\n+++ b/jadx-cli/src/main/java/jadx/cli/LogHelper.java\n@@ -54,7 +54,7 @@ public static void applyLogLevel(LogLevelEnum logLevel) {\n \t\tLogger rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);\n \t\trootLogger.setLevel(logLevel.getLevel());\n \n-\t\tif (logLevel != LogLevelEnum.QUIET) {\n+\t\tif (logLevel == LogLevelEnum.PROGRESS) {\n \t\t\t// show progress for all levels except quiet\n \t\t\tsetLevelForClass(JadxCLI.class, Level.INFO);\n \t\t\tsetLevelForClass(JadxDecompiler.class, Level.INFO);\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -128,6 +128,7 @@ private void loadInputFiles() {\n \t\t\t\tloadedInputs.add(loadResult);\n \t\t\t}\n \t\t}\n+\t\tLOG.debug(\"Loaded using {} inputs plugin\", loadedInputs.size());\n \t}\n \n \tprivate void reset() {\n\ndiff --git a/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/JadxPluginManager.java b/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/JadxPluginManager.java\n--- a/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/JadxPluginManager.java\n+++ b/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/JadxPluginManager.java\n@@ -39,6 +39,7 @@ public void load() {\n \t\tServiceLoader<JadxPlugin> jadxPlugins = ServiceLoader.load(JadxPlugin.class);\n \t\tfor (JadxPlugin plugin : jadxPlugins) {\n \t\t\taddPlugin(plugin);\n+\t\t\tLOG.debug(\"Loading plugin: {}\", plugin.getPluginInfo().getPluginId());\n \t\t}\n \t\tresolve();\n \t}",
    "output": "Fix and add debug log messages in initialization phase * Fix log level settings in the CLI * Add log messages in initialization phase"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -709,6 +709,7 @@ public static BlockNode getPathCross(MethodNode mth, Collection<BlockNode> block\n \t\t\treturn oneBlock;\n \t\t}\n \t\tBitSet combinedDF = newBlocksBitSet(mth);\n+\t\tint k = mth.getBasicBlocks().size();\n \t\twhile (true) {\n \t\t\t// collect dom frontier blocks from current set until only one block left\n \t\t\tforEachBlockFromBitSet(mth, domFrontBS, block -> {\n@@ -726,6 +727,10 @@ public static BlockNode getPathCross(MethodNode mth, Collection<BlockNode> block\n \t\t\tif (cardinality == 0) {\n \t\t\t\treturn null;\n \t\t\t}\n+\t\t\tif (k-- < 0) {\n+\t\t\t\tmth.addWarnComment(\"Path cross not found for \" + blocks + \", limit reached: \" + mth.getBasicBlocks().size());\n+\t\t\t\treturn null;\n+\t\t\t}\n \t\t\t// replace domFrontBS with combinedDF\n \t\t\tdomFrontBS.clear();\n \t\t\tdomFrontBS.or(combinedDF);",
    "output": "Fix prevent endless loop in path cross search"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n@@ -1,9 +1,13 @@\n package jadx.core.xmlgen;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n import java.util.Map;\n+import java.util.stream.Collectors;\n \n import javax.xml.parsers.DocumentBuilder;\n \n@@ -171,19 +175,20 @@ public String decode(String attrName, long value) {\n \t\tif (attr.getType() == MAttrType.ENUM) {\n \t\t\treturn attr.getValues().get(value);\n \t\t} else if (attr.getType() == MAttrType.FLAG) {\n-\t\t\tStringBuilder sb = new StringBuilder();\n-\t\t\tfor (Map.Entry<Long, String> entry : attr.getValues().entrySet()) {\n-\t\t\t\tlong key = entry.getKey();\n+\t\t\tList<String> flagList = new LinkedList<>();\n+\t\t\tList<Long> attrKeys = new ArrayList<>(attr.getValues().keySet());\n+\t\t\tattrKeys.sort((a, b) -> Long.compare(b, a)); // sort descending\n+\t\t\tfor (Long key : attrKeys) {\n+\t\t\t\tString attrValue = attr.getValues().get(key);\n \t\t\t\tif (value == key) {\n-\t\t\t\t\tsb = new StringBuilder(entry.getValue() + '|');\n+\t\t\t\t\tflagList.add(attrValue);\n \t\t\t\t\tbreak;\n \t\t\t\t} else if ((key != 0) && ((value & key) == key)) {\n-\t\t\t\t\tsb.append(entry.getValue()).append('|');\n+\t\t\t\t\tflagList.add(attrValue);\n+\t\t\t\t\tvalue ^= key;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif (sb.length() != 0) {\n-\t\t\t\treturn sb.deleteCharAt(sb.length() - 1).toString();\n-\t\t\t}\n+\t\t\treturn flagList.stream().collect(Collectors.joining(\"|\"));\n \t\t}\n \t\treturn null;\n \t}",
    "output": "Fix improved decoding of flag attributes in binary XML files"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -459,7 +459,7 @@ private void addEnumFields(ICodeWriter code) throws CodegenException {\n \t\t\t}\n \t\t\tif (f.getCls() != null) {\n \t\t\t\tcode.add(' ');\n-\t\t\t\tnew ClassGen(f.getCls(), this).addClassBody(code);\n+\t\t\t\tnew ClassGen(f.getCls(), this).addClassBody(code, true);\n \t\t\t}\n \t\t\tif (it.hasNext()) {\n \t\t\t\tcode.add(',');\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -71,7 +71,14 @@ public void init(RootNode root) {\n \n \t@Override\n \tpublic boolean visit(ClassNode cls) throws JadxException {\n-\t\tif (!convertToEnum(cls)) {\n+\t\tboolean converted;\n+\t\ttry {\n+\t\t\tconverted = convertToEnum(cls);\n+\t\t} catch (Exception e) {\n+\t\t\tcls.addWarnComment(\"Enum visitor error\", e);\n+\t\t\tconverted = false;\n+\t\t}\n+\t\tif (!converted) {\n \t\t\tAccessInfo accessFlags = cls.getAccessFlags();\n \t\t\tif (accessFlags.isEnum()) {\n \t\t\t\tcls.setAccessFlags(accessFlags.remove(AccessFlags.ENUM));\n@@ -179,8 +186,7 @@ private void processConstructorInsn(ClassNode cls, EnumField enumField, MethodNo\n \t\tif (!enumClsInfo.equals(cls.getClassInfo())) {\n \t\t\tClassNode enumCls = cls.root().resolveClass(enumClsInfo);\n \t\t\tif (enumCls != null) {\n-\t\t\t\tprocessEnumCls(enumField, enumCls);\n-\t\t\t\tcls.addInlinedClass(enumCls);\n+\t\t\t\tprocessEnumCls(cls, enumField, enumCls);\n \t\t\t}\n \t\t}\n \t\tList<RegisterArg> regs = new ArrayList<>();\n@@ -381,7 +387,11 @@ private EnumField createEnumFieldByConstructor(ClassNode cls, FieldNode enumFiel\n \t\tif (constrCls == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tif (!clsInfo.equals(cls.getClassInfo()) && !constrCls.getAccessFlags().isEnum()) {\n+\t\tif (constrCls.equals(cls)) {\n+\t\t\t// allow same class\n+\t\t} else if (constrCls.contains(AFlag.ANONYMOUS_CLASS)) {\n+\t\t\t// allow external class already marked as anonymous\n+\t\t} else {\n \t\t\treturn null;\n \t\t}\n \t\tMethodNode ctrMth = cls.root().resolveMethod(co.getCallMth());\n@@ -466,15 +476,19 @@ private boolean usesValuesField(MethodNode mth, FieldInfo valuesFieldInfo) {\n \t\treturn InsnUtils.searchInsn(mth, InsnType.SGET, insnTest) != null;\n \t}\n \n-\tprivate static void processEnumCls(EnumField field, ClassNode innerCls) {\n+\tprivate static void processEnumCls(ClassNode cls, EnumField field, ClassNode innerCls) {\n \t\t// remove constructor, because it is anonymous class\n \t\tfor (MethodNode innerMth : innerCls.getMethods()) {\n \t\t\tif (innerMth.getAccessFlags().isConstructor()) {\n \t\t\t\tinnerMth.add(AFlag.DONT_GENERATE);\n \t\t\t}\n \t\t}\n \t\tfield.setCls(innerCls);\n-\t\tinnerCls.add(AFlag.DONT_GENERATE);\n+\t\tif (!innerCls.getParentClass().equals(cls)) {\n+\t\t\t// not inner\n+\t\t\tcls.addInlinedClass(innerCls);\n+\t\t\tinnerCls.add(AFlag.DONT_GENERATE);\n+\t\t}\n \t}\n \n \tprivate ConstructorInsn getConstructorInsn(InsnNode insn) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n@@ -42,10 +42,7 @@ public boolean visit(ClassNode cls) throws JadxException {\n \t}\n \n \tprivate static void markAnonymousClass(ClassNode cls) {\n-\t\tboolean synthetic = cls.getAccessFlags().isSynthetic()\n-\t\t\t\t|| cls.getClassInfo().getShortName().contains(\"$\")\n-\t\t\t\t|| Character.isDigit(cls.getClassInfo().getShortName().charAt(0));\n-\t\tif (!synthetic) {\n+\t\tif (!canBeAnonymous(cls)) {\n \t\t\treturn;\n \t\t}\n \t\tMethodNode anonymousConstructor = checkUsage(cls);\n@@ -77,6 +74,22 @@ private static void markAnonymousClass(ClassNode cls) {\n \t\t}\n \t}\n \n+\tprivate static boolean canBeAnonymous(ClassNode cls) {\n+\t\tif (cls.getAccessFlags().isSynthetic()) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tString shortName = cls.getClassInfo().getShortName();\n+\t\tif (shortName.contains(\"$\") || Character.isDigit(shortName.charAt(0))) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (cls.getUseIn().size() == 1 && cls.getUseInMth().size() == 1) {\n+\t\t\tMethodNode useMth = cls.getUseInMth().get(0);\n+\t\t\t// allow use in enum class init\n+\t\t\treturn useMth.getMethodInfo().isClassInit() && useMth.getParentClass().isEnum();\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \t/**\n \t * Checks:\n \t * - class have only one constructor which used only once (allow common code for field init)\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java\n--- a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java\n@@ -52,19 +52,18 @@ public JadxCodeAssertions containsLines(int commonIndent, String... lines) {\n \t\t}\n \t\tString indent = TestUtils.indent(commonIndent);\n \t\tStringBuilder sb = new StringBuilder();\n-\t\tboolean first = true;\n \t\tfor (String line : lines) {\n-\t\t\tif (!line.isEmpty()) {\n-\t\t\t\tif (first) {\n-\t\t\t\t\tfirst = false;\n-\t\t\t\t} else {\n-\t\t\t\t\tsb.append(ICodeWriter.NL);\n-\t\t\t\t}\n-\t\t\t\tsb.append(indent);\n-\t\t\t\tsb.append(line);\n+\t\t\tsb.append(ICodeWriter.NL);\n+\t\t\tif (line.isEmpty()) {\n+\t\t\t\t// don't add common indent to empty lines\n+\t\t\t\tcontinue;\n \t\t\t}\n+\t\t\tString searchLine = indent + line;\n+\t\t\tsb.append(searchLine);\n+\t\t\t// check every line for easier debugging\n+\t\t\tcontains(searchLine);\n \t\t}\n-\t\treturn containsOnlyOnce(sb.toString());\n+\t\treturn containsOnlyOnce(sb.substring(ICodeWriter.NL.length()));\n \t}\n \n \tpublic JadxCodeAssertions removeBlockComments() {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums2.java b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums2.java\n@@ -2,11 +2,10 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.core.dex.nodes.ClassNode;\n+import jadx.api.CommentsLevel;\n import jadx.tests.api.IntegrationTest;\n-import jadx.tests.api.utils.JadxMatchers;\n \n-import static org.hamcrest.MatcherAssert.assertThat;\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n \n public class TestEnums2 extends IntegrationTest {\n \n@@ -32,25 +31,25 @@ public int apply(int x, int y) {\n \n \t@Test\n \tpublic void test() {\n-\t\tClassNode cls = getClassNode(TestCls.class);\n-\t\tString code = removeLineComments(cls);\n-\n-\t\tassertThat(code, JadxMatchers.containsLines(1,\n-\t\t\t\t\"public enum Operation {\",\n-\t\t\t\tindent(1) + \"PLUS {\",\n-\t\t\t\tindent(2) + \"@Override\",\n-\t\t\t\tindent(2) + \"public int apply(int x, int y) {\",\n-\t\t\t\tindent(3) + \"return x + y;\",\n-\t\t\t\tindent(2) + '}',\n-\t\t\t\tindent(1) + \"},\",\n-\t\t\t\tindent(1) + \"MINUS {\",\n-\t\t\t\tindent(2) + \"@Override\",\n-\t\t\t\tindent(2) + \"public int apply(int x, int y) {\",\n-\t\t\t\tindent(3) + \"return x - y;\",\n-\t\t\t\tindent(2) + '}',\n-\t\t\t\tindent(1) + \"};\",\n-\t\t\t\t\"\",\n-\t\t\t\tindent(1) + \"public abstract int apply(int i, int i2);\",\n-\t\t\t\t\"}\"));\n+\t\tgetArgs().setCommentsLevel(CommentsLevel.WARN);\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsLines(1,\n+\t\t\t\t\t\t\"public enum Operation {\",\n+\t\t\t\t\t\tindent(1) + \"PLUS {\",\n+\t\t\t\t\t\tindent(2) + \"@Override\",\n+\t\t\t\t\t\tindent(2) + \"public int apply(int x, int y) {\",\n+\t\t\t\t\t\tindent(3) + \"return x + y;\",\n+\t\t\t\t\t\tindent(2) + '}',\n+\t\t\t\t\t\tindent(1) + \"},\",\n+\t\t\t\t\t\tindent(1) + \"MINUS {\",\n+\t\t\t\t\t\tindent(2) + \"@Override\",\n+\t\t\t\t\t\tindent(2) + \"public int apply(int x, int y) {\",\n+\t\t\t\t\t\tindent(3) + \"return x - y;\",\n+\t\t\t\t\t\tindent(2) + '}',\n+\t\t\t\t\t\tindent(1) + \"};\",\n+\t\t\t\t\t\t\"\",\n+\t\t\t\t\t\tindent(1) + \"public abstract int apply(int i, int i2);\",\n+\t\t\t\t\t\t\"}\");\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsInterface.java b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsInterface.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsInterface.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsInterface.java\n@@ -2,11 +2,10 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.core.dex.nodes.ClassNode;\n+import jadx.api.CommentsLevel;\n import jadx.tests.api.IntegrationTest;\n-import jadx.tests.api.utils.JadxMatchers;\n \n-import static org.hamcrest.MatcherAssert.assertThat;\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n \n public class TestEnumsInterface extends IntegrationTest {\n \n@@ -34,23 +33,23 @@ public interface IOperation {\n \n \t@Test\n \tpublic void test() {\n-\t\tClassNode cls = getClassNode(TestCls.class);\n-\t\tString code = removeLineComments(cls);\n-\n-\t\tassertThat(code, JadxMatchers.containsLines(1,\n-\t\t\t\t\"public enum Operation implements IOperation {\",\n-\t\t\t\tindent(1) + \"PLUS {\",\n-\t\t\t\tindent(2) + \"@Override\",\n-\t\t\t\tindent(2) + \"public int apply(int x, int y) {\",\n-\t\t\t\tindent(3) + \"return x + y;\",\n-\t\t\t\tindent(2) + '}',\n-\t\t\t\tindent(1) + \"},\",\n-\t\t\t\tindent(1) + \"MINUS {\",\n-\t\t\t\tindent(2) + \"@Override\",\n-\t\t\t\tindent(2) + \"public int apply(int x, int y) {\",\n-\t\t\t\tindent(3) + \"return x - y;\",\n-\t\t\t\tindent(2) + '}',\n-\t\t\t\tindent(1) + '}',\n-\t\t\t\t\"}\"));\n+\t\tgetArgs().setCommentsLevel(CommentsLevel.WARN);\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsLines(1,\n+\t\t\t\t\t\t\"public enum Operation implements IOperation {\",\n+\t\t\t\t\t\tindent(1) + \"PLUS {\",\n+\t\t\t\t\t\tindent(2) + \"@Override\",\n+\t\t\t\t\t\tindent(2) + \"public int apply(int x, int y) {\",\n+\t\t\t\t\t\tindent(3) + \"return x + y;\",\n+\t\t\t\t\t\tindent(2) + '}',\n+\t\t\t\t\t\tindent(1) + \"},\",\n+\t\t\t\t\t\tindent(1) + \"MINUS {\",\n+\t\t\t\t\t\tindent(2) + \"@Override\",\n+\t\t\t\t\t\tindent(2) + \"public int apply(int x, int y) {\",\n+\t\t\t\t\t\tindent(3) + \"return x - y;\",\n+\t\t\t\t\t\tindent(2) + '}',\n+\t\t\t\t\t\tindent(1) + '}',\n+\t\t\t\t\t\t\"}\");\n \t}\n }",
    "output": "Fix correct inline for enums in `j$.time.temporal`"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n@@ -390,15 +390,23 @@ private static BlockNode getTopSplitterBlock(MethodNode mth, BlockNode top) {\n \tprivate static BlockNode searchTopBlock(MethodNode mth, List<BlockNode> blocks) {\n \t\tBlockNode top = BlockUtils.getTopBlock(blocks);\n \t\tif (top != null) {\n-\t\t\treturn top;\n+\t\t\treturn adjustTopBlock(top);\n \t\t}\n \t\tBlockNode topDom = BlockUtils.getCommonDominator(mth, blocks);\n \t\tif (topDom != null) {\n-\t\t\treturn topDom;\n+\t\t\treturn adjustTopBlock(topDom);\n \t\t}\n \t\tthrow new JadxRuntimeException(\"Failed to find top block for try-catch from: \" + blocks);\n \t}\n \n+\tprivate static BlockNode adjustTopBlock(BlockNode topBlock) {\n+\t\tif (topBlock.getSuccessors().size() == 1 && !topBlock.contains(AType.EXC_CATCH)) {\n+\t\t\t// top block can be lifted by other exception handlers included in blocks list, trying to undo that\n+\t\t\treturn topBlock.getSuccessors().get(0);\n+\t\t}\n+\t\treturn topBlock;\n+\t}\n+\n \t@Nullable\n \tprivate static BlockNode searchBottomBlock(MethodNode mth, List<BlockNode> blocks) {\n \t\t// search common post-dominator block inside input set\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n@@ -140,7 +140,7 @@ private static void renameVariables(MethodNode mth) {\n \t\tstack.push(initState);\n \t\twhile (!stack.isEmpty()) {\n \t\t\tRenameState state = stack.pop();\n-\t\t\trenameVarsInBlock(state);\n+\t\t\trenameVarsInBlock(mth, state);\n \t\t\tfor (BlockNode dominated : state.getBlock().getDominatesOn()) {\n \t\t\t\tstack.push(RenameState.copyFrom(state, dominated));\n \t\t\t}\n@@ -156,7 +156,7 @@ private static void initPhiInEnterBlock(RenameState initState) {\n \t\t}\n \t}\n \n-\tprivate static void renameVarsInBlock(RenameState state) {\n+\tprivate static void renameVarsInBlock(MethodNode mth, RenameState state) {\n \t\tBlockNode block = state.getBlock();\n \t\tfor (InsnNode insn : block.getInstructions()) {\n \t\t\tif (insn.getType() != InsnType.PHI) {\n@@ -168,8 +168,9 @@ private static void renameVarsInBlock(RenameState state) {\n \t\t\t\t\tint regNum = reg.getRegNum();\n \t\t\t\t\tSSAVar var = state.getVar(regNum);\n \t\t\t\t\tif (var == null) {\n-\t\t\t\t\t\tthrow new JadxRuntimeException(\"Not initialized variable reg: \" + regNum\n-\t\t\t\t\t\t\t\t+ \", insn: \" + insn + \", block:\" + block);\n+\t\t\t\t\t\t// TODO: in most cases issue in incorrectly attached exception handlers\n+\t\t\t\t\t\tmth.addWarnComment(\"Not initialized variable reg: \" + regNum + \", insn: \" + insn + \", block:\" + block);\n+\t\t\t\t\t\tvar = state.startVar(reg);\n \t\t\t\t\t}\n \t\t\t\t\tvar.use(reg);\n \t\t\t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally8.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally8.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally8.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally8.java\n@@ -55,7 +55,6 @@ public void test() {\n \t}\n \n \t@Test\n-\t@NotYetImplemented\n \tpublic void test2() {\n \t\tdisableCompilation();\n \t\tClassNode cls = getClassNode(TestCls.class);",
    "output": "Fix improve exception handlers attach"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -172,7 +172,7 @@ private String lit(LiteralArg arg) {\n \n \tprivate void instanceField(ICodeWriter code, FieldInfo field, InsnArg arg) throws CodegenException {\n \t\tClassNode pCls = mth.getParentClass();\n-\t\tFieldNode fieldNode = pCls.root().deepResolveField(field);\n+\t\tFieldNode fieldNode = pCls.root().resolveField(field);\n \t\tif (fieldNode != null) {\n \t\t\tFieldReplaceAttr replace = fieldNode.get(AType.FIELD_REPLACE);\n \t\t\tif (replace != null) {\n@@ -210,7 +210,7 @@ public static void makeStaticFieldAccess(ICodeWriter code, FieldInfo field, Clas\n \t\t\t}\n \t\t\tcode.add('.');\n \t\t}\n-\t\tFieldNode fieldNode = clsGen.getClassNode().root().deepResolveField(field);\n+\t\tFieldNode fieldNode = clsGen.getClassNode().root().resolveField(field);\n \t\tif (fieldNode != null) {\n \t\t\tcode.attachAnnotation(fieldNode);\n \t\t}\n@@ -764,7 +764,7 @@ private void makeInvoke(InvokeNode insn, ICodeWriter code) throws CodegenExcepti\n \t\t\treturn;\n \t\t}\n \t\tMethodInfo callMth = insn.getCallMth();\n-\t\tMethodNode callMthNode = mth.root().deepResolveMethod(callMth);\n+\t\tMethodNode callMthNode = mth.root().resolveMethod(callMth);\n \n \t\tint k = 0;\n \t\tswitch (type) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -378,15 +378,6 @@ public List<ClassNode> searchClassByShortName(String shortName) {\n \n \t@Nullable\n \tpublic MethodNode resolveMethod(@NotNull MethodInfo mth) {\n-\t\tClassNode cls = resolveClass(mth.getDeclClass());\n-\t\tif (cls != null) {\n-\t\t\treturn cls.searchMethod(mth);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t@Nullable\n-\tpublic MethodNode deepResolveMethod(@NotNull MethodInfo mth) {\n \t\tClassNode cls = resolveClass(mth.getDeclClass());\n \t\tif (cls == null) {\n \t\t\treturn null;\n@@ -430,19 +421,14 @@ private MethodNode deepResolveMethod(@NotNull ClassNode cls, String signature) {\n \n \t@Nullable\n \tpublic FieldNode resolveField(FieldInfo field) {\n-\t\tClassNode cls = resolveClass(field.getDeclClass());\n-\t\tif (cls != null) {\n-\t\t\treturn cls.searchField(field);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t@Nullable\n-\tpublic FieldNode deepResolveField(@NotNull FieldInfo field) {\n \t\tClassNode cls = resolveClass(field.getDeclClass());\n \t\tif (cls == null) {\n \t\t\treturn null;\n \t\t}\n+\t\tFieldNode fieldNode = cls.searchField(field);\n+\t\tif (fieldNode != null) {\n+\t\t\treturn fieldNode;\n+\t\t}\n \t\treturn deepResolveField(cls, field);\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java\n@@ -38,7 +38,7 @@ public IMethodDetails getMethodDetails(BaseInvokeNode invokeNode) {\n \n \t@Nullable\n \tpublic IMethodDetails getMethodDetails(MethodInfo callMth) {\n-\t\tMethodNode mthNode = root.deepResolveMethod(callMth);\n+\t\tMethodNode mthNode = root.resolveMethod(callMth);\n \t\tif (mthNode != null) {\n \t\t\treturn mthNode;\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n@@ -244,7 +244,7 @@ private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {\n \t\t\treturn false;\n \t\t}\n \t\tMethodInfo callMth = invokeInsn.getCallMth();\n-\t\tMethodNode wrappedMth = mth.root().deepResolveMethod(callMth);\n+\t\tMethodNode wrappedMth = mth.root().resolveMethod(callMth);\n \t\tif (wrappedMth == null) {\n \t\t\treturn false;\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n@@ -106,7 +106,7 @@ private static boolean fixVisibilityOfInlineCode(MethodNode mth, InsnNode insn)\n \t\tInsnType insnType = insn.getType();\n \t\tif (insnType == InsnType.INVOKE) {\n \t\t\tInvokeNode invoke = (InvokeNode) insn;\n-\t\t\tMethodNode callMthNode = mth.root().deepResolveMethod(invoke.getCallMth());\n+\t\t\tMethodNode callMthNode = mth.root().resolveMethod(invoke.getCallMth());\n \t\t\tif (callMthNode != null) {\n \t\t\t\tFixAccessModifiers.changeVisibility(callMthNode, newVisFlag);\n \t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/InsnUtils.java b/jadx-core/src/main/java/jadx/core/utils/InsnUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/InsnUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/InsnUtils.java\n@@ -96,7 +96,7 @@ public static Object getConstValueByInsn(RootNode root, InsnNode insn) {\n \t\t\t\treturn ((ConstClassNode) insn).getClsType();\n \t\t\tcase SGET:\n \t\t\t\tFieldInfo f = (FieldInfo) ((IndexInsnNode) insn).getIndex();\n-\t\t\t\tFieldNode fieldNode = root.deepResolveField(f);\n+\t\t\t\tFieldNode fieldNode = root.resolveField(f);\n \t\t\t\tif (fieldNode == null) {\n \t\t\t\t\tLOG.warn(\"Field {} not found\", f);\n \t\t\t\t\treturn null;",
    "output": "Fix always use deep resolve for fields and methods"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -537,14 +537,18 @@ private void addInnerType(ICodeWriter code, ArgType baseType) {\n \t\tArgType innerType = baseType.getInnerType();\n \t\tArgType outerType = innerType.getOuterType();\n \t\tif (outerType != null) {\n-\t\t\tuseClass(code, outerType);\n+\t\t\tuseClassWithShortName(code, baseType, outerType);\n \t\t\tcode.add('.');\n \t\t\taddInnerType(code, innerType);\n \t\t\treturn;\n \t\t}\n+\t\tuseClassWithShortName(code, baseType, innerType);\n+\t}\n+\n+\tprivate void useClassWithShortName(ICodeWriter code, ArgType baseType, ArgType type) {\n \t\tString fullNameObj;\n-\t\tif (innerType.getObject().contains(\".\")) {\n-\t\t\tfullNameObj = innerType.getObject();\n+\t\tif (type.getObject().contains(\".\")) {\n+\t\t\tfullNameObj = type.getObject();\n \t\t} else {\n \t\t\tfullNameObj = baseType.getObject();\n \t\t}\n@@ -554,7 +558,7 @@ private void addInnerType(ICodeWriter code, ArgType baseType) {\n \t\t\tcode.attachAnnotation(classNode);\n \t\t}\n \t\tcode.add(classInfo.getAliasShortName());\n-\t\taddGenerics(code, innerType);\n+\t\taddGenerics(code, type);\n \t}\n \n \tprivate void addGenerics(ICodeWriter code, ArgType type) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestGenericsInFullInnerCls.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestGenericsInFullInnerCls.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestGenericsInFullInnerCls.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestGenericsInFullInnerCls.java\n@@ -40,4 +40,12 @@ public void testWithDeobf() {\n \t\tloadFromSmaliFiles();\n \t\t// compilation should pass\n \t}\n+\n+\t@Test\n+\tpublic void testWithFullNames() {\n+\t\tgetArgs().setUseImports(false);\n+\t\tgetArgs().setCommentsLevel(CommentsLevel.WARN);\n+\t\tloadFromSmaliFiles();\n+\t\t// compilation should pass\n+\t}\n }",
    "output": "Fix correct use of class names for inner types"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -238,10 +238,11 @@ private void addMethodArguments(ICodeWriter code, List<RegisterArg> args) {\n \t\t\t\tclassGen.useType(code, argType);\n \t\t\t}\n \t\t\tcode.add(' ');\n-\t\t\tif (code.isMetadataSupported() && ssaVar != null) {\n+\t\t\tString varName = nameGen.assignArg(var);\n+\t\t\tif (code.isMetadataSupported() && ssaVar != null /* for fallback mode */) {\n \t\t\t\tcode.attachDefinition(VarDeclareRef.get(mth, var));\n \t\t\t}\n-\t\t\tcode.add(nameGen.assignArg(var));\n+\t\t\tcode.add(varName);\n \n \t\t\ti++;\n \t\t\tif (it.hasNext()) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -99,9 +99,6 @@ private MethodNode(ClassNode classNode, IMethodData mthData) {\n \t@Override\n \tpublic void unload() {\n \t\tloaded = false;\n-\t\tif (noCode) {\n-\t\t\treturn;\n-\t\t}\n \t\t// don't unload retType, argTypes, typeParameters\n \t\tthisArg = null;\n \t\targsList = null;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java b/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java\n@@ -26,9 +26,6 @@ public class InitCodeVariables extends AbstractVisitor {\n \n \t@Override\n \tpublic void visit(MethodNode mth) throws JadxException {\n-\t\tif (mth.isNoCode()) {\n-\t\t\treturn;\n-\t\t}\n \t\tinitCodeVars(mth);\n \t}\n \n@@ -42,16 +39,24 @@ public static void rerun(MethodNode mth) {\n \tprivate static void initCodeVars(MethodNode mth) {\n \t\tRegisterArg thisArg = mth.getThisArg();\n \t\tif (thisArg != null) {\n-\t\t\tinitCodeVar(thisArg.getSVar());\n+\t\t\tinitCodeVar(mth, thisArg);\n \t\t}\n \t\tfor (RegisterArg mthArg : mth.getArgRegs()) {\n-\t\t\tinitCodeVar(mthArg.getSVar());\n+\t\t\tinitCodeVar(mth, mthArg);\n \t\t}\n \t\tfor (SSAVar ssaVar : mth.getSVars()) {\n \t\t\tinitCodeVar(ssaVar);\n \t\t}\n \t}\n \n+\tpublic static void initCodeVar(MethodNode mth, RegisterArg regArg) {\n+\t\tSSAVar ssaVar = regArg.getSVar();\n+\t\tif (ssaVar == null) {\n+\t\t\tssaVar = mth.makeNewSVar(regArg);\n+\t\t}\n+\t\tinitCodeVar(ssaVar);\n+\t}\n+\n \tpublic static void initCodeVar(SSAVar ssaVar) {\n \t\tif (ssaVar.isCodeVarSet()) {\n \t\t\treturn;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesDeclAnnotation.java b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesDeclAnnotation.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesDeclAnnotation.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesDeclAnnotation.java\n@@ -0,0 +1,52 @@\n+package jadx.tests.integration.variables;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.api.data.annotations.VarDeclareRef;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.core.dex.nodes.MethodNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestVariablesDeclAnnotation extends IntegrationTest {\n+\n+\tpublic abstract static class TestCls {\n+\t\tpublic int test(String str, int i) {\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\tpublic abstract int test2(String str);\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tassertThat(cls).code()\n+\t\t\t\t.containsOne(\"public int test(String str, int i) {\")\n+\t\t\t\t.containsOne(\"public abstract int test2(String str);\");\n+\n+\t\tcheckArgNamesInMethod(cls, \"test\", \"[str, i]\");\n+\t\tcheckArgNamesInMethod(cls, \"test2\", \"[str]\");\n+\t}\n+\n+\tprivate static void checkArgNamesInMethod(ClassNode cls, String mthName, String expectedVars) {\n+\t\tMethodNode testMth = cls.searchMethodByShortName(mthName);\n+\t\tassertThat(testMth).isNotNull();\n+\n+\t\tint mthLine = testMth.getDecompiledLine();\n+\t\tList<String> argNames = cls.getCode().getAnnotations().entrySet().stream()\n+\t\t\t\t.filter(e -> e.getKey().getLine() == mthLine && e.getValue() instanceof VarDeclareRef)\n+\t\t\t\t.sorted(Comparator.comparingInt(e -> e.getKey().getPos()))\n+\t\t\t\t.map(e -> ((VarDeclareRef) e.getValue()).getName())\n+\t\t\t\t.collect(Collectors.toList());\n+\n+\t\tassertThat(argNames).doesNotContainNull();\n+\t\tassertThat(argNames.toString()).isEqualTo(expectedVars);\n+\t}\n+}",
    "output": "Fix correct method arg name if unused"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n@@ -5,6 +5,7 @@\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.regex.Pattern;\n \n import org.jetbrains.annotations.Nullable;\n \n@@ -25,6 +26,7 @@\n import jadx.core.dex.visitors.AbstractVisitor;\n \n public class RenameVisitor extends AbstractVisitor {\n+\tprivate static final Pattern ANONYMOUS_CLASS_PATTERN = Pattern.compile(\"^\\\\d+$\");\n \n \t@Override\n \tpublic void init(RootNode root) {\n@@ -130,11 +132,12 @@ private static void checkPackage(Deobfuscator deobfuscator, ClassNode cls, Class\n \tprivate static String fixClsShortName(JadxArgs args, String clsName) {\n \t\tboolean renameValid = args.isRenameValid();\n \t\tif (renameValid) {\n-\t\t\tchar firstChar = clsName.charAt(0);\n-\t\t\tif (Character.isDigit(firstChar)) {\n+\t\t\tif (ANONYMOUS_CLASS_PATTERN.matcher(clsName).matches()) {\n \t\t\t\treturn Consts.ANONYMOUS_CLASS_PREFIX + NameMapper.removeInvalidCharsMiddle(clsName);\n \t\t\t}\n-\t\t\tif (firstChar == '$') {\n+\n+\t\t\tchar firstChar = clsName.charAt(0);\n+\t\t\tif (firstChar == '$' || Character.isDigit(firstChar)) {\n \t\t\t\treturn 'C' + NameMapper.removeInvalidCharsMiddle(clsName);\n \t\t\t}\n \t\t}",
    "output": "Fix rename classes as anonymous only if they are a number"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -112,16 +112,25 @@ private void fillDeobfPresets() {\n \t\t\t\tdeobfPresets.getPkgPresetMap().put(p.getName(), p.getAlias());\n \t\t\t}\n \t\t}\n-\t\tfor (DeobfClsInfo deobfClsInfo : clsMap.values()) {\n-\t\t\tif (deobfClsInfo.getAlias() != null) {\n-\t\t\t\tdeobfPresets.getClsPresetMap().put(deobfClsInfo.getCls().getClassInfo().makeRawFullName(), deobfClsInfo.getAlias());\n+\t\tfor (ClassNode cls : root.getClasses()) {\n+\t\t\tClassInfo classInfo = cls.getClassInfo();\n+\t\t\tif (classInfo.hasAlias()) {\n+\t\t\t\tdeobfPresets.getClsPresetMap().put(classInfo.makeRawFullName(), classInfo.getAliasShortName());\n+\t\t\t}\n+\n+\t\t\tfor (FieldNode fld : cls.getFields()) {\n+\t\t\t\tFieldInfo fieldInfo = fld.getFieldInfo();\n+\t\t\t\tif (fieldInfo.hasAlias()) {\n+\t\t\t\t\tdeobfPresets.getFldPresetMap().put(fieldInfo.getRawFullId(), fld.getAlias());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfor (MethodNode mth : cls.getMethods()) {\n+\t\t\t\tMethodInfo methodInfo = mth.getMethodInfo();\n+\t\t\t\tif (methodInfo.hasAlias()) {\n+\t\t\t\t\tdeobfPresets.getFldPresetMap().put(methodInfo.getRawFullId(), methodInfo.getAlias());\n+\t\t\t\t}\n \t\t\t}\n-\t\t}\n-\t\tfor (FieldInfo fld : fldMap.keySet()) {\n-\t\t\tdeobfPresets.getFldPresetMap().put(fld.getRawFullId(), fld.getAlias());\n-\t\t}\n-\t\tfor (MethodInfo mth : mthMap.keySet()) {\n-\t\t\tdeobfPresets.getMthPresetMap().put(mth.getRawFullId(), mth.getAlias());\n \t\t}\n \t}",
    "output": "Fix collect missing renames for `.jobf` file"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n@@ -7,6 +7,7 @@\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.List;\n+import java.util.stream.Collectors;\n \n import javax.swing.BorderFactory;\n import javax.swing.JLabel;\n@@ -17,9 +18,12 @@\n import jadx.api.CodePosition;\n import jadx.api.ICodeWriter;\n import jadx.api.JavaClass;\n+import jadx.api.JavaMethod;\n import jadx.api.JavaNode;\n+import jadx.core.dex.attributes.AType;\n import jadx.gui.jobs.TaskStatus;\n import jadx.gui.treemodel.CodeNode;\n+import jadx.gui.treemodel.JMethod;\n import jadx.gui.treemodel.JNode;\n import jadx.gui.ui.MainWindow;\n import jadx.gui.utils.CodeLinesInfo;\n@@ -59,32 +63,55 @@ protected void openInit() {\n \n \tprivate void collectUsageData() {\n \t\tusageList = new ArrayList<>();\n-\t\tnode.getJavaNode().getUseIn()\n+\t\tgetMethodUseIn()\n \t\t\t\t.stream()\n \t\t\t\t.map(JavaNode::getTopParentClass)\n \t\t\t\t.distinct()\n \t\t\t\t.sorted(Comparator.comparing(JavaClass::getFullName))\n \t\t\t\t.forEach(this::processUsageClass);\n \t}\n \n-\tprivate void processUsageClass(JavaClass cls) {\n+\tprivate List<JavaNode> getMethodUseIn() {\n+\t\tif (node instanceof JMethod) {\n+\t\t\tJavaMethod method = ((JMethod) node).getJavaMethod();\n+\t\t\tif (null != method.getMethodNode().get(AType.METHOD_OVERRIDE)) {\n+\t\t\t\treturn method.getOverrideRelatedMethods().stream().flatMap(m -> m.getUseIn().stream()).collect(Collectors.toList());\n+\t\t\t}\n+\t\t}\n+\t\treturn node.getJavaNode().getUseIn();\n+\t}\n+\n+\tprivate void processUsageClass(JavaNode usageNode) {\n+\t\tJavaClass cls = usageNode.getTopParentClass();\n \t\tString code = cls.getCodeInfo().getCodeStr();\n \t\tCodeLinesInfo linesInfo = new CodeLinesInfo(cls);\n-\t\tJavaNode javaNode = node.getJavaNode();\n-\t\tList<CodePosition> usage = cls.getUsageFor(javaNode);\n-\t\tfor (CodePosition pos : usage) {\n-\t\t\tif (javaNode.getTopParentClass().equals(cls) && pos.getPos() == javaNode.getDefPos()) {\n-\t\t\t\t// skip declaration\n-\t\t\t\tcontinue;\n+\t\tList<? extends JavaNode> targetNodes = getMethodWithOverride();\n+\t\tfor (JavaNode javaNode : targetNodes) {\n+\t\t\tList<CodePosition> usage = cls.getUsageFor(javaNode);\n+\t\t\tfor (CodePosition pos : usage) {\n+\t\t\t\tif (javaNode.getTopParentClass().equals(cls) && pos.getPos() == javaNode.getDefPos()) {\n+\t\t\t\t\t// skip declaration\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tStringRef line = getLineStrAt(code, pos.getPos());\n+\t\t\t\tif (line.startsWith(\"import \")) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tJavaNode javaNodeByLine = linesInfo.getJavaNodeByLine(pos.getLine());\n+\t\t\t\tJNode useAtNode = javaNodeByLine == null ? node : getNodeCache().makeFrom(javaNodeByLine);\n+\t\t\t\tusageList.add(new CodeNode(useAtNode, line, pos.getLine(), pos.getPos()));\n \t\t\t}\n-\t\t\tStringRef line = getLineStrAt(code, pos.getPos());\n-\t\t\tif (line.startsWith(\"import \")) {\n-\t\t\t\tcontinue;\n+\t\t}\n+\t}\n+\n+\tprivate List<? extends JavaNode> getMethodWithOverride() {\n+\t\tif (node instanceof JMethod) {\n+\t\t\tJavaMethod method = ((JMethod) node).getJavaMethod();\n+\t\t\tif (null != method.getMethodNode().get(AType.METHOD_OVERRIDE)) {\n+\t\t\t\treturn method.getOverrideRelatedMethods();\n \t\t\t}\n-\t\t\tJavaNode javaNodeByLine = linesInfo.getJavaNodeByLine(pos.getLine());\n-\t\t\tJNode useAtNode = javaNodeByLine == null ? node : getNodeCache().makeFrom(javaNodeByLine);\n-\t\t\tusageList.add(new CodeNode(useAtNode, line, pos.getLine(), pos.getPos()));\n \t\t}\n+\t\treturn Collections.singletonList(node.getJavaNode());\n \t}\n \n \tprivate StringRef getLineStrAt(String code, int pos) {",
    "output": "Fix find usage for overridden methods"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java b/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n--- a/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n+++ b/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n@@ -8,7 +8,6 @@\n import java.util.Set;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -24,6 +23,7 @@\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.core.utils.files.FileUtils;\n import jadx.core.xmlgen.ResContainer;\n+import jadx.core.xmlgen.XmlSecurity;\n \n public class ExportGradleProject {\n \n@@ -139,7 +139,7 @@ private ApplicationParams getApplicationParams(Document androidManifest, Documen\n \n \tprivate Document parseXml(String xmlContent) {\n \t\ttry {\n-\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder builder = XmlSecurity.getSecureDbf().newDocumentBuilder();\n \t\t\tDocument document = builder.parse(new InputSource(new StringReader(xmlContent)));\n \n \t\t\tdocument.getDocumentElement().normalize();",
    "output": "Use secure xml parser for process manifest"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n@@ -655,7 +655,7 @@ public static boolean isCastNeeded(RootNode root, ArgType from, ArgType to) {\n \t\tif (from.equals(to)) {\n \t\t\treturn false;\n \t\t}\n-\t\tTypeCompareEnum result = root.getTypeUpdate().getTypeCompare().compareTypes(from, to);\n+\t\tTypeCompareEnum result = root.getTypeCompare().compareTypes(from, to);\n \t\treturn !result.isNarrow();\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -38,6 +38,7 @@\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.regions.conditions.IfCondition;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n+import jadx.core.dex.visitors.typeinference.TypeCompareEnum;\n import jadx.core.utils.BlockUtils;\n import jadx.core.utils.InsnList;\n import jadx.core.utils.InsnRemover;\n@@ -82,7 +83,7 @@ private boolean simplifyBlock(MethodNode mth, BlockNode block) {\n \t\tfor (int i = 0; i < list.size(); i++) {\n \t\t\tInsnNode insn = list.get(i);\n \t\t\tint insnCount = list.size();\n-\t\t\tInsnNode modInsn = simplifyInsn(mth, insn);\n+\t\t\tInsnNode modInsn = simplifyInsn(mth, insn, null);\n \t\t\tif (modInsn != null) {\n \t\t\t\tmodInsn.rebindArgs();\n \t\t\t\tif (i < list.size() && list.get(i) == insn) {\n@@ -110,7 +111,7 @@ private void simplifyArgs(MethodNode mth, InsnNode insn) {\n \t\tfor (InsnArg arg : insn.getArguments()) {\n \t\t\tif (arg.isInsnWrap()) {\n \t\t\t\tInsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();\n-\t\t\t\tInsnNode replaceInsn = simplifyInsn(mth, wrapInsn);\n+\t\t\t\tInsnNode replaceInsn = simplifyInsn(mth, wrapInsn, insn);\n \t\t\t\tif (replaceInsn != null) {\n \t\t\t\t\targ.wrapInstruction(mth, replaceInsn);\n \t\t\t\t\tInsnRemover.unbindInsn(mth, wrapInsn);\n@@ -123,7 +124,7 @@ private void simplifyArgs(MethodNode mth, InsnNode insn) {\n \t\t}\n \t}\n \n-\tprivate InsnNode simplifyInsn(MethodNode mth, InsnNode insn) {\n+\tprivate InsnNode simplifyInsn(MethodNode mth, InsnNode insn, @Nullable InsnNode parentInsn) {\n \t\tif (insn.contains(AFlag.DONT_GENERATE)) {\n \t\t\treturn null;\n \t\t}\n@@ -146,8 +147,9 @@ private InsnNode simplifyInsn(MethodNode mth, InsnNode insn) {\n \t\t\tcase SPUT:\n \t\t\t\treturn convertFieldArith(mth, insn);\n \n+\t\t\tcase CAST:\n \t\t\tcase CHECK_CAST:\n-\t\t\t\treturn processCast(mth, (IndexInsnNode) insn);\n+\t\t\t\treturn processCast(mth, (IndexInsnNode) insn, parentInsn);\n \n \t\t\tcase MOVE:\n \t\t\t\tInsnArg firstArg = insn.getArg(0);\n@@ -212,7 +214,7 @@ private InsnNode simplifyStringConstructor(MethodNode mth, ConstructorInsn insn)\n \t\treturn null;\n \t}\n \n-\tprivate static InsnNode processCast(MethodNode mth, IndexInsnNode castInsn) {\n+\tprivate static InsnNode processCast(MethodNode mth, IndexInsnNode castInsn, @Nullable InsnNode parentInsn) {\n \t\tif (castInsn.contains(AFlag.EXPLICIT_CAST)) {\n \t\t\treturn null;\n \t\t}\n@@ -229,7 +231,8 @@ private static InsnNode processCast(MethodNode mth, IndexInsnNode castInsn) {\n \n \t\tArgType castToType = (ArgType) castInsn.getIndex();\n \t\tif (!ArgType.isCastNeeded(mth.root(), argType, castToType)\n-\t\t\t\t|| isCastDuplicate(castInsn)) {\n+\t\t\t\t|| isCastDuplicate(castInsn)\n+\t\t\t\t|| shadowedByOuterCast(mth.root(), castToType, parentInsn)) {\n \t\t\tInsnNode insnNode = new InsnNode(InsnType.MOVE, 1);\n \t\t\tinsnNode.setOffset(castInsn.getOffset());\n \t\t\tinsnNode.setResult(castInsn.getResult());\n@@ -254,6 +257,15 @@ private static boolean isCastDuplicate(IndexInsnNode castInsn) {\n \t\treturn false;\n \t}\n \n+\tprivate static boolean shadowedByOuterCast(RootNode root, ArgType castType, @Nullable InsnNode parentInsn) {\n+\t\tif (parentInsn != null && parentInsn.getType() == InsnType.CAST) {\n+\t\t\tArgType parentCastType = (ArgType) ((IndexInsnNode) parentInsn).getIndex();\n+\t\t\tTypeCompareEnum result = root.getTypeCompare().compareTypes(parentCastType, castType);\n+\t\t\treturn result.isNarrow();\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \t/**\n \t * Simplify 'cmp' instruction in if condition\n \t */\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n@@ -98,13 +98,21 @@ public TypeCompareEnum compareTypes(ArgType first, ArgType second) {\n \t\t\t\t\t|| secondPrimitiveType == PrimitiveType.BOOLEAN) {\n \t\t\t\treturn CONFLICT;\n \t\t\t}\n+\t\t\tif (swapEquals(firstPrimitiveType, secondPrimitiveType, PrimitiveType.CHAR, PrimitiveType.BYTE)\n+\t\t\t\t\t|| swapEquals(firstPrimitiveType, secondPrimitiveType, PrimitiveType.CHAR, PrimitiveType.SHORT)) {\n+\t\t\t\treturn CONFLICT;\n+\t\t\t}\n \t\t\treturn firstPrimitiveType.compareTo(secondPrimitiveType) > 0 ? WIDER : NARROW;\n \t\t}\n \n \t\tLOG.warn(\"Type compare function not complete, can't compare {} and {}\", first, second);\n \t\treturn TypeCompareEnum.CONFLICT;\n \t}\n \n+\tprivate boolean swapEquals(PrimitiveType first, PrimitiveType second, PrimitiveType a, PrimitiveType b) {\n+\t\treturn (first == a && second == b) || (first == b && second == a);\n+\t}\n+\n \tprivate TypeCompareEnum compareArrayWithOtherType(ArgType array, ArgType other) {\n \t\tif (!other.isTypeKnown()) {\n \t\t\tif (other.contains(PrimitiveType.ARRAY)) {\n\ndiff --git a/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java b/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n--- a/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n+++ b/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n@@ -63,10 +63,15 @@ public void compareTypes() {\n \tpublic void comparePrimitives() {\n \t\tcheck(INT, UNKNOWN_OBJECT, TypeCompareEnum.CONFLICT);\n \t\tcheck(INT, OBJECT, TypeCompareEnum.CONFLICT);\n-\t\tcheck(INT, BOOLEAN, TypeCompareEnum.CONFLICT);\n+\n \t\tcheck(INT, CHAR, TypeCompareEnum.WIDER);\n \t\tcheck(INT, SHORT, TypeCompareEnum.WIDER);\n \n+\t\tcheck(BOOLEAN, INT, TypeCompareEnum.CONFLICT);\n+\t\tcheck(BOOLEAN, CHAR, TypeCompareEnum.CONFLICT);\n+\t\tcheck(CHAR, BYTE, TypeCompareEnum.CONFLICT);\n+\t\tcheck(CHAR, SHORT, TypeCompareEnum.CONFLICT);\n+\n \t\tfirstIsNarrow(CHAR, NARROW_INTEGRAL);\n \t\tfirstIsNarrow(array(CHAR), UNKNOWN_OBJECT);\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inline/TestInline2.java b/jadx-core/src/test/java/jadx/tests/integration/inline/TestInline2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inline/TestInline2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inline/TestInline2.java\n@@ -31,6 +31,6 @@ public void test() {\n \n \t\tassertThat(code, containsOne(\"int[] a = {1, 2, 4, 6, 8};\"));\n \t\tassertThat(code, containsOne(\"for (int i = 0; i < a.length; i += 2) {\"));\n-\t\tassertThat(code, containsOne(\"for (long i2 = (long) b; i2 > 0; i2--) {\"));\n+\t\tassertThat(code, containsOne(\"for (long i2 = b; i2 > 0; i2--) {\"));\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestPrimitiveCasts.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestPrimitiveCasts.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestPrimitiveCasts.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestPrimitiveCasts.java\n@@ -17,16 +17,24 @@ public void test() {\n \t\t\tuseByte((byte) getInt());\n \t\t\tuseChar((char) 0);\n \t\t\tuseChar((char) getInt());\n+\n \t\t\tuseShort((short) 0L);\n \t\t\tuseShort((short) getLong());\n \t\t\tuseByte((byte) 0L);\n \t\t\tuseByte((byte) getLong());\n \t\t\tuseChar((char) 0L);\n \t\t\tuseChar((char) getLong());\n+\n \t\t\tuseShort((short) ' ');\n \t\t\tuseShort((short) getChar());\n \t\t\tuseByte((byte) ' ');\n \t\t\tuseByte((byte) getChar());\n+\n+\t\t\tuseInt((byte) 7);\n+\t\t\tuseInt((char) ' ');\n+\t\t\tuseInt(getChar());\n+\t\t\tuseInt((int) 2L);\n+\t\t\tuseInt((int) getLong());\n \t\t}\n \n \t\tprivate long getLong() {\n@@ -49,13 +57,17 @@ private void useByte(byte b) {\n \n \t\tprivate void useShort(short s) {\n \t\t}\n+\n+\t\tprivate void useInt(int i) {\n+\t\t}\n \t}\n \n \t@TestWithProfiles({ TestProfile.DX_J8, TestProfile.JAVA8 })\n \tpublic void test() {\n \t\tnoDebugInfo();\n \t\tassertThat(getClassNode(TestCls.class))\n \t\t\t\t.code()\n-\t\t\t\t.doesNotContain(\"(0)\");\n+\t\t\t\t.doesNotContain(\"(0)\")\n+\t\t\t\t.doesNotContain(\") ((int) getLong())\");\n \t}\n }",
    "output": "Fix simplify cascading casts"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java\n@@ -1,5 +1,7 @@\n package jadx.core.dex.instructions.args;\n \n+import org.jetbrains.annotations.Nullable;\n+\n import jadx.core.codegen.TypeGen;\n import jadx.core.utils.StringUtils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n@@ -57,12 +59,48 @@ public boolean isLiteral() {\n \t}\n \n \tpublic boolean isInteger() {\n-\t\tPrimitiveType type = this.type.getPrimitiveType();\n-\t\treturn type == PrimitiveType.INT\n-\t\t\t\t|| type == PrimitiveType.BYTE\n-\t\t\t\t|| type == PrimitiveType.CHAR\n-\t\t\t\t|| type == PrimitiveType.SHORT\n-\t\t\t\t|| type == PrimitiveType.LONG;\n+\t\tswitch (type.getPrimitiveType()) {\n+\t\t\tcase INT:\n+\t\t\tcase BYTE:\n+\t\t\tcase CHAR:\n+\t\t\tcase SHORT:\n+\t\t\tcase LONG:\n+\t\t\t\treturn true;\n+\t\t\tdefault:\n+\t\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tpublic boolean isNegative() {\n+\t\tif (isInteger()) {\n+\t\t\treturn literal < 0;\n+\t\t}\n+\t\tif (type == ArgType.FLOAT) {\n+\t\t\tfloat val = Float.intBitsToFloat(((int) literal));\n+\t\t\treturn val < 0 && Float.isFinite(val);\n+\t\t}\n+\t\tif (type == ArgType.DOUBLE) {\n+\t\t\tdouble val = Double.longBitsToDouble(literal);\n+\t\t\treturn val < 0 && Double.isFinite(val);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t@Nullable\n+\tpublic LiteralArg negate() {\n+\t\tlong neg;\n+\t\tif (isInteger()) {\n+\t\t\tneg = -literal;\n+\t\t} else if (type == ArgType.FLOAT) {\n+\t\t\tfloat val = Float.intBitsToFloat(((int) literal));\n+\t\t\tneg = Float.floatToIntBits(-val);\n+\t\t} else if (type == ArgType.DOUBLE) {\n+\t\t\tdouble val = Double.longBitsToDouble(literal);\n+\t\t\tneg = Double.doubleToLongBits(-val);\n+\t\t} else {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn new LiteralArg(neg, type);\n \t}\n \n \t@Override\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -532,32 +532,44 @@ private static InsnNode simplifyArith(ArithNode arith) {\n \t\tif (arith.getArgsCount() != 2) {\n \t\t\treturn null;\n \t\t}\n-\t\tInsnArg litArg = null;\n+\t\tLiteralArg litArg = null;\n \t\tInsnArg secondArg = arith.getArg(1);\n \t\tif (secondArg.isInsnWrap()) {\n \t\t\tInsnNode wr = ((InsnWrapArg) secondArg).getWrapInsn();\n \t\t\tif (wr.getType() == InsnType.CONST) {\n-\t\t\t\tlitArg = wr.getArg(0);\n+\t\t\t\tInsnArg arg = wr.getArg(0);\n+\t\t\t\tif (arg.isLiteral()) {\n+\t\t\t\t\tlitArg = (LiteralArg) arg;\n+\t\t\t\t}\n \t\t\t}\n \t\t} else if (secondArg.isLiteral()) {\n-\t\t\tlitArg = secondArg;\n-\t\t}\n-\t\tif (litArg != null) {\n-\t\t\tlong lit = ((LiteralArg) litArg).getLiteral();\n-\t\t\t// fix 'c + (-1)' => 'c - (1)'\n-\t\t\tif (arith.getOp() == ArithOp.ADD && lit < 0) {\n-\t\t\t\treturn new ArithNode(ArithOp.SUB,\n-\t\t\t\t\t\tarith.getResult(), arith.getArg(0),\n-\t\t\t\t\t\tInsnArg.lit(-lit, litArg.getType()));\n-\t\t\t}\n-\t\t\tInsnArg firstArg = arith.getArg(0);\n-\t\t\tif (arith.getOp() == ArithOp.XOR && firstArg.getType() == ArgType.BOOLEAN\n-\t\t\t\t\t&& (lit == 0 || lit == 1)) {\n-\t\t\t\tInsnNode node = new InsnNode(lit == 0 ? InsnType.MOVE : InsnType.NOT, 1);\n-\t\t\t\tnode.setResult(arith.getResult());\n-\t\t\t\tnode.addArg(firstArg);\n-\t\t\t\treturn node;\n-\t\t\t}\n+\t\t\tlitArg = (LiteralArg) secondArg;\n+\t\t}\n+\t\tif (litArg == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tswitch (arith.getOp()) {\n+\t\t\tcase ADD:\n+\t\t\t\t// fix 'c + (-1)' to 'c - (1)'\n+\t\t\t\tif (litArg.isNegative()) {\n+\t\t\t\t\tLiteralArg negLitArg = litArg.negate();\n+\t\t\t\t\tif (negLitArg != null) {\n+\t\t\t\t\t\treturn new ArithNode(ArithOp.SUB, arith.getResult(), arith.getArg(0), negLitArg);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\tcase XOR:\n+\t\t\t\t// simplify xor on boolean\n+\t\t\t\tInsnArg firstArg = arith.getArg(0);\n+\t\t\t\tlong lit = litArg.getLiteral();\n+\t\t\t\tif (firstArg.getType() == ArgType.BOOLEAN && (lit == 0 || lit == 1)) {\n+\t\t\t\t\tInsnNode node = new InsnNode(lit == 0 ? InsnType.MOVE : InsnType.NOT, 1);\n+\t\t\t\t\tnode.setResult(arith.getResult());\n+\t\t\t\t\tnode.addArg(firstArg);\n+\t\t\t\t\treturn node;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n \t\t}\n \t\treturn null;\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/arith/TestPrimitivesNegate.java b/jadx-core/src/test/java/jadx/tests/integration/arith/TestPrimitivesNegate.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/arith/TestPrimitivesNegate.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/arith/TestPrimitivesNegate.java\n@@ -0,0 +1,33 @@\n+package jadx.tests.integration.arith;\n+\n+import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.extensions.profiles.TestProfile;\n+import jadx.tests.api.extensions.profiles.TestWithProfiles;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestPrimitivesNegate extends IntegrationTest {\n+\n+\t@SuppressWarnings(\"UnnecessaryUnaryMinus\")\n+\tpublic static class TestCls {\n+\t\tpublic double test() {\n+\t\t\tdouble[] arr = new double[5];\n+\t\t\tarr[0] = -20;\n+\t\t\tarr[0] += -79;\n+\t\t\treturn arr[0];\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(test()).isEqualTo(-99);\n+\t\t}\n+\t}\n+\n+\t@TestWithProfiles({ TestProfile.DX_J8, TestProfile.JAVA8 })\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"dArr[0] = -20.0d;\")\n+\t\t\t\t.containsOne(\"dArr[0] = dArr[0] - 79.0d;\");\n+\t}\n+}",
    "output": "Fix correct literal negate for double and float"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -15,6 +15,8 @@\n import java.awt.dnd.DropTarget;\n import java.awt.event.ActionEvent;\n import java.awt.event.ActionListener;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n import java.awt.event.KeyAdapter;\n import java.awt.event.KeyEvent;\n import java.awt.event.MouseAdapter;\n@@ -680,28 +682,29 @@ private void toggleDeobfuscation() {\n \t\treOpenFile();\n \t}\n \n-\tprivate void nodeClickAction(@Nullable Object obj) {\n+\tprivate boolean nodeClickAction(@Nullable Object obj) {\n+\t\tif (obj == null) {\n+\t\t\treturn false;\n+\t\t}\n \t\ttry {\n-\t\t\tif (obj == null) {\n-\t\t\t\treturn;\n-\t\t\t}\n \t\t\tif (obj instanceof JResource) {\n \t\t\t\tJResource res = (JResource) obj;\n \t\t\t\tResourceFile resFile = res.getResFile();\n \t\t\t\tif (resFile != null && JResource.isSupportedForView(resFile.getType())) {\n-\t\t\t\t\ttabbedPane.showNode(res);\n+\t\t\t\t\treturn tabbedPane.showNode(res);\n \t\t\t\t}\n \t\t\t} else if (obj instanceof JNode) {\n \t\t\t\tJNode node = (JNode) obj;\n \t\t\t\tif (node.getRootClass() != null) {\n \t\t\t\t\ttabbedPane.codeJump(new JumpPosition(node));\n-\t\t\t\t} else {\n-\t\t\t\t\ttabbedPane.showNode(node);\n+\t\t\t\t\treturn true;\n \t\t\t\t}\n+\t\t\t\treturn tabbedPane.showNode(node);\n \t\t\t}\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Content loading error\", e);\n \t\t}\n+\t\treturn false;\n \t}\n \n \tprivate void treeRightClickAction(MouseEvent e) {\n@@ -738,6 +741,7 @@ private JNode getJNodeUnderMouse(MouseEvent mouseEvent) {\n \t\t}\n \t\tObject obj = path.getLastPathComponent();\n \t\tif (obj instanceof JNode) {\n+\t\t\ttree.setSelectionPath(path);\n \t\t\treturn (JNode) obj;\n \t\t}\n \t\treturn null;\n@@ -1090,11 +1094,22 @@ private void initUI() {\n \t\ttree = new JTree(treeModel);\n \t\tToolTipManager.sharedInstance().registerComponent(tree);\n \t\ttree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n+\t\ttree.setFocusable(false);\n+\t\ttree.addFocusListener(new FocusAdapter() {\n+\t\t\t@Override\n+\t\t\tpublic void focusLost(FocusEvent e) {\n+\t\t\t\ttree.setFocusable(false);\n+\t\t\t}\n+\t\t});\n \t\ttree.addMouseListener(new MouseAdapter() {\n \t\t\t@Override\n-\t\t\tpublic void mouseClicked(MouseEvent e) {\n+\t\t\tpublic void mousePressed(MouseEvent e) {\n \t\t\t\tif (SwingUtilities.isLeftMouseButton(e)) {\n-\t\t\t\t\tnodeClickAction(getJNodeUnderMouse(e));\n+\t\t\t\t\tif (!nodeClickAction(getJNodeUnderMouse(e))) {\n+\t\t\t\t\t\t// click ignored -> switch to focusable mode\n+\t\t\t\t\t\ttree.setFocusable(true);\n+\t\t\t\t\t\ttree.requestFocus();\n+\t\t\t\t\t}\n \t\t\t\t} else if (SwingUtilities.isRightMouseButton(e)) {\n \t\t\t\t\ttreeRightClickAction(e);\n \t\t\t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n@@ -203,12 +203,13 @@ private void showCode(final JumpPosition jumpPos) {\n \t\t});\n \t}\n \n-\tpublic void showNode(JNode node) {\n+\tpublic boolean showNode(JNode node) {\n \t\tfinal ContentPanel contentPanel = getContentPanel(node);\n \t\tif (contentPanel == null) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n-\t\tSwingUtilities.invokeLater(() -> selectTab(contentPanel));\n+\t\tselectTab(contentPanel);\n+\t\treturn true;\n \t}\n \n \tpublic void selectTab(ContentPanel contentPanel) {",
    "output": "Fix reduce tree focus switching"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -9,6 +9,7 @@\n import java.awt.GraphicsDevice;\n import java.awt.GraphicsEnvironment;\n import java.awt.HeadlessException;\n+import java.awt.Rectangle;\n import java.awt.Toolkit;\n import java.awt.dnd.DnDConstants;\n import java.awt.dnd.DropTarget;\n@@ -704,7 +705,7 @@ private void nodeClickAction(@Nullable Object obj) {\n \t}\n \n \tprivate void treeRightClickAction(MouseEvent e) {\n-\t\tJNode obj = getJNodeUnderMouse(e, false);\n+\t\tJNode obj = getJNodeUnderMouse(e);\n \t\tif (obj instanceof JPackage) {\n \t\t\tJPackagePopupMenu menu = new JPackagePopupMenu(this, (JPackage) obj);\n \t\t\tmenu.show(e.getComponent(), e.getX(), e.getY());\n@@ -718,17 +719,26 @@ private void treeRightClickAction(MouseEvent e) {\n \t}\n \n \t@Nullable\n-\tprivate JNode getJNodeUnderMouse(MouseEvent mouseEvent, boolean trySelection) {\n-\t\tTreePath path = tree.getPathForLocation(mouseEvent.getX(), mouseEvent.getY());\n-\t\tif (path == null && trySelection) {\n-\t\t\t// maybe click on node row (mouse pressed event should select this node in tree)\n-\t\t\tpath = tree.getSelectionPath();\n+\tprivate JNode getJNodeUnderMouse(MouseEvent mouseEvent) {\n+\t\tTreePath path = tree.getClosestPathForLocation(mouseEvent.getX(), mouseEvent.getY());\n+\t\tif (path == null) {\n+\t\t\treturn null;\n \t\t}\n-\t\tif (path != null) {\n-\t\t\tObject obj = path.getLastPathComponent();\n-\t\t\tif (obj instanceof JNode) {\n-\t\t\t\treturn (JNode) obj;\n+\t\t// allow 'closest' path only at the right of the item row\n+\t\tRectangle pathBounds = tree.getPathBounds(path);\n+\t\tif (pathBounds != null) {\n+\t\t\tint y = mouseEvent.getY();\n+\t\t\tif (y < pathBounds.y || y > (pathBounds.y + pathBounds.height)) {\n+\t\t\t\treturn null;\n \t\t\t}\n+\t\t\tif (mouseEvent.getX() < pathBounds.x) {\n+\t\t\t\t// exclude expand/collapse events\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\t\tObject obj = path.getLastPathComponent();\n+\t\tif (obj instanceof JNode) {\n+\t\t\treturn (JNode) obj;\n \t\t}\n \t\treturn null;\n \t}\n@@ -1081,16 +1091,10 @@ private void initUI() {\n \t\tToolTipManager.sharedInstance().registerComponent(tree);\n \t\ttree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n \t\ttree.addMouseListener(new MouseAdapter() {\n-\n-\t\t\t@Override\n-\t\t\tpublic void mousePressed(MouseEvent e) {\n-\t\t\t\tsuper.mousePressed(e);\n-\t\t\t}\n-\n \t\t\t@Override\n \t\t\tpublic void mouseClicked(MouseEvent e) {\n \t\t\t\tif (SwingUtilities.isLeftMouseButton(e)) {\n-\t\t\t\t\tnodeClickAction(getJNodeUnderMouse(e, true));\n+\t\t\t\t\tnodeClickAction(getJNodeUnderMouse(e));\n \t\t\t\t} else if (SwingUtilities.isRightMouseButton(e)) {\n \t\t\t\t\ttreeRightClickAction(e);\n \t\t\t\t}",
    "output": "Fix correct handling for tree row click"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -112,7 +112,7 @@ public void addArg(ICodeWriter code, InsnArg arg, Set<Flags> flags) throws Codeg\n \t\t\t}\n \t\t\tcode.add(mgen.getNameGen().useArg(reg));\n \t\t} else if (arg.isLiteral()) {\n-\t\t\tcode.add(lit((LiteralArg) arg));\n+\t\t\taddLiteralArg(code, (LiteralArg) arg, flags);\n \t\t} else if (arg.isInsnWrap()) {\n \t\t\taddWrappedArg(code, (InsnWrapArg) arg, flags);\n \t\t} else if (arg.isNamed()) {\n@@ -122,6 +122,15 @@ public void addArg(ICodeWriter code, InsnArg arg, Set<Flags> flags) throws Codeg\n \t\t}\n \t}\n \n+\tprivate void addLiteralArg(ICodeWriter code, LiteralArg litArg, Set<Flags> flags) {\n+\t\tString literalStr = lit(litArg);\n+\t\tif (!flags.contains(Flags.BODY_ONLY_NOWRAP) && literalStr.startsWith(\"-\")) {\n+\t\t\tcode.add('(').add(literalStr).add(')');\n+\t\t} else {\n+\t\t\tcode.add(literalStr);\n+\t\t}\n+\t}\n+\n \tprivate void addWrappedArg(ICodeWriter code, InsnWrapArg arg, Set<Flags> flags) throws CodegenException {\n \t\tInsnNode wrapInsn = arg.getWrapInsn();\n \t\tif (wrapInsn.contains(AFlag.FORCE_ASSIGN_INLINE)) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n@@ -508,7 +508,17 @@ private SwitchInsn makeSwitch(InsnData insn, boolean packed) {\n \tprivate InsnNode makeNewArray(InsnData insn) {\n \t\tArgType indexType = ArgType.parse(insn.getIndexAsType());\n \t\tint dim = (int) insn.getLiteral();\n-\t\tArgType arrType = dim == 0 ? indexType : ArgType.array(indexType, dim);\n+\t\tArgType arrType;\n+\t\tif (dim == 0) {\n+\t\t\tarrType = indexType;\n+\t\t} else {\n+\t\t\tif (indexType.isArray()) {\n+\t\t\t\t// java bytecode can pass array as a base type\n+\t\t\t\tarrType = indexType;\n+\t\t\t} else {\n+\t\t\t\tarrType = ArgType.array(indexType, dim);\n+\t\t\t}\n+\t\t}\n \t\tint regsCount = insn.getRegsCount();\n \t\tNewArrayNode newArr = new NewArrayNode(arrType, regsCount - 1);\n \t\tnewArr.setResult(InsnArg.reg(insn, 0, arrType));\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestOverloadedInvoke.java b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestOverloadedInvoke.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestOverloadedInvoke.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestOverloadedInvoke.java\n@@ -0,0 +1,39 @@\n+package jadx.tests.integration.invoke;\n+\n+import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.extensions.profiles.TestProfile;\n+import jadx.tests.api.extensions.profiles.TestWithProfiles;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestOverloadedInvoke extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic static final int N = 10;\n+\n+\t\tpublic void test() {\n+\t\t\tint[][][] arr = new int[N][N][N];\n+\t\t\tuse(arr, -1);\n+\t\t\tuse(arr[0], -2);\n+\t\t}\n+\n+\t\tpublic void use(Object[][] arr, Object obj) {\n+\t\t}\n+\n+\t\tpublic void use(int[][] arr, int i) {\n+\t\t}\n+\t}\n+\n+\t@TestWithProfiles({ TestProfile.DX_J8, TestProfile.D8_J11, TestProfile.JAVA8 })\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"use(iArr[0], -2);\")\n+\t\t\t\t.containsOne(\"use((Object[][]) iArr, (Object) (-1));\");\n+\t\t// TODO: don't add unnecessary casts\n+\t\t// .containsOne(\"use(iArr, -1);\");\n+\t\t// TODO: replace call `Array.newInstance` with new array creation: `new int[N][N][N]`\n+\t\t// .containsOne(\"new int[10][10][10];\");\n+\t}\n+}",
    "output": "Fix wrap negative literals before cast"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxArgs.java b/jadx-core/src/main/java/jadx/api/JadxArgs.java\n--- a/jadx-core/src/main/java/jadx/api/JadxArgs.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java\n@@ -138,7 +138,7 @@ public int getThreadsCount() {\n \t}\n \n \tpublic void setThreadsCount(int threadsCount) {\n-\t\tthis.threadsCount = threadsCount;\n+\t\tthis.threadsCount = Math.max(1, threadsCount); // make sure threadsCount >= 1\n \t}\n \n \tpublic boolean isCfgOutput() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -433,8 +433,10 @@ private SettingsGroup makeDecompilationGroup() {\n \t\t\tneedReload();\n \t\t});\n \n-\t\tSpinnerNumberModel spinnerModel = new SpinnerNumberModel(\n-\t\t\t\tsettings.getThreadsCount(), 1, Runtime.getRuntime().availableProcessors() * 2, 1);\n+\t\t// fix for #1331\n+\t\tint threadsCountValue = settings.getThreadsCount();\n+\t\tint threadsCountMax = Math.max(2, Math.max(threadsCountValue, Runtime.getRuntime().availableProcessors() * 2));\n+\t\tSpinnerNumberModel spinnerModel = new SpinnerNumberModel(threadsCountValue, 1, threadsCountMax, 1);\n \t\tJSpinner threadsCount = new JSpinner(spinnerModel);\n \t\tthreadsCount.addChangeListener(e -> {\n \t\t\tsettings.setThreadsCount((Integer) threadsCount.getValue());",
    "output": "Fix processing threads spinner initialization"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/device/debugger/DbgUtils.java b/jadx-gui/src/main/java/jadx/gui/device/debugger/DbgUtils.java\n--- a/jadx-gui/src/main/java/jadx/gui/device/debugger/DbgUtils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/device/debugger/DbgUtils.java\n@@ -126,13 +126,21 @@ public static String searchPackageName(MainWindow mainWindow) {\n \t@Nullable\n \tpublic static JClass searchMainActivity(MainWindow mainWindow) {\n \t\tString content = getManifestContent(mainWindow);\n-\t\tint pos = content.indexOf(\"<action android:name=\\\"android.intent.action.MAIN\\\"\");\n-\t\tif (pos > -1) {\n-\t\t\tpos = content.lastIndexOf(\"<activity \", pos);\n-\t\t\tif (pos > -1) {\n-\t\t\t\tpos = content.indexOf(\" android:name=\\\"\", pos);\n+\t\tint pos; // current position\n+\t\tint actionPos = 0; // last found action's index\n+\t\tString actionTag = \"<action android:name=\\\"android.intent.action.MAIN\\\"\";\n+\t\tint actionTagLen = 0; // beginning offset. suggested length set after first iteration\n+\t\twhile (actionPos > -1) {\n+\t\t\tpos = content.indexOf(actionTag, actionPos + actionTagLen);\n+\t\t\tactionPos = pos;\n+\t\t\tint activityPos = content.lastIndexOf(\"<activity \", pos);\n+\t\t\tif (activityPos > -1) {\n+\t\t\t\tint aliasPos = content.lastIndexOf(\"<activity-alias \", pos);\n+\t\t\t\tboolean isAnAlias = aliasPos > -1 && aliasPos > activityPos;\n+\t\t\t\tString classPathAttribute = \" android:\" + (isAnAlias ? \"targetActivity\" : \"name\") + \"=\\\"\";\n+\t\t\t\tpos = content.indexOf(classPathAttribute, isAnAlias ? aliasPos : activityPos);\n \t\t\t\tif (pos > -1) {\n-\t\t\t\t\tpos += \" android:name=\\\"\".length();\n+\t\t\t\t\tpos += classPathAttribute.length();\n \t\t\t\t\tString classFullName = content.substring(pos, content.indexOf(\"\\\"\", pos));\n \t\t\t\t\t// in case the MainActivity class has been renamed before, we need raw name.\n \t\t\t\t\tJavaClass cls = mainWindow.getWrapper().getDecompiler().searchJavaClassByAliasFullName(classFullName);\n@@ -142,6 +150,9 @@ public static JClass searchMainActivity(MainWindow mainWindow) {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif (actionTagLen == 0) {\n+\t\t\t\tactionTagLen = actionTag.length();\n+\t\t\t}\n \t\t}\n \t\treturn null;\n \t}",
    "output": "Fix support multiple main <action> and <activity-alias> tags * fix(dgb): support multiple main <action> and <activity-alias> tags in manifest * Update jadx-gui/src/main/java/jadx/gui/device/debugger/DbgUtils.java"
  },
  {
    "input": "diff --git a/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers3.java b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers3.java\n@@ -0,0 +1,39 @@\n+package jadx.tests.integration.debuginfo;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.extensions.inputs.InputPlugin;\n+import jadx.tests.api.extensions.inputs.TestWithInputPlugins;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestLineNumbers3 extends IntegrationTest {\n+\n+\tpublic static class TestCls extends Exception {\n+\n+\t\tpublic TestCls(final Object message) {\n+\t\t\tsuper((message == null) ? \"\" : message.toString());\n+\t\t\t/*\n+\t\t\t * comment to increase line number in return instruction\n+\t\t\t * -\n+\t\t\t * -\n+\t\t\t * -\n+\t\t\t * -\n+\t\t\t * -\n+\t\t\t * -\n+\t\t\t * -\n+\t\t\t * -\n+\t\t\t * -\n+\t\t\t * -\n+\t\t\t */\n+\t\t}\n+\t}\n+\n+\t@TestWithInputPlugins({ InputPlugin.DEX, InputPlugin.JAVA })\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tassertThat(cls).code().containsOne(\"super(message == null ? \\\"\\\" : message.toString());\");\n+\t\tString linesMapStr = cls.getCode().getLineMapping().toString();\n+\t\tassertThat(linesMapStr).isEqualTo(\"{4=13, 5=14, 6=15}\");\n+\t}\n+}\n\ndiff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/debuginfo/DebugInfoParser.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/debuginfo/DebugInfoParser.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/debuginfo/DebugInfoParser.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/debuginfo/DebugInfoParser.java\n@@ -185,25 +185,16 @@ public DebugInfo process(int debugOff) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tsetSourceLines(addr, codeSize, line);\n \n \t\treturn new DebugInfo(linesMap, resultList);\n \t}\n \n \tprivate int addrChange(int addr, int addrInc, int line) {\n-\t\tint newAddr = addr + addrInc;\n-\t\tint maxAddr = codeSize - 1;\n-\t\tnewAddr = Math.min(newAddr, maxAddr);\n-\t\tsetSourceLines(addr, newAddr, line);\n+\t\tint newAddr = Math.min(addr + addrInc, codeSize - 1);\n+\t\tsetLine(newAddr, line);\n \t\treturn newAddr;\n \t}\n \n-\tprivate void setSourceLines(int start, int end, int line) {\n-\t\tfor (int offset = start + 1; offset < end; offset++) {\n-\t\t\tsetLine(offset, line);\n-\t\t}\n-\t}\n-\n \tprivate void setLine(int offset, int line) {\n \t\tlinesMap.put(offset, line);\n \t}",
    "output": "Use debug line numbers only at fixed offsets"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourceFile.java b/jadx-core/src/main/java/jadx/api/ResourceFile.java\n--- a/jadx-core/src/main/java/jadx/api/ResourceFile.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java\n@@ -37,6 +37,10 @@ public String toString() {\n \tprivate ZipRef zipRef;\n \tprivate String deobfName;\n \n+\tpublic static ResourceFile createResourceFile(JadxDecompiler decompiler, File file, ResourceType type) {\n+\t\treturn new ResourceFile(decompiler, file.getAbsolutePath(), type);\n+\t}\n+\n \tpublic static ResourceFile createResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {\n \t\tif (!ZipSecurity.isValidZipEntryName(name)) {\n \t\t\treturn null;\n\ndiff --git a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n--- a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n@@ -145,16 +145,8 @@ private void loadFile(List<ResourceFile> list, File file) {\n \t\t\t\treturn null;\n \t\t\t});\n \t\t} else {\n-\t\t\taddResourceFile(list, file);\n-\t\t}\n-\t}\n-\n-\tprivate void addResourceFile(List<ResourceFile> list, File file) {\n-\t\tString name = file.getAbsolutePath();\n-\t\tResourceType type = ResourceType.getFileType(name);\n-\t\tResourceFile rf = ResourceFile.createResourceFile(jadxRef, name, type);\n-\t\tif (rf != null) {\n-\t\t\tlist.add(rf);\n+\t\t\tResourceType type = ResourceType.getFileType(file.getAbsolutePath());\n+\t\t\tlist.add(ResourceFile.createResourceFile(jadxRef, file, type));\n \t\t}\n \t}",
    "output": "Fix skip input file name checks by zip name validator"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n@@ -58,7 +58,7 @@ private static Path getPathDeobfMapPath(RootNode root) {\n \t\tif (inputFiles.isEmpty()) {\n \t\t\treturn null;\n \t\t}\n-\t\tPath inputFilePath = inputFiles.get(0).getAbsoluteFile().toPath();\n+\t\tPath inputFilePath = inputFiles.get(0).toPath().toAbsolutePath();\n \t\tString baseName = FileUtils.getPathBaseName(inputFilePath);\n \t\treturn inputFilePath.getParent().resolve(baseName + \".jobf\");\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n@@ -75,7 +75,7 @@ public static void addFileToJar(JarOutputStream jar, File source, String entryNa\n \n \tpublic static void makeDirsForFile(Path path) {\n \t\tif (path != null) {\n-\t\t\tmakeDirs(path.getParent().toFile());\n+\t\t\tmakeDirs(path.toAbsolutePath().getParent().toFile());\n \t\t}\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -451,7 +451,7 @@ private void onOpen(List<Path> paths) {\n \t\tupdate();\n \t\trestoreOpenTabs();\n \t\trunInitialBackgroundJobs();\n-\t\tBreakpointManager.init(paths.get(0).getParent());\n+\t\tBreakpointManager.init(paths.get(0).toAbsolutePath().getParent());\n \t}\n \n \tprivate void addTreeCustomNodes() {\n@@ -517,7 +517,7 @@ private void update() {\n \t\tif (projectPath == null) {\n \t\t\tpathString = \"\";\n \t\t} else {\n-\t\t\tpathString = \" [\" + projectPath.getParent().toAbsolutePath() + ']';\n+\t\t\tpathString = \" [\" + projectPath.toAbsolutePath().getParent() + ']';\n \t\t}\n \t\tsetTitle((project.isSaved() ? \"\" : '*')\n \t\t\t\t+ project.getName() + pathString + \" - \" + DEFAULT_TITLE);",
    "output": "Fix correct usage of `Path.getParent()`"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n@@ -31,23 +31,14 @@\n import jadx.gui.settings.data.TabViewState;\n import jadx.gui.ui.MainWindow;\n import jadx.gui.ui.codearea.EditorViewState;\n-import jadx.gui.utils.PathTypeAdapter;\n+import jadx.gui.utils.RelativePathTypeAdapter;\n \n public class JadxProject {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(JadxProject.class);\n \n \tprivate static final int CURRENT_PROJECT_VERSION = 1;\n \tpublic static final String PROJECT_EXTENSION = \"jadx\";\n \n-\tprivate static final Gson GSON = new GsonBuilder()\n-\t\t\t.registerTypeHierarchyAdapter(Path.class, PathTypeAdapter.singleton())\n-\t\t\t.registerTypeAdapter(ICodeComment.class, GsonUtils.interfaceReplace(JadxCodeComment.class))\n-\t\t\t.registerTypeAdapter(ICodeRename.class, GsonUtils.interfaceReplace(JadxCodeRename.class))\n-\t\t\t.registerTypeAdapter(IJavaNodeRef.class, GsonUtils.interfaceReplace(JadxNodeRef.class))\n-\t\t\t.registerTypeAdapter(IJavaCodeRef.class, GsonUtils.interfaceReplace(JadxCodeRef.class))\n-\t\t\t.setPrettyPrinting()\n-\t\t\t.create();\n-\n \tprivate transient MainWindow mainWindow;\n \tprivate transient JadxSettings settings;\n \n@@ -179,9 +170,11 @@ public void saveAs(Path path) {\n \t}\n \n \tpublic void save() {\n-\t\tif (getProjectPath() != null) {\n-\t\t\ttry (Writer writer = Files.newBufferedWriter(getProjectPath(), StandardCharsets.UTF_8)) {\n-\t\t\t\tGSON.toJson(data, writer);\n+\t\tPath savePath = getProjectPath();\n+\t\tif (savePath != null) {\n+\t\t\tPath basePath = savePath.toAbsolutePath().getParent();\n+\t\t\ttry (Writer writer = Files.newBufferedWriter(savePath, StandardCharsets.UTF_8)) {\n+\t\t\t\tbuildGson(basePath).toJson(data, writer);\n \t\t\t\tsaved = true;\n \t\t\t} catch (Exception e) {\n \t\t\t\tLOG.error(\"Error saving project\", e);\n@@ -190,9 +183,10 @@ public void save() {\n \t}\n \n \tpublic static JadxProject from(Path path) {\n+\t\tPath basePath = path.toAbsolutePath().getParent();\n \t\ttry (Reader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {\n \t\t\tJadxProject project = new JadxProject();\n-\t\t\tproject.data = GSON.fromJson(reader, ProjectData.class);\n+\t\t\tproject.data = buildGson(basePath).fromJson(reader, ProjectData.class);\n \t\t\tproject.saved = true;\n \t\t\tproject.setProjectPath(path);\n \t\t\tproject.upgrade();\n@@ -203,6 +197,17 @@ public static JadxProject from(Path path) {\n \t\t}\n \t}\n \n+\tprivate static Gson buildGson(Path basePath) {\n+\t\treturn new GsonBuilder()\n+\t\t\t\t.registerTypeHierarchyAdapter(Path.class, new RelativePathTypeAdapter(basePath))\n+\t\t\t\t.registerTypeAdapter(ICodeComment.class, GsonUtils.interfaceReplace(JadxCodeComment.class))\n+\t\t\t\t.registerTypeAdapter(ICodeRename.class, GsonUtils.interfaceReplace(JadxCodeRename.class))\n+\t\t\t\t.registerTypeAdapter(IJavaNodeRef.class, GsonUtils.interfaceReplace(JadxNodeRef.class))\n+\t\t\t\t.registerTypeAdapter(IJavaCodeRef.class, GsonUtils.interfaceReplace(JadxCodeRef.class))\n+\t\t\t\t.setPrettyPrinting()\n+\t\t\t\t.create();\n+\t}\n+\n \tprivate void upgrade() {\n \t\tint fromVersion = data.getProjectVersion();\n \t\tLOG.debug(\"upgrade settings from version: {} to {}\", fromVersion, CURRENT_PROJECT_VERSION);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -361,6 +361,12 @@ private void saveProjectAs() {\n \t\tif (currentDirectory != null) {\n \t\t\tfileChooser.setCurrentDirectory(currentDirectory.toFile());\n \t\t}\n+\t\tif (this.project.getFilePaths().size() == 1) {\n+\t\t\t// If there is only one file loaded we suggest saving the jadx project file next to the loaded file\n+\t\t\tPath loadedFile = this.project.getFilePaths().get(0);\n+\t\t\tString fileName = loadedFile.getFileName() + \".\" + JadxProject.PROJECT_EXTENSION;\n+\t\t\tfileChooser.setSelectedFile(loadedFile.resolveSibling(fileName).toFile());\n+\t\t}\n \t\tint ret = fileChooser.showSaveDialog(mainPanel);\n \t\tif (ret == JFileChooser.APPROVE_OPTION) {\n \t\t\tsettings.setLastSaveProjectPath(fileChooser.getCurrentDirectory().toPath());\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/RelativePathTypeAdapter.java b/jadx-gui/src/main/java/jadx/gui/utils/RelativePathTypeAdapter.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/RelativePathTypeAdapter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/RelativePathTypeAdapter.java\n@@ -0,0 +1,44 @@\n+package jadx.gui.utils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Objects;\n+\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+\n+public class RelativePathTypeAdapter extends TypeAdapter<Path> {\n+\tprivate final Path basePath;\n+\n+\tpublic RelativePathTypeAdapter(Path basePath) {\n+\t\tthis.basePath = Objects.requireNonNull(basePath);\n+\t}\n+\n+\t@Override\n+\tpublic void write(JsonWriter out, Path value) throws IOException {\n+\t\tif (value == null) {\n+\t\t\tout.nullValue();\n+\t\t} else {\n+\t\t\tvalue = value.toAbsolutePath().normalize();\n+\t\t\tString relativePath = basePath.relativize(value).toString();\n+\t\t\tout.value(relativePath);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic Path read(JsonReader in) throws IOException {\n+\t\tif (in.peek() == JsonToken.NULL) {\n+\t\t\tin.nextNull();\n+\t\t\treturn null;\n+\t\t}\n+\t\tPath p = Paths.get(in.nextString());\n+\t\tif (p.isAbsolute()) {\n+\t\t\treturn p;\n+\t\t}\n+\t\treturn basePath.resolve(p);\n+\t}\n+\n+}",
    "output": "Use relative file paths in .jadx project file"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -111,7 +111,18 @@ public boolean addDefinition(ICodeWriter code) {\n \t\t\tCodeGenUtils.addRenamedComment(code, mth, mth.getName());\n \t\t}\n \t\tif (mth.contains(AFlag.INCONSISTENT_CODE) && mth.checkCommentsLevel(CommentsLevel.ERROR)) {\n-\t\t\tcode.startLine(\"/* Code decompiled incorrectly, please refer to instructions dump */\");\n+\t\t\tcode.startLine(\"/*\");\n+\t\t\tcode.incIndent();\n+\t\t\tcode.startLine(\"Code decompiled incorrectly, please refer to instructions dump.\");\n+\t\t\tif (!mth.root().getArgs().isShowInconsistentCode()) {\n+\t\t\t\tif (code.isMetadataSupported()) {\n+\t\t\t\t\tcode.startLine(\"To view partially-correct code enable 'Show inconsistent code' option in preferences\");\n+\t\t\t\t} else {\n+\t\t\t\t\tcode.startLine(\"To view partially-correct add '--show-bad-code' argument\");\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcode.decIndent();\n+\t\t\tcode.startLine(\"*/\");\n \t\t}\n \n \t\tcode.startLineWithNum(mth.getSourceLine());\n@@ -314,7 +325,14 @@ public void addFallbackMethodCode(ICodeWriter code, FallbackOption fallbackOptio\n \t\t\t\t\t.filter(insn -> insn.getType() != InsnType.NOP)\n \t\t\t\t\t.count();\n \t\t\tif (insnCountEstimate > 100) {\n-\t\t\t\tcode.startLine(\"// Method dump skipped, instructions count: \" + insnArr.length);\n+\t\t\t\tcode.incIndent();\n+\t\t\t\tcode.startLine(\"Method dump skipped, instructions count: \" + insnArr.length);\n+\t\t\t\tif (code.isMetadataSupported()) {\n+\t\t\t\t\tcode.startLine(\"To view this dump change 'Code comments level' option to 'DEBUG'\");\n+\t\t\t\t} else {\n+\t\t\t\t\tcode.startLine(\"To view this dump add '--comments-level debug' option\");\n+\t\t\t\t}\n+\t\t\t\tcode.decIndent();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}",
    "output": "Add comments with option references to improve usability"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n@@ -323,23 +323,14 @@ private static void removeExcHandler(MethodNode mth, ExceptionHandler excHandler\n \tprivate static boolean wrapBlocksWithTryCatch(MethodNode mth, TryCatchBlockAttr tryCatchBlock) {\n \t\tList<BlockNode> blocks = tryCatchBlock.getBlocks();\n \t\tBlockNode top = searchTopBlock(mth, blocks);\n-\t\tif (top.getPredecessors().isEmpty()) {\n+\t\tif (top.getPredecessors().isEmpty() && top != mth.getEnterBlock()) {\n \t\t\treturn false;\n \t\t}\n \t\tBlockNode bottom = searchBottomBlock(mth, blocks);\n-\n \t\tif (Consts.DEBUG_EXC_HANDLERS) {\n \t\t\tLOG.debug(\"TryCatch #{} split: top {}, bottom: {}\", tryCatchBlock.id(), top, bottom);\n \t\t}\n-\n-\t\tBlockNode topSplitterBlock;\n-\t\tif (top == mth.getEnterBlock()) {\n-\t\t\tBlockNode fixedTop = mth.getEnterBlock().getSuccessors().get(0);\n-\t\t\ttopSplitterBlock = BlockSplitter.blockSplitTop(mth, fixedTop);\n-\t\t} else {\n-\t\t\tBlockNode existTopSplitter = BlockUtils.getBlockWithFlag(top.getPredecessors(), AFlag.EXC_TOP_SPLITTER);\n-\t\t\ttopSplitterBlock = existTopSplitter != null ? existTopSplitter : BlockSplitter.blockSplitTop(mth, top);\n-\t\t}\n+\t\tBlockNode topSplitterBlock = getTopSplitterBlock(mth, top);\n \t\ttopSplitterBlock.add(AFlag.EXC_TOP_SPLITTER);\n \t\ttopSplitterBlock.add(AFlag.SYNTHETIC);\n \n@@ -356,6 +347,10 @@ private static boolean wrapBlocksWithTryCatch(MethodNode mth, TryCatchBlockAttr\n \t\t\tBlockSplitter.connect(bottom, bottomSplitterBlock);\n \t\t}\n \n+\t\tif (Consts.DEBUG_EXC_HANDLERS) {\n+\t\t\tLOG.debug(\"TryCatch #{} result splitters: top {}, bottom: {}\",\n+\t\t\t\t\ttryCatchBlock.id(), topSplitterBlock, bottomSplitterBlock);\n+\t\t}\n \t\tconnectSplittersAndHandlers(tryCatchBlock, topSplitterBlock, bottomSplitterBlock);\n \n \t\tfor (BlockNode block : blocks) {\n@@ -373,6 +368,25 @@ private static boolean wrapBlocksWithTryCatch(MethodNode mth, TryCatchBlockAttr\n \t\treturn true;\n \t}\n \n+\tprivate static BlockNode getTopSplitterBlock(MethodNode mth, BlockNode top) {\n+\t\tif (top == mth.getEnterBlock()) {\n+\t\t\tBlockNode fixedTop = mth.getEnterBlock().getSuccessors().get(0);\n+\t\t\treturn BlockSplitter.blockSplitTop(mth, fixedTop);\n+\t\t}\n+\t\tBlockNode existPredTopSplitter = BlockUtils.getBlockWithFlag(top.getPredecessors(), AFlag.EXC_TOP_SPLITTER);\n+\t\tif (existPredTopSplitter != null) {\n+\t\t\treturn existPredTopSplitter;\n+\t\t}\n+\t\t// try to reuse exists splitter on empty simple path below top block\n+\t\tif (top.getCleanSuccessors().size() == 1 && top.getInstructions().isEmpty()) {\n+\t\t\tBlockNode otherTopSplitter = BlockUtils.getBlockWithFlag(top.getCleanSuccessors(), AFlag.EXC_TOP_SPLITTER);\n+\t\t\tif (otherTopSplitter != null && otherTopSplitter.getPredecessors().size() == 1) {\n+\t\t\t\treturn otherTopSplitter;\n+\t\t\t}\n+\t\t}\n+\t\treturn BlockSplitter.blockSplitTop(mth, top);\n+\t}\n+\n \tprivate static BlockNode searchTopBlock(MethodNode mth, List<BlockNode> blocks) {\n \t\tBlockNode top = BlockUtils.getTopBlock(blocks);\n \t\tif (top != null) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -572,9 +572,9 @@ public static boolean isAnyPathExists(BlockNode start, BlockNode end) {\n \t\treturn traverseSuccessorsUntil(start, end, new BitSet(), false);\n \t}\n \n-\tpublic static BlockNode getTopBlock(Collection<BlockNode> blocks) {\n+\tpublic static BlockNode getTopBlock(List<BlockNode> blocks) {\n \t\tif (blocks.size() == 1) {\n-\t\t\treturn blocks.iterator().next();\n+\t\t\treturn blocks.get(0);\n \t\t}\n \t\tfor (BlockNode from : blocks) {\n \t\t\tboolean top = true;\n@@ -594,9 +594,9 @@ public static BlockNode getTopBlock(Collection<BlockNode> blocks) {\n \t/**\n \t * Search last block in control flow graph from input set.\n \t */\n-\tpublic static BlockNode getBottomBlock(Collection<BlockNode> blocks) {\n+\tpublic static BlockNode getBottomBlock(List<BlockNode> blocks) {\n \t\tif (blocks.size() == 1) {\n-\t\t\treturn blocks.iterator().next();\n+\t\t\treturn blocks.get(0);\n \t\t}\n \t\tfor (BlockNode bottomCandidate : blocks) {\n \t\t\tboolean bottom = true;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n@@ -59,6 +59,10 @@ public static void dumpRaw(MethodNode mth, String desc, Predicate<MethodNode> du\n \t\t}\n \t}\n \n+\tpublic static void dumpRawTest(MethodNode mth, String desc) {\n+\t\tdumpRaw(mth, desc, method -> method.getName().equals(\"test\"));\n+\t}\n+\n \tpublic static void dumpRaw(MethodNode mth, String desc) {\n \t\tFile out = new File(\"test-graph-\" + desc + \"-tmp\");\n \t\tDotGraphVisitor.dumpRaw().save(out, mth);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally13.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally13.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally13.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally13.java\n@@ -0,0 +1,52 @@\n+package jadx.tests.integration.trycatch;\n+\n+import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.extensions.inputs.InputPlugin;\n+import jadx.tests.api.extensions.inputs.TestWithInputPlugins;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestTryCatchFinally13 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic void test(int i) {\n+\t\t\ttry {\n+\t\t\t\tdoSomething1();\n+\t\t\t\tif (i == -12) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tif (i > 10) {\n+\t\t\t\t\tdoSomething2();\n+\t\t\t\t} else if (i == -1) {\n+\t\t\t\t\tdoSomething3();\n+\t\t\t\t}\n+\t\t\t} catch (Exception ex) {\n+\t\t\t\tlogError();\n+\t\t\t} finally {\n+\t\t\t\tdoSomething4();\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void logError() {\n+\t\t}\n+\n+\t\tprivate void doSomething1() {\n+\t\t}\n+\n+\t\tprivate void doSomething2() {\n+\t\t}\n+\n+\t\tprivate void doSomething3() {\n+\t\t}\n+\n+\t\tprivate void doSomething4() {\n+\t\t}\n+\t}\n+\n+\t@TestWithInputPlugins({ InputPlugin.DEX, InputPlugin.JAVA })\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"} finally {\");\n+\t}\n+}",
    "output": "Use correct top block for try blocks with same start"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -763,8 +763,7 @@ private void makeInvoke(InvokeNode insn, ICodeWriter code) throws CodegenExcepti\n \t\t\tcase VIRTUAL:\n \t\t\tcase INTERFACE:\n \t\t\t\tInsnArg arg = insn.getArg(0);\n-\t\t\t\t// FIXME: add 'this' for equals methods in scope\n-\t\t\t\tif (!arg.isThis()) {\n+\t\t\t\tif (needInvokeArg(arg)) {\n \t\t\t\t\taddArgDot(code, arg);\n \t\t\t\t}\n \t\t\t\tk++;\n@@ -799,6 +798,20 @@ private void makeInvoke(InvokeNode insn, ICodeWriter code) throws CodegenExcepti\n \t\tgenerateMethodArguments(code, insn, k, callMthNode);\n \t}\n \n+\t// FIXME: add 'this' for equals methods in scope\n+\tprivate boolean needInvokeArg(InsnArg arg) {\n+\t\tif (arg.isAnyThis()) {\n+\t\t\tif (arg.isThis()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tClassNode clsNode = mth.root().resolveClass(arg.getType());\n+\t\t\tif (clsNode != null && clsNode.contains(AFlag.DONT_GENERATE)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n \tprivate void makeInvokeLambda(ICodeWriter code, InvokeCustomNode customNode) throws CodegenException {\n \t\tif (customNode.isUseRef()) {\n \t\t\tmakeRefLambda(code, customNode);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n@@ -232,6 +232,27 @@ public boolean isThis() {\n \t\treturn contains(AFlag.THIS);\n \t}\n \n+\t/**\n+\t * Return true for 'this' from other classes (often occur in anonymous classes)\n+\t */\n+\tpublic boolean isAnyThis() {\n+\t\tif (contains(AFlag.THIS)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tInsnNode wrappedInsn = unwrap();\n+\t\tif (wrappedInsn != null && wrappedInsn.getType() == InsnType.IGET) {\n+\t\t\treturn wrappedInsn.getArg(0).isAnyThis();\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic InsnNode unwrap() {\n+\t\tif (isInsnWrap()) {\n+\t\t\treturn ((InsnWrapArg) this).getWrapInsn();\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \tpublic boolean isConst() {\n \t\treturn isLiteral() || (isInsnWrap() && ((InsnWrapArg) this).getWrapInsn().isConstInsn());\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/rename/RenameVisitor.java\n@@ -97,7 +97,7 @@ private static void checkClassName(Deobfuscator deobfuscator, ClassNode cls, Jad\n \t\t\t// check inner classes names\n \t\t\tClassInfo parentClass = classInfo.getParentClass();\n \t\t\twhile (parentClass != null) {\n-\t\t\t\tif (parentClass.getAliasShortName().equals(clsName)) {\n+\t\t\t\tif (parentClass.getAliasShortName().equals(newShortName)) {\n \t\t\t\t\tString clsAlias = deobfuscator.getClsAlias(cls);\n \t\t\t\t\tclassInfo.changeShortName(clsAlias);\n \t\t\t\t\tcls.addAttr(new RenameReasonAttr(cls).append(\"collision with other inner class name\"));\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java\n--- a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java\n@@ -74,6 +74,13 @@ public JadxCodeAssertions removeBlockComments() {\n \t\treturn newCode;\n \t}\n \n+\tpublic JadxCodeAssertions removeLineComments() {\n+\t\tString code = actual.replaceAll(\"//.*(?!$)\", \"\");\n+\t\tJadxCodeAssertions newCode = new JadxCodeAssertions(code);\n+\t\tnewCode.print();\n+\t\treturn newCode;\n+\t}\n+\n \tpublic JadxCodeAssertions print() {\n \t\tSystem.out.println(\"-----------------------------------------------------------\");\n \t\tSystem.out.println(actual);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass18.java b/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass18.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass18.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass18.java\n@@ -0,0 +1,60 @@\n+package jadx.tests.integration.inner;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.api.CommentsLevel;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestAnonymousClass18 extends IntegrationTest {\n+\n+\t@SuppressWarnings({ \"Convert2Lambda\", \"Anonymous2MethodRef\", \"unused\" })\n+\tpublic static class TestCls {\n+\n+\t\tpublic interface Job {\n+\t\t\tvoid executeJob();\n+\t\t}\n+\n+\t\tpublic void start() {\n+\t\t\trunJob(new Job() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void executeJob() {\n+\t\t\t\t\trunJob(new Job() {\n+\t\t\t\t\t\t@Override\n+\t\t\t\t\t\tpublic void executeJob() {\n+\t\t\t\t\t\t\tdoSomething();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\tprivate void doSomething() {\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tpublic static void runJob(Job job) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tgetArgs().setCommentsLevel(CommentsLevel.WARN);\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"AnonymousClass1.this\")\n+\t\t\t\t.doesNotContain(\"class AnonymousClass1\")\n+\t\t\t\t// .doesNotContain(\"TestAnonymousClass18$TestCls.runJob(\") // TODO: ???\n+\t\t\t\t.containsOne(indent() + \"doSomething();\");\n+\t}\n+\n+\t@Test\n+\tpublic void testNoInline() {\n+\t\tgetArgs().setInlineAnonymousClasses(false);\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"class AnonymousClass1 implements Job {\")\n+\t\t\t\t.containsOne(\"class C00001 implements Job {\")\n+\t\t\t\t.containsOne(\"AnonymousClass1.this.doSomething();\");\n+\t}\n+}",
    "output": "Fix invoke in nested anonymous classes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessInstructionsVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessInstructionsVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessInstructionsVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessInstructionsVisitor.java\n@@ -80,6 +80,13 @@ private static void initJumps(MethodNode mth, InsnNode[] insnByOffset) {\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n \n+\t\t\t\tcase STR_CONCAT:\n+\t\t\t\t\t// invoke-custom with string concatenation translated directly to STR_CONCAT, merge next move-result\n+\t\t\t\t\tif (insn.getResult() == null) {\n+\t\t\t\t\t\tmergeMoveResult(insnByOffset, offset, insn, ArgType.STRING);\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\n \t\t\t\tcase FILLED_NEW_ARRAY:\n \t\t\t\t\tArgType arrType = ((FilledNewArrayNode) insn).getArrayType();\n \t\t\t\t\tmergeMoveResult(insnByOffset, offset, insn, arrType);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n@@ -47,6 +47,7 @@\n import jadx.core.xmlgen.ResourceStorage;\n import jadx.core.xmlgen.entry.ResourceEntry;\n import jadx.tests.api.compiler.DynamicCompiler;\n+import jadx.tests.api.compiler.JavaUtils;\n import jadx.tests.api.compiler.StaticCompiler;\n import jadx.tests.api.utils.TestUtils;\n \n@@ -490,6 +491,7 @@ protected void useEclipseCompiler() {\n \t}\n \n \tprotected void useTargetJavaVersion(int version) {\n+\t\tAssumptions.assumeTrue(JavaUtils.checkJavaVersion(version), \"skip test for higher java version\");\n \t\tthis.targetJavaVersion = version;\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConcatJava11.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConcatJava11.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConcatJava11.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConcatJava11.java\n@@ -3,6 +3,8 @@\n import org.junit.jupiter.api.Test;\n \n import jadx.tests.api.RaungTest;\n+import jadx.tests.api.extensions.inputs.InputPlugin;\n+import jadx.tests.api.extensions.inputs.TestWithInputPlugins;\n \n import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n \n@@ -40,7 +42,7 @@ public void test() {\n \t}\n \n \t@Test\n-\tpublic void testJava() {\n+\tpublic void testJava8() {\n \t\tnoDebugInfo();\n \t\tassertThat(getClassNode(TestCls.class))\n \t\t\t\t.code()\n@@ -49,4 +51,14 @@ public void testJava() {\n \t\t\t\t\t\t\"return str + \\\"test\\\" + str + 7;\",\n \t\t\t\t\t\t\"return str + \\\"test\\\" + str + \\\"7\\\";\"); // dynamic concat add const to string recipe\n \t}\n+\n+\t@TestWithInputPlugins({ InputPlugin.DEX, InputPlugin.JAVA })\n+\tpublic void testJava11() {\n+\t\tuseTargetJavaVersion(11);\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"return str + \\\"test\\\";\")\n+\t\t\t\t.containsOne(\"return str + \\\"test\\\" + str + \\\"7\\\";\");\n+\t}\n }\n\ndiff --git a/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java b/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n--- a/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n+++ b/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n@@ -158,9 +158,13 @@ private static void convertSimpleJar(ConvertResult result, Path path) throws Exc\n \n \t\ttry {\n \t\t\tDxConverter.run(path, tempDirectory);\n-\t\t} catch (Exception e) {\n+\t\t} catch (Throwable e) {\n \t\t\tLOG.warn(\"DX convert failed, trying D8, path: {}\", path);\n-\t\t\tD8Converter.run(path, tempDirectory);\n+\t\t\ttry {\n+\t\t\t\tD8Converter.run(path, tempDirectory);\n+\t\t\t} catch (Throwable ex) {\n+\t\t\t\tLOG.error(\"D8 convert failed: {}\", ex.getMessage());\n+\t\t\t}\n \t\t}\n \n \t\tLOG.debug(\"Converted to dex: {}\", path.toAbsolutePath());",
    "output": "Fix handle move-result after invoke-custom with string concat"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n@@ -59,6 +59,11 @@ public RegisterArg getAssign() {\n \t\treturn assign;\n \t}\n \n+\t@Nullable\n+\tpublic InsnNode getAssignInsn() {\n+\t\treturn assign.getParentInsn();\n+\t}\n+\n \tpublic void setAssign(@NotNull RegisterArg assign) {\n \t\tthis.assign = assign;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/DeboxingVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/DeboxingVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/DeboxingVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DeboxingVisitor.java\n@@ -137,6 +137,17 @@ private boolean canChangeTypeToPrimitive(RegisterArg arg) {\n \t\t\tif (ssaVar.isTypeImmutable()) {\n \t\t\t\treturn false;\n \t\t\t}\n+\t\t\tInsnNode assignInsn = ssaVar.getAssignInsn();\n+\t\t\tif (assignInsn == null) {\n+\t\t\t\t// method arg\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tInsnType assignInsnType = assignInsn.getType();\n+\t\t\tif (assignInsnType == InsnType.CONST || assignInsnType == InsnType.MOVE) {\n+\t\t\t\tif (assignInsn.getArg(0).getType().isObject()) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tfor (RegisterArg useArg : ssaVar.getUseList()) {\n \t\t\t\tInsnNode parentInsn = useArg.getParentInsn();\n \t\t\t\tif (parentInsn == null) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockExceptionHandler.java\n@@ -49,6 +49,7 @@ public static boolean process(MethodNode mth) {\n \t\tif (mth.isNoExceptionHandlers()) {\n \t\t\treturn false;\n \t\t}\n+\t\tBlockProcessor.updateCleanSuccessors(mth);\n \t\tBlockProcessor.computeDominanceFrontier(mth);\n \n \t\tprocessCatchAttr(mth);\n@@ -394,16 +395,32 @@ private static BlockNode searchBottomBlock(MethodNode mth, List<BlockNode> block\n \t\t// not found -> blocks don't have same dominator\n \t\t// try to search common cross block outside input set\n \t\t// NOTE: bottom block not needed for exit nodes (no data flow from them)\n-\t\treturn BlockUtils.getPathCross(mth, blocks);\n+\t\tBlockNode pathCross = BlockUtils.getPathCross(mth, blocks);\n+\t\tif (pathCross == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<BlockNode> preds = new ArrayList<>(pathCross.getPredecessors());\n+\t\tpreds.removeAll(blocks);\n+\t\tList<BlockNode> outsidePredecessors = preds.stream()\n+\t\t\t\t.filter(p -> !BlockUtils.atLeastOnePathExists(blocks, p))\n+\t\t\t\t.collect(Collectors.toList());\n+\t\tif (outsidePredecessors.isEmpty()) {\n+\t\t\treturn pathCross;\n+\t\t}\n+\t\t// some predecessors outside of input set paths -> split block only for input set\n+\t\tBlockNode splitCross = BlockSplitter.blockSplitTop(mth, pathCross);\n+\t\tsplitCross.add(AFlag.SYNTHETIC);\n+\t\tfor (BlockNode outsidePredecessor : outsidePredecessors) {\n+\t\t\t// return predecessors to split bottom block (original)\n+\t\t\tBlockSplitter.replaceConnection(outsidePredecessor, splitCross, pathCross);\n+\t\t}\n+\t\treturn splitCross;\n \t}\n \n \tprivate static void connectSplittersAndHandlers(TryCatchBlockAttr tryCatchBlock, BlockNode topSplitterBlock,\n \t\t\t@Nullable BlockNode bottomSplitterBlock) {\n \t\tfor (ExceptionHandler handler : tryCatchBlock.getHandlers()) {\n \t\t\tBlockNode handlerBlock = handler.getHandlerBlock();\n-\t\t\tif (handlerBlock == null) {\n-\t\t\t\tSystem.out.println();\n-\t\t\t}\n \t\t\tBlockSplitter.connect(topSplitterBlock, handlerBlock);\n \t\t\tif (bottomSplitterBlock != null) {\n \t\t\t\tBlockSplitter.connect(bottomSplitterBlock, handlerBlock);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocks/BlockProcessor.java\n@@ -76,7 +76,7 @@ private static void processBlocksTree(MethodNode mth) {\n \t\tmth.finishBasicBlocks();\n \t}\n \n-\tprivate static void updateCleanSuccessors(MethodNode mth) {\n+\tstatic void updateCleanSuccessors(MethodNode mth) {\n \t\tmth.getBasicBlocks().forEach(BlockNode::updateCleanSuccessors);\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -524,7 +524,22 @@ private static boolean traverseSuccessorsUntil(BlockNode from, BlockNode until,\n \t\treturn false;\n \t}\n \n-\tpublic static boolean isPathExists(Collection<BlockNode> startBlocks, BlockNode end) {\n+\t/**\n+\t * Search at least one path from startBlocks to end\n+\t */\n+\tpublic static boolean atLeastOnePathExists(Collection<BlockNode> startBlocks, BlockNode end) {\n+\t\tfor (BlockNode startBlock : startBlocks) {\n+\t\t\tif (isPathExists(startBlock, end)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Check if exist path from every startBlocks to end\n+\t */\n+\tpublic static boolean isAllPathExists(Collection<BlockNode> startBlocks, BlockNode end) {\n \t\tfor (BlockNode startBlock : startBlocks) {\n \t\t\tif (!isPathExists(startBlock, end)) {\n \t\t\t\treturn false;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n@@ -53,6 +53,12 @@ public static void dump(MethodNode mth) {\n \t\tdump(mth, \"dump\");\n \t}\n \n+\tpublic static void dumpRaw(MethodNode mth, String desc, Predicate<MethodNode> dumpCondition) {\n+\t\tif (dumpCondition.test(mth)) {\n+\t\t\tdumpRaw(mth, desc);\n+\t\t}\n+\t}\n+\n \tpublic static void dumpRaw(MethodNode mth, String desc) {\n \t\tFile out = new File(\"test-graph-\" + desc + \"-tmp\");\n \t\tDotGraphVisitor.dumpRaw().save(out, mth);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch9.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch9.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch9.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch9.java\n@@ -0,0 +1,44 @@\n+package jadx.tests.integration.trycatch;\n+\n+import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.extensions.inputs.InputPlugin;\n+import jadx.tests.api.extensions.inputs.TestWithInputPlugins;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestTryCatch9 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic Integer test(final Integer i) {\n+\t\t\tif (i == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tInteger res = null;\n+\t\t\ttry {\n+\t\t\t\tif (i == 5) {\n+\t\t\t\t\tres = 4;\n+\t\t\t\t} else {\n+\t\t\t\t\tres = 9;\n+\t\t\t\t}\n+\t\t\t} catch (final Exception ex) {\n+\t\t\t\tlogError(ex);\n+\t\t\t}\n+\t\t\treturn res;\n+\t\t}\n+\n+\t\tprivate void logError(Exception ex) {\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(test(5)).isEqualTo(4);\n+\t\t}\n+\t}\n+\n+\t@TestWithInputPlugins({ InputPlugin.DEX, InputPlugin.JAVA })\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"logError(ex);\")\n+\t\t\t\t.containsOne(\"Integer res = null;\");\n+\t}\n+}",
    "output": "Fix improve try/catch bounds detection"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -948,7 +948,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t\t}\n \t\t};\n \t\tforwardAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"nav.forward\"));\n-\t\tforwardAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_RIGHT, KeyEvent.ALT_DOWN_MASK));\n+\t\tforwardAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_RIGHT, KeyEvent.ALT_DOWN_MASK, SystemInfo.IS_MAC));\n \n \t\tAction quarkAction = new AbstractAction(\"Quark Engine\", ICON_QUARK) {\n \t\t\t@Override",
    "output": "Fix forward navigation shortcut on macOS"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java\n@@ -3,6 +3,7 @@\n import java.util.List;\n import java.util.Map;\n \n+import com.google.gson.JsonElement;\n import com.google.gson.annotations.SerializedName;\n \n import jadx.core.utils.Utils;\n@@ -15,7 +16,7 @@ public static class Crime {\n \t\tpublic List<String> permissions;\n \n \t\tList<Method> native_api;\n-\t\tList<String[]> combination;\n+\t\tList<JsonElement> combination;\n \t\tList<Map<String, InvokePlace>> register;\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java\n@@ -32,6 +32,8 @@\n import org.slf4j.LoggerFactory;\n \n import com.beust.jcommander.Strings;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n \n import jadx.api.JavaClass;\n import jadx.api.JavaMethod;\n@@ -246,13 +248,15 @@ private void addDetails() {\n \t\t\t\t}\n \t\t\t\tadd(node);\n \t\t\t}\n-\t\t\tList<String[]> combination = crime.combination;\n-\t\t\tif (Utils.notEmpty(combination)) {\n+\t\t\tList<JsonElement> combination = crime.combination;\n+\t\t\tif (Utils.notEmpty(combination) && combination.get(0) instanceof JsonArray) {\n \t\t\t\tTextTreeNode node = new TextTreeNode(\"Combination\");\n \t\t\t\tint size = combination.size();\n \t\t\t\tfor (int i = 0; i < size; i++) {\n \t\t\t\t\tTextTreeNode set = new TextTreeNode(\"Set \" + i);\n-\t\t\t\t\tfor (String mth : combination.get(i)) {\n+\t\t\t\t\tJsonArray array = (JsonArray) combination.get(i);\n+\t\t\t\t\tfor (JsonElement ele : array) {\n+\t\t\t\t\t\tString mth = ele.getAsString();\n \t\t\t\t\t\tset.add(resolveMethod(mth));\n \t\t\t\t\t}\n \t\t\t\t\tnode.add(set);",
    "output": "Fix update Quark report parsing"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -413,6 +413,10 @@ private void loadJavaClass(JavaClass javaClass) {\n \t\t\tclassesMap.put(innerCls.getClassNode(), innerCls);\n \t\t\tloadJavaClass(innerCls);\n \t\t}\n+\t\tfor (JavaClass inlinedCls : javaClass.getInlinedClasses()) {\n+\t\t\tclassesMap.put(inlinedCls.getClassNode(), inlinedCls);\n+\t\t\tloadJavaClass(inlinedCls);\n+\t\t}\n \t}\n \n \t/**\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JavaClass.java b/jadx-core/src/main/java/jadx/api/JavaClass.java\n--- a/jadx-core/src/main/java/jadx/api/JavaClass.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java\n@@ -23,6 +23,7 @@ public final class JavaClass implements JavaNode {\n \tprivate final JavaClass parent;\n \n \tprivate List<JavaClass> innerClasses = Collections.emptyList();\n+\tprivate List<JavaClass> inlinedClasses = Collections.emptyList();\n \tprivate List<JavaField> fields = Collections.emptyList();\n \tprivate List<JavaMethod> methods = Collections.emptyList();\n \tprivate boolean listsLoaded;\n@@ -100,13 +101,23 @@ private synchronized void loadLists() {\n \t\t\t}\n \t\t\tthis.innerClasses = Collections.unmodifiableList(list);\n \t\t}\n+\t\tint inlinedClsCount = cls.getInlinedClasses().size();\n+\t\tif (inlinedClsCount != 0) {\n+\t\t\tList<JavaClass> list = new ArrayList<>(inlinedClsCount);\n+\t\t\tfor (ClassNode inner : cls.getInlinedClasses()) {\n+\t\t\t\tJavaClass javaClass = rootDecompiler.convertClassNode(inner);\n+\t\t\t\tjavaClass.loadLists();\n+\t\t\t\tlist.add(javaClass);\n+\t\t\t}\n+\t\t\tthis.inlinedClasses = Collections.unmodifiableList(list);\n+\t\t}\n \n \t\tint fieldsCount = cls.getFields().size();\n \t\tif (fieldsCount != 0) {\n \t\t\tList<JavaField> flds = new ArrayList<>(fieldsCount);\n \t\t\tfor (FieldNode f : cls.getFields()) {\n \t\t\t\tif (!f.contains(AFlag.DONT_GENERATE)) {\n-\t\t\t\t\tJavaField javaField = new JavaField(f, this);\n+\t\t\t\t\tJavaField javaField = new JavaField(this, f);\n \t\t\t\t\tflds.add(javaField);\n \t\t\t\t}\n \t\t\t}\n@@ -254,6 +265,11 @@ public List<JavaClass> getInnerClasses() {\n \t\treturn innerClasses;\n \t}\n \n+\tpublic List<JavaClass> getInlinedClasses() {\n+\t\tloadLists();\n+\t\treturn inlinedClasses;\n+\t}\n+\n \tpublic List<JavaField> getFields() {\n \t\tloadLists();\n \t\treturn fields;\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JavaField.java b/jadx-core/src/main/java/jadx/api/JavaField.java\n--- a/jadx-core/src/main/java/jadx/api/JavaField.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaField.java\n@@ -13,7 +13,7 @@ public final class JavaField implements JavaNode {\n \tprivate final FieldNode field;\n \tprivate final JavaClass parent;\n \n-\tJavaField(FieldNode f, JavaClass cls) {\n+\tJavaField(JavaClass cls, FieldNode f) {\n \t\tthis.field = f;\n \t\tthis.parent = cls;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -557,6 +557,10 @@ public List<ClassNode> getInnerClasses() {\n \t\treturn innerClasses;\n \t}\n \n+\tpublic List<ClassNode> getInlinedClasses() {\n+\t\treturn inlinedClasses;\n+\t}\n+\n \t/**\n \t * Get all inner and inlined classes recursively\n \t *",
    "output": "Fix include inlined classes in usage search"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n@@ -109,7 +109,7 @@ public String decodeValue(int dataType, int data) {\n \t\t\tcase TYPE_INT_DEC:\n \t\t\t\treturn Integer.toString(data);\n \t\t\tcase TYPE_INT_HEX:\n-\t\t\t\treturn Integer.toHexString(data);\n+\t\t\t\treturn \"0x\" + Integer.toHexString(data);\n \t\t\tcase TYPE_INT_BOOLEAN:\n \t\t\t\treturn data == 0 ? \"false\" : \"true\";\n \t\t\tcase TYPE_FLOAT:",
    "output": "Fix binary xml hexadecimal int value decoding"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -108,6 +108,10 @@ private void initialLoad(IClassData cls) {\n \t\t\tListConsumer<IFieldData, FieldNode> fieldsConsumer = new ListConsumer<>(fld -> FieldNode.build(this, fld));\n \t\t\tListConsumer<IMethodData, MethodNode> methodsConsumer = new ListConsumer<>(mth -> MethodNode.build(this, mth));\n \t\t\tcls.visitFieldsAndMethods(fieldsConsumer, methodsConsumer);\n+\t\t\tif (this.fields != null && this.methods != null) {\n+\t\t\t\t// TODO: temporary solution for restore usage info in reloaded methods and fields\n+\t\t\t\trestoreUsageData(this.fields, this.methods, fieldsConsumer.getResult(), methodsConsumer.getResult());\n+\t\t\t}\n \t\t\tthis.fields = fieldsConsumer.getResult();\n \t\t\tthis.methods = methodsConsumer.getResult();\n \n@@ -124,6 +128,24 @@ private void initialLoad(IClassData cls) {\n \t\t}\n \t}\n \n+\tprivate void restoreUsageData(List<FieldNode> oldFields, List<MethodNode> oldMethods,\n+\t\t\tList<FieldNode> newFields, List<MethodNode> newMethods) {\n+\t\tMap<FieldInfo, FieldNode> oldFieldMap = Utils.groupBy(oldFields, FieldNode::getFieldInfo);\n+\t\tfor (FieldNode newField : newFields) {\n+\t\t\tFieldNode oldField = oldFieldMap.get(newField.getFieldInfo());\n+\t\t\tif (oldField != null) {\n+\t\t\t\tnewField.setUseIn(oldField.getUseIn());\n+\t\t\t}\n+\t\t}\n+\t\tMap<MethodInfo, MethodNode> oldMethodsMap = Utils.groupBy(oldMethods, MethodNode::getMethodInfo);\n+\t\tfor (MethodNode newMethod : newMethods) {\n+\t\t\tMethodNode oldMethod = oldMethodsMap.get(newMethod.getMethodInfo());\n+\t\t\tif (oldMethod != null) {\n+\t\t\t\tnewMethod.setUseIn(oldMethod.getUseIn());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tprivate ArgType checkSuperType(IClassData cls) {\n \t\tString superType = cls.getSuperType();\n \t\tif (superType == null) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/Utils.java b/jadx-core/src/main/java/jadx/core/utils/Utils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/Utils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java\n@@ -315,6 +315,21 @@ public static <K, V> Map<K, V> mergeMaps(Map<K, V> first, Map<K, V> second) {\n \t\treturn result;\n \t}\n \n+\t/**\n+\t * Build map from list of values with value to key mapping function\n+\t * <br>\n+\t * Similar to:\n+\t * <br>\n+\t * {@code list.stream().collect(Collectors.toMap(mapKey, Function.identity())); }\n+\t */\n+\tpublic static <K, V> Map<K, V> groupBy(List<V> list, Function<V, K> mapKey) {\n+\t\tMap<K, V> map = new HashMap<>(list.size());\n+\t\tfor (V v : list) {\n+\t\t\tmap.put(mapKey.apply(v), v);\n+\t\t}\n+\t\treturn map;\n+\t}\n+\n \t@Nullable\n \tpublic static <T> T getOne(@Nullable List<T> list) {\n \t\tif (list == null || list.size() != 1) {",
    "output": "Fix restore usage data after class reload"
  },
  {
    "input": "diff --git a/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/input/data/annotations/EncodedValue.java b/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/input/data/annotations/EncodedValue.java\n--- a/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/input/data/annotations/EncodedValue.java\n+++ b/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/input/data/annotations/EncodedValue.java\n@@ -5,8 +5,9 @@\n import jadx.api.plugins.input.data.attributes.IJadxAttrType;\n import jadx.api.plugins.input.data.attributes.IJadxAttribute;\n import jadx.api.plugins.input.data.attributes.JadxAttrType;\n+import jadx.api.plugins.input.data.attributes.PinnedAttribute;\n \n-public class EncodedValue implements IJadxAttribute {\n+public class EncodedValue extends PinnedAttribute {\n \tpublic static final EncodedValue NULL = new EncodedValue(EncodedType.ENCODED_NULL, null);\n \n \tprivate final EncodedType type;",
    "output": "Fix don't unload field init values"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java b/jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java\n@@ -202,12 +202,14 @@ private void filter(JResource resNode, ZipFile zip) {\n \t\t\t\t} else {\n \t\t\t\t\tresNodes.add(resNode);\n \t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tLOG.debug(\"Resource skipped because of size limit: {} res size {} bytes\", resNode, size);\n \t\t\t}\n \t\t}\n \t}\n \n \tprivate void refreshSettings() {\n-\t\tint size = cache.getJadxSettings().getSrhResourceSkipSize() * 10240;\n+\t\tint size = cache.getJadxSettings().getSrhResourceSkipSize() * 1048576;\n \t\tif (size != sizeLimit\n \t\t\t\t|| !cache.getJadxSettings().getSrhResourceFileExt().equals(fileExts)) {\n \t\t\tclear();\n@@ -224,14 +226,10 @@ private void refreshSettings() {\n \t\t\t\t\textSet.add(ext);\n \t\t\t\t}\n \t\t\t}\n-\t\t\ttry {\n-\t\t\t\tZipFile zipFile = getZipFile(cache.getJRoot());\n+\t\t\ttry (ZipFile zipFile = getZipFile(cache.getJRoot())) {\n \t\t\t\ttraverseTree(cache.getJRoot(), zipFile); // reindex\n-\t\t\t\tif (zipFile != null) {\n-\t\t\t\t\tzipFile.close();\n-\t\t\t\t}\n \t\t\t} catch (Exception e) {\n-\t\t\t\te.printStackTrace();\n+\t\t\t\tLOG.error(\"Failed to apply settings to resource index\", e);\n \t\t\t}\n \t\t}\n \t}",
    "output": "Fix configured resource indexing size limit is now correctly considered"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n@@ -7,6 +7,7 @@\n import org.jetbrains.annotations.Nullable;\n \n import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n@@ -249,6 +250,11 @@ public void notInner(RootNode root) {\n \t\tsplitAndApplyNames(root, type, false);\n \t}\n \n+\tpublic void convertToInner(ClassNode parent) {\n+\t\tthis.parentClass = parent.getClassInfo();\n+\t\tsplitAndApplyNames(parent.root(), type, true);\n+\t}\n+\n \tpublic void updateNames(RootNode root) {\n \t\tsplitAndApplyNames(root, type, isInner());\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -179,18 +179,27 @@ private int getAccessFlags(IClassData cls) {\n \t}\n \n \tpublic static ClassNode addSyntheticClass(RootNode root, String name, int accessFlags) {\n-\t\tClassNode cls = new ClassNode(root, name, accessFlags);\n+\t\tClassInfo clsInfo = ClassInfo.fromName(root, name);\n+\t\tClassNode existCls = root.resolveClass(clsInfo);\n+\t\tif (existCls != null) {\n+\t\t\tthrow new JadxRuntimeException(\"Class already exist: \" + name);\n+\t\t}\n+\t\treturn addSyntheticClass(root, clsInfo, accessFlags);\n+\t}\n+\n+\tpublic static ClassNode addSyntheticClass(RootNode root, ClassInfo clsInfo, int accessFlags) {\n+\t\tClassNode cls = new ClassNode(root, clsInfo, accessFlags);\n \t\tcls.add(AFlag.SYNTHETIC);\n \t\tcls.setState(ProcessState.PROCESS_COMPLETE);\n \t\troot.addClassNode(cls);\n \t\treturn cls;\n \t}\n \n \t// Create empty class\n-\tprivate ClassNode(RootNode root, String name, int accessFlags) {\n+\tprivate ClassNode(RootNode root, ClassInfo clsInfo, int accessFlags) {\n \t\tthis.root = root;\n \t\tthis.clsData = null;\n-\t\tthis.clsInfo = ClassInfo.fromName(root, name);\n+\t\tthis.clsInfo = clsInfo;\n \t\tthis.interfaces = new ArrayList<>();\n \t\tthis.methods = new ArrayList<>();\n \t\tthis.fields = new ArrayList<>();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n@@ -23,7 +23,6 @@\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.FieldNode;\n-import jadx.core.dex.nodes.ProcessState;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.xmlgen.ResourceStorage;\n import jadx.core.xmlgen.entry.ResourceEntry;\n@@ -40,25 +39,27 @@ private AndroidResourcesUtils() {\n \tpublic static ClassNode searchAppResClass(RootNode root, ResourceStorage resStorage) {\n \t\tString appPackage = root.getAppPackage();\n \t\tString fullName = appPackage != null ? appPackage + \".R\" : \"R\";\n-\t\tClassNode resCls = root.resolveClass(fullName);\n+\t\tClassInfo clsInfo = ClassInfo.fromName(root, fullName);\n+\t\tClassNode resCls = root.resolveClass(clsInfo);\n \t\tif (resCls != null) {\n \t\t\taddResourceFields(resCls, resStorage, true);\n \t\t\treturn resCls;\n \t\t}\n \t\tLOG.info(\"Can't find 'R' class in app package: {}\", appPackage);\n \t\tList<ClassNode> candidates = root.searchClassByShortName(\"R\");\n \t\tif (candidates.size() == 1) {\n-\t\t\tresCls = candidates.get(0);\n-\t\t\taddResourceFields(resCls, resStorage, true);\n-\t\t\treturn resCls;\n+\t\t\tClassNode resClsCandidate = candidates.get(0);\n+\t\t\taddResourceFields(resClsCandidate, resStorage, true);\n+\t\t\treturn resClsCandidate;\n \t\t}\n \t\tif (!candidates.isEmpty()) {\n \t\t\tLOG.info(\"Found several 'R' class candidates: {}\", candidates);\n \t\t}\n \t\tLOG.info(\"App 'R' class not found, put all resources ids into : '{}'\", fullName);\n-\t\tClassNode newResCls = makeClass(root, fullName, resStorage);\n-\t\taddResourceFields(newResCls, resStorage, false);\n-\t\treturn newResCls;\n+\t\tClassNode rCls = ClassNode.addSyntheticClass(root, clsInfo, AccessFlags.PUBLIC | AccessFlags.FINAL);\n+\t\trCls.addInfoComment(\"This class is generated by JADX\");\n+\t\taddResourceFields(rCls, resStorage, false);\n+\t\treturn rCls;\n \t}\n \n \tpublic static boolean handleAppResField(ICodeWriter code, ClassGen clsGen, ClassInfo declClass) {\n@@ -88,42 +89,52 @@ public static boolean isResourceClass(ClassNode cls) {\n \t\treturn parentClass != null && parentClass.getShortName().equals(\"R\");\n \t}\n \n-\tprivate static ClassNode makeClass(RootNode root, String clsName, ResourceStorage resStorage) {\n-\t\tClassNode rCls = ClassNode.addSyntheticClass(root, clsName, AccessFlags.PUBLIC | AccessFlags.FINAL);\n-\t\trCls.addInfoComment(\"This class is generated by JADX\");\n-\t\trCls.setState(ProcessState.PROCESS_COMPLETE);\n-\t\treturn rCls;\n+\tprivate static final class ResClsInfo {\n+\t\tprivate final ClassNode typeCls;\n+\t\tprivate final Map<String, FieldNode> fieldsMap = new HashMap<>();\n+\n+\t\tprivate ResClsInfo(ClassNode typeCls) {\n+\t\t\tthis.typeCls = typeCls;\n+\t\t}\n+\n+\t\tpublic ClassNode getTypeCls() {\n+\t\t\treturn typeCls;\n+\t\t}\n+\n+\t\tpublic Map<String, FieldNode> getFieldsMap() {\n+\t\t\treturn fieldsMap;\n+\t\t}\n \t}\n \n \tprivate static void addResourceFields(ClassNode resCls, ResourceStorage resStorage, boolean rClsExists) {\n \t\tMap<Integer, FieldNode> resFieldsMap = fillResFieldsMap(resCls);\n-\t\tMap<String, ClassNode> innerClsMap = new TreeMap<>();\n+\t\tMap<String, ResClsInfo> innerClsMap = new TreeMap<>();\n \t\tif (rClsExists) {\n \t\t\tfor (ClassNode innerClass : resCls.getInnerClasses()) {\n-\t\t\t\tinnerClsMap.put(innerClass.getShortName(), innerClass);\n+\t\t\t\tResClsInfo innerResCls = new ResClsInfo(innerClass);\n+\t\t\t\tinnerClass.getFields().forEach(field -> innerResCls.getFieldsMap().put(field.getName(), field));\n+\t\t\t\tinnerClsMap.put(innerClass.getShortName(), innerResCls);\n \t\t\t}\n \t\t}\n \t\tfor (ResourceEntry resource : resStorage.getResources()) {\n-\t\t\tfinal String resTypeName = resource.getTypeName();\n-\t\t\tClassNode typeCls = innerClsMap.computeIfAbsent(\n+\t\t\tString resTypeName = resource.getTypeName();\n+\t\t\tString resName = resTypeName.equals(\"style\") ? resource.getKeyName().replace('.', '_') : resource.getKeyName();\n+\n+\t\t\tResClsInfo typeClsInfo = innerClsMap.computeIfAbsent(\n \t\t\t\t\tresTypeName,\n-\t\t\t\t\tname -> addClassForResType(resCls, rClsExists, name));\n-\t\t\tfinal String resName;\n-\t\t\tif (\"style\".equals(resTypeName)) {\n-\t\t\t\tresName = resource.getKeyName().replace('.', '_');\n-\t\t\t} else {\n-\t\t\t\tresName = resource.getKeyName();\n-\t\t\t}\n-\t\t\tFieldNode rField = typeCls.searchFieldByName(resName);\n-\t\t\tif (rField == null) {\n+\t\t\t\t\tname -> getClassForResType(resCls, rClsExists, name));\n+\t\t\ttypeClsInfo.getFieldsMap().computeIfAbsent(resName, name -> {\n+\t\t\t\tClassNode typeCls = typeClsInfo.getTypeCls();\n \t\t\t\tFieldInfo rFieldInfo = FieldInfo.from(typeCls.root(), typeCls.getClassInfo(), resName, ArgType.INT);\n-\t\t\t\trField = new FieldNode(typeCls, rFieldInfo, AccessFlags.PUBLIC | AccessFlags.STATIC | AccessFlags.FINAL);\n-\t\t\t\trField.addAttr(new EncodedValue(EncodedType.ENCODED_INT, resource.getId()));\n-\t\t\t\ttypeCls.getFields().add(rField);\n+\t\t\t\tFieldNode newResField = new FieldNode(typeCls, rFieldInfo,\n+\t\t\t\t\t\tAccessFlags.PUBLIC | AccessFlags.STATIC | AccessFlags.FINAL);\n+\t\t\t\tnewResField.addAttr(new EncodedValue(EncodedType.ENCODED_INT, resource.getId()));\n+\t\t\t\ttypeCls.getFields().add(newResField);\n \t\t\t\tif (rClsExists) {\n-\t\t\t\t\trField.addInfoComment(\"Added by JADX\");\n+\t\t\t\t\tnewResField.addInfoComment(\"Added by JADX\");\n \t\t\t\t}\n-\t\t\t}\n+\t\t\t\treturn newResField;\n+\t\t\t});\n \t\t\tFieldNode fieldNode = resFieldsMap.get(resource.getId());\n \t\t\tif (fieldNode != null\n \t\t\t\t\t&& !fieldNode.getName().equals(resName)\n@@ -136,14 +147,27 @@ private static void addResourceFields(ClassNode resCls, ResourceStorage resStora\n \t}\n \n \t@NotNull\n-\tprivate static ClassNode addClassForResType(ClassNode resCls, boolean rClsExists, String typeName) {\n-\t\tClassNode newTypeCls = ClassNode.addSyntheticClass(resCls.root(), resCls.getFullName() + '$' + typeName,\n+\tprivate static ResClsInfo getClassForResType(ClassNode resCls, boolean rClsExists, String typeName) {\n+\t\tString clsFullName = resCls.getFullName() + '$' + typeName;\n+\t\tClassInfo clsInfo = ClassInfo.fromName(resCls.root(), clsFullName);\n+\t\tClassNode existCls = resCls.root().resolveClass(clsInfo);\n+\t\tif (existCls != null) {\n+\t\t\tif (!rClsExists && !existCls.isInner()) {\n+\t\t\t\t// convert found res cls to inner for R class\n+\t\t\t\texistCls.getClassInfo().convertToInner(resCls);\n+\t\t\t\tresCls.addInnerClass(existCls);\n+\t\t\t}\n+\t\t\tResClsInfo resClsInfo = new ResClsInfo(existCls);\n+\t\t\texistCls.getFields().forEach(field -> resClsInfo.getFieldsMap().put(field.getName(), field));\n+\t\t\treturn resClsInfo;\n+\t\t}\n+\t\tClassNode newTypeCls = ClassNode.addSyntheticClass(resCls.root(), clsInfo,\n \t\t\t\tAccessFlags.PUBLIC | AccessFlags.STATIC | AccessFlags.FINAL);\n \t\tresCls.addInnerClass(newTypeCls);\n \t\tif (rClsExists) {\n \t\t\tnewTypeCls.addInfoComment(\"Added by JADX\");\n \t\t}\n-\t\treturn newTypeCls;\n+\t\treturn new ResClsInfo(newTypeCls);\n \t}\n \n \t@NotNull",
    "output": "Fix check if inner classes for missing R class already exist"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -419,7 +419,11 @@ private void loadJavaClass(JavaClass javaClass) {\n \t * Get JavaClass by ClassNode without loading and decompilation\n \t */\n \tJavaClass convertClassNode(ClassNode cls) {\n-\t\treturn classesMap.computeIfAbsent(cls, node -> {\n+\t\treturn classesMap.compute(cls, (node, prevJavaCls) -> {\n+\t\t\tif (prevJavaCls != null && prevJavaCls.getClassNode() == cls) {\n+\t\t\t\t// keep previous variable\n+\t\t\t\treturn prevJavaCls;\n+\t\t\t}\n \t\t\tif (cls.isInner()) {\n \t\t\t\treturn new JavaClass(cls, convertClassNode(cls.getParentClass()));\n \t\t\t}\n@@ -431,7 +435,7 @@ JavaClass convertClassNode(ClassNode cls) {\n \t@ApiStatus.Internal\n \tpublic JavaClass getJavaClassByNode(ClassNode cls) {\n \t\tJavaClass javaClass = classesMap.get(cls);\n-\t\tif (javaClass != null) {\n+\t\tif (javaClass != null && javaClass.getClassNode() == cls) {\n \t\t\treturn javaClass;\n \t\t}\n \t\t// load parent class if inner\n@@ -461,7 +465,7 @@ public JavaClass getJavaClassByNode(ClassNode cls) {\n \t@Nullable\n \tprivate JavaMethod getJavaMethodByNode(MethodNode mth) {\n \t\tJavaMethod javaMethod = methodsMap.get(mth);\n-\t\tif (javaMethod != null) {\n+\t\tif (javaMethod != null && javaMethod.getMethodNode() == mth) {\n \t\t\treturn javaMethod;\n \t\t}\n \t\tif (mth.contains(AFlag.DONT_GENERATE)) {\n@@ -486,7 +490,7 @@ private JavaMethod getJavaMethodByNode(MethodNode mth) {\n \t@Nullable\n \tprivate JavaField getJavaFieldByNode(FieldNode fld) {\n \t\tJavaField javaField = fieldsMap.get(fld);\n-\t\tif (javaField != null) {\n+\t\tif (javaField != null && javaField.getFieldNode() == fld) {\n \t\t\treturn javaField;\n \t\t}\n \t\t// parent class not loaded yet\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n@@ -17,6 +17,7 @@\n import jadx.gui.ui.TabbedPane;\n import jadx.gui.ui.codearea.ClassCodeContentPanel;\n import jadx.gui.ui.panel.ContentPanel;\n+import jadx.gui.utils.CacheObject;\n import jadx.gui.utils.NLS;\n import jadx.gui.utils.UiUtils;\n \n@@ -71,13 +72,18 @@ public synchronized void load() {\n \t\tupdate();\n \t}\n \n-\tpublic synchronized void reload() {\n+\tpublic synchronized void reload(CacheObject cache) {\n+\t\tcache.getNodeCache().removeWholeClass(cls);\n+\t\tcache.getIndexService().remove(cls);\n \t\tcls.reload();\n \t\tloaded = true;\n \t\tupdate();\n+\t\tcache.getIndexService().indexCls(cls);\n \t}\n \n-\tpublic synchronized void unload() {\n+\tpublic synchronized void unload(CacheObject cache) {\n+\t\tcache.getNodeCache().removeWholeClass(cls);\n+\t\tcache.getIndexService().remove(cls);\n \t\tcls.unload();\n \t\tloaded = false;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -254,8 +254,7 @@ private void handleSelectClassOption() {\n \t\t\t\t\t\tNLS.str(\"error_dialog.title\"), JOptionPane.ERROR_MESSAGE);\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\tJNode node = cacheObject.getNodeCache().makeFrom(javaNode);\n-\t\t\ttabbedPane.codeJump(new JumpPosition(node.getRootClass(), node.getLine(), JumpPosition.getDefPos(node)));\n+\t\t\ttabbedPane.codeJump(cacheObject.getNodeCache().makeFrom(javaNode));\n \t\t}\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n@@ -218,8 +218,11 @@ public void selectTab(ContentPanel contentPanel) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Jump to node definition\n+\t */\n \tpublic void codeJump(JNode node) {\n-\t\tcodeJump(new JumpPosition(node));\n+\t\tcodeJump(new JumpPosition(Objects.requireNonNull(node)));\n \t}\n \n \tpublic void codeJump(JumpPosition pos) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n@@ -171,7 +171,7 @@ public JumpPosition getDefPosForNodeAtOffset(int offset) {\n \t\t\treturn null;\n \t\t}\n \t\tJNode jNode = convertJavaNode(foundNode);\n-\t\treturn new JumpPosition(jNode.getRootClass(), pos.getLine(), JumpPosition.getDefPos(jNode));\n+\t\treturn new JumpPosition(jNode.getRootClass(), pos);\n \t}\n \n \tprivate JNode convertJavaNode(JavaNode javaNode) {\n@@ -252,8 +252,7 @@ public void refreshClass() {\n \t\t\t\tCaretPositionFix caretFix = new CaretPositionFix(this);\n \t\t\t\tcaretFix.save();\n \n-\t\t\t\tcls.reload();\n-\t\t\t\tgetMainWindow().getCacheObject().getIndexService().refreshIndex(cls.getCls());\n+\t\t\t\tcls.reload(getMainWindow().getCacheObject());\n \n \t\t\t\tClassCodeContentPanel codeContentPanel = (ClassCodeContentPanel) this.contentPanel;\n \t\t\t\tcodeContentPanel.getTabbedPane().refresh(cls);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n@@ -42,7 +42,6 @@\n import jadx.core.dex.visitors.rename.RenameVisitor;\n import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n-import jadx.gui.jobs.IndexService;\n import jadx.gui.jobs.TaskStatus;\n import jadx.gui.settings.JadxProject;\n import jadx.gui.treemodel.JClass;\n@@ -222,26 +221,23 @@ private void processPackage(List<JavaNode> toUpdate) {\n \t}\n \n \tprivate void refreshClasses(Set<JClass> updatedTopClasses) {\n-\t\tIndexService indexService = cache.getIndexService();\n \t\tif (updatedTopClasses.size() < 10) {\n \t\t\t// small batch => reload\n \t\t\tLOG.debug(\"Classes to reload: {}\", updatedTopClasses.size());\n \t\t\tfor (JClass cls : updatedTopClasses) {\n \t\t\t\ttry {\n-\t\t\t\t\tcls.reload();\n-\t\t\t\t\tindexService.refreshIndex(cls.getCls());\n+\t\t\t\t\tcls.reload(cache);\n \t\t\t\t} catch (Exception e) {\n \t\t\t\t\tLOG.error(\"Failed to reload class: {}\", cls.getFullName(), e);\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\t// big batch => unload\n \t\t\tLOG.debug(\"Classes to unload: {}\", updatedTopClasses.size());\n-\t\t\tindexService.setComplete(false);\n+\t\t\tcache.getIndexService().setComplete(false);\n \t\t\tfor (JClass cls : updatedTopClasses) {\n \t\t\t\ttry {\n-\t\t\t\t\tcls.unload();\n-\t\t\t\t\tindexService.remove(cls.getCls());\n+\t\t\t\t\tcls.unload(cache);\n \t\t\t\t} catch (Exception e) {\n \t\t\t\t\tLOG.error(\"Failed to unload class: {}\", cls.getFullName(), e);\n \t\t\t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n@@ -45,7 +45,6 @@ public UsageDialog(MainWindow mainWindow, JNode node) {\n \n \t@Override\n \tprotected void openInit() {\n-\t\tusageList = new ArrayList<>();\n \t\tmainWindow.getBackgroundExecutor().execute(NLS.str(\"progress.load\"),\n \t\t\t\tthis::collectUsageData,\n \t\t\t\t(status) -> {\n@@ -59,6 +58,7 @@ protected void openInit() {\n \t}\n \n \tprivate void collectUsageData() {\n+\t\tusageList = new ArrayList<>();\n \t\tnode.getJavaNode().getUseIn()\n \t\t\t\t.stream()\n \t\t\t\t.map(JavaNode::getTopParentClass)\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/JNodeCache.java b/jadx-gui/src/main/java/jadx/gui/utils/JNodeCache.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/JNodeCache.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/JNodeCache.java\n@@ -25,7 +25,7 @@ public JNode makeFrom(JavaNode javaNode) {\n \t\t}\n \t\t// don't use 'computeIfAbsent' method here, it this cause 'Recursive update' exception\n \t\tJNode jNode = cache.get(javaNode);\n-\t\tif (jNode == null) {\n+\t\tif (jNode == null || jNode.getJavaNode() != javaNode) {\n \t\t\tjNode = convert(javaNode);\n \t\t\tcache.put(javaNode, jNode);\n \t\t}\n@@ -37,13 +37,23 @@ public JClass makeFrom(JavaClass javaCls) {\n \t\t\treturn null;\n \t\t}\n \t\tJClass jCls = (JClass) cache.get(javaCls);\n-\t\tif (jCls == null) {\n+\t\tif (jCls == null || jCls.getCls() != javaCls) {\n \t\t\tjCls = convert(javaCls);\n \t\t\tcache.put(javaCls, jCls);\n \t\t}\n \t\treturn jCls;\n \t}\n \n+\tpublic void remove(JavaNode javaNode) {\n+\t\tcache.remove(javaNode);\n+\t}\n+\n+\tpublic void removeWholeClass(JavaClass javaCls) {\n+\t\tremove(javaCls);\n+\t\tjavaCls.getMethods().forEach(this::remove);\n+\t\tjavaCls.getFields().forEach(this::remove);\n+\t}\n+\n \tprivate JClass convert(JavaClass cls) {\n \t\tJavaClass parentCls = cls.getDeclaringClass();\n \t\tif (parentCls == cls) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/JumpPosition.java b/jadx-gui/src/main/java/jadx/gui/utils/JumpPosition.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/JumpPosition.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/JumpPosition.java\n@@ -3,7 +3,6 @@\n import java.util.Objects;\n \n import jadx.api.CodePosition;\n-import jadx.api.JavaNode;\n import jadx.gui.treemodel.JNode;\n \n public class JumpPosition {\n@@ -41,14 +40,6 @@ public int getLine() {\n \t\treturn line;\n \t}\n \n-\tpublic static int getDefPos(JNode node) {\n-\t\tJavaNode javaNode = node.getJavaNode();\n-\t\tif (javaNode == null) {\n-\t\t\treturn -1;\n-\t\t}\n-\t\treturn javaNode.getDefPos();\n-\t}\n-\n \t@Override\n \tpublic boolean equals(Object obj) {\n \t\tif (this == obj) {\n@@ -58,7 +49,7 @@ public boolean equals(Object obj) {\n \t\t\treturn false;\n \t\t}\n \t\tJumpPosition position = (JumpPosition) obj;\n-\t\treturn line == position.line && node.equals(position.node) && pos == position.pos;\n+\t\treturn line == position.line && pos == position.pos && node.equals(position.node);\n \t}\n \n \t@Override",
    "output": "Use correct definition position on jump after code reload"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -43,7 +43,7 @@ public class JadxSettings extends JadxCLIArgs {\n \n \tprivate static final Path USER_HOME = Paths.get(System.getProperty(\"user.home\"));\n \tprivate static final int RECENT_PROJECTS_COUNT = 15;\n-\tprivate static final int CURRENT_SETTINGS_VERSION = 13;\n+\tprivate static final int CURRENT_SETTINGS_VERSION = 14;\n \n \tprivate static final Font DEFAULT_FONT = new RSyntaxTextArea().getFont();\n \n@@ -62,10 +62,10 @@ public class JadxSettings extends JadxCLIArgs {\n \tprivate String fontStr = \"\";\n \tprivate String smaliFontStr = \"\";\n \tprivate String editorThemePath = \"\";\n-\tprivate String lafTheme = LafManager.SYSTEM_THEME_NAME;\n+\tprivate String lafTheme = LafManager.INITIAL_THEME_NAME;\n \tprivate LangLocale langLocale = NLS.defaultLocale();\n \tprivate boolean autoStartJobs = false;\n-\tprotected String excludedPackages = \"\";\n+\tprivate String excludedPackages = \"\";\n \tprivate boolean autoSaveProject = false;\n \n \tprivate boolean showHeapUsageBar = false;\n@@ -130,6 +130,14 @@ public void fixOnLoad() {\n \t\t}\n \t}\n \n+\tpublic int getSettingsVersion() {\n+\t\treturn settingsVersion;\n+\t}\n+\n+\tpublic void setSettingsVersion(int settingsVersion) {\n+\t\tthis.settingsVersion = settingsVersion;\n+\t}\n+\n \tpublic String getCmdSelectClass() {\n \t\treturn cmdSelectClass;\n \t}\n@@ -635,6 +643,10 @@ private void upgradeSettings(int fromVersion) {\n \t\t\talwaysSelectOpened = false;\n \t\t\tfromVersion++;\n \t\t}\n+\t\tif (fromVersion == 13) {\n+\t\t\tlafTheme = LafManager.INITIAL_THEME_NAME;\n+\t\t\tfromVersion++;\n+\t\t}\n \t\tif (fromVersion != CURRENT_SETTINGS_VERSION) {\n \t\t\tthrow new JadxRuntimeException(\"Incorrect settings upgrade\");\n \t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java\n@@ -37,6 +37,7 @@ public boolean shouldSkipField(FieldAttributes f) {\n \t\t\treturn JadxSettings.SKIP_FIELDS.contains(f.getName())\n \t\t\t\t\t|| f.hasModifier(Modifier.PUBLIC)\n \t\t\t\t\t|| f.hasModifier(Modifier.TRANSIENT)\n+\t\t\t\t\t|| f.hasModifier(Modifier.STATIC)\n \t\t\t\t\t|| (f.getAnnotation(GsonExclude.class) != null);\n \t\t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/LafManager.java b/jadx-gui/src/main/java/jadx/gui/utils/LafManager.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/LafManager.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/LafManager.java\n@@ -1,31 +1,29 @@\n package jadx.gui.utils;\n \n-import java.util.ArrayList;\n-import java.util.Comparator;\n import java.util.LinkedHashMap;\n-import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n \n-import javax.swing.LookAndFeel;\n import javax.swing.UIManager;\n \n-import org.reflections.Reflections;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.formdev.flatlaf.FlatDarculaLaf;\n+import com.formdev.flatlaf.FlatDarkLaf;\n+import com.formdev.flatlaf.FlatIntelliJLaf;\n import com.formdev.flatlaf.FlatLaf;\n+import com.formdev.flatlaf.FlatLightLaf;\n import com.formdev.flatlaf.extras.FlatAnimatedLafChange;\n+import com.formdev.flatlaf.intellijthemes.FlatAllIJThemes;\n \n-import ch.qos.logback.classic.Level;\n-\n-import jadx.cli.LogHelper;\n import jadx.gui.settings.JadxSettings;\n \n public class LafManager {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(LafManager.class);\n \n \tpublic static final String SYSTEM_THEME_NAME = \"default\";\n+\tpublic static final String INITIAL_THEME_NAME = FlatLightLaf.NAME;\n+\n \tprivate static final Map<String, String> THEMES_MAP = initThemesMap();\n \n \tpublic static void init(JadxSettings settings) {\n@@ -66,28 +64,18 @@ private static boolean setupLaf(String themeClass) {\n \tprivate static Map<String, String> initThemesMap() {\n \t\tMap<String, String> map = new LinkedHashMap<>();\n \t\tmap.put(SYSTEM_THEME_NAME, SYSTEM_THEME_NAME);\n-\t\tfor (FlatLaf flatLafTheme : collectFlatLafThemes()) {\n-\t\t\tmap.put(flatLafTheme.getName(), flatLafTheme.getClass().getName());\n-\t\t}\n-\t\treturn map;\n-\t}\n \n-\tprivate static List<FlatLaf> collectFlatLafThemes() {\n-\t\tLogHelper.setLevelForPackage(\"org.reflections\", Level.WARN);\n-\t\tReflections reflections = new Reflections(\"com.formdev.flatlaf\");\n-\t\tSet<Class<? extends FlatLaf>> lafClasses = reflections.getSubTypesOf(FlatLaf.class);\n-\n-\t\tList<FlatLaf> themes = new ArrayList<>(lafClasses.size());\n-\t\tfor (Class<? extends FlatLaf> lafClass : lafClasses) {\n-\t\t\ttry {\n-\t\t\t\tthemes.add(lafClass.getDeclaredConstructor().newInstance());\n-\t\t\t} catch (Exception e) {\n-\t\t\t\t// some classes not themes, ignore them\n-\t\t\t\tLOG.trace(\"Failed make instance for class: {}\", lafClass.getName(), e);\n-\t\t\t}\n+\t\t// default flatlaf themes\n+\t\tmap.put(FlatLightLaf.NAME, FlatLightLaf.class.getName());\n+\t\tmap.put(FlatDarkLaf.NAME, FlatDarkLaf.class.getName());\n+\t\tmap.put(FlatIntelliJLaf.NAME, FlatIntelliJLaf.class.getName());\n+\t\tmap.put(FlatDarculaLaf.NAME, FlatDarculaLaf.class.getName());\n+\n+\t\t// themes from flatlaf-intellij-themes\n+\t\tfor (FlatAllIJThemes.FlatIJLookAndFeelInfo themeInfo : FlatAllIJThemes.INFOS) {\n+\t\t\tmap.put(themeInfo.getName(), themeInfo.getClassName());\n \t\t}\n-\t\tthemes.sort(Comparator.comparing(LookAndFeel::getName));\n-\t\treturn themes;\n+\t\treturn map;\n \t}\n \n \tprivate static boolean applyLaf(String theme) {",
    "output": "Fix collect FlatLaf themes without reflection"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -257,12 +257,13 @@ private List<Runnable> getSaveTasks(boolean saveSources, boolean saveResources)\n \t\t\tresOutDir = args.getOutDirRes();\n \t\t}\n \t\tList<Runnable> tasks = new ArrayList<>();\n-\t\tif (saveSources) {\n-\t\t\tappendSourcesSave(tasks, sourcesOutDir);\n-\t\t}\n+\t\t// save resources first because decompilation can hang or fail\n \t\tif (saveResources) {\n \t\t\tappendResourcesSaveTasks(tasks, resOutDir);\n \t\t}\n+\t\tif (saveSources) {\n+\t\t\tappendSourcesSave(tasks, sourcesOutDir);\n+\t\t}\n \t\treturn tasks;\n \t}",
    "output": "Fix save resources before decompilation"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n@@ -18,7 +18,9 @@\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.MethodOverrideAttr;\n+import jadx.core.dex.attributes.nodes.RenameReasonAttr;\n import jadx.core.dex.info.AccessInfo;\n+import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.IMethodDetails;\n@@ -65,8 +67,12 @@ private void processMth(ClassNode cls, List<ArgType> superTypes, MethodNode mth)\n \t\t\tmth.addAttr(attr);\n \t\t\tIMethodDetails baseMth = Utils.last(attr.getOverrideList());\n \t\t\tif (baseMth != null) {\n-\t\t\t\tfixMethodReturnType(mth, baseMth, superTypes);\n-\t\t\t\tfixMethodArgTypes(mth, baseMth, superTypes);\n+\t\t\t\tboolean updated = fixMethodReturnType(mth, baseMth, superTypes);\n+\t\t\t\tupdated |= fixMethodArgTypes(mth, baseMth, superTypes);\n+\t\t\t\tif (updated && cls.root().getArgs().isRenameValid()) {\n+\t\t\t\t\t// check if new signature cause method collisions\n+\t\t\t\t\tfixMethodSignatureCollisions(mth);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -248,14 +254,16 @@ private void addSuperType(RootNode root, Map<String, ArgType> superTypesMap, Arg\n \t\t}\n \t}\n \n-\tprivate void fixMethodReturnType(MethodNode mth, IMethodDetails baseMth, List<ArgType> superTypes) {\n+\tprivate boolean fixMethodReturnType(MethodNode mth, IMethodDetails baseMth, List<ArgType> superTypes) {\n \t\tArgType returnType = mth.getReturnType();\n \t\tif (returnType == ArgType.VOID) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n-\t\tif (updateReturnType(mth, baseMth, superTypes)) {\n+\t\tboolean updated = updateReturnType(mth, baseMth, superTypes);\n+\t\tif (updated) {\n \t\t\tmth.addInfoComment(\"Return type fixed from '\" + returnType + \"' to match base method\");\n \t\t}\n+\t\treturn updated;\n \t}\n \n \tprivate boolean updateReturnType(MethodNode mth, IMethodDetails baseMth, List<ArgType> superTypes) {\n@@ -283,15 +291,15 @@ private boolean updateReturnType(MethodNode mth, IMethodDetails baseMth, List<Ar\n \t\treturn false;\n \t}\n \n-\tprivate void fixMethodArgTypes(MethodNode mth, IMethodDetails baseMth, List<ArgType> superTypes) {\n+\tprivate boolean fixMethodArgTypes(MethodNode mth, IMethodDetails baseMth, List<ArgType> superTypes) {\n \t\tList<ArgType> mthArgTypes = mth.getArgTypes();\n \t\tList<ArgType> baseArgTypes = baseMth.getArgTypes();\n \t\tif (mthArgTypes.equals(baseArgTypes)) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tint argCount = mthArgTypes.size();\n \t\tif (argCount != baseArgTypes.size()) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tboolean changed = false;\n \t\tList<ArgType> newArgTypes = new ArrayList<>(argCount);\n@@ -307,6 +315,7 @@ private void fixMethodArgTypes(MethodNode mth, IMethodDetails baseMth, List<ArgT\n \t\tif (changed) {\n \t\t\tmth.updateArgTypes(newArgTypes, \"Method arguments types fixed to match base method\");\n \t\t}\n+\t\treturn changed;\n \t}\n \n \tprivate ArgType updateArgType(MethodNode mth, IMethodDetails baseMth, List<ArgType> superTypes, int argNum) {\n@@ -333,4 +342,38 @@ private ArgType updateArgType(MethodNode mth, IMethodDetails baseMth, List<ArgTy\n \t\t}\n \t\treturn null;\n \t}\n+\n+\tprivate void fixMethodSignatureCollisions(MethodNode mth) {\n+\t\tString mthName = mth.getMethodInfo().getAlias();\n+\t\tString newSignature = MethodInfo.makeShortId(mthName, mth.getArgTypes(), null);\n+\t\tfor (MethodNode otherMth : mth.getParentClass().getMethods()) {\n+\t\t\tString otherMthName = otherMth.getAlias();\n+\t\t\tif (otherMthName.equals(mthName) && otherMth != mth) {\n+\t\t\t\tString otherSignature = otherMth.getMethodInfo().makeSignature(true, false);\n+\t\t\t\tif (otherSignature.equals(newSignature)) {\n+\t\t\t\t\tif (otherMth.contains(AFlag.DONT_RENAME) || otherMth.contains(AType.METHOD_OVERRIDE)) {\n+\t\t\t\t\t\totherMth.addWarnComment(\"Can't rename method to resolve collision\");\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\totherMth.getMethodInfo().setAlias(makeNewAlias(otherMth));\n+\t\t\t\t\t\totherMth.addAttr(new RenameReasonAttr(\"avoid collision after fix types in other method\"));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// TODO: at this point deobfuscator is not available and map file already saved\n+\tprivate static String makeNewAlias(MethodNode mth) {\n+\t\tClassNode cls = mth.getParentClass();\n+\t\tString baseName = mth.getAlias();\n+\t\tint k = 2;\n+\t\twhile (true) {\n+\t\t\tString alias = baseName + k;\n+\t\t\tMethodNode methodNode = cls.searchMethodByShortName(alias);\n+\t\t\tif (methodNode == null) {\n+\t\t\t\treturn alias;\n+\t\t\t}\n+\t\t\tk++;\n+\t\t}\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n@@ -123,6 +123,7 @@ public void init() {\n \t\targs.setThreadsCount(1);\n \t\targs.setSkipResources(true);\n \t\targs.setFsCaseSensitive(false); // use same value on all systems\n+\t\targs.setCommentsLevel(CommentsLevel.DEBUG);\n \t}\n \n \t@AfterEach\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/generics/TestSyntheticOverride.java b/jadx-core/src/test/java/jadx/tests/integration/generics/TestSyntheticOverride.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/generics/TestSyntheticOverride.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/generics/TestSyntheticOverride.java\n@@ -0,0 +1,41 @@\n+package jadx.tests.integration.generics;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestSyntheticOverride extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tfinal class TestSyntheticOverride extends Lambda implements Function1<String, Unit> {\n+\n+\t\t\t// fixing method types to match interface (i.e Unit invoke(String str))\n+\t\t\t// make duplicate methods signatures\n+\t\t\tpublic bridge synthetic Object invoke(Object str) {\n+\t\t\t\tinvoke(str);\n+\t\t\t\treturn Unit.INSTANCE;\n+\t\t\t}\n+\n+\t\t\tpublic final void invoke(String str) {\n+\t\t\t\t...\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tallowWarnInCode();\n+\t\tdisableCompilation();\n+\t\tList<ClassNode> classNodes = loadFromSmaliFiles();\n+\t\tassertThat(searchCls(classNodes, \"TestSyntheticOverride\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"invoke(String str)\")\n+\t\t\t\t.containsOne(\"invoke2(String str)\");\n+\t}\n+}",
    "output": "Fix resolve methods collisions after type fix"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -1319,7 +1319,11 @@ private void restoreOpenTabs() {\n \t\tfor (EditorViewState viewState : openTabs) {\n \t\t\ttabbedPane.restoreEditorViewState(viewState);\n \t\t}\n-\t\ttabbedPane.setSelectedIndex(project.getActiveTab());\n+\t\ttry {\n+\t\t\ttabbedPane.setSelectedIndex(project.getActiveTab());\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.warn(\"Failed to restore active tab\", e);\n+\t\t}\n \t}\n \n \tprivate void saveSplittersInfo() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java b/jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/ResourceIndex.java\n@@ -11,6 +11,10 @@\n \n import javax.swing.tree.TreeNode;\n \n+import org.jetbrains.annotations.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import io.reactivex.BackpressureStrategy;\n import io.reactivex.Flowable;\n import io.reactivex.FlowableEmitter;\n@@ -26,9 +30,12 @@\n import static jadx.core.utils.StringUtils.getLine;\n \n public class ResourceIndex {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(ResourceIndex.class);\n+\n \tprivate final List<JResource> resNodes = new ArrayList<>();\n \tprivate final Set<String> extSet = new HashSet<>();\n-\tprivate CacheObject cache;\n+\tprivate final CacheObject cache;\n+\n \tprivate String fileExts;\n \tprivate boolean anyExt;\n \tprivate int sizeLimit;\n@@ -40,7 +47,6 @@ public ResourceIndex(CacheObject cache) {\n \tprivate void search(final JResource resNode,\n \t\t\tFlowableEmitter<JResSearchNode> emitter,\n \t\t\tSearchSettings searchSettings) {\n-\t\tint pos = 0;\n \t\tint line = 0;\n \t\tint lastPos = 0;\n \t\tint lastLineOccurred = -1;\n@@ -50,12 +56,12 @@ private void search(final JResource resNode,\n \t\ttry {\n \t\t\tcontent = resNode.getContent();\n \t\t} catch (Exception e) {\n-\t\t\te.printStackTrace();\n+\t\t\tLOG.error(\"Error load resource node content\", e);\n \t\t\treturn;\n \t\t}\n \t\tdo {\n \t\t\tsearchSettings.setStartPos(lastPos);\n-\t\t\tpos = searchSettings.find(content);\n+\t\t\tint pos = searchSettings.find(content);\n \t\t\tif (pos > -1) {\n \t\t\t\tline += countLinesByPos(content, pos, lastPos);\n \t\t\t\tlastPos = pos + searchStrLen;\n@@ -103,15 +109,15 @@ private void clear() {\n \t\tresNodes.clear();\n \t}\n \n-\tprivate void traverseTree(TreeNode root, ZipFile zip) {\n+\tprivate void traverseTree(TreeNode root, @Nullable ZipFile zip) {\n \t\tfor (int i = 0; i < root.getChildCount(); i++) {\n \t\t\tTreeNode node = root.getChildAt(i);\n \t\t\tif (node instanceof JResource) {\n \t\t\t\tJResource resNode = (JResource) node;\n \t\t\t\ttry {\n \t\t\t\t\tresNode.loadNode();\n \t\t\t\t} catch (Exception e) {\n-\t\t\t\t\te.printStackTrace();\n+\t\t\t\t\tLOG.error(\"Error load resource node: {}\", resNode, e);\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t\tResourceFile resFile = resNode.getResFile();\n@@ -133,6 +139,7 @@ private boolean shouldSearchXML() {\n \t\treturn anyExt || fileExts.contains(\".xml\");\n \t}\n \n+\t@Nullable\n \tprivate ZipFile getZipFile(TreeNode res) {\n \t\tfor (int i = 0; i < res.getChildCount(); i++) {\n \t\t\tTreeNode node = res.getChildAt(i);\n@@ -141,7 +148,7 @@ private ZipFile getZipFile(TreeNode res) {\n \t\t\t\ttry {\n \t\t\t\t\tresNode.loadNode();\n \t\t\t\t} catch (Exception e) {\n-\t\t\t\t\te.printStackTrace();\n+\t\t\t\t\tLOG.error(\"Error load resource node: {}\", resNode, e);\n \t\t\t\t\treturn null;\n \t\t\t\t}\n \t\t\t\tResourceFile file = resNode.getResFile();\n@@ -151,11 +158,14 @@ private ZipFile getZipFile(TreeNode res) {\n \t\t\t\t\t\treturn zip;\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tFile zfile = file.getZipRef().getZipFile();\n-\t\t\t\t\tif (FileUtils.isZipFile(zfile)) {\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\treturn new ZipFile(zfile);\n-\t\t\t\t\t\t} catch (IOException ignore) {\n+\t\t\t\t\tResourceFile.ZipRef zipRef = file.getZipRef();\n+\t\t\t\t\tif (zipRef != null) {\n+\t\t\t\t\t\tFile zfile = zipRef.getZipFile();\n+\t\t\t\t\t\tif (FileUtils.isZipFile(zfile)) {\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\treturn new ZipFile(zfile);\n+\t\t\t\t\t\t\t} catch (IOException ignore) {\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}",
    "output": "Fix resolve NPE in resource index for single dex, other minor issues"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -647,11 +647,17 @@ private void filledNewArray(FilledNewArrayNode insn, ICodeWriter code) throws Co\n \t\t}\n \t\tcode.add('{');\n \t\tint c = insn.getArgsCount();\n+\t\tint wrap = 0;\n \t\tfor (int i = 0; i < c; i++) {\n \t\t\taddArg(code, insn.getArg(i), false);\n \t\t\tif (i + 1 < c) {\n \t\t\t\tcode.add(\", \");\n \t\t\t}\n+\t\t\twrap++;\n+\t\t\tif (wrap == 1000) {\n+\t\t\t\tcode.startLine();\n+\t\t\t\twrap = 0;\n+\t\t\t}\n \t\t}\n \t\tcode.add('}');\n \t}",
    "output": "Fix wrap long array data (workaround for RSTA hang)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -228,7 +228,7 @@ private void addMethodArguments(ICodeWriter code, List<RegisterArg> args) {\n \t\t\t}\n \t\t\tcode.add(' ');\n \t\t\tif (code.isMetadataSupported() && ssaVar != null) {\n-\t\t\t\tcode.attachAnnotation(VarDeclareRef.get(mth, var));\n+\t\t\t\tcode.attachDefinition(VarDeclareRef.get(mth, var));\n \t\t\t}\n \t\t\tcode.add(nameGen.assignArg(var));\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n@@ -348,7 +348,7 @@ private void makeCatchBlock(ICodeWriter code, ExceptionHandler handler) throws C\n \t\t} else if (arg instanceof RegisterArg) {\n \t\t\tCodeVar codeVar = ((RegisterArg) arg).getSVar().getCodeVar();\n \t\t\tif (code.isMetadataSupported()) {\n-\t\t\t\tcode.attachAnnotation(VarDeclareRef.get(mth, codeVar));\n+\t\t\t\tcode.attachDefinition(VarDeclareRef.get(mth, codeVar));\n \t\t\t}\n \t\t\tcode.add(mgen.getNameGen().assignArg(codeVar));\n \t\t} else if (arg instanceof NamedArg) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -717,19 +717,15 @@ private void nodeClickAction(@Nullable Object obj) {\n \t\t}\n \t}\n \n-\tprivate void rename(JNode node) {\n-\t\tRenameDialog.rename(this, node);\n-\t}\n-\n \tprivate void treeRightClickAction(MouseEvent e) {\n \t\tJNode obj = getJNodeUnderMouse(e, false);\n \t\tif (obj instanceof JPackage) {\n \t\t\tJPackagePopupMenu menu = new JPackagePopupMenu(this, (JPackage) obj);\n \t\t\tmenu.show(e.getComponent(), e.getX(), e.getY());\n \t\t} else if (obj instanceof JClass || obj instanceof JField || obj instanceof JMethod) {\n-\t\t\tJPopupMenu menu = new JPopupMenu();\n \t\t\tJMenuItem jmi = new JMenuItem(NLS.str(\"popup.rename\"));\n-\t\t\tjmi.addActionListener(action -> rename(obj));\n+\t\t\tjmi.addActionListener(action -> RenameDialog.rename(this, obj));\n+\t\t\tJPopupMenu menu = new JPopupMenu();\n \t\t\tmenu.add(jmi);\n \t\t\tmenu.show(e.getComponent(), e.getX(), e.getY());\n \t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java\n@@ -49,7 +49,7 @@ private void showRenameDialog() {\n \t\t\tLOG.warn(\"Can't rename node: {}\", node);\n \t\t\treturn;\n \t\t}\n-\t\tRenameDialog.rename(codeArea.getMainWindow(), node);\n+\t\tRenameDialog.rename(codeArea.getMainWindow(), codeArea.getNode(), node);\n \t\tnode = null;\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/RenameDialog.java\n@@ -68,19 +68,25 @@ public class RenameDialog extends JDialog {\n \n \tprivate final transient MainWindow mainWindow;\n \tprivate final transient CacheObject cache;\n+\tprivate final transient JNode source;\n \tprivate final transient JNode node;\n \tprivate transient JTextField renameField;\n \n \tpublic static boolean rename(MainWindow mainWindow, JNode node) {\n-\t\tRenameDialog renameDialog = new RenameDialog(mainWindow, node);\n+\t\treturn rename(mainWindow, node, node);\n+\t}\n+\n+\tpublic static boolean rename(MainWindow mainWindow, JNode source, JNode node) {\n+\t\tRenameDialog renameDialog = new RenameDialog(mainWindow, source, node);\n \t\trenameDialog.setVisible(true);\n \t\treturn true;\n \t}\n \n-\tprivate RenameDialog(MainWindow mainWindow, JNode node) {\n+\tprivate RenameDialog(MainWindow mainWindow, JNode source, JNode node) {\n \t\tsuper(mainWindow);\n \t\tthis.mainWindow = mainWindow;\n \t\tthis.cache = mainWindow.getCacheObject();\n+\t\tthis.source = source;\n \t\tthis.node = node;\n \t\tinitUI();\n \t}\n@@ -158,6 +164,9 @@ private void refreshState() {\n \t\tJavaNode javaNode = node.getJavaNode();\n \n \t\tList<JavaNode> toUpdate = new ArrayList<>();\n+\t\tif (source != null && source != node) {\n+\t\t\ttoUpdate.add(source.getJavaNode());\n+\t\t}\n \t\tif (javaNode != null) {\n \t\t\ttoUpdate.add(javaNode);\n \t\t\ttoUpdate.addAll(javaNode.getUseIn());\n@@ -171,8 +180,8 @@ private void refreshState() {\n \t\t}\n \t\tSet<JClass> updatedTopClasses = toUpdate\n \t\t\t\t.stream()\n+\t\t\t\t.map(JavaNode::getTopParentClass)\n \t\t\t\t.map(nodeCache::makeFrom)\n-\t\t\t\t.map(JNode::getRootClass)\n \t\t\t\t.filter(Objects::nonNull)\n \t\t\t\t.collect(Collectors.toSet());",
    "output": "Fix resolve some minor rename issues"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java b/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java\n@@ -1,19 +1,22 @@\n package jadx.gui.treemodel;\n \n+import java.util.Comparator;\n+\n import javax.swing.Icon;\n \n+import org.jetbrains.annotations.NotNull;\n+\n import jadx.api.JavaNode;\n import jadx.gui.utils.search.StringRef;\n \n-public class CodeNode extends JNode {\n-\n+public class CodeNode extends JNode implements Comparable<CodeNode> {\n \tprivate static final long serialVersionUID = 1658650786734966545L;\n \n \tprivate final transient JNode jNode;\n \tprivate final transient JClass jParent;\n \tprivate final transient StringRef line;\n \tprivate final transient int lineNum;\n-\tprivate transient int pos;\n+\tprivate final transient int pos;\n \n \tpublic CodeNode(JNode jNode, StringRef lineStr, int lineNum, int pos) {\n \t\tthis.jNode = jNode;\n@@ -84,6 +87,11 @@ public String getSyntaxName() {\n \t\treturn jNode.getSyntaxName();\n \t}\n \n+\t@Override\n+\tpublic int getPos() {\n+\t\treturn pos;\n+\t}\n+\n \t@Override\n \tpublic boolean equals(Object o) {\n \t\tif (this == o) {\n@@ -101,8 +109,12 @@ public int hashCode() {\n \t\treturn jNode.hashCode();\n \t}\n \n+\tpublic static final Comparator<CodeNode> COMPARATOR = Comparator\n+\t\t\t.comparing(CodeNode::getJParent)\n+\t\t\t.thenComparingInt(CodeNode::getPos);\n+\n \t@Override\n-\tpublic int getPos() {\n-\t\treturn pos;\n+\tpublic int compareTo(@NotNull CodeNode other) {\n+\t\treturn COMPARATOR.compare(this, other);\n \t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n@@ -4,6 +4,7 @@\n import javax.swing.ImageIcon;\n \n import org.fife.ui.rsyntaxtextarea.SyntaxConstants;\n+import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n \n import jadx.api.ICodeInfo;\n@@ -19,7 +20,7 @@\n import jadx.gui.utils.NLS;\n import jadx.gui.utils.UiUtils;\n \n-public class JClass extends JLoadableNode {\n+public class JClass extends JLoadableNode implements Comparable<JClass> {\n \tprivate static final long serialVersionUID = -1239986875244097177L;\n \n \tprivate static final ImageIcon ICON_CLASS = UiUtils.openSvgIcon(\"nodes/class\");\n@@ -198,4 +199,9 @@ public String makeString() {\n \tpublic String makeLongString() {\n \t\treturn cls.getFullName();\n \t}\n+\n+\t@Override\n+\tpublic int compareTo(@NotNull JClass o) {\n+\t\treturn this.getFullName().compareTo(o.getFullName());\n+\t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/dialog/UsageDialog.java\n@@ -3,6 +3,7 @@\n import java.awt.BorderLayout;\n import java.awt.Container;\n import java.awt.FlowLayout;\n+import java.util.Collections;\n import java.util.Comparator;\n import java.util.List;\n import java.util.stream.Collectors;\n@@ -17,6 +18,7 @@\n import jadx.api.JavaNode;\n import jadx.gui.jobs.IndexService;\n import jadx.gui.jobs.TaskStatus;\n+import jadx.gui.treemodel.CodeNode;\n import jadx.gui.treemodel.JNode;\n import jadx.gui.ui.MainWindow;\n import jadx.gui.utils.CodeUsageInfo;\n@@ -95,7 +97,9 @@ protected synchronized void performSearch() {\n \t\tif (usageInfo == null) {\n \t\t\treturn;\n \t\t}\n-\t\tresultsModel.addAll(usageInfo.getUsageList(node));\n+\t\tList<CodeNode> usageList = usageInfo.getUsageList(node);\n+\t\tCollections.sort(usageList);\n+\t\tresultsModel.addAll(usageList);\n \t\t// TODO: highlight only needed node usage\n \t\thighlightText = null;\n \t\tsuper.performSearch();",
    "output": "Fix sort results in usage dialog"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportData.java\n@@ -15,7 +15,7 @@ public static class Crime {\n \t\tpublic List<String> permissions;\n \n \t\tList<Method> native_api;\n-\t\tList<Method> combination;\n+\t\tList<String[]> combination;\n \t\tList<Map<String, InvokePlace>> register;\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportNode.java b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportNode.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportNode.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportNode.java\n@@ -56,21 +56,24 @@ public String makeString() {\n \n \t@Override\n \tpublic ContentPanel getContentPanel(TabbedPane tabbedPane) {\n-\t\tQuarkReportData data;\n \t\ttry {\n-\t\t\tdata = GSON.fromJson(Files.newBufferedReader(apkFile), QuarkReportData.class);\n+\t\t\tQuarkReportData data = GSON.fromJson(Files.newBufferedReader(apkFile), QuarkReportData.class);\n+\t\t\treturn new QuarkReportPanel(tabbedPane, this, data);\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Quark report parse error\", e);\n \t\t\tStringEscapeUtils.Builder builder = StringEscapeUtils.builder(StringEscapeUtils.ESCAPE_HTML4);\n \t\t\tbuilder.append(\"<h2>\");\n \t\t\tbuilder.escape(\"Quark analysis failed!\");\n-\t\t\tbuilder.append(\"</h2><pre>\");\n+\t\t\tbuilder.append(\"</h2>\");\n+\t\t\tbuilder.append(\"<h3>\");\n+\t\t\tbuilder.append(\"Error: \").escape(e.getMessage());\n+\t\t\tbuilder.append(\"</h3>\");\n+\t\t\tbuilder.append(\"<pre>\");\n \t\t\tbuilder.escape(ExceptionUtils.getStackTrace(e));\n \t\t\tbuilder.append(\"</pre>\");\n \t\t\terrorContent = builder.toString();\n \t\t\treturn new HtmlPanel(tabbedPane, this);\n \t\t}\n-\t\treturn new QuarkReportPanel(tabbedPane, this, data);\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/plugins/quark/QuarkReportPanel.java\n@@ -8,6 +8,7 @@\n import java.util.Comparator;\n import java.util.Enumeration;\n import java.util.IdentityHashMap;\n+import java.util.List;\n import java.util.Map;\n \n import javax.swing.BorderFactory;\n@@ -238,20 +239,25 @@ private void addDetails() {\n \t\t\tif (Utils.notEmpty(crime.permissions)) {\n \t\t\t\tadd(new TextTreeNode(\"Permissions: \" + Strings.join(\", \", crime.permissions)));\n \t\t\t}\n-\t\t\tif (Utils.notEmpty(crime.combination)) {\n+\t\t\tif (Utils.notEmpty(crime.native_api)) {\n \t\t\t\tTextTreeNode node = new TextTreeNode(\"Native API\");\n-\t\t\t\tfor (QuarkReportData.Method method : crime.combination) {\n+\t\t\t\tfor (QuarkReportData.Method method : crime.native_api) {\n \t\t\t\t\tnode.add(new TextTreeNode(method.toString()));\n \t\t\t\t}\n \t\t\t\tadd(node);\n-\t\t\t} else {\n-\t\t\t\tif (Utils.notEmpty(crime.native_api)) {\n-\t\t\t\t\tTextTreeNode node = new TextTreeNode(\"Native API\");\n-\t\t\t\t\tfor (QuarkReportData.Method method : crime.native_api) {\n-\t\t\t\t\t\tnode.add(new TextTreeNode(method.toString()));\n+\t\t\t}\n+\t\t\tList<String[]> combination = crime.combination;\n+\t\t\tif (Utils.notEmpty(combination)) {\n+\t\t\t\tTextTreeNode node = new TextTreeNode(\"Combination\");\n+\t\t\t\tint size = combination.size();\n+\t\t\t\tfor (int i = 0; i < size; i++) {\n+\t\t\t\t\tTextTreeNode set = new TextTreeNode(\"Set \" + i);\n+\t\t\t\t\tfor (String mth : combination.get(i)) {\n+\t\t\t\t\t\tset.add(resolveMethod(mth));\n \t\t\t\t\t}\n-\t\t\t\t\tadd(node);\n+\t\t\t\t\tnode.add(set);\n \t\t\t\t}\n+\t\t\t\tadd(node);\n \t\t\t}\n \t\t\tif (Utils.notEmpty(crime.register)) {\n \t\t\t\tTextTreeNode node = new TextTreeNode(\"Invocations\");",
    "output": "Fix update Quark report format parsing"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -249,8 +249,8 @@ public boolean isAlwaysSelectOpened() {\n \t\treturn alwaysSelectOpened;\n \t}\n \n-\tpublic void setAlwaysSelectOpened(boolean showHeapUsageBar) {\n-\t\tthis.alwaysSelectOpened = showHeapUsageBar;\n+\tpublic void setAlwaysSelectOpened(boolean alwaysSelectOpened) {\n+\t\tthis.alwaysSelectOpened = alwaysSelectOpened;\n \t\tpartialSync(settings -> settings.alwaysSelectOpened = alwaysSelectOpened);\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -868,6 +868,9 @@ public void actionPerformed(ActionEvent e) {\n \t\talwaysSelectOpened.setState(settings.isAlwaysSelectOpened());\n \t\talwaysSelectOpened.addActionListener(event -> {\n \t\t\tsettings.setAlwaysSelectOpened(!settings.isAlwaysSelectOpened());\n+\t\t\tif (settings.isAlwaysSelectOpened()) {\n+\t\t\t\tthis.syncWithEditor();\n+\t\t\t}\n \t\t});\n \n \t\tAction syncAction = new AbstractAction(NLS.str(\"menu.sync\"), ICON_SYNC) {",
    "output": "Fix \"Always Select Opened File/Class\" was not syncing upon activation"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n@@ -5,6 +5,8 @@\n import java.util.Set;\n import java.util.regex.Pattern;\n \n+import jadx.core.utils.StringUtils;\n+\n import static jadx.core.utils.StringUtils.notEmpty;\n \n public class NameMapper {\n@@ -99,16 +101,42 @@ public static boolean isValidIdentifierPart(int codePoint) {\n \t\treturn Character.isJavaIdentifierPart(codePoint);\n \t}\n \n-\tpublic static boolean isPrintableChar(int c) {\n+\tpublic static boolean isPrintableChar(char c) {\n+\t\treturn 32 <= c && c <= 126;\n+\t}\n+\n+\tpublic static boolean isPrintableAsciiCodePoint(int c) {\n \t\treturn 32 <= c && c <= 126;\n \t}\n \n+\tpublic static boolean isPrintableCodePoint(int codePoint) {\n+\t\tif (Character.isISOControl(codePoint)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (Character.isWhitespace(codePoint)) {\n+\t\t\t// don't print whitespaces other than standard one\n+\t\t\treturn codePoint == ' ';\n+\t\t}\n+\t\tswitch (Character.getType(codePoint)) {\n+\t\t\tcase Character.CONTROL:\n+\t\t\tcase Character.FORMAT:\n+\t\t\tcase Character.PRIVATE_USE:\n+\t\t\tcase Character.SURROGATE:\n+\t\t\tcase Character.UNASSIGNED:\n+\t\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n \tpublic static boolean isAllCharsPrintable(String str) {\n \t\tint len = str.length();\n-\t\tfor (int i = 0; i < len; i++) {\n-\t\t\tif (!isPrintableChar(str.charAt(i))) {\n+\t\tint offset = 0;\n+\t\twhile (offset < len) {\n+\t\t\tint codePoint = str.codePointAt(offset);\n+\t\t\tif (!isPrintableAsciiCodePoint(codePoint)) {\n \t\t\t\treturn false;\n \t\t\t}\n+\t\t\toffset += Character.charCount(codePoint);\n \t\t}\n \t\treturn true;\n \t}\n@@ -135,12 +163,11 @@ public static String removeInvalidCharsMiddle(String name) {\n \t\t}\n \t\tint len = name.length();\n \t\tStringBuilder sb = new StringBuilder(len);\n-\t\tfor (int i = 0; i < len; i++) {\n-\t\t\tint codePoint = name.codePointAt(i);\n-\t\t\tif (isPrintableChar(codePoint) && isValidIdentifierPart(codePoint)) {\n-\t\t\t\tsb.append((char) codePoint);\n+\t\tStringUtils.visitCodePoints(name, codePoint -> {\n+\t\t\tif (isPrintableAsciiCodePoint(codePoint) && isValidIdentifierPart(codePoint)) {\n+\t\t\t\tsb.appendCodePoint(codePoint);\n \t\t\t}\n-\t\t}\n+\t\t});\n \t\treturn sb.toString();\n \t}\n \n@@ -161,14 +188,12 @@ public static String removeInvalidChars(String name, String prefix) {\n \t}\n \n \tpublic static String removeNonPrintableCharacters(String name) {\n-\t\tint len = name.length();\n-\t\tStringBuilder sb = new StringBuilder(len);\n-\t\tfor (int i = 0; i < len; i++) {\n-\t\t\tint codePoint = name.codePointAt(i);\n-\t\t\tif (isPrintableChar(codePoint)) {\n-\t\t\t\tsb.append((char) codePoint);\n+\t\tStringBuilder sb = new StringBuilder(name.length());\n+\t\tStringUtils.visitCodePoints(name, codePoint -> {\n+\t\t\tif (isPrintableAsciiCodePoint(codePoint)) {\n+\t\t\t\tsb.appendCodePoint(codePoint);\n \t\t\t}\n-\t\t}\n+\t\t});\n \t\treturn sb.toString();\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -186,7 +186,7 @@ private InsnNode simplifyStringConstructor(MethodNode mth, ConstructorInsn insn)\n \t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tarr[i] = (byte) ((LiteralArg) arrArg).getLiteral();\n-\t\t\t\t\t\tif (NameMapper.isPrintableChar(arr[i])) {\n+\t\t\t\t\t\tif (NameMapper.isPrintableChar((char) arr[i])) {\n \t\t\t\t\t\t\tprintable++;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/StringUtils.java b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n@@ -2,6 +2,7 @@\n \n import java.text.SimpleDateFormat;\n import java.util.Date;\n+import java.util.function.IntConsumer;\n \n import org.jetbrains.annotations.Nullable;\n \n@@ -23,63 +24,81 @@ public StringUtils(JadxArgs args) {\n \t\tthis.escapeUnicode = args.isEscapeUnicode();\n \t}\n \n+\tpublic static void visitCodePoints(String str, IntConsumer visitor) {\n+\t\tint len = str.length();\n+\t\tint offset = 0;\n+\t\twhile (offset < len) {\n+\t\t\tint codePoint = str.codePointAt(offset);\n+\t\t\tvisitor.accept(codePoint);\n+\t\t\toffset += Character.charCount(codePoint);\n+\t\t}\n+\t}\n+\n \tpublic String unescapeString(String str) {\n \t\tint len = str.length();\n \t\tif (len == 0) {\n \t\t\treturn \"\\\"\\\"\";\n \t\t}\n \t\tStringBuilder res = new StringBuilder();\n \t\tres.append('\"');\n-\t\tfor (int i = 0; i < len; i++) {\n-\t\t\tint c = str.charAt(i) & 0xFFFF;\n-\t\t\tprocessCharInsideString(c, res);\n-\t\t}\n+\t\tvisitCodePoints(str, codePoint -> processCodePoint(codePoint, res));\n \t\tres.append('\"');\n \t\treturn res.toString();\n \t}\n \n-\tprivate void processCharInsideString(int c, StringBuilder res) {\n-\t\tString str = getSpecialStringForChar(c);\n+\tprivate void processCodePoint(int codePoint, StringBuilder res) {\n+\t\tString str = getSpecialStringForCodePoint(codePoint);\n \t\tif (str != null) {\n \t\t\tres.append(str);\n \t\t\treturn;\n \t\t}\n-\t\tif (c < 32 || c >= 127 && escapeUnicode) {\n-\t\t\tres.append(\"\\\\u\").append(String.format(\"%04x\", c));\n+\t\tif (isEscapeNeededForCodePoint(codePoint)) {\n+\t\t\tres.append(\"\\\\u\").append(String.format(\"%04x\", codePoint));\n \t\t} else {\n-\t\t\tres.append((char) c);\n+\t\t\tres.appendCodePoint(codePoint);\n \t\t}\n \t}\n \n+\tprivate boolean isEscapeNeededForCodePoint(int codePoint) {\n+\t\tif (codePoint < 32) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (codePoint < 127) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (escapeUnicode) {\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn !NameMapper.isPrintableCodePoint(codePoint);\n+\t}\n+\n \t/**\n-\t * Represent single char best way possible\n+\t * Represent single char the best way possible\n \t */\n-\tpublic String unescapeChar(int c, boolean explicitCast) {\n+\tpublic String unescapeChar(char c, boolean explicitCast) {\n \t\tif (c == '\\'') {\n \t\t\treturn \"'\\\\''\";\n \t\t}\n-\t\tString str = getSpecialStringForChar(c);\n+\t\tString str = getSpecialStringForCodePoint(c);\n \t\tif (str != null) {\n \t\t\treturn '\\'' + str + '\\'';\n \t\t}\n \t\tif (c >= 127 && escapeUnicode) {\n-\t\t\treturn String.format(\"'\\\\u%04x'\", c);\n+\t\t\treturn String.format(\"'\\\\u%04x'\", (int) c);\n \t\t}\n \t\tif (NameMapper.isPrintableChar(c)) {\n-\t\t\treturn \"'\" + (char) c + '\\'';\n-\t\t}\n-\t\tif (explicitCast) {\n-\t\t\treturn \"(char) \" + c;\n+\t\t\treturn \"'\" + c + '\\'';\n \t\t}\n-\t\treturn String.valueOf(c);\n+\t\tString intStr = Integer.toString(c);\n+\t\treturn explicitCast ? \"(char) \" + intStr : intStr;\n \t}\n \n \tpublic String unescapeChar(char ch) {\n \t\treturn unescapeChar(ch, false);\n \t}\n \n \t@Nullable\n-\tprivate String getSpecialStringForChar(int c) {\n+\tprivate String getSpecialStringForCodePoint(int c) {\n \t\tswitch (c) {\n \t\t\tcase '\\n':\n \t\t\t\treturn \"\\\\n\";\n@@ -183,7 +202,7 @@ public static String escapeResStrValue(String str) {\n \t}\n \n \tprivate static String escapeXmlChar(char c) {\n-\t\tif (c >= 0 && c <= 0x1F) {\n+\t\tif (c <= 0x1F) {\n \t\t\treturn \"\\\\\" + (int) c;\n \t\t}\n \t\tswitch (c) {\n@@ -315,7 +334,6 @@ public static boolean isWhite(char chr) {\n \n \tpublic static boolean isWordSeparator(char chr) {\n \t\treturn WORD_SEPARATORS.indexOf(chr) != -1;\n-\n \t}\n \n \tpublic static String getDateText() {",
    "output": "Use correct iteration over code points in string"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n@@ -160,6 +160,18 @@ public static String removeInvalidChars(String name, String prefix) {\n \t\treturn result;\n \t}\n \n+\tpublic static String removeNonPrintableCharacters(String name) {\n+\t\tint len = name.length();\n+\t\tStringBuilder sb = new StringBuilder(len);\n+\t\tfor (int i = 0; i < len; i++) {\n+\t\t\tint codePoint = name.codePointAt(i);\n+\t\t\tif (isPrintableChar(codePoint)) {\n+\t\t\t\tsb.append((char) codePoint);\n+\t\t\t}\n+\t\t}\n+\t\treturn sb.toString();\n+\t}\n+\n \tprivate NameMapper() {\n \t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -125,22 +125,27 @@ private static void checkPackage(Deobfuscator deobfuscator, ClassNode cls, Class\n \n \t@Nullable\n \tprivate static String fixClsShortName(JadxArgs args, String clsName) {\n-\t\tchar firstChar = clsName.charAt(0);\n \t\tboolean renameValid = args.isRenameValid();\n-\t\tif (Character.isDigit(firstChar) && renameValid) {\n-\t\t\treturn Consts.ANONYMOUS_CLASS_PREFIX + NameMapper.removeInvalidCharsMiddle(clsName);\n-\t\t}\n-\t\tif (firstChar == '$' && renameValid) {\n-\t\t\treturn 'C' + NameMapper.removeInvalidCharsMiddle(clsName);\n+\t\tif (renameValid) {\n+\t\t\tchar firstChar = clsName.charAt(0);\n+\t\t\tif (Character.isDigit(firstChar)) {\n+\t\t\t\treturn Consts.ANONYMOUS_CLASS_PREFIX + NameMapper.removeInvalidCharsMiddle(clsName);\n+\t\t\t}\n+\t\t\tif (firstChar == '$') {\n+\t\t\t\treturn 'C' + NameMapper.removeInvalidCharsMiddle(clsName);\n+\t\t\t}\n \t\t}\n \t\tString cleanClsName = args.isRenamePrintable()\n-\t\t\t\t? NameMapper.removeInvalidChars(clsName, \"C\")\n+\t\t\t\t? NameMapper.removeNonPrintableCharacters(clsName)\n \t\t\t\t: clsName;\n \t\tif (cleanClsName.isEmpty()) {\n \t\t\treturn null;\n \t\t}\n-\t\tif (renameValid && !NameMapper.isValidIdentifier(cleanClsName)) {\n-\t\t\treturn 'C' + cleanClsName;\n+\t\tif (renameValid) {\n+\t\t\tcleanClsName = NameMapper.removeInvalidChars(clsName, \"C\");\n+\t\t\tif (!NameMapper.isValidIdentifier(cleanClsName)) {\n+\t\t\t\treturn 'C' + cleanClsName;\n+\t\t\t}\n \t\t}\n \t\treturn cleanClsName;\n \t}",
    "output": "Fix \"rename to make printable\" option was renaming fully printable class names"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/ProcessClass.java b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n--- a/jadx-core/src/main/java/jadx/core/ProcessClass.java\n+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n@@ -67,10 +67,14 @@ private static ICodeInfo process(ClassNode cls, boolean codegen) {\n \t\t\t\t\t}\n \t\t\t\t\treturn code;\n \t\t\t\t}\n+\t\t\t\treturn null;\n \t\t\t} catch (Throwable e) {\n+\t\t\t\tif (codegen) {\n+\t\t\t\t\tthrow e;\n+\t\t\t\t}\n \t\t\t\tcls.addError(\"Class process error: \" + e.getClass().getSimpleName(), e);\n+\t\t\t\treturn null;\n \t\t\t}\n-\t\t\treturn null;\n \t\t}\n \t}",
    "output": "Fix show cause exception if class codegen failed"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -538,7 +538,11 @@ JavaNode convertNode(Object obj) {\n \t\t}\n \t\tif (obj instanceof VariableNode) {\n \t\t\tVariableNode varNode = (VariableNode) obj;\n-\t\t\treturn new JavaVariable(getJavaClassByNode(varNode.getClassNode().getTopParentClass()), varNode);\n+\t\t\tJavaClass javaCls = getJavaClassByNode(varNode.getClassNode().getTopParentClass());\n+\t\t\tif (javaCls == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn new JavaVariable(javaCls, varNode);\n \t\t}\n \t\tthrow new JadxRuntimeException(\"Unexpected node type: \" + obj);\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JavaVariable.java b/jadx-core/src/main/java/jadx/api/JavaVariable.java\n--- a/jadx-core/src/main/java/jadx/api/JavaVariable.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaVariable.java\n@@ -2,16 +2,17 @@\n \n import java.util.Collections;\n import java.util.List;\n+import java.util.Objects;\n \n import jadx.core.dex.nodes.VariableNode;\n \n public class JavaVariable implements JavaNode {\n-\tJavaClass cls;\n-\tVariableNode node;\n+\tprivate final JavaClass cls;\n+\tprivate final VariableNode node;\n \n \tpublic JavaVariable(JavaClass cls, VariableNode node) {\n-\t\tthis.cls = cls;\n-\t\tthis.node = node;\n+\t\tthis.cls = Objects.requireNonNull(cls);\n+\t\tthis.node = Objects.requireNonNull(node);\n \t}\n \n \tpublic VariableNode getVariableNode() {",
    "output": "Fix resolve NPE during index"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n@@ -2,8 +2,10 @@\n \n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n import java.util.stream.Collectors;\n@@ -269,9 +271,70 @@ private static boolean insnUseExcludedField(FieldInitInfo initInfo, Set<FieldInf\n \t\treturn Objects.equals(exclude, Boolean.TRUE);\n \t}\n \n-\tprivate static void fixFieldsOrder(ClassNode cls, List<FieldInitInfo> fieldsInit) {\n+\tprivate static void fixFieldsOrder(ClassNode cls, List<FieldInitInfo> inits) {\n+\t\tList<FieldNode> orderedFields = processFieldsDependencies(cls, inits);\n+\t\tapplyFieldsOrder(cls, orderedFields);\n+\t}\n+\n+\tprivate static List<FieldNode> processFieldsDependencies(ClassNode cls, List<FieldInitInfo> inits) {\n+\t\tList<FieldNode> orderedFields = Utils.collectionMap(inits, v -> v.fieldNode);\n+\t\t// collect dependant fields\n+\t\tMap<FieldNode, List<FieldNode>> deps = new HashMap<>(inits.size());\n+\t\tfor (FieldInitInfo initInfo : inits) {\n+\t\t\tIndexInsnNode insn = initInfo.putInsn;\n+\t\t\tboolean staticField = insn.getType() == InsnType.SPUT;\n+\t\t\tInsnType useType = staticField ? InsnType.SGET : InsnType.IGET;\n+\t\t\tinsn.visitInsns(subInsn -> {\n+\t\t\t\tif (subInsn.getType() == useType) {\n+\t\t\t\t\tFieldInfo fieldInfo = (FieldInfo) ((IndexInsnNode) subInsn).getIndex();\n+\t\t\t\t\tif (fieldInfo.getDeclClass().equals(cls.getClassInfo())) {\n+\t\t\t\t\t\tFieldNode depField = cls.searchField(fieldInfo);\n+\t\t\t\t\t\tif (depField != null) {\n+\t\t\t\t\t\t\tdeps.computeIfAbsent(initInfo.fieldNode, k -> new ArrayList<>())\n+\t\t\t\t\t\t\t\t\t.add(depField);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\tif (deps.isEmpty()) {\n+\t\t\treturn orderedFields;\n+\t\t}\n+\t\t// build new list with deps fields before usage field\n+\t\tList<FieldNode> result = new ArrayList<>();\n+\t\tfor (FieldNode field : orderedFields) {\n+\t\t\tint idx = result.indexOf(field);\n+\t\t\tList<FieldNode> fieldDeps = deps.get(field);\n+\t\t\tif (fieldDeps == null) {\n+\t\t\t\tif (idx == -1) {\n+\t\t\t\t\tresult.add(field);\n+\t\t\t\t}\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (idx == -1) {\n+\t\t\t\tfor (FieldNode depField : fieldDeps) {\n+\t\t\t\t\tif (!result.contains(depField)) {\n+\t\t\t\t\t\tresult.add(depField);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tresult.add(field);\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tfor (FieldNode depField : fieldDeps) {\n+\t\t\t\tint depIdx = result.indexOf(depField);\n+\t\t\t\tif (depIdx == -1) {\n+\t\t\t\t\tresult.add(idx, depField);\n+\t\t\t\t} else if (depIdx > idx) {\n+\t\t\t\t\tresult.remove(depIdx);\n+\t\t\t\t\tresult.add(idx, depField);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate static void applyFieldsOrder(ClassNode cls, List<FieldNode> orderedFields) {\n \t\tList<FieldNode> clsFields = cls.getFields();\n-\t\tList<FieldNode> orderedFields = Utils.collectionMap(fieldsInit, v -> v.fieldNode);\n \t\t// check if already ordered\n \t\tboolean ordered = Collections.indexOfSubList(clsFields, orderedFields) != -1;\n \t\tif (!ordered) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n@@ -327,47 +327,58 @@ private void runAutoCheck(ClassNode cls) {\n \t\tString clsName = cls.getClassInfo().getFullName();\n \t\ttry {\n \t\t\t// run 'check' method from original class\n-\t\t\tClass<?> origCls;\n-\t\t\ttry {\n-\t\t\t\torigCls = Class.forName(clsName);\n-\t\t\t} catch (ClassNotFoundException e) {\n-\t\t\t\t// ignore\n+\t\t\tif (runSourceAutoCheck(clsName)) {\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\tMethod checkMth;\n-\t\t\ttry {\n-\t\t\t\tcheckMth = origCls.getMethod(CHECK_METHOD_NAME);\n-\t\t\t} catch (NoSuchMethodException e) {\n-\t\t\t\t// ignore\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tif (!checkMth.getReturnType().equals(void.class)\n-\t\t\t\t\t|| !Modifier.isPublic(checkMth.getModifiers())\n-\t\t\t\t\t|| Modifier.isStatic(checkMth.getModifiers())) {\n-\t\t\t\tfail(\"Wrong 'check' method\");\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tlimitExecTime(() -> checkMth.invoke(origCls.getConstructor().newInstance()));\n-\t\t\t\tSystem.out.println(\"Source check: PASSED\");\n-\t\t\t} catch (Throwable e) {\n-\t\t\t\tthrow new JadxRuntimeException(\"Source check failed\", e);\n-\t\t\t}\n \t\t\t// run 'check' method from decompiled class\n \t\t\tif (compile) {\n-\t\t\t\ttry {\n-\t\t\t\t\tlimitExecTime(() -> invoke(cls, \"check\"));\n-\t\t\t\t\tSystem.out.println(\"Decompiled check: PASSED\");\n-\t\t\t\t} catch (Throwable e) {\n-\t\t\t\t\tthrow new JadxRuntimeException(\"Decompiled check failed\", e);\n-\t\t\t\t}\n+\t\t\t\trunDecompiledAutoCheck(cls);\n \t\t\t}\n \t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tfail(\"Auto check exception: \" + e.getMessage());\n \t\t}\n \t}\n \n+\tprivate boolean runSourceAutoCheck(String clsName) {\n+\t\tClass<?> origCls;\n+\t\ttry {\n+\t\t\torigCls = Class.forName(clsName);\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\t// ignore\n+\t\t\treturn true;\n+\t\t}\n+\t\tMethod checkMth;\n+\t\ttry {\n+\t\t\tcheckMth = origCls.getMethod(CHECK_METHOD_NAME);\n+\t\t} catch (NoSuchMethodException e) {\n+\t\t\t// ignore\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (!checkMth.getReturnType().equals(void.class)\n+\t\t\t\t|| !Modifier.isPublic(checkMth.getModifiers())\n+\t\t\t\t|| Modifier.isStatic(checkMth.getModifiers())) {\n+\t\t\tfail(\"Wrong 'check' method\");\n+\t\t\treturn true;\n+\t\t}\n+\t\ttry {\n+\t\t\tlimitExecTime(() -> checkMth.invoke(origCls.getConstructor().newInstance()));\n+\t\t\tSystem.out.println(\"Source check: PASSED\");\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow new JadxRuntimeException(\"Source check failed\", e);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic void runDecompiledAutoCheck(ClassNode cls) {\n+\t\ttry {\n+\t\t\tlimitExecTime(() -> invoke(cls, \"check\"));\n+\t\t\tSystem.out.println(\"Decompiled check: PASSED\");\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow new JadxRuntimeException(\"Decompiled check failed\", e);\n+\t\t}\n+\t}\n+\n \tprivate <T> T limitExecTime(Callable<T> call) {\n \t\tExecutorService executor = Executors.newSingleThreadExecutor();\n \t\tFuture<T> future = executor.submit(call);\n@@ -406,10 +417,6 @@ protected MethodNode getMethod(ClassNode cls, String method) {\n \t\treturn null;\n \t}\n \n-\tvoid compile(ClassNode cls) {\n-\t\tcompile(Collections.singletonList(cls));\n-\t}\n-\n \tvoid compile(List<ClassNode> clsList) {\n \t\tif (!compile) {\n \t\t\treturn;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java\n--- a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java\n@@ -42,4 +42,14 @@ public JadxCodeAssertions reloadCode(IntegrationTest testInstance) {\n \t\ttestInstance.runChecks(actual);\n \t\treturn codeAssertions;\n \t}\n+\n+\t/**\n+\t * Force running auto check on decompiled code.\n+\t * Useful for smali tests.\n+\t */\n+\tpublic JadxClassNodeAssertions runDecompiledAutoCheck(IntegrationTest testInstance) {\n+\t\tisNotNull();\n+\t\ttestInstance.runDecompiledAutoCheck(actual);\n+\t\treturn this;\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitOrder2.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitOrder2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitOrder2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitOrder2.java\n@@ -0,0 +1,35 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestFieldInitOrder2 extends SmaliTest {\n+\n+\t@SuppressWarnings({ \"SpellCheckingInspection\", \"StaticVariableName\" })\n+\tpublic static class TestCls {\n+\t\tstatic String ZPREFIX = \"SOME_\";\n+\t\tprivate static final String VALUE = ZPREFIX + \"VALUE\";\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(VALUE).isEqualTo(\"SOME_VALUE\");\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"private static final String VALUE = ZPREFIX + \\\"VALUE\\\";\");\n+\t}\n+\n+\t@Test\n+\tpublic void testSmali() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.runDecompiledAutoCheck(this)\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"private static final String VALUE = ZPREFIX + \\\"VALUE\\\";\");\n+\t}\n+}",
    "output": "Fix restore fields order if init use other fields"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -101,6 +101,10 @@ public void addArg(ICodeWriter code, InsnArg arg) throws CodegenException {\n \t}\n \n \tpublic void addArg(ICodeWriter code, InsnArg arg, boolean wrap) throws CodegenException {\n+\t\taddArg(code, arg, wrap ? BODY_ONLY_FLAG : BODY_ONLY_NOWRAP_FLAGS);\n+\t}\n+\n+\tpublic void addArg(ICodeWriter code, InsnArg arg, Set<Flags> flags) throws CodegenException {\n \t\tif (arg.isRegister()) {\n \t\t\tCodeVar codeVar = CodeGenUtils.getCodeVar((RegisterArg) arg);\n \t\t\tif (codeVar != null) {\n@@ -113,7 +117,7 @@ public void addArg(ICodeWriter code, InsnArg arg, boolean wrap) throws CodegenEx\n \t\t} else if (arg.isLiteral()) {\n \t\t\tcode.add(lit((LiteralArg) arg));\n \t\t} else if (arg.isInsnWrap()) {\n-\t\t\taddWrappedArg(code, (InsnWrapArg) arg, wrap);\n+\t\t\taddWrappedArg(code, (InsnWrapArg) arg, flags);\n \t\t} else if (arg.isNamed()) {\n \t\t\tif (arg instanceof NamedArg) {\n \t\t\t\tVariableNode node = mth.getVariable(((NamedArg) arg).getIndex());\n@@ -127,15 +131,14 @@ public void addArg(ICodeWriter code, InsnArg arg, boolean wrap) throws CodegenEx\n \t\t}\n \t}\n \n-\tprivate void addWrappedArg(ICodeWriter code, InsnWrapArg arg, boolean wrap) throws CodegenException {\n+\tprivate void addWrappedArg(ICodeWriter code, InsnWrapArg arg, Set<Flags> flags) throws CodegenException {\n \t\tInsnNode wrapInsn = arg.getWrapInsn();\n \t\tif (wrapInsn.contains(AFlag.FORCE_ASSIGN_INLINE)) {\n \t\t\tcode.add('(');\n \t\t\tmakeInsn(wrapInsn, code, Flags.INLINE);\n \t\t\tcode.add(')');\n \t\t} else {\n-\t\t\tFlags flags = wrap ? Flags.BODY_ONLY : Flags.BODY_ONLY_NOWRAP;\n-\t\t\tmakeInsn(wrapInsn, code, flags);\n+\t\t\tmakeInsnBody(code, wrapInsn, flags);\n \t\t}\n \t}\n \n@@ -509,7 +512,7 @@ private void makeInsnBody(ICodeWriter code, InsnNode insn, Set<Flags> state) thr\n \t\t\t\tbreak;\n \n \t\t\tcase ONE_ARG:\n-\t\t\t\taddArg(code, insn.getArg(0));\n+\t\t\t\taddArg(code, insn.getArg(0), state);\n \t\t\t\tbreak;\n \n \t\t\t/* fallback mode instructions */\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkMethodsForInline.java\n@@ -76,7 +76,7 @@ private static MethodInlineAttr inlineMth(MethodNode mth) {\n \t\t}\n \t\tif (insnsCount == 1) {\n \t\t\tInsnNode insn = insns.get(0);\n-\t\t\tif (insn.getType() == InsnType.RETURN) {\n+\t\t\tif (insn.getType() == InsnType.RETURN && insn.getArgsCount() == 1) {\n \t\t\t\t// synthetic field getter\n \t\t\t\t// set arg from 'return' instruction\n \t\t\t\treturn addInlineAttr(mth, InsnNode.wrapArg(insn.getArg(0)));",
    "output": "Fix don't add parenthesis for field init code"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/AttachTryCatchVisitor.java\n@@ -69,7 +69,7 @@ private static void markTryBounds(InsnNode[] insnByOffset, ITry aTry, CatchAttr\n \t\t\tInsnNode insnAtOffset = insnByOffset[offset];\n \t\t\tif (insnAtOffset != null) {\n \t\t\t\tinsn = insnAtOffset;\n-\t\t\t\tinsn.addAttr(catchAttr);\n+\t\t\t\tattachCatchAttr(catchAttr, insn);\n \t\t\t\tif (!tryBlockStarted) {\n \t\t\t\t\tinsn.add(AFlag.TRY_ENTER);\n \t\t\t\t\ttryBlockStarted = true;\n@@ -91,6 +91,17 @@ private static void markTryBounds(InsnNode[] insnByOffset, ITry aTry, CatchAttr\n \t\t}\n \t}\n \n+\tprivate static void attachCatchAttr(CatchAttr catchAttr, InsnNode insn) {\n+\t\tCatchAttr existAttr = insn.get(AType.EXC_CATCH);\n+\t\tif (existAttr != null) {\n+\t\t\t// merge handlers\n+\t\t\tList<ExceptionHandler> handlers = Utils.concat(existAttr.getHandlers(), catchAttr.getHandlers());\n+\t\t\tinsn.addAttr(new CatchAttr(handlers));\n+\t\t} else {\n+\t\t\tinsn.addAttr(catchAttr);\n+\t\t}\n+\t}\n+\n \tprivate static List<ExceptionHandler> attachHandlers(MethodNode mth, ICatch catchBlock, InsnNode[] insnByOffset) {\n \t\tint[] handlerOffsetArr = catchBlock.getHandlers();\n \t\tString[] handlerTypes = catchBlock.getTypes();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/finaly/MarkFinallyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/finaly/MarkFinallyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/finaly/MarkFinallyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/finaly/MarkFinallyVisitor.java\n@@ -80,6 +80,7 @@ private static boolean processTryBlock(MethodNode mth, TryCatchBlockAttr tryBloc\n \t\t\t\t\t\treThrowInsn = BlockUtils.getLastInsn(excBlock);\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif (allHandler != null && reThrowInsn != null) {\n@@ -108,27 +109,47 @@ private static boolean extractFinally(MethodNode mth, TryCatchBlockAttr tryBlock\n \t\tBlockNode startBlock = Utils.getOne(handlerBlock.getCleanSuccessors());\n \t\tFinallyExtractInfo extractInfo = new FinallyExtractInfo(allHandler, startBlock, handlerBlocks);\n \n-\t\t// collect handlers from this and all inner blocks\n-\t\tList<ExceptionHandler> handlers = new ArrayList<>();\n-\t\tcollectAllHandlers(tryBlock, handlers);\n-\n+\t\tboolean hasInnerBlocks = !tryBlock.getInnerTryBlocks().isEmpty();\n+\t\tList<ExceptionHandler> handlers;\n+\t\tif (hasInnerBlocks) {\n+\t\t\t// collect handlers from this and all inner blocks (intentionally not using recursive collect for\n+\t\t\t// now)\n+\t\t\thandlers = new ArrayList<>(tryBlock.getHandlers());\n+\t\t\tfor (TryCatchBlockAttr innerTryBlock : tryBlock.getInnerTryBlocks()) {\n+\t\t\t\thandlers.addAll(innerTryBlock.getHandlers());\n+\t\t\t}\n+\t\t} else {\n+\t\t\thandlers = tryBlock.getHandlers();\n+\t\t}\n+\t\tif (handlers.isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n \t\t// search 'finally' instructions in other handlers\n-\t\tif (!handlers.isEmpty()) {\n-\t\t\tfor (ExceptionHandler otherHandler : handlers) {\n-\t\t\t\tif (otherHandler == allHandler) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tfor (BlockNode checkBlock : otherHandler.getBlocks()) {\n-\t\t\t\t\tif (searchDuplicateInsns(checkBlock, extractInfo)) {\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\textractInfo.getFinallyInsnsSlice().resetIncomplete();\n-\t\t\t\t\t}\n+\t\tfor (ExceptionHandler otherHandler : handlers) {\n+\t\t\tif (otherHandler == allHandler) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tfor (BlockNode checkBlock : otherHandler.getBlocks()) {\n+\t\t\t\tif (searchDuplicateInsns(checkBlock, extractInfo)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t} else {\n+\t\t\t\t\textractInfo.getFinallyInsnsSlice().resetIncomplete();\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif (extractInfo.getDuplicateSlices().size() != handlers.size() - 1) {\n+\t\t}\n+\t\tboolean mergeInnerTryBlocks;\n+\t\tint duplicatesCount = extractInfo.getDuplicateSlices().size();\n+\t\tboolean fullTryBlock = duplicatesCount == (handlers.size() - 1);\n+\t\tif (fullTryBlock) {\n+\t\t\t// all collected handlers have duplicate block\n+\t\t\tmergeInnerTryBlocks = hasInnerBlocks;\n+\t\t} else {\n+\t\t\t// some handlers don't have duplicated blocks\n+\t\t\tif (!hasInnerBlocks || duplicatesCount != (tryBlock.getHandlers().size() - 1)) {\n+\t\t\t\t// unexpected count of duplicated slices\n \t\t\t\treturn false;\n \t\t\t}\n+\t\t\tmergeInnerTryBlocks = false;\n \t\t}\n \n \t\t// remove 'finally' from 'try' blocks, check all up paths on each exit (connected with finally exit)\n@@ -166,9 +187,8 @@ private static boolean extractFinally(MethodNode mth, TryCatchBlockAttr tryBlock\n \t\tapply(extractInfo);\n \t\tallHandler.setFinally(true);\n \n-\t\t// merge inner try blocks\n-\t\tList<TryCatchBlockAttr> innerTryBlocks = tryBlock.getInnerTryBlocks();\n-\t\tif (!innerTryBlocks.isEmpty()) {\n+\t\tif (mergeInnerTryBlocks) {\n+\t\t\tList<TryCatchBlockAttr> innerTryBlocks = tryBlock.getInnerTryBlocks();\n \t\t\tfor (TryCatchBlockAttr innerTryBlock : innerTryBlocks) {\n \t\t\t\ttryBlock.getHandlers().addAll(innerTryBlock.getHandlers());\n \t\t\t\ttryBlock.getBlocks().addAll(innerTryBlock.getBlocks());\n@@ -188,13 +208,6 @@ private static List<BlockNode> getPathStarts(MethodNode mth, BlockNode bottom, B\n \t\treturn preds.collect(Collectors.toList());\n \t}\n \n-\tprivate static void collectAllHandlers(TryCatchBlockAttr tryBlock, List<ExceptionHandler> handlers) {\n-\t\thandlers.addAll(tryBlock.getHandlers());\n-\t\tfor (TryCatchBlockAttr innerTryBlock : tryBlock.getInnerTryBlocks()) {\n-\t\t\tcollectAllHandlers(innerTryBlock, handlers);\n-\t\t}\n-\t}\n-\n \tprivate static boolean checkSlices(FinallyExtractInfo extractInfo) {\n \t\tInsnsSlice finallySlice = extractInfo.getFinallyInsnsSlice();\n \t\tList<InsnNode> finallyInsnsList = finallySlice.getInsnsList();\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally12.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally12.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally12.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally12.java\n@@ -0,0 +1,111 @@\n+package jadx.tests.integration.trycatch;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestTryCatchFinally12 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tprivate StringBuilder sb;\n+\n+\t\tpublic void test1(int excType) {\n+\t\t\ttry {\n+\t\t\t\ttry {\n+\t\t\t\t\tcall(excType);\n+\t\t\t\t} catch (NullPointerException e) {\n+\t\t\t\t\tsb.append(\"-catch\");\n+\t\t\t\t}\n+\t\t\t\tsb.append(\"-out\");\n+\t\t\t} finally {\n+\t\t\t\tsb.append(\"-finally\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void test2(int excType) {\n+\t\t\ttry {\n+\t\t\t\ttry {\n+\t\t\t\t\tcall(excType);\n+\t\t\t\t} catch (NullPointerException e) {\n+\t\t\t\t\tsb.append(\"-catch\");\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\tsb.append(\"-finally\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void test3(int excType) {\n+\t\t\ttry {\n+\t\t\t\tcall(excType);\n+\t\t\t} catch (NullPointerException e) {\n+\t\t\t\tsb.append(\"-catch\");\n+\t\t\t} finally {\n+\t\t\t\tsb.append(\"-finally\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void call(int excType) {\n+\t\t\tsb.append(\"call\");\n+\t\t\tswitch (excType) {\n+\t\t\t\tcase 1:\n+\t\t\t\t\tsb.append(\"-npe\");\n+\t\t\t\t\tthrow new NullPointerException();\n+\t\t\t\tcase 2:\n+\t\t\t\t\tsb.append(\"-iae\");\n+\t\t\t\t\tthrow new IllegalArgumentException();\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic String runTest(int testNumber, int excType) {\n+\t\t\tsb = new StringBuilder();\n+\t\t\ttry {\n+\t\t\t\tswitch (testNumber) {\n+\t\t\t\t\tcase 1:\n+\t\t\t\t\t\ttest1(excType);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase 2:\n+\t\t\t\t\t\ttest2(excType);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase 3:\n+\t\t\t\t\t\ttest3(excType);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t} catch (IllegalArgumentException e) {\n+\t\t\t\tassertThat(excType).isEqualTo(2);\n+\t\t\t}\n+\t\t\treturn sb.toString();\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(runTest(1, 0)).isEqualTo(\"call-out-finally\");\n+\t\t\tassertThat(runTest(1, 1)).isEqualTo(\"call-npe-catch-out-finally\");\n+\t\t\tassertThat(runTest(1, 2)).isEqualTo(\"call-iae-finally\");\n+\n+\t\t\tassertThat(runTest(2, 0)).isEqualTo(\"call-finally\");\n+\t\t\tassertThat(runTest(2, 1)).isEqualTo(\"call-npe-catch-finally\");\n+\t\t\tassertThat(runTest(2, 2)).isEqualTo(\"call-iae-finally\");\n+\n+\t\t\tassertThat(runTest(3, 0)).isEqualTo(\"call-finally\");\n+\t\t\tassertThat(runTest(3, 1)).isEqualTo(\"call-npe-catch-finally\");\n+\t\t\tassertThat(runTest(3, 2)).isEqualTo(\"call-iae-finally\");\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.countString(3, \"} finally {\");\n+\t}\n+\n+\t@Test\n+\tpublic void testWithoutFinally() {\n+\t\tgetArgs().setExtractFinally(false);\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"} finally {\")\n+\t\t\t\t.countString(2 + 2 + 3, \"sb.append(\\\"-finally\\\");\");\n+\t}\n+}",
    "output": "Fix support nested try/finally blocks"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -450,15 +450,18 @@ public MethodNode searchMethodByShortName(String name) {\n \t}\n \n \tpublic ClassNode getParentClass() {\n-\t\tif (parentClass == null) {\n-\t\t\tif (clsInfo.isInner()) {\n-\t\t\t\tClassNode parent = root.resolveClass(clsInfo.getParentClass());\n-\t\t\t\tparentClass = parent == null ? this : parent;\n-\t\t\t} else {\n-\t\t\t\tparentClass = this;\n+\t\treturn parentClass;\n+\t}\n+\n+\tpublic void updateParentClass() {\n+\t\tif (clsInfo.isInner()) {\n+\t\t\tClassNode parent = root.resolveClass(clsInfo.getParentClass());\n+\t\t\tif (parent != null) {\n+\t\t\t\tparentClass = parent;\n+\t\t\t\treturn;\n \t\t\t}\n \t\t}\n-\t\treturn parentClass;\n+\t\tparentClass = this;\n \t}\n \n \tpublic ClassNode getTopParentClass() {\n@@ -548,7 +551,7 @@ public boolean isAnonymous() {\n \t}\n \n \tpublic boolean isInner() {\n-\t\treturn parentClass != null;\n+\t\treturn parentClass != this;\n \t}\n \n \t@Nullable\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -100,14 +100,16 @@ public void loadClasses(List<ILoadResult> loadedInputs) {\n \t\t\tmarkDuplicatedClasses(classes);\n \t\t}\n \t\tclasses = new ArrayList<>(clsMap.values());\n-\t\t// sort classes by name, expect top classes before inner\n-\t\tclasses.sort(Comparator.comparing(ClassNode::getFullName));\n-\t\tinitInnerClasses();\n \n \t\t// print stats for loaded classes\n \t\tint mthCount = classes.stream().mapToInt(c -> c.getMethods().size()).sum();\n \t\tint insnsCount = classes.stream().flatMap(c -> c.getMethods().stream()).mapToInt(MethodNode::getInsnsCount).sum();\n \t\tLOG.info(\"Loaded classes: {}, methods: {}, instructions: {}\", classes.size(), mthCount, insnsCount);\n+\n+\t\t// sort classes by name, expect top classes before inner\n+\t\tclasses.sort(Comparator.comparing(ClassNode::getFullName));\n+\t\t// move inner classes\n+\t\tinitInnerClasses();\n \t}\n \n \tprivate void addDummyClass(IClassData classData, Exception exc) {\n@@ -254,6 +256,7 @@ private void initInnerClasses() {\n \t\t\t\tinnerCls.getClassInfo().updateNames(this);\n \t\t\t}\n \t\t}\n+\t\tclasses.forEach(ClassNode::updateParentClass);\n \t}\n \n \tpublic void runPreDecompileStage() {\n@@ -266,6 +269,9 @@ public void runPreDecompileStage() {\n \t\t\t\tLOG.error(\"Visitor init failed: {}\", pass.getClass().getSimpleName(), e);\n \t\t\t}\n \t\t\tfor (ClassNode cls : classes) {\n+\t\t\t\tif (cls.isInner()) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n \t\t\t\tDepthTraversal.visit(pass, cls);\n \t\t\t}\n \t\t\tif (debugEnabled) {",
    "output": "Fix don't visit inner classes twice in pre-processing"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/SearchBar.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/SearchBar.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/SearchBar.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/SearchBar.java\n@@ -6,9 +6,9 @@\n \n import javax.swing.Icon;\n import javax.swing.JButton;\n-import javax.swing.JCheckBox;\n import javax.swing.JLabel;\n import javax.swing.JTextField;\n+import javax.swing.JToggleButton;\n import javax.swing.JToolBar;\n import javax.swing.text.BadLocationException;\n \n@@ -28,19 +28,25 @@ class SearchBar extends JToolBar {\n \tprivate static final long serialVersionUID = 1836871286618633003L;\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(SearchBar.class);\n-\n+\tprivate static final Icon ICON_MARK = UiUtils.openSvgIcon(\"search/mark\");\n+\tprivate static final Icon ICON_MARK_SELECTED = UiUtils.openSvgIcon(\"search/previewSelected\");\n+\tprivate static final Icon ICON_REGEX = UiUtils.openSvgIcon(\"search/regexHovered\");\n+\tprivate static final Icon ICON_REGEX_SELECTED = UiUtils.openSvgIcon(\"search/regexSelected\");\n+\tprivate static final Icon ICON_WORDS = UiUtils.openSvgIcon(\"search/wordsHovered\");\n+\tprivate static final Icon ICON_WORDS_SELECTED = UiUtils.openSvgIcon(\"search/wordsSelected\");\n+\tprivate static final Icon ICON_MATCH = UiUtils.openSvgIcon(\"search/matchCaseHovered\");\n+\tprivate static final Icon ICON_MATCH_SELECTED = UiUtils.openSvgIcon(\"search/matchCaseSelected\");\n \tprivate static final Icon ICON_UP = UiUtils.openSvgIcon(\"ui/top\");\n \tprivate static final Icon ICON_DOWN = UiUtils.openSvgIcon(\"ui/bottom\");\n \tprivate static final Icon ICON_CLOSE = UiUtils.openSvgIcon(\"ui/close\");\n \n \tprivate RSyntaxTextArea rTextArea;\n \n \tprivate final JTextField searchField;\n-\tprivate final JCheckBox markAllCB;\n-\tprivate final JCheckBox regexCB;\n-\tprivate final JCheckBox wholeWordCB;\n-\tprivate final JCheckBox matchCaseCB;\n-\n+\tprivate final JToggleButton markAllCB;\n+\tprivate final JToggleButton regexCB;\n+\tprivate final JToggleButton wholeWordCB;\n+\tprivate final JToggleButton matchCaseCB;\n \tprivate boolean notFound;\n \n \tpublic SearchBar(RSyntaxTextArea textArea) {\n@@ -70,36 +76,50 @@ public void keyReleased(KeyEvent e) {\n \t\tnew TextStandardActions(searchField);\n \t\tadd(searchField);\n \n-\t\tJButton prevButton = new JButton(NLS.str(\"search.previous\"));\n+\t\tActionListener forwardListener = e -> search(1);\n+\n+\t\tmatchCaseCB = new JToggleButton();\n+\t\tmatchCaseCB.setIcon(ICON_MATCH);\n+\t\tmatchCaseCB.setSelectedIcon(ICON_MATCH_SELECTED);\n+\t\tmatchCaseCB.setToolTipText(NLS.str(\"search.match_case\"));\n+\t\tmatchCaseCB.addActionListener(forwardListener);\n+\t\tadd(matchCaseCB);\n+\n+\t\twholeWordCB = new JToggleButton();\n+\t\twholeWordCB.setIcon(ICON_WORDS);\n+\t\twholeWordCB.setSelectedIcon(ICON_WORDS_SELECTED);\n+\t\twholeWordCB.setToolTipText(NLS.str(\"search.whole_word\"));\n+\t\twholeWordCB.addActionListener(forwardListener);\n+\t\tadd(wholeWordCB);\n+\n+\t\tregexCB = new JToggleButton();\n+\t\tregexCB.setIcon(ICON_REGEX);\n+\t\tregexCB.setSelectedIcon(ICON_REGEX_SELECTED);\n+\t\tregexCB.setToolTipText(NLS.str(\"search.regex\"));\n+\t\tregexCB.addActionListener(forwardListener);\n+\t\tadd(regexCB);\n+\n+\t\tJButton prevButton = new JButton();\n \t\tprevButton.setIcon(ICON_UP);\n+\t\tprevButton.setToolTipText(NLS.str(\"search.previous\"));\n \t\tprevButton.addActionListener(e -> search(-1));\n \t\tprevButton.setBorderPainted(false);\n \t\tadd(prevButton);\n \n-\t\tJButton nextButton = new JButton(NLS.str(\"search.next\"));\n+\t\tJButton nextButton = new JButton();\n \t\tnextButton.setIcon(ICON_DOWN);\n+\t\tnextButton.setToolTipText(NLS.str(\"search.next\"));\n \t\tnextButton.addActionListener(e -> search(1));\n \t\tnextButton.setBorderPainted(false);\n \t\tadd(nextButton);\n \n-\t\tActionListener forwardListener = e -> search(0);\n-\n-\t\tmarkAllCB = new JCheckBox(NLS.str(\"search.mark_all\"));\n+\t\tmarkAllCB = new JToggleButton();\n+\t\tmarkAllCB.setIcon(ICON_MARK);\n+\t\tmarkAllCB.setSelectedIcon(ICON_MARK_SELECTED);\n+\t\tmarkAllCB.setToolTipText(NLS.str(\"search.mark_all\"));\n \t\tmarkAllCB.addActionListener(forwardListener);\n \t\tadd(markAllCB);\n \n-\t\tregexCB = new JCheckBox(NLS.str(\"search.regex\"));\n-\t\tregexCB.addActionListener(forwardListener);\n-\t\tadd(regexCB);\n-\n-\t\tmatchCaseCB = new JCheckBox(NLS.str(\"search.match_case\"));\n-\t\tmatchCaseCB.addActionListener(forwardListener);\n-\t\tadd(matchCaseCB);\n-\n-\t\twholeWordCB = new JCheckBox(NLS.str(\"search.whole_word\"));\n-\t\twholeWordCB.addActionListener(forwardListener);\n-\t\tadd(wholeWordCB);\n-\n \t\tJButton closeButton = new JButton();\n \t\tcloseButton.setIcon(ICON_CLOSE);\n \t\tcloseButton.addActionListener(e -> toggle());\n@@ -110,7 +130,7 @@ public void keyReleased(KeyEvent e) {\n \t\tsetVisible(false);\n \t}\n \n-\tpublic boolean toggle() {\n+\tpublic void toggle() {\n \t\tboolean visible = !isVisible();\n \t\tsetVisible(visible);\n \n@@ -124,7 +144,6 @@ public boolean toggle() {\n \t\t} else {\n \t\t\trTextArea.requestFocus();\n \t\t}\n-\t\treturn visible;\n \t}\n \n \tprivate void search(int direction) {\n@@ -177,11 +196,4 @@ private void search(int direction) {\n \t\t}\n \t\tsearchField.repaint();\n \t}\n-\n-\tpublic void setRTextArea(RSyntaxTextArea rTextArea) {\n-\t\tthis.rTextArea = rTextArea;\n-\t\tif (isVisible()) {\n-\t\t\tthis.search(0);\n-\t\t}\n-\t}\n }",
    "output": "Fix updated SearchBar in code viewer"
  },
  {
    "input": "diff --git a/jadx-cli/src/test/java/jadx/cli/TestInput.java b/jadx-cli/src/test/java/jadx/cli/TestInput.java\n--- a/jadx-cli/src/test/java/jadx/cli/TestInput.java\n+++ b/jadx-cli/src/test/java/jadx/cli/TestInput.java\n@@ -7,6 +7,7 @@\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n import java.util.List;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n@@ -44,19 +45,20 @@ public void testMultipleInput() throws Exception {\n \t}\n \n \tprivate void decompile(String tmpDirName, String... inputSamples) throws URISyntaxException, IOException {\n-\t\tStringBuilder args = new StringBuilder();\n+\t\tList<String> args = new ArrayList<>();\n \t\tPath tempDir = FileUtils.createTempDir(tmpDirName);\n-\t\targs.append(\"-v\");\n-\t\targs.append(\" -d \").append(tempDir.toAbsolutePath());\n+\t\targs.add(\"-v\");\n+\t\targs.add(\"-d\");\n+\t\targs.add(tempDir.toAbsolutePath().toString());\n \n \t\tfor (String inputSample : inputSamples) {\n \t\t\tURL resource = getClass().getClassLoader().getResource(inputSample);\n \t\t\tassertThat(resource).isNotNull();\n \t\t\tString sampleFile = resource.toURI().getRawPath();\n-\t\t\targs.append(' ').append(sampleFile);\n+\t\t\targs.add(sampleFile);\n \t\t}\n \n-\t\tint result = JadxCLI.execute(args.toString().split(\" \"));\n+\t\tint result = JadxCLI.execute(args.toArray(new String[0]));\n \t\tassertThat(result).isEqualTo(0);\n \t\tList<Path> resultJavaFiles = collectJavaFilesInDir(tempDir);\n \t\tassertThat(resultJavaFiles).isNotEmpty();",
    "output": "Use maven-publish for JitPack and other fixes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -147,16 +147,24 @@ private void parseResourceMap() throws IOException {\n \t}\n \n \tprivate void parseNameSpace() throws IOException {\n-\t\tif (is.readInt16() != 0x10) {\n-\t\t\tdie(\"NAMESPACE header is not 0x0010\");\n+\t\tint headerSize = is.readInt16();\n+\t\tif (headerSize > 0x10) {\n+\t\t\tLOG.warn(\"Invalid namespace header\");\n+\t\t} else if (headerSize < 0x10) {\n+\t\t\tdie(\"NAMESPACE header is not 0x10 big\");\n \t\t}\n-\t\tif (is.readInt32() != 0x18) {\n+\t\tint size = is.readInt32();\n+\t\tif (size > 0x18) {\n+\t\t\tLOG.warn(\"Invalid namespace size\");\n+\t\t} else if (size < 0x18) {\n \t\t\tdie(\"NAMESPACE header chunk is not 0x18 big\");\n \t\t}\n+\n \t\tint beginLineNumber = is.readInt32();\n \t\tint comment = is.readInt32();\n \t\tint beginPrefix = is.readInt32();\n \t\tint beginURI = is.readInt32();\n+\t\tis.skip(headerSize - 0x10);\n \n \t\tString nsKey = getString(beginURI);\n \t\tString nsValue = getString(beginPrefix);\n@@ -167,16 +175,23 @@ private void parseNameSpace() throws IOException {\n \t}\n \n \tprivate void parseNameSpaceEnd() throws IOException {\n-\t\tif (is.readInt16() != 0x10) {\n-\t\t\tdie(\"NAMESPACE header is not 0x0010\");\n-\t\t}\n-\t\tif (is.readInt32() != 0x18) {\n+\t\tint headerSize = is.readInt16();\n+\t\tif (headerSize > 0x10) {\n+\t\t\tLOG.warn(\"Invalid namespace end\");\n+\t\t} else if (headerSize < 0x10) {\n+\t\t\tdie(\"NAMESPACE end is not 0x10 big\");\n+\t\t}\n+\t\tint dataSize = is.readInt32();\n+\t\tif (dataSize > 0x18) {\n+\t\t\tLOG.warn(\"Invalid namespace size\");\n+\t\t} else if (dataSize < 0x18) {\n \t\t\tdie(\"NAMESPACE header chunk is not 0x18 big\");\n \t\t}\n \t\tint endLineNumber = is.readInt32();\n \t\tint comment = is.readInt32();\n \t\tint endPrefix = is.readInt32();\n \t\tint endURI = is.readInt32();\n+\t\tis.skip(headerSize - 0x10);\n \t\tnamespaceDepth--;\n \n \t\tString nsKey = getString(endURI);",
    "output": "Fix handle incorrect android manifest namespace chunks * allow for handling of incorrect android manifest namespace chunks * Update BinaryXMLParser.java"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n@@ -1,6 +1,7 @@\n package jadx.core.dex.visitors;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n \n@@ -16,8 +17,6 @@\n import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxException;\n \n-import static java.util.Collections.unmodifiableList;\n-\n public class SignatureProcessor extends AbstractVisitor {\n \n \tprivate RootNode root;\n@@ -106,25 +105,38 @@ private void parseMethodSignature(MethodNode mth) {\n \t\t\tList<ArgType> parsedArgTypes = sp.consumeMethodArgs(mth.getMethodInfo().getArgsCount());\n \t\t\tArgType parsedRetType = sp.consumeType();\n \n-\t\t\tif (!validateParsedType(parsedRetType, mth.getMethodInfo().getReturnType())) {\n-\t\t\t\tmth.addWarnComment(\"Incorrect return type in method signature: \" + sp.getSignature());\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tList<ArgType> checkedArgTypes = checkArgTypes(mth, sp, parsedArgTypes);\n-\t\t\tif (checkedArgTypes == null) {\n-\t\t\t\treturn;\n-\t\t\t}\n \t\t\tmth.updateTypeParameters(typeParameters); // apply before expand args\n-\n \t\t\tTypeUtils typeUtils = root.getTypeUtils();\n \t\t\tArgType retType = typeUtils.expandTypeVariables(mth, parsedRetType);\n-\t\t\tList<ArgType> resultArgTypes = Utils.collectionMap(checkedArgTypes, t -> typeUtils.expandTypeVariables(mth, t));\n-\t\t\tmth.updateTypes(unmodifiableList(resultArgTypes), retType);\n+\t\t\tList<ArgType> argTypes = Utils.collectionMap(parsedArgTypes, t -> typeUtils.expandTypeVariables(mth, t));\n+\n+\t\t\tif (!validateAndApplyTypes(mth, sp, retType, argTypes)) {\n+\t\t\t\t// bad types -> reset typed parameters\n+\t\t\t\tmth.updateTypeParameters(Collections.emptyList());\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\tmth.addWarnComment(\"Failed to parse method signature: \" + sp.getSignature(), e);\n \t\t}\n \t}\n \n+\tprivate boolean validateAndApplyTypes(MethodNode mth, SignatureParser sp, ArgType retType, List<ArgType> argTypes) {\n+\t\ttry {\n+\t\t\tif (!validateParsedType(retType, mth.getMethodInfo().getReturnType())) {\n+\t\t\t\tmth.addWarnComment(\"Incorrect return type in method signature: \" + sp.getSignature());\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tList<ArgType> checkedArgTypes = checkArgTypes(mth, sp, argTypes);\n+\t\t\tif (checkedArgTypes == null) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tmth.updateTypes(Utils.lockList(checkedArgTypes), retType);\n+\t\t\treturn true;\n+\t\t} catch (Exception e) {\n+\t\t\tmth.addWarnComment(\"Type validation failed for signature: \" + sp.getSignature(), e);\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n \tprivate List<ArgType> checkArgTypes(MethodNode mth, SignatureParser sp, List<ArgType> parsedArgTypes) {\n \t\tMethodInfo mthInfo = mth.getMethodInfo();\n \t\tList<ArgType> mthArgTypes = mthInfo.getArgumentsTypes();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n@@ -245,12 +245,12 @@ private TypeCompareEnum compareGenericTypeWithObject(ArgType genericType, ArgTyp\n \t\tif (objType.isGenericType()) {\n \t\t\treturn compareTypeVariables(genericType, objType);\n \t\t}\n-\n+\t\tboolean rootObject = objType.equals(ArgType.OBJECT);\n \t\tList<ArgType> extendTypes = genericType.getExtendTypes();\n \t\tif (extendTypes.isEmpty()) {\n-\t\t\treturn NARROW;\n+\t\t\treturn rootObject ? NARROW : CONFLICT;\n \t\t}\n-\t\tif (extendTypes.contains(objType) || objType.equals(ArgType.OBJECT)) {\n+\t\tif (extendTypes.contains(objType) || rootObject) {\n \t\t\treturn NARROW;\n \t\t}\n \t\tfor (ArgType extendType : extendTypes) {\n\ndiff --git a/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java b/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n--- a/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n+++ b/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n@@ -138,7 +138,7 @@ public void compareWildCards() {\n \tpublic void compareGenericTypes() {\n \t\tArgType vType = genericType(\"V\");\n \t\tcheck(vType, OBJECT, TypeCompareEnum.NARROW);\n-\t\tcheck(vType, STRING, TypeCompareEnum.NARROW);\n+\t\tcheck(vType, STRING, TypeCompareEnum.CONFLICT);\n \n \t\tArgType rType = genericType(\"R\");\n \t\tcheck(vType, rType, TypeCompareEnum.CONFLICT);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver18.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver18.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver18.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver18.java\n@@ -0,0 +1,37 @@\n+package jadx.tests.integration.types;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestTypeResolver18 extends IntegrationTest {\n+\n+\tpublic static class TestCls<T> {\n+\t\tprivate final AtomicReference<T> reference = new AtomicReference<>();\n+\n+\t\tpublic void test() {\n+\t\t\tT t = this.reference.get();\n+\t\t\tif (t instanceof Closeable) {\n+\t\t\t\ttry {\n+\t\t\t\t\t((Closeable) t).close();\n+\t\t\t\t} catch (IOException unused) {\n+\t\t\t\t\t// ignore\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tthis.reference.set(null);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"((Closeable) t).close();\");\n+\t}\n+}",
    "output": "Fix handle unbound type variables in type inference"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -579,7 +579,7 @@ public void useClass(ICodeWriter code, ClassNode classNode) {\n \t\taddClsName(code, classNode.getClassInfo());\n \t}\n \n-\tprivate void addClsName(ICodeWriter code, ClassInfo classInfo) {\n+\tpublic void addClsName(ICodeWriter code, ClassInfo classInfo) {\n \t\tString clsName = useClassInternal(cls.getClassInfo(), classInfo);\n \t\tcode.add(clsName);\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -677,13 +677,17 @@ private void makeConstructor(ConstructorInsn insn, ICodeWriter code) throws Code\n \t\tif (insn.isSelf()) {\n \t\t\tthrow new JadxRuntimeException(\"Constructor 'self' invoke must be removed!\");\n \t\t}\n+\t\tMethodNode callMth = mth.root().resolveMethod(insn.getCallMth());\n \t\tif (insn.isSuper()) {\n+\t\t\tcode.attachAnnotation(callMth);\n \t\t\tcode.add(\"super\");\n \t\t} else if (insn.isThis()) {\n+\t\t\tcode.attachAnnotation(callMth);\n \t\t\tcode.add(\"this\");\n \t\t} else {\n \t\t\tcode.add(\"new \");\n-\t\t\tuseClass(code, insn.getClassType());\n+\t\t\tcode.attachAnnotation(callMth);\n+\t\t\tmgen.getClassGen().addClsName(code, insn.getClassType());\n \t\t\tGenericInfoAttr genericInfoAttr = insn.get(AType.GENERIC_INFO);\n \t\t\tif (genericInfoAttr != null) {\n \t\t\t\tcode.add('<');\n@@ -701,7 +705,6 @@ private void makeConstructor(ConstructorInsn insn, ICodeWriter code) throws Code\n \t\t\t\tcode.add('>');\n \t\t\t}\n \t\t}\n-\t\tMethodNode callMth = mth.root().resolveMethod(insn.getCallMth());\n \t\tgenerateMethodArguments(code, insn, 0, callMth);\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java b/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n@@ -12,6 +12,7 @@\n \n import jadx.api.CodePosition;\n import jadx.api.JavaClass;\n+import jadx.api.JavaMethod;\n import jadx.api.JavaNode;\n import jadx.gui.treemodel.CodeNode;\n import jadx.gui.treemodel.JNode;\n@@ -55,7 +56,14 @@ public void processClass(JavaClass javaClass, CodeLinesInfo linesInfo, List<Stri\n \t\t\t\t\t// skip declaration\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n-\t\t\t\taddUsage(nodeCache.makeFrom(javaNode), javaClass, linesInfo, codePosition, lines);\n+\t\t\t\tJNode node = nodeCache.makeFrom(javaNode);\n+\t\t\t\taddUsage(node, javaClass, linesInfo, codePosition, lines);\n+\t\t\t\tif (javaNode instanceof JavaMethod) {\n+\t\t\t\t\t// add constructor usage also as class usage\n+\t\t\t\t\tif (((JavaMethod) javaNode).isConstructor()) {\n+\t\t\t\t\t\taddUsage(node.getJParent(), javaClass, linesInfo, codePosition, lines);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Code usage process failed for class: {}\", javaClass, e);\n@@ -64,12 +72,16 @@ public void processClass(JavaClass javaClass, CodeLinesInfo linesInfo, List<Stri\n \n \tprivate void addUsage(JNode jNode, JavaClass javaClass,\n \t\t\tCodeLinesInfo linesInfo, CodePosition codePosition, List<StringRef> lines) {\n-\t\tUsageInfo usageInfo = usageMap.computeIfAbsent(jNode, key -> new UsageInfo());\n \t\tint line = codePosition.getLine();\n-\t\tJavaNode javaNodeByLine = linesInfo.getJavaNodeByLine(line);\n \t\tStringRef codeLine = lines.get(line - 1);\n+\t\tif (codeLine.startsWith(\"import \")) {\n+\t\t\t// skip imports\n+\t\t\treturn;\n+\t\t}\n+\t\tJavaNode javaNodeByLine = linesInfo.getJavaNodeByLine(line);\n \t\tJNode node = nodeCache.makeFrom(javaNodeByLine == null ? javaClass : javaNodeByLine);\n \t\tCodeNode codeNode = new CodeNode(node, codeLine, line, codePosition.getPos());\n+\t\tUsageInfo usageInfo = usageMap.computeIfAbsent(jNode, key -> new UsageInfo());\n \t\tusageInfo.addUsage(codeNode);\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/search/StringRef.java b/jadx-gui/src/main/java/jadx/gui/utils/search/StringRef.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/search/StringRef.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/StringRef.java\n@@ -117,6 +117,19 @@ private static int indexOf(String source, int sourceOffset, int sourceCount,\n \t\treturn -1;\n \t}\n \n+\tpublic boolean startsWith(String str) {\n+\t\tint strLen = str.length();\n+\t\tif (this.length < strLen) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tfor (int i = 0; i < strLen; i++) {\n+\t\t\tif (charAt(i) != str.charAt(i)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n \tpublic static List<StringRef> split(String str, String splitBy) {\n \t\tint len = str.length();\n \t\tint targetLen = splitBy.length();",
    "output": "Fix improve constructors and classes usage list"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -1108,6 +1108,7 @@ public Component getTreeCellRendererComponent(JTree tree,\n \t\t\t\tComponent c = super.getTreeCellRendererComponent(tree, value, selected, expanded, isLeaf, row, focused);\n \t\t\t\tif (value instanceof JNode) {\n \t\t\t\t\tJNode jNode = (JNode) value;\n+\t\t\t\t\tsetText(jNode.makeStringHtml());\n \t\t\t\t\tsetIcon(jNode.getIcon());\n \t\t\t\t\tsetToolTipText(jNode.getTooltip());\n \t\t\t\t} else {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/UiUtils.java\n@@ -32,6 +32,7 @@\n \n import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.ui.codearea.AbstractCodeArea;\n \n@@ -117,20 +118,43 @@ public static String typeStr(ArgType type) {\n \t\t\treturn \"null\";\n \t\t}\n \t\tif (type.isObject()) {\n-\t\t\tString cls = type.toString();\n-\t\t\tint dot = cls.lastIndexOf('.');\n-\t\t\tif (dot != -1) {\n-\t\t\t\treturn cls.substring(dot + 1);\n-\t\t\t} else {\n-\t\t\t\treturn cls;\n+\t\t\tif (type.isGenericType()) {\n+\t\t\t\treturn type.getObject();\n \t\t\t}\n+\t\t\tArgType wt = type.getWildcardType();\n+\t\t\tif (wt != null) {\n+\t\t\t\tArgType.WildcardBound bound = type.getWildcardBound();\n+\t\t\t\tif (bound == ArgType.WildcardBound.UNBOUND) {\n+\t\t\t\t\treturn bound.getStr();\n+\t\t\t\t}\n+\t\t\t\treturn bound.getStr() + typeStr(wt);\n+\t\t\t}\n+\t\t\tString objName = objectShortName(type.getObject());\n+\t\t\tArgType outerType = type.getOuterType();\n+\t\t\tif (outerType != null) {\n+\t\t\t\treturn typeStr(outerType) + '.' + objName;\n+\t\t\t}\n+\t\t\tList<ArgType> genericTypes = type.getGenericTypes();\n+\t\t\tif (genericTypes != null) {\n+\t\t\t\tString generics = Utils.listToString(genericTypes, \", \", UiUtils::typeStr);\n+\t\t\t\treturn objName + '<' + generics + '>';\n+\t\t\t}\n+\t\t\treturn objName;\n \t\t}\n \t\tif (type.isArray()) {\n \t\t\treturn typeStr(type.getArrayElement()) + \"[]\";\n \t\t}\n \t\treturn type.toString();\n \t}\n \n+\tprivate static String objectShortName(String obj) {\n+\t\tint dot = obj.lastIndexOf('.');\n+\t\tif (dot != -1) {\n+\t\t\treturn obj.substring(dot + 1);\n+\t\t}\n+\t\treturn obj;\n+\t}\n+\n \tpublic static OverlayIcon makeIcon(AccessInfo af, Icon pub, Icon pri, Icon pro, Icon def) {\n \t\tIcon icon;\n \t\tif (af.isPublic()) {",
    "output": "Use correct type formatter in class tree"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java b/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n@@ -50,6 +50,11 @@ public void processClass(JavaClass javaClass, CodeLinesInfo linesInfo, List<Stri\n \t\t\tfor (Map.Entry<CodePosition, JavaNode> entry : usage.entrySet()) {\n \t\t\t\tCodePosition codePosition = entry.getKey();\n \t\t\t\tJavaNode javaNode = entry.getValue();\n+\t\t\t\tif (javaNode.getTopParentClass().equals(javaClass)\n+\t\t\t\t\t\t&& codePosition.getPos() == javaNode.getDefPos()) {\n+\t\t\t\t\t// skip declaration\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n \t\t\t\taddUsage(nodeCache.makeFrom(javaNode), javaClass, linesInfo, codePosition, lines);\n \t\t\t}\n \t\t} catch (Exception e) {",
    "output": "Fix exclude declaration from usage list"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java b/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n--- a/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n+++ b/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n@@ -113,21 +113,27 @@ private ApplicationParams getApplicationParams(Document androidManifest, Documen\n \t\tInteger targetSdk = Integer.valueOf(usesSdk.getAttribute(\"android:targetSdkVersion\"));\n \t\tString appName = \"UNKNOWN\";\n \n-\t\tString appLabelName = application.getAttribute(\"android:label\").split(\"/\")[1];\n-\t\tNodeList strings = appStrings.getElementsByTagName(\"string\");\n-\n-\t\tfor (int i = 0; i < strings.getLength(); i++) {\n-\t\t\tString stringName = strings.item(i)\n-\t\t\t\t\t.getAttributes()\n-\t\t\t\t\t.getNamedItem(\"name\")\n-\t\t\t\t\t.getNodeValue();\n-\n-\t\t\tif (stringName.equals(appLabelName)) {\n-\t\t\t\tappName = strings.item(i).getTextContent();\n-\t\t\t\tbreak;\n+\t\tif (application.hasAttribute(\"android:label\")) {\n+\t\t\tString appLabelName = application.getAttribute(\"android:label\");\n+\t\t\tif (appLabelName.startsWith(\"@string\")) {\n+\t\t\t\tappLabelName = appLabelName.split(\"/\")[1];\n+\t\t\t\tNodeList strings = appStrings.getElementsByTagName(\"string\");\n+\n+\t\t\t\tfor (int i = 0; i < strings.getLength(); i++) {\n+\t\t\t\t\tString stringName = strings.item(i)\n+\t\t\t\t\t\t\t.getAttributes()\n+\t\t\t\t\t\t\t.getNamedItem(\"name\")\n+\t\t\t\t\t\t\t.getNodeValue();\n+\n+\t\t\t\t\tif (stringName.equals(appLabelName)) {\n+\t\t\t\t\t\tappName = strings.item(i).getTextContent();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tappName = appLabelName;\n \t\t\t}\n \t\t}\n-\n \t\treturn new ApplicationParams(appName, minSdk, targetSdk, versionCode, versionName);\n \t}",
    "output": "Fix additional checks for export to gradle"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n@@ -35,6 +35,9 @@ public boolean visit(ClassNode cls) throws JadxException {\n \n \tprivate static void markAnonymousClass(ClassNode cls) {\n \t\tif (usedOnlyOnce(cls) || isAnonymous(cls) || isLambdaCls(cls)) {\n+\t\t\tif (isStaticFieldUsedOutside(cls)) {\n+\t\t\t\treturn;\n+\t\t\t}\n \t\t\tcls.add(AFlag.ANONYMOUS_CLASS);\n \t\t\tcls.add(AFlag.DONT_GENERATE);\n \n@@ -46,6 +49,21 @@ private static void markAnonymousClass(ClassNode cls) {\n \t\t}\n \t}\n \n+\tprivate static boolean isStaticFieldUsedOutside(ClassNode cls) {\n+\t\tClassNode topCls = cls.getTopParentClass();\n+\t\tfor (FieldNode field : cls.getFields()) {\n+\t\t\tif (field.isStatic()) {\n+\t\t\t\tfor (MethodNode useMth : field.getUseIn()) {\n+\t\t\t\t\tClassNode useCls = useMth.getParentClass().getTopParentClass();\n+\t\t\t\t\tif (!useCls.equals(topCls)) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tprivate static boolean usedOnlyOnce(ClassNode cls) {\n \t\tif (cls.getUseIn().size() == 1 && cls.getUseInMth().size() == 1) {\n \t\t\t// used only once",
    "output": "Fix keep lambda classes if static field used outside"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -335,19 +335,25 @@ private String generateNameForNS(String attrUrl) {\n \t}\n \n \tprivate String getAttributeName(int id) {\n-\t\tString str = getString(id);\n-\t\tif (str == null || str.isEmpty()) {\n+\t\t// As the outcome of https://github.com/skylot/jadx/issues/1208\n+\t\t// Android seems to favor entries from AndroidResMap and only if\n+\t\t// there is no entry uses the values form the XML string pool\n+\t\tif (0 <= id && id < resourceIds.length) {\n \t\t\tint resId = resourceIds[id];\n-\t\t\tstr = ValuesParser.getAndroidResMap().get(resId);\n-\t\t\tif (str == null) {\n-\t\t\t\treturn \"NOT_FOUND_0x\" + Integer.toHexString(id);\n-\t\t\t}\n-\t\t\t// cut type before /\n-\t\t\tint typeEnd = str.indexOf('/');\n-\t\t\tif (typeEnd != -1) {\n-\t\t\t\treturn str.substring(typeEnd + 1);\n+\t\t\tString str = ValuesParser.getAndroidResMap().get(resId);\n+\t\t\tif (str != null) {\n+\t\t\t\t// cut type before /\n+\t\t\t\tint typeEnd = str.indexOf('/');\n+\t\t\t\tif (typeEnd != -1) {\n+\t\t\t\t\treturn str.substring(typeEnd + 1);\n+\t\t\t\t}\n+\t\t\t\treturn str;\n \t\t\t}\n-\t\t\treturn str;\n+\t\t}\n+\n+\t\tString str = getString(id);\n+\t\tif (str == null || str.isEmpty()) {\n+\t\t\treturn \"NOT_FOUND_0x\" + Integer.toHexString(id);\n \t\t}\n \t\treturn str;\n \t}",
    "output": "Fix reversed XML attribute name decoding priority"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/ClassTypeVarsAttr.java b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/ClassTypeVarsAttr.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/ClassTypeVarsAttr.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/ClassTypeVarsAttr.java\n@@ -31,8 +31,12 @@ public List<ArgType> getTypeVars() {\n \t\treturn typeVars;\n \t}\n \n-\tpublic Map<String, Map<ArgType, ArgType>> getSuperTypeMaps() {\n-\t\treturn superTypeMaps;\n+\tpublic Map<ArgType, ArgType> getTypeVarsMapFor(ArgType type) {\n+\t\tMap<ArgType, ArgType> typeMap = superTypeMaps.get(type.getObject());\n+\t\tif (typeMap == null) {\n+\t\t\treturn Collections.emptyMap();\n+\t\t}\n+\t\treturn typeMap;\n \t}\n \n \t@Override\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n@@ -805,6 +805,10 @@ public boolean containsTypeVariable() {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tArgType outerType = getOuterType();\n+\t\t\tif (outerType != null) {\n+\t\t\t\treturn outerType.containsTypeVariable();\n+\t\t\t}\n \t\t\treturn false;\n \t\t}\n \t\tif (isArray()) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n@@ -164,19 +164,41 @@ public ArgType replaceClassGenerics(ArgType instanceType, ArgType genericSourceT\n \t\tif (typeWithGeneric == null || genericSourceType == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tMap<ArgType, ArgType> typeVarsMap;\n+\t\tMap<ArgType, ArgType> typeVarsMap = Collections.emptyMap();\n \t\tClassTypeVarsAttr typeVars = getClassTypeVars(instanceType);\n \t\tif (typeVars != null) {\n-\t\t\ttypeVarsMap = typeVars.getSuperTypeMaps().get(genericSourceType.getObject());\n-\t\t} else {\n-\t\t\ttypeVarsMap = getTypeVariablesMapping(instanceType);\n+\t\t\ttypeVarsMap = mergeTypeMaps(typeVarsMap, typeVars.getTypeVarsMapFor(genericSourceType));\n \t\t}\n-\t\tif (typeVarsMap == null) {\n-\t\t\treturn null;\n+\t\ttypeVarsMap = mergeTypeMaps(typeVarsMap, getTypeVariablesMapping(instanceType));\n+\t\tArgType outerType = instanceType.getOuterType();\n+\t\twhile (outerType != null) {\n+\t\t\ttypeVarsMap = mergeTypeMaps(typeVarsMap, getTypeVariablesMapping(outerType));\n+\t\t\touterType = outerType.getOuterType();\n \t\t}\n \t\treturn replaceTypeVariablesUsingMap(typeWithGeneric, typeVarsMap);\n \t}\n \n+\tprivate static Map<ArgType, ArgType> mergeTypeMaps(Map<ArgType, ArgType> base, Map<ArgType, ArgType> addition) {\n+\t\tif (base.isEmpty()) {\n+\t\t\treturn addition;\n+\t\t}\n+\t\tif (addition.isEmpty()) {\n+\t\t\treturn base;\n+\t\t}\n+\t\tMap<ArgType, ArgType> map = new HashMap<>(base.size() + addition.size());\n+\t\tfor (Map.Entry<ArgType, ArgType> entry : base.entrySet()) {\n+\t\t\tArgType value = entry.getValue();\n+\t\t\tArgType type = addition.remove(value);\n+\t\t\tif (type != null) {\n+\t\t\t\tmap.put(entry.getKey(), type);\n+\t\t\t} else {\n+\t\t\t\tmap.put(entry.getKey(), entry.getValue());\n+\t\t\t}\n+\t\t}\n+\t\tmap.putAll(addition);\n+\t\treturn map;\n+\t}\n+\n \tpublic Map<ArgType, ArgType> getTypeVariablesMapping(ArgType clsType) {\n \t\tif (!clsType.isGeneric()) {\n \t\t\treturn Collections.emptyMap();\n@@ -274,13 +296,25 @@ public ArgType replaceTypeVariablesUsingMap(ArgType replaceType, Map<ArgType, Ar\n \t\t\treturn ArgType.wildcard(newWildcardType, replaceType.getWildcardBound());\n \t\t}\n \n-\t\tList<ArgType> genericTypes = replaceType.getGenericTypes();\n-\t\tif (replaceType.isGeneric() && notEmpty(genericTypes)) {\n-\t\t\tList<ArgType> newTypes = Utils.collectionMap(genericTypes, t -> {\n-\t\t\t\tArgType type = replaceTypeVariablesUsingMap(t, replaceMap);\n-\t\t\t\treturn type == null ? t : type;\n-\t\t\t});\n-\t\t\treturn ArgType.generic(replaceType, newTypes);\n+\t\tif (replaceType.isGeneric()) {\n+\t\t\tArgType outerType = replaceType.getOuterType();\n+\t\t\tif (outerType != null) {\n+\t\t\t\tArgType replacedOuter = replaceTypeVariablesUsingMap(outerType, replaceMap);\n+\t\t\t\tif (replacedOuter == null) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tArgType innerType = replaceType.getInnerType();\n+\t\t\t\tArgType replacedInner = replaceTypeVariablesUsingMap(innerType, replaceMap);\n+\t\t\t\treturn ArgType.outerGeneric(replacedOuter, replacedInner == null ? innerType : replacedInner);\n+\t\t\t}\n+\t\t\tList<ArgType> genericTypes = replaceType.getGenericTypes();\n+\t\t\tif (notEmpty(genericTypes)) {\n+\t\t\t\tList<ArgType> newTypes = Utils.collectionMap(genericTypes, t -> {\n+\t\t\t\t\tArgType type = replaceTypeVariablesUsingMap(t, replaceMap);\n+\t\t\t\t\treturn type == null ? t : type;\n+\t\t\t\t});\n+\t\t\t\treturn ArgType.generic(replaceType, newTypes);\n+\t\t\t}\n \t\t}\n \t\treturn null;\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/core/dex/instructions/args/ArgTypeTest.java b/jadx-core/src/test/java/jadx/core/dex/instructions/args/ArgTypeTest.java\n--- a/jadx-core/src/test/java/jadx/core/dex/instructions/args/ArgTypeTest.java\n+++ b/jadx-core/src/test/java/jadx/core/dex/instructions/args/ArgTypeTest.java\n@@ -36,11 +36,11 @@ void testInnerGeneric() {\n \t\tArgType base = ArgType.generic(\"java.util.Map\", genericTypes);\n \n \t\tArgType genericInner = ArgType.outerGeneric(base, ArgType.generic(\"Entry\", genericTypes));\n-\t\tLOG.debug(\"genericInner : {}\", genericInner);\n+\t\tassertThat(genericInner.toString(), is(\"java.util.Map<K, V>$Entry<K, V>\"));\n+\t\tassertTrue(genericInner.containsTypeVariable());\n \n \t\tArgType genericInner2 = ArgType.outerGeneric(base, ArgType.object(\"Entry\"));\n-\t\tLOG.debug(\"genericInner2: {}\", genericInner2);\n-\n-\t\tassertThat(genericInner.toString(), is(\"java.util.Map<K, V>$Entry<K, V>\"));\n+\t\tassertThat(genericInner2.toString(), is(\"java.util.Map<K, V>$Entry\"));\n+\t\tassertTrue(genericInner2.containsTypeVariable());\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/core/dex/nodes/utils/TypeUtilsTest.java b/jadx-core/src/test/java/jadx/core/dex/nodes/utils/TypeUtilsTest.java\n--- a/jadx-core/src/test/java/jadx/core/dex/nodes/utils/TypeUtilsTest.java\n+++ b/jadx-core/src/test/java/jadx/core/dex/nodes/utils/TypeUtilsTest.java\n@@ -1,6 +1,7 @@\n package jadx.core.dex.nodes.utils;\n \n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.Map;\n \n import org.junit.jupiter.api.BeforeEach;\n@@ -10,11 +11,13 @@\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.nodes.RootNode;\n \n+import static jadx.core.dex.instructions.args.ArgType.EXCEPTION;\n import static jadx.core.dex.instructions.args.ArgType.STRING;\n import static jadx.core.dex.instructions.args.ArgType.array;\n import static jadx.core.dex.instructions.args.ArgType.generic;\n import static jadx.core.dex.instructions.args.ArgType.genericType;\n import static jadx.core.dex.instructions.args.ArgType.object;\n+import static jadx.core.dex.instructions.args.ArgType.outerGeneric;\n import static org.assertj.core.api.Assertions.assertThat;\n \n class TypeUtilsTest {\n@@ -36,6 +39,26 @@ void replaceTypeVariablesUsingMap() {\n \t\treplaceTypeVar(array(typeVar), typeMap, array(STRING));\n \t}\n \n+\t@Test\n+\tvoid replaceTypeVariablesUsingMap2() {\n+\t\tArgType kVar = genericType(\"K\");\n+\t\tArgType vVar = genericType(\"V\");\n+\t\tArgType mapCls = object(\"java.util.Map\");\n+\t\tArgType entryCls = object(\"Entry\");\n+\t\tArgType typedMap = generic(mapCls, kVar, vVar);\n+\t\tArgType typedEntry = generic(entryCls, kVar, vVar);\n+\n+\t\tMap<ArgType, ArgType> typeMap = new HashMap<>();\n+\t\ttypeMap.put(kVar, STRING);\n+\t\ttypeMap.put(vVar, EXCEPTION);\n+\n+\t\tArgType replacedMap = typeUtils.replaceTypeVariablesUsingMap(typedMap, typeMap);\n+\t\tArgType replacedEntry = typeUtils.replaceTypeVariablesUsingMap(typedEntry, typeMap);\n+\n+\t\treplaceTypeVar(outerGeneric(typedMap, entryCls), typeMap, outerGeneric(replacedMap, entryCls));\n+\t\treplaceTypeVar(outerGeneric(typedMap, typedEntry), typeMap, outerGeneric(replacedMap, replacedEntry));\n+\t}\n+\n \tprivate void replaceTypeVar(ArgType typeVar, Map<ArgType, ArgType> typeMap, ArgType expected) {\n \t\tArgType resultType = typeUtils.replaceTypeVariablesUsingMap(typeVar, typeMap);\n \t\tassertThat(resultType)\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/generics/TestTypeVarsFromOuterClass.java b/jadx-core/src/test/java/jadx/tests/integration/generics/TestTypeVarsFromOuterClass.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/generics/TestTypeVarsFromOuterClass.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/generics/TestTypeVarsFromOuterClass.java\n@@ -0,0 +1,62 @@\n+package jadx.tests.integration.generics;\n+\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestTypeVarsFromOuterClass extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic interface I<X> {\n+\t\t\tMap.Entry<X, X> entry();\n+\t\t}\n+\n+\t\tpublic static class Outer<Y> {\n+\t\t\tpublic class Inner implements I<Y> {\n+\t\t\t\t@Override\n+\t\t\t\tpublic Map.Entry<Y, Y> entry() {\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tpublic Inner getInner() {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate Outer<String> outer;\n+\n+\t\tpublic void test() {\n+\t\t\tOuter<String>.Inner inner = this.outer.getInner();\n+\t\t\tuse(inner, inner);\n+\t\t\tMap.Entry<String, String> entry = inner.entry();\n+\t\t\tuse(entry.getKey(), entry.getValue());\n+\t\t}\n+\n+\t\tpublic void test2() {\n+\t\t\t// force interface virtual call\n+\t\t\tI<String> base = this.outer.getInner();\n+\t\t\tuse(base, base);\n+\t\t\tMap.Entry<String, String> entry = base.entry();\n+\t\t\tuse(entry.getKey(), entry.getValue());\n+\t\t}\n+\n+\t\tpublic void use(Object a, Object b) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"Outer<Y>.Inner inner\")\n+\t\t\t\t.doesNotContain(\"Object entry = \")\n+\t\t\t\t.countString(2, \"Outer<String>.Inner inner = this.outer.getInner();\")\n+\t\t\t\t.countString(2, \"Map.Entry<String, String> entry = \");\n+\t}\n+}",
    "output": "Fix resolve type vars from outer class"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java\n@@ -398,8 +398,8 @@ private static boolean checkBlocksTree(BlockNode dupBlock, BlockNode finallyBloc\n \t\t\tInsnsSlice dupSlice, FinallyExtractInfo extractInfo) {\n \t\tInsnsSlice finallySlice = extractInfo.getFinallyInsnsSlice();\n \n-\t\tList<BlockNode> finallyCS = finallyBlock.getSuccessors();\n-\t\tList<BlockNode> dupCS = dupBlock.getSuccessors();\n+\t\tList<BlockNode> finallyCS = finallyBlock.getCleanSuccessors();\n+\t\tList<BlockNode> dupCS = dupBlock.getCleanSuccessors();\n \t\tif (finallyCS.size() == dupCS.size()) {\n \t\t\tfor (int i = 0; i < finallyCS.size(); i++) {\n \t\t\t\tBlockNode finSBlock = finallyCS.get(i);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally11.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally11.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally11.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally11.java\n@@ -0,0 +1,48 @@\n+package jadx.tests.integration.trycatch;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestTryCatchFinally11 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tprivate int count = 0;\n+\n+\t\tpublic void test(List<Object> list) {\n+\t\t\ttry {\n+\t\t\t\tcall1();\n+\t\t\t} finally {\n+\t\t\t\tfor (Object item : list) {\n+\t\t\t\t\tcall2(item);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void call1() {\n+\t\t\tcount += 100;\n+\t\t}\n+\n+\t\tprivate void call2(Object item) {\n+\t\t\tcount++;\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tTestCls t = new TestCls();\n+\t\t\tt.test(Arrays.asList(\"1\", \"2\"));\n+\t\t\tassertThat(t.count).isEqualTo(102);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"} finally {\");\n+\t}\n+}",
    "output": "Fix prevent StackOverflowError in MarkFinallyVisitor"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Consts.java b/jadx-core/src/main/java/jadx/core/Consts.java\n--- a/jadx-core/src/main/java/jadx/core/Consts.java\n+++ b/jadx-core/src/main/java/jadx/core/Consts.java\n@@ -22,6 +22,8 @@ public class Consts {\n \tpublic static final String DALVIK_THROWS = \"Ldalvik/annotation/Throws;\";\n \tpublic static final String DALVIK_ANNOTATION_DEFAULT = \"Ldalvik/annotation/AnnotationDefault;\";\n \n+\tpublic static final String OVERRIDE_ANNOTATION = \"Ljava/lang/Override;\";\n+\n \tpublic static final String DEFAULT_PACKAGE_NAME = \"defpackage\";\n \tpublic static final String ANONYMOUS_CLASS_PREFIX = \"AnonymousClass\";\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java\n@@ -69,7 +69,7 @@ private void add(IAttributeNode node, ICodeWriter code) {\n \t\t}\n \t\tfor (IAnnotation a : aList.getAll()) {\n \t\t\tString aCls = a.getAnnotationClass();\n-\t\t\tif (!aCls.startsWith(Consts.DALVIK_ANNOTATION_PKG)) {\n+\t\t\tif (!aCls.startsWith(Consts.DALVIK_ANNOTATION_PKG) && !aCls.equals(Consts.OVERRIDE_ANNOTATION)) {\n \t\t\t\tcode.startLine();\n \t\t\t\tformatAnnotation(code, a);\n \t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n@@ -56,7 +56,7 @@ private void processCls(ClassNode cls) {\n \t}\n \n \tprivate void processMth(ClassNode cls, List<ArgType> superTypes, MethodNode mth) {\n-\t\tif (mth.isConstructor() || mth.getAccessFlags().isStatic()) {\n+\t\tif (mth.isConstructor() || mth.getAccessFlags().isStatic() || mth.getAccessFlags().isPrivate()) {\n \t\t\treturn;\n \t\t}\n \t\tMethodOverrideAttr attr = processOverrideMethods(cls, mth, superTypes);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestExplicitOverride.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestExplicitOverride.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestExplicitOverride.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestExplicitOverride.java\n@@ -0,0 +1,16 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.countString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestExplicitOverride extends SmaliTest {\n+\t@Test\n+\tpublic void test() {\n+\t\tString code = getClassNodeFromSmali().getCode().getCodeStr();\n+\t\tassertThat(code, countString(1, \"@Override\"));\n+\t}\n+}",
    "output": "Fix prevent duplicated override annotations and minor optimization"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -192,12 +192,13 @@ private void processConstructorInsn(ClassNode cls, EnumField enumField, MethodNo\n \t\tif (ctrMth != null) {\n \t\t\tmarkArgsForSkip(ctrMth);\n \t\t}\n-\t\tif (co.getResult().getSVar().getUseList().size() <= 2) {\n+\t\tRegisterArg coResArg = co.getResult();\n+\t\tif (coResArg == null || coResArg.getSVar().getUseList().size() <= 2) {\n \t\t\tInsnRemover.removeWithoutUnbind(classInitMth, staticBlock, co);\n \t\t} else {\n \t\t\t// constructor result used in other places -> replace constructor with enum field get (SGET)\n \t\t\tIndexInsnNode enumGet = new IndexInsnNode(InsnType.SGET, enumField.getField().getFieldInfo(), 0);\n-\t\t\tenumGet.setResult(co.getResult().duplicate());\n+\t\t\tenumGet.setResult(coResArg.duplicate());\n \t\t\tBlockUtils.replaceInsn(classInitMth, staticBlock, co, enumGet);\n \t\t}\n \t}",
    "output": "Fix resolve NPE in enum processing"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -192,7 +192,14 @@ private void processConstructorInsn(ClassNode cls, EnumField enumField, MethodNo\n \t\tif (ctrMth != null) {\n \t\t\tmarkArgsForSkip(ctrMth);\n \t\t}\n-\t\tInsnRemover.removeWithoutUnbind(classInitMth, staticBlock, co);\n+\t\tif (co.getResult().getSVar().getUseList().size() <= 2) {\n+\t\t\tInsnRemover.removeWithoutUnbind(classInitMth, staticBlock, co);\n+\t\t} else {\n+\t\t\t// constructor result used in other places -> replace constructor with enum field get (SGET)\n+\t\t\tIndexInsnNode enumGet = new IndexInsnNode(InsnType.SGET, enumField.getField().getFieldInfo(), 0);\n+\t\t\tenumGet.setResult(co.getResult().duplicate());\n+\t\t\tBlockUtils.replaceInsn(classInitMth, staticBlock, co, enumGet);\n+\t\t}\n \t}\n \n \t@Nullable\n@@ -335,7 +342,6 @@ private EnumField processEnumFieldByRegister(ClassNode cls, RegisterArg arg, Blo\n \t\t\tenumFieldNode = createFakeField(cls, \"EF\" + arg.getRegNum());\n \t\t\tcls.addField(enumFieldNode);\n \t\t}\n-\t\ttoRemove.add(constrInsn);\n \t\treturn createEnumFieldByConstructor(cls, enumFieldNode, (ConstructorInsn) constrInsn);\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n@@ -21,6 +21,7 @@\n import jadx.core.dex.nodes.FieldNode;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n import jadx.core.utils.BlockUtils;\n import jadx.core.utils.InsnRemover;\n import jadx.core.utils.exceptions.JadxException;\n@@ -80,8 +81,16 @@ private static void moveStaticFieldsInit(ClassNode cls) {\n \t\tif (classInitMth == null) {\n \t\t\treturn;\n \t\t}\n+\t\twhile (processFields(cls, classInitMth)) {\n+\t\t\t// sometimes instructions moved to field init prevent from vars inline -> inline and try again\n+\t\t\tCodeShrinkVisitor.shrinkMethod(classInitMth);\n+\t\t}\n+\t}\n+\n+\tprivate static boolean processFields(ClassNode cls, MethodNode classInitMth) {\n+\t\tboolean changed = false;\n \t\tfor (FieldNode field : cls.getFields()) {\n-\t\t\tif (field.contains(AFlag.DONT_GENERATE)) {\n+\t\t\tif (field.contains(AFlag.DONT_GENERATE) || field.contains(AType.FIELD_INIT)) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (field.getAccessFlags().isStatic()) {\n@@ -95,10 +104,12 @@ private static void moveStaticFieldsInit(ClassNode cls) {\n \t\t\t\t\t\t}\n \t\t\t\t\t\tInsnRemover.remove(classInitMth, insn);\n \t\t\t\t\t\taddFieldInitAttr(classInitMth, field, insn);\n+\t\t\t\t\t\tchanged = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\treturn changed;\n \t}\n \n \tprivate static class InitInfo {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumWithFields.java b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumWithFields.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumWithFields.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumWithFields.java\n@@ -0,0 +1,47 @@\n+package jadx.tests.integration.enums;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class TestEnumWithFields extends SmaliTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic enum SearchTimeout {\n+\t\t\tDISABLED(0), TWO_SECONDS(2), FIVE_SECONDS(5);\n+\n+\t\t\tpublic static final SearchTimeout DEFAULT = DISABLED;\n+\t\t\tpublic static final SearchTimeout MAX = FIVE_SECONDS;\n+\n+\t\t\tpublic final int sec;\n+\n+\t\t\tSearchTimeout(int val) {\n+\t\t\t\tthis.sec = val;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertEquals(0, SearchTimeout.DISABLED.sec);\n+\t\t\tassertEquals(0, SearchTimeout.DEFAULT.sec);\n+\t\t\tassertEquals(2, SearchTimeout.TWO_SECONDS.sec);\n+\t\t\tassertEquals(5, SearchTimeout.MAX.sec);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code();\n+\t}\n+\n+\t@Test\n+\tpublic void test2() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code();\n+\t}\n+}",
    "output": "Fix allow to reuse enum fields in static fields"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n@@ -72,6 +72,7 @@ public enum AFlag {\n \tINCONSISTENT_CODE, // warning about incorrect decompilation\n \n \tREQUEST_IF_REGION_OPTIMIZE, // run if region visitor again\n+\tRERUN_SSA_TRANSFORM,\n \n \t// Class processing flags\n \tRESTART_CODEGEN, // codegen must be executed again\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n@@ -83,6 +83,10 @@ void setSVar(@NotNull SSAVar sVar) {\n \t\tthis.sVar = sVar;\n \t}\n \n+\tpublic void resetSSAVar() {\n+\t\tthis.sVar = null;\n+\t}\n+\n \t@Override\n \tpublic String getName() {\n \t\tif (isSuper()) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n@@ -35,17 +35,17 @@ public ConstructorInsn(MethodNode mth, InvokeNode invoke) {\n \t}\n \n \tprivate CallType getCallType(MethodNode mth, ClassInfo classType, InsnArg instanceArg) {\n-\t\tif (instanceArg.isThis()) {\n-\t\t\tif (classType.equals(mth.getParentClass().getClassInfo())) {\n-\t\t\t\tif (callMth.getShortId().equals(mth.getMethodInfo().getShortId())) {\n-\t\t\t\t\t// self constructor\n-\t\t\t\t\treturn CallType.SELF;\n-\t\t\t\t}\n-\t\t\t\treturn CallType.THIS;\n-\t\t\t}\n+\t\tif (!instanceArg.isThis()) {\n+\t\t\treturn CallType.CONSTRUCTOR;\n+\t\t}\n+\t\tif (!classType.equals(mth.getParentClass().getClassInfo())) {\n \t\t\treturn CallType.SUPER;\n \t\t}\n-\t\treturn CallType.CONSTRUCTOR;\n+\t\tif (callMth.getShortId().equals(mth.getMethodInfo().getShortId())) {\n+\t\t\t// self constructor\n+\t\t\treturn CallType.SELF;\n+\t\t}\n+\t\treturn CallType.THIS;\n \t}\n \n \tpublic ConstructorInsn(MethodInfo callMth, CallType callType) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n@@ -5,7 +5,7 @@\n import org.jetbrains.annotations.Nullable;\n \n import jadx.core.codegen.TypeGen;\n-import jadx.core.dex.info.MethodInfo;\n+import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.InvokeNode;\n import jadx.core.dex.instructions.args.InsnArg;\n@@ -33,8 +33,10 @@ public void visit(MethodNode mth) {\n \t\tif (mth.isNoCode()) {\n \t\t\treturn;\n \t\t}\n-\n \t\treplaceInvoke(mth);\n+\t\tif (mth.contains(AFlag.RERUN_SSA_TRANSFORM)) {\n+\t\t\tSSATransform.rerun(mth);\n+\t\t}\n \t}\n \n \tprivate static void replaceInvoke(MethodNode mth) {\n@@ -53,65 +55,73 @@ private static void replaceInvoke(MethodNode mth) {\n \t}\n \n \tprivate static void processInvoke(MethodNode mth, BlockNode block, int indexInBlock, InsnRemover remover) {\n-\t\tClassNode parentClass = mth.getParentClass();\n-\t\tInsnNode insn = block.getInstructions().get(indexInBlock);\n-\t\tInvokeNode inv = (InvokeNode) insn;\n-\t\tMethodInfo callMth = inv.getCallMth();\n-\t\tif (!callMth.isConstructor()) {\n+\t\tInvokeNode inv = (InvokeNode) block.getInstructions().get(indexInBlock);\n+\t\tif (!inv.getCallMth().isConstructor()) {\n \t\t\treturn;\n \t\t}\n-\t\tRegisterArg instanceArg = ((RegisterArg) inv.getArg(0));\n-\t\tInsnNode instArgAssignInsn = instanceArg.getAssignInsn();\n \t\tConstructorInsn co = new ConstructorInsn(mth, inv);\n+\t\tif (canRemoveConstructor(mth, co)) {\n+\t\t\tremover.addAndUnbind(inv);\n+\t\t\treturn;\n+\t\t}\n+\t\tRegisterArg instanceArg = ((RegisterArg) inv.getArg(0));\n+\t\tInsnNode newInstInsn = null;\n \t\tif (co.isNewInstance()) {\n-\t\t\tco.setResult(instanceArg);\n-\t\t\t// convert from 'use' to 'assign'\n-\t\t\tinstanceArg.getSVar().setAssign(instanceArg);\n+\t\t\tInsnNode assignInsn = instanceArg.getAssignInsn();\n+\t\t\tif (assignInsn != null) {\n+\t\t\t\tif (assignInsn.getType() == InsnType.CONSTRUCTOR) {\n+\t\t\t\t\t// arg already used in another constructor instruction\n+\t\t\t\t\tmth.add(AFlag.RERUN_SSA_TRANSFORM);\n+\t\t\t\t} else {\n+\t\t\t\t\tnewInstInsn = removeAssignChain(mth, assignInsn, remover, InsnType.NEW_INSTANCE);\n+\t\t\t\t\tif (newInstInsn != null) {\n+\t\t\t\t\t\tnewInstInsn.add(AFlag.REMOVE);\n+\t\t\t\t\t\tremover.addWithoutUnbind(newInstInsn);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// convert instance arg from 'use' to 'assign'\n+\t\t\tco.setResult(instanceArg.duplicate());\n \t\t}\n \t\tinstanceArg.getSVar().removeUse(instanceArg);\n \n \t\tco.rebindArgs();\n-\t\tboolean remove = false;\n-\t\tif (co.isSuper() && (co.getArgsCount() == 0 || parentClass.isEnum())) {\n-\t\t\tremove = true;\n-\t\t} else if (co.isThis() && co.getArgsCount() == 0) {\n-\t\t\tMethodNode defCo = parentClass.searchMethodByShortId(callMth.getShortId());\n-\t\t\tif (defCo == null || defCo.isNoCode()) {\n-\t\t\t\t// default constructor not implemented\n-\t\t\t\tremove = true;\n-\t\t\t}\n-\t\t}\n-\t\t// remove super() call in instance initializer\n-\t\tif (parentClass.isAnonymous() && mth.isDefaultConstructor() && co.isSuper()) {\n-\t\t\tremove = true;\n-\t\t}\n-\t\tif (remove) {\n-\t\t\tremover.addAndUnbind(insn);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (co.isNewInstance()) {\n-\t\t\tInsnNode newInstInsn = removeAssignChain(mth, instArgAssignInsn, remover, InsnType.NEW_INSTANCE);\n-\t\t\tif (newInstInsn != null) {\n-\t\t\t\tremover.addWithoutUnbind(newInstInsn);\n-\t\t\t\tRegisterArg instArg = newInstInsn.getResult();\n-\t\t\t\tRegisterArg resultArg = co.getResult();\n-\t\t\t\tif (!resultArg.equals(instArg)) {\n-\t\t\t\t\t// replace all usages of 'instArg' with result of this constructor instruction\n-\t\t\t\t\tfor (RegisterArg useArg : new ArrayList<>(instArg.getSVar().getUseList())) {\n-\t\t\t\t\t\tInsnNode parentInsn = useArg.getParentInsn();\n-\t\t\t\t\t\tif (parentInsn != null) {\n-\t\t\t\t\t\t\tparentInsn.replaceArg(useArg, resultArg.duplicate());\n-\t\t\t\t\t\t}\n+\t\tif (co.isNewInstance() && newInstInsn != null) {\n+\t\t\tRegisterArg instArg = newInstInsn.getResult();\n+\t\t\tRegisterArg resultArg = co.getResult();\n+\t\t\tif (!resultArg.equals(instArg)) {\n+\t\t\t\t// replace all usages of 'instArg' with result of this constructor instruction\n+\t\t\t\tfor (RegisterArg useArg : new ArrayList<>(instArg.getSVar().getUseList())) {\n+\t\t\t\t\tInsnNode parentInsn = useArg.getParentInsn();\n+\t\t\t\t\tif (parentInsn != null) {\n+\t\t\t\t\t\tparentInsn.replaceArg(useArg, resultArg.duplicate());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tConstructorInsn replace = processConstructor(mth, co);\n \t\tif (replace != null) {\n \t\t\tremover.addAndUnbind(co);\n-\t\t\tco = replace;\n+\t\t\tBlockUtils.replaceInsn(mth, block, indexInBlock, replace);\n+\t\t} else {\n+\t\t\tBlockUtils.replaceInsn(mth, block, indexInBlock, co);\n \t\t}\n-\t\tBlockUtils.replaceInsn(mth, block, indexInBlock, co);\n+\t}\n+\n+\tprivate static boolean canRemoveConstructor(MethodNode mth, ConstructorInsn co) {\n+\t\tClassNode parentClass = mth.getParentClass();\n+\t\tif (co.isSuper() && (co.getArgsCount() == 0 || parentClass.isEnum())) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (co.isThis() && co.getArgsCount() == 0) {\n+\t\t\tMethodNode defCo = parentClass.searchMethodByShortId(co.getCallMth().getShortId());\n+\t\t\tif (defCo == null || defCo.isNoCode()) {\n+\t\t\t\t// default constructor not implemented\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\t// remove super() call in instance initializer\n+\t\treturn parentClass.isAnonymous() && mth.isDefaultConstructor() && co.isSuper();\n \t}\n \n \t/**\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n@@ -41,11 +41,16 @@ public void visit(MethodNode mth) throws JadxException {\n \t\tprocess(mth);\n \t}\n \n+\tpublic static void rerun(MethodNode mth) {\n+\t\tmth.remove(AFlag.RERUN_SSA_TRANSFORM);\n+\t\tresetSSAVars(mth);\n+\t\tprocess(mth);\n+\t}\n+\n \tprivate static void process(MethodNode mth) {\n \t\tif (!mth.getSVars().isEmpty()) {\n \t\t\treturn;\n \t\t}\n-\n \t\tLiveVarAnalysis la = new LiveVarAnalysis(mth);\n \t\tla.runAnalysis();\n \t\tint regsCount = mth.getRegsCount();\n@@ -433,4 +438,15 @@ private static void hidePhiInsns(MethodNode mth) {\n \t\t\tblock.getInstructions().removeIf(insn -> insn.getType() == InsnType.PHI);\n \t\t}\n \t}\n+\n+\tprivate static void resetSSAVars(MethodNode mth) {\n+\t\tfor (SSAVar ssaVar : mth.getSVars()) {\n+\t\t\tssaVar.getAssign().resetSSAVar();\n+\t\t\tssaVar.getUseList().forEach(RegisterArg::resetSSAVar);\n+\t\t}\n+\t\tfor (BlockNode block : mth.getBasicBlocks()) {\n+\t\t\tblock.remove(AType.PHI_LIST);\n+\t\t}\n+\t\tmth.getSVars().clear();\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestConstructorBranched.java\n@@ -0,0 +1,33 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+@SuppressWarnings(\"CommentedOutCode\")\n+public class TestConstructorBranched extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tpublic Set<String> test(Collection<String> collection) {\n+\t\t\tSet<String> set;\n+\t\t\tif (collection == null) {\n+\t\t\t\tset = new HashSet<>();\n+\t\t\t} else {\n+\t\t\t\tset = new HashSet<>(collection);\n+\t\t\t}\n+\t\t\tset.add(\"end\");\n+\t\t\treturn set;\n+\t\t}\n+\t */\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"new HashSet()\")\n+\t\t\t\t.containsOne(\"new HashSet(collection)\");\n+\t}\n+}",
    "output": "Fix support branched object construction"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n@@ -61,6 +61,9 @@ public ArgType expandTypeVariables(MethodNode mth, ArgType type) {\n \t}\n \n \tprivate void expandTypeVar(NotificationAttrNode node, ArgType type, Collection<ArgType> typeVars) {\n+\t\tif (typeVars.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n \t\tboolean allExtendsEmpty = true;\n \t\tfor (ArgType argType : typeVars) {\n \t\t\tif (notEmpty(argType.getExtendTypes())) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundFieldGetAssign.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundFieldGetAssign.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundFieldGetAssign.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundFieldGetAssign.java\n@@ -0,0 +1,83 @@\n+package jadx.core.dex.visitors.typeinference;\n+\n+import jadx.core.dex.info.FieldInfo;\n+import jadx.core.dex.instructions.IndexInsnNode;\n+import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.instructions.args.InsnArg;\n+import jadx.core.dex.instructions.args.RegisterArg;\n+import jadx.core.dex.nodes.RootNode;\n+\n+/**\n+ * Dynamic bound for instance field get of generic type.\n+ * Bound type calculated using instance generic type.\n+ */\n+public final class TypeBoundFieldGetAssign implements ITypeBoundDynamic {\n+\tprivate final RootNode root;\n+\tprivate final IndexInsnNode getNode;\n+\tprivate final FieldInfo fieldInfo;\n+\tprivate final ArgType initType;\n+\n+\tpublic TypeBoundFieldGetAssign(RootNode root, IndexInsnNode getNode, ArgType initType) {\n+\t\tthis.root = root;\n+\t\tthis.getNode = getNode;\n+\t\tthis.fieldInfo = ((FieldInfo) getNode.getIndex());\n+\t\tthis.initType = initType;\n+\t}\n+\n+\t@Override\n+\tpublic BoundEnum getBound() {\n+\t\treturn BoundEnum.ASSIGN;\n+\t}\n+\n+\t@Override\n+\tpublic ArgType getType(TypeUpdateInfo updateInfo) {\n+\t\treturn getResultType(updateInfo.getType(getInstanceArg()));\n+\t}\n+\n+\t@Override\n+\tpublic ArgType getType() {\n+\t\treturn getResultType(getInstanceArg().getType());\n+\t}\n+\n+\tprivate ArgType getResultType(ArgType instanceType) {\n+\t\tArgType resultGeneric = root.getTypeUtils().replaceClassGenerics(instanceType, initType);\n+\t\tif (resultGeneric != null && !resultGeneric.isWildcard()) {\n+\t\t\treturn resultGeneric;\n+\t\t}\n+\t\treturn initType; // TODO: check if this type is allowed in current scope\n+\t}\n+\n+\tprivate InsnArg getInstanceArg() {\n+\t\treturn getNode.getArg(0);\n+\t}\n+\n+\t@Override\n+\tpublic RegisterArg getArg() {\n+\t\treturn getNode.getResult();\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTypeBoundFieldGetAssign that = (TypeBoundFieldGetAssign) o;\n+\t\treturn getNode.equals(that.getNode);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn getNode.hashCode();\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"FieldGetAssign{\" + fieldInfo\n+\t\t\t\t+ \", type=\" + getType()\n+\t\t\t\t+ \", instanceArg=\" + getInstanceArg()\n+\t\t\t\t+ '}';\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -293,6 +293,10 @@ private void addAssignBound(TypeInfo typeInfo, RegisterArg assign) {\n \t\t\t\taddBound(typeInfo, makeAssignInvokeBound((InvokeNode) insn));\n \t\t\t\tbreak;\n \n+\t\t\tcase IGET:\n+\t\t\t\taddBound(typeInfo, makeAssignFieldGetBound((IndexInsnNode) insn));\n+\t\t\t\tbreak;\n+\n \t\t\tcase CHECK_CAST:\n \t\t\t\taddBound(typeInfo, new TypeBoundCheckCastAssign(root, (IndexInsnNode) insn));\n \t\t\t\tbreak;\n@@ -304,6 +308,14 @@ private void addAssignBound(TypeInfo typeInfo, RegisterArg assign) {\n \t\t}\n \t}\n \n+\tprivate ITypeBound makeAssignFieldGetBound(IndexInsnNode insn) {\n+\t\tArgType initType = insn.getResult().getInitType();\n+\t\tif (initType.containsTypeVariable()) {\n+\t\t\treturn new TypeBoundFieldGetAssign(root, insn, initType);\n+\t\t}\n+\t\treturn new TypeBoundConst(BoundEnum.ASSIGN, initType);\n+\t}\n+\n \tprivate ITypeBound makeAssignInvokeBound(InvokeNode invokeNode) {\n \t\tArgType boundType = invokeNode.getCallMth().getReturnType();\n \t\tArgType genericReturnType = root.getMethodUtils().getMethodGenericReturnType(invokeNode);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenericFields.java b/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenericFields.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenericFields.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenericFields.java\n@@ -0,0 +1,40 @@\n+package jadx.tests.integration.generics;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestGenericFields extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic static class Summary {\n+\t\t\tValue<Amount> price;\n+\t\t}\n+\n+\t\tpublic static class Value<T> {\n+\t\t\tT value;\n+\t\t}\n+\n+\t\tpublic static class Amount {\n+\t\t\tString cur;\n+\t\t\tint val;\n+\t\t}\n+\n+\t\tpublic String test(Summary summary) {\n+\t\t\tAmount amount = summary.price.value;\n+\t\t\treturn amount.val + \" \" + amount.cur;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"T t = \")\n+\t\t\t\t.containsOne(\"Amount amount =\");\n+\t}\n+}",
    "output": "Fix resolve generic type vars for instance field get instruction"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/NameGen.java b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n@@ -70,7 +70,9 @@ public void inheritUsedNames(NameGen otherNameGen) {\n \tprivate void addNamesUsedInClass() {\n \t\tClassNode parentClass = mth.getParentClass();\n \t\tfor (FieldNode field : parentClass.getFields()) {\n-\t\t\tvarNames.add(field.getAlias());\n+\t\t\tif (field.isStatic()) {\n+\t\t\t\tvarNames.add(field.getAlias());\n+\t\t\t}\n \t\t}\n \t\tfor (ClassNode innerClass : parentClass.getInnerClasses()) {\n \t\t\tvarNames.add(innerClass.getClassInfo().getAliasShortName());\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/TestConstructorArgNames.java b/jadx-core/src/test/java/jadx/tests/integration/names/TestConstructorArgNames.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/TestConstructorArgNames.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestConstructorArgNames.java\n@@ -0,0 +1,41 @@\n+package jadx.tests.integration.names;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestConstructorArgNames extends IntegrationTest {\n+\n+\t@SuppressWarnings({ \"FieldCanBeLocal\", \"FieldMayBeFinal\", \"StaticVariableName\", \"ParameterName\" })\n+\tpublic static class TestCls {\n+\t\tprivate static String STR = \"static field\";\n+\t\tprivate final String str;\n+\t\tprivate final String store;\n+\n+\t\tpublic TestCls(String str, String STR) {\n+\t\t\tthis.str = str;\n+\t\t\tthis.store = STR;\n+\t\t}\n+\n+\t\tpublic TestCls() {\n+\t\t\tthis.str = \"a\";\n+\t\t\tthis.store = STR;\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(new TestCls(\"a\", \"b\").store).isEqualTo(\"b\");\n+\t\t\tassertThat(new TestCls().store).isEqualTo(STR);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"this.str = str;\")\n+\t\t\t\t.containsOne(\"this.store = STR2;\")\n+\t\t\t\t.containsOne(\"this.store = STR;\");\n+\t}\n+}",
    "output": "Fix allow local variables have name same as instance fields"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n--- a/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n@@ -5,7 +5,6 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n@@ -80,26 +79,37 @@ public void printUsage() {\n \t\t\t}\n \t\t\tStringBuilder opt = new StringBuilder();\n \t\t\topt.append(\"  \").append(p.getNames());\n+\t\t\tString description = p.getDescription();\n \t\t\taddSpaces(opt, maxNamesLen - opt.length() + 3);\n-\t\t\topt.append(\"- \").append(p.getDescription());\n+\t\t\tif (description.contains(\"\\n\")) {\n+\t\t\t\tString[] lines = description.split(\"\\n\");\n+\t\t\t\topt.append(\"- \").append(lines[0]);\n+\t\t\t\tfor (int i = 1; i < lines.length; i++) {\n+\t\t\t\t\topt.append('\\n');\n+\t\t\t\t\taddSpaces(opt, maxNamesLen + 5);\n+\t\t\t\t\topt.append(lines[i]);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\topt.append(\"- \").append(description);\n+\t\t\t}\n \t\t\tString defaultValue = getDefaultValue(args, f, opt);\n \t\t\tif (defaultValue != null) {\n \t\t\t\topt.append(\", default: \").append(defaultValue);\n \t\t\t}\n \t\t\tout.println(opt);\n \t\t}\n-\t\tout.println(\"Example:\");\n+\t\tout.println(\"Examples:\");\n \t\tout.println(\"  jadx -d out classes.dex\");\n+\t\tout.println(\"  jadx --rename-flags \\\"none\\\" classes.dex\");\n+\t\tout.println(\"  jadx --rename-flags \\\"valid, printable\\\" classes.dex\");\n+\t\tout.println(\"  jadx --log-level ERROR app.apk\");\n \t}\n \n \t/**\n \t * Get all declared fields of the specified class and all super classes\n-\t *\n-\t * @param clazz\n-\t * @return\n \t */\n \tprivate List<Field> getFields(Class<?> clazz) {\n-\t\tList<Field> fieldList = new LinkedList<>();\n+\t\tList<Field> fieldList = new ArrayList<>();\n \t\twhile (clazz != null) {\n \t\t\tfieldList.addAll(Arrays.asList(clazz.getDeclaredFields()));\n \t\t\tclazz = clazz.getSuperclass();\n\ndiff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n@@ -91,7 +91,7 @@ public class JadxCLIArgs {\n \t)\n \tprotected String deobfuscationMapFile;\n \n-\t@Parameter(names = { \"--deobf-rewrite-cfg\" }, description = \"force to save deobfuscation map\")\n+\t@Parameter(names = { \"--deobf-rewrite-cfg\" }, description = \"force to ignore and overwrite deobfuscation map file\")\n \tprotected boolean deobfuscationForceSave = false;\n \n \t@Parameter(names = { \"--deobf-use-sourcename\" }, description = \"use source file name as class name alias\")\n@@ -102,11 +102,12 @@ public class JadxCLIArgs {\n \n \t@Parameter(\n \t\t\tnames = { \"--rename-flags\" },\n-\t\t\tdescription = \"what to rename, comma-separated,\"\n-\t\t\t\t\t+ \" 'case' for system case sensitivity,\"\n-\t\t\t\t\t+ \" 'valid' for java identifiers,\"\n-\t\t\t\t\t+ \" 'printable' characters,\"\n-\t\t\t\t\t+ \" 'none' or 'all' (default)\",\n+\t\t\tdescription = \"fix options (comma-separated list of): \"\n+\t\t\t\t\t+ \"\\n 'case' - fix case sensitivity issues (according to --fs-case-sensitive option),\"\n+\t\t\t\t\t+ \"\\n 'valid' - rename java identifiers to make them valid,\"\n+\t\t\t\t\t+ \"\\n 'printable' - remove non-printable chars from identifiers,\"\n+\t\t\t\t\t+ \"\\nor single 'none' - to disable all renames\"\n+\t\t\t\t\t+ \"\\nor single 'all' - to enable all (default)\",\n \t\t\tconverter = RenameConverter.class\n \t)\n \tprotected Set<RenameEnum> renameFlags = EnumSet.allOf(RenameEnum.class);\n@@ -123,19 +124,19 @@ public class JadxCLIArgs {\n \t@Parameter(names = { \"-f\", \"--fallback\" }, description = \"make simple dump (using goto instead of 'if', 'for', etc)\")\n \tprotected boolean fallbackMode = false;\n \n-\t@Parameter(names = { \"-v\", \"--verbose\" }, description = \"verbose output (set --log-level to DEBUG)\")\n-\tprotected boolean verbose = false;\n-\n-\t@Parameter(names = { \"-q\", \"--quiet\" }, description = \"turn off output (set --log-level to QUIET)\")\n-\tprotected boolean quiet = false;\n-\n \t@Parameter(\n \t\t\tnames = { \"--log-level\" },\n \t\t\tdescription = \"set log level, values: QUIET, PROGRESS, ERROR, WARN, INFO, DEBUG\",\n \t\t\tconverter = LogHelper.LogLevelConverter.class\n \t)\n \tprotected LogHelper.LogLevelEnum logLevel = LogHelper.LogLevelEnum.PROGRESS;\n \n+\t@Parameter(names = { \"-v\", \"--verbose\" }, description = \"verbose output (set --log-level to DEBUG)\")\n+\tprotected boolean verbose = false;\n+\n+\t@Parameter(names = { \"-q\", \"--quiet\" }, description = \"turn off output (set --log-level to QUIET)\")\n+\tprotected boolean quiet = false;\n+\n \t@Parameter(names = { \"--version\" }, description = \"print jadx version\")\n \tprotected boolean printVersion = false;\n \n@@ -219,9 +220,7 @@ public JadxArgs toJadxArgs() {\n \t\targs.setInsertDebugLines(addDebugLines);\n \t\targs.setInlineAnonymousClasses(inlineAnonymousClasses);\n \t\targs.setInlineMethods(inlineMethods);\n-\t\targs.setRenameCaseSensitive(isRenameCaseSensitive());\n-\t\targs.setRenameValid(isRenameValid());\n-\t\targs.setRenamePrintable(isRenamePrintable());\n+\t\targs.setRenameFlags(renameFlags);\n \t\targs.setFsCaseSensitive(fsCaseSensitive);\n \t\treturn args;\n \t}\n@@ -368,7 +367,7 @@ public Set<RenameEnum> convert(String value) {\n \t\t\tSet<RenameEnum> set = EnumSet.noneOf(RenameEnum.class);\n \t\t\tfor (String s : value.split(\",\")) {\n \t\t\t\ttry {\n-\t\t\t\t\tset.add(RenameEnum.valueOf(s.toUpperCase(Locale.ROOT)));\n+\t\t\t\t\tset.add(RenameEnum.valueOf(s.trim().toUpperCase(Locale.ROOT)));\n \t\t\t\t} catch (IllegalArgumentException e) {\n \t\t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\t\t\t'\\'' + s + \"' is unknown for parameter \" + paramName\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -535,13 +535,15 @@ private void upgradeSettings(int fromVersion) {\n \t\tLOG.debug(\"upgrade settings from version: {} to {}\", fromVersion, CURRENT_SETTINGS_VERSION);\n \t\tif (fromVersion == 0) {\n \t\t\tsetDeobfuscationMinLength(3);\n+\t\t\tsetDeobfuscationMaxLength(64);\n \t\t\tsetDeobfuscationUseSourceNameAsAlias(true);\n \t\t\tsetDeobfuscationParseKotlinMetadata(true);\n-\t\t\tsetDeobfuscationForceSave(true);\n-\t\t\tsetThreadsCount(1);\n+\t\t\tsetDeobfuscationForceSave(false);\n+\t\t\tsetThreadsCount(JadxArgs.DEFAULT_THREADS_COUNT);\n \t\t\tsetReplaceConsts(true);\n \t\t\tsetSkipResources(false);\n \t\t\tsetAutoStartJobs(false);\n+\t\t\tsetAutoSaveProject(true);\n \t\t\tfromVersion++;\n \t\t}\n \t\tif (fromVersion == 1) {",
    "output": "Fix reword rename flags in cli and gui"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -43,6 +43,7 @@\n import jadx.core.utils.CodeGenUtils;\n import jadx.core.utils.ErrorsCounter;\n import jadx.core.utils.Utils;\n+import jadx.core.utils.android.AndroidResourcesUtils;\n import jadx.core.utils.exceptions.CodegenException;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n@@ -402,7 +403,9 @@ public void addField(ICodeWriter code, FieldNode f) {\n \t\t\t\tif (encodedValue.getType() == EncodedType.ENCODED_NULL) {\n \t\t\t\t\tcode.add(TypeGen.literalToString(0, f.getType(), cls, fallback));\n \t\t\t\t} else {\n-\t\t\t\t\tannotationGen.encodeValue(cls.root(), code, encodedValue);\n+\t\t\t\t\tif (!AndroidResourcesUtils.handleResourceFieldValue(cls, code, encodedValue)) {\n+\t\t\t\t\t\tannotationGen.encodeValue(cls.root(), code, encodedValue);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else if (fv.isInsn()) {\n \t\t\t\tInsnGen insnGen = makeInsnGen(fv.getInsnMth());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n@@ -74,6 +74,23 @@ public static boolean handleAppResField(ICodeWriter code, ClassGen clsGen, Class\n \t\treturn false;\n \t}\n \n+\t/**\n+\t * Force hex format for Android resources ids\n+\t */\n+\t@SuppressWarnings(\"RedundantCast\")\n+\tpublic static boolean handleResourceFieldValue(ClassNode cls, ICodeWriter code, EncodedValue encodedValue) {\n+\t\tif (encodedValue.getType() == EncodedType.ENCODED_INT && isResourceClass(cls)) {\n+\t\t\tcode.add(String.format(\"0x%X\", ((Integer) encodedValue.getValue())));\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic static boolean isResourceClass(ClassNode cls) {\n+\t\tClassNode parentClass = cls.getParentClass();\n+\t\treturn parentClass != null && parentClass.getShortName().equals(\"R\");\n+\t}\n+\n \tprivate static ClassNode makeClass(RootNode root, String clsName, ResourceStorage resStorage) {\n \t\tClassNode rCls = ClassNode.addSyntheticClass(root, clsName, AccessFlags.PUBLIC | AccessFlags.FINAL);\n \t\trCls.addAttr(AType.COMMENTS, \"This class is generated by JADX\");\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/XmlGenUtils.java b/jadx-core/src/main/java/jadx/core/xmlgen/XmlGenUtils.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/XmlGenUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/XmlGenUtils.java\n@@ -35,7 +35,7 @@ public static ICodeInfo makeXmlDump(ICodeWriter writer, ResourceStorage resStora\n \t\tSet<String> addedValues = new HashSet<>();\n \t\tfor (ResourceEntry ri : resStorage.getResources()) {\n \t\t\tif (addedValues.add(ri.getTypeName() + '.' + ri.getKeyName())) {\n-\t\t\t\tString format = String.format(\"<public type=\\\"%s\\\" name=\\\"%s\\\" id=\\\"%s\\\" />\",\n+\t\t\t\tString format = String.format(\"<public type=\\\"%s\\\" name=\\\"%s\\\" id=\\\"0x%X\\\" />\",\n \t\t\t\t\t\tri.getTypeName(), ri.getKeyName(), ri.getId());\n \t\t\t\twriter.startLine(format);\n \t\t\t}",
    "output": "Fix format Android resources ids as hex"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Jadx.java b/jadx-core/src/main/java/jadx/core/Jadx.java\n--- a/jadx-core/src/main/java/jadx/core/Jadx.java\n+++ b/jadx-core/src/main/java/jadx/core/Jadx.java\n@@ -85,9 +85,9 @@ public static List<IDexTreeVisitor> getPreDecompilePassesList() {\n \t\tList<IDexTreeVisitor> passes = new ArrayList<>();\n \t\tpasses.add(new SignatureProcessor());\n \t\tpasses.add(new OverrideMethodVisitor());\n-\t\tpasses.add(new ProcessAnonymous());\n \t\tpasses.add(new RenameVisitor());\n \t\tpasses.add(new UsageInfoVisitor());\n+\t\tpasses.add(new ProcessAnonymous());\n \t\treturn passes;\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n@@ -5,11 +5,15 @@\n import jadx.core.dex.nodes.FieldNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.RootNode;\n+import jadx.core.dex.visitors.usage.UsageInfoVisitor;\n import jadx.core.utils.exceptions.JadxException;\n \n @JadxVisitor(\n \t\tname = \"ProcessAnonymous\",\n-\t\tdesc = \"Mark anonymous and lambda classes (for future inline)\"\n+\t\tdesc = \"Mark anonymous and lambda classes (for future inline)\",\n+\t\trunAfter = {\n+\t\t\t\tUsageInfoVisitor.class\n+\t\t}\n )\n public class ProcessAnonymous extends AbstractVisitor {\n \n@@ -30,7 +34,7 @@ public boolean visit(ClassNode cls) throws JadxException {\n \t}\n \n \tprivate static void markAnonymousClass(ClassNode cls) {\n-\t\tif (isAnonymous(cls) || isLambdaCls(cls)) {\n+\t\tif (usedOnlyOnce(cls) || isAnonymous(cls) || isLambdaCls(cls)) {\n \t\t\tcls.add(AFlag.ANONYMOUS_CLASS);\n \t\t\tcls.add(AFlag.DONT_GENERATE);\n \n@@ -42,6 +46,28 @@ private static void markAnonymousClass(ClassNode cls) {\n \t\t}\n \t}\n \n+\tprivate static boolean usedOnlyOnce(ClassNode cls) {\n+\t\tif (cls.getUseIn().size() == 1 && cls.getUseInMth().size() == 1) {\n+\t\t\t// used only once\n+\t\t\tboolean synthetic = cls.getAccessFlags().isSynthetic() || cls.getClassInfo().getShortName().contains(\"$\");\n+\t\t\tif (synthetic) {\n+\t\t\t\t// must have only one constructor which used only once\n+\t\t\t\tMethodNode ctr = null;\n+\t\t\t\tfor (MethodNode mth : cls.getMethods()) {\n+\t\t\t\t\tif (mth.isConstructor()) {\n+\t\t\t\t\t\tif (ctr != null) {\n+\t\t\t\t\t\t\tctr = null;\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tctr = mth;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn ctr != null && ctr.getUseIn().size() == 1;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tprivate static boolean isAnonymous(ClassNode cls) {\n \t\treturn cls.getClassInfo().isInner()\n \t\t\t\t&& Character.isDigit(cls.getClassInfo().getShortName().charAt(0))",
    "output": "Fix inline class as anonymous if it used only once"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JavaClass.java b/jadx-core/src/main/java/jadx/api/JavaClass.java\n--- a/jadx-core/src/main/java/jadx/api/JavaClass.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java\n@@ -66,11 +66,6 @@ public synchronized String getSmali() {\n \t\treturn cls.getSmali();\n \t}\n \n-\tpublic synchronized void unload() {\n-\t\tcls.unload();\n-\t\tlistsLoaded = false;\n-\t}\n-\n \t/**\n \t * Internal API. Not Stable!\n \t */\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n@@ -68,8 +68,6 @@ public void saveAll(File dir, ProgressMonitor progressMonitor) {\n \t\t\tdecompiler.getArgs().setRootDir(dir);\n \t\t\tdecompiler.save(500, (done, total) -> progressMonitor.setProgress((int) (done * 100.0 / total)));\n \t\t\tprogressMonitor.close();\n-\t\t\tLOG.info(\"decompilation complete, freeing memory ...\");\n-\t\t\tdecompiler.getClasses().forEach(JavaClass::unload);\n \t\t\tLOG.info(\"done\");\n \t\t};\n \t\tnew Thread(save).start();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n@@ -57,19 +57,18 @@ public boolean canRename() {\n \t}\n \n \tpublic synchronized void load() {\n-\t\tif (!loaded) {\n-\t\t\tcls.decompile();\n-\t\t\tcls.unload();\n-\t\t\tloaded = true;\n+\t\tif (loaded) {\n+\t\t\treturn;\n \t\t}\n+\t\tcls.decompile();\n+\t\tloaded = true;\n \t\tupdate();\n \t}\n \n \tpublic synchronized void reload() {\n \t\tcls.reload();\n \t\tloaded = true;\n \t\tupdate();\n-\t\tcls.unload();\n \t}\n \n \tpublic synchronized void update() {\n@@ -93,8 +92,7 @@ public synchronized void update() {\n \n \t@Override\n \tpublic @Nullable ICodeInfo getCodeInfo() {\n-\t\tload();\n-\t\treturn cls.getClassNode().getCode();\n+\t\treturn cls.getCodeInfo();\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java\n@@ -120,9 +120,6 @@ private void initLineNumbers() {\n \t\tif (codeArea instanceof SmaliArea) {\n \t\t\treturn;\n \t\t}\n-\t\tLineNumbers numbers = new LineNumbers(codeArea);\n-\t\tnumbers.setUseSourceLines(isUseSourceLines());\n-\t\tcodeScrollPane.setRowHeaderView(numbers);\n \t\tinitLineNumbers(isUseSourceLines());\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n@@ -42,7 +42,8 @@ public class LineNumbers extends JPanel implements CaretListener {\n \tprivate static final int NUM_HEIGHT = Integer.MAX_VALUE - 1000000;\n \tprivate static final Map<?, ?> DESKTOP_HINTS = (Map<?, ?>) Toolkit.getDefaultToolkit().getDesktopProperty(\"awt.font.desktophints\");\n \n-\tprivate final AbstractCodeArea codeArea;\n+\tprivate final transient AbstractCodeArea codeArea;\n+\tprivate final transient ICodeInfo codeInfo;\n \tprivate boolean useSourceLines = true;\n \n \tprivate transient int lastDigits;\n@@ -55,10 +56,11 @@ public class LineNumbers extends JPanel implements CaretListener {\n \n \tprivate transient Insets textAreaInsets;\n \tprivate transient Rectangle visibleRect = new Rectangle();\n-\tprivate transient ICodeInfo codeInfo;\n \n \tpublic LineNumbers(AbstractCodeArea codeArea) {\n \t\tthis.codeArea = codeArea;\n+\t\tthis.codeInfo = codeArea.getNode().getCodeInfo();\n+\n \t\tsetFont(codeArea.getFont());\n \t\tSyntaxScheme syntaxScheme = codeArea.getSyntaxScheme();\n \t\tnumberColor = syntaxScheme.getStyle(Token.LITERAL_NUMBER_DECIMAL_INT).foreground;\n@@ -110,8 +112,6 @@ private void setPreferredWidth() {\n \t@SuppressWarnings(\"deprecation\")\n \t@Override\n \tpublic void paintComponent(Graphics g) {\n-\t\tcodeInfo = codeArea.getNode().getCodeInfo();\n-\n \t\tvisibleRect = g.getClipBounds(visibleRect);\n \t\tif (visibleRect == null) {\n \t\t\tvisibleRect = getVisibleRect();\n@@ -127,7 +127,7 @@ public void paintComponent(Graphics g) {\n \n \t\tDimension size = getSize();\n \t\tg.setColor(codeArea.getBackground());\n-\t\tg.fillRect(0, 0, size.width, size.height);\n+\t\tg.fillRect(0, visibleRect.y, size.width, visibleRect.height);\n \n \t\tFontMetrics fontMetrics = codeArea.getFontMetrics(font);\n \t\tInsets insets = getInsets();",
    "output": "Fix improve code area performance and line numbers repaint"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/device/debugger/BreakpointManager.java b/jadx-gui/src/main/java/jadx/gui/device/debugger/BreakpointManager.java\n--- a/jadx-gui/src/main/java/jadx/gui/device/debugger/BreakpointManager.java\n+++ b/jadx-gui/src/main/java/jadx/gui/device/debugger/BreakpointManager.java\n@@ -166,7 +166,7 @@ protected String getFullMthRawID() {\n \n \t\t@Override\n \t\tpublic int hashCode() {\n-\t\t\treturn (int) (31 * codeOffset + 31 * cls.hashCode() + 31 * mth.hashCode());\n+\t\t\treturn Objects.hash(codeOffset, cls, mth);\n \t\t}\n \n \t\t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java b/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java\n--- a/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java\n+++ b/jadx-gui/src/main/java/jadx/gui/device/debugger/smali/Smali.java\n@@ -660,8 +660,8 @@ private void fmtCols(InsnData insn, LineInfo line) {\n \tprivate void formatByteCode(StringBuilder smali, byte[] bytes) {\n \t\tint maxLen = Math.min(bytes.length, 4 * 2); // limit to 4 units\n \t\tStringBuilder inHex = new StringBuilder();\n-\t\tfor (int i = 0; i < maxLen; i++) {\n-\t\t\tint temp = ((bytes[i++] & 0xff) << 8) | (bytes[i] & 0xff);\n+\t\tfor (int i = 0; i < maxLen - 1; i += 2) {\n+\t\t\tint temp = ((bytes[i] & 0xff) << 8) | (bytes[i + 1] & 0xff);\n \t\t\tinHex.append(String.format(\"%04x \", temp));\n \t\t}\n \t\tsmali.append(String.format(FMT_BYTECODE_COL, inHex));",
    "output": "Fix resolve LGTM alerts"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/ADBDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/ADBDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/ADBDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/ADBDialog.java\n@@ -624,7 +624,8 @@ private String forwardJDWP() {\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tresultDesc = rst.desc;\n-\t\t\t\t} while (false);\n+\t\t\t\t\tbreak;\n+\t\t\t\t} while (true);\n \t\t\t} catch (IOException e) {\n \t\t\t\te.printStackTrace();\n \t\t\t}",
    "output": "Fix correct port retry in smali debugger"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -158,9 +158,10 @@ private void parseNameSpace() throws IOException {\n \t\tint beginPrefix = is.readInt32();\n \t\tint beginURI = is.readInt32();\n \n+\t\tString nsKey = getString(beginURI);\n \t\tString nsValue = getString(beginPrefix);\n-\t\tif (!nsMap.containsValue(nsValue)) {\n-\t\t\tnsMap.putIfAbsent(getString(beginURI), nsValue);\n+\t\tif (StringUtils.notBlank(nsKey) && !nsMap.containsValue(nsValue)) {\n+\t\t\tnsMap.putIfAbsent(nsKey, nsValue);\n \t\t}\n \t\tnamespaceDepth++;\n \t}\n@@ -178,9 +179,10 @@ private void parseNameSpaceEnd() throws IOException {\n \t\tint endURI = is.readInt32();\n \t\tnamespaceDepth--;\n \n+\t\tString nsKey = getString(endURI);\n \t\tString nsValue = getString(endPrefix);\n-\t\tif (!nsMap.containsValue(nsValue)) {\n-\t\t\tnsMap.putIfAbsent(getString(endURI), nsValue);\n+\t\tif (StringUtils.notBlank(nsKey) && !nsMap.containsValue(nsValue)) {\n+\t\t\tnsMap.putIfAbsent(nsKey, nsValue);\n \t\t}\n \t}\n \n@@ -246,7 +248,7 @@ private void parseElement() throws IOException {\n \t\tint styleIndex = is.readInt16();\n \t\tif (\"manifest\".equals(currentTag) || writer.getIndent() == 0) {\n \t\t\tfor (Map.Entry<String, String> entry : nsMap.entrySet()) {\n-\t\t\t\tString nsValue = entry.getValue();\n+\t\t\t\tString nsValue = getValidTagAttributeName(entry.getValue());\n \t\t\t\twriter.add(\" xmlns\");\n \t\t\t\tif (nsValue != null && !nsValue.trim().isEmpty()) {\n \t\t\t\t\twriter.add(':');",
    "output": "Fix invalid XML NS names * Fix issue in invalid XML NS names * fix: replace methods not available in Java 8 Co-authored-by: bagipro <bugi@MacBook-Pro-2.local> Co-authored-by: Skylot <skylot@gmail.com>"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n@@ -173,10 +173,11 @@ public String decode(String attrName, long value) {\n \t\t} else if (attr.getType() == MAttrType.FLAG) {\n \t\t\tStringBuilder sb = new StringBuilder();\n \t\t\tfor (Map.Entry<Long, String> entry : attr.getValues().entrySet()) {\n-\t\t\t\tif (value == entry.getKey()) {\n+\t\t\t\tlong key = entry.getKey();\n+\t\t\t\tif (value == key) {\n \t\t\t\t\tsb = new StringBuilder(entry.getValue() + '|');\n \t\t\t\t\tbreak;\n-\t\t\t\t} else if ((value & entry.getKey()) == entry.getKey()) {\n+\t\t\t\t} else if ((key != 0) && ((value & key) == key)) {\n \t\t\t\t\tsb.append(entry.getValue()).append('|');\n \t\t\t\t}\n \t\t\t}",
    "output": "Fix XML attribute decoding"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java\n@@ -95,7 +95,9 @@ public CommonSearchDialog(MainWindow mainWindow) {\n \tprotected abstract void loadStart();\n \n \tpublic void loadWindowPos() {\n-\t\tmainWindow.getSettings().loadWindowPos(this);\n+\t\tif (!mainWindow.getSettings().loadWindowPos(this)) {\n+\t\t\tsetSize(800, 500);\n+\t\t}\n \t}\n \n \tpublic void prepare() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n@@ -1,9 +1,6 @@\n package jadx.gui.ui;\n \n-import java.awt.BorderLayout;\n-import java.awt.Container;\n-import java.awt.Dimension;\n-import java.awt.FlowLayout;\n+import java.awt.*;\n import java.awt.event.KeyAdapter;\n import java.awt.event.KeyEvent;\n import java.util.Collections;\n@@ -38,10 +35,12 @@\n import jadx.gui.utils.NLS;\n import jadx.gui.utils.TextStandardActions;\n import jadx.gui.utils.layout.WrapLayout;\n+import jadx.gui.utils.search.SearchSettings;\n import jadx.gui.utils.search.TextSearchIndex;\n \n public class SearchDialog extends CommonSearchDialog {\n \tprivate static final long serialVersionUID = -5105405456969134105L;\n+\tprivate static final Color SEARCHFIELD_ERROR_COLOR = new Color(255, 150, 150);\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(SearchDialog.class);\n \n@@ -81,6 +80,8 @@ public enum SearchOptions {\n \tprivate final transient SearchPreset searchPreset;\n \tprivate final transient Set<SearchOptions> options;\n \n+\tprivate Color searchFieldDefaultBgColor;\n+\n \tprivate transient JTextField searchField;\n \n \tprivate transient Disposable searchDisposable;\n@@ -95,10 +96,10 @@ private SearchDialog(MainWindow mainWindow, SearchPreset preset, Set<SearchOptio\n \t\tthis.options = buildOptions(preset);\n \t\tthis.options.addAll(additionalOptions);\n \n+\t\tloadWindowPos();\n \t\tinitUI();\n \t\tsearchFieldSubscribe();\n \t\tregisterInitOnOpen();\n-\t\tloadWindowPos();\n \t\tregisterActiveTabListener();\n \t}\n \n@@ -183,6 +184,7 @@ private boolean isFullIndexNeeded() {\n \n \tprivate void initUI() {\n \t\tsearchField = new JTextField();\n+\t\tsearchFieldDefaultBgColor = searchField.getBackground();\n \t\tsearchField.setAlignmentX(LEFT_ALIGNMENT);\n \t\tTextStandardActions.attach(searchField);\n \n@@ -246,8 +248,6 @@ public void keyReleased(KeyEvent e) {\n \t\t});\n \n \t\tsetTitle(NLS.str(\"menu.text_search\"));\n-\t\tpack();\n-\t\tsetSize(800, 500);\n \t\tsetLocationRelativeTo(null);\n \t\tsetDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n \t\tsetModalityType(ModalityType.MODELESS);\n@@ -306,7 +306,16 @@ private Flowable<JNode> prepareSearch(String text) {\n \t\t}\n \t\tLOG.debug(\"search event: {}\", text);\n \t\tshowSearchState();\n-\t\treturn index.buildSearch(text, options);\n+\t\ttry {\n+\t\t\tFlowable<JNode> result = index.buildSearch(text, options);\n+\t\t\tif (searchField.getBackground() == SEARCHFIELD_ERROR_COLOR) {\n+\t\t\t\tsearchField.setBackground(searchFieldDefaultBgColor);\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t} catch (SearchSettings.InvalidSearchTermException e) {\n+\t\t\tsearchField.setBackground(SEARCHFIELD_ERROR_COLOR);\n+\t\t\treturn Flowable.empty();\n+\t\t}\n \t}\n \n \tprivate void processSearchResults(java.util.List<JNode> results) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/layout/WrapLayout.java b/jadx-gui/src/main/java/jadx/gui/utils/layout/WrapLayout.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/layout/WrapLayout.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/layout/WrapLayout.java\n@@ -128,10 +128,10 @@ private Dimension layoutSize(Container target, boolean preferred) {\n \n \t\t\t\tif (m.isVisible()) {\n \t\t\t\t\tDimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();\n+\t\t\t\t\tint width = d.width;\n \n \t\t\t\t\t// Can't add the component to current row. Start a new row.\n-\n-\t\t\t\t\tif (rowWidth + d.width > maxWidth) {\n+\t\t\t\t\tif (rowWidth + width >= maxWidth) {\n \t\t\t\t\t\taddRow(dim, rowWidth, rowHeight);\n \t\t\t\t\t\trowWidth = 0;\n \t\t\t\t\t\trowHeight = 0;\n@@ -143,7 +143,7 @@ private Dimension layoutSize(Container target, boolean preferred) {\n \t\t\t\t\t\trowWidth += hgap;\n \t\t\t\t\t}\n \n-\t\t\t\t\trowWidth += d.width;\n+\t\t\t\t\trowWidth += width;\n \t\t\t\t\trowHeight = Math.max(rowHeight, d.height);\n \t\t\t\t}\n \t\t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/search/SearchSettings.java b/jadx-gui/src/main/java/jadx/gui/utils/search/SearchSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/search/SearchSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/SearchSettings.java\n@@ -52,14 +52,13 @@ public Pattern getPattern() {\n \t\treturn this.regexPattern;\n \t}\n \n-\tpublic boolean preCompile() {\n+\tpublic boolean preCompile() throws InvalidSearchTermException {\n \t\tif (useRegex) {\n \t\t\ttry {\n \t\t\t\tint flags = ignoreCase ? Pattern.CASE_INSENSITIVE : 0;\n \t\t\t\tthis.regexPattern = Pattern.compile(searchString, flags);\n \t\t\t} catch (Exception e) {\n-\t\t\t\tLOG.warn(\"Invalid Regex: {}\", this.searchString, e);\n-\t\t\t\treturn false;\n+\t\t\t\tthrow new InvalidSearchTermException(\"Invalid Regex: \" + this.searchString, e);\n \t\t\t}\n \t\t}\n \t\treturn true;\n@@ -105,4 +104,11 @@ public JClass getActiveCls() {\n \tpublic void setActiveCls(JClass activeCls) {\n \t\tthis.activeCls = activeCls;\n \t}\n+\n+\tpublic static class InvalidSearchTermException extends Exception {\n+\n+\t\tpublic InvalidSearchTermException(String message, Throwable cause) {\n+\t\t\tsuper(message, cause);\n+\t\t}\n+\t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java b/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java\n@@ -109,7 +109,8 @@ public void remove(JavaClass cls) {\n \t\tthis.codeIndex.removeForCls(cls);\n \t}\n \n-\tpublic Flowable<JNode> buildSearch(String text, Set<SearchDialog.SearchOptions> options) {\n+\tpublic Flowable<JNode> buildSearch(String text, Set<SearchDialog.SearchOptions> options)\n+\t\t\tthrows SearchSettings.InvalidSearchTermException {\n \t\tboolean ignoreCase = options.contains(IGNORE_CASE);\n \t\tboolean useRegex = options.contains(USE_REGEX);",
    "output": "Fix small search dialog optimizations"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n@@ -463,8 +463,8 @@ private static void processAnonymousConstructor(MethodNode mth, ConstructorInsn\n \t\t\t\tSSAVar sVar = reg.getSVar();\n \t\t\t\tif (sVar != null) {\n \t\t\t\t\tsVar.getCodeVar().setFinal(true);\n-\t\t\t\t\tsVar.getAssign().add(AFlag.DONT_INLINE);\n \t\t\t\t}\n+\t\t\t\treg.add(AFlag.DONT_INLINE);\n \t\t\t\treg.add(AFlag.SKIP_ARG);\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass17.java b/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass17.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass17.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass17.java\n@@ -0,0 +1,40 @@\n+package jadx.tests.integration.inner;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestAnonymousClass17 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\t@SuppressWarnings({ \"checkstyle:InnerAssignment\", \"Convert2Lambda\" })\n+\t\tpublic void test(boolean a, boolean b) {\n+\t\t\tString v;\n+\t\t\tif (a && (v = get(b)) != null) {\n+\t\t\t\tuse(new Runnable() {\n+\t\t\t\t\t@Override\n+\t\t\t\t\tpublic void run() {\n+\t\t\t\t\t\tSystem.out.println(v);\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic String get(boolean a) {\n+\t\t\treturn a ? \"str\" : null;\n+\t\t}\n+\n+\t\tpublic void use(Runnable r) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"if (a && (v = get(b)) != null) {\");\n+\t}\n+}",
    "output": "Fix correct inline flag for variables used in anonymous classes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n@@ -498,19 +498,26 @@ private static boolean independentBlockTreeMod(MethodNode mth) {\n \t}\n \n \tprivate static boolean checkLoops(MethodNode mth, BlockNode block) {\n+\t\tif (!block.contains(AFlag.LOOP_START)) {\n+\t\t\treturn false;\n+\t\t}\n \t\tList<LoopInfo> loops = block.getAll(AType.LOOP);\n \t\tint loopsCount = loops.size();\n \t\tif (loopsCount == 0) {\n \t\t\treturn false;\n \t\t}\n+\t\tfor (LoopInfo loop : loops) {\n+\t\t\tif (insertBlocksForBreak(mth, loop)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n \t\tif (loopsCount > 1 && splitLoops(mth, block, loops)) {\n \t\t\treturn true;\n \t\t}\n \t\tif (loopsCount == 1) {\n \t\t\tLoopInfo loop = loops.get(0);\n-\t\t\treturn insertBlocksForBreak(mth, loop)\n-\t\t\t\t\t|| insertBlocksForContinue(mth, loop)\n-\t\t\t\t\t|| insertBlockForProdecessors(mth, loop)\n+\t\t\treturn insertBlocksForContinue(mth, loop)\n+\t\t\t\t\t|| insertBlockForPredecessors(mth, loop)\n \t\t\t\t\t|| insertPreHeader(mth, loop);\n \t\t}\n \t\treturn false;\n@@ -588,7 +595,7 @@ private static boolean insertBlocksForContinue(MethodNode mth, LoopInfo loop) {\n \t/**\n \t * Insert additional block if loop header has several predecessors (exclude back edges)\n \t */\n-\tprivate static boolean insertBlockForProdecessors(MethodNode mth, LoopInfo loop) {\n+\tprivate static boolean insertBlockForPredecessors(MethodNode mth, LoopInfo loop) {\n \t\tBlockNode loopHeader = loop.getStart();\n \t\tList<BlockNode> preds = loopHeader.getPredecessors();\n \t\tif (preds.size() > 2) {",
    "output": "Fix prevent infinite loop in block tree mod for loops"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/search/StringRef.java b/jadx-gui/src/main/java/jadx/gui/utils/search/StringRef.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/search/StringRef.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/StringRef.java\n@@ -140,6 +140,10 @@ public static List<StringRef> split(String str, String splitBy) {\n \t\treturn list;\n \t}\n \n+\tpublic int getOffset() {\n+\t\treturn offset;\n+\t}\n+\n \tpublic int hashCode() {\n \t\tint h = hash;\n \t\tint len = length;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java b/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java\n@@ -91,7 +91,7 @@ public void indexCode(JavaClass cls, CodeLinesInfo linesInfo, List<StringRef> li\n \t\t\t\tJavaNode node = linesInfo.getJavaNodeByLine(lineNum);\n \t\t\t\tJavaNode javaNode = node == null ? cls : node;\n \t\t\t\tJNode nodeAtLine = nodeCache.makeFrom(javaNode);\n-\t\t\t\tcodeIndex.put(new CodeNode(nodeAtLine, line, lineNum, javaNode.getDefPos()));\n+\t\t\t\tcodeIndex.put(new CodeNode(nodeAtLine, line, lineNum, line.getOffset()));\n \t\t\t}\n \t\t} catch (Exception e) {\n \t\t\tLOG.warn(\"Failed to index class: {}\", cls, e);",
    "output": "Use correct offset for code line"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Jadx.java b/jadx-core/src/main/java/jadx/core/Jadx.java\n--- a/jadx-core/src/main/java/jadx/core/Jadx.java\n+++ b/jadx-core/src/main/java/jadx/core/Jadx.java\n@@ -14,6 +14,7 @@\n import jadx.core.dex.visitors.AttachCommentsVisitor;\n import jadx.core.dex.visitors.AttachMethodDetails;\n import jadx.core.dex.visitors.AttachTryCatchVisitor;\n+import jadx.core.dex.visitors.CheckCode;\n import jadx.core.dex.visitors.ClassModifier;\n import jadx.core.dex.visitors.ConstInlineVisitor;\n import jadx.core.dex.visitors.ConstructorVisitor;\n@@ -96,6 +97,7 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {\n \t\t}\n \n \t\tList<IDexTreeVisitor> passes = new ArrayList<>();\n+\t\tpasses.add(new CheckCode());\n \t\tif (args.isDebugInfo()) {\n \t\t\tpasses.add(new DebugInfoAttachVisitor());\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -612,6 +612,11 @@ public IDebugInfo getDebugInfo() {\n \t\treturn noCode ? null : codeReader.getDebugInfo();\n \t}\n \n+\tpublic void ignoreMethod() {\n+\t\tadd(AFlag.DONT_GENERATE);\n+\t\tnoCode = true;\n+\t}\n+\n \t/**\n \t * Calculate instructions count at currect stage\n \t */\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/CheckCode.java b/jadx-core/src/main/java/jadx/core/dex/visitors/CheckCode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/CheckCode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CheckCode.java\n@@ -0,0 +1,48 @@\n+package jadx.core.dex.visitors;\n+\n+import jadx.core.dex.info.MethodInfo;\n+import jadx.core.dex.instructions.InsnType;\n+import jadx.core.dex.nodes.InsnNode;\n+import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.utils.exceptions.JadxException;\n+\n+@JadxVisitor(\n+\t\tname = \"CheckCode\",\n+\t\tdesc = \"Check and remove bad or incorrect code\"\n+)\n+public class CheckCode extends AbstractVisitor {\n+\n+\t@Override\n+\tpublic void visit(MethodNode mth) throws JadxException {\n+\t\tMethodInfo mthInfo = mth.getMethodInfo();\n+\t\tif (mthInfo.getArgumentsTypes().size() > 255) {\n+\t\t\t// java spec don't allow more than 255 args\n+\t\t\tif (canRemoveMethod(mth)) {\n+\t\t\t\tmth.ignoreMethod();\n+\t\t\t} else {\n+\t\t\t\t// TODO: convert args to array\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate boolean canRemoveMethod(MethodNode mth) {\n+\t\tif (mth.getUseIn().isEmpty()) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tInsnNode[] insns = mth.getInstructions();\n+\t\tif (insns.length == 0) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tfor (InsnNode insn : insns) {\n+\t\t\tif (insn != null && insn.getType() != InsnType.NOP) {\n+\t\t\t\tif (insn.getType() == InsnType.RETURN && insn.getArgsCount() == 0) {\n+\t\t\t\t\t// ignore void return\n+\t\t\t\t} else {\n+\t\t\t\t\t// found useful instruction\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+}",
    "output": "Remove method with more than 255 args"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java\n@@ -97,6 +97,8 @@ public class AType<T extends IAttribute> {\n \n \tpublic static final Set<AType<?>> SKIP_ON_UNLOAD = new HashSet<>(Arrays.asList(\n \t\t\tSOURCE_FILE,\n+\t\t\tANNOTATION_LIST,\n+\t\t\tANNOTATION_MTH_PARAMETERS,\n \t\t\tFIELD_INIT,\n \t\t\tFIELD_REPLACE,\n \t\t\tMETHOD_INLINE,",
    "output": "Fix don't unload annotation attributes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n@@ -163,17 +163,33 @@ public void save() throws IOException {\n \t}\n \n \tpublic String getForCls(ClassInfo cls) {\n+\t\tif (clsPresetMap.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n \t\treturn clsPresetMap.get(cls.makeRawFullName());\n \t}\n \n \tpublic String getForFld(FieldInfo fld) {\n+\t\tif (fldPresetMap.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n \t\treturn fldPresetMap.get(fld.getRawFullId());\n \t}\n \n \tpublic String getForMth(MethodInfo mth) {\n+\t\tif (mthPresetMap.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n \t\treturn mthPresetMap.get(mth.getRawFullId());\n \t}\n \n+\tpublic Set<String> getForVars(MethodInfo mth) {\n+\t\tif (varPresetMap.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn varPresetMap.get(mth.getRawFullId());\n+\t}\n+\n \tpublic void clear() {\n \t\tclsPresetMap.clear();\n \t\tfldPresetMap.clear();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -43,6 +43,8 @@ public class Deobfuscator {\n \tprivate final Set<String> pkgSet = new TreeSet<>();\n \tprivate final Set<String> reservedClsNames = new HashSet<>();\n \n+\tprivate final NavigableSet<MethodNode> mthProcessQueue = new TreeSet<>();\n+\n \tprivate final int maxLength;\n \tprivate final int minLength;\n \tprivate final boolean useSourceNameAsAlias;\n@@ -155,6 +157,13 @@ private void process() {\n \t\tfor (ClassNode cls : root.getClasses()) {\n \t\t\tprocessClass(cls);\n \t\t}\n+\t\twhile (true) {\n+\t\t\tMethodNode next = mthProcessQueue.pollLast();\n+\t\t\tif (next == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\trenameMethod(next);\n+\t\t}\n \t}\n \n \tprivate void processClass(ClassNode cls) {\n@@ -182,9 +191,8 @@ private void processClass(ClassNode cls) {\n \t\t\t}\n \t\t\trenameField(field);\n \t\t}\n-\t\tfor (MethodNode mth : cls.getMethods()) {\n-\t\t\trenameMethod(mth);\n-\t\t}\n+\t\tmthProcessQueue.addAll(cls.getMethods());\n+\n \t\tfor (ClassNode innerCls : cls.getInnerClasses()) {\n \t\t\tprocessClass(innerCls);\n \t\t}\n@@ -203,9 +211,10 @@ public void forceRenameField(FieldNode field) {\n \t}\n \n \tprivate void renameMethod(MethodNode mth) {\n-\t\tSet<String> names = deobfPresets.getVarPresetMap().get(mth.getMethodInfo().getRawFullId());\n+\t\tMethodInfo mthInfo = mth.getMethodInfo();\n+\t\tSet<String> names = deobfPresets.getForVars(mthInfo);\n \t\tif (names != null) {\n-\t\t\tmth.getMethodInfo().setVarNameMap(names);\n+\t\t\tmthInfo.setVarNameMap(names);\n \t\t}\n \t\tString alias = getMethodAlias(mth);\n \t\tif (alias != null) {\n@@ -219,28 +228,25 @@ public void forceRenameMethod(MethodNode mth) {\n \t}\n \n \tprivate void applyMethodAlias(MethodNode mth, String alias) {\n-\t\tMethodInfo methodInfo = mth.getMethodInfo();\n-\t\tmethodInfo.setAlias(alias);\n-\t\tString prev = mthMap.put(methodInfo, alias);\n-\t\tif (prev == null) {\n-\t\t\tresolveOverriding(mth, alias);\n-\t\t}\n-\t}\n+\t\tsetSingleMethodAlias(mth, alias);\n \n-\tprivate void resolveOverriding(MethodNode mth, String alias) {\n \t\tMethodOverrideAttr overrideAttr = mth.get(AType.METHOD_OVERRIDE);\n \t\tif (overrideAttr != null) {\n \t\t\tfor (MethodNode ovrdMth : overrideAttr.getRelatedMthNodes()) {\n-\t\t\t\tif (ovrdMth == mth) {\n-\t\t\t\t\tcontinue;\n+\t\t\t\tif (ovrdMth != mth) {\n+\t\t\t\t\tsetSingleMethodAlias(ovrdMth, alias);\n \t\t\t\t}\n-\t\t\t\tMethodInfo methodInfo = ovrdMth.getMethodInfo();\n-\t\t\t\tmethodInfo.setAlias(alias);\n-\t\t\t\tmthMap.put(methodInfo, alias);\n \t\t\t}\n \t\t}\n \t}\n \n+\tprivate void setSingleMethodAlias(MethodNode mth, String alias) {\n+\t\tMethodInfo mthInfo = mth.getMethodInfo();\n+\t\tmthInfo.setAlias(alias);\n+\t\tmthMap.put(mthInfo, alias);\n+\t\tmthProcessQueue.remove(mth);\n+\t}\n+\n \tpublic void addPackagePreset(String origPkgName, String pkgAlias) {\n \t\tPackageNode pkg = getPackageNode(origPkgName, true);\n \t\tpkg.setAlias(pkgAlias);\n@@ -497,15 +503,6 @@ private String getMethodAlias(MethodNode mth) {\n \t\tif (alias != null) {\n \t\t\treturn alias;\n \t\t}\n-\t\tMethodOverrideAttr overrideAttr = mth.get(AType.METHOD_OVERRIDE);\n-\t\tif (overrideAttr != null) {\n-\t\t\tfor (MethodNode relatedMthNode : overrideAttr.getRelatedMthNodes()) {\n-\t\t\t\tString assignedAlias = getAssignedAlias(relatedMthNode.getMethodInfo());\n-\t\t\t\tif (assignedAlias != null) {\n-\t\t\t\t\treturn assignedAlias;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n \t\tif (shouldRename(mth.getName())) {\n \t\t\treturn makeMethodAlias(mth);\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java\n@@ -19,6 +19,9 @@ public final class MethodInfo implements Comparable<MethodInfo> {\n \tprivate final List<ArgType> argTypes;\n \tprivate final ClassInfo declClass;\n \tprivate final String shortId;\n+\tprivate final String rawFullId;\n+\tprivate final int hash;\n+\n \tprivate String alias;\n \tprivate Map<String, String> varNameMap;\n \n@@ -29,6 +32,8 @@ private MethodInfo(ClassInfo declClass, String name, List<ArgType> args, ArgType\n \t\tthis.argTypes = args;\n \t\tthis.retType = retType;\n \t\tthis.shortId = makeShortId(name, argTypes, retType);\n+\t\tthis.rawFullId = declClass.makeRawFullName() + '.' + shortId;\n+\t\tthis.hash = calcHashCode();\n \t}\n \n \tpublic static MethodInfo fromRef(RootNode root, IMethodRef methodRef) {\n@@ -103,7 +108,7 @@ public String getFullId() {\n \t}\n \n \tpublic String getRawFullId() {\n-\t\treturn declClass.makeRawFullName() + '.' + shortId;\n+\t\treturn rawFullId;\n \t}\n \n \t/**\n@@ -172,9 +177,13 @@ public boolean hasVarNameMap() {\n \t\treturn varNameMap != null && varNameMap.size() > 0;\n \t}\n \n+\tpublic int calcHashCode() {\n+\t\treturn shortId.hashCode() + 31 * declClass.hashCode();\n+\t}\n+\n \t@Override\n \tpublic int hashCode() {\n-\t\treturn shortId.hashCode() + 31 * declClass.hashCode();\n+\t\treturn hash;\n \t}\n \n \t@Override\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -111,7 +111,11 @@ public void loadClasses(List<ILoadResult> loadedInputs) {\n \t\t// sort classes by name, expect top classes before inner\n \t\tclasses.sort(Comparator.comparing(ClassNode::getFullName));\n \t\tinitInnerClasses();\n-\t\tLOG.info(\"Classes loaded: {}\", classes.size());\n+\n+\t\t// print stats for loaded classes\n+\t\tint mthCount = classes.stream().mapToInt(c -> c.getMethods().size()).sum();\n+\t\tint insnsCount = classes.stream().flatMap(c -> c.getMethods().stream()).mapToInt(MethodNode::getInsnsCount).sum();\n+\t\tLOG.info(\"Loaded classes: {}, methods: {}, instructions: {}\", classes.size(), mthCount, insnsCount);\n \t}\n \n \tprivate void addDummyClass(IClassData classData, Exception exc) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n@@ -1,11 +1,14 @@\n package jadx.core.utils;\n \n import java.io.File;\n+import java.util.Comparator;\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n import java.util.function.Predicate;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n@@ -18,13 +21,16 @@\n import jadx.api.impl.SimpleCodeWriter;\n import jadx.core.codegen.InsnGen;\n import jadx.core.codegen.MethodGen;\n+import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.IAttributeNode;\n+import jadx.core.dex.attributes.nodes.MethodOverrideAttr;\n import jadx.core.dex.nodes.BlockNode;\n import jadx.core.dex.nodes.IBlock;\n import jadx.core.dex.nodes.IContainer;\n import jadx.core.dex.nodes.IRegion;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.visitors.AbstractVisitor;\n import jadx.core.dex.visitors.DotGraphVisitor;\n import jadx.core.dex.visitors.IDexTreeVisitor;\n@@ -184,4 +190,23 @@ public static void printMap(Map<?, ?> map, String desc) {\n \tpublic static void printStackTrace(String label) {\n \t\tLOG.debug(\"StackTrace: {}\\n{}\", label, Utils.getStackTrace(new Exception()));\n \t}\n+\n+\tpublic static void printMethodOverrideTop(RootNode root) {\n+\t\tLOG.debug(\"Methods override top 10:\");\n+\t\troot.getClasses().stream()\n+\t\t\t\t.flatMap(c -> c.getMethods().stream())\n+\t\t\t\t.filter(m -> m.contains(AType.METHOD_OVERRIDE))\n+\t\t\t\t.map(m -> m.get(AType.METHOD_OVERRIDE))\n+\t\t\t\t.filter(o -> !o.getOverrideList().isEmpty())\n+\t\t\t\t.filter(distinctByKey(methodOverrideAttr -> methodOverrideAttr.getRelatedMthNodes().size()))\n+\t\t\t\t.filter(distinctByKey(MethodOverrideAttr::getRelatedMthNodes))\n+\t\t\t\t.sorted(Comparator.comparingInt(o -> -o.getRelatedMthNodes().size()))\n+\t\t\t\t.limit(10)\n+\t\t\t\t.forEach(o -> LOG.debug(\"  {} : {}\", o.getRelatedMthNodes().size(), Utils.last(o.getOverrideList())));\n+\t}\n+\n+\tprivate static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {\n+\t\tSet<Object> seen = ConcurrentHashMap.newKeySet();\n+\t\treturn t -> seen.add(keyExtractor.apply(t));\n+\t}\n }",
    "output": "Fix improve deobfuscation performance for overridden methods"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/QuarkDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/QuarkDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/QuarkDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/QuarkDialog.java\n@@ -1,31 +1,36 @@\n package jadx.gui.ui;\n \n-import java.awt.*;\n+import java.awt.BorderLayout;\n+import java.awt.Container;\n import java.io.BufferedReader;\n import java.io.File;\n-import java.io.FileNotFoundException;\n import java.io.FileReader;\n-import java.io.IOException;\n import java.io.InputStreamReader;\n+import java.io.Reader;\n import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n \n-import javax.swing.*;\n+import javax.swing.JButton;\n+import javax.swing.JComboBox;\n+import javax.swing.JDialog;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JProgressBar;\n+import javax.swing.SwingWorker;\n+import javax.swing.WindowConstants;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.gson.JsonIOException;\n import com.google.gson.JsonObject;\n import com.google.gson.JsonParser;\n-import com.google.gson.JsonSyntaxException;\n \n import jadx.gui.settings.JadxSettings;\n import jadx.gui.treemodel.JRoot;\n import jadx.gui.utils.NLS;\n-import jadx.gui.utils.logs.LogCollector;\n+import jadx.gui.utils.UiUtils;\n \n class QuarkDialog extends JDialog {\n \n@@ -46,7 +51,6 @@ class QuarkDialog extends JDialog {\n \tprivate ArrayList<Path> analyzeFile = new ArrayList<Path>();\n \n \tpublic QuarkDialog(MainWindow mainWindow) {\n-\n \t\tthis.mainWindow = mainWindow;\n \t\tthis.settings = mainWindow.getSettings();\n \t\tthis.files = mainWindow.getWrapper().getOpenPaths();\n@@ -56,11 +60,9 @@ public QuarkDialog(MainWindow mainWindow) {\n \t\t\treturn;\n \t\t}\n \t\tinitUI();\n-\t\tsettings.loadWindowPos(this);\n \t}\n \n \tprivate boolean prepareAnalysis() {\n-\n \t\tString[] exts = new String[] { \"apk\", \"dex\" };\n \n \t\tif (this.files.size() != 1) {\n@@ -69,8 +71,8 @@ private boolean prepareAnalysis() {\n \t\t\t\tint dotIndex = fileName.lastIndexOf('.');\n \t\t\t\tString extension = (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n \n-\t\t\t\tif (!Arrays.stream(exts).anyMatch(extension::equals)) {\n-\t\t\t\t\tLOG.warn(\"Quark: Current file can't be analysis \", fileName);\n+\t\t\t\tif (Arrays.stream(exts).noneMatch(extension::equals)) {\n+\t\t\t\t\tLOG.warn(\"Quark: Current file can't be analysis: {}\", fileName);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tanalyzeFile.add(filePath);\n@@ -80,8 +82,8 @@ private boolean prepareAnalysis() {\n \t\tString fileName = this.files.get(0).toString();\n \t\tint dotIndex = fileName.lastIndexOf('.');\n \t\tString extension = (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n-\t\tif (!Arrays.stream(exts).anyMatch(extension::equals)) {\n-\t\t\tLOG.warn(\"Quark: Current file can't be analysis \", fileName);\n+\t\tif (Arrays.stream(exts).noneMatch(extension::equals)) {\n+\t\t\tLOG.warn(\"Quark: Current file can't be analysis: {}\", fileName);\n \t\t\treturn false;\n \t\t}\n \t\tanalyzeFile.add(this.files.get(0));\n@@ -99,7 +101,6 @@ private String[] filesToStringArr() {\n \t}\n \n \tpublic final void initUI() {\n-\n \t\tJLabel description = new JLabel(\"Analyzing apk using Quark-Engine\");\n \t\tJLabel selectApkText = new JLabel(\"Select Apk/Dex\");\n \t\tdescription.setAlignmentX(0.5f);\n@@ -144,10 +145,13 @@ public final void initUI() {\n \n \t\tsetTitle(\"Quark Engine\");\n \t\tpack();\n-\t\tsetSize(200, 125);\n-\t\tsetDefaultCloseOperation(DISPOSE_ON_CLOSE);\n-\t\tsetModalityType(ModalityType.MODELESS);\n+\t\tif (!mainWindow.getSettings().loadWindowPos(this)) {\n+\t\t\tsetSize(300, 140);\n+\t\t}\n \t\tsetLocationRelativeTo(null);\n+\t\tsetDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n+\t\tsetModalityType(ModalityType.MODELESS);\n+\t\tUiUtils.addEscapeShortCutToDispose(this);\n \t}\n \n \tprivate void analyzeAPK() {\n@@ -156,22 +160,17 @@ private void analyzeAPK() {\n \t}\n \n \tprivate void loadReportFile() {\n-\t\ttry {\n-\t\t\tJsonObject quarkReport = (JsonObject) JsonParser.parseReader(new FileReader(quarkReportFile.getAbsolutePath().toString()));\n-\n-\t\t\tJRoot root = mainWindow.getCacheObject().getJRoot();\n-\n+\t\ttry (Reader reader = new FileReader(quarkReportFile)) {\n+\t\t\tJsonObject quarkReport = (JsonObject) JsonParser.parseReader(reader);\n \t\t\tQuarkReport quarkNode = QuarkReport.analysisAPK(quarkReport);\n \n+\t\t\tJRoot root = mainWindow.getCacheObject().getJRoot();\n \t\t\troot.update();\n \t\t\troot.add(quarkNode);\n-\n \t\t\tmainWindow.reloadTree();\n-\n-\t\t} catch (JsonIOException | JsonSyntaxException | FileNotFoundException e) {\n+\t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Quark: Load report failed: \", e);\n \t\t}\n-\n \t}\n \n \tprivate void close() {\n@@ -180,7 +179,6 @@ private void close() {\n \n \t@Override\n \tpublic void dispose() {\n-\t\tLogCollector.getInstance().resetListener();\n \t\tsettings.saveWindowPos(this);\n \t\tsuper.dispose();\n \t}\n@@ -193,29 +191,34 @@ public LoadTask() {\n \t\t@Override\n \t\tpublic Void doInBackground() {\n \t\t\ttry {\n-\n \t\t\t\tquarkReportFile = File.createTempFile(\"QuarkReport-\", \".json\");\n \n-\t\t\t\tString outputPath = quarkReportFile.getAbsolutePath().toString();\n-\t\t\t\tString apkName = selectFile.getSelectedItem().toString();\n+\t\t\t\tString apkName = (String) selectFile.getSelectedItem();\n \t\t\t\tString apkPath = null;\n \t\t\t\tfor (Path path : files) {\n \t\t\t\t\tif (path.getFileName().toString().equals(apkName)) {\n \t\t\t\t\t\tapkPath = path.toString();\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tString cmd = \"quark -a \" + apkPath + \" -s -o \" + outputPath;\n-\t\t\t\tRuntime run = Runtime.getRuntime();\n-\t\t\t\tProcess process = run.exec(cmd);\n-\n-\t\t\t\tBufferedReader buf = new BufferedReader(new InputStreamReader(process.getInputStream()));\n-\t\t\t\tString output = \"\";\n-\t\t\t\tLOG.debug(\"Quark analyzing...\");\n-\t\t\t\twhile ((output = buf.readLine()) != null) {\n-\t\t\t\t\tLOG.debug(output);\n+\t\t\t\tList<String> cmdList = new ArrayList<>();\n+\t\t\t\tcmdList.add(\"quark\");\n+\t\t\t\tcmdList.add(\"-a\");\n+\t\t\t\tcmdList.add(apkPath);\n+\t\t\t\tcmdList.add(\"-s\");\n+\t\t\t\tcmdList.add(\"-o\");\n+\t\t\t\tcmdList.add(quarkReportFile.getAbsolutePath());\n+\t\t\t\tLOG.debug(\"Running Quark cmd: {}\", String.join(\" \", cmdList));\n+\t\t\t\tProcess process = Runtime.getRuntime().exec(cmdList.toArray(new String[0]));\n+\t\t\t\ttry (BufferedReader buf = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n+\t\t\t\t\tLOG.debug(\"Quark analyzing...\");\n+\t\t\t\t\twhile (process.isAlive()) {\n+\t\t\t\t\t\tString output = buf.readLine();\n+\t\t\t\t\t\tif (output != null) {\n+\t\t\t\t\t\t\tLOG.debug(output);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n-\n-\t\t\t} catch (IOException e) {\n+\t\t\t} catch (Exception e) {\n \t\t\t\tLOG.error(\"Quark failed: \", e);\n \t\t\t\tdispose();\n \t\t\t}\n@@ -228,5 +231,4 @@ public void done() {\n \t\t\tdispose();\n \t\t}\n \t}\n-\n }",
    "output": "Fix resolve potential command injection, fix other code style issues"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -11,6 +11,7 @@\n import java.util.Set;\n import java.util.stream.Stream;\n \n+import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n \n import jadx.api.ICodeInfo;\n@@ -59,6 +60,9 @@ public class ClassGen {\n \n \tprivate boolean bodyGenStarted;\n \n+\t@Nullable\n+\tprivate NameGen outerNameGen;\n+\n \tpublic ClassGen(ClassNode cls, JadxArgs jadxArgs) {\n \t\tthis(cls, null, jadxArgs.isUseImports(), jadxArgs.isFallbackMode(), jadxArgs.isShowInconsistentCode());\n \t}\n@@ -238,13 +242,12 @@ public void addClassBody(ICodeWriter clsCode) throws CodegenException {\n \t */\n \tpublic void addClassBody(ICodeWriter clsCode, boolean printClassName) throws CodegenException {\n \t\tclsCode.add('{');\n+\t\tif (printClassName) {\n+\t\t\tclsCode.add(\" // from class: \" + cls.getClassInfo().getFullName());\n+\t\t}\n \t\tsetBodyGenStarted(true);\n \t\tclsDeclOffset = clsCode.getLength();\n \t\tclsCode.incIndent();\n-\t\tif (printClassName) {\n-\t\t\tclsCode.startLine();\n-\t\t\tclsCode.add(\"/* class \" + cls.getFullName() + \" */\");\n-\t\t}\n \t\taddFields(clsCode);\n \t\taddInnerClsAndMethods(clsCode);\n \t\tclsCode.decIndent();\n@@ -746,4 +749,13 @@ public boolean isBodyGenStarted() {\n \tpublic void setBodyGenStarted(boolean bodyGenStarted) {\n \t\tthis.bodyGenStarted = bodyGenStarted;\n \t}\n+\n+\t@Nullable\n+\tpublic NameGen getOuterNameGen() {\n+\t\treturn outerNameGen;\n+\t}\n+\n+\tpublic void setOuterNameGen(@NotNull NameGen outerNameGen) {\n+\t\tthis.outerNameGen = outerNameGen;\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -725,7 +725,10 @@ private void inlineAnonymousConstructor(ICodeWriter code, ClassNode cls, Constru\n \t\tMethodNode callMth = mth.root().resolveMethod(insn.getCallMth());\n \t\tgenerateMethodArguments(code, insn, 0, callMth);\n \t\tcode.add(' ');\n-\t\tnew ClassGen(cls, mgen.getClassGen().getParentGen()).addClassBody(code, true);\n+\n+\t\tClassGen classGen = new ClassGen(cls, mgen.getClassGen().getParentGen());\n+\t\tclassGen.setOuterNameGen(mgen.getNameGen());\n+\t\tclassGen.addClassBody(code, true);\n \t}\n \n \tprivate void makeInvoke(InvokeNode insn, ICodeWriter code) throws CodegenException {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -58,7 +58,7 @@ public MethodGen(ClassGen classGen, MethodNode mth) {\n \t\tthis.mth = mth;\n \t\tthis.classGen = classGen;\n \t\tthis.annotationGen = classGen.getAnnotationGen();\n-\t\tthis.nameGen = new NameGen(mth, classGen.isFallbackMode());\n+\t\tthis.nameGen = new NameGen(mth, classGen);\n \t}\n \n \tpublic ClassGen getClassGen() {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/NameGen.java b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n@@ -53,9 +53,13 @@ public class NameGen {\n \t\t\t\t\"java.lang.Exception\", \"exc\");\n \t}\n \n-\tpublic NameGen(MethodNode mth, boolean fallback) {\n+\tpublic NameGen(MethodNode mth, ClassGen classGen) {\n \t\tthis.mth = mth;\n-\t\tthis.fallback = fallback;\n+\t\tthis.fallback = classGen.isFallbackMode();\n+\t\tNameGen outerNameGen = classGen.getOuterNameGen();\n+\t\tif (outerNameGen != null) {\n+\t\t\tinheritUsedNames(outerNameGen);\n+\t\t}\n \t\taddNamesUsedInClass();\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicateVarNames.java b/jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicateVarNames.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicateVarNames.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicateVarNames.java\n@@ -0,0 +1,54 @@\n+package jadx.tests.integration.names;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestDuplicateVarNames extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic static class A {\n+\t\t\tpublic String mth(A a) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic String toString() {\n+\t\t\t\treturn \"1\";\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic A test(A a) {\n+\t\t\treturn new A() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic String mth(A innerA) {\n+\t\t\t\t\treturn a + \".\" + innerA;\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tString str = test(new A()).mth(new A() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic String toString() {\n+\t\t\t\t\treturn \"2\";\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tassertThat(str).isEqualTo(\"1.2\");\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\n+\t\tassertThat(cls)\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"return a + \\\".\\\" + a;\")\n+\t\t\t\t.doesNotContain(\"AnonymousClass1\");\n+\t}\n+}",
    "output": "Fix resolve variable name shadowing in anonymous classes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -426,6 +426,8 @@ private void addEnumFields(ICodeWriter code) throws CodegenException {\n \t\tInsnGen igen = null;\n \t\tfor (Iterator<EnumField> it = enumFields.getFields().iterator(); it.hasNext();) {\n \t\t\tEnumField f = it.next();\n+\n+\t\t\tCodeGenUtils.addComments(code, f.getField());\n \t\t\tcode.startLine(f.getField().getAlias());\n \t\t\tConstructorInsn constrInsn = f.getConstrInsn();\n \t\t\tMethodNode callMth = cls.root().resolveMethod(constrInsn.getCallMth());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -330,6 +330,10 @@ public List<FieldNode> getFields() {\n \t\treturn fields;\n \t}\n \n+\tpublic void addField(FieldNode fld) {\n+\t\tfields.add(fld);\n+\t}\n+\n \tpublic FieldNode getConstField(Object obj) {\n \t\treturn getConstField(obj, true);\n \t}\n@@ -651,5 +655,4 @@ public int compareTo(@NotNull ClassNode o) {\n \tpublic String toString() {\n \t\treturn clsInfo.getFullName();\n \t}\n-\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -262,9 +262,9 @@ private List<EnumField> extractEnumFieldsFromFilledArray(ClassNode cls, InsnNode\n \t\t\tEnumField field = null;\n \t\t\tif (arg.isInsnWrap()) {\n \t\t\t\tInsnNode wrappedInsn = ((InsnWrapArg) arg).getWrapInsn();\n-\t\t\t\tfield = processEnumFieldByField(cls, wrappedInsn, staticBlock, toRemove);\n+\t\t\t\tfield = processEnumFieldByWrappedInsn(cls, wrappedInsn, staticBlock, toRemove);\n \t\t\t} else if (arg.isRegister()) {\n-\t\t\t\tfield = processEnumFiledByRegister(cls, (RegisterArg) arg, staticBlock, toRemove);\n+\t\t\t\tfield = processEnumFieldByRegister(cls, (RegisterArg) arg, staticBlock, toRemove);\n \t\t\t}\n \t\t\tif (field == null) {\n \t\t\t\treturn null;\n@@ -275,6 +275,19 @@ private List<EnumField> extractEnumFieldsFromFilledArray(ClassNode cls, InsnNode\n \t\treturn enumFields;\n \t}\n \n+\tprivate EnumField processEnumFieldByWrappedInsn(ClassNode cls, InsnNode wrappedInsn, BlockNode staticBlock, List<InsnNode> toRemove) {\n+\t\tif (wrappedInsn.getType() == InsnType.SGET) {\n+\t\t\treturn processEnumFieldByField(cls, wrappedInsn, staticBlock, toRemove);\n+\t\t}\n+\t\tConstructorInsn constructorInsn = castConstructorInsn(wrappedInsn);\n+\t\tif (constructorInsn != null) {\n+\t\t\tFieldNode enumFieldNode = createFakeField(cls, \"EF\" + constructorInsn.getOffset());\n+\t\t\tcls.addField(enumFieldNode);\n+\t\t\treturn createEnumFieldByConstructor(cls, enumFieldNode, constructorInsn);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \t@Nullable\n \tprivate EnumField processEnumFieldByField(ClassNode cls, InsnNode sgetInsn, BlockNode staticBlock, List<InsnNode> toRemove) {\n \t\tif (sgetInsn.getType() != InsnType.SGET) {\n@@ -303,16 +316,40 @@ private EnumField processEnumFieldByField(ClassNode cls, InsnNode sgetInsn, Bloc\n \t}\n \n \t@Nullable\n-\tprivate EnumField processEnumFiledByRegister(ClassNode cls, RegisterArg arg, BlockNode staticBlock, List<InsnNode> toRemove) {\n+\tprivate EnumField processEnumFieldByRegister(ClassNode cls, RegisterArg arg, BlockNode staticBlock, List<InsnNode> toRemove) {\n \t\tInsnNode assignInsn = arg.getAssignInsn();\n \t\tif (assignInsn != null && assignInsn.getType() == InsnType.SGET) {\n \t\t\treturn processEnumFieldByField(cls, assignInsn, staticBlock, toRemove);\n \t\t}\n \n \t\tSSAVar ssaVar = arg.getSVar();\n-\t\tif (ssaVar.getUseCount() == 1) {\n+\t\tif (ssaVar.getUseCount() == 0) {\n \t\t\treturn null;\n \t\t}\n+\t\tInsnNode constrInsn = ssaVar.getAssign().getParentInsn();\n+\t\tif (constrInsn == null || constrInsn.getType() != InsnType.CONSTRUCTOR) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tFieldNode enumFieldNode = searchEnumField(cls, ssaVar, toRemove);\n+\t\tif (enumFieldNode == null) {\n+\t\t\tenumFieldNode = createFakeField(cls, \"EF\" + arg.getRegNum());\n+\t\t\tcls.addField(enumFieldNode);\n+\t\t}\n+\t\ttoRemove.add(constrInsn);\n+\t\treturn createEnumFieldByConstructor(cls, enumFieldNode, (ConstructorInsn) constrInsn);\n+\t}\n+\n+\tprivate FieldNode createFakeField(ClassNode cls, String name) {\n+\t\tFieldNode enumFieldNode;\n+\t\tFieldInfo fldInfo = FieldInfo.from(cls.root(), cls.getClassInfo(), name, cls.getType());\n+\t\tenumFieldNode = new FieldNode(cls, fldInfo, 0);\n+\t\tenumFieldNode.add(AFlag.SYNTHETIC);\n+\t\tenumFieldNode.addAttr(AType.COMMENTS, \"Fake field, exist only in values array\");\n+\t\treturn enumFieldNode;\n+\t}\n+\n+\t@Nullable\n+\tprivate FieldNode searchEnumField(ClassNode cls, SSAVar ssaVar, List<InsnNode> toRemove) {\n \t\tInsnNode sputInsn = ssaVar.getUseList().get(0).getParentInsn();\n \t\tif (sputInsn == null || sputInsn.getType() != InsnType.SPUT) {\n \t\t\treturn null;\n@@ -322,14 +359,8 @@ private EnumField processEnumFiledByRegister(ClassNode cls, RegisterArg arg, Blo\n \t\tif (enumFieldNode == null) {\n \t\t\treturn null;\n \t\t}\n-\n-\t\tInsnNode constrInsn = ssaVar.getAssign().getParentInsn();\n-\t\tif (constrInsn == null || constrInsn.getType() != InsnType.CONSTRUCTOR) {\n-\t\t\treturn null;\n-\t\t}\n \t\ttoRemove.add(sputInsn);\n-\t\ttoRemove.add(constrInsn);\n-\t\treturn createEnumFieldByConstructor(cls, enumFieldNode, (ConstructorInsn) constrInsn);\n+\t\treturn enumFieldNode;\n \t}\n \n \tprivate EnumField createEnumFieldByConstructor(ClassNode cls, FieldNode enumFieldNode, ConstructorInsn co) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums10.java b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums10.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums10.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums10.java\n@@ -0,0 +1,22 @@\n+package jadx.tests.integration.enums;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+/**\n+ * Some enum field was removed, but still exist in values array\n+ */\n+public class TestEnums10 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"Failed to restore enum class\")\n+\t\t\t\t.containsOne(\"enum TestEnums10 {\")\n+\t\t\t\t.countString(4, \"/* Fake field\");\n+\t}\n+}",
    "output": "Fix restore enums with removed fields"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/ContentPanel.java b/jadx-gui/src/main/java/jadx/gui/ui/ContentPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/ContentPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/ContentPanel.java\n@@ -4,6 +4,7 @@\n \n import org.jetbrains.annotations.Nullable;\n \n+import jadx.gui.treemodel.JClass;\n import jadx.gui.treemodel.JNode;\n \n public abstract class ContentPanel extends JPanel {\n@@ -38,6 +39,10 @@ public JNode getNode() {\n \t */\n \t@Nullable\n \tpublic String getTabTooltip() {\n-\t\treturn null;\n+\t\tJClass jClass = node.getRootClass();\n+\t\tif (jClass != null) {\n+\t\t\treturn jClass.getFullName();\n+\t\t}\n+\t\treturn node.getName();\n \t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/TabComponent.java b/jadx-gui/src/main/java/jadx/gui/ui/TabComponent.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/TabComponent.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabComponent.java\n@@ -47,7 +47,13 @@ private void init() {\n \t\tpanel.setOpaque(false);\n \n \t\tJNode node = contentPanel.getNode();\n-\t\tlabel = new JLabel(node.makeLongStringHtml());\n+\t\tString tabTitle;\n+\t\tif (node.getRootClass() != null) {\n+\t\t\ttabTitle = node.getRootClass().getName();\n+\t\t} else {\n+\t\t\ttabTitle = node.makeLongStringHtml();\n+\t\t}\n+\t\tlabel = new JLabel(tabTitle);\n \t\tlabel.setFont(getLabelFont());\n \t\tString toolTip = contentPanel.getTabTooltip();\n \t\tif (toolTip != null) {\n@@ -89,7 +95,7 @@ public void mouseClicked(MouseEvent e) {\n \n \t\tpanel.add(label);\n \t\tpanel.add(closeBtn);\n-\t\tpanel.setBorder(BorderFactory.createEmptyBorder(4, 0, 0, 0));\n+\t\tpanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));\n \t}\n \n \tprivate JPopupMenu createTabPopupMenu(final ContentPanel contentPanel) {",
    "output": "Fix compact TabComponent labels and TabToolTip"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -25,6 +25,7 @@\n import jadx.api.JadxArgs;\n import jadx.cli.JadxCLIArgs;\n import jadx.cli.LogHelper;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.gui.ui.MainWindow;\n import jadx.gui.ui.codearea.EditorTheme;\n import jadx.gui.utils.FontUtils;\n@@ -36,7 +37,7 @@ public class JadxSettings extends JadxCLIArgs {\n \n \tprivate static final Path USER_HOME = Paths.get(System.getProperty(\"user.home\"));\n \tprivate static final int RECENT_PROJECTS_COUNT = 15;\n-\tprivate static final int CURRENT_SETTINGS_VERSION = 10;\n+\tprivate static final int CURRENT_SETTINGS_VERSION = 11;\n \n \tprivate static final Font DEFAULT_FONT = new RSyntaxTextArea().getFont();\n \n@@ -485,6 +486,11 @@ private void upgradeSettings(int fromVersion) {\n \t\tif (fromVersion == 10) {\n \t\t\tsrhResourceSkipSize = 3;\n \t\t\tsrhResourceFileExt = \".xml|.html|.js|.json|.txt\";\n+\t\t\tfontStr = fontStr.replace('-', '/');\n+\t\t\tfromVersion++;\n+\t\t}\n+\t\tif (fromVersion != CURRENT_SETTINGS_VERSION) {\n+\t\t\tthrow new JadxRuntimeException(\"Incorrect settings upgrade\");\n \t\t}\n \t\tsettingsVersion = CURRENT_SETTINGS_VERSION;\n \t\tsync();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/FontUtils.java b/jadx-gui/src/main/java/jadx/gui/utils/FontUtils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/FontUtils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/FontUtils.java\n@@ -24,7 +24,7 @@ public static void registerBundledFonts() {\n \t}\n \n \tpublic static Font loadByStr(String fontDesc) {\n-\t\tString[] parts = fontDesc.split(\"-\");\n+\t\tString[] parts = fontDesc.split(\"/\");\n \t\tif (parts.length != 3) {\n \t\t\tthrow new JadxRuntimeException(\"Unsupported font description format: \" + fontDesc);\n \t\t}\n@@ -42,8 +42,8 @@ public static Font loadByStr(String fontDesc) {\n \n \tpublic static String convertToStr(Font font) {\n \t\treturn font.getFontName()\n-\t\t\t\t+ '-' + convertFontStyleToString(font.getStyle())\n-\t\t\t\t+ '-' + font.getSize();\n+\t\t\t\t+ '/' + convertFontStyleToString(font.getStyle())\n+\t\t\t\t+ '/' + font.getSize();\n \t}\n \n \tpublic static String convertFontStyleToString(int style) {",
    "output": "Fix correct font save with '-' in name"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeCustomNode.java b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeCustomNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeCustomNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeCustomNode.java\n@@ -20,6 +20,38 @@ public InvokeCustomNode(MethodInfo lambdaInfo, InsnData insn, boolean instanceCa\n \t\tsuper(lambdaInfo, insn, InvokeType.CUSTOM, instanceCall, isRange);\n \t}\n \n+\tprivate InvokeCustomNode(MethodInfo mth, InvokeType invokeType, int argsCount) {\n+\t\tsuper(mth, invokeType, argsCount);\n+\t}\n+\n+\t@Override\n+\tpublic InsnNode copy() {\n+\t\tInvokeCustomNode copy = new InvokeCustomNode(getCallMth(), getInvokeType(), getArgsCount());\n+\t\tcopyCommonParams(copy);\n+\t\tcopy.setImplMthInfo(implMthInfo);\n+\t\tcopy.setHandleType(handleType);\n+\t\tcopy.setCallInsn(callInsn);\n+\t\tcopy.setInlineInsn(inlineInsn);\n+\t\tcopy.setUseRef(useRef);\n+\t\treturn copy;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isSame(InsnNode obj) {\n+\t\tif (this == obj) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (!(obj instanceof InvokeCustomNode) || !super.isSame(obj)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tInvokeCustomNode other = (InvokeCustomNode) obj;\n+\t\treturn handleType == other.handleType\n+\t\t\t\t&& implMthInfo.equals(other.implMthInfo)\n+\t\t\t\t&& callInsn.isSame(other.callInsn)\n+\t\t\t\t&& inlineInsn == other.inlineInsn\n+\t\t\t\t&& useRef == other.useRef;\n+\t}\n+\n \tpublic MethodInfo getImplMthInfo() {\n \t\treturn implMthInfo;\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaInArray.java b/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaInArray.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaInArray.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/java8/TestLambdaInArray.java\n@@ -0,0 +1,40 @@\n+package jadx.tests.integration.java8;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestLambdaInArray extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic List<Function<String, Integer>> test() {\n+\t\t\treturn Arrays.asList(this::call1, this::call2);\n+\t\t}\n+\n+\t\tprivate Integer call1(String s) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprivate Integer call2(String s) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tpublic void check() throws Exception {\n+\t\t\tassertThat(test()).hasSize(2);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"return Arrays.asList(this::call1, this::call2);\");\n+\t}\n+}",
    "output": "Fix implement 'copy' and 'isSame' methods in InvokeCustomNode"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -5,6 +5,7 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.stream.Collectors;\n \n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n@@ -20,6 +21,7 @@\n import jadx.api.plugins.input.data.ILoadResult;\n import jadx.core.Jadx;\n import jadx.core.clsp.ClspGraph;\n+import jadx.core.dex.attributes.AType;\n import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.info.ConstStorage;\n import jadx.core.dex.info.FieldInfo;\n@@ -60,8 +62,8 @@ public class RootNode {\n \n \tprivate final ICodeCache codeCache;\n \n-\tprivate final List<ClassNode> classes = new ArrayList<>();\n \tprivate final Map<ClassInfo, ClassNode> clsMap = new HashMap<>();\n+\tprivate List<ClassNode> classes = new ArrayList<>();\n \n \tprivate ClspGraph clsp;\n \t@Nullable\n@@ -91,6 +93,18 @@ public void loadClasses(List<ILoadResult> loadedInputs) {\n \t\t\t\t}\n \t\t\t});\n \t\t}\n+\t\tif (classes.size() != clsMap.size()) {\n+\t\t\t// class name duplication detected\n+\t\t\tclasses.stream().collect(Collectors.groupingBy(ClassNode::getClassInfo))\n+\t\t\t\t\t.entrySet().stream()\n+\t\t\t\t\t.filter(entry -> entry.getValue().size() > 1)\n+\t\t\t\t\t.forEach(entry -> {\n+\t\t\t\t\t\tLOG.warn(\"Found duplicated class: {}, count: {}. Only one will be loaded!\", entry.getKey(),\n+\t\t\t\t\t\t\t\tentry.getValue().size());\n+\t\t\t\t\t\tentry.getValue().forEach(cls -> cls.addAttr(AType.COMMENTS, \"WARNING: Classes with same name are omitted\"));\n+\t\t\t\t\t});\n+\t\t}\n+\t\tclasses = new ArrayList<>(clsMap.values());\n \t\t// sort classes by name, expect top classes before inner\n \t\tclasses.sort(Comparator.comparing(ClassNode::getFullName));\n \t\tinitInnerClasses();\n\ndiff --git a/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java b/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n--- a/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n+++ b/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n@@ -82,9 +82,11 @@ private static void processAars(List<Path> input, ConvertResult result) {\n \t\t\t\t.filter(aarMatcher::matches)\n \t\t\t\t.forEach(path -> ZipSecurity.readZipEntries(path.toFile(), (entry, in) -> {\n \t\t\t\t\ttry {\n-\t\t\t\t\t\tif (entry.getName().endsWith(\".jar\")) {\n+\t\t\t\t\t\tString entryName = entry.getName();\n+\t\t\t\t\t\tif (entryName.endsWith(\".jar\")) {\n \t\t\t\t\t\t\tPath tempJar = saveInputStreamToFile(in, \".jar\");\n \t\t\t\t\t\t\tresult.addTempPath(tempJar);\n+\t\t\t\t\t\t\tLOG.debug(\"Loading jar: {} ...\", entryName);\n \t\t\t\t\t\t\tconvertJar(result, tempJar);\n \t\t\t\t\t\t}\n \t\t\t\t\t} catch (Exception e) {",
    "output": "Fix detect loaded class duplication"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -882,8 +882,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t\t}\n \t\t};\n \t\tbackAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"nav.back\"));\n-\t\tbackAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_LEFT,\n-\t\t\t\tUiUtils.ctrlButton() | KeyEvent.ALT_DOWN_MASK));\n+\t\tbackAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_ESCAPE, 0));\n \n \t\tAction forwardAction = new AbstractAction(NLS.str(\"nav.forward\"), ICON_FORWARD) {\n \t\t\t@Override\n@@ -892,8 +891,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t\t}\n \t\t};\n \t\tforwardAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"nav.forward\"));\n-\t\tforwardAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_RIGHT,\n-\t\t\t\tUiUtils.ctrlButton() | KeyEvent.ALT_DOWN_MASK));\n+\t\tforwardAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_RIGHT, KeyEvent.ALT_DOWN_MASK));\n \n \t\tJMenu file = new JMenu(NLS.str(\"menu.file\"));\n \t\tfile.setMnemonic(KeyEvent.VK_F);",
    "output": "Use common keyboard shortcuts for navigation"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n@@ -30,8 +30,6 @@ public abstract class AbstractCodeArea extends RSyntaxTextArea {\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(AbstractCodeArea.class);\n \n-\tpublic static final Color MARK_ALL_HIGHLIGHT_COLOR = Color.decode(\"#FFED89\");\n-\n \tprotected final ContentPanel contentPanel;\n \tprotected final JNode node;\n \n@@ -45,7 +43,6 @@ public AbstractCodeArea(ContentPanel contentPanel) {\n \t\tloadSettings();\n \t\tJadxSettings settings = contentPanel.getTabbedPane().getMainWindow().getSettings();\n \t\tsetLineWrap(settings.isCodeAreaLineWrap());\n-\t\tsetMarkAllHighlightColor(MARK_ALL_HIGHLIGHT_COLOR);\n \n \t\tJPopupMenu popupMenu = getPopupMenu();\n \t\tpopupMenu.addSeparator();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/EditorTheme.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/EditorTheme.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/EditorTheme.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/EditorTheme.java\n@@ -10,7 +10,8 @@ public final class EditorTheme {\n \t\t\t\t\tnew EditorTheme(\"idea\"),\n \t\t\t\t\tnew EditorTheme(\"vs\"),\n \t\t\t\t\tnew EditorTheme(\"dark\"),\n-\t\t\t\t\tnew EditorTheme(\"monokai\")\n+\t\t\t\t\tnew EditorTheme(\"monokai\"),\n+\t\t\t\t\tnew EditorTheme(\"druid\")\n \t\t\t};\n \n \tpublic static EditorTheme[] getAllThemes() {",
    "output": "Fix improve color schemes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -448,7 +448,7 @@ JavaNode convertNode(Object obj) {\n \t\t}\n \t\tif (obj instanceof VariableNode) {\n \t\t\tVariableNode varNode = (VariableNode) obj;\n-\t\t\treturn new JavaVariable(getJavaClassByNode(varNode.getClassNode()), varNode);\n+\t\t\treturn new JavaVariable(getJavaClassByNode(varNode.getClassNode().getTopParentClass()), varNode);\n \t\t}\n \t\tthrow new JadxRuntimeException(\"Unexpected node type: \" + obj);\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JavaVariable.java b/jadx-core/src/main/java/jadx/api/JavaVariable.java\n--- a/jadx-core/src/main/java/jadx/api/JavaVariable.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaVariable.java\n@@ -55,6 +55,9 @@ public int hashCode() {\n \n \t@Override\n \tpublic boolean equals(Object obj) {\n-\t\treturn node.equals(obj);\n+\t\tif (obj instanceof JavaVariable) {\n+\t\t\treturn node.equals(((JavaVariable) obj).getVariableNode());\n+\t\t}\n+\t\treturn false;\n \t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -92,7 +92,6 @@ public void addArg(CodeWriter code, InsnArg arg, boolean wrap) throws CodegenExc\n \t\t\tif (codeVar != null) {\n \t\t\t\tVariableNode node = mth.getVariable(codeVar.getIndex());\n \t\t\t\tif (node != null) {\n-\t\t\t\t\tnode.useVar(code, codeVar);\n \t\t\t\t\tcode.attachAnnotation(node);\n \t\t\t\t}\n \t\t\t}\n@@ -653,7 +652,6 @@ private void makeConstructor(ConstructorInsn insn, CodeWriter code) throws Codeg\n \t\tif (insn.isSuper()) {\n \t\t\tcode.add(\"super\");\n \t\t} else if (insn.isThis()) {\n-\t\t\tcode.attachAnnotation(mth.getParentClass());\n \t\t\tcode.add(\"this\");\n \t\t} else {\n \t\t\tcode.add(\"new \");\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -110,15 +110,6 @@ public VariableNode getVariable(int index) {\n \t\treturn null;\n \t}\n \n-\tpublic VariableNode getVariable(int index, VarKind varType) {\n-\t\tfor (VariableNode variable : variables) {\n-\t\t\tif (variable.getVarKind() == varType && variable.getIndex() == index) {\n-\t\t\t\treturn variable;\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n \tpublic VariableNode declareVar(VisibleVar var, NameGen nameGen, VarKind varKind) {\n \t\tif (var instanceof CodeVar) {\n \t\t\tif (((CodeVar) var).isThis()) {\n@@ -127,14 +118,11 @@ public VariableNode declareVar(VisibleVar var, NameGen nameGen, VarKind varKind)\n \t\t}\n \t\tVariableNode varNode;\n \t\tint index = var.getIndex();\n-\t\tif (index == -1) {\n+\t\tif (index > -1) {\n+\t\t\tvarNode = getVariable(var.getIndex());\n+\t\t} else {\n \t\t\tindex = variables.size();\n \t\t\tvar.setIndex(index);\n-\t\t\tvarNode = null;\n-\t\t} else {\n-\t\t\tvarNode = getVariable(var.getIndex());\n-\t\t}\n-\t\tif (varNode == null) {\n \t\t\tString name = mthInfo.getVariableName(VariableNode.makeVarIndex(index, varKind));\n \t\t\tif (name != null) {\n \t\t\t\tvar.setName(name); // set name with user renamed previously.\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/VariableNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/VariableNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/VariableNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/VariableNode.java\n@@ -1,9 +1,7 @@\n package jadx.core.dex.nodes;\n \n-import jadx.core.codegen.CodeWriter;\n import jadx.core.dex.attributes.nodes.LineAttrNode;\n import jadx.core.dex.instructions.args.ArgType;\n-import jadx.core.dex.instructions.args.CodeVar;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public class VariableNode extends LineAttrNode {\n@@ -56,17 +54,6 @@ public int getIndex() {\n \t\treturn index;\n \t}\n \n-\tpublic void addUsage(int line, int offset, int codeOffset) {\n-\t}\n-\n-\tpublic void useVar(CodeWriter code, CodeVar codeVar) {\n-\t\tif (!codeVar.isThis()) { // TODO: add usage\n-\t\t\t// IdentifierVisitor.VariableNode node = codeVar.getVariableNode();\n-\t\t\t// node.addUsage(code.getLine(), code.getOffset(), code.bufLength());\n-\t\t\t// code.attachAnnotation(node);\n-\t\t}\n-\t}\n-\n \tpublic String getRenameKey() {\n \t\treturn mth.getMethodInfo().getRawFullId() + VAR_SEPARATOR + makeVarIndex(index, varKind);\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java\n@@ -12,6 +12,9 @@\n import javax.swing.border.EmptyBorder;\n import javax.swing.event.PopupMenuEvent;\n import javax.swing.event.PopupMenuListener;\n+import javax.swing.text.BadLocationException;\n+\n+import org.fife.ui.rsyntaxtextarea.Token;\n \n import jadx.api.ICodeInfo;\n import jadx.core.utils.StringUtils;\n@@ -146,12 +149,67 @@ public JScrollPane getCodeScrollPane() {\n \t}\n \n \tpublic void refresh() {\n-\t\tJViewport viewport = getCodeScrollPane().getViewport();\n-\t\tPoint viewPosition = viewport.getViewPosition();\n+\t\tint line;\n+\t\tint lineCount;\n+\t\tint tokenIndex;\n+\t\tint pos = codeArea.getCaretPosition();\n+\t\ttry {\n+\t\t\t// after rename the change of document is undetectable, so\n+\t\t\t// use Token offset to calculate the new caret position.\n+\t\t\tline = codeArea.getLineOfOffset(pos);\n+\t\t\tToken token = codeArea.getTokenListForLine(line);\n+\t\t\ttokenIndex = getTokenIndexByOffset(token, pos);\n+\t\t} catch (BadLocationException e) {\n+\t\t\te.printStackTrace();\n+\t\t\ttokenIndex = 0;\n+\t\t\tline = codeArea.getLineCount() - 1;\n+\t\t}\n+\t\tlineCount = codeArea.getLineCount();\n \t\tcodeArea.refresh();\n \t\tinitLineNumbers();\n+\t\tint lineDiff = codeArea.getLineCount() - lineCount;\n+\t\tif (lineDiff > 0) {\n+\t\t\tlineDiff--;\n+\t\t} else if (lineDiff < 0) {\n+\t\t\tlineDiff++;\n+\t\t}\n+\t\tToken token = codeArea.getTokenListForLine(line + lineDiff);\n+\t\tint newPos = getOffsetOfTokenByIndex(tokenIndex, token);\n \t\tSwingUtilities.invokeLater(() -> {\n-\t\t\tviewport.setViewPosition(viewPosition);\n+\t\t\tif (newPos != -1) {\n+\t\t\t\tcodeArea.scrollToPos(newPos);\n+\t\t\t} else {\n+\t\t\t\tcodeArea.scrollToLine(codeArea.getLineCount() - 1);\n+\t\t\t}\n \t\t});\n \t}\n+\n+\tprivate int getTokenIndexByOffset(Token token, int offset) {\n+\t\tif (token != null) {\n+\t\t\tint index = 1;\n+\t\t\twhile (token.getEndOffset() < offset) {\n+\t\t\t\ttoken = token.getNextToken();\n+\t\t\t\tif (token == null) {\n+\t\t\t\t\tindex = 0;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tindex++;\n+\t\t\t}\n+\t\t\treturn index;\n+\t\t}\n+\t\treturn -1;\n+\t}\n+\n+\tprivate int getOffsetOfTokenByIndex(int index, Token token) {\n+\t\tif (token != null) {\n+\t\t\tfor (int i = 0; i < index; i++) {\n+\t\t\t\ttoken = token.getNextToken();\n+\t\t\t\tif (token == null) {\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn token.getOffset();\n+\t\t}\n+\t\treturn -1;\n+\t}\n }",
    "output": "Fix variable usage & caret position after rename"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -39,6 +39,7 @@\n import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.core.xmlgen.BinaryXMLParser;\n+import jadx.core.xmlgen.ResContainer;\n import jadx.core.xmlgen.ResourcesSaver;\n \n /**\n@@ -193,7 +194,23 @@ private ExecutorService getSaveExecutor(boolean saveSources, boolean saveResourc\n \t\tFile sourcesOutDir;\n \t\tFile resOutDir;\n \t\tif (args.isExportAsGradleProject()) {\n-\t\t\tExportGradleProject export = new ExportGradleProject(root, args.getOutDir());\n+\t\t\tResourceFile androidManifest = resources.stream()\n+\t\t\t\t\t.filter(resourceFile -> resourceFile.getType() == ResourceType.MANIFEST)\n+\t\t\t\t\t.findFirst()\n+\t\t\t\t\t.orElseThrow(IllegalStateException::new);\n+\n+\t\t\tResContainer strings = resources.stream()\n+\t\t\t\t\t.filter(resourceFile -> resourceFile.getType() == ResourceType.ARSC)\n+\t\t\t\t\t.findFirst()\n+\t\t\t\t\t.orElseThrow(IllegalStateException::new)\n+\t\t\t\t\t.loadContent()\n+\t\t\t\t\t.getSubFiles()\n+\t\t\t\t\t.stream()\n+\t\t\t\t\t.filter(resContainer -> resContainer.getFileName().contains(\"strings.xml\"))\n+\t\t\t\t\t.findFirst()\n+\t\t\t\t\t.orElseThrow(IllegalStateException::new);\n+\n+\t\t\tExportGradleProject export = new ExportGradleProject(root, args.getOutDir(), androidManifest, strings);\n \t\t\texport.init();\n \t\t\tsourcesOutDir = export.getSrcOutDir();\n \t\t\tresOutDir = export.getResOutDir();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/export/ApplicationParams.java b/jadx-core/src/main/java/jadx/core/export/ApplicationParams.java\n--- a/jadx-core/src/main/java/jadx/core/export/ApplicationParams.java\n+++ b/jadx-core/src/main/java/jadx/core/export/ApplicationParams.java\n@@ -0,0 +1,39 @@\n+package jadx.core.export;\n+\n+public class ApplicationParams {\n+\n+\tprivate final String applicationLabel;\n+\tprivate final Integer minSdkVersion;\n+\tprivate final Integer targetSdkVersion;\n+\tprivate final Integer versionCode;\n+\tprivate final String versionName;\n+\n+\tpublic ApplicationParams(String applicationLabel, Integer minSdkVersion, Integer targetSdkVersion, Integer versionCode,\n+\t\t\tString versionName) {\n+\t\tthis.applicationLabel = applicationLabel;\n+\t\tthis.minSdkVersion = minSdkVersion;\n+\t\tthis.targetSdkVersion = targetSdkVersion;\n+\t\tthis.versionCode = versionCode;\n+\t\tthis.versionName = versionName;\n+\t}\n+\n+\tpublic String getApplicationName() {\n+\t\treturn applicationLabel;\n+\t}\n+\n+\tpublic Integer getMinSdkVersion() {\n+\t\treturn minSdkVersion;\n+\t}\n+\n+\tpublic Integer getTargetSdkVersion() {\n+\t\treturn targetSdkVersion;\n+\t}\n+\n+\tpublic Integer getVersionCode() {\n+\t\treturn versionCode;\n+\t}\n+\n+\tpublic String getVersionName() {\n+\t\treturn versionName;\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java b/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n--- a/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n+++ b/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java\n@@ -2,18 +2,28 @@\n \n import java.io.File;\n import java.io.IOException;\n+import java.io.StringReader;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Set;\n \n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.InputSource;\n \n+import jadx.api.ResourceFile;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.core.utils.files.FileUtils;\n+import jadx.core.xmlgen.ResContainer;\n \n public class ExportGradleProject {\n \n@@ -24,39 +34,62 @@ public class ExportGradleProject {\n \t\t\t\"BuildConfig\"));\n \n \tprivate final RootNode root;\n-\tprivate final File outDir;\n+\tprivate final File projectDir;\n+\tprivate final File appDir;\n \tprivate final File srcOutDir;\n \tprivate final File resOutDir;\n+\tprivate final ApplicationParams applicationParams;\n \n-\tpublic ExportGradleProject(RootNode root, File outDir) {\n+\tpublic ExportGradleProject(RootNode root, File projectDir, ResourceFile androidManifest, ResContainer appStrings) {\n \t\tthis.root = root;\n-\t\tthis.outDir = outDir;\n-\t\tthis.srcOutDir = new File(outDir, \"src/main/java\");\n-\t\tthis.resOutDir = new File(outDir, \"src/main\");\n+\t\tthis.projectDir = projectDir;\n+\t\tthis.appDir = new File(projectDir, \"app\");\n+\t\tthis.srcOutDir = new File(appDir, \"src/main/java\");\n+\t\tthis.resOutDir = new File(appDir, \"src/main\");\n+\t\tthis.applicationParams = getApplicationParams(\n+\t\t\t\tparseAndroidManifest(androidManifest),\n+\t\t\t\tparseAppStrings(appStrings));\n \t}\n \n \tpublic void init() {\n \t\ttry {\n \t\t\tFileUtils.makeDirs(srcOutDir);\n \t\t\tFileUtils.makeDirs(resOutDir);\n-\t\t\tsaveBuildGradle();\n+\t\t\tsaveProjectBuildGradle();\n+\t\t\tsaveApplicationBuildGradle();\n+\t\t\tsaveSettingsGradle();\n \t\t\tskipGeneratedClasses();\n \t\t} catch (Exception e) {\n \t\t\tthrow new JadxRuntimeException(\"Gradle export failed\", e);\n \t\t}\n \t}\n \n-\tprivate void saveBuildGradle() throws IOException {\n+\tprivate void saveProjectBuildGradle() throws IOException {\n \t\tTemplateFile tmpl = TemplateFile.fromResources(\"/export/build.gradle.tmpl\");\n+\t\ttmpl.save(new File(projectDir, \"build.gradle\"));\n+\t}\n+\n+\tprivate void saveSettingsGradle() throws IOException {\n+\t\tTemplateFile tmpl = TemplateFile.fromResources(\"/export/settings.gradle.tmpl\");\n+\n+\t\ttmpl.add(\"applicationName\", applicationParams.getApplicationName());\n+\t\ttmpl.save(new File(projectDir, \"settings.gradle\"));\n+\t}\n+\n+\tprivate void saveApplicationBuildGradle() throws IOException {\n+\t\tTemplateFile tmpl = TemplateFile.fromResources(\"/export/app.build.gradle.tmpl\");\n \t\tString appPackage = root.getAppPackage();\n+\n \t\tif (appPackage == null) {\n \t\t\tappPackage = \"UNKNOWN\";\n \t\t}\n+\n \t\ttmpl.add(\"applicationId\", appPackage);\n-\t\t// TODO: load from AndroidManifest.xml\n-\t\ttmpl.add(\"minSdkVersion\", 9);\n-\t\ttmpl.add(\"targetSdkVersion\", 21);\n-\t\ttmpl.save(new File(outDir, \"build.gradle\"));\n+\t\ttmpl.add(\"minSdkVersion\", applicationParams.getMinSdkVersion());\n+\t\ttmpl.add(\"targetSdkVersion\", applicationParams.getTargetSdkVersion());\n+\t\ttmpl.add(\"versionCode\", applicationParams.getVersionCode());\n+\t\ttmpl.add(\"versionName\", applicationParams.getVersionName());\n+\t\ttmpl.save(new File(appDir, \"build.gradle\"));\n \t}\n \n \tprivate void skipGeneratedClasses() {\n@@ -69,6 +102,60 @@ private void skipGeneratedClasses() {\n \t\t}\n \t}\n \n+\tprivate ApplicationParams getApplicationParams(Document androidManifest, Document appStrings) {\n+\t\tElement manifest = (Element) androidManifest.getElementsByTagName(\"manifest\").item(0);\n+\t\tElement usesSdk = (Element) androidManifest.getElementsByTagName(\"uses-sdk\").item(0);\n+\t\tElement application = (Element) androidManifest.getElementsByTagName(\"application\").item(0);\n+\n+\t\tInteger versionCode = Integer.valueOf(manifest.getAttribute(\"android:versionCode\"));\n+\t\tString versionName = manifest.getAttribute(\"android:versionName\");\n+\t\tInteger minSdk = Integer.valueOf(usesSdk.getAttribute(\"android:minSdkVersion\"));\n+\t\tInteger targetSdk = Integer.valueOf(usesSdk.getAttribute(\"android:targetSdkVersion\"));\n+\t\tString appName = \"UNKNOWN\";\n+\n+\t\tString appLabelName = application.getAttribute(\"android:label\").split(\"/\")[1];\n+\t\tNodeList strings = appStrings.getElementsByTagName(\"string\");\n+\n+\t\tfor (int i = 0; i < strings.getLength(); i++) {\n+\t\t\tString stringName = strings.item(i)\n+\t\t\t\t\t.getAttributes()\n+\t\t\t\t\t.getNamedItem(\"name\")\n+\t\t\t\t\t.getNodeValue();\n+\n+\t\t\tif (stringName.equals(appLabelName)) {\n+\t\t\t\tappName = strings.item(i).getTextContent();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new ApplicationParams(appName, minSdk, targetSdk, versionCode, versionName);\n+\t}\n+\n+\tprivate Document parseXml(String xmlContent) {\n+\t\ttry {\n+\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocument document = builder.parse(new InputSource(new StringReader(xmlContent)));\n+\n+\t\t\tdocument.getDocumentElement().normalize();\n+\n+\t\t\treturn document;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new JadxRuntimeException(\"Can not parse xml content\", e);\n+\t\t}\n+\t}\n+\n+\tprivate Document parseAppStrings(ResContainer appStrings) {\n+\t\tString content = appStrings.getText().getCodeStr();\n+\n+\t\treturn parseXml(content);\n+\t}\n+\n+\tprivate Document parseAndroidManifest(ResourceFile androidManifest) {\n+\t\tString content = androidManifest.loadContent().getText().getCodeStr();\n+\n+\t\treturn parseXml(content);\n+\t}\n+\n \tpublic File getSrcOutDir() {\n \t\treturn srcOutDir;\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/functional/TemplateFileTest.java b/jadx-core/src/test/java/jadx/tests/functional/TemplateFileTest.java\n--- a/jadx-core/src/test/java/jadx/tests/functional/TemplateFileTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/functional/TemplateFileTest.java\n@@ -11,14 +11,18 @@ public class TemplateFileTest {\n \n \t@Test\n \tpublic void testBuildGradle() throws Exception {\n-\t\tTemplateFile tmpl = TemplateFile.fromResources(\"/export/build.gradle.tmpl\");\n+\t\tTemplateFile tmpl = TemplateFile.fromResources(\"/export/app.build.gradle.tmpl\");\n \t\ttmpl.add(\"applicationId\", \"SOME_ID\");\n \t\ttmpl.add(\"minSdkVersion\", 1);\n \t\ttmpl.add(\"targetSdkVersion\", 2);\n+\t\ttmpl.add(\"versionCode\", 3);\n+\t\ttmpl.add(\"versionName\", \"1.2.3\");\n \t\tString res = tmpl.build();\n \t\tSystem.out.println(res);\n \n \t\tassertThat(res, containsString(\"applicationId 'SOME_ID'\"));\n \t\tassertThat(res, containsString(\"targetSdkVersion 2\"));\n+\t\tassertThat(res, containsString(\"versionCode 3\"));\n+\t\tassertThat(res, containsString(\"versionName \\\"1.2.3\\\"\"));\n \t}\n }",
    "output": "Fix new gradle export"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/AbstractCodeArea.java\n@@ -62,7 +62,11 @@ public void actionPerformed(ActionEvent e) {\n \t\t\t\tsettings.setCodeAreaLineWrap(wrap);\n \t\t\t\tcontentPanel.getTabbedPane().getOpenTabs().values().forEach(v -> {\n \t\t\t\t\tif (v instanceof AbstractCodeContentPanel) {\n-\t\t\t\t\t\t((AbstractCodeContentPanel) v).getCodeArea().setLineWrap(wrap);\n+\t\t\t\t\t\tAbstractCodeArea codeArea = ((AbstractCodeContentPanel) v).getCodeArea();\n+\t\t\t\t\t\tcodeArea.setLineWrap(wrap);\n+\t\t\t\t\t\tif (codeArea.isVisible()) {\n+\t\t\t\t\t\t\tcodeArea.repaint();\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t});\n \t\t\t\tsettings.sync();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n@@ -1,18 +1,30 @@\n package jadx.gui.ui.codearea;\n \n-import java.awt.*;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.Shape;\n+import java.awt.Toolkit;\n import java.awt.event.MouseAdapter;\n import java.awt.event.MouseEvent;\n import java.util.Map;\n \n-import javax.swing.*;\n+import javax.swing.JPanel;\n import javax.swing.border.Border;\n import javax.swing.border.CompoundBorder;\n import javax.swing.border.EmptyBorder;\n import javax.swing.border.MatteBorder;\n import javax.swing.event.CaretEvent;\n import javax.swing.event.CaretListener;\n import javax.swing.text.Element;\n+import javax.swing.text.View;\n \n import org.fife.ui.rsyntaxtextarea.SyntaxScheme;\n import org.fife.ui.rsyntaxtextarea.Token;\n@@ -108,8 +120,8 @@ public void paintComponent(Graphics g) {\n \t\t}\n \t\tapplyRenderHints(g);\n \n-\t\tFont font = codeArea.getFont();\n-\t\tfont = font.deriveFont(font.getSize2D() - 1.0f);\n+\t\tFont baseFont = codeArea.getFont();\n+\t\tFont font = baseFont.deriveFont(baseFont.getSize2D() - 1.0f);\n \t\tg.setFont(font);\n \n \t\tDimension size = getSize();\n@@ -120,45 +132,92 @@ public void paintComponent(Graphics g) {\n \t\tInsets insets = getInsets();\n \t\tint availableWidth = size.width - insets.right;\n \n-\t\tint cellHeight = codeArea.getLineHeight();\n-\t\tint ascent = codeArea.getMaxAscent();\n-\n \t\ttextAreaInsets = codeArea.getInsets(textAreaInsets);\n \t\tif (visibleRect.y < textAreaInsets.top) {\n \t\t\tvisibleRect.height -= (textAreaInsets.top - visibleRect.y);\n \t\t\tvisibleRect.y = textAreaInsets.top;\n \t\t}\n+\t\tboolean lineWrap = codeArea.getLineWrap();\n+\t\tint cellHeight = codeArea.getLineHeight();\n+\t\tint ascent = codeArea.getMaxAscent();\n+\t\tint currentLine = codeArea.getCaretLineNumber();\n \n-\t\tint topLine = (visibleRect.y - textAreaInsets.top) / cellHeight;\n-\t\tint actualTopY = topLine * cellHeight + textAreaInsets.top;\n-\t\tint y = actualTopY + ascent;\n+\t\tint y;\n+\t\tint topLine;\n+\t\tint linesCount;\n+\t\tView parentView = null;\n+\t\tRectangle editorRect = null;\n+\t\tif (lineWrap) {\n+\t\t\tElement root = codeArea.getDocument().getDefaultRootElement();\n+\t\t\tparentView = codeArea.getUI().getRootView(codeArea).getView(0);\n+\t\t\tint topPosition = codeArea.viewToModel(new Point(visibleRect.x, visibleRect.y));\n+\t\t\ttopLine = root.getElementIndex(topPosition);\n+\t\t\tlinesCount = root.getElementCount();\n+\t\t\teditorRect = getEditorBoundingRect();\n+\t\t\tRectangle topLineBounds = getLineBounds(parentView, topLine, editorRect);\n+\t\t\tif (topLineBounds == null) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\ty = ascent + topLineBounds.y;\n+\t\t} else {\n+\t\t\tlinesCount = codeArea.getLineCount();\n+\t\t\ttopLine = (visibleRect.y - textAreaInsets.top) / cellHeight;\n+\t\t\ty = ascent + topLine * cellHeight + textAreaInsets.top;\n+\t\t}\n \t\tint endY = visibleRect.y + visibleRect.height + ascent;\n-\n-\t\tint currentLine = 1 + codeArea.getCaretLineNumber();\n-\t\tint lineNum = topLine + 1;\n-\t\tint linesCount = codeArea.getLineCount();\n+\t\tint lineNum = topLine;\n \t\tboolean isCurLine = updateColor(g, false, true);\n-\t\twhile (y < endY && lineNum <= linesCount) {\n+\t\twhile (y < endY && lineNum < linesCount) {\n \t\t\ttry {\n-\t\t\t\tString lineStr = getTextLineNumber(lineNum);\n+\t\t\t\tString lineStr = getTextLineNumber(lineNum + 1);\n \t\t\t\tif (lineStr != null) {\n \t\t\t\t\tisCurLine = updateColor(g, lineNum == currentLine, isCurLine);\n \t\t\t\t\tint x = availableWidth - fontMetrics.stringWidth(lineStr);\n \t\t\t\t\tg.drawString(lineStr, x, y);\n-\t\t\t\t} else if (!useSourceLines) {\n-\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tif (lineWrap) {\n+\t\t\t\t\tRectangle lineBounds = getLineBounds(parentView, lineNum, editorRect);\n+\t\t\t\t\tif (lineBounds == null) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t\ty += lineBounds.height;\n+\t\t\t\t} else {\n+\t\t\t\t\ty += cellHeight;\n \t\t\t\t}\n \t\t\t\tlineNum++;\n-\t\t\t\ty += cellHeight;\n \t\t\t} catch (Exception e) {\n-\t\t\t\tif (LOG.isDebugEnabled()) {\n-\t\t\t\t\tLOG.debug(\"Line numbers draw error\", e);\n-\t\t\t\t}\n+\t\t\t\tLOG.debug(\"Line numbers draw error\", e);\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t}\n \n+\tprivate Rectangle getLineBounds(View parent, int line, Rectangle editorRect) {\n+\t\tShape alloc = parent.getChildAllocation(line, editorRect);\n+\t\tif (alloc == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tif (alloc instanceof Rectangle) {\n+\t\t\treturn (Rectangle) alloc;\n+\t\t}\n+\t\treturn alloc.getBounds();\n+\t}\n+\n+\tprotected Rectangle getEditorBoundingRect() {\n+\t\tRectangle bounds = codeArea.getBounds();\n+\t\tif (bounds.width <= 0 || bounds.height <= 0) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tbounds.x = 0;\n+\t\tbounds.y = 0;\n+\t\tInsets insets = codeArea.getInsets();\n+\t\tbounds.x += insets.left;\n+\t\tbounds.y += insets.top;\n+\t\tbounds.width -= insets.left + insets.right;\n+\t\tbounds.height -= insets.top + insets.bottom;\n+\t\treturn bounds;\n+\t}\n+\n \tprivate boolean updateColor(Graphics g, boolean newCurLine, boolean oldCurLine) {\n \t\tif (oldCurLine != newCurLine) {\n \t\t\tif (newCurLine) {",
    "output": "Fix correct line numbers with enabled line wrap"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n@@ -46,7 +46,6 @@ public final class CodeArea extends AbstractCodeArea {\n \t\tCodeLinkGenerator codeLinkGenerator = new CodeLinkGenerator(this);\n \t\tsetLinkGenerator(codeLinkGenerator);\n \t\taddMouseListener(new MouseAdapter() {\n-\t\t\t@SuppressWarnings(\"deprecation\")\n \t\t\t@Override\n \t\t\tpublic void mouseClicked(MouseEvent e) {\n \t\t\t\tif (e.getClickCount() % 2 == 0 || e.isControlDown()) {\n@@ -60,6 +59,7 @@ public void mouseClicked(MouseEvent e) {\n \t\t}\n \t}\n \n+\t@SuppressWarnings(\"deprecation\")\n \tprivate void navToDecl(Point point, CodeLinkGenerator codeLinkGenerator) {\n \t\tint offs = viewToModel(point);\n \t\tJumpPosition jump = codeLinkGenerator.getJumpLinkAtOffset(CodeArea.this, offs);",
    "output": "Fix update korean translation"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/JNodeMenuAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/JNodeMenuAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/JNodeMenuAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/JNodeMenuAction.java\n@@ -36,13 +36,11 @@ public void popupMenuWillBecomeVisible(PopupMenuEvent e) {\n \n \t@Nullable\n \tprivate T getNode() {\n-\t\tPoint pos = codeArea.getMousePosition();\n-\t\tif (pos != null) {\n-\t\t\tToken token = codeArea.viewToToken(pos);\n-\t\t\tint offset = codeArea.adjustOffsetForToken(token);\n-\t\t\treturn getNodeByOffset(offset);\n-\t\t}\n-\t\treturn null;\n+\t\tPoint pos = MouseInfo.getPointerInfo().getLocation();\n+\t\tSwingUtilities.convertPointFromScreen(pos, codeArea);\n+\t\tToken token = codeArea.viewToToken(pos);\n+\t\tint offset = codeArea.adjustOffsetForToken(token);\n+\t\treturn getNodeByOffset(offset);\n \t}\n \n \t@Override",
    "output": "Fix codearea popup menu always disabled in macos"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayData.java b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayData.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayData.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayData.java\n@@ -39,6 +39,7 @@ private FillArrayData(Object data, int size, int elemSize) {\n \tprivate static ArgType getElementType(int elementWidthUnit) {\n \t\tswitch (elementWidthUnit) {\n \t\t\tcase 1:\n+\t\t\tcase 0:\n \t\t\t\treturn ONE_BYTE_TYPE;\n \t\t\tcase 2:\n \t\t\t\treturn TWO_BYTES_TYPE;\n\ndiff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java\n@@ -336,6 +336,10 @@ public void decode(DexInsnData insn, int opcodeUnit, SectionReader in) {\n \t\t\t\t\tdata = array;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n+\t\t\t\tcase 0: {\n+\t\t\t\t\tdata = new byte[0];\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new DexException(\"Unexpected element size in FILL_ARRAY_DATA_PAYLOAD: \" + elemSize);\n \t\t\t}",
    "output": "Fix elemSize=0 fill_array_data_payload insn obfuscation"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -313,7 +313,8 @@ private void preProcessClass(ClassNode cls) {\n \t\t} else {\n \t\t\tif (!clsMap.containsKey(classInfo)) {\n \t\t\t\tString clsShortName = classInfo.getShortName();\n-\t\t\t\tboolean badName = shouldRename(clsShortName) || reservedClsNames.contains(clsShortName);\n+\t\t\t\tboolean badName = shouldRename(clsShortName)\n+\t\t\t\t\t\t|| (args.isRenameValid() && reservedClsNames.contains(clsShortName));\n \t\t\t\tmakeClsAlias(cls, badName);\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -188,17 +188,20 @@ private static void checkMethods(Deobfuscator deobfuscator, ClassNode cls, JadxA\n \t\t\t\tmth.addAttr(new RenameReasonAttr(mth, notValid, notPrintable));\n \t\t\t}\n \t\t}\n-\t\tSet<String> names = new HashSet<>(methods.size());\n-\t\tfor (MethodNode mth : methods) {\n-\t\t\tAccessInfo accessFlags = mth.getAccessFlags();\n-\t\t\tif (accessFlags.isBridge() || accessFlags.isSynthetic()\n-\t\t\t\t\t|| mth.contains(AFlag.DONT_GENERATE) /* this flag not set yet */) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tString signature = mth.getMethodInfo().makeSignature(true, false);\n-\t\t\tif (!names.add(signature)) {\n-\t\t\t\tdeobfuscator.forceRenameMethod(mth);\n-\t\t\t\tmth.addAttr(new RenameReasonAttr(\"collision with other method in class\"));\n+\t\t// Rename methods with same signature\n+\t\tif (args.isRenameValid()) {\n+\t\t\tSet<String> names = new HashSet<>(methods.size());\n+\t\t\tfor (MethodNode mth : methods) {\n+\t\t\t\tAccessInfo accessFlags = mth.getAccessFlags();\n+\t\t\t\tif (accessFlags.isBridge() || accessFlags.isSynthetic()\n+\t\t\t\t\t\t|| mth.contains(AFlag.DONT_GENERATE) /* this flag not set yet */) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tString signature = mth.getMethodInfo().makeSignature(true, false);\n+\t\t\t\tif (!names.add(signature)) {\n+\t\t\t\t\tdeobfuscator.forceRenameMethod(mth);\n+\t\t\t\t\tmth.addAttr(new RenameReasonAttr(\"collision with other method in class\"));\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/deobf/a/TestNegativeRenameCondition.java b/jadx-core/src/test/java/jadx/tests/integration/deobf/a/TestNegativeRenameCondition.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/deobf/a/TestNegativeRenameCondition.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/deobf/a/TestNegativeRenameCondition.java\n@@ -0,0 +1,43 @@\n+package jadx.tests.integration.deobf.a;\n+\n+import java.util.Collections;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestNegativeRenameCondition extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\t@SuppressWarnings(\"checkstyle:TypeName\")\n+\t\tpublic interface a {\n+\n+\t\t\t@SuppressWarnings(\"checkstyle:MethodName\")\n+\t\t\tvoid a();\n+\t\t}\n+\n+\t\tpublic void test(a a) {\n+\t\t\ta.a();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tenableDeobfuscation();\n+\t\t// disable rename by length\n+\t\targs.setDeobfuscationMinLength(0);\n+\t\targs.setDeobfuscationMaxLength(999);\n+\t\t// disable all renaming options\n+\t\targs.setRenameFlags(Collections.emptySet());\n+\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"renamed from\")\n+\t\t\t\t.containsOne(\"package jadx.tests.integration.deobf.a;\")\n+\t\t\t\t.containsOne(\"public interface a {\");\n+\t}\n+}",
    "output": "Fix complete disable rename if all rename options unchecked"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -291,13 +291,15 @@ public void addFallbackMethodCode(CodeWriter code, FallbackOption fallbackOption\n \t\t\tcode.startLine(\"// Can't load method instructions.\");\n \t\t\treturn;\n \t\t}\n-\t\tlong insnCountEstimate = Stream.of(insnArr)\n-\t\t\t\t.filter(Objects::nonNull)\n-\t\t\t\t.filter(insn -> insn.getType() != InsnType.NOP)\n-\t\t\t\t.count();\n-\t\tif (insnCountEstimate > 100) {\n-\t\t\tcode.startLine(\"// Method dump skipped, instructions count: \" + insnArr.length);\n-\t\t\treturn;\n+\t\tif (fallbackOption == COMMENTED_DUMP) {\n+\t\t\tlong insnCountEstimate = Stream.of(insnArr)\n+\t\t\t\t\t.filter(Objects::nonNull)\n+\t\t\t\t\t.filter(insn -> insn.getType() != InsnType.NOP)\n+\t\t\t\t\t.count();\n+\t\t\tif (insnCountEstimate > 100) {\n+\t\t\t\tcode.startLine(\"// Method dump skipped, instructions count: \" + insnArr.length);\n+\t\t\t\treturn;\n+\t\t\t}\n \t\t}\n \t\tcode.incIndent();\n \t\tif (mth.getThisArg() != null) {",
    "output": "Fix don't skip method instructions in fallback mode"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java b/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n@@ -5,6 +5,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Predicate;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -29,6 +30,10 @@ public List<CodeNode> getUsageList() {\n \t\tpublic synchronized void addUsage(CodeNode codeNode) {\n \t\t\tusageList.add(codeNode);\n \t\t}\n+\n+\t\tpublic synchronized void removeUsageIf(Predicate<? super CodeNode> filter) {\n+\t\t\tusageList.removeIf(filter);\n+\t\t}\n \t}\n \n \tprivate final JNodeCache nodeCache;\n@@ -76,7 +81,7 @@ public void remove(JavaClass cls) {\n \t\t\tif (e.getKey().getJavaNode().getTopParentClass().equals(cls)) {\n \t\t\t\treturn true;\n \t\t\t}\n-\t\t\te.getValue().getUsageList().removeIf(node -> node.getJavaNode().getTopParentClass().equals(cls));\n+\t\t\te.getValue().removeUsageIf(node -> node.getJavaNode().getTopParentClass().equals(cls));\n \t\t\treturn false;\n \t\t});\n \t}",
    "output": "Fix synchronized conditional usageList remove method added"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/JPackagePopupMenu.java b/jadx-gui/src/main/java/jadx/gui/ui/JPackagePopupMenu.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/JPackagePopupMenu.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/JPackagePopupMenu.java\n@@ -79,7 +79,7 @@ private String concat(List<String> parts, int n) {\n \n \tprivate void rename(JPackage pkg) {\n \t\tLOG.debug(\"Renaming package: fullName={}, name={}\", pkg.getFullName(), pkg.getName());\n-\t\tnew RenameDialog(mainWindow, pkg).setVisible(true);\n+\t\tRenameDialog.rename(mainWindow, pkg);\n \t}\n \n \tprivate List<String> splitPackage(String rawPackage) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -655,8 +655,7 @@ private void nodeClickAction(@Nullable Object obj) {\n \t}\n \n \tprivate void rename(JNode node) {\n-\t\tRenameDialog renameDialog = new RenameDialog(this, node);\n-\t\trenameDialog.setVisible(true);\n+\t\tRenameDialog.rename(this, node);\n \t}\n \n \tprivate void treeRightClickAction(MouseEvent e) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n@@ -1,9 +1,12 @@\n package jadx.gui.ui;\n \n-import java.awt.*;\n+import java.awt.BorderLayout;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.Writer;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n@@ -15,7 +18,17 @@\n import java.util.Set;\n import java.util.stream.Collectors;\n \n-import javax.swing.*;\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.BoxLayout;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JLabel;\n+import javax.swing.JOptionPane;\n+import javax.swing.JPanel;\n+import javax.swing.JTextField;\n+import javax.swing.SwingConstants;\n+import javax.swing.WindowConstants;\n \n import org.jetbrains.annotations.NotNull;\n import org.slf4j.Logger;\n@@ -57,17 +70,24 @@ public class RenameDialog extends JDialog {\n \tprivate final transient JNode node;\n \tprivate transient JTextField renameField;\n \n-\tpublic RenameDialog(MainWindow mainWindow, JNode node) {\n+\tpublic static boolean rename(MainWindow mainWindow, JNode node) {\n+\t\tif (!checkSettings(mainWindow)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tRenameDialog renameDialog = new RenameDialog(mainWindow, node);\n+\t\trenameDialog.setVisible(true);\n+\t\treturn true;\n+\t}\n+\n+\tprivate RenameDialog(MainWindow mainWindow, JNode node) {\n \t\tsuper(mainWindow);\n \t\tthis.mainWindow = mainWindow;\n \t\tthis.cache = mainWindow.getCacheObject();\n \t\tthis.node = node;\n-\t\tif (checkSettings()) {\n-\t\t\tinitUI();\n-\t\t}\n+\t\tinitUI();\n \t}\n \n-\tprivate boolean checkSettings() {\n+\tpublic static boolean checkSettings(MainWindow mainWindow) {\n \t\tStringBuilder errorMessage = new StringBuilder();\n \t\terrorMessage.append(NLS.str(\"msg.rename_disabled\")).append(CodeWriter.NL);\n \n@@ -143,19 +163,17 @@ private void writeDeobfMapFile(Path deobfMapPath, List<String> deobfMap) throws\n \t\t\tLOG.error(\"updateDeobfMapFile(): deobfMapPath is null!\");\n \t\t\treturn;\n \t\t}\n-\t\tFile tmpFile = File.createTempFile(\"deobf_tmp_\", \".txt\");\n-\t\ttry (FileOutputStream fileOut = new FileOutputStream(tmpFile)) {\n+\t\tPath deobfMapDir = deobfMapPath.getParent();\n+\t\tPath tmpFile = Files.createTempFile(deobfMapDir, \"deobf_tmp_\", \".txt\");\n+\n+\t\ttry (Writer writer = Files.newBufferedWriter(tmpFile, StandardCharsets.UTF_8)) {\n \t\t\tfor (String entry : deobfMap) {\n-\t\t\t\tfileOut.write(entry.getBytes(StandardCharsets.UTF_8));\n-\t\t\t\tfileOut.write(System.lineSeparator().getBytes(StandardCharsets.UTF_8));\n+\t\t\t\twriter.write(entry);\n+\t\t\t\twriter.write(System.lineSeparator());\n \t\t\t}\n \t\t}\n-\t\tFile oldMap = File.createTempFile(\"deobf_bak_\", \".txt\");\n-\t\tFiles.copy(deobfMapPath, oldMap.toPath(), StandardCopyOption.REPLACE_EXISTING);\n-\t\tLOG.trace(\"Copying \" + tmpFile.toPath() + \" to \" + deobfMapPath);\n-\t\tFiles.copy(tmpFile.toPath(), deobfMapPath, StandardCopyOption.REPLACE_EXISTING);\n-\t\tFiles.delete(oldMap.toPath());\n-\t\tFiles.delete(tmpFile.toPath());\n+\t\tFiles.move(tmpFile, deobfMapPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);\n+\t\tLOG.info(\"Updated deobf file {}\", deobfMapPath);\n \t}\n \n \t@NotNull\n@@ -167,14 +185,15 @@ private List<String> updateDeobfMap(List<String> deobfMap, String alias) {\n \t\tString id = alias.substring(0, alias.indexOf('=') + 1);\n \t\tint i = 0;\n \t\twhile (i < deobfMap.size()) {\n-\t\t\tif (deobfMap.get(i).startsWith(id)) {\n-\t\t\t\tLOG.debug(\"updateDeobfMap(): Removing entry {}\", deobfMap.get(i));\n+\t\t\tString entry = deobfMap.get(i);\n+\t\t\tif (entry.startsWith(id)) {\n+\t\t\t\tLOG.debug(\"updateDeobfMap(): Removing entry {}\", entry);\n \t\t\t\tdeobfMap.remove(i);\n \t\t\t} else {\n \t\t\t\ti++;\n \t\t\t}\n \t\t}\n-\t\tLOG.debug(\"updateDeobfMap(): Placing alias = {}\", alias);\n+\t\tLOG.debug(\"updateDeobfMap(): placing alias = {}\", alias);\n \t\tdeobfMap.add(alias);\n \t\treturn deobfMap;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java\n@@ -33,8 +33,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t\tLOG.info(\"node == null!\");\n \t\t\treturn;\n \t\t}\n-\t\tRenameDialog renameDialog = new RenameDialog(codeArea.getMainWindow(), node);\n-\t\trenameDialog.setVisible(true);\n+\t\tRenameDialog.rename(codeArea.getMainWindow(), node);\n \t}\n \n \t@Nullable",
    "output": "Fix do not show empty rename dialog if user chooses not to change DeobfuscationForceSave settings"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -150,6 +150,7 @@ private void initUI() {\n \n \t\tContainer contentPane = getContentPane();\n \t\tJScrollPane scrollPane = new JScrollPane(panel);\n+\t\tscrollPane.getVerticalScrollBar().setUnitIncrement(16);\n \t\tscrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n \t\tcontentPane.add(scrollPane, BorderLayout.CENTER);\n \t\tcontentPane.add(buttonPane, BorderLayout.PAGE_END);",
    "output": "Fix increase settings vertical scroll increment"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -7,6 +7,7 @@\n import java.util.List;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import org.slf4j.Logger;\n@@ -27,7 +28,7 @@\n public class ResTableParser extends CommonBinaryParser {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ResTableParser.class);\n \n-\tprivate static final Pattern VALID_RES_KEY_PATTERN = Pattern.compile(\"\\\\$+[\\\\w\\\\d-_.]+\");\n+\tprivate static final Pattern VALID_RES_KEY_PATTERN = Pattern.compile(\"[\\\\w\\\\d_]+\");\n \n \tprivate static final class PackageChunk {\n \t\tprivate final int id;\n@@ -315,7 +316,24 @@ private String getResName(int resRef, String origKeyName) {\n \t\t\tconstField.add(AFlag.DONT_RENAME);\n \t\t\treturn constField.getName();\n \t\t}\n-\t\treturn \"RES_\" + resRef; // autogenerate key name\n+\t\t// Making sure origKeyName compliant with resource file name rules\n+\t\tMatcher m = VALID_RES_KEY_PATTERN.matcher(origKeyName);\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tboolean first = true;\n+\t\twhile (m.find()) {\n+\t\t\tif (!first) {\n+\t\t\t\tsb.append(\"_\");\n+\t\t\t}\n+\t\t\tsb.append(m.group());\n+\t\t\tfirst = false;\n+\t\t}\n+\t\t// autogenerate key name, appended with cleaned origKeyName to be human-friendly\n+\t\tString newResName = \"res_\" + resRef;\n+\t\tString cleanedResName = sb.toString();\n+\t\tif (!cleanedResName.isEmpty()) {\n+\t\t\tnewResName += \"_\" + cleanedResName.toLowerCase();\n+\t\t}\n+\t\treturn newResName;\n \t}\n \n \tprivate RawNamedValue parseValueMap() throws IOException {",
    "output": "Use lowercase for resource filename and only use underscore for compatibility with newer android studio (#1043, PR #1057)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfoVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfoVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfoVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfoVisitor.java\n@@ -6,6 +6,8 @@\n import jadx.api.plugins.input.data.ICodeReader;\n import jadx.api.plugins.input.insns.InsnData;\n import jadx.api.plugins.input.insns.Opcode;\n+import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.attributes.nodes.MethodOverrideAttr;\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.instructions.args.ArgType;\n@@ -15,12 +17,14 @@\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.visitors.AbstractVisitor;\n import jadx.core.dex.visitors.JadxVisitor;\n+import jadx.core.dex.visitors.OverrideMethodVisitor;\n import jadx.core.dex.visitors.RenameVisitor;\n \n @JadxVisitor(\n \t\tname = \"UsageInfoVisitor\",\n \t\tdesc = \"Scan class and methods to collect usage info and class dependencies\",\n \t\trunAfter = {\n+\t\t\t\tOverrideMethodVisitor.class, // add method override as use\n \t\t\t\tRenameVisitor.class // sort by alias name\n \t\t}\n )\n@@ -63,6 +67,12 @@ private static void processMethod(MethodNode mth, UsageInfo usageInfo) {\n \t\t} catch (Exception e) {\n \t\t\tmth.addError(\"Dependency scan failed\", e);\n \t\t}\n+\t\tMethodOverrideAttr overrideAttr = mth.get(AType.METHOD_OVERRIDE);\n+\t\tif (overrideAttr != null) {\n+\t\t\tfor (MethodNode relatedMthNode : overrideAttr.getRelatedMthNodes()) {\n+\t\t\t\tusageInfo.methodUse(relatedMthNode, mth);\n+\t\t\t}\n+\t\t}\n \t}\n \n \tprivate static void processInstructions(MethodNode mth, UsageInfo usageInfo) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java\n@@ -10,6 +10,7 @@\n import jadx.api.JavaField;\n import jadx.api.JavaMethod;\n import jadx.api.JavaNode;\n+import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.info.AccessInfo;\n import jadx.gui.utils.NLS;\n import jadx.gui.utils.UiUtils;\n@@ -50,6 +51,11 @@ public void loadNode() {\n \t\tgetRootClass().load();\n \t}\n \n+\t@Override\n+\tpublic boolean canRename() {\n+\t\treturn !cls.getClassNode().contains(AFlag.DONT_RENAME);\n+\t}\n+\n \tpublic synchronized void load() {\n \t\tif (!loaded) {\n \t\t\tcls.decompile();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JField.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JField.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JField.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JField.java\n@@ -5,6 +5,7 @@\n \n import jadx.api.JavaField;\n import jadx.api.JavaNode;\n+import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.info.AccessInfo;\n import jadx.gui.utils.OverlayIcon;\n import jadx.gui.utils.UiUtils;\n@@ -43,6 +44,11 @@ public JClass getRootClass() {\n \t\treturn jParent.getRootClass();\n \t}\n \n+\t@Override\n+\tpublic boolean canRename() {\n+\t\treturn !field.getFieldNode().contains(AFlag.DONT_RENAME);\n+\t}\n+\n \t@Override\n \tpublic int getLine() {\n \t\treturn field.getDecompiledLine();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JMethod.java\n@@ -7,6 +7,7 @@\n \n import jadx.api.JavaMethod;\n import jadx.api.JavaNode;\n+import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.gui.utils.OverlayIcon;\n@@ -68,6 +69,11 @@ public Icon getIcon() {\n \t\treturn icon;\n \t}\n \n+\t@Override\n+\tpublic boolean canRename() {\n+\t\treturn !mth.getMethodNode().contains(AFlag.DONT_RENAME);\n+\t}\n+\n \tString makeBaseString() {\n \t\tif (mth.isClassInit()) {\n \t\t\treturn \"{...}\";\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n@@ -75,6 +75,10 @@ public String getName() {\n \t\treturn javaNode.getName();\n \t}\n \n+\tpublic boolean canRename() {\n+\t\treturn false;\n+\t}\n+\n \tpublic abstract String makeString();\n \n \tpublic String makeStringHtml() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java\n@@ -74,6 +74,11 @@ public String getName() {\n \t\treturn name;\n \t}\n \n+\t@Override\n+\tpublic boolean canRename() {\n+\t\treturn true;\n+\t}\n+\n \tpublic String getFullName() {\n \t\treturn fullName;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n@@ -26,6 +26,9 @@\n import jadx.api.JavaMethod;\n import jadx.api.JavaNode;\n import jadx.core.codegen.CodeWriter;\n+import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.attributes.nodes.MethodOverrideAttr;\n+import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.visitors.RenameVisitor;\n import jadx.core.utils.Utils;\n@@ -113,7 +116,13 @@ private String getNodeAlias(String renameText) {\n \t\tif (node instanceof JMethod) {\n \t\t\tJavaMethod javaMethod = (JavaMethod) node.getJavaNode();\n \t\t\ttype = \"m\";\n-\t\t\tid = javaMethod.getMethodNode().getMethodInfo().getRawFullId();\n+\t\t\tMethodNode mthNode = javaMethod.getMethodNode();\n+\t\t\tMethodOverrideAttr overrideAttr = mthNode.get(AType.METHOD_OVERRIDE);\n+\t\t\tif (overrideAttr != null) {\n+\t\t\t\t// use method closest to base method\n+\t\t\t\tmthNode = Objects.requireNonNull(Utils.last(overrideAttr.getRelatedMthNodes()));\n+\t\t\t}\n+\t\t\tid = mthNode.getMethodInfo().getRawFullId();\n \t\t} else if (node instanceof JField) {\n \t\t\tJavaField javaField = (JavaField) node.getJavaNode();\n \t\t\ttype = \"f\";\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeLinkGenerator.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeLinkGenerator.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeLinkGenerator.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeLinkGenerator.java\n@@ -13,6 +13,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.api.JavaNode;\n import jadx.gui.treemodel.JNode;\n import jadx.gui.utils.JumpPosition;\n \n@@ -27,6 +28,22 @@ public CodeLinkGenerator(CodeArea codeArea) {\n \t\tthis.jNode = codeArea.getNode();\n \t}\n \n+\tpublic JavaNode getNodeAtOffset(RSyntaxTextArea textArea, int offset) {\n+\t\ttry {\n+\t\t\tif (jNode.getCodeInfo() == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tint sourceOffset = getLinkSourceOffset(textArea, offset);\n+\t\t\tif (sourceOffset == -1) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn codeArea.getJavaNodeAtOffset(offset);\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"getNodeAtOffset error\", e);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n \t@Nullable\n \tpublic JumpPosition getJumpLinkAtOffset(RSyntaxTextArea textArea, int offset) {\n \t\ttry {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java\n@@ -11,7 +11,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import jadx.gui.utils.JumpPosition;\n+import jadx.api.JavaNode;\n \n class MouseHoverHighlighter extends MouseMotionAdapter {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(MouseHoverHighlighter.class);\n@@ -50,8 +50,8 @@ private boolean addHighlight(MouseEvent e) {\n \t\t\t\t// don't repaint highlight\n \t\t\t\treturn true;\n \t\t\t}\n-\t\t\tJumpPosition jump = codeLinkGenerator.getJumpLinkAtOffset(codeArea, tokenOffset);\n-\t\t\tif (jump == null) {\n+\t\t\tJavaNode nodeAtOffset = codeLinkGenerator.getNodeAtOffset(codeArea, tokenOffset);\n+\t\t\tif (nodeAtOffset == null) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\tremoveHighlight();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/RenameAction.java\n@@ -2,6 +2,8 @@\n \n import java.awt.event.ActionEvent;\n \n+import javax.swing.event.PopupMenuEvent;\n+\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -19,6 +21,12 @@ public RenameAction(CodeArea codeArea) {\n \t\tsuper(NLS.str(\"popup.rename\"), codeArea);\n \t}\n \n+\t@Override\n+\tpublic void popupMenuWillBecomeVisible(PopupMenuEvent e) {\n+\t\tsuper.popupMenuWillBecomeVisible(e);\n+\t\tsetEnabled(node != null && node.canRename());\n+\t}\n+\n \t@Override\n \tpublic void actionPerformed(ActionEvent e) {\n \t\tif (node == null) {",
    "output": "Fix improve rename for overridden methods"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java b/jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java\n@@ -23,7 +23,7 @@ public synchronized void put(CodeNode value) {\n \t\tvalues.add(value);\n \t}\n \n-\tpublic void removeForCls(JavaClass cls) {\n+\tpublic synchronized void removeForCls(JavaClass cls) {\n \t\tvalues.removeIf(v -> v.getJavaNode().getTopParentClass().equals(cls));\n \t}",
    "output": "Fix prevent NullPointerException and ConcurrentModificationException when renaming something"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -53,7 +53,7 @@\n @JadxVisitor(\n \t\tname = \"EnumVisitor\",\n \t\tdesc = \"Restore enum classes\",\n-\t\trunAfter = { CodeShrinkVisitor.class, ModVisitor.class },\n+\t\trunAfter = { CodeShrinkVisitor.class, ModVisitor.class, ReSugarCode.class },\n \t\trunBefore = { ExtractFieldInit.class }\n )\n public class EnumVisitor extends AbstractVisitor {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n@@ -91,11 +91,11 @@ private static boolean process(MethodNode mth, List<InsnNode> instructions, int\n \t */\n \tprivate static boolean processNewArray(MethodNode mth, NewArrayNode newArrayInsn,\n \t\t\tList<InsnNode> instructions, InsnRemover remover) {\n-\t\tInsnArg arrLenArg = newArrayInsn.getArg(0);\n-\t\tif (!arrLenArg.isLiteral()) {\n+\t\tObject arrayLenConst = InsnUtils.getConstValueByArg(mth.root(), newArrayInsn.getArg(0));\n+\t\tif (!(arrayLenConst instanceof LiteralArg)) {\n \t\t\treturn false;\n \t\t}\n-\t\tint len = (int) ((LiteralArg) arrLenArg).getLiteral();\n+\t\tint len = (int) ((LiteralArg) arrayLenConst).getLiteral();\n \t\tif (len == 0) {\n \t\t\treturn false;\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumWithConstInlining.java b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumWithConstInlining.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumWithConstInlining.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumWithConstInlining.java\n@@ -0,0 +1,128 @@\n+package jadx.tests.integration.enums;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestEnumWithConstInlining extends SmaliTest {\n+\tenum TestCls {\n+\t\tE0,\n+\t\tE1,\n+\t\tE2,\n+\t\tE3,\n+\t\tE4,\n+\t\tE5,\n+\t\tE6,\n+\t\tE7,\n+\t\tE8,\n+\t\tE9,\n+\t\tE10,\n+\t\tE11,\n+\t\tE12,\n+\t\tE13,\n+\t\tE14,\n+\t\tE15,\n+\t\tE16,\n+\t\tE17,\n+\t\tE18,\n+\t\tE19,\n+\t\tE20,\n+\t\tE21,\n+\t\tE22,\n+\t\tE23,\n+\t\tE24,\n+\t\tE25,\n+\t\tE26,\n+\t\tE27,\n+\t\tE28,\n+\t\tE29,\n+\t\tE30,\n+\t\tE31,\n+\t\tE32,\n+\t\tE33,\n+\t\tE34,\n+\t\tE35,\n+\t\tE36,\n+\t\tE37,\n+\t\tE38,\n+\t\tE39,\n+\t\tE40,\n+\t\tE41,\n+\t\tE42,\n+\t\tE43,\n+\t\tE44,\n+\t\tE45,\n+\t\tE46,\n+\t\tE47,\n+\t\tE48,\n+\t\tE49,\n+\t\tE50,\n+\t\tE51,\n+\t\tE52,\n+\t\tE53,\n+\t\tE54,\n+\t\tE55,\n+\t\tE56,\n+\t\tE57,\n+\t\tE58,\n+\t\tE59,\n+\t\tE60,\n+\t\tE61,\n+\t\tE62,\n+\t\tE63,\n+\t\tE64,\n+\t\tE65,\n+\t\tE66,\n+\t\tE67,\n+\t\tE68,\n+\t\tE69,\n+\t\tE70,\n+\t\tE71,\n+\t\tE72,\n+\t\tE73,\n+\t\tE74,\n+\t\tE75,\n+\t\tE76,\n+\t\tE77,\n+\t\tE78,\n+\t\tE79,\n+\t\tE80,\n+\t\tE81,\n+\t\tE82,\n+\t\tE83,\n+\t\tE84,\n+\t\tE85,\n+\t\tE86,\n+\t\tE87,\n+\t\tE88,\n+\t\tE89,\n+\t\tE90,\n+\t\tE91,\n+\t\tE92,\n+\t\tE93,\n+\t\tE94,\n+\t\tE95,\n+\t\tE96,\n+\t\tE97,\n+\t\tE98,\n+\t\tE99,\n+\t\tE100;\n+\n+\t\t/**\n+\t\t * Match the length of the $VALUES array.\n+\t\t */\n+\t\tpublic static final int CONST = 101;\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"E42,\"));\n+\t}\n+}",
    "output": "Fix properly transform array creation with constant field length to filled-array"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n@@ -4,8 +4,6 @@\n import java.util.stream.Collectors;\n \n import org.jetbrains.annotations.Nullable;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n@@ -44,8 +42,6 @@\n )\n public class ReSugarCode extends AbstractVisitor {\n \n-\tprivate static final Logger LOG = LoggerFactory.getLogger(ReSugarCode.class);\n-\n \t@Override\n \tpublic boolean visit(ClassNode cls) throws JadxException {\n \t\tinitClsEnumMap(cls);\n@@ -57,55 +53,57 @@ public void visit(MethodNode mth) throws JadxException {\n \t\tif (mth.isNoCode()) {\n \t\t\treturn;\n \t\t}\n+\t\tboolean changed = false;\n \t\tInsnRemover remover = new InsnRemover(mth);\n \t\tfor (BlockNode block : mth.getBasicBlocks()) {\n \t\t\tremover.setBlock(block);\n \t\t\tList<InsnNode> instructions = block.getInstructions();\n \t\t\tint size = instructions.size();\n \t\t\tfor (int i = 0; i < size; i++) {\n-\t\t\t\tprocess(mth, instructions, i, remover);\n+\t\t\t\tchanged |= process(mth, instructions, i, remover);\n \t\t\t}\n \t\t\tremover.perform();\n \t\t}\n+\t\tif (changed) {\n+\t\t\tCodeShrinkVisitor.shrinkMethod(mth);\n+\t\t}\n \t}\n \n-\tprivate static void process(MethodNode mth, List<InsnNode> instructions, int i, InsnRemover remover) {\n+\tprivate static boolean process(MethodNode mth, List<InsnNode> instructions, int i, InsnRemover remover) {\n \t\tInsnNode insn = instructions.get(i);\n \t\tif (insn.contains(AFlag.REMOVE)) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tswitch (insn.getType()) {\n \t\t\tcase NEW_ARRAY:\n-\t\t\t\tprocessNewArray(mth, (NewArrayNode) insn, instructions, remover);\n-\t\t\t\tbreak;\n+\t\t\t\treturn processNewArray(mth, (NewArrayNode) insn, instructions, remover);\n \n \t\t\tcase SWITCH:\n-\t\t\t\tprocessEnumSwitch(mth, (SwitchInsn) insn);\n-\t\t\t\tbreak;\n+\t\t\t\treturn processEnumSwitch(mth, (SwitchInsn) insn);\n \n \t\t\tdefault:\n-\t\t\t\tbreak;\n+\t\t\t\treturn false;\n \t\t}\n \t}\n \n \t/**\n \t * Replace new-array and sequence of array-put to new filled-array instruction.\n \t */\n-\tprivate static void processNewArray(MethodNode mth, NewArrayNode newArrayInsn,\n+\tprivate static boolean processNewArray(MethodNode mth, NewArrayNode newArrayInsn,\n \t\t\tList<InsnNode> instructions, InsnRemover remover) {\n \t\tInsnArg arrLenArg = newArrayInsn.getArg(0);\n \t\tif (!arrLenArg.isLiteral()) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tint len = (int) ((LiteralArg) arrLenArg).getLiteral();\n \t\tif (len == 0) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tRegisterArg arrArg = newArrayInsn.getResult();\n \t\tSSAVar ssaVar = arrArg.getSVar();\n \t\tList<RegisterArg> useList = ssaVar.getUseList();\n \t\tif (useList.size() < len) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\t// check sequential array put with increasing index\n \t\tint putIndex = 0;\n@@ -118,17 +116,15 @@ private static void processNewArray(MethodNode mth, NewArrayNode newArrayInsn,\n \t\t\t}\n \t\t}\n \t\tif (putIndex != len) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tList<InsnNode> arrPuts = useList.subList(0, len).stream().map(InsnArg::getParentInsn).collect(Collectors.toList());\n \t\t// check that all puts in current block\n \t\tfor (InsnNode arrPut : arrPuts) {\n \t\t\tint index = InsnList.getIndex(instructions, arrPut);\n \t\t\tif (index == -1) {\n-\t\t\t\tif (LOG.isDebugEnabled()) {\n-\t\t\t\t\tLOG.debug(\"TODO: APUT found in different block: {}, mth: {}\", arrPut, mth);\n-\t\t\t\t}\n-\t\t\t\treturn;\n+\t\t\t\tmth.addDebugComment(\"Can't convert new array creation: APUT found in different block: \" + arrPut);\n+\t\t\t\treturn false;\n \t\t\t}\n \t\t}\n \n@@ -146,6 +142,7 @@ private static void processNewArray(MethodNode mth, NewArrayNode newArrayInsn,\n \t\tInsnNode lastPut = Utils.last(arrPuts);\n \t\tint replaceIndex = InsnList.getIndex(instructions, lastPut);\n \t\tinstructions.set(replaceIndex, filledArr);\n+\t\treturn true;\n \t}\n \n \tprivate static boolean checkPutInsn(MethodNode mth, InsnNode insn, RegisterArg arrArg, int putIndex) {\n@@ -164,43 +161,44 @@ private static boolean checkPutInsn(MethodNode mth, InsnNode insn, RegisterArg a\n \t\treturn false;\n \t}\n \n-\tprivate static void processEnumSwitch(MethodNode mth, SwitchInsn insn) {\n+\tprivate static boolean processEnumSwitch(MethodNode mth, SwitchInsn insn) {\n \t\tInsnArg arg = insn.getArg(0);\n \t\tif (!arg.isInsnWrap()) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tInsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();\n \t\tif (wrapInsn.getType() != InsnType.AGET) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tEnumMapInfo enumMapInfo = checkEnumMapAccess(mth.root(), wrapInsn);\n \t\tif (enumMapInfo == null) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tFieldNode enumMapField = enumMapInfo.getMapField();\n \t\tInsnArg invArg = enumMapInfo.getArg();\n \n \t\tEnumMapAttr.KeyValueMap valueMap = getEnumMap(mth, enumMapField);\n \t\tif (valueMap == null) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tint caseCount = insn.getKeys().length;\n \t\tfor (int i = 0; i < caseCount; i++) {\n \t\t\tObject key = insn.getKey(i);\n \t\t\tObject newKey = valueMap.get(key);\n \t\t\tif (newKey == null) {\n-\t\t\t\treturn;\n+\t\t\t\treturn false;\n \t\t\t}\n \t\t}\n \t\t// replace confirmed\n \t\tif (!insn.replaceArg(arg, invArg)) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tfor (int i = 0; i < caseCount; i++) {\n \t\t\tinsn.modifyKey(i, valueMap.get(insn.getKey(i)));\n \t\t}\n \t\tenumMapField.add(AFlag.DONT_GENERATE);\n \t\tcheckAndHideClass(enumMapField.getParentClass());\n+\t\treturn true;\n \t}\n \n \tprivate static void initClsEnumMap(ClassNode enumCls) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestVarArg2.java b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestVarArg2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestVarArg2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestVarArg2.java\n@@ -0,0 +1,27 @@\n+package jadx.tests.integration.invoke;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestVarArg2 extends IntegrationTest {\n+\n+\t@SuppressWarnings(\"ConstantConditions\")\n+\tpublic static class TestCls {\n+\t\tprotected static boolean b1;\n+\t\tprotected static final boolean IS_VALID = b1 && isValid(\"test\");\n+\n+\t\tprivate static boolean isValid(String... string) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"isValid(\\\"test\\\")\"); // TODO: .containsOne(\"b1 && isValid(\\\"test\\\")\");\n+\t}\n+}",
    "output": "Fix force code inline after new array creation resugar"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java b/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java\n@@ -7,6 +7,7 @@\n import org.slf4j.LoggerFactory;\n \n import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.MethodInlineAttr;\n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.instructions.InsnType;\n@@ -16,6 +17,7 @@\n import jadx.core.dex.instructions.args.RegisterArg;\n import jadx.core.dex.instructions.args.SSAVar;\n import jadx.core.dex.nodes.BlockNode;\n+import jadx.core.dex.nodes.IMethodDetails;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;\n@@ -103,9 +105,14 @@ private void inlineMethod(MethodNode mth, MethodNode callMth, MethodInlineAttr m\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tIMethodDetails methodDetailsAttr = inlCopy.get(AType.METHOD_DETAILS);\n \t\tif (!BlockUtils.replaceInsn(mth, block, insn, inlCopy)) {\n \t\t\tmth.addWarnComment(\"Failed to inline method: \" + callMth);\n \t\t}\n+\t\t// replaceInsn replaces the attributes as well, make sure to preserve METHOD_DETAILS\n+\t\tif (methodDetailsAttr != null) {\n+\t\t\tinlCopy.addAttr(methodDetailsAttr);\n+\t\t}\n \t}\n \n \tprivate boolean isAssignNeeded(InsnNode inlineInsn, InvokeNode parentInsn, MethodNode callMthNode) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedAccessor.java b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedAccessor.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedAccessor.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedAccessor.java\n@@ -0,0 +1,41 @@\n+package jadx.tests.integration.invoke;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestCastInOverloadedAccessor extends SmaliTest {\n+\tstatic class X {\n+\t\tvoid test() {\n+\t\t\tnew Runnable() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void run() {\n+\t\t\t\t\touterMethod(\"\");\n+\t\t\t\t\touterMethod(\"\", \"\");\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\n+\t\tprivate void outerMethod(String s) {\n+\t\t}\n+\n+\t\tprivate void outerMethod(String s, String t) {\n+\t\t}\n+\n+\t\tprivate void outerMethod(int a) {\n+\t\t}\n+\n+\t\tprivate void outerMethod(int a, int b) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tString code = getClassNode(X.class).getCode().getCodeStr();\n+\t\tassertThat(code, containsOne(\"outerMethod(\\\"\\\")\"));\n+\t\tassertThat(code, containsOne(\"outerMethod(\\\"\\\", \\\"\\\")\"));\n+\t}\n+}",
    "output": "Fix preserve original method details in inlined invocation"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -16,6 +16,7 @@\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.annotations.MethodParameters;\n+import jadx.core.dex.attributes.nodes.JadxError;\n import jadx.core.dex.attributes.nodes.JumpInfo;\n import jadx.core.dex.attributes.nodes.MethodOverrideAttr;\n import jadx.core.dex.info.AccessInfo;\n@@ -323,6 +324,12 @@ public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[]\n \t\t\tif (insn == null) {\n \t\t\t\tcontinue;\n \t\t\t}\n+\t\t\tif (insn.contains(AType.JADX_ERROR)) {\n+\t\t\t\tfor (JadxError error : insn.getAll(AType.JADX_ERROR)) {\n+\t\t\t\t\tcode.startLine(\"// \").add(error.getError());\n+\t\t\t\t}\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tif (option != BLOCK_DUMP && needLabel(insn, prevInsn)) {\n \t\t\t\tcode.decIndent();\n \t\t\t\tcode.startLine(getLabelName(insn.getOffset()) + ':');\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n@@ -9,6 +9,8 @@\n import jadx.api.plugins.input.insns.custom.IArrayPayload;\n import jadx.api.plugins.input.insns.custom.ISwitchPayload;\n import jadx.core.Consts;\n+import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.attributes.nodes.JadxError;\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.instructions.args.ArgType;\n@@ -40,11 +42,12 @@ public InsnNode[] process(ICodeReader codeReader) {\n \t\t\ttry {\n \t\t\t\trawInsn.decode();\n \t\t\t\tinsn = decode(rawInsn);\n-\t\t\t\tinsn.setOffset(offset);\n \t\t\t} catch (Exception e) {\n-\t\t\t\tLOG.error(\"Failed to decode insn: \" + rawInsn + \", method: \" + method, e);\n+\t\t\t\tmethod.addError(\"Failed to decode insn: \" + rawInsn + \", method: \" + method, e);\n \t\t\t\tinsn = new InsnNode(InsnType.NOP, 0);\n+\t\t\t\tinsn.addAttr(AType.JADX_ERROR, new JadxError(\"decode failed: \" + e.getMessage(), e));\n \t\t\t}\n+\t\t\tinsn.setOffset(offset);\n \t\t\tinstructions[offset] = insn;\n \t\t});\n \t\treturn instructions;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/Utils.java b/jadx-core/src/main/java/jadx/core/utils/Utils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/Utils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java\n@@ -182,6 +182,17 @@ private static void filter(Throwable th) {\n \t\t\t}\n \t\t\tprevElement = stackTraceElement;\n \t\t}\n+\t\t// stop condition not found -> just cut tail to any jadx class\n+\t\tfor (int i = length - 1; i >= 0; i--) {\n+\t\t\tString clsName = stackTrace[i].getClassName();\n+\t\t\tif (clsName.startsWith(\"jadx.\")) {\n+\t\t\t\tif (clsName.startsWith(\"jadx.tests.\")) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tth.setStackTrace(Arrays.copyOfRange(stackTrace, 0, i));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n \t}\n \n \tpublic static <T, R> List<R> collectionMap(Collection<T> list, Function<T, R> mapFunc) {",
    "output": "Fix improve error reporting for instruction decode failure"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n@@ -339,7 +339,7 @@ private static boolean removeUnreachableBlocks(MethodNode mth) {\n \t\tSet<BlockNode> toRemove = new LinkedHashSet<>();\n \t\tfor (BlockNode block : mth.getBasicBlocks()) {\n \t\t\tif (block.getPredecessors().isEmpty() && block != mth.getEnterBlock()) {\n-\t\t\t\tcollectSuccessors(block, toRemove);\n+\t\t\t\tcollectSuccessors(block, mth.getEnterBlock(), toRemove);\n \t\t\t}\n \t\t}\n \t\tif (toRemove.isEmpty()) {\n@@ -390,15 +390,15 @@ private static boolean canRemoveBlock(BlockNode block) {\n \t\t\t\t&& !block.contains(AFlag.MTH_ENTER_BLOCK);\n \t}\n \n-\tprivate static void collectSuccessors(BlockNode startBlock, Set<BlockNode> toRemove) {\n+\tprivate static void collectSuccessors(BlockNode startBlock, BlockNode methodEnterBlock, Set<BlockNode> toRemove) {\n \t\tDeque<BlockNode> stack = new ArrayDeque<>();\n \t\tstack.add(startBlock);\n \t\twhile (!stack.isEmpty()) {\n \t\t\tBlockNode block = stack.pop();\n \t\t\tif (!toRemove.contains(block)) {\n \t\t\t\ttoRemove.add(block);\n \t\t\t\tfor (BlockNode successor : block.getSuccessors()) {\n-\t\t\t\t\tif (toRemove.containsAll(successor.getPredecessors())) {\n+\t\t\t\t\tif (successor != methodEnterBlock && toRemove.containsAll(successor.getPredecessors())) {\n \t\t\t\t\t\tstack.push(successor);\n \t\t\t\t\t}\n \t\t\t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestDeadBlockReferencesStart.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestDeadBlockReferencesStart.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestDeadBlockReferencesStart.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestDeadBlockReferencesStart.java\n@@ -0,0 +1,16 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.countString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestDeadBlockReferencesStart extends SmaliTest {\n+\t@Test\n+\tpublic void test() {\n+\t\tString code = getClassNodeFromSmali().getCode().getCodeStr();\n+\t\tassertThat(code, countString(0, \"throw\"));\n+\t}\n+}",
    "output": "Fix do not remove method start block when it is referenced from dead code"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -30,6 +30,7 @@\n import jadx.core.dex.nodes.IBlock;\n import jadx.core.dex.nodes.IContainer;\n import jadx.core.dex.nodes.IRegion;\n+import jadx.core.dex.nodes.InsnContainer;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.regions.Region;\n@@ -76,6 +77,10 @@ public Region makeRegion(BlockNode startBlock, RegionStack stack) {\n \t\tif (startBlock == null) {\n \t\t\treturn r;\n \t\t}\n+\t\tif (stack.containsExit(startBlock)) {\n+\t\t\tinsertEdgeInsns(r, startBlock);\n+\t\t\treturn r;\n+\t\t}\n \n \t\tint startBlockId = startBlock.getId();\n \t\tif (processedBlocks.get(startBlockId)) {\n@@ -95,6 +100,27 @@ public Region makeRegion(BlockNode startBlock, RegionStack stack) {\n \t\treturn r;\n \t}\n \n+\tprivate void insertEdgeInsns(Region region, BlockNode exitBlock) {\n+\t\tList<EdgeInsnAttr> edgeInsns = exitBlock.getAll(AType.EDGE_INSN);\n+\t\tif (edgeInsns.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tList<InsnNode> insns = new ArrayList<>(edgeInsns.size());\n+\t\taddOneInsnOfType(insns, edgeInsns, InsnType.BREAK);\n+\t\taddOneInsnOfType(insns, edgeInsns, InsnType.CONTINUE);\n+\t\tregion.add(new InsnContainer(insns));\n+\t}\n+\n+\tprivate void addOneInsnOfType(List<InsnNode> insns, List<EdgeInsnAttr> edgeInsns, InsnType insnType) {\n+\t\tfor (EdgeInsnAttr edgeInsn : edgeInsns) {\n+\t\t\tInsnNode insn = edgeInsn.getInsn();\n+\t\t\tif (insn.getType() == insnType) {\n+\t\t\t\tinsns.add(insn);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t/**\n \t * Recursively traverse all blocks from 'block' until block from 'exits'\n \t */\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestLoopInTryCatch.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestLoopInTryCatch.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestLoopInTryCatch.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestLoopInTryCatch.java\n@@ -0,0 +1,29 @@\n+package jadx.tests.integration.trycatch;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestLoopInTryCatch extends SmaliTest {\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsLines(2,\n+\t\t\t\t\t\t\"int i;\",\n+\t\t\t\t\t\t\"while (true) {\",\n+\t\t\t\t\t\t\"    try {\",\n+\t\t\t\t\t\t\"        i = getI();\",\n+\t\t\t\t\t\t\"    } catch (RuntimeException unused) {\",\n+\t\t\t\t\t\t\"        return;\",\n+\t\t\t\t\t\t\"    }\",\n+\t\t\t\t\t\t\"    if (i == 1 || i == 2) {\",\n+\t\t\t\t\t\t\"        break;\",\n+\t\t\t\t\t\t\"    }\",\n+\t\t\t\t\t\t\"}\",\n+\t\t\t\t\t\t\"if (i == 1) {\",\n+\t\t\t\t\t\t\"}\");\n+\t}\n+}",
    "output": "Fix don't add region on exit block"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -8,6 +8,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n \n@@ -224,7 +225,13 @@ private BlockNode processLoop(IRegion curRegion, LoopInfo loop, RegionStack stac\n \t\t\t}\n \t\t\tstack.addExit(out);\n \t\t\tBlockNode loopBody = condInfo.getThenBlock();\n-\t\t\tRegion body = makeRegion(loopBody, stack);\n+\t\t\tRegion body;\n+\t\t\tif (Objects.equals(loopBody, loopStart)) {\n+\t\t\t\t// empty loop body\n+\t\t\t\tbody = new Region(loopRegion);\n+\t\t\t} else {\n+\t\t\t\tbody = makeRegion(loopBody, stack);\n+\t\t\t}\n \t\t\t// add blocks from loop start to first condition block\n \t\t\tBlockNode conditionBlock = condInfo.getIfBlock();\n \t\t\tif (loopStart != conditionBlock) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak3.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak3.java\n@@ -4,7 +4,6 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.tests.api.IntegrationTest;\n \n import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n@@ -23,11 +22,11 @@ public void test() {\n \t\t}\n \t}\n \n-\t@NotYetImplemented\n \t@Test\n \tpublic void test() {\n \t\tassertThat(getClassNode(TestCls.class))\n \t\t\t\t.code()\n-\t\t\t\t.containsOnlyOnce(\"while\");\n+\t\t\t\t.containsOne(\"while\")\n+\t\t\t\t.containsLines(2, \"while (this.it.hasNext() && this.it.next() != null) {\", \"}\");\n \t}\n }",
    "output": "Fix handle empty loop body"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -594,6 +594,8 @@ private BlockNode processMonitorEnter(IRegion curRegion, BlockNode block, InsnNo\n \t\t\t\tList<BlockNode> list = BlockUtils.buildSimplePath(exitBlock);\n \t\t\t\tif (list.isEmpty() || !list.get(list.size() - 1).getSuccessors().isEmpty()) {\n \t\t\t\t\tstack.addExit(exitBlock);\n+\t\t\t\t\t// we can still try using this as an exit block to make sure it's visited.\n+\t\t\t\t\texit = exitBlock;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestSynchronizedInEndlessLoop.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestSynchronizedInEndlessLoop.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestSynchronizedInEndlessLoop.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestSynchronizedInEndlessLoop.java\n@@ -2,7 +2,6 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.tests.api.IntegrationTest;\n \n@@ -34,7 +33,6 @@ int test() {\n \t}\n \n \t@Test\n-\t@NotYetImplemented\n \tpublic void test() {\n \t\tClassNode cls = getClassNode(TestCls.class);\n \t\tString code = cls.getCode().toString();\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized5.java b/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized5.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized5.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized5.java\n@@ -0,0 +1,20 @@\n+package jadx.tests.integration.synchronize;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestSynchronized5 extends SmaliTest {\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmali();\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"1 != 0\"));\n+\t\tassertThat(code, containsString(\"System.gc();\"));\n+\t}\n+}",
    "output": "Fix properly traverse methods with synchronize blocks that have no clear exit"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -3,6 +3,8 @@\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -290,7 +292,11 @@ public void addFallbackMethodCode(CodeWriter code, FallbackOption fallbackOption\n \t\t\tcode.startLine(\"// Can't load method instructions.\");\n \t\t\treturn;\n \t\t}\n-\t\tif (insnArr.length > 100) {\n+\t\tlong insnCountEstimate = Stream.of(insnArr)\n+\t\t\t\t.filter(Objects::nonNull)\n+\t\t\t\t.filter(insn -> insn.getType() != InsnType.NOP)\n+\t\t\t\t.count();\n+\t\tif (insnCountEstimate > 100) {\n \t\t\tcode.startLine(\"// Method dump skipped, instructions count: \" + insnArr.length);\n \t\t\treturn;\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/fallback/TestFallbackManyNops.java b/jadx-core/src/test/java/jadx/tests/integration/fallback/TestFallbackManyNops.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/fallback/TestFallbackManyNops.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/fallback/TestFallbackManyNops.java\n@@ -0,0 +1,27 @@\n+package jadx.tests.integration.fallback;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestFallbackManyNops extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tsetFallback();\n+\t\tdisableCompilation();\n+\n+\t\tClassNode cls = getClassNodeFromSmali();\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"public static void test() {\"));\n+\t\tassertThat(code, containsOne(\"return\"));\n+\t\tassertThat(code, not(containsString(\"Method dump skipped\")));\n+\t}\n+}",
    "output": "Fix do not count nop instructions when considering methods for fallback mode printing"
  },
  {
    "input": "diff --git a/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java b/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n--- a/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n+++ b/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n@@ -27,6 +27,7 @@ public class JavaConvertLoader {\n \tpublic static ConvertResult process(List<Path> input) {\n \t\tConvertResult result = new ConvertResult();\n \t\tprocessJars(input, result);\n+\t\tprocessAars(input, result);\n \t\tprocessClassFiles(input, result);\n \t\treturn result;\n \t}\n@@ -80,6 +81,24 @@ public static String getNameFromClassFile(Path file) throws IOException {\n \t\t}\n \t}\n \n+\tprivate static void processAars(List<Path> input, ConvertResult result) {\n+\t\tPathMatcher aarMatcher = FileSystems.getDefault().getPathMatcher(\"glob:**.aar\");\n+\t\tinput.stream()\n+\t\t\t\t.filter(path -> Files.isRegularFile(path, LinkOption.NOFOLLOW_LINKS))\n+\t\t\t\t.filter(aarMatcher::matches)\n+\t\t\t\t.forEach(path -> ZipSecurity.readZipEntries(path.toFile(), (entry, in) -> {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tif (entry.getName().endsWith(\".jar\")) {\n+\t\t\t\t\t\t\tPath tempJar = saveInputStreamToFile(in, \".jar\");\n+\t\t\t\t\t\t\tresult.addTempPath(tempJar);\n+\t\t\t\t\t\t\tconvertJar(result, tempJar);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\tLOG.error(\"Failed to process zip entry: {}\", entry, e);\n+\t\t\t\t\t}\n+\t\t\t\t}));\n+\t}\n+\n \tprivate static void convertJar(ConvertResult result, Path path) throws Exception {\n \t\tPath tempDirectory = Files.createTempDirectory(\"jadx-\");\n \t\tresult.addTempPath(tempDirectory);\n@@ -121,4 +140,14 @@ public static void copyStream(InputStream input, OutputStream output) throws IOE\n \t\t\toutput.write(buffer, 0, count);\n \t\t}\n \t}\n+\n+\tprivate static Path saveInputStreamToFile(InputStream in, String suffix) throws IOException {\n+\t\tPath tempJar = Files.createTempFile(\"jadx-temp-\", suffix);\n+\t\ttry (OutputStream out = Files.newOutputStream(tempJar)) {\n+\t\t\tcopyStream(in, out);\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new IOException(\"Failed to save temp file\", e);\n+\t\t}\n+\t\treturn tempJar;\n+\t}\n }",
    "output": "Fix support AAR files as input"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n@@ -113,12 +113,11 @@ private static void splitBasicBlocks(MethodNode mth) {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif (insn.contains(AType.EXC_HANDLER)) {\n+\t\t\t\tprocessExceptionHandler(mth, curBlock, insn);\n+\t\t\t}\n \t\t\tif (insn.contains(AFlag.TRY_ENTER)) {\n \t\t\t\tcurBlock = insertSplitterBlock(mth, blocksMap, curBlock, insn, startNew);\n-\t\t\t} else if (insn.contains(AType.EXC_HANDLER)) {\n-\t\t\t\tprocessExceptionHandler(mth, curBlock, insn);\n-\t\t\t\tblocksMap.put(insn.getOffset(), curBlock);\n-\t\t\t\tcurBlock.getInstructions().add(insn);\n \t\t\t} else {\n \t\t\t\tblocksMap.put(insn.getOffset(), curBlock);\n \t\t\t\tcurBlock.getInstructions().add(insn);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryWithEmptyCatchTriple.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryWithEmptyCatchTriple.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryWithEmptyCatchTriple.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryWithEmptyCatchTriple.java\n@@ -0,0 +1,21 @@\n+package jadx.tests.integration.trycatch;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestTryWithEmptyCatchTriple extends SmaliTest {\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmaliWithPkg(\"trycatch\", \"TestTryWithEmptyCatchTriple\");\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"} catch (Error unused) {\"));\n+\t\tassertThat(code, containsOne(\"} catch (Error unused2) {\"));\n+\t\tassertThat(code, containsOne(\"} catch (Error unused3) {\"));\n+\t}\n+}",
    "output": "Fix process exception handler when handler block is start of a new try block"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/MouseHoverHighlighter.java\n@@ -20,7 +20,8 @@ class MouseHoverHighlighter extends MouseMotionAdapter {\n \tprivate final CodeLinkGenerator codeLinkGenerator;\n \tprivate final Highlighter.HighlightPainter highlighter;\n \n-\tprivate boolean added;\n+\tprivate Object tag;\n+\tprivate int highlightedTokenOffset = -1;\n \n \tpublic MouseHoverHighlighter(CodeArea codeArea, CodeLinkGenerator codeLinkGenerator) {\n \t\tthis.codeArea = codeArea;\n@@ -30,28 +31,44 @@ public MouseHoverHighlighter(CodeArea codeArea, CodeLinkGenerator codeLinkGenera\n \n \t@Override\n \tpublic void mouseMoved(MouseEvent e) {\n-\t\tHighlighter highlighter = codeArea.getHighlighter();\n-\t\tif (added) {\n-\t\t\thighlighter.removeAllHighlights();\n-\t\t\tadded = false;\n+\t\tif (!addHighlight(e)) {\n+\t\t\tremoveHighlight();\n \t\t}\n+\t}\n+\n+\tprivate boolean addHighlight(MouseEvent e) {\n \t\tif (e.getModifiersEx() != 0) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\ttry {\n \t\t\tToken token = codeArea.viewToToken(e.getPoint());\n \t\t\tif (token == null || token.getType() != TokenTypes.IDENTIFIER) {\n-\t\t\t\treturn;\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tint tokenOffset = token.getOffset();\n+\t\t\tif (tokenOffset == highlightedTokenOffset) {\n+\t\t\t\t// don't repaint highlight\n+\t\t\t\treturn true;\n \t\t\t}\n-\t\t\tJumpPosition jump = codeLinkGenerator.getJumpLinkAtOffset(codeArea, token.getOffset());\n+\t\t\tJumpPosition jump = codeLinkGenerator.getJumpLinkAtOffset(codeArea, tokenOffset);\n \t\t\tif (jump == null) {\n-\t\t\t\treturn;\n+\t\t\t\treturn false;\n \t\t\t}\n-\t\t\thighlighter.removeAllHighlights();\n-\t\t\thighlighter.addHighlight(token.getOffset(), token.getEndOffset(), this.highlighter);\n-\t\t\tadded = true;\n+\t\t\tremoveHighlight();\n+\t\t\ttag = codeArea.getHighlighter().addHighlight(tokenOffset, token.getEndOffset(), this.highlighter);\n+\t\t\thighlightedTokenOffset = tokenOffset;\n+\t\t\treturn true;\n \t\t} catch (Exception exc) {\n \t\t\tLOG.error(\"Mouse hover highlight error\", exc);\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tprivate void removeHighlight() {\n+\t\tif (tag != null) {\n+\t\t\tcodeArea.getHighlighter().removeHighlight(tag);\n+\t\t\ttag = null;\n+\t\t\thighlightedTokenOffset = -1;\n \t\t}\n \t}\n }",
    "output": "Fix proper reference highlighter remove"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/StringUtils.java b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n@@ -217,9 +217,9 @@ private static String escapeWhiteSpaceChar(char c) {\n \t}\n \n \tprivate static void commonEscapeAndAppend(StringBuilder sb, char c) {\n-\t\tString replace = escapeXmlChar(c);\n+\t\tString replace = escapeWhiteSpaceChar(c);\n \t\tif (replace == null) {\n-\t\t\treplace = escapeWhiteSpaceChar(c);\n+\t\t\treplace = escapeXmlChar(c);\n \t\t}\n \t\tif (replace != null) {\n \t\t\tsb.append(replace);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/functional/StringUtilsTest.java b/jadx-core/src/test/java/jadx/tests/functional/StringUtilsTest.java\n--- a/jadx-core/src/test/java/jadx/tests/functional/StringUtilsTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/functional/StringUtilsTest.java\n@@ -51,4 +51,15 @@ public void testCharUnescape() {\n \tprivate void checkCharUnescape(char input, String result) {\n \t\tassertThat(stringUtils.unescapeChar(input), is('\\'' + result + '\\''));\n \t}\n+\n+\t@Test\n+\tpublic void testResStrValueEscape() {\n+\t\tcheckResStrValueEscape(\"line\\nnew line\", \"line\\\\nnew line\");\n+\t\tcheckResStrValueEscape(\"can't\", \"can\\\\'t\");\n+\t\tcheckResStrValueEscape(\"quote\\\"end\", \"quote\\\\\\\"end\");\n+\t}\n+\n+\tprivate void checkResStrValueEscape(String input, String result) {\n+\t\tassertThat(StringUtils.escapeResStrValue(input), is(result));\n+\t}\n }",
    "output": "Fix unescape new line symbol in string resources"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -313,17 +313,23 @@ private String getAttributeNS(int attributeNS) {\n \t}\n \n \tprivate String generateNameForNS(String attrUrl) {\n-\t\tfor (int i = 1;; i++) {\n-\t\t\tString attrName = \"ns\" + i;\n-\t\t\tif (!nsMap.containsValue(attrName) && !nsMapGenerated.contains(attrName)) {\n-\t\t\t\tnsMapGenerated.add(attrName);\n-\t\t\t\t// do not add generated value to nsMap\n-\t\t\t\t// because attrUrl might be used in a neighbor element, but never defined\n-\t\t\t\twriter.add(\"xmlns:\").add(attrName)\n-\t\t\t\t\t\t.add(\"=\\\"\").add(attrUrl).add(\"\\\" \");\n-\t\t\t\treturn attrName;\n+\t\tString attrName;\n+\t\tif (ANDROID_NS_URL.equals(attrUrl)) {\n+\t\t\tattrName = ANDROID_NS_VALUE;\n+\t\t\tnsMap.put(ANDROID_NS_URL, attrName);\n+\t\t} else {\n+\t\t\tfor (int i = 1;; i++) {\n+\t\t\t\tattrName = \"ns\" + i;\n+\t\t\t\tif (!nsMapGenerated.contains(attrName) && !nsMap.containsValue(attrName)) {\n+\t\t\t\t\tnsMapGenerated.add(attrName);\n+\t\t\t\t\t// do not add generated value to nsMap\n+\t\t\t\t\t// because attrUrl might be used in a neighbor element, but never defined\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\twriter.add(\"xmlns:\").add(attrName).add(\"=\\\"\").add(attrUrl).add(\"\\\" \");\n+\t\treturn attrName;\n \t}\n \n \tprivate String getAttributeName(int id) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n@@ -9,6 +9,7 @@ protected ParserConstants() {\n \t}\n \n \tprotected static final String ANDROID_NS_URL = \"http://schemas.android.com/apk/res/android\";\n+\tprotected static final String ANDROID_NS_VALUE = \"android\";\n \n \t/**\n \t * Chunk types",
    "output": "Fix ns value * Fixes ns value * fix formatting Co-authored-by: bagipro <bugi@MacBook-Pro.local> Co-authored-by: Skylot <skylot@gmail.com>"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/clst/ConvertToClsSet.java b/jadx-cli/src/main/java/jadx/cli/clst/ConvertToClsSet.java\n--- a/jadx-cli/src/main/java/jadx/cli/clst/ConvertToClsSet.java\n+++ b/jadx-cli/src/main/java/jadx/cli/clst/ConvertToClsSet.java\n@@ -1,6 +1,5 @@\n package jadx.cli.clst;\n \n-import java.io.IOException;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.util.ArrayList;\n@@ -17,7 +16,9 @@\n import jadx.api.plugins.input.JadxInputPlugin;\n import jadx.api.plugins.input.data.ILoadResult;\n import jadx.core.clsp.ClsSet;\n+import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.RootNode;\n+import jadx.core.dex.visitors.SignatureProcessor;\n \n /**\n  * Utility class for convert dex or jar to jadx classes set (.jcst)\n@@ -29,7 +30,7 @@ public static void usage() {\n \t\tLOG.info(\"<output .jcst or .jar file> <several input dex or jar files> \");\n \t}\n \n-\tpublic static void main(String[] args) throws IOException {\n+\tpublic static void main(String[] args) throws Exception {\n \t\tif (args.length < 2) {\n \t\t\tusage();\n \t\t\tSystem.exit(1);\n@@ -48,6 +49,13 @@ public static void main(String[] args) throws IOException {\n \t\tRootNode root = new RootNode(jadxArgs);\n \t\troot.loadClasses(loadedInputs);\n \n+\t\t// from pre-decompilation stage run only SignatureProcessor\n+\t\tSignatureProcessor signatureProcessor = new SignatureProcessor();\n+\t\tsignatureProcessor.init(root);\n+\t\tfor (ClassNode classNode : root.getClasses()) {\n+\t\t\tsignatureProcessor.visit(classNode);\n+\t\t}\n+\n \t\tClsSet set = new ClsSet(root);\n \t\tset.loadFrom(root);\n \t\tset.save(output);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java\n--- a/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java\n+++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java\n@@ -49,7 +49,7 @@ public class ClsSet {\n \n \tprivate static final String CLST_EXTENSION = \".jcst\";\n \tprivate static final String CLST_FILENAME = \"core\" + CLST_EXTENSION;\n-\tprivate static final String CLST_PKG_PATH = ClsSet.class.getPackage().getName().replace('.', '/');\n+\tprivate static final String CLST_PATH = \"/clst/\" + CLST_FILENAME;\n \n \tprivate static final String JADX_CLS_SET_HEADER = \"jadx-cst\";\n \tprivate static final int VERSION = 3;\n@@ -78,9 +78,9 @@ private enum TypeEnum {\n \n \tpublic void loadFromClstFile() throws IOException, DecodeException {\n \t\tlong startTime = System.currentTimeMillis();\n-\t\ttry (InputStream input = getClass().getResourceAsStream(CLST_FILENAME)) {\n+\t\ttry (InputStream input = ClsSet.class.getResourceAsStream(CLST_PATH)) {\n \t\t\tif (input == null) {\n-\t\t\t\tthrow new JadxRuntimeException(\"Can't load classpath file: \" + CLST_FILENAME);\n+\t\t\t\tthrow new JadxRuntimeException(\"Can't load classpath file: \" + CLST_PATH);\n \t\t\t}\n \t\t\tload(input);\n \t\t}\n@@ -197,7 +197,7 @@ public void save(Path path) throws IOException {\n \n \t\t\ttry (ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(path));\n \t\t\t\t\tZipInputStream in = new ZipInputStream(Files.newInputStream(temp))) {\n-\t\t\t\tString clst = CLST_PKG_PATH + '/' + CLST_FILENAME;\n+\t\t\t\tString clst = CLST_PATH;\n \t\t\t\tboolean clstReplaced = false;\n \t\t\t\tZipEntry entry = in.getNextEntry();\n \t\t\t\twhile (entry != null) {",
    "output": "Fix update class set data to Android API 30"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n@@ -154,6 +154,30 @@ public Map<ArgType, ArgType> getTypeVariablesMapping(ArgType clsType) {\n \t\treturn replaceMap;\n \t}\n \n+\tpublic Map<ArgType, ArgType> getTypeVarMappingForInvoke(BaseInvokeNode invokeInsn) {\n+\t\tIMethodDetails mthDetails = root.getMethodUtils().getMethodDetails(invokeInsn);\n+\t\tif (mthDetails == null) {\n+\t\t\treturn Collections.emptyMap();\n+\t\t}\n+\t\tMap<ArgType, ArgType> map = new HashMap<>(1 + invokeInsn.getArgsCount());\n+\t\taddTypeVarMapping(map, mthDetails.getReturnType(), invokeInsn.getResult());\n+\t\tint argCount = Math.min(mthDetails.getArgTypes().size(), invokeInsn.getArgsCount());\n+\t\tfor (int i = 0; i < argCount; i++) {\n+\t\t\taddTypeVarMapping(map, mthDetails.getArgTypes().get(i), invokeInsn.getArg(i));\n+\t\t}\n+\t\treturn map;\n+\t}\n+\n+\tprivate static void addTypeVarMapping(Map<ArgType, ArgType> map, ArgType typeVar, InsnArg arg) {\n+\t\tif (arg == null || typeVar == null || !typeVar.isTypeKnown()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tif (typeVar.isGenericType()) {\n+\t\t\tmap.put(typeVar, arg.getType());\n+\t\t}\n+\t\t// TODO: resolve inner type vars: 'List<T> -> List<String>' to 'T -> String'\n+\t}\n+\n \t@Nullable\n \tpublic ArgType replaceMethodGenerics(BaseInvokeNode invokeInsn, IMethodDetails details, ArgType typeWithGeneric) {\n \t\tif (typeWithGeneric == null) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java\n@@ -22,6 +22,7 @@\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.RootNode;\n+import jadx.core.dex.nodes.utils.TypeUtils;\n import jadx.core.dex.visitors.methods.MutableMethodDetails;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n import jadx.core.dex.visitors.typeinference.TypeCompare;\n@@ -156,9 +157,14 @@ private ArgType getCallClassFromInvoke(MethodNode parentMth, BaseInvokeNode invo\n \t}\n \n \tprivate Map<ArgType, ArgType> getTypeVarsMapping(BaseInvokeNode invokeInsn) {\n-\t\tArgType declClsType = invokeInsn.getCallMth().getDeclClass().getType();\n+\t\tMethodInfo callMthInfo = invokeInsn.getCallMth();\n+\t\tArgType declClsType = callMthInfo.getDeclClass().getType();\n \t\tArgType callClsType = getClsCallType(invokeInsn, declClsType);\n-\t\treturn root.getTypeUtils().getTypeVariablesMapping(callClsType);\n+\n+\t\tTypeUtils typeUtils = root.getTypeUtils();\n+\t\tMap<ArgType, ArgType> clsTypeVars = typeUtils.getTypeVariablesMapping(callClsType);\n+\t\tMap<ArgType, ArgType> mthTypeVars = typeUtils.getTypeVarMappingForInvoke(invokeInsn);\n+\t\treturn Utils.mergeMaps(clsTypeVars, mthTypeVars);\n \t}\n \n \tprivate ArgType getClsCallType(BaseInvokeNode invokeInsn, ArgType declClsType) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/Utils.java b/jadx-core/src/main/java/jadx/core/utils/Utils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/Utils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java\n@@ -246,6 +246,22 @@ public static Map<String, String> newConstStringMap(String... parameters) {\n \t\treturn Collections.unmodifiableMap(result);\n \t}\n \n+\t/**\n+\t * Merge two maps. Return HashMap as result. Second map will override values from first map.\n+\t */\n+\tpublic static <K, V> Map<K, V> mergeMaps(Map<K, V> first, Map<K, V> second) {\n+\t\tif (isEmpty(first)) {\n+\t\t\treturn second;\n+\t\t}\n+\t\tif (isEmpty(second)) {\n+\t\t\treturn first;\n+\t\t}\n+\t\tMap<K, V> result = new HashMap<>(first.size() + second.size());\n+\t\tresult.putAll(first);\n+\t\tresult.putAll(second);\n+\t\treturn result;\n+\t}\n+\n \t@Nullable\n \tpublic static <T> T getOne(@Nullable List<T> list) {\n \t\tif (list == null || list.size() != 1) {\n@@ -277,6 +293,10 @@ public static <T> boolean notEmpty(Collection<T> col) {\n \t\treturn col != null && !col.isEmpty();\n \t}\n \n+\tpublic static <K, V> boolean isEmpty(Map<K, V> map) {\n+\t\treturn map == null || map.isEmpty();\n+\t}\n+\n \tpublic static <T> boolean isEmpty(T[] arr) {\n \t\treturn arr == null || arr.length == 0;\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums9.java b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums9.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums9.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums9.java\n@@ -0,0 +1,50 @@\n+package jadx.tests.integration.enums;\n+\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestEnums9 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic enum Types {\n+\t\t\tINT,\n+\t\t\tFLOAT,\n+\t\t\tLONG,\n+\t\t\tDOUBLE,\n+\t\t\tOBJECT,\n+\t\t\tARRAY;\n+\n+\t\t\tprivate static Set<Types> primitives = EnumSet.of(INT, FLOAT, LONG, DOUBLE);\n+\t\t\tpublic static List<Types> references = new ArrayList<>();\n+\n+\t\t\tstatic {\n+\t\t\t\treferences.add(OBJECT);\n+\t\t\t\treferences.add(ARRAY);\n+\t\t\t}\n+\n+\t\t\tpublic static Set<Types> getPrimitives() {\n+\t\t\t\treturn primitives;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(Types.getPrimitives()).contains(Types.INT);\n+\t\t\tassertThat(Types.references).hasSize(2);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"EnumSet.of((Enum) INT,\");\n+\t}\n+}",
    "output": "Fix resolve type variables in invoke from arg types"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -2,7 +2,6 @@\n \n import java.io.IOException;\n import java.io.InputStream;\n-import java.lang.reflect.Field;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n@@ -35,12 +34,10 @@\n  */\n \n public class BinaryXMLParser extends CommonBinaryParser {\n-\n \tprivate static final Logger LOG = LoggerFactory.getLogger(BinaryXMLParser.class);\n-\tprivate static final String ANDROID_R_STYLE_CLS = \"android.R$style\";\n+\n \tprivate static final boolean ATTR_NEW_LINE = false;\n \n-\tprivate final Map<Integer, String> styleMap = new HashMap<>();\n \tprivate final Map<Integer, String> resNames;\n \tprivate Map<String, String> nsMap;\n \tprivate Set<String> nsMapGenerated;\n@@ -62,25 +59,13 @@ public class BinaryXMLParser extends CommonBinaryParser {\n \tpublic BinaryXMLParser(RootNode rootNode) {\n \t\tthis.rootNode = rootNode;\n \t\ttry {\n-\t\t\treadAndroidRStyleClass();\n \t\t\tConstStorage constStorage = rootNode.getConstValues();\n \t\t\tresNames = constStorage.getResourcesNames();\n \t\t} catch (Exception e) {\n \t\t\tthrow new JadxRuntimeException(\"BinaryXMLParser init error\", e);\n \t\t}\n \t}\n \n-\tprivate void readAndroidRStyleClass() {\n-\t\ttry {\n-\t\t\tClass<?> rStyleCls = Class.forName(ANDROID_R_STYLE_CLS);\n-\t\t\tfor (Field f : rStyleCls.getFields()) {\n-\t\t\t\tstyleMap.put(f.getInt(f.getType()), f.getName());\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Android R class loading failed\", e);\n-\t\t}\n-\t}\n-\n \tpublic synchronized ICodeInfo parse(InputStream inputStream) throws IOException {\n \t\tis = new ParserStream(inputStream);\n \t\tif (!isBinaryXml()) {\n@@ -370,26 +355,21 @@ private void decodeAttribute(int attributeNS, int attrValDataType, int attrValDa\n \t\t\tString shortNsName, String attrName) {\n \t\tif (attrValDataType == TYPE_REFERENCE) {\n \t\t\t// reference custom processing\n-\t\t\tString name = styleMap.get(attrValData);\n-\t\t\tif (name != null) {\n-\t\t\t\twriter.add(\"@style/\").add(name.replace('_', '.'));\n+\t\t\tString resName = resNames.get(attrValData);\n+\t\t\tif (resName != null) {\n+\t\t\t\twriter.add('@');\n+\t\t\t\tif (resName.startsWith(\"id/\")) {\n+\t\t\t\t\twriter.add('+');\n+\t\t\t\t}\n+\t\t\t\twriter.add(resName);\n \t\t\t} else {\n-\t\t\t\tString resName = resNames.get(attrValData);\n-\t\t\t\tif (resName != null) {\n-\t\t\t\t\twriter.add('@');\n-\t\t\t\t\tif (resName.startsWith(\"id/\")) {\n-\t\t\t\t\t\twriter.add('+');\n-\t\t\t\t\t}\n-\t\t\t\t\twriter.add(resName);\n+\t\t\t\tString androidResName = ValuesParser.getAndroidResMap().get(attrValData);\n+\t\t\t\tif (androidResName != null) {\n+\t\t\t\t\twriter.add(\"@android:\").add(androidResName);\n+\t\t\t\t} else if (attrValData == 0) {\n+\t\t\t\t\twriter.add(\"@null\");\n \t\t\t\t} else {\n-\t\t\t\t\tresName = ValuesParser.getAndroidResMap().get(attrValData);\n-\t\t\t\t\tif (resName != null) {\n-\t\t\t\t\t\twriter.add(\"@android:\").add(resName);\n-\t\t\t\t\t} else if (attrValData == 0) {\n-\t\t\t\t\t\twriter.add(\"@null\");\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\twriter.add(\"0x\").add(Integer.toHexString(attrValData));\n-\t\t\t\t\t}\n+\t\t\t\t\twriter.add(\"0x\").add(Integer.toHexString(attrValData));\n \t\t\t\t}\n \t\t\t}\n \t\t} else {",
    "output": "Fix update android resources to API 30"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n@@ -26,10 +26,14 @@ public class ValuesParser extends ParserConstants {\n \tpublic ValuesParser(String[] strings, Map<Integer, String> resMap) {\n \t\tthis.strings = strings;\n \t\tthis.resMap = resMap;\n+\t\tgetAndroidResMap();\n+\t}\n \n+\tpublic static Map<Integer, String> getAndroidResMap() {\n \t\tif (androidResMap == null) {\n \t\t\tandroidResMap = loadAndroidResMap();\n \t\t}\n+\t\treturn androidResMap;\n \t}\n \n \tprivate static Map<Integer, String> loadAndroidResMap() {\n@@ -224,8 +228,4 @@ private static String doubleToString(double value) {\n \tprivate static String floatToString(float value) {\n \t\treturn doubleToString(value);\n \t}\n-\n-\tpublic static Map<Integer, String> getAndroidResMap() {\n-\t\treturn androidResMap;\n-\t}\n }",
    "output": "Fix load android res map in getter"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -110,7 +110,7 @@ public boolean addDefinition(CodeWriter code) {\n \t\tif (Consts.DEBUG) {\n \t\t\tcode.add(mth.isVirtual() ? \"/* virtual */ \" : \"/* direct */ \");\n \t\t}\n-\t\tif (clsAccFlags.isInterface() && !mth.isNoCode()) {\n+\t\tif (clsAccFlags.isInterface() && !mth.isNoCode() && !mth.getAccessFlags().isStatic()) {\n \t\t\t// add 'default' for method with code in interface\n \t\t\tcode.add(\"default \");\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestInterfaceDefaultMethod.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestInterfaceDefaultMethod.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestInterfaceDefaultMethod.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestInterfaceDefaultMethod.java\n@@ -0,0 +1,37 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestInterfaceDefaultMethod extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\t@SuppressWarnings(\"UnnecessaryInterfaceModifier\")\n+\t\tpublic interface ITest {\n+\t\t\tvoid test1();\n+\n+\t\t\tdefault void test2() {\n+\t\t\t}\n+\n+\t\t\tstatic void test3() {\n+\t\t\t}\n+\n+\t\t\tabstract void test4();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"static default\")\n+\t\t\t\t.doesNotContain(\"abstract\")\n+\t\t\t\t.containsOne(\"void test1();\")\n+\t\t\t\t.containsOne(\"default void test2() {\")\n+\t\t\t\t.containsOne(\"static void test3() {\");\n+\t}\n+}",
    "output": "Fix don't add 'default' for static methods in interfaces"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -7,6 +7,7 @@\n import java.util.List;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.regex.Pattern;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -26,6 +27,8 @@\n public class ResTableParser extends CommonBinaryParser {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ResTableParser.class);\n \n+\tprivate static final Pattern VALID_RES_KEY_PATTERN = Pattern.compile(\"[\\\\w\\\\d-_.]+\");\n+\n \tprivate static final class PackageChunk {\n \t\tprivate final int id;\n \t\tprivate final String name;\n@@ -292,7 +295,7 @@ private String getResName(int resRef, String origKeyName) {\n \t\tif (renamedKey != null) {\n \t\t\treturn renamedKey;\n \t\t}\n-\t\tif (!origKeyName.isEmpty()) {\n+\t\tif (VALID_RES_KEY_PATTERN.matcher(origKeyName).matches()) {\n \t\t\treturn origKeyName;\n \t\t}\n \t\tFieldNode constField = root.getConstValues().getGlobalConstFields().get(resRef);",
    "output": "Fix rename invalid res keys * Renames invalid res keys * perf: store compiled resource name pattern for better performance Co-authored-by: bagipro <bugi@MacBook-Pro.local> Co-authored-by: Skylot <skylot@gmail.com>"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/android/TextResMapFile.java b/jadx-core/src/main/java/jadx/core/utils/android/TextResMapFile.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/TextResMapFile.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/TextResMapFile.java\n@@ -1,5 +1,9 @@\n package jadx.core.utils.android;\n \n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.ArrayList;\n@@ -13,28 +17,44 @@\n public class TextResMapFile {\n \tprivate static final int SPLIT_POS = 8;\n \n-\tpublic static Map<Integer, String> read(Path resMapFile) {\n-\t\ttry {\n+\tpublic static Map<Integer, String> read(InputStream is) {\n+\t\ttry (BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n \t\t\tMap<Integer, String> resMap = new HashMap<>();\n-\t\t\tfor (String line : Files.readAllLines(resMapFile)) {\n-\t\t\t\tint id = Integer.parseInt(line.substring(0, SPLIT_POS), 16);\n-\t\t\t\tString name = line.substring(SPLIT_POS + 1);\n-\t\t\t\tresMap.put(id, name);\n+\t\t\twhile (true) {\n+\t\t\t\tString line = br.readLine();\n+\t\t\t\tif (line == null) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tparseLine(resMap, line);\n \t\t\t}\n \t\t\treturn resMap;\n \t\t} catch (Exception e) {\n \t\t\tthrow new JadxRuntimeException(\"Failed to read res-map file\", e);\n \t\t}\n \t}\n \n+\tprivate static void parseLine(Map<Integer, String> resMap, String line) {\n+\t\tint id = Integer.parseInt(line.substring(0, SPLIT_POS), 16);\n+\t\tString name = line.substring(SPLIT_POS + 1);\n+\t\tresMap.put(id, name);\n+\t}\n+\n+\tpublic static Map<Integer, String> read(Path resMapFile) {\n+\t\ttry (InputStream in = Files.newInputStream(resMapFile)) {\n+\t\t\treturn read(in);\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new JadxRuntimeException(\"Failed to read res-map file\", e);\n+\t\t}\n+\t}\n+\n \tpublic static void write(Path resMapFile, Map<Integer, String> inputResMap) {\n \t\ttry {\n \t\t\tMap<Integer, String> resMap = new TreeMap<>(inputResMap);\n \t\t\tList<String> lines = new ArrayList<>(resMap.size());\n \t\t\tfor (Map.Entry<Integer, String> entry : resMap.entrySet()) {\n \t\t\t\tlines.add(String.format(\"%08x=%s\", entry.getKey(), entry.getValue()));\n \t\t\t}\n-\t\t\tFiles.write(resMapFile, lines);\n+\t\t\tFiles.write(resMapFile, lines, StandardCharsets.UTF_8);\n \t\t} catch (Exception e) {\n \t\t\tthrow new JadxRuntimeException(\"Failed to write res-map file\", e);\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n@@ -1,7 +1,6 @@\n package jadx.core.xmlgen.entry;\n \n-import java.net.URL;\n-import java.nio.file.Paths;\n+import java.io.InputStream;\n import java.text.NumberFormat;\n import java.util.ArrayList;\n import java.util.List;\n@@ -34,9 +33,8 @@ public ValuesParser(String[] strings, Map<Integer, String> resMap) {\n \t}\n \n \tprivate static Map<Integer, String> loadAndroidResMap() {\n-\t\ttry {\n-\t\t\tURL resMapUrl = ValuesParser.class.getResource(\"/android/res-map.txt\");\n-\t\t\treturn TextResMapFile.read(Paths.get(resMapUrl.toURI()));\n+\t\ttry (InputStream is = ValuesParser.class.getResourceAsStream(\"/android/res-map.txt\")) {\n+\t\t\treturn TextResMapFile.read(is);\n \t\t} catch (Exception e) {\n \t\t\tthrow new JadxRuntimeException(\"Failed to load android resource file\", e);\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/core/xmlgen/entry/ValuesParserTest.java b/jadx-core/src/test/java/jadx/core/xmlgen/entry/ValuesParserTest.java\n--- a/jadx-core/src/test/java/jadx/core/xmlgen/entry/ValuesParserTest.java\n+++ b/jadx-core/src/test/java/jadx/core/xmlgen/entry/ValuesParserTest.java\n@@ -0,0 +1,16 @@\n+package jadx.core.xmlgen.entry;\n+\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ValuesParserTest {\n+\n+\t@Test\n+\tvoid testResMapLoad() {\n+\t\tMap<Integer, String> androidResMap = ValuesParser.getAndroidResMap();\n+\t\tassertThat(androidResMap).isNotNull().isNotEmpty();\n+\t}\n+}",
    "output": "Fix error loading resource map file from bundled jar"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/tools/ConvertArscFile.java b/jadx-cli/src/main/java/jadx/cli/tools/ConvertArscFile.java\n--- a/jadx-cli/src/main/java/jadx/cli/tools/ConvertArscFile.java\n+++ b/jadx-cli/src/main/java/jadx/cli/tools/ConvertArscFile.java\n@@ -0,0 +1,80 @@\n+package jadx.cli.tools;\n+\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import jadx.api.JadxArgs;\n+import jadx.core.dex.nodes.RootNode;\n+import jadx.core.utils.android.TextResMapFile;\n+import jadx.core.xmlgen.ResTableParser;\n+\n+/**\n+ * Utility class for convert '.arsc' to simple text file with mapping id to resource name\n+ */\n+public class ConvertArscFile {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(ConvertArscFile.class);\n+\tprivate static int rewritesCount;\n+\n+\tpublic static void usage() {\n+\t\tLOG.info(\"<res-map file> <input .arsc files>\");\n+\t\tLOG.info(\"\");\n+\t\tLOG.info(\"Note: If res-map already exists - it will be merged and updated\");\n+\t}\n+\n+\tpublic static void main(String[] args) throws IOException {\n+\t\tif (args.length < 2) {\n+\t\t\tusage();\n+\t\t\tSystem.exit(1);\n+\t\t}\n+\t\tList<Path> inputPaths = Stream.of(args).map(Paths::get).collect(Collectors.toList());\n+\t\tPath resMapFile = inputPaths.remove(0);\n+\t\tMap<Integer, String> resMap;\n+\t\tif (Files.isReadable(resMapFile)) {\n+\t\t\tresMap = TextResMapFile.read(resMapFile);\n+\t\t} else {\n+\t\t\tresMap = new HashMap<>();\n+\t\t}\n+\t\tLOG.info(\"Input entries count: {}\", resMap.size());\n+\n+\t\tRootNode root = new RootNode(new JadxArgs()); // not really needed\n+\t\trewritesCount = 0;\n+\t\tfor (Path resFile : inputPaths) {\n+\t\t\ttry (InputStream inputStream = new BufferedInputStream(Files.newInputStream(resFile))) {\n+\t\t\t\tResTableParser resTableParser = new ResTableParser(root);\n+\t\t\t\tresTableParser.decode(inputStream);\n+\t\t\t\tMap<Integer, String> singleResMap = resTableParser.getResStorage().getResourcesNames();\n+\t\t\t\tmergeResMaps(resMap, singleResMap);\n+\t\t\t\tLOG.info(\"{} entries count: {}, after merge: {}\", resFile.getFileName(), singleResMap.size(), resMap.size());\n+\t\t\t}\n+\t\t}\n+\t\tLOG.info(\"Output entries count: {}\", resMap.size());\n+\t\tLOG.info(\"Total rewrites count: {}\", rewritesCount);\n+\t\tTextResMapFile.write(resMapFile, resMap);\n+\t\tLOG.info(\"Result file size: {} B\", resMapFile.toFile().length());\n+\t\tLOG.info(\"done\");\n+\t}\n+\n+\tprivate static void mergeResMaps(Map<Integer, String> mainResMap, Map<Integer, String> newResMap) {\n+\t\tfor (Map.Entry<Integer, String> entry : newResMap.entrySet()) {\n+\t\t\tInteger id = entry.getKey();\n+\t\t\tString name = entry.getValue();\n+\t\t\tString prevName = mainResMap.put(id, name);\n+\t\t\tif (prevName != null && !name.equals(prevName)) {\n+\t\t\t\tLOG.debug(\"Rewrite id: {} from: '{}' to: '{}'\", Integer.toHexString(id), prevName, name);\n+\t\t\t\trewritesCount++;\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -173,7 +173,7 @@ private void updateObfuscatedFiles(ResTableParser parser, List<ResourceFile> res\n \t\tlong start = System.currentTimeMillis();\n \t\tint renamedCount = 0;\n \t\tResourceStorage resStorage = parser.getResStorage();\n-\t\tValuesParser valuesParser = new ValuesParser(this, parser.getStrings(), resStorage.getResourcesNames());\n+\t\tValuesParser valuesParser = new ValuesParser(parser.getStrings(), resStorage.getResourcesNames());\n \t\tMap<String, ResourceEntry> entryNames = new HashMap<>();\n \t\tfor (ResourceEntry resEntry : resStorage.getResources()) {\n \t\t\tString val = valuesParser.getSimpleValueString(resEntry);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/android/TextResMapFile.java b/jadx-core/src/main/java/jadx/core/utils/android/TextResMapFile.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/TextResMapFile.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/TextResMapFile.java\n@@ -0,0 +1,42 @@\n+package jadx.core.utils.android;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n+\n+public class TextResMapFile {\n+\tprivate static final int SPLIT_POS = 8;\n+\n+\tpublic static Map<Integer, String> read(Path resMapFile) {\n+\t\ttry {\n+\t\t\tMap<Integer, String> resMap = new HashMap<>();\n+\t\t\tfor (String line : Files.readAllLines(resMapFile)) {\n+\t\t\t\tint id = Integer.parseInt(line.substring(0, SPLIT_POS), 16);\n+\t\t\t\tString name = line.substring(SPLIT_POS + 1);\n+\t\t\t\tresMap.put(id, name);\n+\t\t\t}\n+\t\t\treturn resMap;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new JadxRuntimeException(\"Failed to read res-map file\", e);\n+\t\t}\n+\t}\n+\n+\tpublic static void write(Path resMapFile, Map<Integer, String> inputResMap) {\n+\t\ttry {\n+\t\t\tMap<Integer, String> resMap = new TreeMap<>(inputResMap);\n+\t\t\tList<String> lines = new ArrayList<>(resMap.size());\n+\t\t\tfor (Map.Entry<Integer, String> entry : resMap.entrySet()) {\n+\t\t\t\tlines.add(String.format(\"%08x=%s\", entry.getKey(), entry.getValue()));\n+\t\t\t}\n+\t\t\tFiles.write(resMapFile, lines);\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new JadxRuntimeException(\"Failed to write res-map file\", e);\n+\t\t}\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -117,7 +117,7 @@ void decode() throws IOException {\n \t\t\t\t\tbreak;\n \t\t\t\tcase RES_STRING_POOL_TYPE:\n \t\t\t\t\tstrings = parseStringPoolNoType();\n-\t\t\t\t\tvaluesParser = new ValuesParser(rootNode, strings, resNames);\n+\t\t\t\t\tvaluesParser = new ValuesParser(strings, resNames);\n \t\t\t\t\tbreak;\n \t\t\t\tcase RES_XML_RESOURCE_MAP_TYPE:\n \t\t\t\t\tparseResourceMap();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -73,7 +73,7 @@ public void decode(InputStream inputStream) throws IOException {\n \tpublic ResContainer decodeFiles(InputStream inputStream) throws IOException {\n \t\tdecode(inputStream);\n \n-\t\tValuesParser vp = new ValuesParser(root, strings, resStorage.getResourcesNames());\n+\t\tValuesParser vp = new ValuesParser(strings, resStorage.getResourcesNames());\n \t\tResXmlGen resGen = new ResXmlGen(resStorage, vp);\n \n \t\tICodeInfo content = makeXmlDump();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n@@ -1,8 +1,7 @@\n package jadx.core.xmlgen.entry;\n \n-import java.io.BufferedInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n+import java.net.URL;\n+import java.nio.file.Paths;\n import java.text.NumberFormat;\n import java.util.ArrayList;\n import java.util.List;\n@@ -13,9 +12,9 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import jadx.core.dex.nodes.RootNode;\n+import jadx.core.utils.android.TextResMapFile;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.core.xmlgen.ParserConstants;\n-import jadx.core.xmlgen.ResTableParser;\n \n public class ValuesParser extends ParserConstants {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ValuesParser.class);\n@@ -25,25 +24,21 @@ public class ValuesParser extends ParserConstants {\n \tprivate final String[] strings;\n \tprivate final Map<Integer, String> resMap;\n \n-\tpublic ValuesParser(RootNode root, String[] strings, Map<Integer, String> resMap) {\n+\tpublic ValuesParser(String[] strings, Map<Integer, String> resMap) {\n \t\tthis.strings = strings;\n \t\tthis.resMap = resMap;\n \n \t\tif (androidResMap == null) {\n-\t\t\ttry {\n-\t\t\t\tdecodeAndroid(root);\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tLOG.error(\"Failed to decode Android Resource file\", e);\n-\t\t\t}\n+\t\t\tandroidResMap = loadAndroidResMap();\n \t\t}\n \t}\n \n-\t// TODO: store only needed data instead full resources.arsc file\n-\tprivate static void decodeAndroid(RootNode root) throws IOException {\n-\t\ttry (InputStream inputStream = new BufferedInputStream(ValuesParser.class.getResourceAsStream(\"/resources.arsc\"))) {\n-\t\t\tResTableParser androidParser = new ResTableParser(root);\n-\t\t\tandroidParser.decode(inputStream);\n-\t\t\tandroidResMap = androidParser.getResStorage().getResourcesNames();\n+\tprivate static Map<Integer, String> loadAndroidResMap() {\n+\t\ttry {\n+\t\t\tURL resMapUrl = ValuesParser.class.getResource(\"/android/res-map.txt\");\n+\t\t\treturn TextResMapFile.read(Paths.get(resMapUrl.toURI()));\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new JadxRuntimeException(\"Failed to load android resource file\", e);\n \t\t}\n \t}",
    "output": "Use text file for store android resource mapping"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java\n@@ -92,6 +92,8 @@ public class AType<T extends IAttribute> {\n \tpublic static final AType<RegDebugInfoAttr> REG_DEBUG_INFO = new AType<>();\n \n \tpublic static final Set<AType<?>> SKIP_ON_UNLOAD = new HashSet<>(Arrays.asList(\n+\t\t\tSOURCE_FILE,\n+\t\t\tFIELD_INIT,\n \t\t\tFIELD_REPLACE,\n \t\t\tMETHOD_INLINE,\n \t\t\tSKIP_MTH_ARGS));\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -167,16 +167,20 @@ private void loadStaticValues(IClassData cls, List<FieldNode> fields) {\n \t\t\t\tf.addAttr(FieldInitAttr.NULL_VALUE);\n \t\t\t}\n \t\t}\n-\t\tList<EncodedValue> values = cls.getStaticFieldInitValues();\n-\t\tint count = values.size();\n-\t\tif (count == 0 || count > staticFields.size()) {\n-\t\t\treturn;\n-\t\t}\n-\t\tfor (int i = 0; i < count; i++) {\n-\t\t\tstaticFields.get(i).addAttr(FieldInitAttr.constValue(values.get(i)));\n+\t\ttry {\n+\t\t\tList<EncodedValue> values = cls.getStaticFieldInitValues();\n+\t\t\tint count = values.size();\n+\t\t\tif (count == 0 || count > staticFields.size()) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tfor (int i = 0; i < count; i++) {\n+\t\t\t\tstaticFields.get(i).addAttr(FieldInitAttr.constValue(values.get(i)));\n+\t\t\t}\n+\t\t\t// process const fields\n+\t\t\troot().getConstValues().processConstFields(this, staticFields);\n+\t\t} catch (Exception e) {\n+\t\t\tthis.addWarnComment(\"Failed to load initial values for static fields\", e);\n \t\t}\n-\t\t// process const fields\n-\t\troot().getConstValues().processConstFields(this, staticFields);\n \t}\n \n \tprivate void addSourceFilenameAttr(String fileName) {",
    "output": "Fix don't unload attributes added to class at initial load"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -280,13 +280,7 @@ private void parseAttribute(int i, boolean newLine) throws IOException {\n \t\tint attributeNS = is.readInt32();\n \t\tint attributeName = is.readInt32();\n \t\tint attributeRawValue = is.readInt32();\n-\t\tint attrValSize = is.readInt16();\n-\t\tif (attrValSize != 0x08) {\n-\t\t\tdie(\"attrValSize != 0x08 not supported\");\n-\t\t}\n-\t\tif (is.readInt8() != 0) {\n-\t\t\tdie(\"res0 is not 0\");\n-\t\t}\n+\t\tis.skip(3);\n \t\tint attrValDataType = is.readInt8();\n \t\tint attrValData = is.readInt32();",
    "output": "Fix skip unused bytes in xml attributes parsing"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java\n@@ -81,17 +81,23 @@ public boolean run() {\n \n \tprivate boolean applyResolvedVars() {\n \t\tList<TypeSearchVarInfo> resolvedVars = state.getResolvedVars();\n+\t\tList<TypeSearchVarInfo> updatedVars = new ArrayList<>();\n \t\tfor (TypeSearchVarInfo var : resolvedVars) {\n \t\t\tSSAVar ssaVar = var.getVar();\n \t\t\tArgType resolvedType = var.getCurrentType();\n+\t\t\tif (!resolvedType.isTypeKnown()) {\n+\t\t\t\t// ignore unknown variables\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (resolvedType.equals(ssaVar.getTypeInfo().getType())) {\n+\t\t\t\t// type already set\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tssaVar.setType(resolvedType);\n+\t\t\tupdatedVars.add(var);\n \t\t}\n \t\tboolean applySuccess = true;\n-\t\tfor (TypeSearchVarInfo var : resolvedVars) {\n-\t\t\tif (!var.getCurrentType().isTypeKnown()) {\n-\t\t\t\t// exclude unknown variables\n-\t\t\t\tcontinue;\n-\t\t\t}\n+\t\tfor (TypeSearchVarInfo var : updatedVars) {\n \t\t\tTypeUpdateResult res = typeUpdate.applyWithWiderIgnSame(mth, var.getVar(), var.getCurrentType());\n \t\t\tif (res == TypeUpdateResult.REJECT) {\n \t\t\t\tmth.addComment(\"JADX DEBUG: Multi-variable search result rejected for \" + var);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java\n@@ -18,7 +18,6 @@ public void test() {\n \t\t\t\t.doesNotContain(\"z2 | 2\")\n \t\t\t\t.containsOne(\"(z2 ? 1 : 0) | 2\")\n \t\t\t\t.containsOne(\"if (z2 && formatCurrency != null) {\")\n-\t\t\t\t.containsOne(\"i = 1;\")\n-\t\t\t\t.containsOne(\"spannable = null;\");\n+\t\t\t\t.containsOne(\"i = 1;\");\n \t}\n }",
    "output": "Fix don't apply again already resolved types"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -290,6 +290,10 @@ public void addFallbackMethodCode(CodeWriter code, FallbackOption fallbackOption\n \t\t\tcode.startLine(\"// Can't load method instructions.\");\n \t\t\treturn;\n \t\t}\n+\t\tif (insnArr.length > 100) {\n+\t\t\tcode.startLine(\"// Method dump skipped, instructions count: \" + insnArr.length);\n+\t\t\treturn;\n+\t\t}\n \t\tcode.incIndent();\n \t\tif (mth.getThisArg() != null) {\n \t\t\tcode.startLine(nameGen.useArg(mth.getThisArg())).add(\" = this;\");\n@@ -305,6 +309,7 @@ public enum FallbackOption {\n \t}\n \n \tpublic static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[] insnArr, FallbackOption option) {\n+\t\tint startIndent = code.getIndent();\n \t\tInsnGen insnGen = new InsnGen(getFallbackMethodGen(mth), true);\n \t\tboolean attachInsns = mth.root().getArgs().isJsonOutput();\n \t\tInsnNode prevInsn = null;\n@@ -349,8 +354,9 @@ public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[]\n \t\t\t\tif (catchAttr != null) {\n \t\t\t\t\tcode.add(\"     // \" + catchAttr);\n \t\t\t\t}\n-\t\t\t} catch (CodegenException e) {\n+\t\t\t} catch (Exception e) {\n \t\t\t\tLOG.debug(\"Error generate fallback instruction: \", e.getCause());\n+\t\t\t\tcode.setIndent(startIndent);\n \t\t\t\tcode.startLine(\"// error: \" + insn);\n \t\t\t}\n \t\t\tprevInsn = insn;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java b/jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java\n@@ -1,5 +1,6 @@\n package jadx.core.dex.visitors;\n \n+import jadx.core.dex.attributes.AType;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.utils.DebugChecks;\n@@ -19,6 +20,9 @@ public static void visit(IDexTreeVisitor visitor, ClassNode cls) {\n \n \tpublic static void visit(IDexTreeVisitor visitor, MethodNode mth) {\n \t\ttry {\n+\t\t\tif (mth.contains(AType.JADX_ERROR)) {\n+\t\t\t\treturn;\n+\t\t\t}\n \t\t\tvisitor.visit(mth);\n \t\t\tif (DebugChecks.checksEnabled) {\n \t\t\t\tDebugChecks.runChecksAfterVisitor(mth, visitor);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n@@ -69,8 +69,7 @@ private static void processBlocksTree(MethodNode mth) {\n \t\t\tupdateExitBlocks(mth);\n \n \t\t\tif (i++ > 100) {\n-\t\t\t\tmth.addWarn(\"CFG modification limit reached, blocks count: \" + mth.getBasicBlocks().size());\n-\t\t\t\tbreak;\n+\t\t\t\tthrow new JadxRuntimeException(\"CFG modification limit reached, blocks count: \" + mth.getBasicBlocks().size());\n \t\t\t}\n \t\t}\n \t\tcheckForUnreachableBlocks(mth);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java\n@@ -34,6 +34,7 @@\n public class TypeSearch {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(TypeSearch.class);\n \n+\tprivate static final int VARS_PROCESS_LIMIT = 5_000;\n \tprivate static final int CANDIDATES_COUNT_LIMIT = 10;\n \tprivate static final int SEARCH_ITERATION_LIMIT = 1_000_000;\n \n@@ -50,6 +51,11 @@ public TypeSearch(MethodNode mth) {\n \t}\n \n \tpublic boolean run() {\n+\t\tif (mth.getSVars().size() > VARS_PROCESS_LIMIT) {\n+\t\t\tmth.addWarnComment(\"Multi-variable search skipped. Vars limit reached: \" + mth.getSVars().size()\n+\t\t\t\t\t+ \" (expected less than \" + VARS_PROCESS_LIMIT + \")\");\n+\t\t\treturn false;\n+\t\t}\n \t\tmth.getSVars().forEach(this::fillTypeCandidates);\n \t\tmth.getSVars().forEach(this::collectConstraints);",
    "output": "Fix adjust limits to skip processing of large methods"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n@@ -166,6 +166,27 @@ public List<PhiInsn> getUsedInPhi() {\n \t\treturn usedInPhi;\n \t}\n \n+\t/**\n+\t * Concat assign PHI insn and usedInPhi\n+\t */\n+\tpublic List<PhiInsn> getPhiList() {\n+\t\tInsnNode assignInsn = getAssign().getParentInsn();\n+\t\tif (assignInsn != null && assignInsn.getType() == InsnType.PHI) {\n+\t\t\tPhiInsn assignPhi = (PhiInsn) assignInsn;\n+\t\t\tif (usedInPhi == null) {\n+\t\t\t\treturn Collections.singletonList(assignPhi);\n+\t\t\t}\n+\t\t\tList<PhiInsn> list = new ArrayList<>(1 + usedInPhi.size());\n+\t\t\tlist.add(assignPhi);\n+\t\t\tlist.addAll(usedInPhi);\n+\t\t\treturn list;\n+\t\t}\n+\t\tif (usedInPhi == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\treturn usedInPhi;\n+\t}\n+\n \tpublic boolean isUsedInPhi() {\n \t\treturn usedInPhi != null && !usedInPhi.isEmpty();\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java b/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java\n@@ -70,11 +70,11 @@ public static void initCodeVar(SSAVar ssaVar) {\n \t}\n \n \tprivate static void setCodeVar(SSAVar ssaVar, CodeVar codeVar) {\n-\t\tList<PhiInsn> usedInPhiList = ssaVar.getUsedInPhi();\n-\t\tif (!usedInPhiList.isEmpty()) {\n+\t\tList<PhiInsn> phiList = ssaVar.getPhiList();\n+\t\tif (!phiList.isEmpty()) {\n \t\t\tSet<SSAVar> vars = new LinkedHashSet<>();\n \t\t\tvars.add(ssaVar);\n-\t\t\tcollectConnectedVars(usedInPhiList, vars);\n+\t\t\tcollectConnectedVars(phiList, vars);\n \t\t\tsetCodeVarType(codeVar, vars);\n \t\t\tvars.forEach(var -> {\n \t\t\t\tif (var.isCodeVarSet()) {\n@@ -105,15 +105,18 @@ private static void setCodeVarType(CodeVar codeVar, Set<SSAVar> vars) {\n \t}\n \n \tprivate static void collectConnectedVars(List<PhiInsn> phiInsnList, Set<SSAVar> vars) {\n+\t\tif (phiInsnList.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n \t\tfor (PhiInsn phiInsn : phiInsnList) {\n \t\t\tSSAVar resultVar = phiInsn.getResult().getSVar();\n \t\t\tif (vars.add(resultVar)) {\n-\t\t\t\tcollectConnectedVars(resultVar.getUsedInPhi(), vars);\n+\t\t\t\tcollectConnectedVars(resultVar.getPhiList(), vars);\n \t\t\t}\n \t\t\tphiInsn.getArguments().forEach(arg -> {\n \t\t\t\tSSAVar sVar = ((RegisterArg) arg).getSVar();\n \t\t\t\tif (vars.add(sVar)) {\n-\t\t\t\t\tcollectConnectedVars(sVar.getUsedInPhi(), vars);\n+\t\t\t\t\tcollectConnectedVars(sVar.getPhiList(), vars);\n \t\t\t\t}\n \t\t\t});\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesInLoop.java b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesInLoop.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesInLoop.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesInLoop.java\n@@ -0,0 +1,19 @@\n+package jadx.tests.integration.variables;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestVariablesInLoop extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"int i;\")\n+\t\t\t\t.countString(2, \"i = 0;\")\n+\t\t\t\t.doesNotContain(\"i3\");\n+\t}\n+}",
    "output": "Fix correct merge code variables across PHI instructions"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n@@ -151,6 +151,9 @@ public ArgType consumeType() {\n \t\t\t\tString typeVarName = consumeUntil(';');\n \t\t\t\tif (typeVarName != null) {\n \t\t\t\t\tconsume(';');\n+\t\t\t\t\tif (typeVarName.contains(\")\")) {\n+\t\t\t\t\t\tthrow new JadxRuntimeException(\"Bad name for type variable: \" + typeVarName);\n+\t\t\t\t\t}\n \t\t\t\t\treturn ArgType.genericType(typeVarName);\n \t\t\t\t}\n \t\t\t\tbreak;\n@@ -268,8 +271,7 @@ public List<ArgType> consumeGenericTypeParameters() {\n \t\t\t}\n \t\t\tString id = consumeUntil(':');\n \t\t\tif (id == null) {\n-\t\t\t\tLOG.error(\"Failed to parse generic types map: {}\", sign);\n-\t\t\t\treturn Collections.emptyList();\n+\t\t\t\tthrow new JadxRuntimeException(\"Failed to parse generic types map\");\n \t\t\t}\n \t\t\tconsume(':');\n \t\t\ttryConsume(':');\n@@ -290,9 +292,12 @@ private List<ArgType> consumeExtendsTypesList() {\n \t\tboolean next;\n \t\tdo {\n \t\t\tArgType argType = consumeType();\n+\t\t\tif (argType == null) {\n+\t\t\t\tthrow new JadxRuntimeException(\"Unexpected end of signature\");\n+\t\t\t}\n \t\t\tif (!argType.equals(ArgType.OBJECT)) {\n \t\t\t\tif (types.isEmpty()) {\n-\t\t\t\t\ttypes = new LinkedList<>();\n+\t\t\t\t\ttypes = new ArrayList<>();\n \t\t\t\t}\n \t\t\t\ttypes.add(argType);\n \t\t\t}\n@@ -304,15 +309,23 @@ private List<ArgType> consumeExtendsTypesList() {\n \t\treturn types;\n \t}\n \n-\tpublic List<ArgType> consumeMethodArgs() {\n+\tpublic List<ArgType> consumeMethodArgs(int argsCount) {\n \t\tconsume('(');\n \t\tif (lookAhead(')')) {\n \t\t\tconsume(')');\n \t\t\treturn Collections.emptyList();\n \t\t}\n-\t\tList<ArgType> args = new LinkedList<>();\n+\t\tList<ArgType> args = new ArrayList<>(argsCount);\n+\t\tint limit = argsCount + 10; // just prevent endless loop, args count can be different for synthetic methods\n \t\tdo {\n-\t\t\targs.add(consumeType());\n+\t\t\tArgType type = consumeType();\n+\t\t\tif (type == null) {\n+\t\t\t\tthrow new JadxRuntimeException(\"Unexpected end of signature\");\n+\t\t\t}\n+\t\t\targs.add(type);\n+\t\t\tif (args.size() > limit) {\n+\t\t\t\tthrow new JadxRuntimeException(\"Arguments count limit reached: \" + args.size());\n+\t\t\t}\n \t\t} while (!lookAhead(')'));\n \t\tconsume(')');\n \t\treturn args;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n@@ -103,7 +103,7 @@ private void parseMethodSignature(MethodNode mth) {\n \t\t}\n \t\ttry {\n \t\t\tList<ArgType> typeParameters = sp.consumeGenericTypeParameters();\n-\t\t\tList<ArgType> parsedArgTypes = sp.consumeMethodArgs();\n+\t\t\tList<ArgType> parsedArgTypes = sp.consumeMethodArgs(mth.getMethodInfo().getArgsCount());\n \t\t\tArgType parsedRetType = sp.consumeType();\n \n \t\t\tif (!validateParsedType(parsedRetType, mth.getMethodInfo().getReturnType())) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/functional/SignatureParserTest.java b/jadx-core/src/test/java/jadx/tests/functional/SignatureParserTest.java\n--- a/jadx-core/src/test/java/jadx/tests/functional/SignatureParserTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/functional/SignatureParserTest.java\n@@ -8,6 +8,7 @@\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.ArgType.WildcardBound;\n import jadx.core.dex.nodes.parser.SignatureParser;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n \n import static jadx.core.dex.instructions.args.ArgType.INT;\n import static jadx.core.dex.instructions.args.ArgType.OBJECT;\n@@ -19,6 +20,7 @@\n import static jadx.core.dex.instructions.args.ArgType.wildcard;\n import static java.util.Collections.emptyList;\n import static java.util.Collections.singletonList;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.hasSize;\n@@ -114,15 +116,15 @@ private static void checkGenerics(String g, Object... objs) {\n \n \t@Test\n \tpublic void testMethodArgs() {\n-\t\tList<ArgType> argTypes = new SignatureParser(\"(Ljava/util/List<*>;)V\").consumeMethodArgs();\n+\t\tList<ArgType> argTypes = new SignatureParser(\"(Ljava/util/List<*>;)V\").consumeMethodArgs(1);\n \n \t\tassertThat(argTypes, hasSize(1));\n \t\tassertThat(argTypes.get(0), is(generic(\"Ljava/util/List;\", wildcard())));\n \t}\n \n \t@Test\n \tpublic void testMethodArgs2() {\n-\t\tList<ArgType> argTypes = new SignatureParser(\"(La/b/C<TT;>.d/E;)V\").consumeMethodArgs();\n+\t\tList<ArgType> argTypes = new SignatureParser(\"(La/b/C<TT;>.d/E;)V\").consumeMethodArgs(1);\n \n \t\tassertThat(argTypes, hasSize(1));\n \t\tArgType argType = argTypes.get(0);\n@@ -132,7 +134,13 @@ public void testMethodArgs2() {\n \n \t@Test\n \tpublic void testBadGenericMap() {\n-\t\tList<ArgType> list = new SignatureParser(\"<A:Ljava/lang/Object;B\").consumeGenericTypeParameters();\n-\t\tassertThat(list, hasSize(0));\n+\t\tassertThatExceptionOfType(JadxRuntimeException.class)\n+\t\t\t\t.isThrownBy(() -> new SignatureParser(\"<A:Ljava/lang/Object;B\").consumeGenericTypeParameters());\n+\t}\n+\n+\t@Test\n+\tpublic void testBadArgs() {\n+\t\tassertThatExceptionOfType(JadxRuntimeException.class)\n+\t\t\t\t.isThrownBy(() -> new SignatureParser(\"(TCONTENT)Lpkg/Cls;\").consumeMethodArgs(1));\n \t}\n }",
    "output": "Fix prevent endless loop in method signature parsing"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourceType.java b/jadx-core/src/main/java/jadx/api/ResourceType.java\n--- a/jadx-core/src/main/java/jadx/api/ResourceType.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourceType.java\n@@ -1,14 +1,20 @@\n package jadx.api;\n \n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n+\n public enum ResourceType {\n \tCODE(\".dex\", \".jar\", \".class\"),\n-\tMANIFEST(\"AndroidManifest.xml\"),\n \tXML(\".xml\"),\n \tARSC(\".arsc\"),\n \tFONT(\".ttf\", \".otf\"),\n \tIMG(\".png\", \".gif\", \".jpg\"),\n \tMEDIA(\".mp3\", \".wav\"),\n \tLIB(\".so\"),\n+\tMANIFEST,\n \tUNKNOWN;\n \n \tprivate final String[] exts;\n@@ -21,12 +27,29 @@ public String[] getExts() {\n \t\treturn exts;\n \t}\n \n-\tpublic static ResourceType getFileType(String fileName) {\n+\tprivate static final Map<String, ResourceType> EXT_MAP = new HashMap<>();\n+\n+\tstatic {\n \t\tfor (ResourceType type : ResourceType.values()) {\n \t\t\tfor (String ext : type.getExts()) {\n-\t\t\t\tif (fileName.toLowerCase().endsWith(ext)) {\n-\t\t\t\t\treturn type;\n+\t\t\t\tResourceType prev = EXT_MAP.put(ext, type);\n+\t\t\t\tif (prev != null) {\n+\t\t\t\t\tthrow new JadxRuntimeException(\"Duplicate extension in ResourceType: \" + ext);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static ResourceType getFileType(String fileName) {\n+\t\tint dot = fileName.lastIndexOf('.');\n+\t\tif (dot != -1) {\n+\t\t\tString ext = fileName.substring(dot).toLowerCase(Locale.ROOT);\n+\t\t\tResourceType resType = EXT_MAP.get(ext);\n+\t\t\tif (resType != null) {\n+\t\t\t\tif (resType == XML && fileName.equals(\"AndroidManifest.xml\")) {\n+\t\t\t\t\treturn MANIFEST;\n \t\t\t\t}\n+\t\t\t\treturn resType;\n \t\t\t}\n \t\t}\n \t\treturn UNKNOWN;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n@@ -143,11 +143,6 @@ public List<ResourceFile> getResources() {\n \t\treturn decompiler.getResources();\n \t}\n \n-\t@Deprecated\n-\tpublic File getOpenFile() {\n-\t\treturn openPaths.get(0).toFile();\n-\t}\n-\n \tpublic List<Path> getOpenPaths() {\n \t\treturn openPaths;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/ApkSignature.java b/jadx-gui/src/main/java/jadx/gui/treemodel/ApkSignature.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/ApkSignature.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/ApkSignature.java\n@@ -15,6 +15,8 @@\n \n import com.android.apksig.ApkVerifier;\n \n+import jadx.api.ResourceFile;\n+import jadx.api.ResourceType;\n import jadx.gui.JadxWrapper;\n import jadx.gui.utils.CertificateManager;\n import jadx.gui.utils.NLS;\n@@ -33,11 +35,20 @@ public class ApkSignature extends JNode {\n \tpublic static ApkSignature getApkSignature(JadxWrapper wrapper) {\n \t\t// Only show the ApkSignature node if an AndroidManifest.xml is present.\n \t\t// Without a manifest the Google ApkVerifier refuses to work.\n-\t\tif (wrapper.getResources().stream().noneMatch(r -> \"AndroidManifest.xml\".equals(r.getOriginalName()))) {\n+\t\tFile apkFile = null;\n+\t\tfor (ResourceFile resFile : wrapper.getResources()) {\n+\t\t\tif (resFile.getType() == ResourceType.MANIFEST) {\n+\t\t\t\tResourceFile.ZipRef zipRef = resFile.getZipRef();\n+\t\t\t\tif (zipRef != null) {\n+\t\t\t\t\tapkFile = zipRef.getZipFile();\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (apkFile == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tFile openFile = wrapper.getOpenFile();\n-\t\treturn new ApkSignature(openFile);\n+\t\treturn new ApkSignature(apkFile);\n \t}\n \n \tpublic ApkSignature(File openFile) {",
    "output": "Fix improve resource type detection and remove deprecated method"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -586,6 +586,10 @@ private boolean trySplitConstInsns(MethodNode mth) {\n \t}\n \n \tprivate boolean checkAndSplitConstInsn(MethodNode mth, SSAVar var) {\n+\t\tArgType type = var.getTypeInfo().getType();\n+\t\tif (type.isTypeKnown() || var.isTypeImmutable()) {\n+\t\t\treturn false;\n+\t\t}\n \t\tif (var.getUsedInPhi().size() < 2) {\n \t\t\treturn false;\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java\n@@ -17,6 +17,8 @@ public void test() {\n \t\t\t\t.doesNotContain(\"z2 == 0\")\n \t\t\t\t.doesNotContain(\"z2 | 2\")\n \t\t\t\t.containsOne(\"(z2 ? 1 : 0) | 2\")\n-\t\t\t\t.containsOne(\"if (z2 && formatCurrency != null) {\");\n+\t\t\t\t.containsOne(\"if (z2 && formatCurrency != null) {\")\n+\t\t\t\t.containsOne(\"i = 1;\")\n+\t\t\t\t.containsOne(\"spannable = null;\");\n \t}\n }",
    "output": "Fix don't apply const split if not needed"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n@@ -676,6 +676,18 @@ public boolean canBePrimitive(PrimitiveType primitiveType) {\n \t\t\t\t|| (!isTypeKnown() && contains(primitiveType));\n \t}\n \n+\tpublic boolean canBeAnyNumber() {\n+\t\tif (isPrimitive()) {\n+\t\t\treturn !getPrimitiveType().isObjectOrArray();\n+\t\t}\n+\t\tfor (PrimitiveType primitiveType : getPossibleTypes()) {\n+\t\t\tif (!primitiveType.isObjectOrArray()) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tpublic static ArgType convertFromPrimitiveType(PrimitiveType primitiveType) {\n \t\tswitch (primitiveType) {\n \t\t\tcase BOOLEAN:\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/PrimitiveType.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/PrimitiveType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/PrimitiveType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/PrimitiveType.java\n@@ -33,4 +33,8 @@ public String getLongName() {\n \tpublic String toString() {\n \t\treturn longName;\n \t}\n+\n+\tpublic boolean isObjectOrArray() {\n+\t\treturn this == OBJECT || this == ARRAY;\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -783,16 +783,21 @@ private boolean processIncompatiblePrimitives(MethodNode mth, SSAVar var) {\n \t\tif (typeInfo.getType().isTypeKnown()) {\n \t\t\treturn false;\n \t\t}\n-\t\tboolean boolAssign = false;\n \t\tfor (ITypeBound bound : typeInfo.getBounds()) {\n-\t\t\tif (bound.getBound() == BoundEnum.ASSIGN && bound.getType().equals(ArgType.BOOLEAN)) {\n-\t\t\t\tboolAssign = true;\n-\t\t\t\tbreak;\n+\t\t\tArgType boundType = bound.getType();\n+\t\t\tswitch (bound.getBound()) {\n+\t\t\t\tcase ASSIGN:\n+\t\t\t\t\tif (!boundType.contains(PrimitiveType.BOOLEAN)) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase USE:\n+\t\t\t\t\tif (!boundType.canBeAnyNumber()) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tif (!boolAssign) {\n-\t\t\treturn false;\n-\t\t}\n \n \t\tboolean fixed = false;\n \t\tfor (ITypeBound bound : typeInfo.getBounds()) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion2.java\n@@ -0,0 +1,22 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestPrimitiveConversion2 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"boolean z2 = !convertedPrice2.code.equals(itemCurrency.code);\")\n+\t\t\t\t.doesNotContain(\"z2 == 0\")\n+\t\t\t\t.doesNotContain(\"z2 | 2\")\n+\t\t\t\t.containsOne(\"(z2 ? 1 : 0) | 2\")\n+\t\t\t\t.containsOne(\"if (z2 && formatCurrency != null) {\");\n+\t}\n+}",
    "output": "Fix improve checks for boolean to int conversion"
  },
  {
    "input": "diff --git a/jadx-cli/src/test/java/jadx/cli/TestInput.java b/jadx-cli/src/test/java/jadx/cli/TestInput.java\n--- a/jadx-cli/src/test/java/jadx/cli/TestInput.java\n+++ b/jadx-cli/src/test/java/jadx/cli/TestInput.java\n@@ -10,6 +10,7 @@\n import java.util.List;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n+\n import org.junit.jupiter.api.AfterAll;\n import org.junit.jupiter.api.Test;\n import org.slf4j.Logger;\n@@ -59,14 +60,28 @@ private void decompile(String tmpDirName, String... inputSamples) throws URISynt\n \t\tassertThat(result).isEqualTo(0);\n \t\tList<Path> resultJavaFiles = collectJavaFilesInDir(tempDir);\n \t\tassertThat(resultJavaFiles).isNotEmpty();\n+\n+\t\t// do not copy input files as resources\n+\t\tPathMatcher logAllFiles = path -> {\n+\t\t\tLOG.debug(\"File in result dir: {}\", path);\n+\t\t\treturn true;\n+\t\t};\n+\t\tfor (Path path : collectFilesInDir(tempDir, logAllFiles)) {\n+\t\t\tfor (String inputSample : inputSamples) {\n+\t\t\t\tassertThat(path.toAbsolutePath().toString()).doesNotContain(inputSample);\n+\t\t\t}\n+\t\t}\n \t}\n \n \tprivate static List<Path> collectJavaFilesInDir(Path dir) throws IOException {\n-\t\tPathMatcher matcher = dir.getFileSystem().getPathMatcher(\"glob:**.java\");\n+\t\tPathMatcher javaMatcher = dir.getFileSystem().getPathMatcher(\"glob:**.java\");\n+\t\treturn collectFilesInDir(dir, javaMatcher);\n+\t}\n+\n+\tprivate static List<Path> collectFilesInDir(Path dir, PathMatcher matcher) throws IOException {\n \t\ttry (Stream<Path> pathStream = Files.walk(dir)) {\n \t\t\treturn pathStream\n \t\t\t\t\t.filter(p -> Files.isRegularFile(p, LinkOption.NOFOLLOW_LINKS))\n-\t\t\t\t\t.peek(f -> LOG.debug(\"File in result dir: {}\", f))\n \t\t\t\t\t.filter(matcher::matches)\n \t\t\t\t\t.collect(Collectors.toList());\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -11,6 +11,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n@@ -210,7 +211,13 @@ private ExecutorService getSaveExecutor(boolean saveSources, boolean saveResourc\n \t}\n \n \tprivate void appendResourcesSave(ExecutorService executor, File outDir) {\n+\t\tSet<String> inputFileNames = args.getInputFiles().stream().map(File::getAbsolutePath).collect(Collectors.toSet());\n \t\tfor (ResourceFile resourceFile : getResources()) {\n+\t\t\tif (resourceFile.getType() != ResourceType.ARSC\n+\t\t\t\t\t&& inputFileNames.contains(resourceFile.getOriginalName())) {\n+\t\t\t\t// ignore resource made from input file\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\texecutor.execute(new ResourcesSaver(outDir, resourceFile));\n \t\t}\n \t}",
    "output": "Fix do not copy input files as resources to output folder"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n@@ -67,7 +67,7 @@ public enum AFlag {\n \t */\n \tEXPLICIT_PRIMITIVE_TYPE,\n \tEXPLICIT_CAST,\n-\tSOFT_CAST, // synthetic cast to help type inference\n+\tSOFT_CAST, // synthetic cast to help type inference (allow unchecked casts for generics)\n \n \tINCONSISTENT_CODE, // warning about incorrect decompilation\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n@@ -206,6 +206,10 @@ public static InsnArg wrapArg(InsnNode insn) {\n \t\treturn arg;\n \t}\n \n+\tpublic boolean isZeroLiteral() {\n+\t\treturn isLiteral() && (((LiteralArg) this)).getLiteral() == 0;\n+\t}\n+\n \tpublic boolean isThis() {\n \t\treturn contains(AFlag.THIS);\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -29,7 +29,6 @@\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.InsnWrapArg;\n-import jadx.core.dex.instructions.args.LiteralArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n import jadx.core.dex.instructions.args.SSAVar;\n import jadx.core.dex.instructions.mods.ConstructorInsn;\n@@ -209,7 +208,7 @@ private List<EnumField> extractEnumFieldsFromInsn(ClassNode cls, BlockNode stati\n \n \t\t\tcase NEW_ARRAY:\n \t\t\t\tInsnArg arg = wrappedInsn.getArg(0);\n-\t\t\t\tif (arg.isLiteral() && ((LiteralArg) arg).getLiteral() == 0) {\n+\t\t\t\tif (arg.isZeroLiteral()) {\n \t\t\t\t\t// empty enum\n \t\t\t\t\treturn Collections.emptyList();\n \t\t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -260,8 +260,7 @@ private static void simplifyIf(IfNode insn) {\n \t\tif (f.isInsnWrap()) {\n \t\t\tInsnNode wi = ((InsnWrapArg) f).getWrapInsn();\n \t\t\tif (wi.getType() == InsnType.CMP_L || wi.getType() == InsnType.CMP_G) {\n-\t\t\t\tif (insn.getArg(1).isLiteral()\n-\t\t\t\t\t\t&& ((LiteralArg) insn.getArg(1)).getLiteral() == 0) {\n+\t\t\t\tif (insn.getArg(1).isZeroLiteral()) {\n \t\t\t\t\tinsn.changeCondition(insn.getOp(), wi.getArg(0), wi.getArg(1));\n \t\t\t\t} else {\n \t\t\t\t\tLOG.warn(\"TODO: cmp {}\", insn);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -10,6 +10,7 @@\n import java.util.Set;\n import java.util.function.Function;\n \n+import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -332,6 +333,10 @@ private ITypeBound makeUseBound(RegisterArg regArg) {\n \t\t\t\treturn invokeUseBound;\n \t\t\t}\n \t\t}\n+\t\tif (insn.getType() == InsnType.CHECK_CAST && insn.contains(AFlag.SOFT_CAST)) {\n+\t\t\t// ignore\n+\t\t\treturn null;\n+\t\t}\n \t\treturn new TypeBoundConst(BoundEnum.USE, regArg.getInitType(), regArg);\n \t}\n \n@@ -499,20 +504,30 @@ private int tryInsertVarCast(MethodNode mth, SSAVar var) {\n \t\t\t\tif (insertAssignCast(mth, var, boundType)) {\n \t\t\t\t\treturn 1;\n \t\t\t\t}\n-\t\t\t\t// TODO: check if use casts are needed\n-\t\t\t\treturn 0;\n+\t\t\t\treturn insertUseCasts(mth, var);\n \t\t\t}\n \t\t}\n \t\treturn 0;\n \t}\n \n+\tprivate int insertUseCasts(MethodNode mth, SSAVar var) {\n+\t\tList<RegisterArg> useList = var.getUseList();\n+\t\tif (useList.isEmpty()) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tint useCasts = 0;\n+\t\tfor (RegisterArg useReg : new ArrayList<>(useList)) {\n+\t\t\tif (insertSoftUseCast(mth, useReg)) {\n+\t\t\t\tuseCasts++;\n+\t\t\t}\n+\t\t}\n+\t\treturn useCasts;\n+\t}\n+\n \tprivate boolean insertAssignCast(MethodNode mth, SSAVar var, ArgType castType) {\n \t\tRegisterArg assignArg = var.getAssign();\n \t\tInsnNode assignInsn = assignArg.getParentInsn();\n-\t\tif (assignInsn == null) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (assignInsn.getType() == InsnType.PHI) {\n+\t\tif (assignInsn == null || assignInsn.getType() == InsnType.PHI) {\n \t\t\treturn false;\n \t\t}\n \t\tBlockNode assignBlock = BlockUtils.getBlockByInsn(mth, assignInsn);\n@@ -521,14 +536,38 @@ private boolean insertAssignCast(MethodNode mth, SSAVar var, ArgType castType) {\n \t\t}\n \t\tRegisterArg newAssignArg = assignArg.duplicateWithNewSSAVar(mth);\n \t\tassignInsn.setResult(newAssignArg);\n+\t\tIndexInsnNode castInsn = makeSoftCastInsn(assignArg, newAssignArg, castType);\n+\t\treturn BlockUtils.insertAfterInsn(assignBlock, assignInsn, castInsn);\n+\t}\n+\n+\tprivate boolean insertSoftUseCast(MethodNode mth, RegisterArg useArg) {\n+\t\tInsnNode useInsn = useArg.getParentInsn();\n+\t\tif (useInsn == null || useInsn.getType() == InsnType.PHI) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (useInsn.getType() == InsnType.IF && useInsn.getArg(1).isZeroLiteral()) {\n+\t\t\t// cast not needed if compare with null\n+\t\t\treturn false;\n+\t\t}\n+\t\tBlockNode useBlock = BlockUtils.getBlockByInsn(mth, useInsn);\n+\t\tif (useBlock == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tRegisterArg newUseArg = useArg.duplicateWithNewSSAVar(mth);\n+\t\tuseInsn.replaceArg(useArg, newUseArg);\n+\n+\t\tIndexInsnNode castInsn = makeSoftCastInsn(newUseArg, useArg, useArg.getInitType());\n+\t\treturn BlockUtils.insertBeforeInsn(useBlock, useInsn, castInsn);\n+\t}\n \n+\t@NotNull\n+\tprivate IndexInsnNode makeSoftCastInsn(RegisterArg result, RegisterArg arg, ArgType castType) {\n \t\tIndexInsnNode castInsn = new IndexInsnNode(InsnType.CHECK_CAST, castType, 1);\n-\t\tcastInsn.setResult(assignArg.duplicate());\n-\t\tcastInsn.addArg(newAssignArg.duplicate());\n+\t\tcastInsn.setResult(result.duplicate());\n+\t\tcastInsn.addArg(arg.duplicate());\n \t\tcastInsn.add(AFlag.SOFT_CAST);\n \t\tcastInsn.add(AFlag.SYNTHETIC);\n-\n-\t\treturn BlockUtils.insertAfterInsn(assignBlock, assignInsn, castInsn);\n+\t\treturn castInsn;\n \t}\n \n \tprivate boolean trySplitConstInsns(MethodNode mth) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -670,17 +670,33 @@ public static boolean replaceInsn(MethodNode mth, BlockNode block, InsnNode oldI\n \t\treturn false;\n \t}\n \n+\tpublic static boolean insertBeforeInsn(BlockNode block, InsnNode insn, InsnNode newInsn) {\n+\t\tint index = getInsnIndexInBlock(block, insn);\n+\t\tif (index == -1) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tblock.getInstructions().add(index, newInsn);\n+\t\treturn true;\n+\t}\n+\n \tpublic static boolean insertAfterInsn(BlockNode block, InsnNode insn, InsnNode newInsn) {\n+\t\tint index = getInsnIndexInBlock(block, insn);\n+\t\tif (index == -1) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tblock.getInstructions().add(index + 1, newInsn);\n+\t\treturn true;\n+\t}\n+\n+\tpublic static int getInsnIndexInBlock(BlockNode block, InsnNode insn) {\n \t\tList<InsnNode> instructions = block.getInstructions();\n \t\tint size = instructions.size();\n \t\tfor (int i = 0; i < size; i++) {\n-\t\t\tInsnNode instruction = instructions.get(i);\n-\t\t\tif (instruction == insn) {\n-\t\t\t\tinstructions.add(i + 1, newInsn);\n-\t\t\t\treturn true;\n+\t\t\tif (instructions.get(i) == insn) {\n+\t\t\t\treturn i;\n \t\t\t}\n \t\t}\n-\t\treturn false;\n+\t\treturn -1;\n \t}\n \n \tpublic static boolean replaceInsn(MethodNode mth, InsnNode oldInsn, InsnNode newInsn) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n@@ -169,4 +169,8 @@ public static void printMap(Map<?, ?> map, String desc) {\n \t\t\tLOG.debug(\"  {}: {}\", entry.getKey(), entry.getValue());\n \t\t}\n \t}\n+\n+\tpublic static void printStackTrace(String label) {\n+\t\tLOG.debug(\"StackTrace: {}\\n{}\", label, Utils.getStackTrace(new Exception()));\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver16.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver16.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver16.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver16.java\n@@ -0,0 +1,35 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+/**\n+ * Issue 1002\n+ * Insertion of additional cast (at use place) needed for successful type inference\n+ */\n+public class TestTypeResolver16 extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tpublic final <T, K> List<T> test(List<? extends T> list, Set<? extends T> set, Function<? super T, ? extends K> function) {\n+\t\t\tcheckParameterIsNotNull(function, \"distinctBy\");\n+\t\t\tif (set != null) {\n+\t\t\t\tList<? extends T> union = list != null ? union(list, set, function) : null;\n+\t\t\t\tif (union != null) {\n+\t\t\t\t\tlist = union;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn list != null ? (List<T>) list : emptyList();\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"(List<T>) list\");\n+\t}\n+}",
    "output": "Fix additional casts at use place to help type inference"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -509,6 +509,12 @@ private int tryInsertVarCast(MethodNode mth, SSAVar var) {\n \tprivate boolean insertAssignCast(MethodNode mth, SSAVar var, ArgType castType) {\n \t\tRegisterArg assignArg = var.getAssign();\n \t\tInsnNode assignInsn = assignArg.getParentInsn();\n+\t\tif (assignInsn == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (assignInsn.getType() == InsnType.PHI) {\n+\t\t\treturn false;\n+\t\t}\n \t\tBlockNode assignBlock = BlockUtils.getBlockByInsn(mth, assignInsn);\n \t\tif (assignBlock == null) {\n \t\t\treturn false;",
    "output": "Fix don't add cast for PHI insn"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n--- a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n@@ -96,7 +96,7 @@ private static ResContainer loadContent(JadxDecompiler jadxRef, ResourceFile rf,\n \t\t\tcase MANIFEST:\n \t\t\tcase XML:\n \t\t\t\tICodeInfo content = jadxRef.getXmlParser().parse(inputStream);\n-\t\t\t\treturn ResContainer.textResource(rf.getOriginalName(), content);\n+\t\t\t\treturn ResContainer.textResource(rf.getDeobfName(), content);\n \n \t\t\tcase ARSC:\n \t\t\t\treturn new ResTableParser(jadxRef.getRoot()).decodeFiles(inputStream);",
    "output": "Fix deobfuscated resource text files saving Co-authored-by: sergey-wowwow <bugi@MacBook-Pro.local>"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -586,7 +586,7 @@ public void setLoadStage(LoadStage loadStage) {\n \tpublic void reloadAtCodegenStage() {\n \t\tClassNode topCls = this.getTopParentClass();\n \t\tif (topCls.getLoadStage() == LoadStage.CODEGEN_STAGE) {\n-\t\t\tthrow new JadxRuntimeException(\"Class not yet loaded at codegen stage\");\n+\t\t\tthrow new JadxRuntimeException(\"Class not yet loaded at codegen stage: \" + topCls);\n \t\t}\n \t\ttopCls.add(AFlag.RELOAD_AT_CODEGEN_STAGE);\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java b/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/InlineMethods.java\n@@ -57,15 +57,15 @@ private void processInvokeInsn(MethodNode mth, BlockNode block, InvokeNode insn)\n \t\t\tMethodInlineAttr mia = MarkMethodsForInline.process(callMth);\n \t\t\tif (mia == null) {\n \t\t\t\t// method not yet loaded => will retry at codegen stage\n-\t\t\t\tmth.getParentClass().reloadAtCodegenStage();\n+\t\t\t\tcallMth.getParentClass().reloadAtCodegenStage();\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tif (mia.notNeeded()) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tinlineMethod(mth, callMth, mia, block, insn);\n \t\t} catch (Exception e) {\n-\t\t\tthrow new JadxRuntimeException(\"Failed to process method for inline\", e);\n+\t\t\tthrow new JadxRuntimeException(\"Failed to process method for inline: \" + callMthInfo, e);\n \t\t}\n \t}",
    "output": "Fix reload request for correct class in method inline visitor"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -88,7 +88,9 @@\n import jadx.gui.settings.JadxSettingsWindow;\n import jadx.gui.treemodel.ApkSignature;\n import jadx.gui.treemodel.JClass;\n+import jadx.gui.treemodel.JField;\n import jadx.gui.treemodel.JLoadableNode;\n+import jadx.gui.treemodel.JMethod;\n import jadx.gui.treemodel.JNode;\n import jadx.gui.treemodel.JPackage;\n import jadx.gui.treemodel.JResource;\n@@ -614,7 +616,7 @@ private void treeRightClickAction(MouseEvent e) {\n \t\tif (obj instanceof JPackage) {\n \t\t\tJPackagePopupMenu menu = new JPackagePopupMenu(this, (JPackage) obj);\n \t\t\tmenu.show(e.getComponent(), e.getX(), e.getY());\n-\t\t} else if (obj != null) {\n+\t\t} else if (obj instanceof JClass || obj instanceof JField || obj instanceof JMethod) {\n \t\t\tJPopupMenu menu = new JPopupMenu();\n \t\t\tJMenuItem jmi = new JMenuItem(NLS.str(\"popup.rename\"));\n \t\t\tjmi.addActionListener(action -> rename(obj));",
    "output": "Fix only show renaming option for JClass, JField and JMethod"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -512,7 +512,7 @@ public void initTree() {\n \t}\n \n \tprivate void clearTree() {\n-\t\ttabbedPane.closeAllTabs();\n+\t\ttabbedPane.reset();\n \t\tresetCache();\n \t\ttreeRoot = null;\n \t\ttreeModel.setRoot(null);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n@@ -214,4 +214,10 @@ public void loadSettings() {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tpublic void reset() {\n+\t\tcloseAllTabs();\n+\t\topenTabs.clear();\n+\t\tjumps.reset();\n+\t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java b/jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java\n@@ -87,4 +87,8 @@ public JumpPosition getNext() {\n \t\tcurrentPos = newPos;\n \t\treturn position;\n \t}\n+\n+\tpublic void reset() {\n+\t\tlist.clear();\n+\t}\n }",
    "output": "Fix clear jumps history on file close"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourceFile.java b/jadx-core/src/main/java/jadx/api/ResourceFile.java\n--- a/jadx-core/src/main/java/jadx/api/ResourceFile.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java\n@@ -72,7 +72,7 @@ void setZipRef(ZipRef zipRef) {\n \n \tpublic void setAlias(ResourceEntry ri) {\n \t\tint index = name.lastIndexOf('.');\n-\t\tdeobfName = String.format(\"%s%s/%s%s\",\n+\t\tdeobfName = String.format(\"res/%s%s/%s%s\",\n \t\t\t\tri.getTypeName(),\n \t\t\t\tri.getConfig(),\n \t\t\t\tri.getKeyName(),",
    "output": "Fix put deobfuscated files to res/ folder"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n@@ -137,8 +137,8 @@ private void writeDeobfMapFile(Path deobfMapPath, List<String> deobfMap) throws\n \t\tFile tmpFile = File.createTempFile(\"deobf_tmp_\", \".txt\");\n \t\ttry (FileOutputStream fileOut = new FileOutputStream(tmpFile)) {\n \t\t\tfor (String entry : deobfMap) {\n-\t\t\t\tfileOut.write(entry.getBytes());\n-\t\t\t\tfileOut.write(System.lineSeparator().getBytes());\n+\t\t\t\tfileOut.write(entry.getBytes(StandardCharsets.UTF_8));\n+\t\t\t\tfileOut.write(System.lineSeparator().getBytes(StandardCharsets.UTF_8));\n \t\t\t}\n \t\t}\n \t\tFile oldMap = File.createTempFile(\"deobf_bak_\", \".txt\");",
    "output": "Use correct charset when writing mapping file"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -167,6 +167,8 @@ private boolean convertToEnum(ClassNode cls) {\n \t\tInsnRemover.removeAllAndUnbind(classInitMth, staticBlock, toRemove);\n \t\tif (classInitMth.countInsns() == 0) {\n \t\t\tclassInitMth.add(AFlag.DONT_GENERATE);\n+\t\t} else if (!toRemove.isEmpty()) {\n+\t\t\tCodeShrinkVisitor.shrinkMethod(classInitMth);\n \t\t}\n \t\tremoveEnumMethods(cls, clsType, valuesField);\n \t\treturn true;\n@@ -263,13 +265,14 @@ private List<EnumField> extractEnumFieldsFromFilledArray(ClassNode cls, InsnNode\n \t\t\t\tInsnNode wrappedInsn = ((InsnWrapArg) arg).getWrapInsn();\n \t\t\t\tfield = processEnumFieldByField(cls, wrappedInsn, staticBlock, toRemove);\n \t\t\t} else if (arg.isRegister()) {\n-\t\t\t\tfield = processEnumFiledByRegister(cls, (RegisterArg) arg, toRemove);\n+\t\t\t\tfield = processEnumFiledByRegister(cls, (RegisterArg) arg, staticBlock, toRemove);\n \t\t\t}\n \t\t\tif (field == null) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tenumFields.add(field);\n \t\t}\n+\t\ttoRemove.add(arrFillInsn);\n \t\treturn enumFields;\n \t}\n \n@@ -292,13 +295,21 @@ private EnumField processEnumFieldByField(ClassNode cls, InsnNode sgetInsn, Bloc\n \t\tif (co == null) {\n \t\t\treturn null;\n \t\t}\n-\t\ttoRemove.add(sgetInsn);\n+\t\tRegisterArg sgetResult = sgetInsn.getResult();\n+\t\tif (sgetResult == null || sgetResult.getSVar().getUseCount() == 1) {\n+\t\t\ttoRemove.add(sgetInsn);\n+\t\t}\n \t\ttoRemove.add(sputInsn);\n \t\treturn createEnumFieldByConstructor(cls, enumFieldNode, co);\n \t}\n \n \t@Nullable\n-\tprivate EnumField processEnumFiledByRegister(ClassNode cls, RegisterArg arg, List<InsnNode> toRemove) {\n+\tprivate EnumField processEnumFiledByRegister(ClassNode cls, RegisterArg arg, BlockNode staticBlock, List<InsnNode> toRemove) {\n+\t\tInsnNode assignInsn = arg.getAssignInsn();\n+\t\tif (assignInsn != null && assignInsn.getType() == InsnType.SGET) {\n+\t\t\treturn processEnumFieldByField(cls, assignInsn, staticBlock, toRemove);\n+\t\t}\n+\n \t\tSSAVar ssaVar = arg.getSVar();\n \t\tif (ssaVar.getUseCount() == 1) {\n \t\t\treturn null;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums8.java b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums8.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums8.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums8.java\n@@ -0,0 +1,17 @@\n+package jadx.tests.integration.enums;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestEnums8 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"enum TestEnums8\");\n+\t}\n+}",
    "output": "Fix added another enum restore pattern"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n@@ -310,12 +310,19 @@ private void initUI() {\n \t\tcontentPane.add(buttonPane, BorderLayout.PAGE_END);\n \n \t\tsetTitle(NLS.str(\"popup.rename\"));\n+\t\tif (!mainWindow.getSettings().loadWindowPos(this)) {\n+\t\t\tsetSize(800, 80);\n+\t\t}\n+\t\t// always pack (ignore saved windows sizes)\n \t\tpack();\n-\t\tsetSize(800, 80);\n \t\tsetLocationRelativeTo(null);\n \t\tsetDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n-\t\tsetModalityType(ModalityType.MODELESS);\n+\t\tsetModalityType(ModalityType.APPLICATION_MODAL);\n+\t}\n \n-\t\tmainWindow.getSettings().loadWindowPos(this);\n+\t@Override\n+\tpublic void dispose() {\n+\t\tmainWindow.getSettings().saveWindowPos(this);\n+\t\tsuper.dispose();\n \t}\n }",
    "output": "Fix rename dialog pack"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JavaClass.java b/jadx-core/src/main/java/jadx/api/JavaClass.java\n--- a/jadx-core/src/main/java/jadx/api/JavaClass.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java\n@@ -59,9 +59,7 @@ public void decompile() {\n \n \tpublic synchronized void refresh() {\n \t\tlistsLoaded = false;\n-\t\tcls.unload();\n-\t\tcls.deepUnload();\n-\t\tcls.reRunDecompile();\n+\t\tcls.reloadCode();\n \t}\n \n \tpublic synchronized String getSmali() {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -225,13 +225,10 @@ public ICodeInfo getCode() {\n \t\treturn decompile(true);\n \t}\n \n-\tpublic synchronized ICodeInfo reRunDecompile() {\n-\t\treturn decompile(false);\n-\t}\n-\n \tpublic synchronized ICodeInfo reloadCode() {\n \t\tunload();\n \t\tdeepUnload();\n+\t\troot.runPreDecompileStageForClass(this);\n \t\treturn decompile(false);\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -44,6 +44,7 @@ public class RootNode {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(RootNode.class);\n \n \tprivate final JadxArgs args;\n+\tprivate final List<IDexTreeVisitor> preDecompilePasses;\n \tprivate final List<IDexTreeVisitor> passes;\n \n \tprivate final ErrorsCounter errorsCounter = new ErrorsCounter();\n@@ -68,6 +69,7 @@ public class RootNode {\n \n \tpublic RootNode(JadxArgs args) {\n \t\tthis.args = args;\n+\t\tthis.preDecompilePasses = Jadx.getPreDecompilePassesList();\n \t\tthis.passes = Jadx.getPassesList(args);\n \t\tthis.stringUtils = new StringUtils(args);\n \t\tthis.constValues = new ConstStorage(args);\n@@ -191,7 +193,7 @@ private void initInnerClasses() {\n \t}\n \n \tpublic void runPreDecompileStage() {\n-\t\tfor (IDexTreeVisitor pass : Jadx.getPreDecompilePassesList()) {\n+\t\tfor (IDexTreeVisitor pass : preDecompilePasses) {\n \t\t\ttry {\n \t\t\t\tpass.init(this);\n \t\t\t} catch (Exception e) {\n@@ -203,6 +205,12 @@ public void runPreDecompileStage() {\n \t\t}\n \t}\n \n+\tpublic void runPreDecompileStageForClass(ClassNode cls) {\n+\t\tfor (IDexTreeVisitor pass : preDecompilePasses) {\n+\t\t\tDepthTraversal.visit(pass, cls);\n+\t\t}\n+\t}\n+\n \tpublic List<ClassNode> getClasses() {\n \t\treturn classes;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SignatureProcessor.java\n@@ -14,6 +14,7 @@\n import jadx.core.dex.nodes.utils.TypeUtils;\n import jadx.core.dex.visitors.typeinference.TypeCompareEnum;\n import jadx.core.utils.Utils;\n+import jadx.core.utils.exceptions.JadxException;\n \n import static java.util.Collections.unmodifiableList;\n \n@@ -24,19 +25,18 @@ public class SignatureProcessor extends AbstractVisitor {\n \t@Override\n \tpublic void init(RootNode root) {\n \t\tthis.root = root;\n-\t\tfor (ClassNode cls : this.root.getClasses()) {\n-\t\t\tprocessCls(cls);\n-\t\t}\n \t}\n \n-\tprivate void processCls(ClassNode cls) {\n+\t@Override\n+\tpublic boolean visit(ClassNode cls) throws JadxException {\n \t\tparseClassSignature(cls);\n \t\tfor (FieldNode field : cls.getFields()) {\n \t\t\tparseFieldSignature(field);\n \t\t}\n \t\tfor (MethodNode mth : cls.getMethods()) {\n \t\t\tparseMethodSignature(mth);\n \t\t}\n+\t\treturn true;\n \t}\n \n \tprivate void parseClassSignature(ClassNode cls) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/rename/TestFieldWithGenericRename.java b/jadx-core/src/test/java/jadx/tests/integration/rename/TestFieldWithGenericRename.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/rename/TestFieldWithGenericRename.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/rename/TestFieldWithGenericRename.java\n@@ -0,0 +1,27 @@\n+package jadx.tests.integration.rename;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestFieldWithGenericRename extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tList<String> list;\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tassertThat(cls.getCode()).containsOnlyOnce(\"List<String> list;\");\n+\n+\t\tcls.searchFieldByName(\"list\").getFieldInfo().setAlias(\"listFieldRenamed\");\n+\n+\t\tassertThat(cls.reloadCode()).print().containsOnlyOnce(\"List<String> listFieldRenamed;\");\n+\t}\n+}",
    "output": "Fix rerun signature parser on class reload"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n--- a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n@@ -7,7 +7,6 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.ArrayList;\n-import java.util.Enumeration;\n import java.util.List;\n import java.util.zip.ZipEntry;\n import java.util.zip.ZipFile;\n@@ -69,7 +68,7 @@ public static <T> T decodeStream(ResourceFile rf, ResourceDecoder<T> decoder) th\n \t\t\t\t\tif (!ZipSecurity.isValidZipEntry(entry)) {\n \t\t\t\t\t\treturn null;\n \t\t\t\t\t}\n-\t\t\t\t\ttry (InputStream inputStream = new BufferedInputStream(zipFile.getInputStream(entry))) {\n+\t\t\t\t\ttry (InputStream inputStream = ZipSecurity.getInputStreamForEntry(zipFile, entry)) {\n \t\t\t\t\t\treturn decoder.decode(entry.getSize(), inputStream);\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -129,17 +128,9 @@ private void loadFile(List<ResourceFile> list, File file) {\n \t\t\treturn;\n \t\t}\n \t\tif (FileUtils.isZipFile(file)) {\n-\t\t\ttry (ZipFile zip = new ZipFile(file)) {\n-\t\t\t\tEnumeration<? extends ZipEntry> entries = zip.entries();\n-\t\t\t\twhile (entries.hasMoreElements()) {\n-\t\t\t\t\tZipEntry entry = entries.nextElement();\n-\t\t\t\t\tif (ZipSecurity.isValidZipEntry(entry)) {\n-\t\t\t\t\t\taddEntry(list, file, entry);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tLOG.warn(\"Failed to open zip file: {}\", file.getAbsolutePath());\n-\t\t\t}\n+\t\t\tZipSecurity.visitZipEntries(file, (zipFile, entry) -> {\n+\t\t\t\taddEntry(list, file, entry);\n+\t\t\t});\n \t\t} else {\n \t\t\taddResourceFile(list, file);\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java\n--- a/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java\n+++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java\n@@ -325,22 +325,22 @@ private static void writeArgType(DataOutputStream out, ArgType argType, Map<Stri\n \n \tprivate void load(File input) throws IOException, DecodeException {\n \t\tString name = input.getName();\n-\t\ttry (InputStream inputStream = new FileInputStream(input)) {\n-\t\t\tif (name.endsWith(CLST_EXTENSION)) {\n+\t\tif (name.endsWith(CLST_EXTENSION)) {\n+\t\t\ttry (InputStream inputStream = new FileInputStream(input)) {\n \t\t\t\tload(inputStream);\n-\t\t\t} else if (name.endsWith(\".jar\")) {\n-\t\t\t\ttry (ZipInputStream in = new ZipInputStream(inputStream)) {\n-\t\t\t\t\tZipEntry entry = in.getNextEntry();\n-\t\t\t\t\twhile (entry != null) {\n-\t\t\t\t\t\tif (entry.getName().endsWith(CLST_EXTENSION) && ZipSecurity.isValidZipEntry(entry)) {\n-\t\t\t\t\t\t\tload(in);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tentry = in.getNextEntry();\n+\t\t\t}\n+\t\t} else if (name.endsWith(\".jar\")) {\n+\t\t\tZipSecurity.readZipEntries(input, (entry, in) -> {\n+\t\t\t\tif (entry.getName().endsWith(CLST_EXTENSION)) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tload(in);\n+\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\tthrow new JadxRuntimeException(\"Failed to load jadx class set\");\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tthrow new JadxRuntimeException(\"Unknown file format: \" + name);\n-\t\t\t}\n+\t\t\t});\n+\t\t} else {\n+\t\t\tthrow new JadxRuntimeException(\"Unknown file format: \" + name);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n@@ -2,6 +2,7 @@\n \n import java.io.File;\n import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.nio.file.StandardCopyOption;\n \n import org.slf4j.Logger;\n@@ -89,9 +90,11 @@ private void saveToFile(ResContainer rc, File outFile) {\n \n \tprivate void saveResourceFile(ResourceFile resFile, File outFile) throws JadxException {\n \t\tResourcesLoader.decodeStream(resFile, (size, is) -> {\n+\t\t\tPath target = outFile.toPath();\n \t\t\ttry {\n-\t\t\t\tFiles.copy(is, outFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n+\t\t\t\tFiles.copy(is, target, StandardCopyOption.REPLACE_EXISTING);\n \t\t\t} catch (Exception e) {\n+\t\t\t\tFiles.deleteIfExists(target); // delete partially written file\n \t\t\t\tthrow new JadxRuntimeException(\"Resource file save error\", e);\n \t\t\t}\n \t\t\treturn null;\n\ndiff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java\n@@ -11,7 +11,6 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.stream.Collectors;\n-import java.util.zip.ZipFile;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -66,19 +65,16 @@ private static List<DexReader> checkFileMagic(File file, InputStream inputStream\n \n \tprivate static List<DexReader> collectDexFromZip(File file) {\n \t\tList<DexReader> result = new ArrayList<>();\n-\t\ttry (ZipFile zip = new ZipFile(file)) {\n-\t\t\tzip.stream()\n-\t\t\t\t\t.filter(entry -> !entry.isDirectory())\n-\t\t\t\t\t.filter(ZipSecurity::isValidZipEntry)\n-\t\t\t\t\t.forEach(entry -> {\n-\t\t\t\t\t\ttry (InputStream in = zip.getInputStream(entry)) {\n-\t\t\t\t\t\t\tresult.addAll(checkFileMagic(null, in, entry.getName()));\n-\t\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\t\tLOG.error(\"Failed to read zip entry: {}\", entry, e);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t});\n+\t\ttry {\n+\t\t\tZipSecurity.readZipEntries(file, (entry, in) -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tresult.addAll(checkFileMagic(null, in, entry.getName()));\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tLOG.error(\"Failed to read zip entry: {}\", entry, e);\n+\t\t\t\t}\n+\t\t\t});\n \t\t} catch (Exception e) {\n-\t\t\tLOG.warn(\"Failed to open zip file: {}\", file.getAbsolutePath());\n+\t\t\tLOG.error(\"Failed to process zip file: {}\", file.getAbsolutePath(), e);\n \t\t}\n \t\treturn result;\n \t}\n\ndiff --git a/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/LimitedInputStream.java b/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/LimitedInputStream.java\n--- a/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/LimitedInputStream.java\n+++ b/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/LimitedInputStream.java\n@@ -0,0 +1,53 @@\n+package jadx.api.plugins.utils;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+public class LimitedInputStream extends FilterInputStream {\n+\n+\tprivate final long maxSize;\n+\n+\tprivate long currentPos;\n+\n+\tprotected LimitedInputStream(InputStream in, long maxSize) {\n+\t\tsuper(in);\n+\t\tthis.maxSize = maxSize;\n+\t}\n+\n+\tprivate void checkPos() {\n+\t\tif (currentPos > maxSize) {\n+\t\t\tthrow new IllegalStateException(\"Read limit exceeded\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic int read() throws IOException {\n+\t\tint data = super.read();\n+\t\tif (data != -1) {\n+\t\t\tcurrentPos++;\n+\t\t\tcheckPos();\n+\t\t}\n+\t\treturn data;\n+\t}\n+\n+\t@Override\n+\tpublic int read(byte[] b, int off, int len) throws IOException {\n+\t\tint count = super.read(b, off, len);\n+\t\tif (count > 0) {\n+\t\t\tcurrentPos += count;\n+\t\t\tcheckPos();\n+\t\t}\n+\t\treturn count;\n+\t}\n+\n+\t@Override\n+\tpublic long skip(long n) throws IOException {\n+\t\tlong skipped = super.skip(n);\n+\t\tif (skipped != 0) {\n+\t\t\tcurrentPos += skipped;\n+\t\t\tcheckPos();\n+\t\t}\n+\t\treturn skipped;\n+\t}\n+}\n\ndiff --git a/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/ZipSecurity.java b/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/ZipSecurity.java\n--- a/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/ZipSecurity.java\n+++ b/jadx-plugins/jadx-plugins-api/src/main/java/jadx/api/plugins/utils/ZipSecurity.java\n@@ -1,8 +1,13 @@\n package jadx.api.plugins.utils;\n \n+import java.io.BufferedInputStream;\n import java.io.File;\n import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Enumeration;\n+import java.util.function.BiConsumer;\n import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -12,6 +17,7 @@ public class ZipSecurity {\n \n \t// size of uncompressed zip entry shouldn't be bigger of compressed in MAX_SIZE_DIFF times\n \tprivate static final int MAX_SIZE_DIFF = 100;\n+\tprivate static final int MAX_ENTRIES_COUNT = 100_000;\n \n \tprivate ZipSecurity() {\n \t}\n@@ -73,4 +79,40 @@ public static boolean isValidZipEntry(ZipEntry entry) {\n \t\treturn isValidZipEntryName(entry.getName())\n \t\t\t\t&& !isZipBomb(entry);\n \t}\n+\n+\tpublic static InputStream getInputStreamForEntry(ZipFile zipFile, ZipEntry entry) throws IOException {\n+\t\tInputStream in = zipFile.getInputStream(entry);\n+\t\tLimitedInputStream limited = new LimitedInputStream(in, entry.getSize());\n+\t\treturn new BufferedInputStream(limited);\n+\t}\n+\n+\tpublic static void visitZipEntries(File file, BiConsumer<ZipFile, ZipEntry> visitor) {\n+\t\ttry (ZipFile zip = new ZipFile(file)) {\n+\t\t\tEnumeration<? extends ZipEntry> entries = zip.entries();\n+\t\t\tint entriesProcessed = 0;\n+\t\t\twhile (entries.hasMoreElements()) {\n+\t\t\t\tZipEntry entry = entries.nextElement();\n+\t\t\t\tif (!entry.isDirectory() && isValidZipEntry(entry)) {\n+\t\t\t\t\tvisitor.accept(zip, entry);\n+\t\t\t\t\tentriesProcessed++;\n+\t\t\t\t\tif (entriesProcessed > MAX_ENTRIES_COUNT) {\n+\t\t\t\t\t\tthrow new IllegalStateException(\"Zip entries count limit exceeded: \" + MAX_ENTRIES_COUNT\n+\t\t\t\t\t\t\t\t+ \", last entry: \" + entry.getName());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new RuntimeException(\"Failed to process zip file: \" + file.getAbsolutePath(), e);\n+\t\t}\n+\t}\n+\n+\tpublic static void readZipEntries(File file, BiConsumer<ZipEntry, InputStream> visitor) {\n+\t\tvisitZipEntries(file, (zip, entry) -> {\n+\t\t\ttry (InputStream in = getInputStreamForEntry(zip, entry)) {\n+\t\t\t\tvisitor.accept(entry, in);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tthrow new RuntimeException(\"Error process zip entry: \" + entry.getName());\n+\t\t\t}\n+\t\t});\n+\t}\n }",
    "output": "Fix prevent zipbomb forged headers attacks (#980, PR #982)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/ProcessClass.java b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n--- a/jadx-core/src/main/java/jadx/core/ProcessClass.java\n+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n@@ -1,15 +1,18 @@\n package jadx.core;\n \n import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n \n import jadx.api.ICodeInfo;\n import jadx.core.codegen.CodeGen;\n+import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.nodes.ClassNode;\n+import jadx.core.dex.nodes.LoadStage;\n import jadx.core.dex.visitors.DepthTraversal;\n import jadx.core.dex.visitors.IDexTreeVisitor;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n-import static jadx.core.dex.nodes.ProcessState.GENERATED;\n+import static jadx.core.dex.nodes.ProcessState.GENERATED_AND_UNLOADED;\n import static jadx.core.dex.nodes.ProcessState.LOADED;\n import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;\n import static jadx.core.dex.nodes.ProcessState.PROCESS_COMPLETE;\n@@ -20,18 +23,27 @@ public final class ProcessClass {\n \tprivate ProcessClass() {\n \t}\n \n-\tpublic static void process(ClassNode cls) {\n-\t\tClassNode topParentClass = cls.getTopParentClass();\n-\t\tif (topParentClass != cls) {\n-\t\t\tprocess(topParentClass);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (cls.getState().isProcessed()) {\n+\t@Nullable\n+\tprivate static ICodeInfo process(ClassNode cls, boolean codegen) {\n+\t\tif (!codegen && cls.getState() == PROCESS_COMPLETE) {\n \t\t\t// nothing to do\n-\t\t\treturn;\n+\t\t\treturn null;\n \t\t}\n \t\tsynchronized (cls.getClassInfo()) {\n \t\t\ttry {\n+\t\t\t\tif (codegen) {\n+\t\t\t\t\tif (cls.getState() == GENERATED_AND_UNLOADED) {\n+\t\t\t\t\t\t// allow to run code generation again\n+\t\t\t\t\t\tcls.setState(NOT_LOADED);\n+\t\t\t\t\t}\n+\t\t\t\t\tcls.setLoadStage(LoadStage.CODEGEN_STAGE);\n+\t\t\t\t\tif (cls.contains(AFlag.RELOAD_AT_CODEGEN_STAGE)) {\n+\t\t\t\t\t\tcls.remove(AFlag.RELOAD_AT_CODEGEN_STAGE);\n+\t\t\t\t\t\tcls.unload();\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tcls.setLoadStage(LoadStage.PROCESS_STAGE);\n+\t\t\t\t}\n \t\t\t\tif (cls.getState() == NOT_LOADED) {\n \t\t\t\t\tcls.load();\n \t\t\t\t}\n@@ -42,9 +54,18 @@ public static void process(ClassNode cls) {\n \t\t\t\t\t}\n \t\t\t\t\tcls.setState(PROCESS_COMPLETE);\n \t\t\t\t}\n+\t\t\t\tif (codegen) {\n+\t\t\t\t\tICodeInfo code = CodeGen.generate(cls);\n+\t\t\t\t\tif (!cls.contains(AFlag.DONT_UNLOAD_CLASS)) {\n+\t\t\t\t\t\tcls.unload();\n+\t\t\t\t\t\tcls.setState(GENERATED_AND_UNLOADED);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn code;\n+\t\t\t\t}\n \t\t\t} catch (Throwable e) {\n \t\t\t\tcls.addError(\"Class process error: \" + e.getClass().getSimpleName(), e);\n \t\t\t}\n+\t\t\treturn null;\n \t\t}\n \t}\n \n@@ -54,21 +75,14 @@ public static ICodeInfo generateCode(ClassNode cls) {\n \t\tif (topParentClass != cls) {\n \t\t\treturn generateCode(topParentClass);\n \t\t}\n-\t\tif (cls.getState() == GENERATED) {\n-\t\t\t// allow to run code generation again\n-\t\t\tcls.setState(NOT_LOADED);\n-\t\t}\n \t\ttry {\n \t\t\tfor (ClassNode depCls : cls.getDependencies()) {\n-\t\t\t\tdepCls.startProcessStage();\n-\t\t\t\tprocess(depCls);\n+\t\t\t\tprocess(depCls, false);\n+\t\t\t}\n+\t\t\tICodeInfo code = process(cls, true);\n+\t\t\tif (code == null) {\n+\t\t\t\tthrow new JadxRuntimeException(\"Codegen failed\");\n \t\t\t}\n-\t\t\tcls.startCodegenStage();\n-\t\t\tprocess(cls);\n-\n-\t\t\tICodeInfo code = CodeGen.generate(cls);\n-\t\t\tcls.setState(GENERATED);\n-\t\t\tcls.unload();\n \t\t\treturn code;\n \t\t} catch (Throwable e) {\n \t\t\tthrow new JadxRuntimeException(\"Failed to generate code for class: \" + cls.getFullName(), e);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n@@ -75,4 +75,6 @@ public enum AFlag {\n \tINCONSISTENT_CODE, // warning about incorrect decompilation\n \n \tREQUEST_IF_REGION_OPTIMIZE, // run if region visitor again\n+\n+\tDONT_UNLOAD_CLASS, // don't unload class after code generation (only for tests and debug!)\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -40,6 +40,7 @@\n \n import static jadx.core.dex.nodes.ProcessState.LOADED;\n import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;\n+import static jadx.core.dex.nodes.ProcessState.PROCESS_COMPLETE;\n \n public class ClassNode extends NotificationAttrNode implements ILoadable, ICodeNode, Comparable<ClassNode> {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ClassNode.class);\n@@ -209,10 +210,10 @@ private void addSourceFilenameAttr(String fileName) {\n \n \tpublic void ensureProcessed() {\n \t\tClassNode topClass = getTopParentClass();\n-\t\tProcessState topState = topClass.getState();\n-\t\tif (!topState.isProcessed()) {\n+\t\tProcessState state = topClass.getState();\n+\t\tif (state != PROCESS_COMPLETE) {\n \t\t\tthrow new JadxRuntimeException(\"Expected class to be processed at this point,\"\n-\t\t\t\t\t+ \" class: \" + topClass + \", state: \" + topState);\n+\t\t\t\t\t+ \" class: \" + topClass + \", state: \" + state);\n \t\t}\n \t}\n \n@@ -583,16 +584,8 @@ public LoadStage getLoadStage() {\n \t\treturn loadStage;\n \t}\n \n-\tpublic void startProcessStage() {\n-\t\tthis.loadStage = LoadStage.PROCESS_STAGE;\n-\t}\n-\n-\tpublic void startCodegenStage() {\n-\t\tthis.loadStage = LoadStage.CODEGEN_STAGE;\n-\t\tif (contains(AFlag.RELOAD_AT_CODEGEN_STAGE)) {\n-\t\t\tunload();\n-\t\t\tremove(AFlag.RELOAD_AT_CODEGEN_STAGE);\n-\t\t}\n+\tpublic void setLoadStage(LoadStage loadStage) {\n+\t\tthis.loadStage = loadStage;\n \t}\n \n \tpublic void reloadAtCodegenStage() {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ProcessState.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ProcessState.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ProcessState.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ProcessState.java\n@@ -5,9 +5,5 @@ public enum ProcessState {\n \tLOADED,\n \tPROCESS_STARTED,\n \tPROCESS_COMPLETE,\n-\tGENERATED;\n-\n-\tpublic boolean isProcessed() {\n-\t\treturn this == PROCESS_COMPLETE || this == GENERATED;\n-\t}\n+\tGENERATED_AND_UNLOADED;\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n@@ -58,11 +58,10 @@ public boolean visit(ClassNode cls) throws JadxException {\n \n \t@Override\n \tpublic void visit(MethodNode mth) throws JadxException {\n-\t\tList<BlockNode> blocks = mth.getBasicBlocks();\n-\t\tif (blocks == null) {\n+\t\tif (mth.isNoCode()) {\n \t\t\treturn;\n \t\t}\n-\t\tfor (BlockNode block : blocks) {\n+\t\tfor (BlockNode block : mth.getBasicBlocks()) {\n \t\t\tif (block.contains(AFlag.DONT_GENERATE)) {\n \t\t\t\tcontinue;\n \t\t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n@@ -28,8 +28,6 @@\n import jadx.api.JadxArgs;\n import jadx.api.JadxDecompiler;\n import jadx.api.JadxInternalAccess;\n-import jadx.core.ProcessClass;\n-import jadx.core.codegen.CodeGen;\n import jadx.core.codegen.CodeWriter;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n@@ -190,11 +188,10 @@ protected JadxDecompiler loadFiles(List<File> inputFiles) {\n \t}\n \n \tprotected void decompileAndCheck(JadxDecompiler d, List<ClassNode> clsList) {\n-\t\tif (unloadCls) {\n-\t\t\tclsList.forEach(ClassNode::decompile);\n-\t\t} else {\n-\t\t\tclsList.forEach(cls -> decompileWithoutUnload(d, cls));\n+\t\tif (!unloadCls) {\n+\t\t\tclsList.forEach(cls -> cls.add(AFlag.DONT_UNLOAD_CLASS));\n \t\t}\n+\t\tclsList.forEach(ClassNode::decompile);\n \n \t\tfor (ClassNode cls : clsList) {\n \t\t\tSystem.out.println(\"-----------------------------------------------------------\");\n@@ -251,22 +248,6 @@ private void insertResources(RootNode root) {\n \t\troot.processResources(resStorage);\n \t}\n \n-\tprotected void decompileWithoutUnload(JadxDecompiler jadx, ClassNode cls) {\n-\t\tProcessClass.process(cls);\n-\t\tgenerateClsCode(cls);\n-\t\t// don't unload class\n-\t}\n-\n-\tprotected void generateClsCode(ClassNode cls) {\n-\t\ttry {\n-\t\t\tICodeInfo code = CodeGen.generate(cls);\n-\t\t\tcls.root().getCodeCache().add(cls.getTopParentClass().getRawName(), code);\n-\t\t} catch (Exception e) {\n-\t\t\te.printStackTrace();\n-\t\t\tfail(e.getMessage());\n-\t\t}\n-\t}\n-\n \tprotected void checkCode(ClassNode cls) {\n \t\tassertFalse(hasErrors(cls), \"Inconsistent cls: \" + cls);\n \t\tfor (MethodNode mthNode : cls.getMethods()) {",
    "output": "Fix move class unload to synchronized block"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n@@ -31,14 +31,13 @@ public class OverrideMethodVisitor extends AbstractVisitor {\n \n \t@Override\n \tpublic boolean visit(ClassNode cls) throws JadxException {\n-\t\tRootNode root = cls.root();\n \t\tList<ArgType> superTypes = collectSuperTypes(cls);\n \t\tfor (MethodNode mth : cls.getMethods()) {\n \t\t\tif (mth.isConstructor() || mth.getAccessFlags().isStatic()) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tString signature = mth.getMethodInfo().makeSignature(false);\n-\t\t\tList<IMethodDetails> overrideList = collectOverrideMethods(root, superTypes, signature);\n+\t\t\tList<IMethodDetails> overrideList = collectOverrideMethods(cls, superTypes, signature);\n \t\t\tif (!overrideList.isEmpty()) {\n \t\t\t\tmth.addAttr(new MethodOverrideAttr(overrideList));\n \t\t\t\tfixMethodReturnType(mth, overrideList, superTypes);\n@@ -48,23 +47,22 @@ public boolean visit(ClassNode cls) throws JadxException {\n \t\treturn true;\n \t}\n \n-\tprivate List<IMethodDetails> collectOverrideMethods(RootNode root, List<ArgType> superTypes, String signature) {\n+\tprivate List<IMethodDetails> collectOverrideMethods(ClassNode cls, List<ArgType> superTypes, String signature) {\n \t\tList<IMethodDetails> overrideList = new ArrayList<>();\n \t\tfor (ArgType superType : superTypes) {\n-\t\t\tClassNode classNode = root.resolveClass(superType);\n+\t\t\tClassNode classNode = cls.root().resolveClass(superType);\n \t\t\tif (classNode != null) {\n \t\t\t\tfor (MethodNode mth : classNode.getMethods()) {\n-\t\t\t\t\tAccessInfo accessFlags = mth.getAccessFlags();\n-\t\t\t\t\tif (!accessFlags.isPrivate()\n-\t\t\t\t\t\t\t&& !accessFlags.isStatic()) {\n+\t\t\t\t\tif (!mth.getAccessFlags().isStatic()\n+\t\t\t\t\t\t\t&& isMethodVisibleInCls(mth, cls)) {\n \t\t\t\t\t\tString mthShortId = mth.getMethodInfo().getShortId();\n \t\t\t\t\t\tif (mthShortId.startsWith(signature)) {\n \t\t\t\t\t\t\toverrideList.add(mth);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tClspClass clsDetails = root.getClsp().getClsDetails(superType);\n+\t\t\t\tClspClass clsDetails = cls.root().getClsp().getClsDetails(superType);\n \t\t\t\tif (clsDetails != null) {\n \t\t\t\t\tMap<String, ClspMethod> methodsMap = clsDetails.getMethodsMap();\n \t\t\t\t\tfor (Map.Entry<String, ClspMethod> entry : methodsMap.entrySet()) {\n@@ -79,6 +77,21 @@ private List<IMethodDetails> collectOverrideMethods(RootNode root, List<ArgType>\n \t\treturn overrideList;\n \t}\n \n+\t/**\n+\t * NOTE: Simplified version of method from {@link ModVisitor#isFieldVisibleInMethod}\n+\t */\n+\tprivate boolean isMethodVisibleInCls(MethodNode superMth, ClassNode cls) {\n+\t\tAccessInfo accessFlags = superMth.getAccessFlags();\n+\t\tif (accessFlags.isPrivate()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (accessFlags.isPublic() || accessFlags.isProtected()) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t// package-private\n+\t\treturn Objects.equals(superMth.getParentClass().getPackage(), cls.getPackage());\n+\t}\n+\n \tprivate List<ArgType> collectSuperTypes(ClassNode cls) {\n \t\tMap<String, ArgType> superTypes = new HashMap<>();\n \t\tcollectSuperTypes(cls, superTypes);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestOverridePackagePrivateMethod.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestOverridePackagePrivateMethod.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestOverridePackagePrivateMethod.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestOverridePackagePrivateMethod.java\n@@ -0,0 +1,67 @@\n+package jadx.tests.integration.others;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.NotYetImplemented;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestOverridePackagePrivateMethod extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\t-----------------------------------------------------------\n+\t\tpackage test;\n+\n+\t\tpublic class A {\n+\t\t\tvoid a() { // package-private\n+\t\t\t}\n+\t\t}\n+\t\t-----------------------------------------------------------\n+\t\tpackage test;\n+\n+\t\tpublic class B extends A {\n+\t\t\t@Override // test.A\n+\t\t\tpublic void a() {\n+\t\t\t}\n+\t\t}\n+\t\t-----------------------------------------------------------\n+\t\tpackage other;\n+\n+\t\timport test.A;\n+\n+\t\tpublic class C extends A {\n+\t\t\t// No @Override here\n+\t\t\tpublic void a() {\n+\t\t\t}\n+\t\t}\n+\t\t-----------------------------------------------------------\n+\t*/\n+\t// @formatter:on\n+\n+\t@NotYetImplemented(\"Don't change access modifiers if not needed\")\n+\t@Test\n+\tpublic void test() {\n+\t\tcommonChecks();\n+\t}\n+\n+\t@Test\n+\tpublic void testDontChangeAccFlags() {\n+\t\tgetArgs().setRespectBytecodeAccModifiers(true);\n+\t\tcommonChecks();\n+\t}\n+\n+\tprivate void commonChecks() {\n+\t\tList<ClassNode> classes = loadFromSmaliFiles();\n+\t\tassertThat(searchCls(classes, \"test.A\"))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"/* access modifiers changed\")\n+\t\t\t\t.containsLine(1, \"void a() {\");\n+\n+\t\tassertThat(searchCls(classes, \"test.B\")).code().containsOne(\"@Override\");\n+\t\tassertThat(searchCls(classes, \"other.C\")).code().doesNotContain(\"@Override\");\n+\t}\n+}",
    "output": "Fix more visibility checks for @Override"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n@@ -73,4 +73,6 @@ public enum AFlag {\n \tSOFT_CAST, // synthetic cast to help type inference\n \n \tINCONSISTENT_CODE, // warning about incorrect decompilation\n+\n+\tREQUEST_IF_REGION_OPTIMIZE, // run if region visitor again\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java\n@@ -26,7 +26,10 @@ public void visit(MethodNode mth) {\n \t\tif (mth.isNoCode()) {\n \t\t\treturn;\n \t\t}\n+\t\tprocess(mth);\n+\t}\n \n+\tpublic static void process(MethodNode mth) {\n \t\tDepthRegionTraversal.traverseIterative(mth, TERNARY_VISITOR);\n \t\tDepthRegionTraversal.traverse(mth, PROCESS_IF_REGION_VISITOR);\n \t\tDepthRegionTraversal.traverseIterative(mth, REMOVE_REDUNDANT_ELSE_VISITOR);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n@@ -53,35 +53,43 @@ public class LoopRegionVisitor extends AbstractVisitor implements IRegionVisitor\n \t@Override\n \tpublic void visit(MethodNode mth) {\n \t\tDepthRegionTraversal.traverse(mth, this);\n+\t\tif (mth.contains(AFlag.REQUEST_IF_REGION_OPTIMIZE)) {\n+\t\t\tIfRegionVisitor.process(mth);\n+\t\t\tmth.remove(AFlag.REQUEST_IF_REGION_OPTIMIZE);\n+\t\t}\n \t}\n \n \t@Override\n \tpublic boolean enterRegion(MethodNode mth, IRegion region) {\n \t\tif (region instanceof LoopRegion) {\n-\t\t\tprocessLoopRegion(mth, (LoopRegion) region);\n+\t\t\tif (processLoopRegion(mth, (LoopRegion) region)) {\n+\t\t\t\t// optimize `if` block after instructions remove\n+\t\t\t\tmth.add(AFlag.REQUEST_IF_REGION_OPTIMIZE);\n+\t\t\t}\n \t\t}\n \t\treturn true;\n \t}\n \n-\tprivate static void processLoopRegion(MethodNode mth, LoopRegion loopRegion) {\n+\tprivate static boolean processLoopRegion(MethodNode mth, LoopRegion loopRegion) {\n \t\tif (loopRegion.isConditionAtEnd()) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tIfCondition condition = loopRegion.getCondition();\n \t\tif (condition == null) {\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n \t\tif (checkForIndexedLoop(mth, loopRegion, condition)) {\n-\t\t\treturn;\n+\t\t\treturn true;\n \t\t}\n-\t\tcheckIterableForEach(mth, loopRegion, condition);\n+\t\treturn checkIterableForEach(mth, loopRegion, condition);\n \t}\n \n \t/**\n \t * Check for indexed loop.\n \t */\n \tprivate static boolean checkForIndexedLoop(MethodNode mth, LoopRegion loopRegion, IfCondition condition) {\n-\t\tInsnNode incrInsn = RegionUtils.getLastInsn(loopRegion);\n+\t\tBlockNode loopEndBlock = loopRegion.getInfo().getEnd();\n+\t\tInsnNode incrInsn = BlockUtils.getLastInsn(BlockUtils.skipSyntheticPredecessor(loopEndBlock));\n \t\tif (incrInsn == null) {\n \t\t\treturn false;\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEach3.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEach3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEach3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestArrayForEach3.java\n@@ -0,0 +1,44 @@\n+package jadx.tests.integration.loops;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+/**\n+ * Issue #977\n+ */\n+public class TestArrayForEach3 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic void test(String[] arr) {\n+\t\t\tfor (String s : arr) {\n+\t\t\t\tif (s.length() > 0) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tthrow new IllegalArgumentException(\"All strings are empty\");\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\ttest(new String[] { \"\", \"a\" }); // no exception\n+\t\t\ttry {\n+\t\t\t\ttest(new String[] { \"\", \"\" });\n+\t\t\t\tfail(\"IllegalArgumentException expected\");\n+\t\t\t} catch (IllegalArgumentException e) {\n+\t\t\t\t// expected\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"while\")\n+\t\t\t\t.containsOne(\"for (String str : strArr) {\");\n+\t}\n+}",
    "output": "Fix transform loop to `for` with branching at end"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -41,8 +41,10 @@\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n import jadx.core.utils.BlockInsnPair;\n+import jadx.core.utils.BlockUtils;\n import jadx.core.utils.InsnRemover;\n import jadx.core.utils.InsnUtils;\n+import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxException;\n \n import static jadx.core.utils.InsnUtils.checkInsnType;\n@@ -133,17 +135,8 @@ private boolean convertToEnum(ClassNode cls) {\n \t\tList<EnumField> enumFields = null;\n \t\tInsnArg arrArg = valuesInitInsn.getArg(0);\n \t\tif (arrArg.isInsnWrap()) {\n-\t\t\tInsnNode arrFillInsn = ((InsnWrapArg) arrArg).getWrapInsn();\n-\t\t\tInsnType insnType = arrFillInsn.getType();\n-\t\t\tif (insnType == InsnType.FILLED_NEW_ARRAY) {\n-\t\t\t\tenumFields = extractEnumFields(cls, arrFillInsn, staticBlock, toRemove);\n-\t\t\t} else if (insnType == InsnType.NEW_ARRAY) {\n-\t\t\t\t// empty enum\n-\t\t\t\tInsnArg arg = arrFillInsn.getArg(0);\n-\t\t\t\tif (arg.isLiteral() && ((LiteralArg) arg).getLiteral() == 0) {\n-\t\t\t\t\tenumFields = Collections.emptyList();\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tInsnNode wrappedInsn = ((InsnWrapArg) arrArg).getWrapInsn();\n+\t\t\tenumFields = extractEnumFieldsFromInsn(cls, staticBlock, wrappedInsn, toRemove);\n \t\t}\n \t\tif (enumFields == null) {\n \t\t\treturn false;\n@@ -201,6 +194,50 @@ private void processConstructorInsn(ClassNode cls, EnumField enumField, MethodNo\n \t\tInsnRemover.removeWithoutUnbind(classInitMth, staticBlock, co);\n \t}\n \n+\t@Nullable\n+\tprivate List<EnumField> extractEnumFieldsFromInsn(ClassNode cls, BlockNode staticBlock,\n+\t\t\tInsnNode wrappedInsn, List<InsnNode> toRemove) {\n+\t\tswitch (wrappedInsn.getType()) {\n+\t\t\tcase FILLED_NEW_ARRAY:\n+\t\t\t\treturn extractEnumFieldsFromFilledArray(cls, wrappedInsn, staticBlock, toRemove);\n+\n+\t\t\tcase INVOKE:\n+\t\t\t\t// handle redirection of values array fill (added in java 15)\n+\t\t\t\treturn extractEnumFieldsFromInvoke(cls, staticBlock, (InvokeNode) wrappedInsn, toRemove);\n+\n+\t\t\tcase NEW_ARRAY:\n+\t\t\t\tInsnArg arg = wrappedInsn.getArg(0);\n+\t\t\t\tif (arg.isLiteral() && ((LiteralArg) arg).getLiteral() == 0) {\n+\t\t\t\t\t// empty enum\n+\t\t\t\t\treturn Collections.emptyList();\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\n+\t\t\tdefault:\n+\t\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprivate List<EnumField> extractEnumFieldsFromInvoke(ClassNode cls, BlockNode staticBlock,\n+\t\t\tInvokeNode invokeNode, List<InsnNode> toRemove) {\n+\t\tMethodInfo callMth = invokeNode.getCallMth();\n+\t\tMethodNode valuesMth = cls.root().resolveMethod(callMth);\n+\t\tif (valuesMth == null || valuesMth.isVoidReturn()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tBlockNode returnBlock = Utils.getOne(valuesMth.getExitBlocks());\n+\t\tInsnNode returnInsn = BlockUtils.getLastInsn(returnBlock);\n+\t\tInsnNode wrappedInsn = getWrappedInsn(getSingleArg(returnInsn));\n+\t\tif (wrappedInsn == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<EnumField> enumFields = extractEnumFieldsFromInsn(cls, staticBlock, wrappedInsn, toRemove);\n+\t\tif (enumFields != null) {\n+\t\t\tvaluesMth.add(AFlag.DONT_GENERATE);\n+\t\t}\n+\t\treturn enumFields;\n+\t}\n+\n \tprivate BlockInsnPair getValuesInitInsn(MethodNode classInitMth, FieldNode valuesField) {\n \t\tFieldInfo searchField = valuesField.getFieldInfo();\n \t\tfor (BlockNode blockNode : classInitMth.getBasicBlocks()) {\n@@ -217,15 +254,16 @@ private BlockInsnPair getValuesInitInsn(MethodNode classInitMth, FieldNode value\n \t\treturn null;\n \t}\n \n-\tprivate List<EnumField> extractEnumFields(ClassNode cls, InsnNode arrFillInsn, BlockNode staticBlock, List<InsnNode> toRemove) {\n+\tprivate List<EnumField> extractEnumFieldsFromFilledArray(ClassNode cls, InsnNode arrFillInsn, BlockNode staticBlock,\n+\t\t\tList<InsnNode> toRemove) {\n \t\tList<EnumField> enumFields = new ArrayList<>();\n \t\tfor (InsnArg arg : arrFillInsn.getArguments()) {\n \t\t\tEnumField field = null;\n \t\t\tif (arg.isInsnWrap()) {\n \t\t\t\tInsnNode wrappedInsn = ((InsnWrapArg) arg).getWrapInsn();\n \t\t\t\tfield = processEnumFieldByField(cls, wrappedInsn, staticBlock, toRemove);\n \t\t\t} else if (arg.isRegister()) {\n-\t\t\t\tfield = processEnumFiledByRegister(cls, ((RegisterArg) arg), toRemove);\n+\t\t\t\tfield = processEnumFiledByRegister(cls, (RegisterArg) arg, toRemove);\n \t\t\t}\n \t\t\tif (field == null) {\n \t\t\t\treturn null;",
    "output": "Fix restore enum for java 15"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n@@ -9,6 +9,7 @@\n import jadx.core.clsp.ClspClass;\n import jadx.core.clsp.ClspMethod;\n import jadx.core.dex.attributes.nodes.MethodOverrideAttr;\n+import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.IMethodDetails;\n@@ -33,7 +34,7 @@ public boolean visit(ClassNode cls) throws JadxException {\n \t\tRootNode root = cls.root();\n \t\tList<ArgType> superTypes = collectSuperTypes(cls);\n \t\tfor (MethodNode mth : cls.getMethods()) {\n-\t\t\tif (mth.isConstructor()) {\n+\t\t\tif (mth.isConstructor() || mth.getAccessFlags().isStatic()) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tString signature = mth.getMethodInfo().makeSignature(false);\n@@ -53,7 +54,9 @@ private List<IMethodDetails> collectOverrideMethods(RootNode root, List<ArgType>\n \t\t\tClassNode classNode = root.resolveClass(superType);\n \t\t\tif (classNode != null) {\n \t\t\t\tfor (MethodNode mth : classNode.getMethods()) {\n-\t\t\t\t\tif (!mth.getAccessFlags().isPrivate()) {\n+\t\t\t\t\tAccessInfo accessFlags = mth.getAccessFlags();\n+\t\t\t\t\tif (!accessFlags.isPrivate()\n+\t\t\t\t\t\t\t&& !accessFlags.isStatic()) {\n \t\t\t\t\t\tString mthShortId = mth.getMethodInfo().getShortId();\n \t\t\t\t\t\tif (mthShortId.startsWith(signature)) {\n \t\t\t\t\t\t\toverrideList.add(mth);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestOverrideStaticMethod.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestOverrideStaticMethod.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestOverrideStaticMethod.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestOverrideStaticMethod.java\n@@ -0,0 +1,36 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestOverrideStaticMethod extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic static class BaseClass {\n+\t\t\tpublic static int a() {\n+\t\t\t\treturn 1;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic static class MyClass extends BaseClass {\n+\t\t\tpublic static int a() {\n+\t\t\t\treturn 2;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(BaseClass.a()).isEqualTo(1);\n+\t\t\tassertThat(MyClass.a()).isEqualTo(2);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"@Override\");\n+\t}\n+}",
    "output": "Fix don't add @Override for static methods"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n@@ -53,9 +53,11 @@ private List<IMethodDetails> collectOverrideMethods(RootNode root, List<ArgType>\n \t\t\tClassNode classNode = root.resolveClass(superType);\n \t\t\tif (classNode != null) {\n \t\t\t\tfor (MethodNode mth : classNode.getMethods()) {\n-\t\t\t\t\tString mthShortId = mth.getMethodInfo().getShortId();\n-\t\t\t\t\tif (mthShortId.startsWith(signature)) {\n-\t\t\t\t\t\toverrideList.add(mth);\n+\t\t\t\t\tif (!mth.getAccessFlags().isPrivate()) {\n+\t\t\t\t\t\tString mthShortId = mth.getMethodInfo().getShortId();\n+\t\t\t\t\t\tif (mthShortId.startsWith(signature)) {\n+\t\t\t\t\t\t\toverrideList.add(mth);\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestOverridePrivateMethod.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestOverridePrivateMethod.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestOverridePrivateMethod.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestOverridePrivateMethod.java\n@@ -0,0 +1,29 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestOverridePrivateMethod extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic static class BaseClass {\n+\t\t\tprivate void a() {\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic static class MyClass extends BaseClass {\n+\t\t\tpublic void a() {\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"@Override\");\n+\t}\n+}",
    "output": "Fix don't add @Override if super method is private"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -28,6 +28,7 @@\n import jadx.core.dex.nodes.FieldNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.RootNode;\n+import jadx.core.utils.kotlin.KotlinMetadataUtils;\n \n public class Deobfuscator {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(Deobfuscator.class);\n@@ -36,9 +37,6 @@ public class Deobfuscator {\n \n \tpublic static final String CLASS_NAME_SEPARATOR = \".\";\n \tpublic static final String INNER_CLASS_SEPARATOR = \"$\";\n-\tpublic static final String KOTLIN_METADATA_ANNOTATION = \"kotlin.Metadata\";\n-\tpublic static final String KOTLIN_METADATA_D2_PARAMETER = \"d2\";\n-\tpublic static final String KOTLIN_METADATA_CLASSNAME_REGEX = \"(L.*;)\";\n \n \tprivate final JadxArgs args;\n \tprivate final RootNode root;\n@@ -351,9 +349,8 @@ private void preProcessClass(ClassNode cls) {\n \t\t} else {\n \t\t\tif (!clsMap.containsKey(classInfo)) {\n \t\t\t\tString clsShortName = classInfo.getShortName();\n-\t\t\t\tif (shouldRename(clsShortName) || reservedClsNames.contains(clsShortName)) {\n-\t\t\t\t\tmakeClsAlias(cls);\n-\t\t\t\t}\n+\t\t\t\tboolean badName = shouldRename(clsShortName) || reservedClsNames.contains(clsShortName);\n+\t\t\t\tmakeClsAlias(cls, badName);\n \t\t\t}\n \t\t}\n \t\tfor (ClassNode innerCls : cls.getInnerClasses()) {\n@@ -366,7 +363,7 @@ public String getClsAlias(ClassNode cls) {\n \t\tif (deobfClsInfo != null) {\n \t\t\treturn deobfClsInfo.getAlias();\n \t\t}\n-\t\treturn makeClsAlias(cls);\n+\t\treturn makeClsAlias(cls, true);\n \t}\n \n \tpublic String getPkgAlias(ClassNode cls) {\n@@ -387,41 +384,35 @@ public String getPkgAlias(ClassNode cls) {\n \t\t}\n \t}\n \n-\tprivate String makeClsAlias(ClassNode cls) {\n-\t\tClassInfo classInfo = cls.getClassInfo();\n-\n-\t\tString metadataClassName = \"\";\n-\t\tString metadataPackageName = \"\";\n+\tprivate String makeClsAlias(ClassNode cls, boolean badName) {\n+\t\tString alias = null;\n+\t\tString pkgName = null;\n \t\tif (this.parseKotlinMetadata) {\n-\t\t\tString rawClassName = getRawClassNameFromMetadata(cls);\n-\t\t\tif (rawClassName != null) {\n-\t\t\t\tmetadataClassName = rawClassName.substring(rawClassName.lastIndexOf(\".\") + 1, rawClassName.length() - 1);\n-\t\t\t\tif (rawClassName.lastIndexOf(\".\") != -1) {\n-\t\t\t\t\tmetadataPackageName = rawClassName.substring(1, rawClassName.lastIndexOf(\".\"));\n-\t\t\t\t}\n+\t\t\tClassInfo kotlinCls = KotlinMetadataUtils.getClassName(cls);\n+\t\t\tif (kotlinCls != null) {\n+\t\t\t\talias = prepareNameFull(kotlinCls.getShortName(), \"C\");\n+\t\t\t\tpkgName = kotlinCls.getPackage();\n \t\t\t}\n \t\t}\n-\t\tString alias = null;\n-\n-\t\tif (this.useSourceNameAsAlias) {\n+\t\tif (alias == null && this.useSourceNameAsAlias) {\n \t\t\talias = getAliasFromSourceFile(cls);\n \t\t}\n \n+\t\tClassInfo classInfo = cls.getClassInfo();\n \t\tif (alias == null) {\n-\t\t\tif (metadataClassName.isEmpty()) {\n+\t\t\tif (badName) {\n \t\t\t\tString clsName = classInfo.getShortName();\n \t\t\t\tString prefix = makeClsPrefix(cls);\n \t\t\t\talias = String.format(\"%sC%04d%s\", prefix, clsIndex++, prepareNamePart(clsName));\n \t\t\t} else {\n-\t\t\t\talias = metadataClassName;\n+\t\t\t\t// rename not needed\n+\t\t\t\treturn classInfo.getShortName();\n \t\t\t}\n \t\t}\n-\t\tPackageNode pkg;\n-\t\tif (metadataPackageName.isEmpty()) {\n-\t\t\tpkg = getPackageNode(classInfo.getPackage(), true);\n-\t\t} else {\n-\t\t\tpkg = getPackageNode(metadataPackageName, true);\n+\t\tif (pkgName == null) {\n+\t\t\tpkgName = classInfo.getPackage();\n \t\t}\n+\t\tPackageNode pkg = getPackageNode(pkgName, true);\n \t\tclsMap.put(classInfo, new DeobfClsInfo(this, cls, pkg, alias));\n \t\treturn alias;\n \t}\n@@ -484,29 +475,6 @@ private String makeClsPrefix(ClassNode cls) {\n \t\treturn result;\n \t}\n \n-\t/**\n-\t * Try to get class name form Kotlin meta data\n-\t *\n-\t * @param cls\n-\t * @return\n-\t */\n-\t@Nullable\n-\tprivate String getRawClassNameFromMetadata(ClassNode cls) {\n-\t\tif (cls.getAnnotation(KOTLIN_METADATA_ANNOTATION) != null\n-\t\t\t\t&& cls.getAnnotation(KOTLIN_METADATA_ANNOTATION).getValues().get(KOTLIN_METADATA_D2_PARAMETER) != null\n-\t\t\t\t&& cls.getAnnotation(KOTLIN_METADATA_ANNOTATION).getValues().get(KOTLIN_METADATA_D2_PARAMETER) instanceof List) {\n-\t\t\tObject rawClassNameObject =\n-\t\t\t\t\t((List) cls.getAnnotation(KOTLIN_METADATA_ANNOTATION).getValues().get(KOTLIN_METADATA_D2_PARAMETER)).get(0);\n-\t\t\tif (rawClassNameObject instanceof String) {\n-\t\t\t\tString rawClassName = ((String) rawClassNameObject).trim().replace(\"/\", \".\");\n-\t\t\t\tif (rawClassName.length() > 1 && rawClassName.matches(KOTLIN_METADATA_CLASSNAME_REGEX)) {\n-\t\t\t\t\treturn rawClassName;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n \t@Nullable\n \tprivate String getAliasFromSourceFile(ClassNode cls) {\n \t\tSourceFileAttr sourceFileAttr = cls.get(AType.SOURCE_FILE);\n@@ -628,6 +596,24 @@ private String prepareNamePart(String name) {\n \t\treturn NameMapper.removeInvalidCharsMiddle(name);\n \t}\n \n+\tprivate String prepareNameFull(String name, String prefix) {\n+\t\tif (name.length() > maxLength) {\n+\t\t\treturn makeHashName(name, prefix);\n+\t\t}\n+\t\tString result = NameMapper.removeInvalidChars(name, prefix);\n+\t\tif (result.isEmpty()) {\n+\t\t\treturn makeHashName(name, prefix);\n+\t\t}\n+\t\tif (NameMapper.isReserved(result)) {\n+\t\t\treturn prefix + result;\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate static String makeHashName(String name, String invalidPrefix) {\n+\t\treturn invalidPrefix + 'x' + Integer.toHexString(name.hashCode());\n+\t}\n+\n \tprivate void dumpClassAlias(ClassNode cls) {\n \t\tPackageNode pkg = getPackageNode(cls.getPackage(), false);\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/kotlin/KotlinMetadataUtils.java b/jadx-core/src/main/java/jadx/core/utils/kotlin/KotlinMetadataUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/kotlin/KotlinMetadataUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/kotlin/KotlinMetadataUtils.java\n@@ -0,0 +1,59 @@\n+package jadx.core.utils.kotlin;\n+\n+import java.util.List;\n+\n+import org.jetbrains.annotations.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import jadx.api.plugins.input.data.annotations.EncodedType;\n+import jadx.api.plugins.input.data.annotations.EncodedValue;\n+import jadx.api.plugins.input.data.annotations.IAnnotation;\n+import jadx.core.dex.info.ClassInfo;\n+import jadx.core.dex.nodes.ClassNode;\n+\n+// TODO: parse data from d1 (protobuf encoded) to get original method names and other useful info\n+public class KotlinMetadataUtils {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(KotlinMetadataUtils.class);\n+\n+\tprivate static final String KOTLIN_METADATA_ANNOTATION = \"Lkotlin/Metadata;\";\n+\tprivate static final String KOTLIN_METADATA_D2_PARAMETER = \"d2\";\n+\tprivate static final String KOTLIN_METADATA_CLASSNAME_REGEX = \"(L.*;)\";\n+\n+\t/**\n+\t * Try to get class info from Kotlin Metadata annotation\n+\t */\n+\t@Nullable\n+\tpublic static ClassInfo getClassName(ClassNode cls) {\n+\t\tIAnnotation metadataAnnotation = cls.getAnnotation(KOTLIN_METADATA_ANNOTATION);\n+\t\tList<EncodedValue> d2Param = getParamAsList(metadataAnnotation, KOTLIN_METADATA_D2_PARAMETER);\n+\t\tif (d2Param == null || d2Param.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tEncodedValue firstValue = d2Param.get(0);\n+\t\tif (firstValue == null || firstValue.getType() != EncodedType.ENCODED_STRING) {\n+\t\t\treturn null;\n+\t\t}\n+\t\ttry {\n+\t\t\tString rawClassName = ((String) firstValue.getValue()).trim();\n+\t\t\tif (rawClassName.matches(KOTLIN_METADATA_CLASSNAME_REGEX)) {\n+\t\t\t\treturn ClassInfo.fromName(cls.root(), rawClassName);\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"Failed to parse kotlin metadata\", e);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate static List<EncodedValue> getParamAsList(IAnnotation annotation, String paramName) {\n+\t\tif (annotation == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tEncodedValue encodedValue = annotation.getValues().get(paramName);\n+\t\tif (encodedValue == null || encodedValue.getType() != EncodedType.ENCODED_ARRAY) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn (List<EncodedValue>) encodedValue.getValue();\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/deobf/TestKotlinMetadata.java b/jadx-core/src/test/java/jadx/tests/integration/deobf/TestKotlinMetadata.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/deobf/TestKotlinMetadata.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/deobf/TestKotlinMetadata.java\n@@ -0,0 +1,48 @@\n+package jadx.tests.integration.deobf;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestKotlinMetadata extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\t@file:JvmName(\"TestKotlinMetadata\")\n+\t\tclass TestMetaData {\n+\n+\t\t\t@JvmField\n+\t\t\tval id = 1\n+\n+\t\t\t@JvmName(\"makeTwo\")\n+\t\t\tfun double(x: Int): Int {\n+\t\t\t\treturn 2 * x\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tprepareArgs(true);\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"class TestMetaData {\");\n+\t}\n+\n+\t@Test\n+\tpublic void testIgnoreMetadata() {\n+\t\tprepareArgs(false);\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"class C0000TestKotlinMetadata {\");\n+\t}\n+\n+\tprivate void prepareArgs(boolean parseKotlinMetadata) {\n+\t\tenableDeobfuscation();\n+\t\targs.setDeobfuscationMinLength(100); // rename everything\n+\t\tgetArgs().setParseKotlinMetadata(parseKotlinMetadata);\n+\t\tdisableCompilation();\n+\t}\n+}",
    "output": "Fix resolved regression in Kotlin metadata parser"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -20,6 +20,8 @@\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.PhiListAttr;\n import jadx.core.dex.info.ClassInfo;\n+import jadx.core.dex.instructions.ArithNode;\n+import jadx.core.dex.instructions.ArithOp;\n import jadx.core.dex.instructions.BaseInvokeNode;\n import jadx.core.dex.instructions.IndexInsnNode;\n import jadx.core.dex.instructions.InsnType;\n@@ -759,15 +761,16 @@ && fixBooleanUsage(mth, bound)) {\n \n \tprivate boolean fixBooleanUsage(MethodNode mth, ITypeBound bound) {\n \t\tArgType boundType = bound.getType();\n-\t\tif (!boundType.isPrimitive() || boundType == ArgType.BOOLEAN) {\n+\t\tif (boundType == ArgType.BOOLEAN\n+\t\t\t\t|| (boundType.isTypeKnown() && !boundType.isPrimitive())) {\n \t\t\treturn false;\n \t\t}\n \t\tRegisterArg boundArg = bound.getArg();\n \t\tif (boundArg == null) {\n \t\t\treturn false;\n \t\t}\n \t\tInsnNode insn = boundArg.getParentInsn();\n-\t\tif (insn == null) {\n+\t\tif (insn == null || insn.getType() == InsnType.IF) {\n \t\t\treturn false;\n \t\t}\n \t\tBlockNode blockNode = BlockUtils.getBlockByInsn(mth, insn);\n@@ -779,21 +782,47 @@ private boolean fixBooleanUsage(MethodNode mth, ITypeBound bound) {\n \t\tif (insnIndex == -1) {\n \t\t\treturn false;\n \t\t}\n-\t\tif (insn.getType() == InsnType.CAST) {\n+\t\tInsnType insnType = insn.getType();\n+\t\tif (insnType == InsnType.CAST) {\n \t\t\t// replace cast\n \t\t\tArgType type = (ArgType) ((IndexInsnNode) insn).getIndex();\n \t\t\tTernaryInsn convertInsn = prepareBooleanConvertInsn(insn.getResult(), boundArg, type);\n \t\t\tBlockUtils.replaceInsn(mth, blockNode, insnIndex, convertInsn);\n-\t\t} else {\n-\t\t\t// insert before insn\n-\t\t\tRegisterArg resultArg = boundArg.duplicateWithNewSSAVar(mth);\n-\t\t\tTernaryInsn convertInsn = prepareBooleanConvertInsn(resultArg, boundArg, boundType);\n-\t\t\tinsnList.add(insnIndex, convertInsn);\n-\t\t\tinsn.replaceArg(bound.getArg(), convertInsn.getResult().duplicate());\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (insnType == InsnType.ARITH) {\n+\t\t\tArithNode arithInsn = (ArithNode) insn;\n+\t\t\tif (arithInsn.getOp() == ArithOp.XOR && arithInsn.getArgsCount() == 2) {\n+\t\t\t\t// replace (boolean ^ 1) with (!boolean)\n+\t\t\t\tInsnArg secondArg = arithInsn.getArg(1);\n+\t\t\t\tif (secondArg.isLiteral() && ((LiteralArg) secondArg).getLiteral() == 1) {\n+\t\t\t\t\tInsnNode convertInsn = notBooleanToInt(arithInsn, boundArg);\n+\t\t\t\t\tBlockUtils.replaceInsn(mth, blockNode, insnIndex, convertInsn);\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n+\n+\t\t// insert before insn\n+\t\tRegisterArg resultArg = boundArg.duplicateWithNewSSAVar(mth);\n+\t\tTernaryInsn convertInsn = prepareBooleanConvertInsn(resultArg, boundArg, boundType);\n+\t\tinsnList.add(insnIndex, convertInsn);\n+\t\tinsn.replaceArg(boundArg, convertInsn.getResult().duplicate());\n \t\treturn true;\n \t}\n \n+\tprivate InsnNode notBooleanToInt(ArithNode insn, RegisterArg boundArg) {\n+\t\tInsnNode notInsn = new InsnNode(InsnType.NOT, 1);\n+\t\tnotInsn.addArg(boundArg.duplicate());\n+\t\tnotInsn.add(AFlag.SYNTHETIC);\n+\n+\t\tInsnArg notArg = InsnArg.wrapArg(notInsn);\n+\t\tnotArg.setType(ArgType.BOOLEAN);\n+\t\tTernaryInsn convertInsn = ModVisitor.makeBooleanConvertInsn(insn.getResult(), notArg, ArgType.INT);\n+\t\tconvertInsn.add(AFlag.SYNTHETIC);\n+\t\treturn convertInsn;\n+\t}\n+\n \tprivate TernaryInsn prepareBooleanConvertInsn(RegisterArg resultArg, RegisterArg boundArg, ArgType useType) {\n \t\tRegisterArg useArg = boundArg.getSVar().getAssign().duplicate();\n \t\tTernaryInsn convertInsn = ModVisitor.makeBooleanConvertInsn(resultArg, useArg, useType);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver15.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver15.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver15.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver15.java\n@@ -0,0 +1,40 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+/**\n+ * Issue 921 (second case)\n+ */\n+public class TestTypeResolver15 extends SmaliTest {\n+\n+\tpublic static class TestCls {\n+\t\tprivate void test(boolean z) {\n+\t\t\tuseInt(z ? 0 : 8);\n+\t\t\tuseInt(!z ? 1 : 0); // replaced with xor in smali test\n+\t\t}\n+\n+\t\tprivate void useInt(int i) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t// .containsOne(\"useInt(!z ? 1 : 0);\") // TODO: convert to ternary\n+\t\t\t\t.containsOne(\"useInt(z ? 0 : 8);\");\n+\t}\n+\n+\t@Test\n+\tpublic void testSmali() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"useInt(z ? 0 : 8);\")\n+\t\t\t\t.containsOne(\"useInt(!z ? 1 : 0);\");\n+\t}\n+}",
    "output": "Fix handle xor on boolean"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -569,8 +569,16 @@ private void makeInsnBody(CodeWriter code, InsnNode insn, Set<Flags> state) thro\n \tprivate void fillArray(CodeWriter code, FillArrayInsn arrayNode) throws CodegenException {\n \t\tcode.add(\"// fill-array-data instruction\");\n \t\tcode.startLine();\n-\t\tList<LiteralArg> args = arrayNode.getLiteralArgs(arrayNode.getElementType());\n \t\tInsnArg arrArg = arrayNode.getArg(0);\n+\t\tArgType arrayType = arrArg.getType();\n+\t\tArgType elemType;\n+\t\tif (arrayType.isTypeKnown() && arrayType.isArray()) {\n+\t\t\telemType = arrayType.getArrayElement();\n+\t\t} else {\n+\t\t\tArgType elementType = arrayNode.getElementType(); // unknown type\n+\t\t\telemType = elementType.selectFirst();\n+\t\t}\n+\t\tList<LiteralArg> args = arrayNode.getLiteralArgs(elemType);\n \t\tint len = args.size();\n \t\tfor (int i = 0; i < len; i++) {\n \t\t\tif (i != 0) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayData.java b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayData.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayData.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayData.java\n@@ -14,7 +14,7 @@\n \n public final class FillArrayData extends InsnNode {\n \n-\tprivate static final ArgType ONE_BYTE_TYPE = ArgType.unknown(PrimitiveType.BOOLEAN, PrimitiveType.BYTE);\n+\tprivate static final ArgType ONE_BYTE_TYPE = ArgType.unknown(PrimitiveType.BYTE, PrimitiveType.BOOLEAN);\n \tprivate static final ArgType TWO_BYTES_TYPE = ArgType.unknown(PrimitiveType.SHORT, PrimitiveType.CHAR);\n \tprivate static final ArgType FOUR_BYTES_TYPE = ArgType.unknown(PrimitiveType.INT, PrimitiveType.FLOAT);\n \tprivate static final ArgType EIGHT_BYTES_TYPE = ArgType.unknown(PrimitiveType.LONG, PrimitiveType.DOUBLE);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/EncodedValueUtils.java b/jadx-core/src/main/java/jadx/core/utils/EncodedValueUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/EncodedValueUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/EncodedValueUtils.java\n@@ -0,0 +1,53 @@\n+package jadx.core.utils;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import jadx.api.plugins.input.data.annotations.EncodedValue;\n+import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.instructions.args.InsnArg;\n+import jadx.core.dex.instructions.args.LiteralArg;\n+import jadx.core.dex.nodes.RootNode;\n+\n+public class EncodedValueUtils {\n+\n+\t/**\n+\t * Return constant literal from {@code jadx.api.plugins.input.data.annotations.EncodedValue}\n+\t *\n+\t * @return LiteralArg, String, ArgType or null\n+\t */\n+\t@Nullable\n+\tpublic static Object convertToConstValue(RootNode root, EncodedValue encodedValue) {\n+\t\tif (encodedValue == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tObject value = encodedValue.getValue();\n+\t\tswitch (encodedValue.getType()) {\n+\t\t\tcase ENCODED_NULL:\n+\t\t\t\treturn InsnArg.lit(0, ArgType.OBJECT);\n+\t\t\tcase ENCODED_BOOLEAN:\n+\t\t\t\treturn Boolean.TRUE.equals(value) ? LiteralArg.TRUE : LiteralArg.FALSE;\n+\t\t\tcase ENCODED_BYTE:\n+\t\t\t\treturn InsnArg.lit((Byte) value, ArgType.BYTE);\n+\t\t\tcase ENCODED_SHORT:\n+\t\t\t\treturn InsnArg.lit((Short) value, ArgType.SHORT);\n+\t\t\tcase ENCODED_CHAR:\n+\t\t\t\treturn InsnArg.lit((Character) value, ArgType.CHAR);\n+\t\t\tcase ENCODED_INT:\n+\t\t\t\treturn InsnArg.lit((Integer) value, ArgType.INT);\n+\t\t\tcase ENCODED_LONG:\n+\t\t\t\treturn InsnArg.lit((Long) value, ArgType.LONG);\n+\t\t\tcase ENCODED_FLOAT:\n+\t\t\t\treturn InsnArg.lit(Float.floatToIntBits((Float) value), ArgType.FLOAT);\n+\t\t\tcase ENCODED_DOUBLE:\n+\t\t\t\treturn InsnArg.lit(Double.doubleToLongBits((Double) value), ArgType.DOUBLE);\n+\t\t\tcase ENCODED_STRING:\n+\t\t\t\treturn (String) value;\n+\n+\t\t\tcase ENCODED_TYPE:\n+\t\t\t\treturn ArgType.parse((String) value);\n+\n+\t\t\tdefault:\n+\t\t\t\treturn null;\n+\t\t}\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/InsnUtils.java b/jadx-core/src/main/java/jadx/core/utils/InsnUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/InsnUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/InsnUtils.java\n@@ -101,11 +101,8 @@ public static Object getConstValueByInsn(RootNode root, InsnNode insn) {\n \t\t\t\t\treturn null;\n \t\t\t\t}\n \t\t\t\tFieldInitAttr attr = fieldNode.get(AType.FIELD_INIT);\n-\t\t\t\tif (attr != null) {\n-\t\t\t\t\tif (attr.getValueType() == FieldInitAttr.InitType.CONST) {\n-\t\t\t\t\t\treturn attr.getEncodedValue().getValue();\n-\t\t\t\t\t}\n-\t\t\t\t\treturn attr.getInsn();\n+\t\t\t\tif (attr != null && attr.getValueType() == FieldInitAttr.InitType.CONST) {\n+\t\t\t\t\treturn EncodedValueUtils.convertToConstValue(root, attr.getEncodedValue());\n \t\t\t\t}\n \t\t\t\treturn null;\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayFill4.java b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayFill4.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayFill4.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayFill4.java\n@@ -0,0 +1,29 @@\n+package jadx.tests.integration.arrays;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestArrayFill4 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\t// replaced constant break filled array creation\n+\t\tprivate static final int ARRAY_SIZE = 4;\n+\n+\t\tpublic long[] test() {\n+\t\t\treturn new long[] { 0, 1, Long.MAX_VALUE, Long.MIN_VALUE + 1 };\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"new long[ARRAY_SIZE];\")\n+\t\t\t\t.containsOne(\"return new long[]{0, 1, \");\n+\t}\n+}",
    "output": "Fix correct type and data merge for filled-array instruction"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n@@ -15,6 +15,7 @@ public enum AFlag {\n \n \tDONT_WRAP,\n \tDONT_INLINE,\n+\tDONT_INLINE_CONST,\n \tDONT_GENERATE, // process as usual, but don't output to generated code\n \tCOMMENT_OUT, // process as usual, but comment insn in generated code\n \tREMOVE, // can be completely removed\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n@@ -10,7 +10,6 @@\n import jadx.core.dex.instructions.IndexInsnNode;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.InvokeNode;\n-import jadx.core.dex.instructions.InvokeType;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.LiteralArg;\n@@ -73,17 +72,8 @@ private static void checkInsn(MethodNode mth, InsnNode insn, List<InsnNode> toRe\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tlong lit = ((LiteralArg) constArg).getLiteral();\n-\t\t\tif (lit == 0 && checkObjectInline(sVar)) {\n-\t\t\t\tif (sVar.getUseCount() == 1) {\n-\t\t\t\t\tInsnNode assignInsn = insn.getResult().getAssignInsn();\n-\t\t\t\t\tif (assignInsn != null) {\n-\t\t\t\t\t\tassignInsn.add(AFlag.DONT_INLINE);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\t// don't inline const values in synchronized statement\n-\t\t\tif (checkForSynchronizeBlock(insn, sVar)) {\n+\t\t\tif (lit == 0 && forbidNullInlines(sVar)) {\n+\t\t\t\t// all usages forbids inlining\n \t\t\t\treturn;\n \t\t\t}\n \t\t} else if (insnType == InsnType.CONST_STR) {\n@@ -117,20 +107,6 @@ private static void checkInsn(MethodNode mth, InsnNode insn, List<InsnNode> toRe\n \t\treplaceConst(mth, insn, constArg, toRemove);\n \t}\n \n-\tprivate static boolean checkForSynchronizeBlock(InsnNode insn, SSAVar ssaVar) {\n-\t\tfor (RegisterArg reg : ssaVar.getUseList()) {\n-\t\t\tInsnNode parentInsn = reg.getParentInsn();\n-\t\t\tif (parentInsn != null) {\n-\t\t\t\tInsnType insnType = parentInsn.getType();\n-\t\t\t\tif (insnType == InsnType.MONITOR_ENTER || insnType == InsnType.MONITOR_EXIT) {\n-\t\t\t\t\tinsn.add(AFlag.DONT_INLINE);\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n \tprivate static boolean checkForFinallyBlock(SSAVar sVar) {\n \t\tList<SSAVar> ssaVars = sVar.getCodeVar().getSsaVars();\n \t\tif (ssaVars.size() <= 1) {\n@@ -153,45 +129,67 @@ private static boolean checkForFinallyBlock(SSAVar sVar) {\n \t}\n \n \t/**\n-\t * Don't inline null object if:\n-\t * - used as instance arg in invoke instruction\n-\t * - used in 'array.length'\n+\t * Don't inline null object\n \t */\n-\tprivate static boolean checkObjectInline(SSAVar sVar) {\n-\t\tfor (RegisterArg useArg : sVar.getUseList()) {\n+\tprivate static boolean forbidNullInlines(SSAVar sVar) {\n+\t\tList<RegisterArg> useList = sVar.getUseList();\n+\t\tif (useList.isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tint k = 0;\n+\t\tfor (RegisterArg useArg : useList) {\n \t\t\tInsnNode insn = useArg.getParentInsn();\n \t\t\tif (insn == null) {\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tInsnType insnType = insn.getType();\n-\t\t\tif (insnType == InsnType.INVOKE) {\n-\t\t\t\tInvokeNode inv = (InvokeNode) insn;\n-\t\t\t\tif (inv.getInvokeType() != InvokeType.STATIC\n-\t\t\t\t\t\t&& inv.getArg(0) == useArg) {\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n-\t\t\t} else if (insnType == InsnType.ARRAY_LENGTH) {\n-\t\t\t\tif (insn.getArg(0) == useArg) {\n-\t\t\t\t\treturn true;\n-\t\t\t\t}\n+\t\t\tif (!canUseNull(insn, useArg)) {\n+\t\t\t\tuseArg.add(AFlag.DONT_INLINE_CONST);\n+\t\t\t\tk++;\n \t\t\t}\n \t\t}\n-\t\treturn false;\n+\t\treturn k == useList.size();\n \t}\n \n-\tprivate static int replaceConst(MethodNode mth, InsnNode constInsn, InsnArg constArg, List<InsnNode> toRemove) {\n+\tprivate static boolean canUseNull(InsnNode insn, RegisterArg useArg) {\n+\t\tswitch (insn.getType()) {\n+\t\t\tcase INVOKE:\n+\t\t\t\treturn ((InvokeNode) insn).getInstanceArg() != useArg;\n+\n+\t\t\tcase ARRAY_LENGTH:\n+\t\t\tcase AGET:\n+\t\t\tcase APUT:\n+\t\t\tcase IGET:\n+\t\t\tcase SWITCH:\n+\t\t\tcase MONITOR_ENTER:\n+\t\t\tcase MONITOR_EXIT:\n+\t\t\tcase INSTANCE_OF:\n+\t\t\t\treturn insn.getArg(0) != useArg;\n+\n+\t\t\tcase IPUT:\n+\t\t\t\treturn insn.getArg(1) != useArg;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate static void replaceConst(MethodNode mth, InsnNode constInsn, InsnArg constArg, List<InsnNode> toRemove) {\n \t\tSSAVar ssaVar = constInsn.getResult().getSVar();\n+\t\tif (ssaVar.getUseCount() == 0) {\n+\t\t\ttoRemove.add(constInsn);\n+\t\t\treturn;\n+\t\t}\n \t\tList<RegisterArg> useList = new ArrayList<>(ssaVar.getUseList());\n \t\tint replaceCount = 0;\n \t\tfor (RegisterArg arg : useList) {\n+\t\t\tif (arg.contains(AFlag.DONT_INLINE_CONST)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tif (replaceArg(mth, arg, constArg, constInsn, toRemove)) {\n \t\t\t\treplaceCount++;\n \t\t\t}\n \t\t}\n \t\tif (replaceCount == useList.size()) {\n \t\t\ttoRemove.add(constInsn);\n \t\t}\n-\t\treturn replaceCount;\n \t}\n \n \tprivate static boolean replaceArg(MethodNode mth, RegisterArg arg, InsnArg constArg, InsnNode constInsn, List<InsnNode> toRemove) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n@@ -93,10 +93,14 @@ private static void checkInline(MethodNode mth, BlockNode block, InsnList insnLi\n \t\t}\n \t\tList<RegisterArg> useList = sVar.getUseList();\n \t\tif (!useList.isEmpty()) {\n-\t\t\tInsnNode parentInsn = useList.get(0).getParentInsn();\n+\t\t\tRegisterArg useArg = useList.get(0);\n+\t\t\tInsnNode parentInsn = useArg.getParentInsn();\n \t\t\tif (parentInsn != null && parentInsn.contains(AFlag.DONT_GENERATE)) {\n \t\t\t\treturn;\n \t\t\t}\n+\t\t\tif (!assignInline && useArg.contains(AFlag.DONT_INLINE_CONST)) {\n+\t\t\t\treturn;\n+\t\t\t}\n \t\t}\n \n \t\tint assignPos = insnList.getIndex(assignInsn);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/Utils.java b/jadx-core/src/main/java/jadx/core/utils/Utils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/Utils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java\n@@ -58,7 +58,7 @@ public static String listToString(Iterable<?> objects, String joiner) {\n \t\tif (objects == null) {\n \t\t\treturn \"\";\n \t\t}\n-\t\treturn listToString(objects, joiner, Object::toString);\n+\t\treturn listToString(objects, joiner, Objects::toString);\n \t}\n \n \tpublic static <T> String listToString(Iterable<T> objects, Function<T, String> toStr) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestWrongCode2.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestWrongCode2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestWrongCode2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestWrongCode2.java\n@@ -0,0 +1,65 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestWrongCode2 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\t@SuppressWarnings(\"ConstantConditions\")\n+\t\tpublic String test() {\n+\t\t\tA a = null;\n+\t\t\ta.str = \"\";\n+\t\t\treturn a.str;\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"ConstantConditions\")\n+\t\tpublic int test2() {\n+\t\t\tint[] a = null;\n+\t\t\ta[1] = 2;\n+\t\t\treturn a[0];\n+\t\t}\n+\n+\t\t@SuppressWarnings({ \"ConstantConditions\", \"SynchronizationOnLocalVariableOrMethodParameter\" })\n+\t\tpublic boolean test3() {\n+\t\t\tA a = null;\n+\t\t\tsynchronized (a) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic boolean test4() {\n+\t\t\treturn null instanceof A;\n+\t\t}\n+\n+\t\t// everything is 'A' :)\n+\t\t@SuppressWarnings({ \"MethodName\", \"LocalVariableName\" }) // ignore checkstyle\n+\t\tpublic A A() {\n+\t\t\tA A = A();\n+\t\t\tA.A = A;\n+\t\t\treturn A;\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"MemberName\")\n+\t\tpublic static class A {\n+\t\t\tpublic String str;\n+\t\t\tpublic A A;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"return a.str;\");\n+\t}\n+\n+\t@Test\n+\tpublic void testNoDebug() {\n+\t\tnoDebugInfo();\n+\t\tgetClassNode(TestCls.class);\n+\t}\n+}",
    "output": "Fix don't inline 'null' object to make code compilable"
  },
  {
    "input": "diff --git a/jadx-cli/src/test/java/jadx/cli/TestInput.java b/jadx-cli/src/test/java/jadx/cli/TestInput.java\n--- a/jadx-cli/src/test/java/jadx/cli/TestInput.java\n+++ b/jadx-cli/src/test/java/jadx/cli/TestInput.java\n@@ -33,6 +33,11 @@ public void testSmaliInput() throws Exception {\n \t\tdecompile(\"smali\", \"samples/HelloWorld.smali\");\n \t}\n \n+\t@Test\n+\tpublic void testClassInput() throws Exception {\n+\t\tdecompile(\"class\", \"samples/HelloWorld.class\");\n+\t}\n+\n \tprivate void decompile(String tmpDirName, String inputSample) throws URISyntaxException, IOException {\n \t\tStringBuilder args = new StringBuilder();\n \t\tPath tempDir = FileUtils.createTempDir(tmpDirName);\n\ndiff --git a/jadx-core/src/main/java/jadx/api/impl/InMemoryCodeCache.java b/jadx-core/src/main/java/jadx/api/impl/InMemoryCodeCache.java\n--- a/jadx-core/src/main/java/jadx/api/impl/InMemoryCodeCache.java\n+++ b/jadx-core/src/main/java/jadx/api/impl/InMemoryCodeCache.java\n@@ -26,4 +26,9 @@ public void remove(String clsFullName) {\n \tpublic @Nullable ICodeInfo get(String clsFullName) {\n \t\treturn storage.get(clsFullName);\n \t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"InMemoryCodeCache\";\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/api/impl/NoOpCodeCache.java b/jadx-core/src/main/java/jadx/api/impl/NoOpCodeCache.java\n--- a/jadx-core/src/main/java/jadx/api/impl/NoOpCodeCache.java\n+++ b/jadx-core/src/main/java/jadx/api/impl/NoOpCodeCache.java\n@@ -21,4 +21,9 @@ public void remove(String clsFullName) {\n \tpublic @Nullable ICodeInfo get(String clsFullName) {\n \t\treturn null;\n \t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"NoOpCodeCache\";\n+\t}\n }\n\ndiff --git a/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java b/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n--- a/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n+++ b/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n@@ -1,40 +1,86 @@\n package jadx.plugins.input.javaconvert;\n \n+import java.io.BufferedInputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.FileSystems;\n import java.nio.file.Files;\n import java.nio.file.LinkOption;\n import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n+import org.objectweb.asm.ClassReader;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.api.plugins.utils.ZipSecurity;\n+\n public class JavaConvertLoader {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(JavaConvertLoader.class);\n \n \tpublic static ConvertResult process(List<Path> input) {\n \t\tConvertResult result = new ConvertResult();\n-\t\tfor (Path path : input) {\n-\t\t\tif (isJavaFile(path)) {\n-\t\t\t\ttry {\n-\t\t\t\t\tconvert(result, path);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tLOG.error(\"Failed to convert file: \" + path.toAbsolutePath(), e);\n+\t\tprocessJars(input, result);\n+\t\tprocessClassFiles(input, result);\n+\t\treturn result;\n+\t}\n+\n+\tprivate static void processJars(List<Path> input, ConvertResult result) {\n+\t\tPathMatcher jarMatcher = FileSystems.getDefault().getPathMatcher(\"glob:**.jar\");\n+\t\tinput.stream()\n+\t\t\t\t.filter(path -> Files.isRegularFile(path, LinkOption.NOFOLLOW_LINKS))\n+\t\t\t\t.filter(jarMatcher::matches)\n+\t\t\t\t.forEach(path -> {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tconvertJar(result, path);\n+\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\tLOG.error(\"Failed to convert file: \" + path.toAbsolutePath(), e);\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t}\n+\n+\tprivate static void processClassFiles(List<Path> input, ConvertResult result) {\n+\t\tPathMatcher jarMatcher = FileSystems.getDefault().getPathMatcher(\"glob:**.class\");\n+\t\tList<Path> clsFiles = input.stream()\n+\t\t\t\t.filter(path -> Files.isRegularFile(path, LinkOption.NOFOLLOW_LINKS))\n+\t\t\t\t.filter(jarMatcher::matches)\n+\t\t\t\t.collect(Collectors.toList());\n+\t\tif (clsFiles.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\t\ttry {\n+\t\t\tPath jarFile = Files.createTempFile(\"jadx-\", \".jar\");\n+\t\t\ttry (JarOutputStream jo = new JarOutputStream(Files.newOutputStream(jarFile))) {\n+\t\t\t\tfor (Path file : clsFiles) {\n+\t\t\t\t\tString clsName = getNameFromClassFile(file);\n+\t\t\t\t\tif (clsName == null || !ZipSecurity.isValidZipEntryName(clsName)) {\n+\t\t\t\t\t\tthrow new IOException(\"Can't read class name from file: \" + file);\n+\t\t\t\t\t}\n+\t\t\t\t\taddFileToJar(jo, file, clsName + \".class\");\n \t\t\t\t}\n \t\t\t}\n+\t\t\tresult.addTempPath(jarFile);\n+\t\t\tLOG.debug(\"Packed class files {} into jar {}\", clsFiles, jarFile);\n+\t\t\tconvertJar(result, jarFile);\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"Error process class files\", e);\n \t\t}\n-\t\treturn result;\n \t}\n \n-\tprivate static boolean isJavaFile(Path path) {\n-\t\tString fileName = path.getFileName().toString();\n-\t\treturn fileName.endsWith(\".jar\")\n-\t\t\t\t|| fileName.endsWith(\".class\");\n+\tpublic static String getNameFromClassFile(Path file) throws IOException {\n+\t\ttry (InputStream in = Files.newInputStream(file)) {\n+\t\t\tClassReader classReader = new ClassReader(in);\n+\t\t\treturn classReader.getClassName();\n+\t\t}\n \t}\n \n-\tprivate static void convert(ConvertResult result, Path path) throws Exception {\n+\tprivate static void convertJar(ConvertResult result, Path path) throws Exception {\n \t\tPath tempDirectory = Files.createTempDirectory(\"jadx-\");\n \t\tresult.addTempPath(tempDirectory);\n \n@@ -45,10 +91,34 @@ private static void convert(ConvertResult result, Path path) throws Exception {\n \t}\n \n \tprivate static List<Path> collectFilesInDir(Path tempDirectory) throws IOException {\n+\t\tPathMatcher dexMatcher = FileSystems.getDefault().getPathMatcher(\"glob:**.dex\");\n \t\ttry (Stream<Path> pathStream = Files.walk(tempDirectory, 1)) {\n \t\t\treturn pathStream\n \t\t\t\t\t.filter(p -> Files.isRegularFile(p, LinkOption.NOFOLLOW_LINKS))\n+\t\t\t\t\t.filter(dexMatcher::matches)\n \t\t\t\t\t.collect(Collectors.toList());\n \t\t}\n \t}\n+\n+\tpublic static void addFileToJar(JarOutputStream jar, Path source, String entryName) throws IOException {\n+\t\ttry (BufferedInputStream in = new BufferedInputStream(Files.newInputStream(source))) {\n+\t\t\tJarEntry entry = new JarEntry(entryName);\n+\t\t\tentry.setTime(Files.getLastModifiedTime(source, LinkOption.NOFOLLOW_LINKS).toMillis());\n+\t\t\tjar.putNextEntry(entry);\n+\n+\t\t\tcopyStream(in, jar);\n+\t\t\tjar.closeEntry();\n+\t\t}\n+\t}\n+\n+\tpublic static void copyStream(InputStream input, OutputStream output) throws IOException {\n+\t\tbyte[] buffer = new byte[8 * 1024];\n+\t\twhile (true) {\n+\t\t\tint count = input.read(buffer);\n+\t\t\tif (count == -1) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\toutput.write(buffer, 0, count);\n+\t\t}\n+\t}\n }",
    "output": "Fix load .class files"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n@@ -21,6 +21,7 @@\n import jadx.core.utils.BlockUtils;\n import jadx.core.utils.InsnList;\n import jadx.core.utils.InsnRemover;\n+import jadx.core.utils.RegionUtils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n @JadxVisitor(\n@@ -109,7 +110,7 @@ private static void checkInline(MethodNode mth, BlockNode block, InsnList insnLi\n \t\t\tBlockNode assignBlock = BlockUtils.getBlockByInsn(mth, assignInsn);\n \t\t\tif (assignBlock != null\n \t\t\t\t\t&& assignInsn != arg.getParentInsn()\n-\t\t\t\t\t&& canMoveBetweenBlocks(assignInsn, assignBlock, block, argsInfo.getInsn())) {\n+\t\t\t\t\t&& canMoveBetweenBlocks(mth, assignInsn, assignBlock, block, argsInfo.getInsn())) {\n \t\t\t\tif (assignInline) {\n \t\t\t\t\tassignInline(mth, arg, assignInsn, assignBlock);\n \t\t\t\t} else {\n@@ -150,7 +151,7 @@ private static boolean inline(MethodNode mth, RegisterArg arg, InsnNode insn, Bl\n \t\treturn replaced;\n \t}\n \n-\tprivate static boolean canMoveBetweenBlocks(InsnNode assignInsn, BlockNode assignBlock,\n+\tprivate static boolean canMoveBetweenBlocks(MethodNode mth, InsnNode assignInsn, BlockNode assignBlock,\n \t\t\tBlockNode useBlock, InsnNode useInsn) {\n \t\tif (!BlockUtils.isPathExists(assignBlock, useBlock)) {\n \t\t\treturn false;\n@@ -176,8 +177,12 @@ private static boolean canMoveBetweenBlocks(InsnNode assignInsn, BlockNode assig\n \t\tfor (BlockNode block : pathsBlocks) {\n \t\t\tif (block.contains(AFlag.DONT_GENERATE)) {\n \t\t\t\tif (BlockUtils.checkLastInsnType(block, InsnType.MONITOR_EXIT)) {\n-\t\t\t\t\t// don't move from synchronized block\n-\t\t\t\t\treturn false;\n+\t\t\t\t\tif (RegionUtils.isBlocksInSameRegion(mth, assignBlock, useBlock)) {\n+\t\t\t\t\t\t// allow move inside same synchronized region\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// don't move from synchronized block\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\t// skip checks for not generated blocks\n \t\t\t\tcontinue;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java b/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/RegionUtils.java\n@@ -19,6 +19,8 @@\n import jadx.core.dex.nodes.IContainer;\n import jadx.core.dex.nodes.IRegion;\n import jadx.core.dex.nodes.InsnNode;\n+import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.dex.regions.Region;\n import jadx.core.dex.trycatch.CatchAttr;\n import jadx.core.dex.trycatch.ExceptionHandler;\n import jadx.core.dex.trycatch.TryCatchBlock;\n@@ -329,6 +331,26 @@ public static IContainer getBlockContainer(IContainer container, BlockNode block\n \t\t}\n \t}\n \n+\t/**\n+\t * Check if two blocks in same region on same level\n+\t * TODO: Add 'region' annotation to all blocks to speed up checks\n+\t */\n+\tpublic static boolean isBlocksInSameRegion(MethodNode mth, BlockNode firstBlock, BlockNode secondBlock) {\n+\t\tRegion region = mth.getRegion();\n+\t\tif (region == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tIContainer firstContainer = getBlockContainer(region, firstBlock);\n+\t\tif (firstContainer instanceof IRegion) {\n+\t\t\tif (firstContainer instanceof IBranchRegion) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tList<IContainer> subBlocks = ((IRegion) firstContainer).getSubBlocks();\n+\t\t\treturn subBlocks.contains(secondBlock);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tpublic static boolean isDominatedBy(BlockNode dom, IContainer cont) {\n \t\tif (dom == cont) {\n \t\t\treturn true;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized4.java b/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized4.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized4.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized4.java\n@@ -26,6 +26,8 @@ public boolean test(int i) {\n \tpublic void test() {\n \t\tassertThat(getClassNodeFromSmali())\n \t\t\t\t.code()\n-\t\t\t\t.containsOne(\"synchronized (this.obj) {\");\n+\t\t\t\t.containsOne(\"synchronized (this.obj) {\")\n+\t\t\t\t.containsOne(\"return call(this.obj, i);\")\n+\t\t\t\t.containsOne(\"return getField() == null;\");\n \t}\n }",
    "output": "Fix allow to inline variables around 'monitor-exit' in synchronized block"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/regions/SynchronizedRegion.java b/jadx-core/src/main/java/jadx/core/dex/regions/SynchronizedRegion.java\n--- a/jadx-core/src/main/java/jadx/core/dex/regions/SynchronizedRegion.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/regions/SynchronizedRegion.java\n@@ -1,6 +1,6 @@\n package jadx.core.dex.regions;\n \n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.List;\n \n import jadx.core.dex.nodes.IContainer;\n@@ -10,7 +10,7 @@\n public final class SynchronizedRegion extends AbstractRegion {\n \n \tprivate final InsnNode enterInsn;\n-\tprivate final List<InsnNode> exitInsns = new LinkedList<>();\n+\tprivate final List<InsnNode> exitInsns = new ArrayList<>();\n \tprivate final Region region;\n \n \tpublic SynchronizedRegion(IRegion parent, InsnNode insn) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -6,7 +6,6 @@\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -538,17 +537,22 @@ private static void collectWhileDominates(BlockNode dominator, BlockNode child,\n \t}\n \n \tpublic static List<BlockNode> buildSimplePath(BlockNode block) {\n-\t\tList<BlockNode> list = new LinkedList<>();\n-\t\tBlockNode currentBlock = block;\n+\t\tif (block == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tList<BlockNode> list = new ArrayList<>();\n+\t\tif (block.getCleanSuccessors().size() >= 2) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tlist.add(block);\n+\n+\t\tBlockNode currentBlock = getNextBlock(block);\n \t\twhile (currentBlock != null\n \t\t\t\t&& currentBlock.getCleanSuccessors().size() < 2\n \t\t\t\t&& currentBlock.getPredecessors().size() == 1) {\n \t\t\tlist.add(currentBlock);\n \t\t\tcurrentBlock = getNextBlock(currentBlock);\n \t\t}\n-\t\tif (list.isEmpty()) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n \t\treturn list;\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized4.java b/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized4.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized4.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized4.java\n@@ -0,0 +1,31 @@\n+package jadx.tests.integration.synchronize;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestSynchronized4 extends SmaliTest {\n+\n+\t// @formatter:off\n+\t/*\n+\t\tpublic boolean test(int i) {\n+\t\t\tsynchronized (this.obj) {\n+\t\t\t\tif (isZero(i)) {\n+\t\t\t\t\treturn call(obj, i);\n+\t\t\t\t}\n+\t\t\t\tSystem.out.println();\n+\t\t\t\treturn getField() == null;\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"synchronized (this.obj) {\");\n+\t}\n+}",
    "output": "Fix correct detection of exits in synchronized block"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n@@ -52,12 +52,8 @@ public void setType(ArgType newType) {\n \t\tsVar.setType(newType);\n \t}\n \n-\tpublic void updateImmutableType(ArgType type) {\n-\t\tif (sVar == null) {\n-\t\t\tthrow new JadxRuntimeException(\"Unknown SSA variable to update immutable type: \" + this);\n-\t\t}\n-\t\tsVar.forceSetType(type);\n-\t\tsVar.getAssign().add(AFlag.IMMUTABLE_TYPE);\n+\tpublic void forceSetInitType(ArgType type) {\n+\t\tthis.type = type;\n \t}\n \n \t@Nullable\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n@@ -8,7 +8,10 @@\n \n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import jadx.core.Consts;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;\n@@ -21,6 +24,8 @@\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public class SSAVar {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(SSAVar.class);\n+\n \tprivate final int regNum;\n \tprivate final int version;\n \n@@ -68,8 +73,8 @@ public int getUseCount() {\n \n \t@Nullable\n \tpublic ArgType getImmutableType() {\n-\t\tif (assign.contains(AFlag.IMMUTABLE_TYPE)) {\n-\t\t\treturn assign.getType();\n+\t\tif (isTypeImmutable()) {\n+\t\t\treturn assign.getInitType();\n \t\t}\n \t\treturn null;\n \t}\n@@ -78,6 +83,17 @@ public boolean isTypeImmutable() {\n \t\treturn assign.contains(AFlag.IMMUTABLE_TYPE);\n \t}\n \n+\tpublic void markAsImmutable(ArgType type) {\n+\t\tassign.add(AFlag.IMMUTABLE_TYPE);\n+\t\tArgType initType = assign.getInitType();\n+\t\tif (!initType.equals(type)) {\n+\t\t\tassign.forceSetInitType(type);\n+\t\t\tif (Consts.DEBUG_TYPE_INFERENCE) {\n+\t\t\t\tLOG.debug(\"Update immutable type at var {} assign with type: {} previous type: {}\", this.toShortString(), type, initType);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tpublic void setType(ArgType type) {\n \t\tArgType imType = getImmutableType();\n \t\tif (imType != null && !imType.equals(type)) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -803,21 +803,15 @@ private TernaryInsn prepareBooleanConvertInsn(RegisterArg resultArg, RegisterArg\n \n \tprivate static void assignImmutableTypes(MethodNode mth) {\n \t\tfor (SSAVar ssaVar : mth.getSVars()) {\n-\t\t\tArgType imType = getSsaImmutableType(ssaVar);\n-\t\t\tif (imType != null) {\n-\t\t\t\tssaVar.getAssign().updateImmutableType(imType);\n+\t\t\tArgType immutableType = getSsaImmutableType(ssaVar);\n+\t\t\tif (immutableType != null) {\n+\t\t\t\tssaVar.markAsImmutable(immutableType);\n \t\t\t}\n \t\t}\n \t}\n \n \t@Nullable\n \tprivate static ArgType getSsaImmutableType(SSAVar ssaVar) {\n-\t\tif (ssaVar.isTypeImmutable()) {\n-\t\t\tArgType type = ssaVar.getTypeInfo().getType();\n-\t\t\tif (type != ArgType.UNKNOWN) {\n-\t\t\t\treturn type;\n-\t\t\t}\n-\t\t}\n \t\tif (ssaVar.getAssign().contains(AFlag.IMMUTABLE_TYPE)) {\n \t\t\treturn ssaVar.getAssign().getInitType();\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitiveConversion.java\n@@ -0,0 +1,28 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestPrimitiveConversion extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tpublic void test(long j, boolean z) {\n+\t\t\tputByte(j, z ? (byte) 1 : (byte) 0);\n+\t\t}\n+\n+\t\tprivate static void putByte(long j, byte z) {\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"putByte(j, z);\")\n+\t\t\t\t.containsOne(\"putByte(j, z ? (byte) 1 : 0);\");\n+\t}\n+}",
    "output": "Fix handle method arguments in primitive types conversion"
  },
  {
    "input": "diff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java\n@@ -347,7 +347,7 @@ public void decode(DexInsnData insn, int opcodeUnit, SectionReader in) {\n \t\tpublic void skip(DexInsnData insn, SectionReader in) {\n \t\t\tint elemSize = in.readUShort();\n \t\t\tint size = in.readInt();\n-\t\t\tif (size == 1) {\n+\t\t\tif (elemSize == 1) {\n \t\t\t\tin.skip(size + size % 2);\n \t\t\t} else {\n \t\t\t\tin.skip(size * elemSize);",
    "output": "Fix correct parsing for array-data-payload"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Consts.java b/jadx-core/src/main/java/jadx/core/Consts.java\n--- a/jadx-core/src/main/java/jadx/core/Consts.java\n+++ b/jadx-core/src/main/java/jadx/core/Consts.java\n@@ -4,6 +4,7 @@ public class Consts {\n \tpublic static final boolean DEBUG = false;\n \tpublic static final boolean DEBUG_USAGE = false;\n \tpublic static final boolean DEBUG_TYPE_INFERENCE = false;\n+\tpublic static final boolean DEBUG_OVERLOADED_CASTS = false;\n \n \tpublic static final String CLASS_OBJECT = \"java.lang.Object\";\n \tpublic static final String CLASS_STRING = \"java.lang.String\";\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java\n@@ -3,7 +3,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import jadx.core.deobf.NameMapper;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.LiteralArg;\n@@ -71,11 +70,7 @@ public static String literalToString(long lit, ArgType type, StringUtils stringU\n \t\t\tcase BOOLEAN:\n \t\t\t\treturn lit == 0 ? \"false\" : \"true\";\n \t\t\tcase CHAR:\n-\t\t\t\tchar ch = (char) lit;\n-\t\t\t\tif (!NameMapper.isPrintableChar(ch)) {\n-\t\t\t\t\treturn Integer.toString(ch);\n-\t\t\t\t}\n-\t\t\t\treturn stringUtils.unescapeChar(ch);\n+\t\t\t\treturn stringUtils.unescapeChar((char) lit, cast);\n \t\t\tcase BYTE:\n \t\t\t\treturn formatByte(lit, cast);\n \t\t\tcase SHORT:\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java\n@@ -278,13 +278,14 @@ private List<ArgType> searchCastTypes(MethodNode parentMth, IMethodDetails mthDe\n \t\tif (argsCount == 1) {\n \t\t\treturn mthDetails.getArgTypes();\n \t\t}\n-\t\t// TODO: try to minimize casts count\n-\t\tparentMth.addComment(\"JADX DEBUG: Failed to find minimal casts for resolve overloaded methods, cast all args instead\"\n-\t\t\t\t+ NL + \" method: \" + mthDetails\n-\t\t\t\t+ NL + \" arg types: \" + compilerVarTypes\n-\t\t\t\t+ NL + \" candidates:\"\n-\t\t\t\t+ NL + \"  \" + Utils.listToString(overloadedMethods, NL + \"  \"));\n-\n+\t\tif (Consts.DEBUG_OVERLOADED_CASTS) {\n+\t\t\t// TODO: try to minimize casts count\n+\t\t\tparentMth.addComment(\"JADX DEBUG: Failed to find minimal casts for resolve overloaded methods, cast all args instead\"\n+\t\t\t\t\t+ NL + \" method: \" + mthDetails\n+\t\t\t\t\t+ NL + \" arg types: \" + compilerVarTypes\n+\t\t\t\t\t+ NL + \" candidates:\"\n+\t\t\t\t\t+ NL + \"  \" + Utils.listToString(overloadedMethods, NL + \"  \"));\n+\t\t}\n \t\t// not resolved -> cast all args\n \t\treturn mthDetails.getArgTypes();\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/StringUtils.java b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n@@ -1,6 +1,9 @@\n package jadx.core.utils;\n \n+import org.jetbrains.annotations.Nullable;\n+\n import jadx.api.JadxArgs;\n+import jadx.core.deobf.NameMapper;\n \n public class StringUtils {\n \tprivate static final StringUtils DEFAULT_INSTANCE = new StringUtils(new JadxArgs());\n@@ -24,57 +27,74 @@ public String unescapeString(String str) {\n \t\tres.append('\"');\n \t\tfor (int i = 0; i < len; i++) {\n \t\t\tint c = str.charAt(i) & 0xFFFF;\n-\t\t\tprocessChar(c, res);\n+\t\t\tprocessCharInsideString(c, res);\n \t\t}\n \t\tres.append('\"');\n \t\treturn res.toString();\n \t}\n \n-\tpublic String unescapeChar(char ch) {\n-\t\tif (ch == '\\'') {\n-\t\t\treturn \"'\\\\\\''\";\n+\tprivate void processCharInsideString(int c, StringBuilder res) {\n+\t\tString str = getSpecialStringForChar(c);\n+\t\tif (str != null) {\n+\t\t\tres.append(str);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (c < 32 || c >= 127 && escapeUnicode) {\n+\t\t\tres.append(\"\\\\u\").append(String.format(\"%04x\", c));\n+\t\t} else {\n+\t\t\tres.append((char) c);\n \t\t}\n-\t\tStringBuilder res = new StringBuilder();\n-\t\tres.append('\\'');\n-\t\tprocessChar(ch, res);\n-\t\tres.append('\\'');\n-\t\treturn res.toString();\n \t}\n \n-\tprivate void processChar(int c, StringBuilder res) {\n+\t/**\n+\t * Represent single char best way possible\n+\t */\n+\tpublic String unescapeChar(int c, boolean explicitCast) {\n+\t\tif (c == '\\'') {\n+\t\t\treturn \"'\\\\''\";\n+\t\t}\n+\t\tString str = getSpecialStringForChar(c);\n+\t\tif (str != null) {\n+\t\t\treturn '\\'' + str + '\\'';\n+\t\t}\n+\t\tif (c >= 127 && escapeUnicode) {\n+\t\t\treturn String.format(\"'\\\\u%04x'\", c);\n+\t\t}\n+\t\tif (NameMapper.isPrintableChar(c)) {\n+\t\t\treturn \"'\" + (char) c + '\\'';\n+\t\t}\n+\t\tif (explicitCast) {\n+\t\t\treturn \"(char) \" + c;\n+\t\t}\n+\t\treturn String.valueOf(c);\n+\t}\n+\n+\tpublic String unescapeChar(char ch) {\n+\t\treturn unescapeChar(ch, false);\n+\t}\n+\n+\t@Nullable\n+\tprivate String getSpecialStringForChar(int c) {\n \t\tswitch (c) {\n \t\t\tcase '\\n':\n-\t\t\t\tres.append(\"\\\\n\");\n-\t\t\t\tbreak;\n+\t\t\t\treturn \"\\\\n\";\n \t\t\tcase '\\r':\n-\t\t\t\tres.append(\"\\\\r\");\n-\t\t\t\tbreak;\n+\t\t\t\treturn \"\\\\r\";\n \t\t\tcase '\\t':\n-\t\t\t\tres.append(\"\\\\t\");\n-\t\t\t\tbreak;\n+\t\t\t\treturn \"\\\\t\";\n \t\t\tcase '\\b':\n-\t\t\t\tres.append(\"\\\\b\");\n-\t\t\t\tbreak;\n+\t\t\t\treturn \"\\\\b\";\n \t\t\tcase '\\f':\n-\t\t\t\tres.append(\"\\\\f\");\n-\t\t\t\tbreak;\n+\t\t\t\treturn \"\\\\f\";\n \t\t\tcase '\\'':\n-\t\t\t\tres.append('\\'');\n-\t\t\t\tbreak;\n+\t\t\t\treturn \"'\";\n \t\t\tcase '\"':\n-\t\t\t\tres.append(\"\\\\\\\"\");\n-\t\t\t\tbreak;\n+\t\t\t\treturn \"\\\\\\\"\";\n \t\t\tcase '\\\\':\n-\t\t\t\tres.append(\"\\\\\\\\\");\n-\t\t\t\tbreak;\n+\t\t\t\treturn \"\\\\\\\\\";\n \n \t\t\tdefault:\n-\t\t\t\tif (c < 32 || c >= 127 && escapeUnicode) {\n-\t\t\t\t\tres.append(\"\\\\u\").append(String.format(\"%04x\", c));\n-\t\t\t\t} else {\n-\t\t\t\t\tres.append((char) c);\n-\t\t\t\t}\n-\t\t\t\tbreak;\n+\t\t\t\treturn null;\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/functional/StringUtilsTest.java b/jadx-core/src/test/java/jadx/tests/functional/StringUtilsTest.java\n--- a/jadx-core/src/test/java/jadx/tests/functional/StringUtilsTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/functional/StringUtilsTest.java\n@@ -43,8 +43,9 @@ public void testCharUnescape() {\n \t\tcheckCharUnescape('a', \"a\");\n \t\tcheckCharUnescape(' ', \" \");\n \t\tcheckCharUnescape('\\n', \"\\\\n\");\n-\t\tcheckCharUnescape('\\'', \"\\\\\\'\");\n-\t\tcheckCharUnescape('\\0', \"\\\\u0000\");\n+\t\tcheckCharUnescape('\\'', \"\\\\'\");\n+\n+\t\tassertThat(stringUtils.unescapeChar('\\0'), is(\"0\"));\n \t}\n \n \tprivate void checkCharUnescape(char input, String result) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke4.java b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke4.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke4.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke4.java\n@@ -0,0 +1,24 @@\n+package jadx.tests.integration.invoke;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestCastInOverloadedInvoke4 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic String test(String str) {\n+\t\t\treturn str.replace('\\n', ' ');\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"return str.replace('\\\\n', ' ');\");\n+\t}\n+}",
    "output": "Fix resolve char literal incorrect print as string"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -511,7 +511,8 @@ public void useClass(CodeWriter code, ArgType type) {\n \t\tif (outerType != null) {\n \t\t\tuseClass(code, outerType);\n \t\t\tcode.add('.');\n-\t\t\tuseClass(code, type.getInnerType());\n+\t\t\t// import not needed, force use short name\n+\t\t\tuseClassShortName(code, type.getObject());\n \t\t\treturn;\n \t\t}\n \n@@ -540,6 +541,15 @@ public void useClass(CodeWriter code, ArgType type) {\n \t\t}\n \t}\n \n+\tprivate void useClassShortName(CodeWriter code, String object) {\n+\t\tClassInfo classInfo = ClassInfo.fromName(cls.root(), object);\n+\t\tClassNode classNode = cls.root().resolveClass(classInfo);\n+\t\tif (classNode != null) {\n+\t\t\tcode.attachAnnotation(classNode);\n+\t\t}\n+\t\tcode.add(classInfo.getAliasShortName());\n+\t}\n+\n \tpublic void useClass(CodeWriter code, ClassInfo classInfo) {\n \t\tClassNode classNode = cls.root().resolveClass(classInfo);\n \t\tif (classNode != null) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n@@ -116,7 +116,7 @@ public static ArgType generic(String obj, ArgType... generics) {\n \t}\n \n \tpublic static ArgType outerGeneric(ArgType genericOuterType, ArgType innerType) {\n-\t\treturn new OuterGenericObject((GenericObject) genericOuterType, (ObjectType) innerType);\n+\t\treturn new OuterGenericObject((ObjectType) genericOuterType, (ObjectType) innerType);\n \t}\n \n \tpublic static ArgType array(@NotNull ArgType vtype) {\n@@ -341,10 +341,10 @@ public String toString() {\n \t}\n \n \tprivate static class OuterGenericObject extends ObjectType {\n-\t\tprivate final GenericObject outerType;\n+\t\tprivate final ObjectType outerType;\n \t\tprivate final ObjectType innerType;\n \n-\t\tpublic OuterGenericObject(GenericObject outerType, ObjectType innerType) {\n+\t\tpublic OuterGenericObject(ObjectType outerType, ObjectType innerType) {\n \t\t\tsuper(outerType.getObject() + '$' + innerType.getObject());\n \t\t\tthis.outerType = outerType;\n \t\t\tthis.innerType = innerType;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n@@ -173,10 +173,14 @@ public ArgType consumeType() {\n \t\tthrow new JadxRuntimeException(\"Can't parse type: \" + debugString() + \", unexpected: \" + ch);\n \t}\n \n-\tprivate ArgType consumeObjectType(boolean incompleteType) {\n+\tprivate ArgType consumeObjectType(boolean innerType) {\n \t\tmark();\n \t\tint ch;\n \t\tdo {\n+\t\t\tif (innerType && lookAhead('.')) {\n+\t\t\t\t// stop before next nested inner class\n+\t\t\t\treturn ArgType.object(inclusiveSlice());\n+\t\t\t}\n \t\t\tch = next();\n \t\t\tif (ch == STOP_CHAR) {\n \t\t\t\treturn null;\n@@ -185,36 +189,44 @@ private ArgType consumeObjectType(boolean incompleteType) {\n \n \t\tif (ch == ';') {\n \t\t\tString obj;\n-\t\t\tif (incompleteType) {\n+\t\t\tif (innerType) {\n \t\t\t\tobj = slice().replace('/', '.');\n \t\t\t} else {\n \t\t\t\tobj = inclusiveSlice();\n \t\t\t}\n \t\t\treturn ArgType.object(obj);\n-\t\t} else {\n-\t\t\t// generic type start ('<')\n-\t\t\tString obj = slice();\n-\t\t\tif (!incompleteType) {\n-\t\t\t\tobj += ';';\n-\t\t\t}\n-\t\t\tArgType[] genArr = consumeGenericArgs();\n-\t\t\tconsume('>');\n+\t\t}\n+\t\t// generic type start ('<')\n+\t\tString obj = slice();\n+\t\tif (!innerType) {\n+\t\t\tobj += ';';\n+\t\t}\n+\t\tArgType[] genArr = consumeGenericArgs();\n+\t\tconsume('>');\n \n-\t\t\tArgType genericType = ArgType.generic(obj, genArr);\n-\t\t\tif (lookAhead('.')) {\n-\t\t\t\tconsume('.');\n-\t\t\t\tnext();\n-\t\t\t\t// type parsing not completed, proceed to inner class\n-\t\t\t\tArgType inner = consumeObjectType(true);\n-\t\t\t\tif (inner == null) {\n-\t\t\t\t\tthrow new JadxRuntimeException(\"No inner type found: \" + debugString());\n-\t\t\t\t}\n-\t\t\t\treturn ArgType.outerGeneric(genericType, inner);\n-\t\t\t} else {\n-\t\t\t\tconsume(';');\n-\t\t\t\treturn genericType;\n+\t\tArgType genericType = ArgType.generic(obj, genArr);\n+\t\tif (!lookAhead('.')) {\n+\t\t\tconsume(';');\n+\t\t\treturn genericType;\n+\t\t}\n+\t\tconsume('.');\n+\t\tnext();\n+\t\t// type parsing not completed, proceed to inner class\n+\t\tArgType inner = consumeObjectType(true);\n+\t\tif (inner == null) {\n+\t\t\tthrow new JadxRuntimeException(\"No inner type found: \" + debugString());\n+\t\t}\n+\t\t// for every nested inner type create nested type object\n+\t\twhile (lookAhead('.')) {\n+\t\t\tgenericType = ArgType.outerGeneric(genericType, inner);\n+\t\t\tconsume('.');\n+\t\t\tnext();\n+\t\t\tinner = consumeObjectType(true);\n+\t\t\tif (inner == null) {\n+\t\t\t\tthrow new JadxRuntimeException(\"Unexpected inner type found: \" + debugString());\n \t\t\t}\n \t\t}\n+\t\treturn ArgType.outerGeneric(genericType, inner);\n \t}\n \n \tprivate ArgType[] consumeGenericArgs() {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/functional/SignatureParserTest.java b/jadx-core/src/test/java/jadx/tests/functional/SignatureParserTest.java\n--- a/jadx-core/src/test/java/jadx/tests/functional/SignatureParserTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/functional/SignatureParserTest.java\n@@ -21,6 +21,7 @@\n import static java.util.Collections.emptyList;\n import static java.util.Collections.singletonList;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.hasSize;\n import static org.hamcrest.Matchers.is;\n \n@@ -58,6 +59,16 @@ public void testInnerGeneric() {\n \t\tassertThat(objectStr, is(\"a$LinkedHashIterator\"));\n \t}\n \n+\t@Test\n+\tpublic void testNestedInnerGeneric() {\n+\t\tString signature = \"La<TV;>.I.X;\";\n+\t\tArgType result = new SignatureParser(signature).consumeType();\n+\t\tassertThat(result.getObject(), is(\"a$I$X\"));\n+\t\t// nested 'outerGeneric' objects\n+\t\tArgType obj = generic(\"La;\", genericType(\"V\"));\n+\t\tassertThat(result, equalTo(outerGeneric(outerGeneric(obj, object(\"I\")), object(\"X\"))));\n+\t}\n+\n \t@Test\n \tpublic void testWildcards() {\n \t\tcheckWildcards(\"*\", wildcard());\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/deobf/TestFieldFromInnerClass.java b/jadx-core/src/test/java/jadx/tests/integration/deobf/TestFieldFromInnerClass.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/deobf/TestFieldFromInnerClass.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/deobf/TestFieldFromInnerClass.java\n@@ -0,0 +1,41 @@\n+package jadx.tests.integration.deobf;\n+\n+import java.util.List;\n+import java.util.Queue;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestFieldFromInnerClass extends IntegrationTest {\n+\n+\tpublic static class TestCls<T> {\n+\t\tTestCls<T>.I f;\n+\n+\t\tpublic class I {\n+\t\t\tQueue<T> a;\n+\n+\t\t\tQueue<TestCls<T>.I> b;\n+\n+\t\t\tpublic class X {\n+\t\t\t\tList<TestCls<T>.I.X> c;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tenableDeobfuscation();\n+\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tassertThat(cls)\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"class I {\")\n+\t\t\t\t.doesNotContain(\".I \")\n+\t\t\t\t.doesNotContain(\".I.X>\");\n+\t}\n+}",
    "output": "Use recursive objects for nested inner generic classes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -49,6 +49,7 @@ public class MethodNode extends NotificationAttrNode implements IMethodDetails,\n \n \tprivate final ICodeReader codeReader;\n \tprivate final boolean methodIsVirtual;\n+\tprivate final int insnsCount;\n \n \tprivate boolean noCode;\n \tprivate int regsCount;\n@@ -85,9 +86,16 @@ public MethodNode(ClassNode classNode, IMethodData mthData) {\n \t\tthis.mthInfo = MethodInfo.fromData(classNode.root(), mthData);\n \t\tthis.parentClass = classNode;\n \t\tthis.accFlags = new AccessInfo(mthData.getAccessFlags(), AFType.METHOD);\n-\t\tthis.noCode = mthData.getCodeReader() == null;\n-\t\tthis.codeReader = noCode ? null : mthData.getCodeReader().copy();\n \t\tthis.methodIsVirtual = !mthData.isDirect();\n+\t\tICodeReader codeReader = mthData.getCodeReader();\n+\t\tthis.noCode = codeReader == null;\n+\t\tif (noCode) {\n+\t\t\tthis.codeReader = null;\n+\t\t\tthis.insnsCount = 0;\n+\t\t} else {\n+\t\t\tthis.codeReader = codeReader.copy();\n+\t\t\tthis.insnsCount = codeReader.getInsnsCount();\n+\t\t}\n \t\tunload();\n \t}\n \n@@ -596,8 +604,7 @@ public IDebugInfo getDebugInfo() {\n \t}\n \n \t/**\n-\t * Stat method.\n-\t * Calculate instructions count as a measure of method size\n+\t * Calculate instructions count at currect stage\n \t */\n \tpublic long countInsns() {\n \t\tif (instructions != null) {\n@@ -609,6 +616,13 @@ public long countInsns() {\n \t\treturn -1;\n \t}\n \n+\t/**\n+\t * Raw instructions count in method bytecode\n+\t */\n+\tpublic int getInsnsCount() {\n+\t\treturn insnsCount;\n+\t}\n+\n \t@Override\n \tpublic boolean isVarArg() {\n \t\treturn accFlags.isVarArgs();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -49,6 +49,7 @@\n import jadx.core.utils.InsnList;\n import jadx.core.utils.InsnUtils;\n import jadx.core.utils.Utils;\n+import jadx.core.utils.exceptions.JadxOverflowException;\n \n @JadxVisitor(\n \t\tname = \"Type Inference\",\n@@ -88,10 +89,14 @@ public void visit(MethodNode mth) {\n \t\tif (Consts.DEBUG_TYPE_INFERENCE) {\n \t\t\tLOG.info(\"Start type inference in method: {}\", mth);\n \t\t}\n-\t\tfor (Function<MethodNode, Boolean> resolver : resolvers) {\n-\t\t\tif (resolver.apply(mth) && checkTypes(mth)) {\n-\t\t\t\treturn;\n+\t\ttry {\n+\t\t\tfor (Function<MethodNode, Boolean> resolver : resolvers) {\n+\t\t\t\tif (resolver.apply(mth) && checkTypes(mth)) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n \t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tmth.addError(\"Type inference failed with exception\", e);\n \t\t}\n \t}\n \n@@ -148,6 +153,8 @@ private void setImmutableType(MethodNode mth, SSAVar ssaVar) {\n \t\t\tif (immutableType != null) {\n \t\t\t\tapplyImmutableType(mth, ssaVar, immutableType);\n \t\t\t}\n+\t\t} catch (JadxOverflowException e) {\n+\t\t\tthrow e;\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Failed to set immutable type for var: {}\", ssaVar, e);\n \t\t}\n@@ -156,6 +163,8 @@ private void setImmutableType(MethodNode mth, SSAVar ssaVar) {\n \tprivate boolean setBestType(MethodNode mth, SSAVar ssaVar) {\n \t\ttry {\n \t\t\treturn calculateFromBounds(mth, ssaVar);\n+\t\t} catch (JadxOverflowException e) {\n+\t\t\tthrow e;\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Failed to calculate best type for var: {}\", ssaVar, e);\n \t\t\treturn false;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n@@ -166,12 +166,7 @@ private TypeUpdateResult requestUpdate(TypeUpdateInfo updateInfo, InsnArg arg, A\n \t\t\treturn CHANGED;\n \t\t}\n \t\tupdateInfo.requestUpdate(arg, candidateType);\n-\t\tif (updateInfo.getUpdates().size() > 500) {\n-\t\t\tif (Consts.DEBUG_TYPE_INFERENCE) {\n-\t\t\t\tLOG.error(\"Type update error: too deep update tree\");\n-\t\t\t}\n-\t\t\treturn REJECT;\n-\t\t}\n+\t\tupdateInfo.checkUpdatesCount();\n \t\ttry {\n \t\t\tTypeUpdateResult result = runListeners(updateInfo, arg, candidateType);\n \t\t\tif (result == REJECT) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateInfo.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateInfo.java\n@@ -6,15 +6,18 @@\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.utils.exceptions.JadxOverflowException;\n \n public class TypeUpdateInfo {\n \tprivate final MethodNode mth;\n \tprivate final TypeUpdateFlags flags;\n \tprivate final List<TypeUpdateEntry> updates = new ArrayList<>();\n+\tprivate final int updatesLimitCount;\n \n \tpublic TypeUpdateInfo(MethodNode mth, TypeUpdateFlags flags) {\n \t\tthis.mth = mth;\n \t\tthis.flags = flags;\n+\t\tthis.updatesLimitCount = mth.getInsnsCount() * 5; // maximum registers count to update at once\n \t}\n \n \tpublic void requestUpdate(InsnArg arg, ArgType changeType) {\n@@ -53,6 +56,12 @@ public void rollbackUpdate(InsnArg arg) {\n \t\tupdates.removeIf(updateEntry -> updateEntry.getArg() == arg);\n \t}\n \n+\tpublic void checkUpdatesCount() {\n+\t\tif (updates.size() > updatesLimitCount) {\n+\t\t\tthrow new JadxOverflowException(\"Type inference error: update tree size limit reached\");\n+\t\t}\n+\t}\n+\n \tpublic MethodNode getMth() {\n \t\treturn mth;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java\n--- a/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java\n@@ -51,13 +51,12 @@ private synchronized <N extends IDexNode & IAttributeNode> String addError(N nod\n \n \t\tString msg = formatMsg(node, error);\n \t\tif (PRINT_MTH_SIZE && node instanceof MethodNode) {\n-\t\t\tlong insnsCount = ((MethodNode) node).countInsns();\n-\t\t\tmsg = \"[\" + insnsCount + \"] \" + msg;\n+\t\t\tmsg = \"[\" + ((MethodNode) node).getInsnsCount() + \"] \" + msg;\n \t\t}\n \t\tif (e == null) {\n \t\t\tLOG.error(msg);\n \t\t} else if (e instanceof StackOverflowError) {\n-\t\t\tLOG.error(msg);\n+\t\t\tLOG.error(\"{}, error: StackOverflowError\", msg);\n \t\t} else if (e instanceof JadxOverflowException) {\n \t\t\t// don't print full stack trace\n \t\t\tString details = e.getMessage();",
    "output": "Fix improve limit calculation for type updates in type inference"
  },
  {
    "input": "diff --git a/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java b/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n--- a/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n+++ b/jadx-plugins/jadx-java-convert/src/main/java/jadx/plugins/input/javaconvert/JavaConvertLoader.java\n@@ -2,6 +2,7 @@\n \n import java.io.IOException;\n import java.nio.file.Files;\n+import java.nio.file.LinkOption;\n import java.nio.file.Path;\n import java.util.List;\n import java.util.stream.Collectors;\n@@ -44,8 +45,10 @@ private static void convert(ConvertResult result, Path path) throws Exception {\n \t}\n \n \tprivate static List<Path> collectFilesInDir(Path tempDirectory) throws IOException {\n-\t\ttry (Stream<Path> pathStream = Files.walk(tempDirectory)) {\n-\t\t\treturn pathStream.collect(Collectors.toList());\n+\t\ttry (Stream<Path> pathStream = Files.walk(tempDirectory, 1)) {\n+\t\t\treturn pathStream\n+\t\t\t\t\t.filter(p -> Files.isRegularFile(p, LinkOption.NOFOLLOW_LINKS))\n+\t\t\t\t\t.collect(Collectors.toList());\n \t\t}\n \t}\n }",
    "output": "Fix exclude directories from dex convertion results"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java\n@@ -516,17 +516,15 @@ public void done() {\n \t\t}\n \t}\n \n-\tprotected void loadStartCommon() {\n+\tprivate void loadStartCommon() {\n \t\tsetCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n \t\tprogressPane.setIndeterminate(true);\n \t\tprogressPane.setVisible(true);\n-\t\tresultsTable.setEnabled(false);\n \t\twarnLabel.setVisible(false);\n \t}\n \n \tprivate void loadFinishedCommon() {\n \t\tsetCursor(null);\n-\t\tresultsTable.setEnabled(true);\n \t\tprogressPane.setVisible(false);\n \n \t\tTextSearchIndex textIndex = cache.getTextIndex();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n@@ -1,7 +1,6 @@\n package jadx.gui.ui;\n \n import java.awt.*;\n-import java.awt.event.KeyEvent;\n import java.io.File;\n import java.io.FileOutputStream;\n import java.io.IOException;\n@@ -42,7 +41,7 @@\n import jadx.gui.ui.codearea.CodePanel;\n import jadx.gui.utils.*;\n \n-public class RenameDialog extends JDialog {\n+public class RenameDialog extends CommonSearchDialog {\n \tprivate static final long serialVersionUID = -3269715644416902410L;\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(RenameDialog.class);\n@@ -55,13 +54,16 @@ public class RenameDialog extends JDialog {\n \n \tprivate CodeArea codeArea;\n \n+\tprivate JButton renameBtn;\n+\n \tpublic RenameDialog(CodeArea codeArea, JNode node) {\n \t\tsuper(codeArea.getMainWindow());\n \t\tmainWindow = codeArea.getMainWindow();\n \t\tthis.codeArea = codeArea;\n \t\tthis.node = node;\n \t\tif (isDeobfuscationSettingsValid()) {\n \t\t\tinitUI();\n+\t\t\tregisterInitOnOpen();\n \t\t\tloadWindowPos();\n \t\t} else {\n \t\t\tLOG.error(\"Deobfuscation settings are invalid - please enable deobfuscation and disable force rewrite deobfuscation map\");\n@@ -95,14 +97,19 @@ private void showRenameDisabledErrorMessage(LangLocale langLocale, String messag\n \t\t\t\tJOptionPane.ERROR_MESSAGE);\n \t}\n \n-\tprivate void loadWindowPos() {\n-\t\tmainWindow.getSettings().loadWindowPos(this);\n+\t@Override\n+\tprotected void openInit() {\n+\t\tprepare();\n+\t}\n+\n+\t@Override\n+\tprotected void loadStart() {\n+\t\trenameBtn.setEnabled(false);\n \t}\n \n \t@Override\n-\tpublic void dispose() {\n-\t\tmainWindow.getSettings().saveWindowPos(this);\n-\t\tsuper.dispose();\n+\tprotected void loadFinished() {\n+\t\trenameBtn.setEnabled(true);\n \t}\n \n \tprivate Path getDeobfMapPath(RootNode root) {\n@@ -239,7 +246,7 @@ private int refreshState(RootNode rootNode) {\n \t\tRenameVisitor renameVisitor = new RenameVisitor();\n \t\trenameVisitor.init(rootNode);\n \n-\t\tmainWindow.getCacheObject().getNodeCache().refresh(node);\n+\t\tcache.getNodeCache().refresh(node);\n \n \t\tSet<JavaClass> updatedClasses = getUpdatedClasses();\n \n@@ -277,7 +284,7 @@ private void refreshTabs(TabbedPane tabbedPane, Set<JavaClass> updatedClasses) {\n \n \tprivate Set<JavaClass> getUpdatedClasses() {\n \t\tSet<JavaClass> usageClasses = new HashSet<>();\n-\t\tCodeUsageInfo usageInfo = mainWindow.getCacheObject().getUsageInfo();\n+\t\tCodeUsageInfo usageInfo = cache.getUsageInfo();\n \t\tif (usageInfo != null) {\n \t\t\tusageInfo.getUsageList(node).forEach((node) -> {\n \t\t\t\tJavaClass rootClass = node.getRootClass().getCls();\n@@ -290,7 +297,6 @@ private Set<JavaClass> getUpdatedClasses() {\n \t}\n \n \tprivate void setRefreshTask(Set<JavaClass> refreshClasses) {\n-\t\tCacheObject cache = mainWindow.getCacheObject();\n \t\tUnloadJob unloadJob = new UnloadJob(mainWindow.getWrapper(), mainWindow.getSettings().getThreadsCount(), refreshClasses);\n \t\tRefreshJob refreshJob = new RefreshJob(mainWindow.getWrapper(), mainWindow.getSettings().getThreadsCount(), refreshClasses);\n \t\tLOG.info(\"Waiting for old unloadJob and refreshJob\");\n@@ -304,26 +310,24 @@ private void setRefreshTask(Set<JavaClass> refreshClasses) {\n \t\tLOG.info(\"Old unloadJob and refreshJob finished\");\n \t\tcache.setUnloadJob(unloadJob);\n \t\tcache.setRefreshJob(refreshJob);\n-\t\tcache.setIndexJob(new IndexJob(mainWindow.getWrapper(), mainWindow.getCacheObject(), mainWindow.getSettings().getThreadsCount()));\n+\t\tcache.setIndexJob(new IndexJob(mainWindow.getWrapper(), cache, mainWindow.getSettings().getThreadsCount()));\n \t\tmainWindow.runBackgroundUnloadRefreshAndIndexJobs();\n \t}\n \n-\tprivate void initCommon() {\n-\t\tKeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n-\t\tgetRootPane().registerKeyboardAction(e -> dispose(), stroke, JComponent.WHEN_IN_FOCUSED_WINDOW);\n-\t}\n-\n \t@NotNull\n-\tprivate JPanel initButtonsPanel() {\n+\tprotected JPanel initButtonsPanel() {\n \t\tJButton cancelButton = new JButton(NLS.str(\"search_dialog.cancel\"));\n \t\tcancelButton.addActionListener(event -> dispose());\n-\t\tJButton renameBtn = new JButton(NLS.str(\"popup.rename\"));\n+\t\trenameBtn = new JButton(NLS.str(\"popup.rename\"));\n \t\trenameBtn.addActionListener(event -> rename());\n \t\tgetRootPane().setDefaultButton(renameBtn);\n \n+\t\tprogressPane = new ProgressPanel(mainWindow, false);\n+\n \t\tJPanel buttonPane = new JPanel();\n \t\tbuttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.LINE_AXIS));\n \t\tbuttonPane.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));\n+\t\tbuttonPane.add(progressPane);\n \t\tbuttonPane.add(Box.createRigidArea(new Dimension(5, 0)));\n \t\tbuttonPane.add(Box.createHorizontalGlue());\n \t\tbuttonPane.add(renameBtn);\n@@ -349,8 +353,14 @@ private void initUI() {\n \t\trenamePane.add(nodeLabel);\n \t\trenamePane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n \n+\t\twarnLabel = new JLabel();\n+\t\twarnLabel.setForeground(Color.RED);\n+\t\twarnLabel.setVisible(false);\n+\n \t\tJPanel textPane = new JPanel();\n-\t\ttextPane.setLayout(new FlowLayout(FlowLayout.LEFT));\n+\t\ttextPane.setLayout(new BoxLayout(textPane, BoxLayout.PAGE_AXIS));\n+\t\ttextPane.add(warnLabel);\n+\t\ttextPane.add(Box.createRigidArea(new Dimension(0, 5)));\n \t\ttextPane.add(renameField);\n \t\ttextPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n@@ -282,11 +282,13 @@ private JCheckBox makeOptionsCheckBox(String name, final SearchOptions opt) {\n \n \t@Override\n \tprotected void loadFinished() {\n+\t\tresultsTable.setEnabled(true);\n \t\tsearchField.setEnabled(true);\n \t}\n \n \t@Override\n \tprotected void loadStart() {\n+\t\tresultsTable.setEnabled(false);\n \t\tsearchField.setEnabled(false);\n \t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/UsageDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/UsageDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/UsageDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/UsageDialog.java\n@@ -30,12 +30,13 @@ protected void openInit() {\n \n \t@Override\n \tprotected void loadFinished() {\n+\t\tresultsTable.setEnabled(true);\n \t\tperformSearch();\n \t}\n \n \t@Override\n \tprotected void loadStart() {\n-\t\t// no op\n+\t\tresultsTable.setEnabled(false);\n \t}\n \n \t@Override",
    "output": "Fix run indexJob before rename"
  },
  {
    "input": "diff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexFileLoader.java\n@@ -1,8 +1,7 @@\n package jadx.plugins.input.dex;\n \n import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n+import java.io.InputStream;\n import java.nio.file.FileSystem;\n import java.nio.file.FileSystems;\n import java.nio.file.FileVisitResult;\n@@ -12,7 +11,6 @@\n import java.nio.file.StandardOpenOption;\n import java.nio.file.attribute.BasicFileAttributes;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n@@ -35,11 +33,15 @@ public static List<DexReader> collectDexFiles(List<Path> pathsList) {\n \t}\n \n \tprivate static List<DexReader> loadDexFromPath(Path path, int depth) {\n-\t\ttry (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ)) {\n-\t\t\tif (isDex(fileChannel)) {\n-\t\t\t\treturn Collections.singletonList(new DexReader(path, fileChannel));\n+\t\ttry (InputStream inputStream = Files.newInputStream(path, StandardOpenOption.READ)) {\n+\t\t\tbyte[] magic = new byte[DexConsts.MAX_MAGIC_SIZE];\n+\t\t\tif (inputStream.read(magic) != magic.length) {\n+\t\t\t\treturn Collections.emptyList();\n \t\t\t}\n-\t\t\tif (depth == 0 && isZip(fileChannel)) {\n+\t\t\tif (isStartWithBytes(magic, DexConsts.DEX_FILE_MAGIC)) {\n+\t\t\t\treturn Collections.singletonList(new DexReader(path));\n+\t\t\t}\n+\t\t\tif (depth == 0 && isStartWithBytes(magic, DexConsts.ZIP_FILE_MAGIC)) {\n \t\t\t\treturn collectDexFromZip(path, depth);\n \t\t\t}\n \t\t} catch (Exception e) {\n@@ -64,22 +66,16 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n \t\treturn result;\n \t}\n \n-\tprivate static boolean isDex(FileChannel fileChannel) {\n-\t\treturn isStartWithBytes(fileChannel, DexConsts.DEX_FILE_MAGIC);\n-\t}\n-\n-\tprivate static boolean isZip(FileChannel fileChannel) {\n-\t\treturn isStartWithBytes(fileChannel, DexConsts.ZIP_FILE_MAGIC);\n-\t}\n-\n-\tprivate static boolean isStartWithBytes(FileChannel fileChannel, byte[] startBytes) {\n-\t\ttry {\n-\t\t\tfileChannel.position(0);\n-\t\t\tByteBuffer buf = ByteBuffer.allocate(startBytes.length);\n-\t\t\tfileChannel.read(buf);\n-\t\t\treturn Arrays.equals(startBytes, buf.array());\n-\t\t} catch (Exception e) {\n+\tprivate static boolean isStartWithBytes(byte[] fileMagic, byte[] expectedBytes) {\n+\t\tint len = expectedBytes.length;\n+\t\tif (fileMagic.length < len) {\n \t\t\treturn false;\n \t\t}\n+\t\tfor (int i = 0; i < len; i++) {\n+\t\t\tif (fileMagic[i] != expectedBytes[i]) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n \t}\n }\n\ndiff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexReader.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexReader.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexReader.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/DexReader.java\n@@ -3,8 +3,8 @@\n import java.io.Closeable;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n import java.nio.file.FileSystem;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.function.Consumer;\n \n@@ -17,32 +17,15 @@\n public class DexReader implements Closeable {\n \n \tprivate final Path path;\n-\tprivate final FileChannel fileChannel;\n \tprivate final ByteBuffer buf;\n \tprivate final DexHeader header;\n \n-\tpublic DexReader(Path path, FileChannel fileChannel) throws IOException {\n+\tpublic DexReader(Path path) throws IOException {\n \t\tthis.path = path;\n-\t\tthis.fileChannel = fileChannel;\n-\t\tthis.buf = loadIntoByteBuffer(fileChannel);\n+\t\tthis.buf = ByteBuffer.wrap(Files.readAllBytes(path));\n \t\tthis.header = new DexHeader(new SectionReader(this, 0));\n \t}\n \n-\tprivate static ByteBuffer loadIntoByteBuffer(FileChannel fileChannel) throws IOException {\n-\t\tlong size = fileChannel.size();\n-\t\tif (size > Integer.MAX_VALUE) {\n-\t\t\tthrow new IOException(\"File too big\");\n-\t\t}\n-\t\tint readSize = (int) size;\n-\t\tByteBuffer buf = ByteBuffer.allocate(readSize);\n-\t\tfileChannel.position(0);\n-\t\tint read = fileChannel.read(buf);\n-\t\tif (read != readSize) {\n-\t\t\tthrow new IOException(\"Failed to read whole file into buffer. Read: \" + read + \", expected: \" + readSize);\n-\t\t}\n-\t\treturn buf;\n-\t}\n-\n \tpublic String getDexVersion() {\n \t\treturn this.header.getVersion();\n \t}\n@@ -86,7 +69,6 @@ public String getFullPath() {\n \n \t@Override\n \tpublic void close() throws IOException {\n-\t\tthis.fileChannel.close();\n \t}\n \n \t@Override\n\ndiff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/DexConsts.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/DexConsts.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/DexConsts.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/sections/DexConsts.java\n@@ -6,6 +6,8 @@ public class DexConsts {\n \n \tpublic static final byte[] ZIP_FILE_MAGIC = { 0x50, 0x4B, 0x03, 0x04 };\n \n+\tpublic static final int MAX_MAGIC_SIZE = 4;\n+\n \tpublic static final int ENDIAN_CONSTANT = 0x12345678;\n \n \tpublic static final int NO_INDEX = -1;",
    "output": "Fix don't use FileChannel on ZipFs to avoid creation of temp files"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Jadx.java b/jadx-core/src/main/java/jadx/core/Jadx.java\n--- a/jadx-core/src/main/java/jadx/core/Jadx.java\n+++ b/jadx-core/src/main/java/jadx/core/Jadx.java\n@@ -113,9 +113,6 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {\n \t\tpasses.add(new MarkFinallyVisitor());\n \t\tpasses.add(new ConstInlineVisitor());\n \t\tpasses.add(new TypeInferenceVisitor());\n-\t\tif (args.isRawCFGOutput()) {\n-\t\t\tpasses.add(DotGraphVisitor.dumpRaw());\n-\t\t}\n \t\tif (args.isDebugInfo()) {\n \t\t\tpasses.add(new DebugInfoApplyVisitor());\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java\n@@ -1,7 +1,6 @@\n package jadx.core.dex.visitors;\n \n import java.util.ArrayList;\n-import java.util.List;\n \n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;\n@@ -35,20 +34,17 @@ private static void moveInline(MethodNode mth) {\n \t\tInsnRemover remover = new InsnRemover(mth);\n \t\tfor (BlockNode block : mth.getBasicBlocks()) {\n \t\t\tremover.setBlock(block);\n-\t\t\tList<InsnNode> insns = block.getInstructions();\n-\t\t\tint size = insns.size();\n-\t\t\tfor (int i = 0; i < size; i++) {\n-\t\t\t\tInsnNode insn = insns.get(i);\n+\t\t\tfor (InsnNode insn : block.getInstructions()) {\n \t\t\t\tif (insn.getType() == InsnType.MOVE\n-\t\t\t\t\t\t&& processMove(mth, block, insn, i)) {\n+\t\t\t\t\t\t&& processMove(mth, insn)) {\n \t\t\t\t\tremover.addAndUnbind(insn);\n \t\t\t\t}\n \t\t\t}\n \t\t\tremover.perform();\n \t\t}\n \t}\n \n-\tprivate static boolean processMove(MethodNode mth, BlockNode block, InsnNode move, int i) {\n+\tprivate static boolean processMove(MethodNode mth, InsnNode move) {\n \t\tRegisterArg resultArg = move.getResult();\n \t\tInsnArg moveArg = move.getArg(0);\n \t\tif (resultArg.sameRegAndSVar(moveArg)) {\n@@ -58,21 +54,26 @@ private static boolean processMove(MethodNode mth, BlockNode block, InsnNode mov\n \t\tif (ssaVar.isUsedInPhi()) {\n \t\t\treturn false;\n \t\t}\n-\t\tRegDebugInfoAttr debugInfo = resultArg.get(AType.REG_DEBUG_INFO);\n+\t\tRegDebugInfoAttr debugInfo = moveArg.get(AType.REG_DEBUG_INFO);\n \t\tfor (RegisterArg useArg : ssaVar.getUseList()) {\n \t\t\tInsnNode useInsn = useArg.getParentInsn();\n-\t\t\tif (useInsn == null || !fromThisBlock(block, useInsn, i)) {\n+\t\t\tif (useInsn == null) {\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tRegDebugInfoAttr debugInfoAttr = useArg.get(AType.REG_DEBUG_INFO);\n-\t\t\tif (debugInfoAttr != null) {\n-\t\t\t\tdebugInfo = debugInfoAttr;\n+\t\t\tif (debugInfo == null) {\n+\t\t\t\tRegDebugInfoAttr debugInfoAttr = useArg.get(AType.REG_DEBUG_INFO);\n+\t\t\t\tif (debugInfoAttr != null) {\n+\t\t\t\t\tdebugInfo = debugInfoAttr;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// all checks passed, execute inline\n \t\tfor (RegisterArg useArg : new ArrayList<>(ssaVar.getUseList())) {\n \t\t\tInsnNode useInsn = useArg.getParentInsn();\n+\t\t\tif (useInsn == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\tInsnArg replaceArg;\n \t\t\tif (moveArg.isRegister()) {\n \t\t\t\treplaceArg = ((RegisterArg) moveArg).duplicate(useArg.getInitType());\n@@ -83,21 +84,10 @@ private static boolean processMove(MethodNode mth, BlockNode block, InsnNode mov\n \t\t\tif (debugInfo != null) {\n \t\t\t\treplaceArg.addAttr(debugInfo);\n \t\t\t}\n-\t\t\tif (useInsn == null || !useInsn.replaceArg(useArg, replaceArg)) {\n+\t\t\tif (!useInsn.replaceArg(useArg, replaceArg)) {\n \t\t\t\tmth.addWarnComment(\"Failed to replace arg in insn: \" + useInsn);\n \t\t\t}\n \t\t}\n \t\treturn true;\n \t}\n-\n-\tprivate static boolean fromThisBlock(BlockNode block, InsnNode insn, int curPos) {\n-\t\tList<InsnNode> list = block.getInstructions();\n-\t\tint size = list.size();\n-\t\tfor (int j = curPos; j < size; j++) {\n-\t\t\tif (list.get(j) == insn) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/TestReturnWrapping.java b/jadx-core/src/test/java/jadx/tests/integration/TestReturnWrapping.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/TestReturnWrapping.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/TestReturnWrapping.java\n@@ -24,15 +24,14 @@ public static Object f2(Object arg0, int arg1) {\n \t\t\tint i = arg1;\n \t\t\tif (arg0 == null) {\n \t\t\t\treturn ret + Integer.toHexString(i);\n-\t\t\t} else {\n-\t\t\t\ti++;\n-\t\t\t\ttry {\n-\t\t\t\t\tret = new Object().getClass();\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tret = \"Qwerty\";\n-\t\t\t\t}\n-\t\t\t\treturn i > 128 ? arg0.toString() + ret.toString() : i;\n \t\t\t}\n+\t\t\ti++;\n+\t\t\ttry {\n+\t\t\t\tret = new Object().getClass();\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tret = \"Qwerty\";\n+\t\t\t}\n+\t\t\treturn i > 128 ? arg0.toString() + ret.toString() : i;\n \t\t}\n \n \t\tpublic static int f3(int arg0) {\n@@ -54,12 +53,7 @@ public void test() {\n \n \t\tassertThat(code, containsString(\"return 255;\"));\n \t\tassertThat(code, containsString(\"return arg0 + 1;\"));\n-\n-\t\t// TODO: reduce code vars by name\n-\t\t// assertThat(code, containsString(\"return i > 128 ? arg0.toString() + ret.toString() :\n-\t\t// Integer.valueOf(i);\"));\n-\t\tassertThat(code, containsString(\"return i2 > 128 ? arg0.toString() + ret.toString() : Integer.valueOf(i2);\"));\n-\n+\t\tassertThat(code, containsString(\"return i > 128 ? arg0.toString() + ret.toString() : Integer.valueOf(i);\"));\n \t\tassertThat(code, containsString(\"return arg0 + 2;\"));\n \t\tassertThat(code, containsString(\"arg0 -= 951;\"));\n \t}",
    "output": "Fix allow cross-block move inline"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n@@ -287,9 +287,9 @@ private void addCaseKey(CodeWriter code, InsnArg arg, Object k) {\n \t\t\t\tstaticField(code, fn.getFieldInfo());\n \t\t\t\t// print original value, sometimes replaced with incorrect field\n \t\t\t\tFieldInitAttr valueAttr = fn.get(AType.FIELD_INIT);\n-\t\t\t\tif (valueAttr != null) {\n+\t\t\t\tif (valueAttr != null && valueAttr.getValueType() == FieldInitAttr.InitType.CONST) {\n \t\t\t\t\tObject value = valueAttr.getEncodedValue();\n-\t\t\t\t\tif (value != null && valueAttr.getValueType() == FieldInitAttr.InitType.CONST) {\n+\t\t\t\t\tif (value != null) {\n \t\t\t\t\t\tcode.add(\" /*\").add(value.toString()).add(\"*/\");\n \t\t\t\t\t}\n \t\t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java b/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java\n@@ -72,9 +72,9 @@ public void processConstFields(ClassNode cls, List<FieldNode> staticFields) {\n \t\t\tif (accFlags.isStatic() && accFlags.isFinal()) {\n \t\t\t\tFieldInitAttr fv = f.get(AType.FIELD_INIT);\n \t\t\t\tif (fv != null\n-\t\t\t\t\t\t&& fv.getEncodedValue() != null\n \t\t\t\t\t\t&& fv.getValueType() == FieldInitAttr.InitType.CONST\n-\t\t\t\t\t\t&& fv != FieldInitAttr.NULL_VALUE) {\n+\t\t\t\t\t\t&& fv != FieldInitAttr.NULL_VALUE\n+\t\t\t\t\t\t&& fv.getEncodedValue() != null) {\n \t\t\t\t\taddConstField(cls, f, fv.getEncodedValue().getValue(), accFlags.isPublic());\n \t\t\t\t}\n \t\t\t}",
    "output": "Fix resolve ClassCastException on encoded value access"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/IndexInsnNode.java b/jadx-core/src/main/java/jadx/core/dex/instructions/IndexInsnNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/IndexInsnNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IndexInsnNode.java\n@@ -41,10 +41,15 @@ public String toString() {\n \t\tswitch (insnType) {\n \t\t\tcase CAST:\n \t\t\tcase CHECK_CAST:\n-\t\t\t\treturn InsnUtils.formatOffset(offset) + \": \"\n-\t\t\t\t\t\t+ InsnUtils.insnTypeToString(insnType)\n-\t\t\t\t\t\t+ getResult() + \" = (\" + InsnUtils.indexToString(index) + \") \"\n-\t\t\t\t\t\t+ Utils.listToString(getArguments());\n+\t\t\t\tStringBuilder sb = new StringBuilder();\n+\t\t\t\tsb.append(InsnUtils.formatOffset(offset)).append(\": \");\n+\t\t\t\tsb.append(insnType).append(' ');\n+\t\t\t\tif (getResult() != null) {\n+\t\t\t\t\tsb.append(getResult()).append(\" = \");\n+\t\t\t\t}\n+\t\t\t\tsb.append('(').append(InsnUtils.indexToString(index)).append(\") \");\n+\t\t\t\tsb.append(Utils.listToString(getArguments()));\n+\t\t\t\treturn sb.toString();\n \n \t\t\tdefault:\n \t\t\t\treturn super.toString() + ' ' + InsnUtils.indexToString(index);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -30,6 +30,7 @@\n import jadx.core.dex.nodes.utils.TypeUtils;\n import jadx.core.dex.visitors.DepthTraversal;\n import jadx.core.dex.visitors.IDexTreeVisitor;\n+import jadx.core.dex.visitors.typeinference.TypeCompare;\n import jadx.core.dex.visitors.typeinference.TypeUpdate;\n import jadx.core.utils.CacheStorage;\n import jadx.core.utils.ErrorsCounter;\n@@ -424,6 +425,10 @@ public TypeUpdate getTypeUpdate() {\n \t\treturn typeUpdate;\n \t}\n \n+\tpublic TypeCompare getTypeCompare() {\n+\t\treturn typeUpdate.getTypeCompare();\n+\t}\n+\n \tpublic ICodeCache getCodeCache() {\n \t\treturn codeCache;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n@@ -33,6 +33,7 @@\n import jadx.core.dex.instructions.SwitchInsn;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n+import jadx.core.dex.instructions.args.InsnWrapArg;\n import jadx.core.dex.instructions.args.LiteralArg;\n import jadx.core.dex.instructions.args.NamedArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n@@ -49,6 +50,7 @@\n import jadx.core.dex.trycatch.ExceptionHandler;\n import jadx.core.dex.visitors.regions.variables.ProcessVariables;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n+import jadx.core.dex.visitors.typeinference.TypeCompareEnum;\n import jadx.core.utils.InsnRemover;\n import jadx.core.utils.InsnUtils;\n import jadx.core.utils.exceptions.JadxException;\n@@ -144,6 +146,11 @@ private static void replaceStep(MethodNode mth, InsnRemover remover) {\n \t\t\t\t\t\tfixPrimitiveCast(mth, block, i, insn);\n \t\t\t\t\t\tbreak;\n \n+\t\t\t\t\tcase IPUT:\n+\t\t\t\t\tcase IGET:\n+\t\t\t\t\t\tfixTypeForFieldAccess(mth, (IndexInsnNode) insn);\n+\t\t\t\t\t\tbreak;\n+\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tbreak;\n \t\t\t\t}\n@@ -152,6 +159,31 @@ private static void replaceStep(MethodNode mth, InsnRemover remover) {\n \t\t}\n \t}\n \n+\tprivate static void fixTypeForFieldAccess(MethodNode mth, IndexInsnNode insn) {\n+\t\tInsnArg instanceArg = insn.getArg(insn.getType() == InsnType.IGET ? 0 : 1);\n+\t\tif (instanceArg.contains(AFlag.SUPER)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tif (instanceArg.isInsnWrap() && ((InsnWrapArg) instanceArg).getWrapInsn().getType() == InsnType.CAST) {\n+\t\t\treturn;\n+\t\t}\n+\t\tFieldInfo fieldInfo = (FieldInfo) insn.getIndex();\n+\t\tArgType clsType = fieldInfo.getDeclClass().getType();\n+\t\tArgType instanceType = instanceArg.getType();\n+\t\tTypeCompareEnum result = mth.root().getTypeCompare().compareTypes(instanceType, clsType);\n+\t\tif (result.isEqual() || (result == TypeCompareEnum.NARROW_BY_GENERIC && !instanceType.isGenericType())) {\n+\t\t\treturn;\n+\t\t}\n+\t\tIndexInsnNode castInsn = new IndexInsnNode(InsnType.CAST, clsType, 1);\n+\t\tcastInsn.addArg(instanceArg.duplicate());\n+\t\tcastInsn.add(AFlag.EXPLICIT_CAST);\n+\n+\t\tInsnArg castArg = InsnArg.wrapInsnIntoArg(castInsn);\n+\t\tcastArg.setType(clsType);\n+\t\tinsn.replaceArg(instanceArg, castArg);\n+\t\tInsnRemover.unbindArgUsage(mth, instanceArg);\n+\t}\n+\n \tprivate static void replaceConstKeys(ClassNode parentClass, SwitchInsn insn) {\n \t\tint[] keys = insn.getKeys();\n \t\tint len = keys.length;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestFieldAccess.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestFieldAccess.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestFieldAccess.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestFieldAccess.java\n@@ -0,0 +1,31 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestFieldAccess extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tprivate String field;\n+\n+\t\tstatic <T extends TestCls> T testPut(T t) {\n+\t\t\t((TestCls) t).field = \"\";\n+\t\t\treturn t;\n+\t\t}\n+\n+\t\tstatic <T extends TestCls> T testGet(T t) {\n+\t\t\tSystem.out.println(((TestCls) t).field);\n+\t\t\treturn t;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"t.field\");\n+\t}\n+}",
    "output": "Add cast to exact type on field access"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfo.java b/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/usage/UsageInfo.java\n@@ -64,11 +64,16 @@ public void clsUse(ClassNode cls, ClassNode depCls) {\n \tpublic void methodUse(MethodNode mth, MethodNode useMth) {\n \t\tclsUse(mth, useMth.getParentClass());\n \t\tmthUsage.add(useMth, mth);\n+\t\t// implicit usage\n+\t\tclsUse(mth, useMth.getReturnType());\n+\t\tuseMth.getMethodInfo().getArgumentsTypes().forEach(argType -> clsUse(mth, argType));\n \t}\n \n \tpublic void fieldUse(MethodNode mth, FieldNode useFld) {\n \t\tclsUse(mth, useFld.getParentClass());\n \t\tfieldUsage.add(useFld, mth);\n+\t\t// implicit usage\n+\t\tclsUse(mth, useFld.getType());\n \t}\n \n \tprivate void processType(ArgType type, Consumer<ClassNode> consumer) {",
    "output": "Add methods and fields types into usage info"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n@@ -13,6 +13,7 @@\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.visitors.typeinference.TypeCompareEnum;\n import jadx.core.utils.Utils;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public abstract class ArgType {\n \tpublic static final ArgType INT = primitive(PrimitiveType.INT);\n@@ -645,6 +646,9 @@ public static ArgType convertFromPrimitiveType(PrimitiveType primitiveType) {\n \t}\n \n \tpublic static ArgType parse(String type) {\n+\t\tif (type == null || type.isEmpty()) {\n+\t\t\tthrow new JadxRuntimeException(\"Failed to parse type string: \" + type);\n+\t\t}\n \t\tchar f = type.charAt(0);\n \t\tswitch (f) {\n \t\t\tcase 'L':\n\ndiff --git a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java\n--- a/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java\n+++ b/jadx-plugins/jadx-dex-input/src/main/java/jadx/plugins/input/dex/insns/DexInsnFormat.java\n@@ -293,7 +293,7 @@ public void decode(DexInsnData insn, int opcodeUnit, SectionReader in) {\n \t\t@Override\n \t\tpublic void skip(DexInsnData insn, SectionReader in) {\n \t\t\tint size = in.readUShort();\n-\t\t\tin.skip(4 + size * 4 * 2);\n+\t\t\tin.skip(size * 8);\n \t\t\tinsn.setLength(size * 4 + 2);\n \t\t}\n \t};",
    "output": "Fix correct skip size for sparse switch payload"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/GenericInfoAttr.java b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/GenericInfoAttr.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/GenericInfoAttr.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/GenericInfoAttr.java\n@@ -1,5 +1,7 @@\n package jadx.core.dex.attributes.nodes;\n \n+import java.util.Arrays;\n+\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.IAttribute;\n import jadx.core.dex.instructions.args.ArgType;\n@@ -28,4 +30,9 @@ public void setExplicit(boolean explicit) {\n \tpublic AType<GenericInfoAttr> getType() {\n \t\treturn AType.GENERIC_INFO;\n \t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"GenericInfoAttr{\" + Arrays.toString(genericTypes) + \", explicit=\" + explicit + '}';\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -274,6 +274,12 @@ public List<ArgType> getArgTypes() {\n \t\treturn argTypes;\n \t}\n \n+\tpublic void updateArgTypes(List<ArgType> newArgTypes, String comment) {\n+\t\tthis.addDebugComment(comment + \", original types: \" + getArgTypes());\n+\t\tthis.argTypes = Collections.unmodifiableList(newArgTypes);\n+\t\tinitArguments(newArgTypes);\n+\t}\n+\n \tpublic boolean containsGenericArgs() {\n \t\treturn !Objects.equals(mthInfo.getArgumentsTypes(), getArgTypes());\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java\n@@ -156,16 +156,20 @@ private ArgType getCallClassFromInvoke(MethodNode parentMth, BaseInvokeNode invo\n \t}\n \n \tprivate Map<ArgType, ArgType> getTypeVarsMapping(BaseInvokeNode invokeInsn) {\n-\t\tMethodInfo callMth = invokeInsn.getCallMth();\n-\t\tArgType declClsType = callMth.getDeclClass().getType();\n-\t\tArgType callClsType;\n+\t\tArgType declClsType = invokeInsn.getCallMth().getDeclClass().getType();\n+\t\tArgType callClsType = getClsCallType(invokeInsn, declClsType);\n+\t\treturn root.getTypeUtils().getTypeVariablesMapping(callClsType);\n+\t}\n+\n+\tprivate ArgType getClsCallType(BaseInvokeNode invokeInsn, ArgType declClsType) {\n \t\tInsnArg instanceArg = invokeInsn.getInstanceArg();\n \t\tif (instanceArg != null) {\n-\t\t\tcallClsType = instanceArg.getType();\n-\t\t} else {\n-\t\t\tcallClsType = declClsType;\n+\t\t\treturn instanceArg.getType();\n \t\t}\n-\t\treturn root.getTypeUtils().getTypeVariablesMapping(callClsType);\n+\t\tif (invokeInsn.getType() == InsnType.CONSTRUCTOR && invokeInsn.getResult() != null) {\n+\t\t\treturn invokeInsn.getResult().getType();\n+\t\t}\n+\t\treturn declClsType;\n \t}\n \n \tprivate void applyArgsCast(BaseInvokeNode invokeInsn, int argsOffset, List<ArgType> compilerVarTypes, List<ArgType> castTypes) {\n@@ -213,7 +217,7 @@ private IMethodDetails resolveTypeVars(IMethodDetails mthDetails, Map<ArgType, A\n \t\t\t}\n \t\t\tif (argType.containsTypeVariable()) {\n \t\t\t\tArgType resolvedType = root.getTypeUtils().replaceTypeVariablesUsingMap(argType, typeVarsMapping);\n-\t\t\t\tif (resolvedType == null || resolvedType.containsTypeVariable()) {\n+\t\t\t\tif (resolvedType == null || resolvedType.equals(argType)) {\n \t\t\t\t\t// type variables erased from method info by compiler\n \t\t\t\t\tresolvedType = mthDetails.getMethodInfo().getArgumentsTypes().get(argNum);\n \t\t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/OverrideMethodVisitor.java\n@@ -41,6 +41,7 @@ public boolean visit(ClassNode cls) throws JadxException {\n \t\t\tif (!overrideList.isEmpty()) {\n \t\t\t\tmth.addAttr(new MethodOverrideAttr(overrideList));\n \t\t\t\tfixMethodReturnType(mth, overrideList, superTypes);\n+\t\t\t\tfixMethodArgTypes(mth, overrideList, superTypes);\n \t\t\t}\n \t\t}\n \t\treturn true;\n@@ -105,6 +106,9 @@ private void addSuperType(RootNode root, Map<String, ArgType> superTypesMap, Arg\n \n \tprivate void fixMethodReturnType(MethodNode mth, List<IMethodDetails> overrideList, List<ArgType> superTypes) {\n \t\tArgType returnType = mth.getReturnType();\n+\t\tif (returnType == ArgType.VOID) {\n+\t\t\treturn;\n+\t\t}\n \t\tint updateCount = 0;\n \t\tfor (IMethodDetails baseMth : overrideList) {\n \t\t\tif (updateReturnType(mth, baseMth, superTypes)) {\n@@ -145,4 +149,61 @@ private boolean updateReturnType(MethodNode mth, IMethodDetails baseMth, List<Ar\n \t\t}\n \t\treturn false;\n \t}\n+\n+\tprivate void fixMethodArgTypes(MethodNode mth, List<IMethodDetails> overrideList, List<ArgType> superTypes) {\n+\t\tfor (IMethodDetails baseMth : overrideList) {\n+\t\t\tupdateArgTypes(mth, baseMth, superTypes);\n+\t\t}\n+\t}\n+\n+\tprivate void updateArgTypes(MethodNode mth, IMethodDetails baseMth, List<ArgType> superTypes) {\n+\t\tList<ArgType> mthArgTypes = mth.getArgTypes();\n+\t\tList<ArgType> baseArgTypes = baseMth.getArgTypes();\n+\t\tif (mthArgTypes.equals(baseArgTypes)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tint argCount = mthArgTypes.size();\n+\t\tif (argCount != baseArgTypes.size()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tboolean changed = false;\n+\t\tList<ArgType> newArgTypes = new ArrayList<>(argCount);\n+\t\tfor (int argNum = 0; argNum < argCount; argNum++) {\n+\t\t\tArgType newType = updateArgType(mth, baseMth, superTypes, argNum);\n+\t\t\tif (newType != null) {\n+\t\t\t\tchanged = true;\n+\t\t\t\tnewArgTypes.add(newType);\n+\t\t\t} else {\n+\t\t\t\tnewArgTypes.add(mthArgTypes.get(argNum));\n+\t\t\t}\n+\t\t}\n+\t\tif (changed) {\n+\t\t\tmth.updateArgTypes(newArgTypes, \"Method arguments types fixed to match base method\");\n+\t\t}\n+\t}\n+\n+\tprivate ArgType updateArgType(MethodNode mth, IMethodDetails baseMth, List<ArgType> superTypes, int argNum) {\n+\t\tArgType arg = mth.getArgTypes().get(argNum);\n+\t\tArgType baseArg = baseMth.getArgTypes().get(argNum);\n+\t\tif (arg.equals(baseArg)) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tif (!baseArg.containsTypeVariable()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tTypeCompare typeCompare = mth.root().getTypeUpdate().getTypeCompare();\n+\t\tArgType baseCls = baseMth.getMethodInfo().getDeclClass().getType();\n+\t\tfor (ArgType superType : superTypes) {\n+\t\t\tTypeCompareEnum compareResult = typeCompare.compareTypes(superType, baseCls);\n+\t\t\tif (compareResult == TypeCompareEnum.NARROW_BY_GENERIC) {\n+\t\t\t\tArgType targetArgType = mth.root().getTypeUtils().replaceClassGenerics(superType, baseArg);\n+\t\t\t\tif (targetArgType != null\n+\t\t\t\t\t\t&& !targetArgType.containsTypeVariable()\n+\t\t\t\t\t\t&& !targetArgType.equals(arg)) {\n+\t\t\t\t\treturn targetArgType;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n@@ -12,9 +12,9 @@\n import org.slf4j.LoggerFactory;\n \n import jadx.core.Consts;\n+import jadx.core.dex.instructions.BaseInvokeNode;\n import jadx.core.dex.instructions.IndexInsnNode;\n import jadx.core.dex.instructions.InsnType;\n-import jadx.core.dex.instructions.InvokeNode;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.PrimitiveType;\n@@ -277,11 +277,12 @@ private Map<InsnType, ITypeListener> initListenerRegistry() {\n \t\tregistry.put(InsnType.NOT, this::suggestAllSameListener);\n \t\tregistry.put(InsnType.CHECK_CAST, this::checkCastListener);\n \t\tregistry.put(InsnType.INVOKE, this::invokeListener);\n+\t\tregistry.put(InsnType.CONSTRUCTOR, this::invokeListener);\n \t\treturn registry;\n \t}\n \n \tprivate TypeUpdateResult invokeListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {\n-\t\tInvokeNode invoke = (InvokeNode) insn;\n+\t\tBaseInvokeNode invoke = (BaseInvokeNode) insn;\n \t\tif (isAssign(invoke, arg)) {\n \t\t\t// TODO: implement backward type propagation (from result to instance)\n \t\t\treturn SAME;",
    "output": "Fix resolve generic types in method arguments"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n@@ -31,6 +31,7 @@\n import jadx.gui.jobs.IndexJob;\n import jadx.gui.jobs.RefreshJob;\n import jadx.gui.jobs.UnloadJob;\n+import jadx.gui.settings.JadxSettings;\n import jadx.gui.treemodel.JClass;\n import jadx.gui.treemodel.JField;\n import jadx.gui.treemodel.JMethod;\n@@ -39,10 +40,7 @@\n import jadx.gui.ui.codearea.ClassCodeContentPanel;\n import jadx.gui.ui.codearea.CodeArea;\n import jadx.gui.ui.codearea.CodePanel;\n-import jadx.gui.utils.CacheObject;\n-import jadx.gui.utils.CodeUsageInfo;\n-import jadx.gui.utils.NLS;\n-import jadx.gui.utils.TextStandardActions;\n+import jadx.gui.utils.*;\n \n public class RenameDialog extends JDialog {\n \tprivate static final long serialVersionUID = -3269715644416902410L;\n@@ -62,8 +60,39 @@ public RenameDialog(CodeArea codeArea, JNode node) {\n \t\tmainWindow = codeArea.getMainWindow();\n \t\tthis.codeArea = codeArea;\n \t\tthis.node = node;\n-\t\tinitUI();\n-\t\tloadWindowPos();\n+\t\tif (isDeobfuscationSettingsValid()) {\n+\t\t\tinitUI();\n+\t\t\tloadWindowPos();\n+\t\t} else {\n+\t\t\tLOG.error(\"Deobfuscation settings are invalid - please enable deobfuscation and disable force rewrite deobfuscation map\");\n+\t\t}\n+\t}\n+\n+\tprivate boolean isDeobfuscationSettingsValid() {\n+\t\tboolean valid = true;\n+\t\tString errorMessage = null;\n+\t\tJadxSettings settings = mainWindow.getSettings();\n+\t\tfinal LangLocale langLocale = settings.getLangLocale();\n+\t\tif (settings.isDeobfuscationForceSave()) {\n+\t\t\tvalid = false;\n+\t\t\terrorMessage = NLS.str(\"msg.rename_disabled_force_rewrite_enabled\", langLocale);\n+\t\t}\n+\t\tif (!settings.isDeobfuscationOn()) {\n+\t\t\tvalid = false;\n+\t\t\terrorMessage = NLS.str(\"msg.rename_disabled_deobfuscation_disabled\", langLocale);\n+\t\t}\n+\t\tif (errorMessage != null) {\n+\t\t\tshowRenameDisabledErrorMessage(langLocale, errorMessage);\n+\t\t}\n+\t\treturn valid;\n+\t}\n+\n+\tprivate void showRenameDisabledErrorMessage(LangLocale langLocale, String message) {\n+\t\tJOptionPane.showMessageDialog(\n+\t\t\t\tmainWindow,\n+\t\t\t\tmessage,\n+\t\t\t\tNLS.str(\"msg.rename_disabled_title\", langLocale),\n+\t\t\t\tJOptionPane.ERROR_MESSAGE);\n \t}\n \n \tprivate void loadWindowPos() {\n@@ -131,6 +160,7 @@ private boolean writeDeobfMapFile(Path deobfMapPath, List<String> deobfMap) thro\n \t\tfileOut.close();\n \t\tFile oldMap = File.createTempFile(\"deobf_bak_\", \".txt\");\n \t\tFiles.copy(deobfMapPath, oldMap.toPath(), StandardCopyOption.REPLACE_EXISTING);\n+\t\tLOG.trace(\"Copying \" + tmpFile.toPath() + \" to \" + deobfMapPath);\n \t\tFiles.copy(tmpFile.toPath(), deobfMapPath, StandardCopyOption.REPLACE_EXISTING);\n \t\tFiles.delete(oldMap.toPath());\n \t\tFiles.delete(tmpFile.toPath());\n@@ -143,6 +173,7 @@ private List<String> readDeobfMap(Path deobfMapPath) throws IOException {\n \t}\n \n \tprivate List<String> updateDeobfMap(List<String> deobfMap, String alias) {\n+\t\tLOG.trace(\"updateDeobfMap(): alias = \" + alias);\n \t\tString id = alias.split(\"=\")[0];\n \t\tint i = 0;\n \t\twhile (i < deobfMap.size()) {\n@@ -153,6 +184,7 @@ private List<String> updateDeobfMap(List<String> deobfMap, String alias) {\n \t\t\t\ti++;\n \t\t\t}\n \t\t}\n+\t\tLOG.trace(\"updateDeobfMap(): Placing alias = \" + alias);\n \t\tdeobfMap.add(alias);\n \t\treturn deobfMap;\n \t}\n@@ -170,6 +202,7 @@ private void rename() {\n \t\t\treturn;\n \t\t}\n \t\tif (!refreshDeobfMapFile(renameText, root)) {\n+\t\t\tLOG.error(\"rename(): refreshDeobfMapFile() failed!\");\n \t\t\tdispose();\n \t\t\treturn;\n \t\t}\n@@ -190,22 +223,13 @@ private boolean refreshDeobfMapFile(String renameText, RootNode root) {\n \t\t\tdeobfMap = readDeobfMap(deobfMapPath);\n \t\t} catch (IOException e) {\n \t\t\tLOG.error(\"rename(): readDeobfMap() failed\");\n-\t\t\tdispose();\n \t\t\treturn false;\n \t\t}\n \t\tupdateDeobfMap(deobfMap, getNodeAlias(renameText));\n \t\ttry {\n \t\t\twriteDeobfMapFile(deobfMapPath, deobfMap);\n \t\t} catch (IOException e) {\n \t\t\tLOG.error(\"rename(): writeDeobfMap() failed\");\n-\t\t\tdispose();\n-\t\t\treturn false;\n-\t\t}\n-\t\ttry {\n-\t\t\twriteDeobfMapFile(deobfMapPath, deobfMap);\n-\t\t} catch (IOException e) {\n-\t\t\tLOG.error(\"rename(): updateDeobfMap() failed\");\n-\t\t\tdispose();\n \t\t\treturn false;\n \t\t}\n \t\treturn true;",
    "output": "Fix RenameDialog: Warn user if deobfuscation settings are invalid"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java b/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java\n@@ -52,7 +52,7 @@ private static void initCodeVars(MethodNode mth) {\n \t\t}\n \t}\n \n-\tprivate static void initCodeVar(SSAVar ssaVar) {\n+\tpublic static void initCodeVar(SSAVar ssaVar) {\n \t\tif (ssaVar.isCodeVarSet()) {\n \t\t\treturn;\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -401,13 +401,25 @@ private static InsnNode convertStringBuilderChain(MethodNode mth, InvokeNode toS\n \t\t\tconcatInsn.copyAttributesFrom(toStrInsn);\n \t\t\tconcatInsn.remove(AFlag.DONT_GENERATE);\n \t\t\tconcatInsn.remove(AFlag.REMOVE);\n+\t\t\tcheckResult(mth, concatInsn);\n \t\t\treturn concatInsn;\n \t\t} catch (Exception e) {\n \t\t\tLOG.warn(\"Can't convert string concatenation: {} insn: {}\", mth, toStrInsn, e);\n \t\t}\n \t\treturn null;\n \t}\n \n+\t/* String concat without assign to variable will cause compilation error */\n+\tprivate static void checkResult(MethodNode mth, InsnNode concatInsn) {\n+\t\tif (concatInsn.getResult() == null) {\n+\t\t\tRegisterArg resArg = InsnArg.reg(0, ArgType.STRING);\n+\t\t\tSSAVar ssaVar = mth.makeNewSVar(resArg);\n+\t\t\tInitCodeVariables.initCodeVar(ssaVar);\n+\t\t\tssaVar.setType(ArgType.STRING);\n+\t\t\tconcatInsn.setResult(resArg);\n+\t\t}\n+\t}\n+\n \t/**\n \t * Remove and unbind all instructions with StringBuilder\n \t */\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConcatWithoutResult.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConcatWithoutResult.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConcatWithoutResult.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConcatWithoutResult.java\n@@ -0,0 +1,32 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestStringConcatWithoutResult extends IntegrationTest {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(TestStringConcatWithoutResult.class);\n+\n+\tpublic static class TestCls {\n+\t\tpublic static final boolean LOG_DEBUG = false;\n+\n+\t\tpublic void test(int i) {\n+\t\t\tString msg = \"Input arg value: \" + i;\n+\t\t\tif (LOG_DEBUG) {\n+\t\t\t\tLOG.debug(msg);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\" = \\\"Input arg value: \\\" + i;\");\n+\t}\n+}",
    "output": "Fix don't generate string concatenation without assign to variable"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -16,6 +16,7 @@\n import jadx.core.dex.attributes.nodes.JumpInfo;\n import jadx.core.dex.attributes.nodes.MethodOverrideAttr;\n import jadx.core.dex.info.AccessInfo;\n+import jadx.core.dex.instructions.ConstStringNode;\n import jadx.core.dex.instructions.IfNode;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.args.ArgType;\n@@ -35,6 +36,10 @@\n import jadx.core.utils.exceptions.DecodeException;\n import jadx.core.utils.exceptions.JadxOverflowException;\n \n+import static jadx.core.codegen.MethodGen.FallbackOption.BLOCK_DUMP;\n+import static jadx.core.codegen.MethodGen.FallbackOption.COMMENTED_DUMP;\n+import static jadx.core.codegen.MethodGen.FallbackOption.FALLBACK_MODE;\n+\n public class MethodGen {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(MethodGen.class);\n \n@@ -221,7 +226,7 @@ private void addMethodArguments(CodeWriter code, List<RegisterArg> args) {\n \n \tpublic void addInstructions(CodeWriter code) throws CodegenException {\n \t\tif (mth.root().getArgs().isFallbackMode()) {\n-\t\t\taddFallbackMethodCode(code);\n+\t\t\taddFallbackMethodCode(code, FALLBACK_MODE);\n \t\t} else if (classGen.isFallbackMode()) {\n \t\t\tdumpInstructions(code);\n \t\t} else {\n@@ -249,7 +254,7 @@ public void addRegionInsns(CodeWriter code) throws CodegenException {\n \n \tpublic void dumpInstructions(CodeWriter code) {\n \t\tcode.startLine(\"/*\");\n-\t\taddFallbackMethodCode(code);\n+\t\taddFallbackMethodCode(code, COMMENTED_DUMP);\n \t\tcode.startLine(\"*/\");\n \n \t\tcode.startLine(\"throw new UnsupportedOperationException(\\\"Method not decompiled: \")\n@@ -263,7 +268,7 @@ public void dumpInstructions(CodeWriter code) {\n \t\t\t\t.add(\"\\\");\");\n \t}\n \n-\tpublic void addFallbackMethodCode(CodeWriter code) {\n+\tpublic void addFallbackMethodCode(CodeWriter code, FallbackOption fallbackOption) {\n \t\tif (mth.getInstructions() == null) {\n \t\t\t// load original instructions\n \t\t\ttry {\n@@ -285,19 +290,25 @@ public void addFallbackMethodCode(CodeWriter code) {\n \t\tif (mth.getThisArg() != null) {\n \t\t\tcode.startLine(nameGen.useArg(mth.getThisArg())).add(\" = this;\");\n \t\t}\n-\t\taddFallbackInsns(code, mth, insnArr, true);\n+\t\taddFallbackInsns(code, mth, insnArr, fallbackOption);\n \t\tcode.decIndent();\n \t}\n \n-\tpublic static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[] insnArr, boolean addLabels) {\n+\tpublic enum FallbackOption {\n+\t\tFALLBACK_MODE,\n+\t\tBLOCK_DUMP,\n+\t\tCOMMENTED_DUMP\n+\t}\n+\n+\tpublic static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[] insnArr, FallbackOption option) {\n \t\tInsnGen insnGen = new InsnGen(getFallbackMethodGen(mth), true);\n \t\tboolean attachInsns = mth.root().getArgs().isJsonOutput();\n \t\tInsnNode prevInsn = null;\n \t\tfor (InsnNode insn : insnArr) {\n \t\t\tif (insn == null) {\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tif (addLabels && needLabel(insn, prevInsn)) {\n+\t\t\tif (option != BLOCK_DUMP && needLabel(insn, prevInsn)) {\n \t\t\t\tcode.decIndent();\n \t\t\t\tcode.startLine(getLabelName(insn.getOffset()) + ':');\n \t\t\t\tcode.incIndent();\n@@ -306,7 +317,14 @@ public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[]\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\ttry {\n-\t\t\t\tcode.startLine();\n+\t\t\t\tboolean escapeComment = isCommentEscapeNeeded(insn, option);\n+\t\t\t\tif (escapeComment) {\n+\t\t\t\t\tcode.decIndent();\n+\t\t\t\t\tcode.startLine(\"*/\");\n+\t\t\t\t\tcode.startLine(\"//  \");\n+\t\t\t\t} else {\n+\t\t\t\t\tcode.startLine();\n+\t\t\t\t}\n \t\t\t\tif (attachInsns) {\n \t\t\t\t\tcode.attachLineAnnotation(insn);\n \t\t\t\t}\n@@ -318,6 +336,11 @@ public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[]\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tinsnGen.makeInsn(insn, code, InsnGen.Flags.INLINE);\n+\t\t\t\tif (escapeComment) {\n+\t\t\t\t\tcode.startLine(\"/*\");\n+\t\t\t\t\tcode.incIndent();\n+\t\t\t\t}\n+\n \t\t\t\tCatchAttr catchAttr = insn.get(AType.CATCH_BLOCK);\n \t\t\t\tif (catchAttr != null) {\n \t\t\t\t\tcode.add(\"     // \" + catchAttr);\n@@ -330,6 +353,16 @@ public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[]\n \t\t}\n \t}\n \n+\tprivate static boolean isCommentEscapeNeeded(InsnNode insn, FallbackOption option) {\n+\t\tif (option == COMMENTED_DUMP) {\n+\t\t\tif (insn.getType() == InsnType.CONST_STR) {\n+\t\t\t\tString str = ((ConstStringNode) insn).getString();\n+\t\t\t\treturn str.contains(\"*/\");\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tprivate static boolean needLabel(InsnNode insn, InsnNode prevInsn) {\n \t\tif (insn.contains(AType.EXC_HANDLER)) {\n \t\t\treturn true;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java\n@@ -23,6 +23,8 @@\n import jadx.core.utils.StringUtils;\n import jadx.core.utils.Utils;\n \n+import static jadx.core.codegen.MethodGen.FallbackOption.BLOCK_DUMP;\n+\n public class DotGraphVisitor extends AbstractVisitor {\n \n \tprivate static final String NL = \"\\\\l\";\n@@ -272,7 +274,7 @@ private String insertInsns(MethodNode mth, IBlock block) {\n \t\t\t} else {\n \t\t\t\tCodeWriter code = new CodeWriter();\n \t\t\t\tList<InsnNode> instructions = block.getInstructions();\n-\t\t\t\tMethodGen.addFallbackInsns(code, mth, instructions.toArray(new InsnNode[0]), false);\n+\t\t\t\tMethodGen.addFallbackInsns(code, mth, instructions.toArray(new InsnNode[0]), BLOCK_DUMP);\n \t\t\t\tString str = escape(code.newLine().toString());\n \t\t\t\tif (str.startsWith(NL)) {\n \t\t\t\t\tstr = str.substring(NL.length());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java\n@@ -61,7 +61,7 @@ public void processBlock(MethodNode mth, IBlock container) {\n \t\t\t\t\t\t&& !block.contains(AFlag.ADDED_TO_REGION)\n \t\t\t\t\t\t&& !block.contains(AFlag.DONT_GENERATE)\n \t\t\t\t\t\t&& !block.contains(AFlag.REMOVE)) {\n-\t\t\t\t\tString blockCode = getBlockInsnStr(mth, block);\n+\t\t\t\t\tString blockCode = getBlockInsnStr(mth, block).replace(\"*/\", \"*\\\\/\");\n \t\t\t\t\tmth.addWarn(\"Code restructure failed: missing block: \" + block + \", code lost:\" + blockCode);\n \t\t\t\t}\n \t\t\t}",
    "output": "Fix restart comment to escape strings in insn fallback dump"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n@@ -17,6 +17,7 @@\n import jadx.core.xmlgen.entry.ValuesParser;\n \n import static jadx.core.xmlgen.ParserConstants.PLURALS_MAP;\n+import static jadx.core.xmlgen.ParserConstants.TYPE_REFERENCE;\n \n public class ResXmlGen {\n \n@@ -85,10 +86,16 @@ private void addValue(CodeWriter cw, ResourceEntry ri) {\n \t\t\t\tif (formatValue != null) {\n \t\t\t\t\tcw.add(\"\\\" format=\\\"\").add(formatValue);\n \t\t\t\t}\n-\t\t\t\tcw.add(\"\\\">\");\n+\t\t\t\tcw.add(\"\\\"\");\n \t\t\t} else {\n-\t\t\t\tcw.add(\"name=\\\"\").add(ri.getKeyName()).add(\"\\\">\");\n+\t\t\t\tcw.add(\"name=\\\"\").add(ri.getKeyName()).add('\\\"');\n \t\t\t}\n+\t\t\tif (ri.getParentRef() != 0) {\n+\t\t\t\tString parent = vp.decodeValue(TYPE_REFERENCE, ri.getParentRef());\n+\t\t\t\tcw.add(\" parent=\\\"\").add(parent).add('\\\"');\n+\t\t\t}\n+\t\t\tcw.add(\">\");\n+\n \t\t\tcw.incIndent();\n \t\t\tfor (RawNamedValue value : ri.getNamedValues()) {\n \t\t\t\taddItem(cw, itemTag, ri.getTypeName(), value);",
    "output": "Fix resource XML generation for parent attribute added (PR #933, #931)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n@@ -270,7 +270,6 @@ public String getDetailedVarInfo(MethodNode mth) {\n \t\tif (!types.isEmpty()) {\n \t\t\tsb.append(\", types: \").append(types);\n \t\t}\n-\t\tsb.append(\", assign insn: \").append(getAssign().getParentInsn());\n \t\treturn sb.toString();\n \t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -92,7 +92,13 @@ private boolean resolveTypes(MethodNode mth) {\n \t\tif (tryInsertAdditionalMove(mth)) {\n \t\t\treturn true;\n \t\t}\n-\t\treturn runMultiVariableSearch(mth);\n+\t\tif (runMultiVariableSearch(mth)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (tryRemoveGenerics(mth)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n \t}\n \n \t/**\n@@ -124,11 +130,15 @@ private boolean runTypePropagation(MethodNode mth) {\n \tprivate boolean runMultiVariableSearch(MethodNode mth) {\n \t\tTypeSearch typeSearch = new TypeSearch(mth);\n \t\ttry {\n-\t\t\tboolean success = typeSearch.run();\n-\t\t\tif (!success) {\n+\t\t\tif (!typeSearch.run()) {\n \t\t\t\tmth.addWarn(\"Multi-variable type inference failed\");\n \t\t\t}\n-\t\t\treturn success;\n+\t\t\tfor (SSAVar var : mth.getSVars()) {\n+\t\t\t\tif (!var.getTypeInfo().getType().isTypeKnown()) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true;\n \t\t} catch (Exception e) {\n \t\t\tmth.addWarn(\"Multi-variable type inference failed. Error: \" + Utils.getStackTrace(e));\n \t\t\treturn false;\n@@ -366,6 +376,48 @@ private boolean tryDeduceType(MethodNode mth, SSAVar var, @Nullable ArgType type\n \t\treturn false;\n \t}\n \n+\tprivate boolean tryRemoveGenerics(MethodNode mth) {\n+\t\tboolean resolved = true;\n+\t\tfor (SSAVar var : mth.getSVars()) {\n+\t\t\tArgType type = var.getTypeInfo().getType();\n+\t\t\tif (!type.isTypeKnown() && !var.isTypeImmutable()\n+\t\t\t\t\t&& !tryRawType(mth, var)) {\n+\t\t\t\tresolved = false;\n+\t\t\t}\n+\t\t}\n+\t\treturn resolved;\n+\t}\n+\n+\tprivate boolean tryRawType(MethodNode mth, SSAVar var) {\n+\t\tSet<ArgType> objTypes = new LinkedHashSet<>();\n+\t\tfor (ITypeBound bound : var.getTypeInfo().getBounds()) {\n+\t\t\tArgType boundType = bound.getType();\n+\t\t\tif (boundType.isTypeKnown() && boundType.isObject()) {\n+\t\t\t\tobjTypes.add(boundType);\n+\t\t\t}\n+\t\t}\n+\t\tif (objTypes.isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tfor (ArgType objType : objTypes) {\n+\t\t\tif (checkRawType(mth, var, objType)) {\n+\t\t\t\tmth.addDebugComment(\"Type inference failed for \" + var.toShortString() + \".\"\n+\t\t\t\t\t\t+ \" Raw type applied. Possible types: \" + Utils.listToString(objTypes));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprivate boolean checkRawType(MethodNode mth, SSAVar var, ArgType objType) {\n+\t\tif (objType.isObject() && objType.containsGeneric()) {\n+\t\t\tArgType rawType = ArgType.object(objType.getObject());\n+\t\t\tTypeUpdateResult result = typeUpdate.applyWithWiderAllow(var, rawType);\n+\t\t\treturn result == TypeUpdateResult.CHANGED;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tprivate boolean trySplitConstInsns(MethodNode mth) {\n \t\tboolean constSplitted = false;\n \t\tfor (SSAVar var : new ArrayList<>(mth.getSVars())) {",
    "output": "Fix try raw types to help type inference"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Jadx.java b/jadx-core/src/main/java/jadx/core/Jadx.java\n--- a/jadx-core/src/main/java/jadx/core/Jadx.java\n+++ b/jadx-core/src/main/java/jadx/core/Jadx.java\n@@ -57,6 +57,7 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {\n \t\t\tpasses.add(new BlockExceptionHandler());\n \t\t\tpasses.add(new BlockFinish());\n \n+\t\t\tpasses.add(new AttachMethodDetails());\n \t\t\tpasses.add(new OverrideMethodVisitor());\n \n \t\t\tpasses.add(new SSATransform());\n@@ -65,7 +66,6 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {\n \t\t\tpasses.add(new InitCodeVariables());\n \t\t\tpasses.add(new MarkFinallyVisitor());\n \t\t\tpasses.add(new ConstInlineVisitor());\n-\t\t\tpasses.add(new AttachMethodDetails());\n \t\t\tpasses.add(new TypeInferenceVisitor());\n \t\t\tif (args.isDebugInfo()) {\n \t\t\t\tpasses.add(new DebugInfoApplyVisitor());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/AttachMethodDetails.java b/jadx-core/src/main/java/jadx/core/dex/visitors/AttachMethodDetails.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/AttachMethodDetails.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/AttachMethodDetails.java\n@@ -8,13 +8,17 @@\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.nodes.utils.MethodUtils;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n+import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;\n import jadx.core.utils.exceptions.JadxException;\n \n @JadxVisitor(\n \t\tname = \"Attach Method Details\",\n \t\tdesc = \"Attach method details for invoke instructions\",\n \t\trunBefore = {\n-\t\t\t\tCodeShrinkVisitor.class\n+\t\t\t\tCodeShrinkVisitor.class,\n+\t\t\t\tTypeInferenceVisitor.class,\n+\t\t\t\tMethodInvokeVisitor.class,\n+\t\t\t\tOverrideMethodVisitor.class\n \t\t}\n )\n public class AttachMethodDetails extends AbstractVisitor {",
    "output": "Fix attach method details before OverrideMethodVisitor"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n@@ -5,6 +5,8 @@\n import java.util.List;\n import java.util.Objects;\n \n+import org.jetbrains.annotations.NotNull;\n+\n import jadx.core.Consts;\n import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.nodes.ClassNode;\n@@ -114,7 +116,7 @@ public static ArgType outerGeneric(ArgType genericOuterType, ArgType innerType)\n \t\treturn new OuterGenericObject((GenericObject) genericOuterType, (ObjectType) innerType);\n \t}\n \n-\tpublic static ArgType array(ArgType vtype) {\n+\tpublic static ArgType array(@NotNull ArgType vtype) {\n \t\treturn new ArrayArg(vtype);\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n@@ -117,6 +117,13 @@ public ArgType replaceTypeVariablesUsingMap(ArgType replaceType, Map<ArgType, Ar\n \t\tif (replaceType.isGenericType()) {\n \t\t\treturn replaceMap.get(replaceType);\n \t\t}\n+\t\tif (replaceType.isArray()) {\n+\t\t\tArgType replaced = replaceTypeVariablesUsingMap(replaceType.getArrayElement(), replaceMap);\n+\t\t\tif (replaced == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn ArgType.array(replaced);\n+\t\t}\n \n \t\tArgType wildcardType = replaceType.getWildcardType();\n \t\tif (wildcardType != null && wildcardType.containsTypeVariable()) {\n\ndiff --git a/jadx-core/src/test/java/jadx/core/dex/nodes/utils/TypeUtilsTest.java b/jadx-core/src/test/java/jadx/core/dex/nodes/utils/TypeUtilsTest.java\n--- a/jadx-core/src/test/java/jadx/core/dex/nodes/utils/TypeUtilsTest.java\n+++ b/jadx-core/src/test/java/jadx/core/dex/nodes/utils/TypeUtilsTest.java\n@@ -0,0 +1,45 @@\n+package jadx.core.dex.nodes.utils;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.api.JadxArgs;\n+import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.nodes.RootNode;\n+\n+import static jadx.core.dex.instructions.args.ArgType.STRING;\n+import static jadx.core.dex.instructions.args.ArgType.array;\n+import static jadx.core.dex.instructions.args.ArgType.generic;\n+import static jadx.core.dex.instructions.args.ArgType.genericType;\n+import static jadx.core.dex.instructions.args.ArgType.object;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class TypeUtilsTest {\n+\tprivate TypeUtils typeUtils;\n+\n+\t@BeforeEach\n+\tpublic void init() {\n+\t\ttypeUtils = new TypeUtils(new RootNode(new JadxArgs()));\n+\t}\n+\n+\t@Test\n+\tvoid replaceTypeVariablesUsingMap() {\n+\t\tArgType typeVar = genericType(\"T\");\n+\t\tArgType listCls = object(\"java.util.List\");\n+\t\tMap<ArgType, ArgType> typeMap = Collections.singletonMap(typeVar, STRING);\n+\n+\t\treplaceTypeVar(typeVar, typeMap, STRING);\n+\t\treplaceTypeVar(generic(listCls, typeVar), typeMap, generic(listCls, STRING));\n+\t\treplaceTypeVar(array(typeVar), typeMap, array(STRING));\n+\t}\n+\n+\tprivate void replaceTypeVar(ArgType typeVar, Map<ArgType, ArgType> typeMap, ArgType expected) {\n+\t\tArgType resultType = typeUtils.replaceTypeVariablesUsingMap(typeVar, typeMap);\n+\t\tassertThat(resultType)\n+\t\t\t\t.as(\"Replace %s using map %s\", typeVar, typeMap)\n+\t\t\t\t.isEqualTo(expected);\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/generics/TestMethodOverride.java b/jadx-core/src/test/java/jadx/tests/integration/generics/TestMethodOverride.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/generics/TestMethodOverride.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/generics/TestMethodOverride.java\n@@ -15,6 +15,7 @@ public void test() {\n \t\tassertThat(getClassNodeFromSmali())\n \t\t\t\t.code()\n \t\t\t\t.containsOne(\"String createFromParcel(Parcel parcel) {\")\n-\t\t\t\t.containsOne(\"@Override\");\n+\t\t\t\t.containsOne(\"String[] newArray(int i) {\")\n+\t\t\t\t.countString(2, \"@Override\");\n \t}\n }",
    "output": "Fix replace type variables in arrays"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -181,7 +181,7 @@ public void initMethodTypes() {\n \t\t\tthis.retType = mthInfo.getReturnType();\n \t\t\tthis.argTypes = mthInfo.getArgumentsTypes();\n \t\t} else {\n-\t\t\tthis.argTypes = types;\n+\t\t\tthis.argTypes = Collections.unmodifiableList(types);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/TypeUtils.java\n@@ -110,6 +110,9 @@ public ArgType replaceMethodGenerics(BaseInvokeNode invokeInsn, IMethodDetails d\n \n \t@Nullable\n \tpublic ArgType replaceTypeVariablesUsingMap(ArgType replaceType, Map<ArgType, ArgType> replaceMap) {\n+\t\tif (replaceMap.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n \t\tif (replaceType.isGenericType()) {\n \t\t\treturn replaceMap.get(replaceType);\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInvokeVisitor.java\n@@ -22,6 +22,7 @@\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.RootNode;\n+import jadx.core.dex.visitors.methods.MutableMethodDetails;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n import jadx.core.dex.visitors.typeinference.TypeCompare;\n import jadx.core.dex.visitors.typeinference.TypeCompareEnum;\n@@ -111,12 +112,19 @@ private void processOverloaded(MethodNode parentMth, BaseInvokeNode invokeInsn,\n \t\t\treturn;\n \t\t}\n \n-\t\toverloadMethods.add(mthDetails);\n-\t\tresolveTypeVariablesInMethodArgs(invokeInsn, mthDetails, overloadMethods);\n+\t\t// resolve generic type variables\n+\t\tMap<ArgType, ArgType> typeVarsMapping = getTypeVarsMapping(invokeInsn);\n+\t\tIMethodDetails effectiveMthDetails = resolveTypeVars(mthDetails, typeVarsMapping);\n+\t\tList<IMethodDetails> effectiveOverloadMethods = new ArrayList<>(overloadMethods.size() + 1);\n+\t\tfor (IMethodDetails overloadMethod : overloadMethods) {\n+\t\t\teffectiveOverloadMethods.add(resolveTypeVars(overloadMethod, typeVarsMapping));\n+\t\t}\n+\t\teffectiveOverloadMethods.add(effectiveMthDetails);\n \n+\t\t// search cast types to resolve overloading\n \t\tint argsOffset = invokeInsn.getFirstArgOffset();\n \t\tList<ArgType> compilerVarTypes = collectCompilerVarTypes(invokeInsn, argsOffset);\n-\t\tList<ArgType> castTypes = searchCastTypes(parentMth, mthDetails, overloadMethods, compilerVarTypes);\n+\t\tList<ArgType> castTypes = searchCastTypes(parentMth, effectiveMthDetails, effectiveOverloadMethods, compilerVarTypes);\n \t\tapplyArgsCast(invokeInsn, argsOffset, compilerVarTypes, castTypes);\n \t}\n \n@@ -147,8 +155,7 @@ private ArgType getCallClassFromInvoke(MethodNode parentMth, BaseInvokeNode invo\n \t\treturn callMth.getDeclClass().getType();\n \t}\n \n-\tprivate void resolveTypeVariablesInMethodArgs(BaseInvokeNode invokeInsn, IMethodDetails mthDetails,\n-\t\t\tList<IMethodDetails> overloadedMethods) {\n+\tprivate Map<ArgType, ArgType> getTypeVarsMapping(BaseInvokeNode invokeInsn) {\n \t\tMethodInfo callMth = invokeInsn.getCallMth();\n \t\tArgType declClsType = callMth.getDeclClass().getType();\n \t\tArgType callClsType;\n@@ -158,12 +165,7 @@ private void resolveTypeVariablesInMethodArgs(BaseInvokeNode invokeInsn, IMethod\n \t\t} else {\n \t\t\tcallClsType = declClsType;\n \t\t}\n-\n-\t\tMap<ArgType, ArgType> typeVarsMapping = root.getTypeUtils().getTypeVariablesMapping(callClsType);\n-\t\tresolveTypeVars(mthDetails, typeVarsMapping);\n-\t\tfor (IMethodDetails m : overloadedMethods) {\n-\t\t\tresolveTypeVars(m, typeVarsMapping);\n-\t\t}\n+\t\treturn root.getTypeUtils().getTypeVariablesMapping(callClsType);\n \t}\n \n \tprivate void applyArgsCast(BaseInvokeNode invokeInsn, int argsOffset, List<ArgType> compilerVarTypes, List<ArgType> castTypes) {\n@@ -199,9 +201,11 @@ private void applyArgsCast(BaseInvokeNode invokeInsn, int argsOffset, List<ArgTy\n \t\t}\n \t}\n \n-\tprivate void resolveTypeVars(IMethodDetails mthDetails, Map<ArgType, ArgType> typeVarsMapping) {\n+\tprivate IMethodDetails resolveTypeVars(IMethodDetails mthDetails, Map<ArgType, ArgType> typeVarsMapping) {\n \t\tList<ArgType> argTypes = mthDetails.getArgTypes();\n \t\tint argsCount = argTypes.size();\n+\t\tboolean fixed = false;\n+\t\tList<ArgType> fixedArgTypes = new ArrayList<>(argsCount);\n \t\tfor (int argNum = 0; argNum < argsCount; argNum++) {\n \t\t\tArgType argType = argTypes.get(argNum);\n \t\t\tif (argType == null) {\n@@ -213,9 +217,28 @@ private void resolveTypeVars(IMethodDetails mthDetails, Map<ArgType, ArgType> ty\n \t\t\t\t\t// type variables erased from method info by compiler\n \t\t\t\t\tresolvedType = mthDetails.getMethodInfo().getArgumentsTypes().get(argNum);\n \t\t\t\t}\n-\t\t\t\targTypes.set(argNum, resolvedType);\n+\t\t\t\tfixedArgTypes.add(resolvedType);\n+\t\t\t\tfixed = true;\n+\t\t\t} else {\n+\t\t\t\tfixedArgTypes.add(argType);\n \t\t\t}\n \t\t}\n+\t\tArgType returnType = mthDetails.getReturnType();\n+\t\tif (returnType.containsTypeVariable()) {\n+\t\t\tArgType resolvedType = root.getTypeUtils().replaceTypeVariablesUsingMap(returnType, typeVarsMapping);\n+\t\t\tif (resolvedType == null || resolvedType.containsTypeVariable()) {\n+\t\t\t\treturnType = mthDetails.getMethodInfo().getReturnType();\n+\t\t\t\tfixed = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!fixed) {\n+\t\t\treturn mthDetails;\n+\t\t}\n+\t\tMutableMethodDetails mutableMethodDetails = new MutableMethodDetails(mthDetails);\n+\t\tmutableMethodDetails.setArgTypes(fixedArgTypes);\n+\t\tmutableMethodDetails.setRetType(returnType);\n+\t\treturn mutableMethodDetails;\n \t}\n \n \tprivate List<ArgType> searchCastTypes(MethodNode parentMth, IMethodDetails mthDetails, List<IMethodDetails> overloadedMethods,\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/methods/MutableMethodDetails.java b/jadx-core/src/main/java/jadx/core/dex/visitors/methods/MutableMethodDetails.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/methods/MutableMethodDetails.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/methods/MutableMethodDetails.java\n@@ -0,0 +1,83 @@\n+package jadx.core.dex.visitors.methods;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import jadx.core.dex.info.MethodInfo;\n+import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.nodes.GenericTypeParameter;\n+import jadx.core.dex.nodes.IMethodDetails;\n+\n+public class MutableMethodDetails implements IMethodDetails {\n+\n+\tprivate final MethodInfo mthInfo;\n+\tprivate ArgType retType;\n+\tprivate List<ArgType> argTypes;\n+\tprivate List<GenericTypeParameter> typeParams;\n+\tprivate List<ArgType> throwTypes;\n+\tprivate boolean varArg;\n+\n+\tpublic MutableMethodDetails(IMethodDetails base) {\n+\t\tthis.mthInfo = base.getMethodInfo();\n+\t\tthis.retType = base.getReturnType();\n+\t\tthis.argTypes = Collections.unmodifiableList(base.getArgTypes());\n+\t\tthis.typeParams = Collections.unmodifiableList(base.getTypeParameters());\n+\t\tthis.throwTypes = Collections.unmodifiableList(base.getThrows());\n+\t\tthis.varArg = base.isVarArg();\n+\t}\n+\n+\t@Override\n+\tpublic MethodInfo getMethodInfo() {\n+\t\treturn mthInfo;\n+\t}\n+\n+\t@Override\n+\tpublic ArgType getReturnType() {\n+\t\treturn retType;\n+\t}\n+\n+\t@Override\n+\tpublic List<ArgType> getArgTypes() {\n+\t\treturn argTypes;\n+\t}\n+\n+\t@Override\n+\tpublic List<GenericTypeParameter> getTypeParameters() {\n+\t\treturn typeParams;\n+\t}\n+\n+\t@Override\n+\tpublic List<ArgType> getThrows() {\n+\t\treturn throwTypes;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isVarArg() {\n+\t\treturn varArg;\n+\t}\n+\n+\tpublic void setRetType(ArgType retType) {\n+\t\tthis.retType = retType;\n+\t}\n+\n+\tpublic void setArgTypes(List<ArgType> argTypes) {\n+\t\tthis.argTypes = argTypes;\n+\t}\n+\n+\tpublic void setTypeParams(List<GenericTypeParameter> typeParams) {\n+\t\tthis.typeParams = typeParams;\n+\t}\n+\n+\tpublic void setThrowTypes(List<ArgType> throwTypes) {\n+\t\tthis.throwTypes = throwTypes;\n+\t}\n+\n+\tpublic void setVarArg(boolean varArg) {\n+\t\tthis.varArg = varArg;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"Mutable\" + toAttrString();\n+\t}\n+}",
    "output": "Fix don't modify method argument types in MethodInvokeVisitor (#927 #836)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Jadx.java b/jadx-core/src/main/java/jadx/core/Jadx.java\n--- a/jadx-core/src/main/java/jadx/core/Jadx.java\n+++ b/jadx-core/src/main/java/jadx/core/Jadx.java\n@@ -58,6 +58,7 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {\n \t\t\tpasses.add(new BlockFinish());\n \n \t\t\tpasses.add(new SSATransform());\n+\t\t\tpasses.add(new MoveInlineVisitor());\n \t\t\tpasses.add(new ConstructorVisitor());\n \t\t\tpasses.add(new InitCodeVariables());\n \t\t\tpasses.add(new MarkFinallyVisitor());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n@@ -130,12 +130,20 @@ public RegisterArg duplicate() {\n \t\treturn duplicate(getRegNum(), sVar);\n \t}\n \n+\tpublic RegisterArg duplicate(ArgType initType) {\n+\t\treturn duplicate(getRegNum(), initType, sVar);\n+\t}\n+\n \tpublic RegisterArg duplicate(@Nullable SSAVar ssaVar) {\n \t\treturn duplicate(getRegNum(), ssaVar);\n \t}\n \n \tpublic RegisterArg duplicate(int regNum, @Nullable SSAVar sVar) {\n-\t\tRegisterArg dup = new RegisterArg(regNum, getInitType());\n+\t\treturn duplicate(regNum, getInitType(), sVar);\n+\t}\n+\n+\tpublic RegisterArg duplicate(int regNum, ArgType initType, @Nullable SSAVar sVar) {\n+\t\tRegisterArg dup = new RegisterArg(regNum, initType);\n \t\tif (sVar != null) {\n \t\t\t// only 'set' here, 'assign' or 'use' will binds later\n \t\t\tdup.setSVar(sVar);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n@@ -217,6 +217,17 @@ public boolean isConstInsn() {\n \t\t}\n \t}\n \n+\tpublic boolean canRemoveResult() {\n+\t\tswitch (getType()) {\n+\t\t\tcase INVOKE:\n+\t\t\tcase CONSTRUCTOR:\n+\t\t\t\treturn true;\n+\n+\t\t\tdefault:\n+\t\t\t\treturn false;\n+\t\t}\n+\t}\n+\n \tpublic boolean canReorder() {\n \t\tif (contains(AFlag.DONT_GENERATE)) {\n \t\t\tif (getType() == InsnType.MONITOR_EXIT) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n@@ -24,7 +24,7 @@\n @JadxVisitor(\n \t\tname = \"ConstructorVisitor\",\n \t\tdesc = \"Replace invoke with constructor call\",\n-\t\trunAfter = SSATransform.class,\n+\t\trunAfter = { SSATransform.class, MoveInlineVisitor.class },\n \t\trunBefore = TypeInferenceVisitor.class\n )\n public class ConstructorVisitor extends AbstractVisitor {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MoveInlineVisitor.java\n@@ -0,0 +1,103 @@\n+package jadx.core.dex.visitors;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;\n+import jadx.core.dex.instructions.InsnType;\n+import jadx.core.dex.instructions.args.InsnArg;\n+import jadx.core.dex.instructions.args.RegisterArg;\n+import jadx.core.dex.instructions.args.SSAVar;\n+import jadx.core.dex.nodes.BlockNode;\n+import jadx.core.dex.nodes.InsnNode;\n+import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n+import jadx.core.dex.visitors.ssa.SSATransform;\n+import jadx.core.utils.InsnRemover;\n+\n+@JadxVisitor(\n+\t\tname = \"MoveInlineVisitor\",\n+\t\tdesc = \"Inline redundant move instructions\",\n+\t\trunAfter = SSATransform.class,\n+\t\trunBefore = CodeShrinkVisitor.class\n+)\n+public class MoveInlineVisitor extends AbstractVisitor {\n+\t@Override\n+\tpublic void visit(MethodNode mth) {\n+\t\tif (mth.isNoCode()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tmoveInline(mth);\n+\t}\n+\n+\tprivate static void moveInline(MethodNode mth) {\n+\t\tInsnRemover remover = new InsnRemover(mth);\n+\t\tfor (BlockNode block : mth.getBasicBlocks()) {\n+\t\t\tremover.setBlock(block);\n+\t\t\tList<InsnNode> insns = block.getInstructions();\n+\t\t\tint size = insns.size();\n+\t\t\tfor (int i = 0; i < size; i++) {\n+\t\t\t\tInsnNode insn = insns.get(i);\n+\t\t\t\tif (insn.getType() == InsnType.MOVE\n+\t\t\t\t\t\t&& processMove(mth, block, insn, i)) {\n+\t\t\t\t\tremover.addAndUnbind(insn);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tremover.perform();\n+\t\t}\n+\t}\n+\n+\tprivate static boolean processMove(MethodNode mth, BlockNode block, InsnNode move, int i) {\n+\t\tRegisterArg resultArg = move.getResult();\n+\t\tInsnArg moveArg = move.getArg(0);\n+\t\tif (resultArg.sameRegAndSVar(moveArg)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tSSAVar ssaVar = resultArg.getSVar();\n+\t\tif (ssaVar.isUsedInPhi()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tRegDebugInfoAttr debugInfo = resultArg.get(AType.REG_DEBUG_INFO);\n+\t\tfor (RegisterArg useArg : ssaVar.getUseList()) {\n+\t\t\tInsnNode useInsn = useArg.getParentInsn();\n+\t\t\tif (useInsn == null || !fromThisBlock(block, useInsn, i)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tRegDebugInfoAttr debugInfoAttr = useArg.get(AType.REG_DEBUG_INFO);\n+\t\t\tif (debugInfoAttr != null) {\n+\t\t\t\tdebugInfo = debugInfoAttr;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// all checks passed, execute inline\n+\t\tfor (RegisterArg useArg : new ArrayList<>(ssaVar.getUseList())) {\n+\t\t\tInsnNode useInsn = useArg.getParentInsn();\n+\t\t\tInsnArg replaceArg;\n+\t\t\tif (moveArg.isRegister()) {\n+\t\t\t\treplaceArg = ((RegisterArg) moveArg).duplicate(useArg.getInitType());\n+\t\t\t} else {\n+\t\t\t\treplaceArg = moveArg.duplicate();\n+\t\t\t}\n+\t\t\treplaceArg.copyAttributesFrom(useArg);\n+\t\t\tif (debugInfo != null) {\n+\t\t\t\treplaceArg.addAttr(debugInfo);\n+\t\t\t}\n+\t\t\tif (useInsn == null || !useInsn.replaceArg(useArg, replaceArg)) {\n+\t\t\t\tmth.addWarnComment(\"Failed to replace arg in insn: \" + useInsn);\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate static boolean fromThisBlock(BlockNode block, InsnNode insn, int curPos) {\n+\t\tList<InsnNode> list = block.getInstructions();\n+\t\tint size = list.size();\n+\t\tfor (int j = curPos; j < size; j++) {\n+\t\t\tif (list.get(j) == insn) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/ProcessVariables.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/ProcessVariables.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/ProcessVariables.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/ProcessVariables.java\n@@ -26,6 +26,7 @@\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.regions.loops.LoopRegion;\n import jadx.core.dex.visitors.AbstractVisitor;\n+import jadx.core.dex.visitors.regions.AbstractRegionVisitor;\n import jadx.core.dex.visitors.regions.DepthRegionTraversal;\n import jadx.core.dex.visitors.typeinference.TypeCompare;\n import jadx.core.dex.visitors.typeinference.TypeCompareEnum;\n@@ -41,6 +42,7 @@ public void visit(MethodNode mth) throws JadxException {\n \t\tif (mth.isNoCode() || mth.getSVars().isEmpty()) {\n \t\t\treturn;\n \t\t}\n+\t\tremoveUnusedResults(mth);\n \n \t\tList<CodeVar> codeVars = collectCodeVars(mth);\n \t\tif (codeVars.isEmpty()) {\n@@ -64,6 +66,24 @@ public void visit(MethodNode mth) throws JadxException {\n \t\t}\n \t}\n \n+\tprivate static void removeUnusedResults(MethodNode mth) {\n+\t\tDepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {\n+\t\t\t@Override\n+\t\t\tpublic void processBlock(MethodNode mth, IBlock container) {\n+\t\t\t\tfor (InsnNode insn : container.getInstructions()) {\n+\t\t\t\t\tRegisterArg resultArg = insn.getResult();\n+\t\t\t\t\tif (resultArg != null) {\n+\t\t\t\t\t\tSSAVar ssaVar = resultArg.getSVar();\n+\t\t\t\t\t\tif (ssaVar.getUseList().isEmpty() && insn.canRemoveResult()) {\n+\t\t\t\t\t\t\tinsn.setResult(null);\n+\t\t\t\t\t\t\tmth.removeSVar(ssaVar);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n \tprivate void checkCodeVars(MethodNode mth, List<CodeVar> codeVars) {\n \t\tint unknownTypesCount = 0;\n \t\tfor (CodeVar codeVar : codeVars) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestConstructorWithMoves.java b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestConstructorWithMoves.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestConstructorWithMoves.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestConstructorWithMoves.java\n@@ -0,0 +1,33 @@\n+package jadx.tests.integration.invoke;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestConstructorWithMoves extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tpublic boolean test() {\n+\t\t\t\tjava.lang.Boolean r5 = new java.lang.Boolean\n+\t\t\t\tr8 = r5\n+\t\t\t\tr5 = r8\n+\t\t\t\tr6 = r8\n+\t\t\t\tjava.lang.String r7 = \"test\"\n+\t\t\t\tr6.<init>(r7)\n+\t\t\t\tjava.lang.Boolean r5 = (java.lang.Boolean) r5\n+\t\t\t\tboolean r5 = r5.booleanValue()\n+\t\t\t\tr3 = r5\n+\t\t\t\treturn r3\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"return new Boolean(\\\"test\\\").booleanValue();\");\n+\t}\n+}",
    "output": "Fix inline move instructions to help process constructors"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n@@ -1,5 +1,9 @@\n package jadx.gui.ui.codearea;\n \n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n import javax.swing.*;\n \n import org.fife.ui.rsyntaxtextarea.RSyntaxDocument;\n@@ -38,9 +42,21 @@ public final class CodeArea extends AbstractCodeArea {\n \t\t}\n \n \t\tsetHyperlinksEnabled(true);\n-\t\tCodeLinkGenerator codeLinkProcessor = new CodeLinkGenerator(this);\n-\t\tsetLinkGenerator(codeLinkProcessor);\n-\t\taddHyperlinkListener(codeLinkProcessor);\n+\t\tsetLinkScanningMask(InputEvent.CTRL_DOWN_MASK);\n+\t\tCodeLinkGenerator codeLinkGenerator = new CodeLinkGenerator(this);\n+\t\tsetLinkGenerator(codeLinkGenerator);\n+\t\taddMouseListener(new MouseAdapter() {\n+\t\t\t@Override\n+\t\t\tpublic void mouseClicked(MouseEvent e) {\n+\t\t\t\tif (e.isControlDown()) {\n+\t\t\t\t\tint offs = viewToModel(e.getPoint());\n+\t\t\t\t\tJumpPosition jump = codeLinkGenerator.getJumpLinkAtOffset(CodeArea.this, offs);\n+\t\t\t\t\tif (jump != null) {\n+\t\t\t\t\t\tcontentPanel.getTabbedPane().codeJump(jump);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n \t}\n \n \t@Override\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeLinkGenerator.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeLinkGenerator.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeLinkGenerator.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeLinkGenerator.java\n@@ -3,52 +3,61 @@\n import java.util.Objects;\n \n import javax.swing.event.HyperlinkEvent;\n-import javax.swing.event.HyperlinkListener;\n+import javax.swing.text.BadLocationException;\n \n import org.fife.ui.rsyntaxtextarea.LinkGenerator;\n import org.fife.ui.rsyntaxtextarea.LinkGeneratorResult;\n import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;\n import org.fife.ui.rsyntaxtextarea.Token;\n+import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import jadx.gui.treemodel.JNode;\n-import jadx.gui.ui.ContentPanel;\n import jadx.gui.utils.JumpPosition;\n \n-public class CodeLinkGenerator implements LinkGenerator, HyperlinkListener {\n+public class CodeLinkGenerator implements LinkGenerator {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(CodeLinkGenerator.class);\n \n-\tprivate final ContentPanel contentPanel;\n \tprivate final CodeArea codeArea;\n \tprivate final JNode jNode;\n \n \tpublic CodeLinkGenerator(CodeArea codeArea) {\n-\t\tthis.contentPanel = codeArea.getContentPanel();\n \t\tthis.codeArea = codeArea;\n \t\tthis.jNode = codeArea.getNode();\n \t}\n \n+\t@Nullable\n+\tpublic JumpPosition getJumpLinkAtOffset(RSyntaxTextArea textArea, int offset) {\n+\t\ttry {\n+\t\t\tif (jNode.getCodeInfo() == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tint sourceOffset = getLinkSourceOffset(textArea, offset);\n+\t\t\tif (sourceOffset == -1) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn getJumpBySourceOffset(textArea, sourceOffset);\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"getJumpLinkAtOffset error\", e);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n \t@Override\n \tpublic LinkGeneratorResult isLinkAtOffset(RSyntaxTextArea textArea, int offset) {\n \t\ttry {\n \t\t\tif (jNode.getCodeInfo() == null) {\n \t\t\t\treturn null;\n \t\t\t}\n-\t\t\tToken token = textArea.modelToToken(offset);\n-\t\t\tint sourceOffset = codeArea.adjustOffsetForToken(token);\n+\t\t\tint sourceOffset = getLinkSourceOffset(textArea, offset);\n \t\t\tif (sourceOffset == -1) {\n \t\t\t\treturn null;\n \t\t\t}\n-\t\t\tfinal JumpPosition defPos = codeArea.getDefPosForNodeAtOffset(sourceOffset);\n+\t\t\tJumpPosition defPos = getJumpBySourceOffset(textArea, sourceOffset);\n \t\t\tif (defPos == null) {\n \t\t\t\treturn null;\n \t\t\t}\n-\t\t\tif (Objects.equals(defPos.getNode().getRootClass(), jNode)\n-\t\t\t\t\t&& defPos.getLine() == textArea.getLineOfOffset(sourceOffset) + 1) {\n-\t\t\t\t// ignore self jump\n-\t\t\t\treturn null;\n-\t\t\t}\n \t\t\treturn new LinkGeneratorResult() {\n \t\t\t\t@Override\n \t\t\t\tpublic HyperlinkEvent execute() {\n@@ -67,11 +76,22 @@ public int getSourceOffset() {\n \t\t}\n \t}\n \n-\t@Override\n-\tpublic void hyperlinkUpdate(HyperlinkEvent e) {\n-\t\tObject obj = e.getSource();\n-\t\tif (obj instanceof JumpPosition) {\n-\t\t\tcontentPanel.getTabbedPane().codeJump((JumpPosition) obj);\n+\tprivate int getLinkSourceOffset(RSyntaxTextArea textArea, int offset) {\n+\t\tToken token = textArea.modelToToken(offset);\n+\t\treturn codeArea.adjustOffsetForToken(token);\n+\t}\n+\n+\t@Nullable\n+\tprivate JumpPosition getJumpBySourceOffset(RSyntaxTextArea textArea, int sourceOffset) throws BadLocationException {\n+\t\tfinal JumpPosition defPos = codeArea.getDefPosForNodeAtOffset(sourceOffset);\n+\t\tif (defPos == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tif (Objects.equals(defPos.getNode().getRootClass(), jNode)\n+\t\t\t\t&& defPos.getLine() == textArea.getLineOfOffset(sourceOffset) + 1) {\n+\t\t\t// ignore self jump\n+\t\t\treturn null;\n \t\t}\n+\t\treturn defPos;\n \t}\n }",
    "output": "Fix workaround for link clicks in RSyntaxTextArea"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -45,7 +45,6 @@\n import jadx.core.utils.BlockInsnPair;\n import jadx.core.utils.InsnRemover;\n import jadx.core.utils.InsnUtils;\n-import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxException;\n \n import static jadx.core.utils.InsnUtils.checkInsnType;\n@@ -170,18 +169,9 @@ private boolean convertToEnum(ClassNode cls) {\n \t\t\t\t\t&& cls.root().getArgs().isRenameValid()) {\n \t\t\t\tfieldNode.getFieldInfo().setAlias(name);\n \t\t\t}\n-\t\t\tif (!co.getClassType().equals(cls.getClassInfo())) {\n-\t\t\t\t// enum contains additional methods\n-\t\t\t\tfor (ClassNode innerCls : cls.getInnerClasses()) {\n-\t\t\t\t\tprocessEnumInnerCls(co, enumField, innerCls);\n-\t\t\t\t}\n-\t\t\t}\n \t\t\tfieldNode.add(AFlag.DONT_GENERATE);\n+\t\t\tprocessConstructorInsn(cls, enumField, classInitMth, staticBlock);\n \t\t}\n-\n-\t\tList<InsnNode> constrInsns = Utils.collectionMap(attr.getFields(), EnumField::getConstrInsn);\n-\t\tInsnRemover.removeAllWithoutUnbind(staticBlock, constrInsns);\n-\n \t\tvaluesField.add(AFlag.DONT_GENERATE);\n \t\tInsnRemover.removeAllAndUnbind(classInitMth, staticBlock, toRemove);\n \t\tif (classInitMth.countInsns() == 0) {\n@@ -191,6 +181,28 @@ private boolean convertToEnum(ClassNode cls) {\n \t\treturn true;\n \t}\n \n+\tprivate void processConstructorInsn(ClassNode cls, EnumField enumField, MethodNode classInitMth, BlockNode staticBlock) {\n+\t\tConstructorInsn co = enumField.getConstrInsn();\n+\t\tClassInfo enumClsInfo = co.getClassType();\n+\t\tif (!enumClsInfo.equals(cls.getClassInfo())) {\n+\t\t\tClassNode enumCls = cls.root().resolveClass(enumClsInfo);\n+\t\t\tif (enumCls != null) {\n+\t\t\t\tprocessEnumCls(enumField, enumCls);\n+\t\t\t\tcls.addInlinedClass(enumCls);\n+\t\t\t}\n+\t\t}\n+\t\tList<RegisterArg> regs = new ArrayList<>();\n+\t\tco.getRegisterArgs(regs);\n+\t\tif (!regs.isEmpty()) {\n+\t\t\tcls.addWarnComment(\"Init of enum \" + enumField.getField().getName() + \" can be incorrect\");\n+\t\t}\n+\t\tMethodNode ctrMth = cls.dex().resolveMethod(co.getCallMth());\n+\t\tif (ctrMth != null) {\n+\t\t\tmarkArgsForSkip(ctrMth);\n+\t\t}\n+\t\tInsnRemover.removeWithoutUnbind(classInitMth, staticBlock, co);\n+\t}\n+\n \tprivate BlockInsnPair getValuesInitInsn(MethodNode classInitMth, FieldNode valuesField) {\n \t\tFieldInfo searchField = valuesField.getFieldInfo();\n \t\tfor (BlockNode blockNode : classInitMth.getBasicBlocks()) {\n@@ -288,18 +300,10 @@ private EnumField createEnumFieldByConstructor(ClassNode cls, FieldNode enumFiel\n \t\tif (!clsInfo.equals(cls.getClassInfo()) && !constrCls.getAccessFlags().isEnum()) {\n \t\t\treturn null;\n \t\t}\n-\t\tMethodInfo callMth = co.getCallMth();\n-\t\tMethodNode mth = cls.dex().resolveMethod(callMth);\n-\t\tif (mth == null) {\n+\t\tMethodNode ctrMth = cls.dex().resolveMethod(co.getCallMth());\n+\t\tif (ctrMth == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tList<RegisterArg> regs = new ArrayList<>();\n-\t\tco.getRegisterArgs(regs);\n-\t\tif (!regs.isEmpty()) {\n-\t\t\tcls.addWarnComment(\"Init of enum \" + enumFieldNode.getName() + \" can be incorrect\");\n-\t\t}\n-\n-\t\tmarkArgsForSkip(mth);\n \t\treturn new EnumField(enumFieldNode, co);\n \t}\n \n@@ -378,10 +382,7 @@ private boolean usesValuesField(MethodNode mth, FieldInfo valuesFieldInfo) {\n \t\treturn InsnUtils.searchInsn(mth, InsnType.SGET, insnTest) != null;\n \t}\n \n-\tprivate static void processEnumInnerCls(ConstructorInsn co, EnumField field, ClassNode innerCls) {\n-\t\tif (!innerCls.getClassInfo().equals(co.getClassType())) {\n-\t\t\treturn;\n-\t\t}\n+\tprivate static void processEnumCls(EnumField field, ClassNode innerCls) {\n \t\t// remove constructor, because it is anonymous class\n \t\tfor (MethodNode innerMth : innerCls.getMethods()) {\n \t\t\tif (innerMth.getAccessFlags().isConstructor()) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/InsnRemover.java b/jadx-core/src/main/java/jadx/core/utils/InsnRemover.java\n--- a/jadx-core/src/main/java/jadx/core/utils/InsnRemover.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/InsnRemover.java\n@@ -210,7 +210,9 @@ public static boolean removeWithoutUnbind(MethodNode mth, BlockNode block, InsnN\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}\n-\t\tmth.addWarnComment(\"Failed to remove instruction: \" + insn + \" from block: \" + block);\n+\t\tif (!insn.contains(AFlag.WRAPPED)) {\n+\t\t\tmth.addWarnComment(\"Failed to remove instruction: \" + insn + \" from block: \" + block);\n+\t\t}\n \t\treturn false;\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n@@ -38,6 +38,7 @@\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.utils.DebugChecks;\n+import jadx.core.utils.Utils;\n import jadx.core.utils.files.FileUtils;\n import jadx.core.xmlgen.ResourceStorage;\n import jadx.core.xmlgen.entry.ResourceEntry;\n@@ -262,7 +263,10 @@ protected void generateClsCode(ClassNode cls) {\n \tprotected void checkCode(ClassNode cls) {\n \t\tassertFalse(hasErrors(cls), \"Inconsistent cls: \" + cls);\n \t\tfor (MethodNode mthNode : cls.getMethods()) {\n-\t\t\tassertFalse(hasErrors(mthNode), \"Method with problems: \" + mthNode);\n+\t\t\tif (hasErrors(mthNode)) {\n+\t\t\t\tfail(\"Method with problems: \" + mthNode\n+\t\t\t\t\t\t+ \"\\n \" + Utils.listToString(mthNode.getAttributesStringsList(), \"\\n \"));\n+\t\t\t}\n \t\t}\n \t\tassertThat(cls.getCode().toString(), not(containsString(\"inconsistent\")));\n \t}",
    "output": "Fix correctly process extended enums if class is not inner"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/SkipMethodArgsAttr.java b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/SkipMethodArgsAttr.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/SkipMethodArgsAttr.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/SkipMethodArgsAttr.java\n@@ -44,7 +44,7 @@ public static boolean isSkip(@Nullable MethodNode mth, int argNum) {\n \tprivate final BitSet skipArgs;\n \n \tprivate SkipMethodArgsAttr(MethodNode mth) {\n-\t\tthis.skipArgs = new BitSet(mth.getArgRegs().size());\n+\t\tthis.skipArgs = new BitSet(mth.getMethodInfo().getArgsCount());\n \t}\n \n \tpublic void skip(int argNum) {",
    "output": "Fix resolve error in SkipMethodArgsAttr if method not yet loaded"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n@@ -100,6 +100,12 @@ private static void checkInsn(MethodNode mth, InsnNode insn, List<InsnNode> toRe\n \t\t\t\tconstArg = InsnArg.wrapArg(constGet);\n \t\t\t\tconstArg.setType(ArgType.STRING);\n \t\t\t}\n+\t\t} else if (insnType == InsnType.CONST_CLASS) {\n+\t\t\tif (sVar.isUsedInPhi()) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tconstArg = InsnArg.wrapArg(insn.copyWithoutResult());\n+\t\t\tconstArg.setType(ArgType.CLASS);\n \t\t} else {\n \t\t\treturn;\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -293,6 +293,12 @@ private EnumField createEnumFieldByConstructor(ClassNode cls, FieldNode enumFiel\n \t\tif (mth == null) {\n \t\t\treturn null;\n \t\t}\n+\t\tList<RegisterArg> regs = new ArrayList<>();\n+\t\tco.getRegisterArgs(regs);\n+\t\tif (!regs.isEmpty()) {\n+\t\t\tcls.addWarnComment(\"Init of enum \" + enumFieldNode.getName() + \" can be incorrect\");\n+\t\t}\n+\n \t\tmarkArgsForSkip(mth);\n \t\treturn new EnumField(enumFieldNode, co);\n \t}",
    "output": "Fix inline class constants to fix enum transform"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n@@ -48,6 +48,18 @@ protected ParserConstants() {\n \tprotected static final int TYPE_DIMENSION = 0x05;\n \t// The 'data' holds a complex number encoding a fraction of a container.\n \tprotected static final int TYPE_FRACTION = 0x06;\n+\n+\t/**\n+\t * The 'data' holds a dynamic reference, a reference to another resource table entry.\n+\t * See https://github.com/skylot/jadx/issues/919\n+\t */\n+\tprotected static final int TYPE_DYNAMIC_REFERENCE = 0x07;\n+\n+\t/**\n+\t * According to the sources of apktool this type seem to be related to themes\n+\t * See https://github.com/skylot/jadx/issues/919\n+\t */\n+\tprotected static final int TYPE_DYNAMIC_ATTRIBUTE = 0x08;\n \t// Beginning of integer flavors...\n \tprotected static final int TYPE_FIRST_INT = 0x10;\n \t// The 'data' is a raw integer value of the form n..n.\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java\n@@ -100,6 +100,7 @@ public String decodeValue(int dataType, int data) {\n \t\t\tcase TYPE_INT_COLOR_RGB4:\n \t\t\t\treturn String.format(\"#%03x\", data & 0xFFF);\n \n+\t\t\tcase TYPE_DYNAMIC_REFERENCE:\n \t\t\tcase TYPE_REFERENCE: {\n \t\t\t\tString ri = resMap.get(data);\n \t\t\t\tif (ri == null) {\n@@ -131,6 +132,9 @@ public String decodeValue(int dataType, int data) {\n \t\t\t\treturn decodeComplex(data, false);\n \t\t\tcase TYPE_FRACTION:\n \t\t\t\treturn decodeComplex(data, true);\n+\t\t\tcase TYPE_DYNAMIC_ATTRIBUTE:\n+\t\t\t\tLOG.warn(\"Data type TYPE_DYNAMIC_ATTRIBUTE not yet supported: {}\", data);\n+\t\t\t\treturn \"  TYPE_DYNAMIC_ATTRIBUTE: \" + data;\n \n \t\t\tdefault:\n \t\t\t\tLOG.warn(\"Unknown data type: 0x{} {}\", Integer.toHexString(dataType), data);",
    "output": "Fix XML parsing: handling of TYPE_DYNAMIC_REFERENCE entries (#919, PR #923)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java\n@@ -10,6 +10,7 @@\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n+import jadx.core.dex.instructions.args.SSAVar;\n import jadx.core.dex.nodes.BlockNode;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.utils.Utils;\n@@ -83,6 +84,20 @@ public RegisterArg removeArg(int index) {\n \t\treturn reg;\n \t}\n \n+\t@Nullable\n+\tpublic RegisterArg getArgBySsaVar(SSAVar ssaVar) {\n+\t\tif (getArgsCount() == 0) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tfor (InsnArg insnArg : getArguments()) {\n+\t\t\tRegisterArg reg = (RegisterArg) insnArg;\n+\t\t\tif (reg.getSVar() == ssaVar) {\n+\t\t\t\treturn reg;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \t@Override\n \tpublic boolean replaceArg(InsnArg from, InsnArg to) {\n \t\tif (!(from instanceof RegisterArg) || !(to instanceof RegisterArg)) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -43,6 +43,7 @@\n import jadx.core.dex.visitors.blocksmaker.BlockSplitter;\n import jadx.core.dex.visitors.ssa.SSATransform;\n import jadx.core.utils.BlockUtils;\n+import jadx.core.utils.InsnUtils;\n import jadx.core.utils.Utils;\n \n @JadxVisitor(\n@@ -74,29 +75,26 @@ public void visit(MethodNode mth) {\n \t\tif (Consts.DEBUG) {\n \t\t\tLOG.info(\"Start type inference in method: {}\", mth);\n \t\t}\n-\t\tboolean resolved = runTypePropagation(mth);\n-\t\tif (!resolved) {\n-\t\t\tboolean moveAdded = false;\n-\t\t\tfor (SSAVar var : new ArrayList<>(mth.getSVars())) {\n-\t\t\t\tif (tryInsertAdditionalInsn(mth, var)) {\n-\t\t\t\t\tmoveAdded = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (moveAdded) {\n-\t\t\t\tInitCodeVariables.rerun(mth);\n-\t\t\t\tresolved = runTypePropagation(mth);\n-\t\t\t}\n-\t\t\tif (!resolved) {\n-\t\t\t\tresolved = runMultiVariableSearch(mth);\n-\t\t\t}\n-\t\t}\n-\t\tif (resolved) {\n+\t\tif (resolveTypes(mth)) {\n \t\t\tfor (SSAVar var : new ArrayList<>(mth.getSVars())) {\n \t\t\t\tprocessIncompatiblePrimitives(mth, var);\n \t\t\t}\n \t\t}\n \t}\n \n+\tprivate boolean resolveTypes(MethodNode mth) {\n+\t\tif (runTypePropagation(mth)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (trySplitConstInsns(mth)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (tryInsertAdditionalMove(mth)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn runMultiVariableSearch(mth);\n+\t}\n+\n \t/**\n \t * Guess type from usage and try to set it to current variable\n \t * and all connected instructions with {@link TypeUpdate#apply(SSAVar, ArgType)}\n@@ -354,6 +352,64 @@ private boolean tryDeduceType(MethodNode mth, SSAVar var, @Nullable ArgType type\n \t\treturn false;\n \t}\n \n+\tprivate boolean trySplitConstInsns(MethodNode mth) {\n+\t\tboolean constSplitted = false;\n+\t\tfor (SSAVar var : new ArrayList<>(mth.getSVars())) {\n+\t\t\tif (checkAndSplitConstInsn(mth, var)) {\n+\t\t\t\tconstSplitted = true;\n+\t\t\t}\n+\t\t}\n+\t\tif (!constSplitted) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tInitCodeVariables.rerun(mth);\n+\t\treturn runTypePropagation(mth);\n+\t}\n+\n+\tprivate boolean checkAndSplitConstInsn(MethodNode mth, SSAVar var) {\n+\t\tif (var.getUsedInPhi().size() < 2) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tInsnNode assignInsn = var.getAssign().getAssignInsn();\n+\t\tInsnNode constInsn = InsnUtils.checkInsnType(assignInsn, InsnType.CONST);\n+\t\tif (constInsn == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tBlockNode blockNode = BlockUtils.getBlockByInsn(mth, constInsn);\n+\t\tif (blockNode == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// for every PHI make separate CONST insn\n+\t\tboolean first = true;\n+\t\tfor (PhiInsn phiInsn : var.getUsedInPhi()) {\n+\t\t\tif (first) {\n+\t\t\t\tfirst = false;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tInsnNode copyInsn = constInsn.copyWithNewSsaVar(mth);\n+\t\t\tcopyInsn.add(AFlag.SYNTHETIC);\n+\t\t\tBlockUtils.insertAfterInsn(blockNode, constInsn, copyInsn);\n+\n+\t\t\tRegisterArg phiArg = phiInsn.getArgBySsaVar(var);\n+\t\t\tphiInsn.replaceArg(phiArg, copyInsn.getResult().duplicate());\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate boolean tryInsertAdditionalMove(MethodNode mth) {\n+\t\tboolean moveAdded = false;\n+\t\tfor (SSAVar var : new ArrayList<>(mth.getSVars())) {\n+\t\t\tif (tryInsertAdditionalInsn(mth, var)) {\n+\t\t\t\tmoveAdded = true;\n+\t\t\t}\n+\t\t}\n+\t\tif (!moveAdded) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tInitCodeVariables.rerun(mth);\n+\t\treturn runTypePropagation(mth);\n+\t}\n+\n \t/**\n \t * Add MOVE instruction before PHI in bound blocks to make 'soft' type link.\n \t * This allows to use different types in blocks merged by PHI.\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -663,6 +663,19 @@ public static boolean replaceInsn(MethodNode mth, BlockNode block, InsnNode oldI\n \t\treturn false;\n \t}\n \n+\tpublic static boolean insertAfterInsn(BlockNode block, InsnNode insn, InsnNode newInsn) {\n+\t\tList<InsnNode> instructions = block.getInstructions();\n+\t\tint size = instructions.size();\n+\t\tfor (int i = 0; i < size; i++) {\n+\t\t\tInsnNode instruction = instructions.get(i);\n+\t\t\tif (instruction == insn) {\n+\t\t\t\tinstructions.add(i + 1, newInsn);\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tpublic static boolean replaceInsn(MethodNode mth, InsnNode oldInsn, InsnNode newInsn) {\n \t\tfor (BlockNode block : mth.getBasicBlocks()) {\n \t\t\tif (replaceInsn(mth, block, oldInsn, newInsn)) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver14.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver14.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver14.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver14.java\n@@ -0,0 +1,38 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestTypeResolver14 extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tpublic Date test() throws Exception {\n+\t\t\tDate date = null;\n+\t\t\tLong l = null;\n+\t\t\tCursor query = DBUtil.query(false, (CancellationSignal) null);\n+\t\t\ttry {\n+\t\t\t\tif (query.moveToFirst()) {\n+\t\t\t\t\tif (!query.isNull(0)) {\n+\t\t\t\t\t\tl = Long.valueOf(query.getLong(0));\n+\t\t\t\t\t}\n+\t\t\t\t\tdate = this.this$0.toDate(l);\n+\t\t\t\t}\n+\t\t\t\treturn date;\n+\t\t\t} finally {\n+\t\t\t\tquery.close();\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"? r2\");\n+\t}\n+}",
    "output": "Fix split CONST used in PHI to help type inference"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/PackageNode.java b/jadx-core/src/main/java/jadx/core/deobf/PackageNode.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/PackageNode.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/PackageNode.java\n@@ -31,14 +31,17 @@ public String getName() {\n \tpublic String getFullName() {\n \t\tif (cachedPackageFullName == null) {\n \t\t\tDeque<PackageNode> pp = getParentPackages();\n-\n-\t\t\tStringBuilder result = new StringBuilder();\n-\t\t\tresult.append(pp.pop().getName());\n-\t\t\twhile (!pp.isEmpty()) {\n-\t\t\t\tresult.append(SEPARATOR_CHAR);\n+\t\t\tif (pp.isEmpty()) {\n+\t\t\t\tcachedPackageFullName = \"\";\n+\t\t\t} else {\n+\t\t\t\tStringBuilder result = new StringBuilder();\n \t\t\t\tresult.append(pp.pop().getName());\n+\t\t\t\twhile (!pp.isEmpty()) {\n+\t\t\t\t\tresult.append(SEPARATOR_CHAR);\n+\t\t\t\t\tresult.append(pp.pop().getName());\n+\t\t\t\t}\n+\t\t\t\tcachedPackageFullName = result.toString();\n \t\t\t}\n-\t\t\tcachedPackageFullName = result.toString();\n \t\t}\n \t\treturn cachedPackageFullName;\n \t}",
    "output": "Fix resolve NPE when package is empty (if rename is disabled)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n@@ -15,6 +15,7 @@\n import jadx.core.dex.attributes.nodes.LoopLabelAttr;\n import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.instructions.SwitchNode;\n+import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.CodeVar;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.NamedArg;\n@@ -334,7 +335,7 @@ private void makeCatchBlock(CodeWriter code, ExceptionHandler handler) throws Co\n \t\t}\n \t\tcode.startLine(\"} catch (\");\n \t\tif (handler.isCatchAll()) {\n-\t\t\tcode.add(\"Throwable\");\n+\t\t\tuseClass(code, ArgType.THROWABLE);\n \t\t} else {\n \t\t\tIterator<ClassInfo> it = handler.getCatchTypes().iterator();\n \t\t\tif (it.hasNext()) {\n@@ -347,11 +348,15 @@ private void makeCatchBlock(CodeWriter code, ExceptionHandler handler) throws Co\n \t\t}\n \t\tcode.add(' ');\n \t\tInsnArg arg = handler.getArg();\n-\t\tif (arg instanceof RegisterArg) {\n+\t\tif (arg == null) {\n+\t\t\tcode.add(\"unknown\"); // throwing exception is too late at this point\n+\t\t} else if (arg instanceof RegisterArg) {\n \t\t\tRegisterArg reg = (RegisterArg) arg;\n \t\t\tcode.add(mgen.getNameGen().assignArg(reg.getSVar().getCodeVar()));\n \t\t} else if (arg instanceof NamedArg) {\n \t\t\tcode.add(mgen.getNameGen().assignNamedArg((NamedArg) arg));\n+\t\t} else {\n+\t\t\tthrow new JadxRuntimeException(\"Unexpected arg type in catch block: \" + arg + \", class: \" + arg.getClass().getSimpleName());\n \t\t}\n \t\tcode.add(\") {\");\n \t\tmakeRegionIndent(code, region);",
    "output": "Use correct class for Throwable, insert catch arg name if not defined"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -7,6 +7,7 @@\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Set;\n \n import org.jetbrains.annotations.Nullable;\n@@ -194,6 +195,10 @@ private void loadStaticValues(ClassDef cls, List<FieldNode> staticFields) throws\n \t\troot().getConstValues().processConstFields(this, staticFields);\n \t}\n \n+\t/**\n+\t * Class signature format:\n+\t * https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.9.1\n+\t */\n \tprivate void parseClassSignature() {\n \t\tSignatureParser sp = SignatureParser.fromNode(this);\n \t\tif (sp == null) {\n@@ -203,7 +208,7 @@ private void parseClassSignature() {\n \t\t\t// parse class generic map\n \t\t\tgenerics = sp.consumeGenericTypeParameters();\n \t\t\t// parse super class signature\n-\t\t\tsuperClass = sp.consumeType();\n+\t\t\tsuperClass = validateSuperCls(sp.consumeType(), superClass);\n \t\t\t// parse interfaces signatures\n \t\t\tfor (int i = 0; i < interfaces.size(); i++) {\n \t\t\t\tArgType type = sp.consumeType();\n@@ -218,6 +223,18 @@ private void parseClassSignature() {\n \t\t}\n \t}\n \n+\tprivate ArgType validateSuperCls(ArgType candidateType, ArgType currentType) {\n+\t\tif (!candidateType.isObject()) {\n+\t\t\tthis.addComment(\"Incorrect class signature, super class is not object: \" + SignatureParser.getSignature(this));\n+\t\t\treturn currentType;\n+\t\t}\n+\t\tif (Objects.equals(candidateType.getObject(), this.getClassInfo().getType().getObject())) {\n+\t\t\tthis.addComment(\"Incorrect class signature, super class is equals to this class: \" + SignatureParser.getSignature(this));\n+\t\t\treturn currentType;\n+\t\t}\n+\t\treturn candidateType;\n+\t}\n+\n \tprivate void setFieldsTypesFromSignature() {\n \t\tfor (FieldNode field : fields) {\n \t\t\ttry {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n@@ -33,14 +33,23 @@ public SignatureParser(String signature) {\n \t\tmark = 0;\n \t}\n \n-\t@SuppressWarnings(\"unchecked\")\n+\t@Nullable\n \tpublic static SignatureParser fromNode(IAttributeNode node) {\n+\t\tString signature = getSignature(node);\n+\t\tif (signature == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn new SignatureParser(signature);\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t@Nullable\n+\tpublic static String getSignature(IAttributeNode node) {\n \t\tAnnotation a = node.getAnnotation(Consts.DALVIK_SIGNATURE);\n \t\tif (a == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tString signature = mergeSignature((List<String>) a.getDefaultValue());\n-\t\treturn new SignatureParser(signature);\n+\t\treturn mergeSignature((List<String>) a.getDefaultValue());\n \t}\n \n \tprivate char next() {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/generics/TestClassSignature.java b/jadx-core/src/test/java/jadx/tests/integration/generics/TestClassSignature.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/generics/TestClassSignature.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/generics/TestClassSignature.java\n@@ -0,0 +1,23 @@\n+package jadx.tests.integration.generics;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestClassSignature extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tIncorrect class signature, super class is equals to this class: <T:Ljava/lang/Object;>Lgenerics/TestClassSignature<TT;>;\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"Incorrect class signature\")\n+\t\t\t\t.doesNotContain(\"StackOverflowError\");\n+\t}\n+}",
    "output": "Fix additional checks for class signature"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/SwitchNode.java b/jadx-core/src/main/java/jadx/core/dex/instructions/SwitchNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/SwitchNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/SwitchNode.java\n@@ -119,14 +119,23 @@ public InsnNode copy() {\n \tpublic String toString() {\n \t\tStringBuilder sb = new StringBuilder();\n \t\tsb.append(super.toString());\n-\t\tfor (int i = 0; i < targets.length; i++) {\n-\t\t\tsb.append(CodeWriter.NL);\n-\t\t\tsb.append(\"  case \").append(keys[i]);\n-\t\t\tsb.append(\": goto \").append(InsnUtils.formatOffset(targets[i]));\n-\t\t}\n-\t\tif (def != -1) {\n-\t\t\tsb.append(CodeWriter.NL);\n-\t\t\tsb.append(\"  default: goto \").append(InsnUtils.formatOffset(def));\n+\t\tif (targetBlocks == null) {\n+\t\t\tfor (int i = 0; i < keys.length; i++) {\n+\t\t\t\tsb.append(CodeWriter.NL);\n+\t\t\t\tsb.append(\"  case \").append(keys[i]).append(\": goto \").append(InsnUtils.formatOffset(targets[i]));\n+\t\t\t}\n+\t\t\tif (def != -1) {\n+\t\t\t\tsb.append(CodeWriter.NL);\n+\t\t\t\tsb.append(\"  default: goto \").append(InsnUtils.formatOffset(def));\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfor (int i = 0; i < keys.length; i++) {\n+\t\t\t\tsb.append(CodeWriter.NL);\n+\t\t\t\tsb.append(\"  case \").append(keys[i]).append(\": goto \").append(targetBlocks[i]);\n+\t\t\t}\n+\t\t\tif (def != -1) {\n+\t\t\t\tsb.append(CodeWriter.NL).append(\"  default: goto \").append(defTargetBlock);\n+\t\t\t}\n \t\t}\n \t\treturn sb.toString();\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -761,14 +761,30 @@ private BlockNode processSwitch(IRegion currentRegion, BlockNode block, SwitchNo\n \t\t\tout = calcPostDomOut(mth, block, mth.getExitBlocks());\n \t\t} else {\n \t\t\tBlockNode loopEnd = loop.getEnd();\n-\t\t\t// treat 'continue' as exit\n-\t\t\tout = calcPostDomOut(mth, block, loopEnd.getPredecessors());\n-\t\t\tif (out != null) {\n-\t\t\t\tinsertContinueInSwitch(block, out, loopEnd);\n+\t\t\tstack.addExit(loop.getStart());\n+\t\t\tif (stack.containsExit(block)\n+\t\t\t\t\t|| block == loopEnd\n+\t\t\t\t\t|| loopEnd.getPredecessors().contains(block)) {\n+\t\t\t\t// in exits or last insn in loop => no 'out' block\n+\t\t\t\tout = null;\n \t\t\t} else {\n-\t\t\t\t// no 'continue'\n-\t\t\t\tout = calcPostDomOut(mth, block, Collections.singletonList(loopEnd));\n+\t\t\t\t// treat 'continue' as exit\n+\t\t\t\tout = calcPostDomOut(mth, block, loopEnd.getPredecessors());\n+\t\t\t\tif (out != null) {\n+\t\t\t\t\tinsertContinueInSwitch(block, out, loopEnd);\n+\t\t\t\t} else {\n+\t\t\t\t\t// no 'continue'\n+\t\t\t\t\tout = calcPostDomOut(mth, block, Collections.singletonList(loopEnd));\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tif (out == loop.getStart()) {\n+\t\t\t\t// no other outs instead back edge to loop start\n+\t\t\t\tout = null;\n+\t\t\t}\n+\t\t}\n+\t\tif (out != null && processedBlocks.get(out.getId())) {\n+\t\t\t// out block already processed, prevent endless loop\n+\t\t\tthrow new JadxRuntimeException(\"Failed to find switch 'out' block\");\n \t\t}\n \n \t\tSwitchRegion sw = new SwitchRegion(currentRegion, block);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java\n--- a/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java\n@@ -21,6 +21,7 @@\n \n public class ErrorsCounter {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ErrorsCounter.class);\n+\tprivate static final boolean PRINT_MTH_SIZE = true;\n \n \tprivate final Set<IAttributeNode> errorNodes = new HashSet<>();\n \tprivate int errorsCount;\n@@ -40,6 +41,10 @@ private synchronized <N extends IDexNode & IAttributeNode> String addError(N nod\n \t\terrorsCount++;\n \n \t\tString msg = formatMsg(node, error);\n+\t\tif (PRINT_MTH_SIZE && node instanceof MethodNode) {\n+\t\t\tlong insnsCount = ((MethodNode) node).countInsns();\n+\t\t\tmsg = \"[\" + insnsCount + \"] \" + msg;\n+\t\t}\n \t\tif (e == null) {\n \t\t\tLOG.error(msg);\n \t\t} else if (e instanceof JadxOverflowException) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop2.java b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop2.java\n@@ -0,0 +1,34 @@\n+package jadx.tests.integration.switches;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestSwitchInLoop2 extends IntegrationTest {\n+\tpublic static class TestCls {\n+\t\tpublic boolean test() {\n+\t\t\twhile (true) {\n+\t\t\t\tswitch (call()) {\n+\t\t\t\t\tcase 0:\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\tcase 1:\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate int call() {\n+\t\t\treturn 0;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"while (true) {\")\n+\t\t\t\t.containsOne(\"switch (call()) {\");\n+\t}\n+}",
    "output": "Fix resolve some cases of switch in loop"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n@@ -58,15 +58,15 @@ private static void processBlocksTree(MethodNode mth) {\n \t\t\tclearBlocksState(mth);\n \t\t\tcomputeDominators(mth);\n \t\t}\n-\t\tmarkReturnBlocks(mth);\n+\t\tupdateExitBlocks(mth);\n \n \t\tint i = 0;\n \t\twhile (modifyBlocksTree(mth)) {\n \t\t\t// revert calculations\n \t\t\tclearBlocksState(mth);\n \t\t\t// recalculate dominators tree\n \t\t\tcomputeDominators(mth);\n-\t\t\tmarkReturnBlocks(mth);\n+\t\t\tupdateExitBlocks(mth);\n \n \t\t\tif (i++ > 100) {\n \t\t\t\tmth.addWarn(\"CFG modification limit reached, blocks count: \" + mth.getBasicBlocks().size());\n@@ -337,12 +337,33 @@ private static void computeBlockDF(MethodNode mth, BlockNode block) {\n \t\tblock.setDomFrontier(domFrontier);\n \t}\n \n-\tprivate static void markReturnBlocks(MethodNode mth) {\n+\tprivate static void updateExitBlocks(MethodNode mth) {\n \t\tmth.getExitBlocks().clear();\n \t\tmth.getBasicBlocks().forEach(block -> {\n-\t\t\tif (BlockUtils.checkLastInsnType(block, InsnType.RETURN)) {\n-\t\t\t\tblock.add(AFlag.RETURN);\n-\t\t\t\tmth.getExitBlocks().add(block);\n+\t\t\tboolean noSuccessors = block.getSuccessors().isEmpty();\n+\t\t\tboolean exitBlock = false;\n+\t\t\tInsnNode lastInsn = BlockUtils.getLastInsn(block);\n+\t\t\tif (lastInsn != null) {\n+\t\t\t\tInsnType insnType = lastInsn.getType();\n+\t\t\t\tif (insnType == InsnType.RETURN) {\n+\t\t\t\t\tblock.add(AFlag.RETURN);\n+\t\t\t\t\texitBlock = true;\n+\t\t\t\t\tif (!noSuccessors) {\n+\t\t\t\t\t\tthrow new JadxRuntimeException(\"Found a block after RETURN instruction: \" + lastInsn + \" in block: \" + block);\n+\t\t\t\t\t}\n+\t\t\t\t} else if (insnType == InsnType.THROW) {\n+\t\t\t\t\tif (noSuccessors) {\n+\t\t\t\t\t\texitBlock = true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (exitBlock) {\n+\t\t\t\tmth.addExitBlock(block);\n+\t\t\t} else if (noSuccessors\n+\t\t\t\t\t&& !mth.isVoidReturn()\n+\t\t\t\t\t&& !mth.isConstructor()) {\n+\t\t\t\tmth.addComment(\"JADX INFO: Unexpected exit block: \" + block\n+\t\t\t\t\t\t+ \". Expect last instruction to be RETURN or THROW, got: \" + lastInsn);\n \t\t\t}\n \t\t});\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithThrow.java b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithThrow.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithThrow.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithThrow.java\n@@ -0,0 +1,44 @@\n+package jadx.tests.integration.switches;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestSwitchWithThrow extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic int test(int i) {\n+\t\t\tif (i != 0) {\n+\t\t\t\tswitch (i % 4) {\n+\t\t\t\t\tcase 1:\n+\t\t\t\t\t\tthrow new IllegalStateException(\"1\");\n+\t\t\t\t\tcase 2:\n+\t\t\t\t\t\tthrow new IllegalStateException(\"2\");\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new IllegalStateException(\"Other\");\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tSystem.out.println(\"0\");\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(test(0)).isEqualTo(-1);\n+\t\t\t// TODO: implement 'invoke-custom' support\n+\t\t\t// assertThat(catchThrowable(() -> test(1)))\n+\t\t\t// .isInstanceOf(IllegalStateException.class).hasMessageContaining(\"1\");\n+\t\t\t// assertThat(catchThrowable(() -> test(3)))\n+\t\t\t// .isInstanceOf(IllegalStateException.class).hasMessageContaining(\"Other\");\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.contains(\"throw new IllegalStateException(\\\"1\\\");\");\n+\t}\n+}",
    "output": "Fix correct method exit blocks collection"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -1,10 +1,12 @@\n package jadx.core.dex.visitors;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n import java.util.Optional;\n+import java.util.function.Predicate;\n import java.util.stream.Collectors;\n \n import org.jetbrains.annotations.Nullable;\n@@ -23,6 +25,7 @@\n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.instructions.IndexInsnNode;\n import jadx.core.dex.instructions.InsnType;\n+import jadx.core.dex.instructions.InvokeNode;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.InsnWrapArg;\n@@ -36,12 +39,17 @@\n import jadx.core.dex.nodes.FieldNode;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n import jadx.core.utils.BlockInsnPair;\n import jadx.core.utils.InsnRemover;\n import jadx.core.utils.InsnUtils;\n import jadx.core.utils.exceptions.JadxException;\n \n+import static jadx.core.utils.InsnUtils.checkInsnType;\n+import static jadx.core.utils.InsnUtils.getSingleArg;\n+import static jadx.core.utils.InsnUtils.getWrappedInsn;\n+\n @JadxVisitor(\n \t\tname = \"EnumVisitor\",\n \t\tdesc = \"Restore enum classes\",\n@@ -50,6 +58,18 @@\n )\n public class EnumVisitor extends AbstractVisitor {\n \n+\tprivate MethodInfo enumValueOfMth;\n+\n+\t@Override\n+\tpublic void init(RootNode root) {\n+\t\tenumValueOfMth = MethodInfo.fromDetails(\n+\t\t\t\troot,\n+\t\t\t\tClassInfo.fromType(root, ArgType.ENUM),\n+\t\t\t\t\"valueOf\",\n+\t\t\t\tArrays.asList(ArgType.CLASS, ArgType.STRING),\n+\t\t\t\tArgType.ENUM);\n+\t}\n+\n \t@Override\n \tpublic boolean visit(ClassNode cls) throws JadxException {\n \t\tif (!convertToEnum(cls)) {\n@@ -163,7 +183,7 @@ private boolean convertToEnum(ClassNode cls) {\n \t\tif (classInitMth.countInsns() == 0) {\n \t\t\tclassInitMth.add(AFlag.DONT_GENERATE);\n \t\t}\n-\t\tremoveEnumMethods(cls, clsType);\n+\t\tremoveEnumMethods(cls, clsType, valuesField);\n \t\treturn true;\n \t}\n \n@@ -232,7 +252,7 @@ private EnumField processEnumFiledByRegister(ClassNode cls, RegisterArg arg, Lis\n \t\tif (ssaVar.getUseCount() == 1) {\n \t\t\treturn null;\n \t\t}\n-\t\tfinal InsnNode sputInsn = ssaVar.getUseList().get(0).getParentInsn();\n+\t\tInsnNode sputInsn = ssaVar.getUseList().get(0).getParentInsn();\n \t\tif (sputInsn == null || sputInsn.getType() != InsnType.SPUT) {\n \t\t\treturn null;\n \t\t}\n@@ -283,14 +303,14 @@ private InsnNode searchFieldPutInsn(ClassNode cls, BlockNode staticBlock, FieldN\n \t\treturn null;\n \t}\n \n-\t// TODO: detect these methods by analyzing method instructions\n-\tprivate void removeEnumMethods(ClassNode cls, ArgType clsType) {\n+\tprivate void removeEnumMethods(ClassNode cls, ArgType clsType, FieldNode valuesField) {\n \t\tString enumConstructor = \"<init>(Ljava/lang/String;I)V\";\n \t\tString enumConstructorAlt = \"<init>(Ljava/lang/String;)V\";\n-\t\tString valuesOfMethod = \"valueOf(Ljava/lang/String;)\" + TypeGen.signature(clsType);\n \t\tString valuesMethod = \"values()\" + TypeGen.signature(ArgType.array(clsType));\n \n-\t\t// remove synthetic methods\n+\t\tFieldInfo valuesFieldInfo = valuesField.getFieldInfo();\n+\n+\t\t// remove compiler generated methods\n \t\tfor (MethodNode mth : cls.getMethods()) {\n \t\t\tMethodInfo mi = mth.getMethodInfo();\n \t\t\tif (mi.isClassInit()) {\n@@ -303,12 +323,33 @@ private void removeEnumMethods(ClassNode cls, ArgType clsType) {\n \t\t\t\t\t\t|| shortId.equals(enumConstructorAlt)) {\n \t\t\t\t\tmth.add(AFlag.DONT_GENERATE);\n \t\t\t\t}\n-\t\t\t} else if (shortId.equals(valuesMethod) || shortId.equals(valuesOfMethod)) {\n+\t\t\t} else if (shortId.equals(valuesMethod)\n+\t\t\t\t\t|| usesValuesField(mth, valuesFieldInfo)\n+\t\t\t\t\t|| simpleValueOfMth(mth, clsType)) {\n \t\t\t\tmth.add(AFlag.DONT_GENERATE);\n \t\t\t}\n \t\t}\n \t}\n \n+\tprivate boolean simpleValueOfMth(MethodNode mth, ArgType clsType) {\n+\t\tInsnNode returnInsn = InsnUtils.searchSingleReturnInsn(mth, insn -> insn.getArgsCount() == 1);\n+\t\tif (returnInsn == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tInsnNode wrappedInsn = getWrappedInsn(getSingleArg(returnInsn));\n+\t\tIndexInsnNode castInsn = (IndexInsnNode) checkInsnType(wrappedInsn, InsnType.CHECK_CAST);\n+\t\tif (castInsn != null && Objects.equals(castInsn.getIndex(), clsType)) {\n+\t\t\tInvokeNode invokeInsn = (InvokeNode) checkInsnType(getWrappedInsn(getSingleArg(castInsn)), InsnType.INVOKE);\n+\t\t\treturn invokeInsn != null && invokeInsn.getCallMth().equals(enumValueOfMth);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprivate boolean usesValuesField(MethodNode mth, FieldInfo valuesFieldInfo) {\n+\t\tPredicate<InsnNode> insnTest = insn -> Objects.equals(((IndexInsnNode) insn).getIndex(), valuesFieldInfo);\n+\t\treturn InsnUtils.searchInsn(mth, InsnType.SGET, insnTest) != null;\n+\t}\n+\n \tprivate static void processEnumInnerCls(ConstructorInsn co, EnumField field, ClassNode innerCls) {\n \t\tif (!innerCls.getClassInfo().equals(co.getClassType())) {\n \t\t\treturn;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/InsnUtils.java b/jadx-core/src/main/java/jadx/core/utils/InsnUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/InsnUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/InsnUtils.java\n@@ -1,5 +1,7 @@\n package jadx.core.utils;\n \n+import java.util.function.Predicate;\n+\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -15,9 +17,11 @@\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.InsnWrapArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n+import jadx.core.dex.nodes.BlockNode;\n import jadx.core.dex.nodes.DexNode;\n import jadx.core.dex.nodes.FieldNode;\n import jadx.core.dex.nodes.InsnNode;\n+import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.parser.FieldInitAttr;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n@@ -121,4 +125,72 @@ public static Object getConstValueByInsn(DexNode dex, InsnNode insn) {\n \t\t\t\treturn null;\n \t\t}\n \t}\n+\n+\t@Nullable\n+\tpublic static InsnNode searchSingleReturnInsn(MethodNode mth, Predicate<InsnNode> test) {\n+\t\tif (!mth.isNoCode() && mth.getExitBlocks().size() == 1) {\n+\t\t\treturn searchInsn(mth, InsnType.RETURN, test);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Search instruction of specific type and condition in method.\n+\t * This method support inlined instructions.\n+\t */\n+\t@Nullable\n+\tpublic static InsnNode searchInsn(MethodNode mth, InsnType insnType, Predicate<InsnNode> test) {\n+\t\tif (mth.isNoCode()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tfor (BlockNode block : mth.getBasicBlocks()) {\n+\t\t\tfor (InsnNode insn : block.getInstructions()) {\n+\t\t\t\tInsnNode foundInsn = recursiveInsnCheck(insn, insnType, test);\n+\t\t\t\tif (foundInsn != null) {\n+\t\t\t\t\treturn foundInsn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate static InsnNode recursiveInsnCheck(InsnNode insn, InsnType insnType, Predicate<InsnNode> test) {\n+\t\tif (insn.getType() == insnType && test.test(insn)) {\n+\t\t\treturn insn;\n+\t\t}\n+\t\tfor (InsnArg arg : insn.getArguments()) {\n+\t\t\tif (arg.isInsnWrap()) {\n+\t\t\t\tInsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();\n+\t\t\t\tInsnNode foundInsn = recursiveInsnCheck(wrapInsn, insnType, test);\n+\t\t\t\tif (foundInsn != null) {\n+\t\t\t\t\treturn foundInsn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t@Nullable\n+\tpublic static InsnArg getSingleArg(InsnNode insn) {\n+\t\tif (insn != null && insn.getArgsCount() == 1) {\n+\t\t\treturn insn.getArg(0);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t@Nullable\n+\tpublic static InsnNode checkInsnType(InsnNode insn, InsnType insnType) {\n+\t\tif (insn != null && insn.getType() == insnType) {\n+\t\t\treturn insn;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t@Nullable\n+\tpublic static InsnNode getWrappedInsn(InsnArg arg) {\n+\t\tif (arg != null && arg.isInsnWrap()) {\n+\t\t\treturn ((InsnWrapArg) arg).getWrapInsn();\n+\t\t}\n+\t\treturn null;\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumObfuscated.java b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumObfuscated.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumObfuscated.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumObfuscated.java\n@@ -0,0 +1,49 @@\n+package jadx.tests.integration.enums;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestEnumObfuscated extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tpublic enum TestEnumObfuscated {\n+\t\t\tprivate static final synthetic TestEnumObfuscated[] $VLS = {ONE, TWO};\n+\t\t\tpublic static final TestEnumObfuscated ONE = new TestEnumObfuscated(\"ONE\", 0, 1);\n+\t\t\tpublic static final TestEnumObfuscated TWO = new TestEnumObfuscated(\"TWO\", 1, 2);\n+\t\t\tprivate final int num;\n+\n+\t\t\tprivate TestEnumObfuscated(String str, int i, int i2) {\n+\t\t\t\tsuper(str, i);\n+\t\t\t\tthis.num = i2;\n+\t\t\t}\n+\n+\t\t\tpublic static TestEnumObfuscated vo(String str) {\n+\t\t\t\treturn (TestEnumObfuscated) Enum.valueOf(TestEnumObfuscated.class, str);\n+\t\t\t}\n+\n+\t\t\tpublic static TestEnumObfuscated[] vs() {\n+\t\t\t\treturn (TestEnumObfuscated[]) $VLS.clone();\n+\t\t\t}\n+\n+\t\t\tpublic synthetic int getNum() {\n+\t\t\t\treturn this.num;\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmali();\n+\t\tassertThat(cls)\n+\t\t\t\t.code()\n+\t\t\t\t.doesNotContain(\"$VLS\")\n+\t\t\t\t.doesNotContain(\"vo(\")\n+\t\t\t\t.doesNotContain(\"vs(\")\n+\t\t\t\t.containsOne(\"int getNum() {\");\n+\t}\n+}",
    "output": "Remove enum methods after instructions check"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -303,9 +303,7 @@ private void removeEnumMethods(ClassNode cls, ArgType clsType) {\n \t\t\t\t\t\t|| shortId.equals(enumConstructorAlt)) {\n \t\t\t\t\tmth.add(AFlag.DONT_GENERATE);\n \t\t\t\t}\n-\t\t\t} else if (isSynthetic\n-\t\t\t\t\t|| shortId.equals(valuesMethod)\n-\t\t\t\t\t|| shortId.equals(valuesOfMethod)) {\n+\t\t\t} else if (shortId.equals(valuesMethod) || shortId.equals(valuesOfMethod)) {\n \t\t\t\tmth.add(AFlag.DONT_GENERATE);\n \t\t\t}\n \t\t}",
    "output": "Fix don't remove synthetic methods from enum"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Jadx.java b/jadx-core/src/main/java/jadx/core/Jadx.java\n--- a/jadx-core/src/main/java/jadx/core/Jadx.java\n+++ b/jadx-core/src/main/java/jadx/core/Jadx.java\n@@ -11,28 +11,7 @@\n import org.slf4j.LoggerFactory;\n \n import jadx.api.JadxArgs;\n-import jadx.core.dex.visitors.AttachMethodDetails;\n-import jadx.core.dex.visitors.ClassModifier;\n-import jadx.core.dex.visitors.ConstInlineVisitor;\n-import jadx.core.dex.visitors.ConstructorVisitor;\n-import jadx.core.dex.visitors.DeboxingVisitor;\n-import jadx.core.dex.visitors.DependencyCollector;\n-import jadx.core.dex.visitors.DotGraphVisitor;\n-import jadx.core.dex.visitors.EnumVisitor;\n-import jadx.core.dex.visitors.ExtractFieldInit;\n-import jadx.core.dex.visitors.FallbackModeVisitor;\n-import jadx.core.dex.visitors.FixAccessModifiers;\n-import jadx.core.dex.visitors.IDexTreeVisitor;\n-import jadx.core.dex.visitors.InitCodeVariables;\n-import jadx.core.dex.visitors.MarkFinallyVisitor;\n-import jadx.core.dex.visitors.MethodInlineVisitor;\n-import jadx.core.dex.visitors.MethodInvokeVisitor;\n-import jadx.core.dex.visitors.ModVisitor;\n-import jadx.core.dex.visitors.PrepareForCodeGen;\n-import jadx.core.dex.visitors.ProcessAnonymous;\n-import jadx.core.dex.visitors.ReSugarCode;\n-import jadx.core.dex.visitors.RenameVisitor;\n-import jadx.core.dex.visitors.SimplifyVisitor;\n+import jadx.core.dex.visitors.*;\n import jadx.core.dex.visitors.blocksmaker.BlockExceptionHandler;\n import jadx.core.dex.visitors.blocksmaker.BlockFinish;\n import jadx.core.dex.visitors.blocksmaker.BlockProcessor;\n@@ -71,6 +50,7 @@ public static List<IDexTreeVisitor> getPassesList(JadxArgs args) {\n \t\t\t\tpasses.add(new DebugInfoParseVisitor());\n \t\t\t}\n \n+\t\t\tpasses.add(new FindSuperUsageVisitor());\n \t\t\tpasses.add(new BlockSplitter());\n \t\t\tif (args.isRawCFGOutput()) {\n \t\t\t\tpasses.add(DotGraphVisitor.dumpRaw());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n@@ -33,6 +33,7 @@ public enum AFlag {\n \tANONYMOUS_CLASS,\n \n \tTHIS,\n+\tSUPER,\n \n \t/**\n \t * RegisterArg attribute for method arguments\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n@@ -11,6 +11,7 @@\n \n public class RegisterArg extends InsnArg implements Named {\n \tpublic static final String THIS_ARG_NAME = \"this\";\n+\tpublic static final String SUPER_ARG_NAME = \"super\";\n \n \tprotected final int regNum;\n \t// not null after SSATransform pass\n@@ -87,6 +88,9 @@ public void add(AFlag flag) {\n \n \t@Override\n \tpublic String getName() {\n+\t\tif (isSuper()) {\n+\t\t\treturn SUPER_ARG_NAME;\n+\t\t}\n \t\tif (isThis()) {\n \t\t\treturn THIS_ARG_NAME;\n \t\t}\n@@ -96,6 +100,10 @@ public String getName() {\n \t\treturn sVar.getName();\n \t}\n \n+\tprivate boolean isSuper() {\n+\t\treturn contains(AFlag.SUPER);\n+\t}\n+\n \t@Override\n \tpublic void setName(String name) {\n \t\tif (sVar != null && name != null) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/FindSuperUsageVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/FindSuperUsageVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/FindSuperUsageVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/FindSuperUsageVisitor.java\n@@ -0,0 +1,49 @@\n+package jadx.core.dex.visitors;\n+\n+import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.instructions.args.InsnArg;\n+import jadx.core.dex.instructions.args.RegisterArg;\n+import jadx.core.dex.nodes.InsnNode;\n+import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.dex.visitors.blocksmaker.BlockSplitter;\n+import jadx.core.utils.exceptions.JadxException;\n+\n+@JadxVisitor(\n+\t\tname = \"FindSuperUsageVisitor\",\n+\t\tdesc = \"Finds variables where a member of the super class is used and marks them.\",\n+\t\trunBefore = BlockSplitter.class\n+)\n+public class FindSuperUsageVisitor extends AbstractVisitor {\n+\n+\t@Override\n+\tpublic void visit(MethodNode mth) throws JadxException {\n+\t\tif (mth.isNoCode()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tprocess(mth);\n+\t}\n+\n+\tprivate static void process(MethodNode methodNode) {\n+\t\tArgType superClass = methodNode.getParentClass().getSuperClass();\n+\t\tif (superClass == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\tString superClassName = superClass.getObject();\n+\t\tif (superClassName.equals(\"java.lang.Object\")) {\n+\t\t\treturn;\n+\t\t}\n+\t\tfor (InsnNode instruction : methodNode.getInstructions()) {\n+\t\t\tif (instruction != null) {\n+\t\t\t\tfor (InsnArg argument : instruction.getArguments()) {\n+\t\t\t\t\tif (argument.isRegister()) {\n+\t\t\t\t\t\tArgType argumentType = ((RegisterArg) argument).getInitType();\n+\t\t\t\t\t\tif (argumentType.isObject() && argumentType.getObject().equals(superClassName)) {\n+\t\t\t\t\t\t\targument.add(AFlag.SUPER);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestShadowingSuperMember.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestShadowingSuperMember.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestShadowingSuperMember.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestShadowingSuperMember.java\n@@ -0,0 +1,47 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestShadowingSuperMember extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\n+\t\tpublic class C {\n+\t\t\tpublic C(String s) {\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic class A {\n+\t\t\tpublic int A00;\n+\t\t\tpublic A(String s) {\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic class B extends A {\n+\t\t\tpublic C A00;\n+\t\t\tpublic B(String str) {\n+\t\t\t\tsuper(str);\n+\t\t\t}\n+\n+\t\t\tpublic int add(int b) {\n+\t\t\t\treturn super.A00 + b;\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tallowWarnInCode();\n+\t\tClassNode cls = getClassNodeFromSmaliFiles(\"B\");\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"return super.A00 + \"));\n+\t}\n+}",
    "output": "Use `super` instead `this` when `super` member is shadowed"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n@@ -174,15 +174,24 @@ private TypeCompareEnum compareObjects(ArgType first, ArgType second) {\n \t\t\t\t// both wildcards\n \t\t\t\treturn compareWildcardTypes(first, second);\n \t\t\t}\n-\t\t\t// compare generics arrays\n \t\t\tArgType[] firstGenericTypes = first.getGenericTypes();\n \t\t\tArgType[] secondGenericTypes = second.getGenericTypes();\n-\t\t\tint len = firstGenericTypes.length;\n-\t\t\tif (len == secondGenericTypes.length) {\n-\t\t\t\tfor (int i = 0; i < len; i++) {\n-\t\t\t\t\tTypeCompareEnum res = compareTypes(firstGenericTypes[i], secondGenericTypes[i]);\n-\t\t\t\t\tif (res != EQUAL) {\n-\t\t\t\t\t\treturn res;\n+\t\t\tif (firstGenericTypes == null || secondGenericTypes == null) {\n+\t\t\t\t// check outer types\n+\t\t\t\tArgType firstOuterType = first.getOuterType();\n+\t\t\t\tArgType secondOuterType = second.getOuterType();\n+\t\t\t\tif (firstOuterType != null && secondOuterType != null) {\n+\t\t\t\t\treturn compareTypes(firstOuterType, secondOuterType);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// compare generics arrays\n+\t\t\t\tint len = firstGenericTypes.length;\n+\t\t\t\tif (len == secondGenericTypes.length) {\n+\t\t\t\t\tfor (int i = 0; i < len; i++) {\n+\t\t\t\t\t\tTypeCompareEnum res = compareTypes(firstGenericTypes[i], secondGenericTypes[i]);\n+\t\t\t\t\t\tif (res != EQUAL) {\n+\t\t\t\t\t\t\treturn res;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java b/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n--- a/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n+++ b/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n@@ -155,6 +155,16 @@ public void compareGenericTypesNYI() {\n \t\tcheck(vType, ArgType.STRING, TypeCompareEnum.CONFLICT);\n \t}\n \n+\t@Test\n+\tpublic void compareOuterGenerics() {\n+\t\tArgType hashMapType = object(\"java.util.HashMap\");\n+\t\tArgType innerEntrySetType = object(\"EntrySet\");\n+\t\tArgType firstInstance = ArgType.outerGeneric(generic(hashMapType, STRING, STRING), innerEntrySetType);\n+\t\tArgType secondInstance = ArgType.outerGeneric(generic(hashMapType, OBJECT, OBJECT), innerEntrySetType);\n+\n+\t\tcheck(firstInstance, secondInstance, TypeCompareEnum.NARROW);\n+\t}\n+\n \tprivate void firstIsNarrow(ArgType first, ArgType second) {\n \t\tcheck(first, second, TypeCompareEnum.NARROW);\n \t}",
    "output": "Fix resolve NPE while compare outer generic types"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -176,6 +176,12 @@ public ClassNode resolveClass(ClassInfo clsInfo) {\n \n \t@Nullable\n \tpublic ClassNode resolveClass(ArgType clsType) {\n+\t\tif (!clsType.isTypeKnown() || clsType.isGenericType()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tif (clsType.getWildcardBound() == ArgType.WildcardBound.UNBOUND) {\n+\t\t\treturn null;\n+\t\t}\n \t\tif (clsType.isGeneric()) {\n \t\t\tclsType = ArgType.object(clsType.getObject());\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/utils/MethodUtils.java\n@@ -68,7 +68,7 @@ public ArgType getMethodGenericReturnType(BaseInvokeNode invokeNode) {\n \t}\n \n \tpublic boolean processMethodArgsOverloaded(ArgType startCls, MethodInfo mthInfo, @Nullable List<IMethodDetails> collectedMths) {\n-\t\tif (startCls == null) {\n+\t\tif (startCls == null || !startCls.isObject()) {\n \t\t\treturn false;\n \t\t}\n \t\tboolean isMthConstructor = mthInfo.isConstructor() || mthInfo.isClassInit();",
    "output": "Fix class resolving issues"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java b/jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java\n@@ -26,20 +26,22 @@ public ClassInfo putCls(ClassInfo cls) {\n \t\t}\n \t}\n \n-\tprivate int generateMethodLookupId(DexNode dex, int mthId) {\n+\tprivate static int generateMethodLookupId(DexNode dex, int mthId) {\n \t\treturn dex.getDexId() << 16 | mthId;\n \t}\n \n \tpublic MethodInfo getMethod(DexNode dex, int mtdId) {\n-\t\treturn methods.get(generateMethodLookupId(dex, mtdId));\n+\t\tsynchronized (methods) {\n+\t\t\treturn methods.get(generateMethodLookupId(dex, mtdId));\n+\t\t}\n \t}\n \n \tpublic MethodInfo putMethod(DexNode dex, int mthId, MethodInfo methodInfo) {\n \t\tsynchronized (methods) {\n \t\t\tMethodInfo uniqueMethodInfo = putMethod(methodInfo);\n \t\t\tMethodInfo prev = methods.put(generateMethodLookupId(dex, mthId), uniqueMethodInfo);\n-\t\t\tif (prev != null) {\n-\t\t\t\tthrow new JadxRuntimeException(\"Method info already added: \" + methodInfo);\n+\t\t\tif (prev != null && prev != uniqueMethodInfo) {\n+\t\t\t\tthrow new JadxRuntimeException(\"Method lookup id collision: \" + methodInfo + \", \" + prev + \", \" + uniqueMethodInfo);\n \t\t\t}\n \t\t\treturn uniqueMethodInfo;\n \t\t}",
    "output": "Fix method info cache error"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n@@ -200,13 +200,25 @@ private void replaceConstsInAnnotationForAttrNode(ClassNode parentCls, AttrNode\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tfor (Map.Entry<String, Object> entry : annotation.getValues().entrySet()) {\n-\t\t\t\tObject value = entry.getValue();\n-\t\t\t\tFieldNode constField = parentCls.getConstField(value);\n-\t\t\t\tif (constField != null) {\n-\t\t\t\t\tentry.setValue(constField.getFieldInfo());\n-\t\t\t\t}\n+\t\t\t\tentry.setValue(replaceConstValue(parentCls, entry.getValue()));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+\tprivate Object replaceConstValue(ClassNode parentCls, @Nullable Object value) {\n+\t\tif (value instanceof List) {\n+\t\t\tList listVal = (List) value;\n+\t\t\tif (!listVal.isEmpty()) {\n+\t\t\t\tlistVal.replaceAll(v -> replaceConstValue(parentCls, v));\n \t\t\t}\n+\t\t\treturn listVal;\n+\t\t}\n+\t\tFieldNode constField = parentCls.getConstField(value);\n+\t\tif (constField != null) {\n+\t\t\treturn constField.getFieldInfo();\n \t\t}\n+\t\treturn value;\n \t}\n \n \tprivate static void replaceConst(MethodNode mth, ClassNode parentClass, BlockNode block, int i, InsnNode insn) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inner/TestReplaceConstsInAnnotations2.java b/jadx-core/src/test/java/jadx/tests/integration/inner/TestReplaceConstsInAnnotations2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inner/TestReplaceConstsInAnnotations2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestReplaceConstsInAnnotations2.java\n@@ -0,0 +1,44 @@\n+package jadx.tests.integration.inner;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestReplaceConstsInAnnotations2 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\t@Target(ElementType.TYPE)\n+\t\t@Retention(RetentionPolicy.RUNTIME)\n+\t\tpublic @interface A {\n+\t\t\tint[] value();\n+\t\t}\n+\n+\t\t@A(C.INT_CONST)\n+\t\tpublic static class C {\n+\t\t\tpublic static final int INT_CONST = 23412342;\n+\t\t}\n+\n+\t\t@A({ C.INT_CONST, C2.INT_CONST })\n+\t\tpublic static class C2 {\n+\t\t\tpublic static final int INT_CONST = 34563456;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t// .containsOne(\"@A(C.INT_CONST)\") // TODO: remove brackets for single element\n+\t\t\t\t.containsOne(\"@A({C.INT_CONST}\")\n+\t\t\t\t.containsOne(\"@A({C.INT_CONST, C2.INT_CONST})\")\n+\t\t\t\t.containsOne(\"23412342\")\n+\t\t\t\t.containsOne(\"34563456\");\n+\t}\n+}",
    "output": "Fix replace constants for arrays in annotations"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/JNodeCache.java b/jadx-gui/src/main/java/jadx/gui/utils/JNodeCache.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/JNodeCache.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/JNodeCache.java\n@@ -1,7 +1,7 @@\n package jadx.gui.utils;\n \n-import java.util.HashMap;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import jadx.api.JavaClass;\n import jadx.api.JavaField;\n@@ -15,7 +15,7 @@\n \n public class JNodeCache {\n \n-\tprivate final Map<JavaNode, JNode> cache = new HashMap<>();\n+\tprivate final Map<JavaNode, JNode> cache = new ConcurrentHashMap<>();\n \n \tpublic JNode makeFrom(JavaNode javaNode) {\n \t\tif (javaNode == null) {",
    "output": "Fix concurrent access may cause an java.lang.ClassCastException in JNodeCache"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n@@ -169,7 +169,12 @@ private TypeCompareEnum compareObjects(ArgType first, ArgType second) {\n \t\t\tif (firstGeneric != secondGeneric) {\n \t\t\t\treturn firstGeneric ? NARROW_BY_GENERIC : WIDER_BY_GENERIC;\n \t\t\t}\n-\t\t\t// both generics on same object, compare generics arrays\n+\t\t\t// both generics on same object\n+\t\t\tif (first.getWildcardBound() != null && second.getWildcardBound() != null) {\n+\t\t\t\t// both wildcards\n+\t\t\t\treturn compareWildcardTypes(first, second);\n+\t\t\t}\n+\t\t\t// compare generics arrays\n \t\t\tArgType[] firstGenericTypes = first.getGenericTypes();\n \t\t\tArgType[] secondGenericTypes = second.getGenericTypes();\n \t\t\tint len = firstGenericTypes.length;\n@@ -198,6 +203,22 @@ private TypeCompareEnum compareObjects(ArgType first, ArgType second) {\n \t\treturn TypeCompareEnum.CONFLICT;\n \t}\n \n+\tprivate TypeCompareEnum compareWildcardTypes(ArgType first, ArgType second) {\n+\t\tWildcardBound firstWildcardBound = first.getWildcardBound();\n+\t\tWildcardBound secondWildcardBound = second.getWildcardBound();\n+\t\tif (firstWildcardBound == WildcardBound.UNBOUND) {\n+\t\t\treturn WIDER;\n+\t\t}\n+\t\tif (secondWildcardBound == WildcardBound.UNBOUND) {\n+\t\t\treturn NARROW;\n+\t\t}\n+\t\tTypeCompareEnum wildcardCompare = compareTypes(first.getWildcardType(), second.getWildcardType());\n+\t\tif (firstWildcardBound == secondWildcardBound) {\n+\t\t\treturn wildcardCompare;\n+\t\t}\n+\t\treturn CONFLICT;\n+\t}\n+\n \tprivate TypeCompareEnum compareGenericTypeWithObject(ArgType genericType, ArgType objType) {\n \t\tList<ArgType> extendTypes = genericType.getExtendTypes();\n \t\tif (extendTypes == null || extendTypes.isEmpty()) {\n\ndiff --git a/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java b/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n--- a/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n+++ b/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n@@ -12,6 +12,7 @@\n import jadx.NotYetImplementedExtension;\n import jadx.api.JadxArgs;\n import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.instructions.args.ArgType.WildcardBound;\n import jadx.core.dex.nodes.RootNode;\n \n import static jadx.core.dex.instructions.args.ArgType.BOOLEAN;\n@@ -28,6 +29,7 @@\n import static jadx.core.dex.instructions.args.ArgType.UNKNOWN_OBJECT;\n import static jadx.core.dex.instructions.args.ArgType.array;\n import static jadx.core.dex.instructions.args.ArgType.generic;\n+import static jadx.core.dex.instructions.args.ArgType.object;\n import static jadx.core.dex.instructions.args.ArgType.wildcard;\n import static org.assertj.core.api.Assertions.assertThat;\n \n@@ -83,7 +85,7 @@ public void compareArrays() {\n \n \t\tcheck(array(OBJECT), array(INT), TypeCompareEnum.CONFLICT);\n \n-\t\tArgType integerType = ArgType.object(\"java.lang.Integer\");\n+\t\tArgType integerType = object(\"java.lang.Integer\");\n \t\tcheck(array(OBJECT), array(integerType), TypeCompareEnum.WIDER);\n \t\tcheck(array(INT), array(integerType), TypeCompareEnum.CONFLICT);\n \t\tcheck(array(INT), array(INT), TypeCompareEnum.EQUAL);\n@@ -95,8 +97,8 @@ public void compareArrays() {\n \n \t@Test\n \tpublic void compareGenerics() {\n-\t\tArgType mapCls = ArgType.object(\"java.util.Map\");\n-\t\tArgType setCls = ArgType.object(\"java.util.Set\");\n+\t\tArgType mapCls = object(\"java.util.Map\");\n+\t\tArgType setCls = object(\"java.util.Set\");\n \n \t\tArgType keyType = ArgType.genericType(\"K\");\n \t\tArgType valueType = ArgType.genericType(\"V\");\n@@ -113,6 +115,20 @@ public void compareGenerics() {\n \t\t// TODO implement compare for wildcard with bounds\n \t}\n \n+\t@Test\n+\tpublic void compareWildCards() {\n+\t\tArgType clsWildcard = generic(CLASS.getObject(), wildcard());\n+\t\tArgType clsExtendedWildcard = generic(CLASS.getObject(), wildcard(STRING, WildcardBound.EXTENDS));\n+\t\tcheck(clsWildcard, clsExtendedWildcard, TypeCompareEnum.WIDER);\n+\n+\t\tArgType listWildcard = generic(CLASS.getObject(), wildcard(object(\"java.util.List\"), WildcardBound.EXTENDS));\n+\t\tArgType collWildcard = generic(CLASS.getObject(), wildcard(object(\"java.util.Collection\"), WildcardBound.EXTENDS));\n+\t\tcheck(listWildcard, collWildcard, TypeCompareEnum.NARROW);\n+\n+\t\tArgType collSuperWildcard = generic(CLASS.getObject(), wildcard(object(\"java.util.Collection\"), WildcardBound.SUPER));\n+\t\tcheck(collSuperWildcard, listWildcard, TypeCompareEnum.CONFLICT);\n+\t}\n+\n \t@Test\n \tpublic void compareGenericTypes() {\n \t\tArgType vType = ArgType.genericType(\"V\");",
    "output": "Fix improve wildcard types compare"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -865,10 +865,12 @@ private static BlockNode calcPostDomOut(MethodNode mth, BlockNode block, List<Bl\n \t\t\t// slow search: calculate partial post-dominance for every exit node\n \t\t\tBitSet ipdoms = BlockUtils.newBlocksBitSet(mth);\n \t\t\tfor (BlockNode exitBlock : exits) {\n-\t\t\t\tSet<BlockNode> pathBlocks = BlockUtils.getAllPathsBlocks(block, exitBlock);\n-\t\t\t\tBlockNode ipdom = BlockUtils.calcPartialImmediatePostDominator(mth, block, pathBlocks, exitBlock);\n-\t\t\t\tif (ipdom != null) {\n-\t\t\t\t\tipdoms.set(ipdom.getId());\n+\t\t\t\tif (BlockUtils.isAnyPathExists(block, exitBlock)) {\n+\t\t\t\t\tSet<BlockNode> pathBlocks = BlockUtils.getAllPathsBlocks(block, exitBlock);\n+\t\t\t\t\tBlockNode ipdom = BlockUtils.calcPartialImmediatePostDominator(mth, block, pathBlocks, exitBlock);\n+\t\t\t\t\tif (ipdom != null) {\n+\t\t\t\t\t\tipdoms.set(ipdom.getId());\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\touts.and(ipdoms);",
    "output": "Fix speed up switch processing by skip not relevant exits"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n@@ -96,13 +96,13 @@ private TypeUpdateResult updateTypeChecked(TypeUpdateInfo updateInfo, InsnArg ar\n \t\tTypeCompareEnum compareResult = comparator.compareTypes(candidateType, currentType);\n \t\tif (arg.isTypeImmutable() && currentType != ArgType.UNKNOWN) {\n \t\t\t// don't changed type\n-\t\t\tif (compareResult == TypeCompareEnum.CONFLICT) {\n-\t\t\t\tif (Consts.DEBUG) {\n-\t\t\t\t\tLOG.debug(\"Type rejected for {} due to conflict: candidate={}, current={}\", arg, candidateType, currentType);\n-\t\t\t\t}\n-\t\t\t\treturn REJECT;\n+\t\t\tif (compareResult == TypeCompareEnum.EQUAL) {\n+\t\t\t\treturn SAME;\n \t\t\t}\n-\t\t\treturn SAME;\n+\t\t\tif (Consts.DEBUG) {\n+\t\t\t\tLOG.debug(\"Type rejected for {} due to conflict: candidate={}, current={}\", arg, candidateType, currentType);\n+\t\t\t}\n+\t\t\treturn REJECT;\n \t\t}\n \t\tif (compareResult.isWider() && !updateInfo.getFlags().isAllowWider()) {\n \t\t\tif (Consts.DEBUG) {\n@@ -412,7 +412,7 @@ private TypeUpdateResult arrayPutListener(TypeUpdateInfo updateInfo, InsnNode in\n \t\t\tTypeUpdateResult result = updateTypeChecked(updateInfo, putArg, arrayElement);\n \t\t\tif (result == REJECT) {\n \t\t\t\tArgType putType = putArg.getType();\n-\t\t\t\tif (putType.isTypeKnown() && putType.isObject()) {\n+\t\t\t\tif (putType.isTypeKnown() && !putType.isPrimitive()) {\n \t\t\t\t\tTypeCompareEnum compResult = comparator.compareTypes(arrayElement, putType);\n \t\t\t\t\tif (compResult == TypeCompareEnum.WIDER || compResult == TypeCompareEnum.WIDER_BY_GENERIC) {\n \t\t\t\t\t\t// allow wider result (i.e allow put in Object[] any objects)\n\ndiff --git a/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java b/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n--- a/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n+++ b/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n@@ -15,6 +15,7 @@\n import jadx.core.dex.nodes.RootNode;\n \n import static jadx.core.dex.instructions.args.ArgType.BOOLEAN;\n+import static jadx.core.dex.instructions.args.ArgType.BYTE;\n import static jadx.core.dex.instructions.args.ArgType.CHAR;\n import static jadx.core.dex.instructions.args.ArgType.CLASS;\n import static jadx.core.dex.instructions.args.ArgType.INT;\n@@ -77,6 +78,9 @@ public void compareArrays() {\n \n \t\tfirstIsNarrow(UNKNOWN_ARRAY, OBJECT);\n \n+\t\tfirstIsNarrow(array(BYTE), OBJECT);\n+\t\tfirstIsNarrow(array(array(BYTE)), array(OBJECT));\n+\n \t\tcheck(array(OBJECT), array(INT), TypeCompareEnum.CONFLICT);\n \n \t\tArgType integerType = ArgType.object(\"java.lang.Integer\");\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver11.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver11.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver11.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver11.java\n@@ -1,38 +1,51 @@\n package jadx.tests.integration.types;\n \n+import java.util.Arrays;\n+\n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.tests.api.IntegrationTest;\n \n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n public class TestTypeResolver11 extends IntegrationTest {\n \n \tpublic static class TestCls {\n-\t\tpublic Void test(Object... objArr) {\n-\t\t\tint val = (Integer) objArr[0];\n-\t\t\tString str = (String) objArr[1];\n+\t\tpublic Void test(Object... objects) {\n+\t\t\tint val = (Integer) objects[0];\n+\t\t\tString str = (String) objects[1];\n \t\t\tcall(str, str, val, val);\n \t\t\treturn null;\n \t\t}\n \n \t\tprivate void call(String a, String b, int... val) {\n \t\t}\n \n+\t\tprivate boolean test2(String s1, String... args) {\n+\t\t\tString str = Arrays.toString(args);\n+\t\t\treturn s1.length() + str.length() > 0;\n+\t\t}\n+\n \t\tpublic void check() {\n \t\t\ttest(1, \"str\");\n+\t\t\tassertThat(test2(\"1\", \"2\", \"34\")).isTrue();\n \t\t}\n \t}\n \n-\t@NotYetImplemented(\"Missing cast\")\n \t@Test\n \tpublic void test() {\n-\t\tgetClassNode(TestCls.class);\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"(Integer) objects[0]\")\n+\t\t\t\t.containsOne(\"String str = (String) objects[1];\");\n \t}\n \n-\t@NotYetImplemented(\"Missing cast\")\n \t@Test\n \tpublic void testNoDebug() {\n \t\tnoDebugInfo();\n-\t\tgetClassNode(TestCls.class);\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"(Integer) objArr[0]\")\n+\t\t\t\t.containsOne(\"String str = (String) objArr[1];\");\n \t}\n }",
    "output": "Fix improve type inference for arrays"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n@@ -297,10 +297,13 @@ private void addCaseKey(CodeWriter code, InsnArg arg, Object k) {\n \t\t\t\tcode.add(fn.getAlias());\n \t\t\t} else {\n \t\t\t\tstaticField(code, fn.getFieldInfo());\n-\t\t\t\t// print original value, sometimes replace with incorrect field\n+\t\t\t\t// print original value, sometimes replaced with incorrect field\n \t\t\t\tFieldInitAttr valueAttr = fn.get(AType.FIELD_INIT);\n-\t\t\t\tif (valueAttr != null && valueAttr.getValue() != null) {\n-\t\t\t\t\tcode.add(\" /*\").add(valueAttr.getValue().toString()).add(\"*/\");\n+\t\t\t\tif (valueAttr != null) {\n+\t\t\t\t\tObject value = valueAttr.getValue();\n+\t\t\t\t\tif (value != null && valueAttr.getValueType() == FieldInitAttr.InitType.CONST) {\n+\t\t\t\t\t\tcode.add(\" /*\").add(value.toString()).add(\"*/\");\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t} else if (k instanceof Integer) {",
    "output": "Fix don't print commented case value if it is an instruction"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -607,6 +607,7 @@ private void makeConstructor(ConstructorInsn insn, CodeWriter code)\n \t\tif (cls != null && cls.isAnonymous() && !fallback) {\n \t\t\tcls.ensureProcessed();\n \t\t\tinlineAnonymousConstructor(code, cls, insn);\n+\t\t\tmth.getParentClass().addInlinedClass(cls);\n \t\t\treturn;\n \t\t}\n \t\tif (insn.isSelf()) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -2,11 +2,12 @@\n \n import java.io.StringWriter;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n \n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n@@ -59,6 +60,8 @@ public class ClassNode extends LineAttrNode implements ILoadable, ICodeNode {\n \tprivate final List<FieldNode> fields;\n \tprivate List<ClassNode> innerClasses = Collections.emptyList();\n \n+\tprivate List<ClassNode> inlinedClasses = Collections.emptyList();\n+\n \t// store smali\n \tprivate String smali;\n \t// store parent for inner classes or 'this' otherwise\n@@ -453,14 +456,20 @@ public List<ClassNode> getInnerClasses() {\n \t}\n \n \t/**\n-\t * Get all inner classes recursively\n+\t * Get all inner and inlined classes recursively\n \t *\n-\t * @param innerClassesColl all identified inner classes are added to this collection\n+\t * @param resultClassesSet all identified inner and inlined classes are added to this set\n \t */\n-\tpublic void getInnerClassesRecursive(Collection<ClassNode> innerClassesColl) {\n-\t\tfor (ClassNode innerClass : innerClasses) {\n-\t\t\tinnerClassesColl.add(innerClass);\n-\t\t\tinnerClass.getInnerClassesRecursive(innerClassesColl);\n+\tpublic void getInnerAndInlinedClassesRecursive(Set<ClassNode> resultClassesSet) {\n+\t\tfor (ClassNode innerCls : innerClasses) {\n+\t\t\tif (resultClassesSet.add(innerCls)) {\n+\t\t\t\tinnerCls.getInnerAndInlinedClassesRecursive(resultClassesSet);\n+\t\t\t}\n+\t\t}\n+\t\tfor (ClassNode inlinedCls : inlinedClasses) {\n+\t\t\tif (resultClassesSet.add(inlinedCls)) {\n+\t\t\t\tinlinedCls.getInnerAndInlinedClassesRecursive(resultClassesSet);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -472,6 +481,13 @@ public void addInnerClass(ClassNode cls) {\n \t\tcls.parentClass = this;\n \t}\n \n+\tpublic void addInlinedClass(ClassNode cls) {\n+\t\tif (inlinedClasses.isEmpty()) {\n+\t\t\tinlinedClasses = new ArrayList<>(5);\n+\t\t}\n+\t\tinlinedClasses.add(cls);\n+\t}\n+\n \tpublic boolean isEnum() {\n \t\treturn getAccessFlags().isEnum()\n \t\t\t\t&& getSuperClass() != null\n@@ -550,9 +566,9 @@ public String getSmali() {\n \t\t\tStringWriter stringWriter = new StringWriter(4096);\n \t\t\tgetSmali(this, stringWriter);\n \t\t\tstringWriter.append(System.lineSeparator());\n-\t\t\tList<ClassNode> allInnerClasses = new ArrayList<>();\n-\t\t\tgetInnerClassesRecursive(allInnerClasses);\n-\t\t\tfor (ClassNode innerClass : allInnerClasses) {\n+\t\t\tSet<ClassNode> allInlinedClasses = new LinkedHashSet<>();\n+\t\t\tgetInnerAndInlinedClassesRecursive(allInlinedClasses);\n+\t\t\tfor (ClassNode innerClass : allInlinedClasses) {\n \t\t\t\tgetSmali(innerClass, stringWriter);\n \t\t\t\tstringWriter.append(System.lineSeparator());\n \t\t\t}",
    "output": "Fix record inlined classes and generate Smali code for them (PR #851, #848)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -2,6 +2,7 @@\n \n import java.io.StringWriter;\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n@@ -451,6 +452,18 @@ public List<ClassNode> getInnerClasses() {\n \t\treturn innerClasses;\n \t}\n \n+\t/**\n+\t * Get all inner classes recursively\n+\t *\n+\t * @param innerClassesColl all identified inner classes are added to this collection\n+\t */\n+\tpublic void getInnerClassesRecursive(Collection<ClassNode> innerClassesColl) {\n+\t\tfor (ClassNode innerClass : innerClasses) {\n+\t\t\tinnerClassesColl.add(innerClass);\n+\t\t\tinnerClass.getInnerClassesRecursive(innerClassesColl);\n+\t\t}\n+\t}\n+\n \tpublic void addInnerClass(ClassNode cls) {\n \t\tif (innerClasses.isEmpty()) {\n \t\t\tinnerClasses = new ArrayList<>(5);\n@@ -537,7 +550,9 @@ public String getSmali() {\n \t\t\tStringWriter stringWriter = new StringWriter(4096);\n \t\t\tgetSmali(this, stringWriter);\n \t\t\tstringWriter.append(System.lineSeparator());\n-\t\t\tfor (ClassNode innerClass : innerClasses) {\n+\t\t\tList<ClassNode> allInnerClasses = new ArrayList<>();\n+\t\t\tgetInnerClassesRecursive(allInnerClasses);\n+\t\t\tfor (ClassNode innerClass : allInnerClasses) {\n \t\t\t\tgetSmali(innerClass, stringWriter);\n \t\t\t\tstringWriter.append(System.lineSeparator());\n \t\t\t}",
    "output": "Fix additionally show smali code of all inner classes (recursively) (PR #849, #848)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n@@ -65,6 +65,7 @@ public static LiteralArg lit(DecodedInstruction insn, ArgType type) {\n \t}\n \n \tprivate static InsnWrapArg wrap(InsnNode insn) {\n+\t\tinsn.add(AFlag.WRAPPED);\n \t\treturn new InsnWrapArg(insn);\n \t}\n \n@@ -140,9 +141,17 @@ public static InsnArg wrapInsnIntoArg(InsnNode insn) {\n \t\tInsnArg arg;\n \t\tInsnType type = insn.getType();\n \t\tif (type == InsnType.CONST || type == InsnType.MOVE) {\n-\t\t\targ = insn.getArg(0);\n-\t\t\tinsn.add(AFlag.REMOVE);\n-\t\t\tinsn.add(AFlag.DONT_GENERATE);\n+\t\t\tif (insn.contains(AFlag.FORCE_ASSIGN_INLINE)) {\n+\t\t\t\tRegisterArg resArg = insn.getResult();\n+\t\t\t\targ = wrap(insn);\n+\t\t\t\tif (resArg != null) {\n+\t\t\t\t\targ.setType(resArg.getType());\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\targ = insn.getArg(0);\n+\t\t\t\tinsn.add(AFlag.REMOVE);\n+\t\t\t\tinsn.add(AFlag.DONT_GENERATE);\n+\t\t\t}\n \t\t} else {\n \t\t\targ = wrapArg(insn);\n \t\t}\n@@ -156,8 +165,6 @@ public static InsnArg wrapInsnIntoArg(InsnNode insn) {\n \tpublic static InsnArg wrapArg(InsnNode insn) {\n \t\tRegisterArg resArg = insn.getResult();\n \t\tInsnArg arg = wrap(insn);\n-\t\tinsn.add(AFlag.WRAPPED);\n-\n \t\tswitch (insn.getType()) {\n \t\t\tcase CONST:\n \t\t\tcase MOVE:\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n@@ -100,10 +100,6 @@ private static void checkInline(MethodNode mth, BlockNode block, InsnList insnLi\n \n \t\tint assignPos = insnList.getIndex(assignInsn);\n \t\tif (assignPos != -1) {\n-\t\t\tif (assignInline) {\n-\t\t\t\t// TODO?\n-\t\t\t\treturn;\n-\t\t\t}\n \t\t\tWrapInfo wrapInfo = argsInfo.checkInline(assignPos, arg);\n \t\t\tif (wrapInfo != null) {\n \t\t\t\twrapList.add(wrapInfo);\n@@ -123,32 +119,29 @@ && canMoveBetweenBlocks(assignInsn, assignBlock, block, argsInfo.getInsn())) {\n \t\t}\n \t}\n \n-\tprivate static void assignInline(MethodNode mth, RegisterArg arg, InsnNode assignInsn, BlockNode assignBlock) {\n+\tprivate static boolean assignInline(MethodNode mth, RegisterArg arg, InsnNode assignInsn, BlockNode assignBlock) {\n \t\tRegisterArg useArg = arg.getSVar().getUseList().get(0);\n \t\tInsnNode useInsn = useArg.getParentInsn();\n \t\tif (useInsn == null || useInsn.contains(AFlag.DONT_GENERATE)) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tInsnArg replaceArg;\n-\t\tInsnType assignInsnType = assignInsn.getType();\n-\t\tif (assignInsnType == InsnType.MOVE || assignInsnType == InsnType.CONST) {\n-\t\t\treplaceArg = assignInsn.getArg(0).duplicate();\n-\t\t} else {\n-\t\t\treplaceArg = InsnArg.wrapArg(assignInsn.copy());\n+\t\t\treturn false;\n \t\t}\n+\t\tInsnArg replaceArg = InsnArg.wrapInsnIntoArg(assignInsn.copy());\n \t\tuseInsn.replaceArg(useArg, replaceArg);\n \n \t\tassignInsn.add(AFlag.REMOVE);\n \t\tassignInsn.add(AFlag.DONT_GENERATE);\n \t\tInsnRemover.remove(mth, assignBlock, assignInsn);\n+\t\treturn true;\n \t}\n \n \tprivate static boolean inline(MethodNode mth, RegisterArg arg, InsnNode insn, BlockNode block) {\n \t\tInsnNode parentInsn = arg.getParentInsn();\n \t\tif (parentInsn != null && parentInsn.getType() == InsnType.RETURN) {\n \t\t\tparentInsn.setSourceLine(insn.getSourceLine());\n \t\t}\n+\t\tif (insn.contains(AFlag.FORCE_ASSIGN_INLINE)) {\n+\t\t\treturn assignInline(mth, arg, insn, block);\n+\t\t}\n \t\tboolean replaced = arg.wrapInstruction(mth, insn) != null;\n \t\tif (replaced) {\n \t\t\tInsnList.remove(block, insn);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestInnerAssign3.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestInnerAssign3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestInnerAssign3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestInnerAssign3.java\n@@ -0,0 +1,22 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+/**\n+ * Issue #820\n+ */\n+public class TestInnerAssign3 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"(testMethod = (testClass1 = null).testMethod()) == null\")\n+\t\t\t\t.containsOne(\"testClass1.testField != null\");\n+\t}\n+}",
    "output": "Fix inline assignment instruction from same block"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java\n@@ -25,6 +25,7 @@\n import jadx.core.dex.regions.SynchronizedRegion;\n import jadx.core.dex.regions.loops.LoopRegion;\n import jadx.core.dex.visitors.AbstractVisitor;\n+import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n import jadx.core.utils.InsnRemover;\n import jadx.core.utils.RegionUtils;\n import jadx.core.utils.exceptions.JadxException;\n@@ -58,6 +59,8 @@ public void visit(MethodNode mth) throws JadxException {\n \t}\n \n \tprivate static void postProcessRegions(MethodNode mth) {\n+\t\tprocessForceInlineInsns(mth);\n+\n \t\t// make try-catch regions\n \t\tProcessTryCatchRegions.process(mth);\n \n@@ -70,6 +73,15 @@ private static void postProcessRegions(MethodNode mth) {\n \t\t}\n \t}\n \n+\tprivate static void processForceInlineInsns(MethodNode mth) {\n+\t\tboolean needShrink = mth.getBasicBlocks().stream()\n+\t\t\t\t.flatMap(block -> block.getInstructions().stream())\n+\t\t\t\t.anyMatch(insn -> insn.contains(AFlag.FORCE_ASSIGN_INLINE));\n+\t\tif (needShrink) {\n+\t\t\tCodeShrinkVisitor.shrinkMethod(mth);\n+\t\t}\n+\t}\n+\n \tprivate static final class PostRegionVisitor extends AbstractRegionVisitor {\n \t\t@Override\n \t\tpublic void leaveRegion(MethodNode mth, IRegion region) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestInnerAssign.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestInnerAssign.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestInnerAssign.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestInnerAssign.java\n@@ -9,7 +9,7 @@\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n \n-public class TestConditions19 extends IntegrationTest {\n+public class TestInnerAssign extends IntegrationTest {\n \n \tpublic static class TestCls {\n \t\tprivate String result;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestInnerAssign2.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestInnerAssign2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestInnerAssign2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestInnerAssign2.java\n@@ -0,0 +1,47 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestInnerAssign2 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tprivate String field;\n+\t\tprivate String swapField;\n+\n+\t\t@SuppressWarnings(\"checkstyle:InnerAssignment\")\n+\t\tpublic boolean test(String str) {\n+\t\t\tString sub;\n+\t\t\treturn call(str) || ((sub = this.field) != null && sub.isEmpty());\n+\t\t}\n+\n+\t\tprivate boolean call(String str) {\n+\t\t\tthis.field = swapField;\n+\t\t\treturn str.isEmpty();\n+\t\t}\n+\n+\t\tpublic boolean testWrap(String str, String fieldValue) {\n+\t\t\tthis.field = null;\n+\t\t\tthis.swapField = fieldValue;\n+\t\t\treturn test(str);\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(testWrap(\"\", null)).isTrue();\n+\t\t\tassertThat(testWrap(\"a\", \"\")).isTrue();\n+\t\t\tassertThat(testWrap(\"b\", null)).isFalse();\n+\t\t\tassertThat(testWrap(\"c\", \"d\")).isFalse();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"sub = this.field\")\n+\t\t\t\t.containsOne(\"return call(str) || ((sub = this.field) != null && sub.isEmpty());\");\n+\t}\n+}",
    "output": "Fix shrink code if region maker add FORCE_ASSIGN_INLINE to insn"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -208,7 +208,7 @@ private List<ArgType> parseSignature() {\n \t\t\t}\n \t\t\treturn argsTypes;\n \t\t} catch (Exception e) {\n-\t\t\taddWarningComment(\"Failed to parse method signature: \" + sp.getSignature(), e);\n+\t\t\taddWarnComment(\"Failed to parse method signature: \" + sp.getSignature(), e);\n \t\t\treturn null;\n \t\t}\n \t}\n@@ -698,11 +698,11 @@ public void addWarn(String warnStr) {\n \t\tErrorsCounter.methodWarn(this, warnStr);\n \t}\n \n-\tpublic void addWarningComment(String warn) {\n-\t\taddWarningComment(warn, null);\n+\tpublic void addWarnComment(String warn) {\n+\t\taddWarnComment(warn, null);\n \t}\n \n-\tpublic void addWarningComment(String warn, @Nullable Throwable exc) {\n+\tpublic void addWarnComment(String warn, @Nullable Throwable exc) {\n \t\tString commentStr = \"JADX WARN: \" + warn;\n \t\taddAttr(AType.COMMENTS, commentStr);\n \t\tif (exc != null) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java\n@@ -64,7 +64,7 @@ private static void checkTypes(MethodNode mth) {\n \t\tmth.getSVars().forEach(var -> {\n \t\t\tArgType type = var.getTypeInfo().getType();\n \t\t\tif (!type.isTypeKnown()) {\n-\t\t\t\tmth.addComment(\"JADX WARNING: type inference failed for: \" + var.getDetailedVarInfo(mth));\n+\t\t\t\tmth.addWarnComment(\"Type inference failed for: \" + var.getDetailedVarInfo(mth));\n \t\t\t}\n \t\t});\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -72,7 +72,9 @@ public void visit(MethodNode mth) {\n \t\tif (!resolved) {\n \t\t\tboolean moveAdded = false;\n \t\t\tfor (SSAVar var : new ArrayList<>(mth.getSVars())) {\n-\t\t\t\tmoveAdded |= tryInsertAdditionalInsn(mth, var);\n+\t\t\t\tif (tryInsertAdditionalInsn(mth, var)) {\n+\t\t\t\t\tmoveAdded = true;\n+\t\t\t\t}\n \t\t\t}\n \t\t\tif (moveAdded) {\n \t\t\t\tInitCodeVariables.rerun(mth);\n@@ -361,50 +363,67 @@ private boolean tryInsertAdditionalInsn(MethodNode mth, SSAVar var) {\n \t\t\t}\n \t\t}\n \t\tfor (PhiInsn phiInsn : usedInPhiList) {\n-\t\t\tif (!insertMoveForPhi(mth, phiInsn, var)) {\n+\t\t\tif (!insertMoveForPhi(mth, phiInsn, var, false)) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n+\n+\t\t// all check passed => apply\n+\t\tfor (PhiInsn phiInsn : usedInPhiList) {\n+\t\t\tinsertMoveForPhi(mth, phiInsn, var, true);\n+\t\t}\n+\t\tmth.addComment(\"JADX INFO: additional move instructions added (\" + usedInPhiList.size() + \") to help type inference\");\n \t\treturn true;\n \t}\n \n-\tprivate boolean insertMoveForPhi(MethodNode mth, PhiInsn phiInsn, SSAVar var) {\n+\tprivate boolean insertMoveForPhi(MethodNode mth, PhiInsn phiInsn, SSAVar var, boolean apply) {\n \t\tint argsCount = phiInsn.getArgsCount();\n \t\tfor (int argIndex = 0; argIndex < argsCount; argIndex++) {\n \t\t\tRegisterArg reg = phiInsn.getArg(argIndex);\n \t\t\tif (reg.getSVar() == var) {\n-\t\t\t\tBlockNode blockNode = phiInsn.getBlockByArgIndex(argIndex);\n-\t\t\t\tInsnNode lastInsn = BlockUtils.getLastInsn(blockNode);\n-\t\t\t\tif (lastInsn != null && BlockSplitter.isSeparate(lastInsn.getType())) {\n-\t\t\t\t\t// can't insert move in block with separate instruction\n-\t\t\t\t\t// trying previous block\n-\t\t\t\t\tList<BlockNode> preds = blockNode.getPredecessors();\n-\t\t\t\t\tif (preds.size() == 1) {\n-\t\t\t\t\t\tblockNode = preds.get(0);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tmth.addWarn(\"Failed to insert additional move for type inference\");\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t\t}\n+\t\t\t\tBlockNode startBlock = phiInsn.getBlockByArgIndex(argIndex);\n+\t\t\t\tBlockNode blockNode = checkBlockForInsnInsert(startBlock);\n+\t\t\t\tif (blockNode == null) {\n+\t\t\t\t\tmth.addWarnComment(\"Failed to insert an additional move for type inference into block \" + startBlock);\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tif (apply) {\n+\t\t\t\t\tint regNum = reg.getRegNum();\n+\t\t\t\t\tRegisterArg resultArg = reg.duplicate(regNum, null);\n+\t\t\t\t\tSSAVar newSsaVar = mth.makeNewSVar(regNum, resultArg);\n+\t\t\t\t\tRegisterArg arg = reg.duplicate(regNum, var);\n+\n+\t\t\t\t\tInsnNode moveInsn = new InsnNode(InsnType.MOVE, 1);\n+\t\t\t\t\tmoveInsn.setResult(resultArg);\n+\t\t\t\t\tmoveInsn.addArg(arg);\n+\t\t\t\t\tmoveInsn.add(AFlag.SYNTHETIC);\n+\t\t\t\t\tblockNode.getInstructions().add(moveInsn);\n+\n+\t\t\t\t\tphiInsn.replaceArg(reg, reg.duplicate(regNum, newSsaVar));\n \t\t\t\t}\n-\n-\t\t\t\tint regNum = reg.getRegNum();\n-\t\t\t\tRegisterArg resultArg = reg.duplicate(regNum, null);\n-\t\t\t\tSSAVar newSsaVar = mth.makeNewSVar(regNum, resultArg);\n-\t\t\t\tRegisterArg arg = reg.duplicate(regNum, var);\n-\n-\t\t\t\tInsnNode moveInsn = new InsnNode(InsnType.MOVE, 1);\n-\t\t\t\tmoveInsn.setResult(resultArg);\n-\t\t\t\tmoveInsn.addArg(arg);\n-\t\t\t\tmoveInsn.add(AFlag.SYNTHETIC);\n-\t\t\t\tblockNode.getInstructions().add(moveInsn);\n-\n-\t\t\t\tphiInsn.replaceArg(reg, reg.duplicate(regNum, newSsaVar));\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}\n \t\treturn false;\n \t}\n \n+\t@Nullable\n+\tprivate BlockNode checkBlockForInsnInsert(BlockNode blockNode) {\n+\t\tif (blockNode.isSynthetic()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tInsnNode lastInsn = BlockUtils.getLastInsn(blockNode);\n+\t\tif (lastInsn != null && BlockSplitter.isSeparate(lastInsn.getType())) {\n+\t\t\t// can't insert move in a block with 'separate' instruction => try previous block by simple path\n+\t\t\tList<BlockNode> preds = blockNode.getPredecessors();\n+\t\t\tif (preds.size() == 1) {\n+\t\t\t\treturn checkBlockForInsnInsert(preds.get(0));\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn blockNode;\n+\t}\n+\n \tprivate boolean tryWiderObjects(MethodNode mth, SSAVar var) {\n \t\tSet<ArgType> objTypes = new LinkedHashSet<>();\n \t\tfor (ITypeBound bound : var.getTypeInfo().getBounds()) {",
    "output": "Fix additional checks before insert move to help type inference"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java\n@@ -67,9 +67,10 @@ public boolean run() {\n \t\t\t\tLOG.warn(\"Multi-variable search failed in {}\", mth);\n \t\t\t}\n \t\t}\n-\n-\t\tboolean applySuccess = applyResolvedVars();\n-\t\treturn searchSuccess && applySuccess;\n+\t\tif (searchSuccess) {\n+\t\t\treturn applyResolvedVars();\n+\t\t}\n+\t\treturn false;\n \t}\n \n \tprivate boolean applyResolvedVars() {",
    "output": "Fix don't apply types if search failed"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n@@ -86,6 +86,7 @@ public void visit(MethodNode mth) {\n \t\tInsnRemover remover = new InsnRemover(mth);\n \t\treplaceStep(mth, remover);\n \t\tremoveStep(mth, remover);\n+\t\titerativeRemoveStep(mth);\n \t}\n \n \tprivate static void replaceStep(MethodNode mth, InsnRemover remover) {\n@@ -293,13 +294,43 @@ private static void removeStep(MethodNode mth, InsnRemover remover) {\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tdefault:\n+\t\t\t\t\t\tif (insn.contains(AFlag.REMOVE)) {\n+\t\t\t\t\t\t\tremover.addAndUnbind(insn);\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t\tremover.perform();\n \t\t}\n \t}\n \n+\tprivate static void iterativeRemoveStep(MethodNode mth) {\n+\t\tboolean changed;\n+\t\tdo {\n+\t\t\tchanged = false;\n+\t\t\tfor (BlockNode block : mth.getBasicBlocks()) {\n+\t\t\t\tfor (InsnNode insn : block.getInstructions()) {\n+\t\t\t\t\tif (insn.getType() == InsnType.MOVE\n+\t\t\t\t\t\t\t&& insn.isAttrStorageEmpty()\n+\t\t\t\t\t\t\t&& isResultArgNotUsed(insn)) {\n+\t\t\t\t\t\tInsnRemover.remove(mth, block, insn);\n+\t\t\t\t\t\tchanged = true;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} while (changed);\n+\t}\n+\n+\tprivate static boolean isResultArgNotUsed(InsnNode insn) {\n+\t\tRegisterArg result = insn.getResult();\n+\t\tif (result != null) {\n+\t\t\tSSAVar ssaVar = result.getSVar();\n+\t\t\treturn ssaVar.getUseCount() == 0;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tprivate static void processAnonymousConstructor(MethodNode mth, ConstructorInsn co) {\n \t\tMethodInfo callMth = co.getCallMth();\n \t\tMethodNode callMthNode = mth.dex().resolveMethod(callMth);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n@@ -422,6 +422,7 @@ private static void markOneArgAsThis(RegisterArg arg) {\n \t\t\tif (resArg.getRegNum() != arg.getRegNum()\n \t\t\t\t\t&& !resArg.getSVar().isUsedInPhi()) {\n \t\t\t\tmarkThisArgs(resArg);\n+\t\t\t\tparentInsn.add(AFlag.REMOVE);\n \t\t\t\tparentInsn.add(AFlag.DONT_GENERATE);\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper2.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper2.java\n@@ -0,0 +1,41 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestInsnsBeforeSuper2 extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tpublic class TestInsnsBeforeSuper2 extends java.lang.Exception {\n+\t\t\tprivate int mErrorType;\n+\n+\t\t\tpublic TestInsnsBeforeSuper2(java.lang.String r9, int r10) {\n+\t\t\t\tr8 = this;\n+\t\t\t\tr0 = r8\n+\t\t\t\tr1 = r9\n+\t\t\t\tr2 = r10\n+\t\t\t\tr3 = r0\n+\t\t\t\tr4 = r1\n+\t\t\t\tr5 = r2\n+\t\t\t\tr6 = r1\n+\t\t\t\tr0.<init>(r6)\n+\t\t\t\tr7 = 0\n+\t\t\t\tr0.mErrorType = r7\n+\t\t\t\tr0.mErrorType = r2\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.containsOne(\"super(message);\")\n+\t\t\t\t.containsOne(\"this.mErrorType = errorType;\");\n+\t}\n+}",
    "output": "Remove move instructions with unused result"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JavaClass.java b/jadx-core/src/main/java/jadx/api/JavaClass.java\n--- a/jadx-core/src/main/java/jadx/api/JavaClass.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java\n@@ -59,7 +59,7 @@ public void decompile() {\n \n \tpublic synchronized void refresh() {\n \t\tlistsLoaded = false;\n-\t\tcls.reloadCode();\n+\t\tcls.reRunDecompile();\n \t}\n \n \tpublic synchronized String getSmali() {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -279,13 +279,21 @@ public ICodeInfo getCode() {\n \t\treturn decompile(true);\n \t}\n \n+\tpublic synchronized ICodeInfo reRunDecompile() {\n+\t\treturn decompile(false);\n+\t}\n+\n \tpublic synchronized ICodeInfo reloadCode() {\n \t\tunload();\n \t\tdeepUnload();\n \t\treturn decompile(false);\n \t}\n \n-\tprivate void deepUnload() {\n+\tpublic void deepUnload() {\n+\t\tif (cls == null) {\n+\t\t\t// manually added class\n+\t\t\treturn;\n+\t\t}\n \t\tclearAttributes();\n \t\troot().getConstValues().removeForClass(this);\n \t\tinitialLoad();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/RenameDialog.java\n@@ -222,6 +222,10 @@ private int refreshState(RootNode rootNode) {\n \t\trefreshTabs(mainWindow.getTabbedPane(), updatedClasses);\n \n \t\tif (updatedClasses.size() > 0) {\n+\t\t\tfor (JavaClass updatedClass : updatedClasses) {\n+\t\t\t\tupdatedClass.unload();\n+\t\t\t\tupdatedClass.getClassNode().deepUnload();\n+\t\t\t}\n \t\t\tsetRefreshTask(updatedClasses);\n \t\t}",
    "output": "Fix resolve multi-threaded unloading"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -52,6 +52,8 @@ public class ClassGen {\n \tprivate final Set<ClassInfo> imports = new HashSet<>();\n \tprivate int clsDeclLine;\n \n+\tprivate boolean bodyGenStarted;\n+\n \tpublic ClassGen(ClassNode cls, JadxArgs jadxArgs) {\n \t\tthis(cls, null, jadxArgs.isUseImports(), jadxArgs.isFallbackMode(), jadxArgs.isShowInconsistentCode());\n \t}\n@@ -222,6 +224,7 @@ public boolean addGenericMap(CodeWriter code, List<GenericInfo> generics, boolea\n \n \tpublic void addClassBody(CodeWriter clsCode) throws CodegenException {\n \t\tclsCode.add('{');\n+\t\tsetBodyGenStarted(true);\n \t\tclsDeclLine = clsCode.getLine();\n \t\tclsCode.incIndent();\n \t\taddFields(clsCode);\n@@ -656,4 +659,12 @@ public AnnotationGen getAnnotationGen() {\n \tpublic boolean isFallbackMode() {\n \t\treturn fallback;\n \t}\n+\n+\tpublic boolean isBodyGenStarted() {\n+\t\treturn bodyGenStarted;\n+\t}\n+\n+\tpublic void setBodyGenStarted(boolean bodyGenStarted) {\n+\t\tthis.bodyGenStarted = bodyGenStarted;\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -183,7 +183,7 @@ public static void makeStaticFieldAccess(CodeWriter code, FieldInfo field, Class\n \t\tClassInfo declClass = field.getDeclClass();\n \t\t// TODO\n \t\tboolean fieldFromThisClass = clsGen.getClassNode().getClassInfo().equals(declClass);\n-\t\tif (!fieldFromThisClass) {\n+\t\tif (!fieldFromThisClass || !clsGen.isBodyGenStarted()) {\n \t\t\t// Android specific resources class handler\n \t\t\tif (!handleAppResField(code, clsGen, declClass)) {\n \t\t\t\tclsGen.useClass(code, declClass);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n@@ -11,6 +11,9 @@\n \n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.attributes.AttrNode;\n+import jadx.core.dex.attributes.annotations.Annotation;\n+import jadx.core.dex.attributes.annotations.AnnotationsList;\n import jadx.core.dex.attributes.nodes.FieldReplaceAttr;\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.info.MethodInfo;\n@@ -46,6 +49,7 @@\n import jadx.core.utils.ErrorsCounter;\n import jadx.core.utils.InsnRemover;\n import jadx.core.utils.InsnUtils;\n+import jadx.core.utils.exceptions.JadxException;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n import static jadx.core.utils.BlockUtils.replaceInsn;\n@@ -68,6 +72,12 @@ public class ModVisitor extends AbstractVisitor {\n \tprivate static final long DOUBLE_TO_BITS = Double.doubleToLongBits(1);\n \tprivate static final long FLOAT_TO_BITS = Float.floatToIntBits(1);\n \n+\t@Override\n+\tpublic boolean visit(ClassNode cls) throws JadxException {\n+\t\treplaceConstInAnnotations(cls);\n+\t\treturn true;\n+\t}\n+\n \t@Override\n \tpublic void visit(MethodNode mth) {\n \t\tif (mth.isNoCode()) {\n@@ -171,6 +181,33 @@ private static void fixPrimitiveCast(MethodNode mth, BlockNode block, int i, Ins\n \t\t}\n \t}\n \n+\tprivate void replaceConstInAnnotations(ClassNode cls) {\n+\t\tif (cls.root().getArgs().isReplaceConsts()) {\n+\t\t\treplaceConstsInAnnotationForAttrNode(cls, cls);\n+\t\t\tcls.getFields().forEach(f -> replaceConstsInAnnotationForAttrNode(cls, f));\n+\t\t\tcls.getMethods().forEach(m -> replaceConstsInAnnotationForAttrNode(cls, m));\n+\t\t}\n+\t}\n+\n+\tprivate void replaceConstsInAnnotationForAttrNode(ClassNode parentCls, AttrNode attrNode) {\n+\t\tAnnotationsList annotationsList = attrNode.get(AType.ANNOTATION_LIST);\n+\t\tif (annotationsList == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\tfor (Annotation annotation : annotationsList.getAll()) {\n+\t\t\tif (annotation.getVisibility() == Annotation.Visibility.SYSTEM) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tfor (Map.Entry<String, Object> entry : annotation.getValues().entrySet()) {\n+\t\t\t\tObject value = entry.getValue();\n+\t\t\t\tFieldNode constField = parentCls.getConstField(value);\n+\t\t\t\tif (constField != null) {\n+\t\t\t\t\tentry.setValue(constField.getFieldInfo());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tprivate static void replaceConst(MethodNode mth, ClassNode parentClass, BlockNode block, int i, InsnNode insn) {\n \t\tFieldNode f;\n \t\tif (insn.getType() == InsnType.CONST_STR) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inner/TestRFieldRestore3.java b/jadx-core/src/test/java/jadx/tests/integration/inner/TestRFieldRestore3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inner/TestRFieldRestore3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestRFieldRestore3.java\n@@ -0,0 +1,70 @@\n+package jadx.tests.integration.inner;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestRFieldRestore3 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\t@T(2131230730)\n+\t\tpublic static class A {\n+\t\t\t@F(2131230730)\n+\t\t\tprivate int f;\n+\n+\t\t\t@M(bind = 2137373737)\n+\t\t\tprivate void mth() {\n+\t\t\t}\n+\n+\t\t\t@T(2137373737)\n+\t\t\tprivate class D {\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Retention(RetentionPolicy.RUNTIME)\n+\t\t@Target(ElementType.TYPE)\n+\t\t@interface T {\n+\t\t\tint value();\n+\t\t}\n+\n+\t\t@Retention(RetentionPolicy.RUNTIME)\n+\t\t@Target({ ElementType.FIELD })\n+\t\t@interface F {\n+\t\t\tint value();\n+\t\t}\n+\n+\t\t@Retention(RetentionPolicy.RUNTIME)\n+\t\t@Target({ ElementType.METHOD })\n+\t\t@interface M {\n+\t\t\tint bind();\n+\t\t}\n+\n+\t\tpublic static class R {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tMap<Integer, String> map = new HashMap<>();\n+\t\tmap.put(2131230730, \"id.Button\");\n+\t\tmap.put(2137373737, \"id.MyId\");\n+\t\tsetResMap(map);\n+\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOnlyOnce(\"@T(R.id.Button)\")\n+\t\t\t\t.containsOnlyOnce(\"@T(R.id.MyId)\")\n+\t\t\t\t.containsOnlyOnce(\"@F(R.id.Button)\")\n+\t\t\t\t.containsOnlyOnce(\"@M(bind = R.id.MyId)\");\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inner/TestReplaceConstsInAnnotations.java b/jadx-core/src/test/java/jadx/tests/integration/inner/TestReplaceConstsInAnnotations.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inner/TestReplaceConstsInAnnotations.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestReplaceConstsInAnnotations.java\n@@ -0,0 +1,37 @@\n+package jadx.tests.integration.inner;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestReplaceConstsInAnnotations extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\t@Target(ElementType.TYPE)\n+\t\t@Retention(RetentionPolicy.RUNTIME)\n+\t\tpublic @interface A {\n+\t\t\tint i();\n+\n+\t\t\tfloat f();\n+\t\t}\n+\n+\t\t@A(i = -1, f = C.FLOAT_CONST)\n+\t\tpublic static class C {\n+\t\t\tpublic static final float FLOAT_CONST = 3.14f;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOnlyOnce(\"f = C.FLOAT_CONST\");\n+\t}\n+}",
    "output": "Fix replace constants inside annotations"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n@@ -66,9 +66,13 @@ private static ArgType checkClassType(ArgType type) {\n \t}\n \n \tpublic void changeShortName(String aliasName) {\n-\t\tClassAliasInfo newAlias = new ClassAliasInfo(getAliasPkg(), aliasName);\n-\t\tfillAliasFullName(newAlias);\n-\t\tthis.alias = newAlias;\n+\t\tif (!Objects.equals(name, aliasName)) {\n+\t\t\tClassAliasInfo newAlias = new ClassAliasInfo(getAliasPkg(), aliasName);\n+\t\t\tfillAliasFullName(newAlias);\n+\t\t\tthis.alias = newAlias;\n+\t\t} else {\n+\t\t\tthis.alias = null;\n+\t\t}\n \t}\n \n \tpublic void changePkg(String aliasPkg) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java b/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java\n@@ -2,8 +2,10 @@\n \n import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Set;\n \n import org.jetbrains.annotations.Nullable;\n@@ -52,6 +54,18 @@ public boolean put(Object value, FieldNode fld) {\n \t\tpublic boolean contains(Object value) {\n \t\t\treturn duplicates.contains(value) || values.containsKey(value);\n \t\t}\n+\n+\t\tvoid removeForCls(ClassNode cls) {\n+\t\t\tIterator<Entry<Object, FieldNode>> it = values.entrySet().iterator();\n+\t\t\twhile (it.hasNext()) {\n+\t\t\t\tEntry<Object, FieldNode> entry = it.next();\n+\t\t\t\tFieldNode field = entry.getValue();\n+\t\t\t\tif (field.getParentClass().equals(cls)) {\n+\t\t\t\t\tit.remove();\n+\t\t\t\t\tduplicates.remove(entry.getKey());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n \n \tprivate final boolean replaceEnabled;\n@@ -82,6 +96,11 @@ public void processConstFields(ClassNode cls, List<FieldNode> staticFields) {\n \t\t}\n \t}\n \n+\tpublic void removeForClass(ClassNode cls) {\n+\t\tclasses.remove(cls);\n+\t\tglobalValues.removeForCls(cls);\n+\t}\n+\n \tprivate void addConstField(ClassNode cls, FieldNode fld, Object value, boolean isPublic) {\n \t\tif (isPublic) {\n \t\t\tglobalValues.put(value, fld);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -35,6 +35,7 @@\n import jadx.core.dex.nodes.parser.FieldInitAttr;\n import jadx.core.dex.nodes.parser.SignatureParser;\n import jadx.core.dex.nodes.parser.StaticValuesParser;\n+import jadx.core.dex.visitors.ProcessAnonymous;\n import jadx.core.utils.SmaliUtils;\n import jadx.core.utils.exceptions.DecodeException;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n@@ -175,9 +176,7 @@ private void loadAnnotations(ClassDef cls) {\n \n \tprivate void loadStaticValues(ClassDef cls, List<FieldNode> staticFields) throws DecodeException {\n \t\tfor (FieldNode f : staticFields) {\n-\t\t\tAccessInfo flags = f.getAccessFlags();\n-\t\t\tif (flags.isStatic() && flags.isFinal()) {\n-\t\t\t\tLOG.debug(\"loadStaticValues(): Adding NULL initializer to static final field {}\", f.getAlias());\n+\t\t\tif (f.getAccessFlags().isFinal()) {\n \t\t\t\tf.addAttr(FieldInitAttr.NULL_VALUE);\n \t\t\t}\n \t\t}\n@@ -281,10 +280,19 @@ public ICodeInfo getCode() {\n \n \tpublic synchronized ICodeInfo reloadCode() {\n \t\tunload();\n+\t\tdeepUnload();\n+\t\treturn decompile(false);\n+\t}\n+\n+\tprivate void deepUnload() {\n \t\tclearAttributes();\n+\t\troot().getConstValues().removeForClass(this);\n \t\tinitialLoad();\n-\t\tload();\n-\t\treturn decompile(false);\n+\t\tProcessAnonymous.runForClass(this);\n+\n+\t\tfor (ClassNode innerClass : innerClasses) {\n+\t\t\tinnerClass.deepUnload();\n+\t\t}\n \t}\n \n \tprivate synchronized ICodeInfo decompile(boolean searchInCache) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ProcessAnonymous.java\n@@ -5,27 +5,29 @@\n import jadx.core.dex.nodes.FieldNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.RootNode;\n-import jadx.core.dex.visitors.regions.RegionMakerVisitor;\n \n @JadxVisitor(\n \t\tname = \"ProcessAnonymous\",\n-\t\tdesc = \"Mark anonymous and lambda classes (for future inline)\",\n-\t\trunAfter = RegionMakerVisitor.class\n+\t\tdesc = \"Mark anonymous and lambda classes (for future inline)\"\n )\n public class ProcessAnonymous extends AbstractVisitor {\n \n \t@Override\n \tpublic void init(RootNode root) {\n-\t\tif (!root.getArgs().isInlineAnonymousClasses()) {\n-\t\t\treturn;\n+\t\tif (root.getArgs().isInlineAnonymousClasses()) {\n+\t\t\tfor (ClassNode cls : root.getClasses(true)) {\n+\t\t\t\tmarkAnonymousClass(cls);\n+\t\t\t}\n \t\t}\n+\t}\n \n-\t\tfor (ClassNode cls : root.getClasses(true)) {\n+\tpublic static void runForClass(ClassNode cls) {\n+\t\tif (cls.root().getArgs().isInlineAnonymousClasses()) {\n \t\t\tmarkAnonymousClass(cls);\n \t\t}\n \t}\n \n-\tprivate static boolean markAnonymousClass(ClassNode cls) {\n+\tprivate static void markAnonymousClass(ClassNode cls) {\n \t\tif (isAnonymous(cls) || isLambdaCls(cls)) {\n \t\t\tcls.add(AFlag.ANONYMOUS_CLASS);\n \t\t\tcls.add(AFlag.DONT_GENERATE);\n@@ -35,9 +37,7 @@ private static boolean markAnonymousClass(ClassNode cls) {\n \t\t\t\t\tmth.add(AFlag.ANONYMOUS_CONSTRUCTOR);\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn true;\n \t\t}\n-\t\treturn false;\n \t}\n \n \tprivate static boolean isAnonymous(ClassNode cls) {\n@@ -62,5 +62,4 @@ private static int countStaticFields(ClassNode cls) {\n \t\t}\n \t\treturn c;\n \t}\n-\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/rename/TestAnonymousInline.java b/jadx-core/src/test/java/jadx/tests/integration/rename/TestAnonymousInline.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/rename/TestAnonymousInline.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/rename/TestAnonymousInline.java\n@@ -0,0 +1,34 @@\n+package jadx.tests.integration.rename;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestAnonymousInline extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic Runnable test() {\n+\t\t\treturn new Runnable() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void run() {\n+\t\t\t\t\tSystem.out.println(\"run\");\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tassertThat(cls.getCode())\n+\t\t\t\t.containsOnlyOnce(\"return new Runnable() {\");\n+\n+\t\tassertThat(cls.reloadCode())\n+\t\t\t\t.print()\n+\t\t\t\t.containsOnlyOnce(\"return new Runnable() {\")\n+\t\t\t\t.doesNotContain(\"AnonymousClass1\");\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/rename/TestConstReplace.java b/jadx-core/src/test/java/jadx/tests/integration/rename/TestConstReplace.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/rename/TestConstReplace.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/rename/TestConstReplace.java\n@@ -0,0 +1,30 @@\n+package jadx.tests.integration.rename;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestConstReplace extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic static final String CONST = \"SOME_CONST\";\n+\n+\t\tpublic String test() {\n+\t\t\treturn CONST;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tassertThat(cls.getCode())\n+\t\t\t\t.containsOnlyOnce(\"return CONST;\");\n+\n+\t\tassertThat(cls.reloadCode())\n+\t\t\t\t.print()\n+\t\t\t\t.containsOnlyOnce(\"return CONST;\");\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/rename/TestRenameEnum.java b/jadx-core/src/test/java/jadx/tests/integration/rename/TestRenameEnum.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/rename/TestRenameEnum.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/rename/TestRenameEnum.java\n@@ -0,0 +1,44 @@\n+package jadx.tests.integration.rename;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestRenameEnum extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic enum A implements Runnable {\n+\t\t\tONE {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void run() {\n+\t\t\t\t\tSystem.out.println(\"ONE\");\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\tTWO {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void run() {\n+\t\t\t\t\tSystem.out.println(\"TWO\");\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tassertThat(cls.getCode())\n+\t\t\t\t.containsOnlyOnce(\"public enum A \")\n+\t\t\t\t.containsOnlyOnce(\"ONE {\");\n+\n+\t\tcls.getInnerClasses().get(0).getClassInfo().changeShortName(\"ARenamed\");\n+\n+\t\tassertThat(cls.reloadCode())\n+\t\t\t\t.print()\n+\t\t\t\t.containsOnlyOnce(\"public enum ARenamed \")\n+\t\t\t\t.containsOnlyOnce(\"ONE {\");\n+\t}\n+}",
    "output": "Fix deep reload for inner classes, const values and anonymous classes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -1,5 +1,6 @@\n package jadx.core.dex.nodes;\n \n+import java.io.StringWriter;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n@@ -533,11 +534,24 @@ public String getPackage() {\n \n \tpublic String getSmali() {\n \t\tif (smali == null) {\n-\t\t\tsmali = SmaliUtils.getSmaliCode(dex, clsDefOffset);\n+\t\t\tStringWriter stringWriter = new StringWriter(4096);\n+\t\t\tgetSmali(this, stringWriter);\n+\t\t\tstringWriter.append(System.lineSeparator());\n+\t\t\tfor (ClassNode innerClass : innerClasses) {\n+\t\t\t\tgetSmali(innerClass, stringWriter);\n+\t\t\t\tstringWriter.append(System.lineSeparator());\n+\t\t\t}\n+\t\t\tsmali = stringWriter.toString();\n \t\t}\n \t\treturn smali;\n \t}\n \n+\tprotected static boolean getSmali(ClassNode classNode, StringWriter stringWriter) {\n+\t\tstringWriter.append(String.format(\"###### Class %s (%s)\", classNode.getFullName(), classNode.getRawName()));\n+\t\tstringWriter.append(System.lineSeparator());\n+\t\treturn SmaliUtils.getSmaliCode(classNode.dex, classNode.clsDefOffset, stringWriter);\n+\t}\n+\n \tpublic ProcessState getState() {\n \t\treturn state;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/SmaliUtils.java b/jadx-core/src/main/java/jadx/core/utils/SmaliUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/SmaliUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/SmaliUtils.java\n@@ -4,7 +4,6 @@\n import java.io.StringWriter;\n import java.nio.file.Path;\n \n-import org.jetbrains.annotations.NotNull;\n import org.jf.baksmali.Adaptors.ClassDefinition;\n import org.jf.baksmali.BaksmaliOptions;\n import org.jf.dexlib2.DexFileFactory;\n@@ -34,24 +33,25 @@ public static void assembleDex(String outputDexFile, String inputSmali) {\n \t\t}\n \t}\n \n-\t@NotNull\n-\tpublic static String getSmaliCode(DexNode dex, int clsDefOffset) {\n+\tpublic static boolean getSmaliCode(DexNode dex, int clsDefOffset, StringWriter stringWriter) {\n \t\ttry {\n \t\t\tPath path = dex.getDexFile().getPath();\n \t\t\tDexBackedDexFile dexFile = DexFileFactory.loadDexFile(path.toFile(), null);\n \t\t\tDexBackedClassDef dexBackedClassDef = new DexBackedClassDef(dexFile, clsDefOffset);\n-\t\t\treturn getSmaliCode(dexBackedClassDef);\n+\t\t\tgetSmaliCode(dexBackedClassDef, stringWriter);\n+\t\t\treturn true;\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Error generating smali\", e);\n-\t\t\treturn \"Error generating smali code: \" + e.getMessage()\n-\t\t\t\t\t+ '\\n' + Utils.getStackTrace(e);\n+\t\t\tstringWriter.append(\"Error generating smali code: \");\n+\t\t\tstringWriter.append(e.getMessage());\n+\t\t\tstringWriter.append(System.lineSeparator());\n+\t\t\tstringWriter.append(Utils.getStackTrace(e));\n+\t\t\treturn false;\n \t\t}\n \t}\n \n-\tprivate static String getSmaliCode(DexBackedClassDef classDef) throws IOException {\n+\tprivate static void getSmaliCode(DexBackedClassDef classDef, StringWriter stringWriter) throws IOException {\n \t\tClassDefinition classDefinition = new ClassDefinition(new BaksmaliOptions(), classDef);\n-\t\tStringWriter sw = new StringWriter();\n-\t\tclassDefinition.writeTo(new IndentingWriter(sw));\n-\t\treturn sw.toString();\n+\t\tclassDefinition.writeTo(new IndentingWriter(stringWriter));\n \t}\n }",
    "output": "Fix additionally show smali code of inner classes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstructorVisitor.java\n@@ -2,6 +2,8 @@\n \n import java.util.ArrayList;\n \n+import org.jetbrains.annotations.Nullable;\n+\n import jadx.core.codegen.TypeGen;\n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.instructions.InsnType;\n@@ -105,8 +107,12 @@ private static void processInvoke(MethodNode mth, BlockNode block, int indexInBl\n \t}\n \n \t/**\n-\t * Replace call of synthetic constructor\n+\t * Replace call of synthetic constructor with all 'null' args\n+\t * to a non-synthetic or default constructor if possible.\n+\t *\n+\t * @return insn for replacement or null if replace not needed or not possible.\n \t */\n+\t@Nullable\n \tprivate static ConstructorInsn processConstructor(MethodNode mth, ConstructorInsn co) {\n \t\tMethodNode callMth = mth.dex().resolveMethod(co.getCallMth());\n \t\tif (callMth == null\n@@ -125,11 +131,11 @@ private static ConstructorInsn processConstructor(MethodNode mth, ConstructorIns\n \t\tboolean passThis = instanceArg.isThis();\n \t\tString ctrId = \"<init>(\" + (passThis ? TypeGen.signature(instanceArg.getInitType()) : \"\") + \")V\";\n \t\tMethodNode defCtr = classNode.searchMethodByShortId(ctrId);\n-\t\tif (defCtr == null) {\n+\t\tif (defCtr == null || defCtr.equals(callMth) || defCtr.getAccessFlags().isSynthetic()) {\n \t\t\treturn null;\n \t\t}\n \t\tConstructorInsn newInsn = new ConstructorInsn(defCtr.getMethodInfo(), co.getCallType());\n-\t\tnewInsn.setResult(co.getResult());\n+\t\tnewInsn.setResult(co.getResult().duplicate());\n \t\treturn newInsn;\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestSyntheticConstructor.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestSyntheticConstructor.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestSyntheticConstructor.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestSyntheticConstructor.java\n@@ -0,0 +1,27 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestSyntheticConstructor extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tpublic class Test {\n+\t\t\tstatic {\n+\t\t\t\tnew BuggyConstructor();\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tassertThat(getClassNodeFromSmaliFiles(\"Test\"))\n+\t\t\t\t.code()\n+\t\t\t\t.containsLine(2, \"new BuggyConstructor();\");\n+\t}\n+}",
    "output": "Fix make correct replacement for synthetic constructor"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java b/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java\n@@ -54,10 +54,10 @@ public TextSearchIndex(JNodeCache nodeCache) {\n \tpublic void indexNames(JavaClass cls) {\n \t\tclsNamesIndex.put(cls.getFullName(), nodeCache.makeFrom(cls));\n \t\tfor (JavaMethod mth : cls.getMethods()) {\n-\t\t\tmthNamesIndex.put(mth.getFullName(), nodeCache.makeFrom(mth));\n+\t\t\tmthNamesIndex.put(mth.getName(), nodeCache.makeFrom(mth));\n \t\t}\n \t\tfor (JavaField fld : cls.getFields()) {\n-\t\t\tfldNamesIndex.put(fld.getFullName(), nodeCache.makeFrom(fld));\n+\t\t\tfldNamesIndex.put(fld.getName(), nodeCache.makeFrom(fld));\n \t\t}\n \t\tfor (JavaClass innerCls : cls.getInnerClasses()) {\n \t\t\tindexNames(innerCls);",
    "output": "Fix search only in short names of methods and fields"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n@@ -149,6 +149,13 @@ public JadxArgs getArgs() {\n \t\t\t\t.orElse(null);\n \t}\n \n+\tpublic @Nullable JavaClass searchJavaClassByOrigClassName(String fullName) {\n+\t\treturn decompiler.getClasses().stream()\n+\t\t\t\t.filter(cls -> cls.getClassNode().getClassInfo().getFullName().equals(fullName))\n+\t\t\t\t.findFirst()\n+\t\t\t\t.orElse(null);\n+\t}\n+\n \t/**\n \t * @param rawName Full raw name of an outer class. Inner classes are not supported.\n \t */\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -208,14 +208,17 @@ private void processCommandLineArgs() {\n \tprivate void handleSelectClassOption() {\n \t\tif (settings.getCmdSelectClass() != null) {\n \t\t\tJavaNode javaNode = wrapper.searchJavaClassByClassName(settings.getCmdSelectClass());\n+\t\t\tif (javaNode == null) {\n+\t\t\t\tjavaNode = wrapper.searchJavaClassByOrigClassName(settings.getCmdSelectClass());\n+\t\t\t}\n \t\t\tif (javaNode == null) {\n \t\t\t\tJOptionPane.showMessageDialog(this,\n \t\t\t\t\t\tNLS.str(\"msg.cmd_select_class_error\", settings.getCmdSelectClass()),\n \t\t\t\t\t\tNLS.str(\"error_dialog.title\"), JOptionPane.ERROR_MESSAGE);\n-\t\t\t} else {\n-\t\t\t\tJNode node = cacheObject.getNodeCache().makeFrom(javaNode);\n-\t\t\t\ttabbedPane.codeJump(new JumpPosition(node.getRootClass(), node.getLine()));\n+\t\t\t\treturn;\n \t\t\t}\n+\t\t\tJNode node = cacheObject.getNodeCache().makeFrom(javaNode);\n+\t\t\ttabbedPane.codeJump(new JumpPosition(node.getRootClass(), node.getLine()));\n \t\t}\n \t}",
    "output": "Fix search class with --select-class also by not deobfuscated names"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n@@ -130,7 +130,13 @@ private static void assignInline(MethodNode mth, RegisterArg arg, InsnNode assig\n \t\t\treturn;\n \t\t}\n \n-\t\tInsnArg replaceArg = InsnArg.wrapArg(assignInsn.copy());\n+\t\tInsnArg replaceArg;\n+\t\tInsnType assignInsnType = assignInsn.getType();\n+\t\tif (assignInsnType == InsnType.MOVE || assignInsnType == InsnType.CONST) {\n+\t\t\treplaceArg = assignInsn.getArg(0).duplicate();\n+\t\t} else {\n+\t\t\treplaceArg = InsnArg.wrapArg(assignInsn.copy());\n+\t\t}\n \t\tuseInsn.replaceArg(useArg, replaceArg);\n \n \t\tassignInsn.add(AFlag.REMOVE);",
    "output": "Fix resolve exception on assign inline"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -467,7 +467,9 @@ private void makeInsnBody(CodeWriter code, InsnNode insn, Set<Flags> state) thro\n \t\t\tcase MONITOR_EXIT:\n \t\t\t\tif (isFallback()) {\n \t\t\t\t\tcode.add(\"monitor-exit(\");\n-\t\t\t\t\taddArg(code, insn.getArg(0));\n+\t\t\t\t\tif (insn.getArgsCount() == 1) {\n+\t\t\t\t\t\taddArg(code, insn.getArg(0));\n+\t\t\t\t\t}\n \t\t\t\t\tcode.add(')');\n \t\t\t\t}\n \t\t\t\tbreak;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java\n@@ -155,6 +155,10 @@ static IfInfo mergeNestedIfNodes(IfInfo currentIf) {\n \t\tif (curThen == curElse) {\n \t\t\treturn null;\n \t\t}\n+\t\tif (BlockUtils.isFollowBackEdge(curThen)\n+\t\t\t\t|| BlockUtils.isFollowBackEdge(curElse)) {\n+\t\t\treturn null;\n+\t\t}\n \t\tboolean followThenBranch;\n \t\tIfInfo nextIf = getNextIf(currentIf, curThen);\n \t\tif (nextIf != null) {\n@@ -380,6 +384,9 @@ private static IfInfo getNextIfNodeInfo(IfInfo info, BlockNode block) {\n \t\tif (next.getPredecessors().size() != 1) {\n \t\t\treturn null;\n \t\t}\n+\t\tif (next.contains(AFlag.ADDED_TO_REGION)) {\n+\t\t\treturn null;\n+\t\t}\n \t\tList<InsnNode> insns = block.getInstructions();\n \t\tboolean pass = true;\n \t\tList<InsnNode> forceInlineInsns = new ArrayList<>();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -14,6 +14,7 @@\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.IgnoreEdgeAttr;\n+import jadx.core.dex.attributes.nodes.LoopInfo;\n import jadx.core.dex.attributes.nodes.PhiListAttr;\n import jadx.core.dex.instructions.IfNode;\n import jadx.core.dex.instructions.InsnType;\n@@ -137,6 +138,27 @@ public static boolean isBackEdge(BlockNode from, BlockNode to) {\n \t\treturn from.getSuccessors().contains(to);\n \t}\n \n+\tpublic static boolean isFollowBackEdge(BlockNode block) {\n+\t\tif (block == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (block.contains(AFlag.LOOP_START)) {\n+\t\t\tList<BlockNode> predecessors = block.getPredecessors();\n+\t\t\tif (predecessors.size() == 1) {\n+\t\t\t\tBlockNode loopEndBlock = predecessors.get(0);\n+\t\t\t\tif (loopEndBlock.contains(AFlag.LOOP_END)) {\n+\t\t\t\t\tList<LoopInfo> loops = loopEndBlock.getAll(AType.LOOP);\n+\t\t\t\t\tfor (LoopInfo loop : loops) {\n+\t\t\t\t\t\tif (loop.getStart().equals(block) && loop.getEnd().equals(loopEndBlock)) {\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \t/**\n \t * Check if instruction contains in block (use == for comparison, not equals)\n \t */\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak2.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak2.java\n@@ -0,0 +1,47 @@\n+package jadx.tests.integration.loops;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestDoWhileBreak2 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tIterator<String> it;\n+\n+\t\t@SuppressWarnings(\"ConstantConditions\")\n+\t\tpublic Object test() {\n+\t\t\tString obj;\n+\t\t\tdo {\n+\t\t\t\tobj = this.it.next();\n+\t\t\t\tif (obj == null) {\n+\t\t\t\t\treturn obj; // 'return null' works\n+\t\t\t\t}\n+\t\t\t} while (this.it.hasNext());\n+\t\t\treturn obj;\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tthis.it = Arrays.asList(\"a\", \"b\").iterator();\n+\t\t\tassertThat(test()).isEqualTo(\"b\");\n+\n+\t\t\tthis.it = Arrays.asList(\"a\", \"b\", null).iterator();\n+\t\t\tassertThat(test()).isEqualTo(null);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsLine(2, \"do {\")\n+\t\t\t\t.containsLine(3, \"obj = this.it.next();\")\n+\t\t\t\t.containsLine(3, \"if (obj == null) {\")\n+\t\t\t\t.containsLine(2, \"} while (this.it.hasNext());\");\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak3.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestDoWhileBreak3.java\n@@ -0,0 +1,33 @@\n+package jadx.tests.integration.loops;\n+\n+import java.util.Iterator;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.NotYetImplemented;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestDoWhileBreak3 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tIterator<String> it;\n+\n+\t\tpublic void test() {\n+\t\t\tdo {\n+\t\t\t\tif (!it.hasNext()) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t} while (it.next() != null);\n+\t\t}\n+\t}\n+\n+\t@NotYetImplemented\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNode(TestCls.class))\n+\t\t\t\t.code()\n+\t\t\t\t.containsOnlyOnce(\"while\");\n+\t}\n+}",
    "output": "Fix additional checks for 'if' blocks inside loops"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n--- a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n+++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundExecutor.java\n@@ -79,7 +79,7 @@ public void init() {\n \n \t\t@Override\n \t\tprotected Boolean doInBackground() throws Exception {\n-\t\t\tprogressPane.changeLabel(this, task.getTitle() + ':');\n+\t\t\tprogressPane.changeLabel(this, task.getTitle() + \"… \");\n \t\t\tprogressPane.changeCancelBtnVisible(this, task.canBeCanceled());\n \t\t\tprogressPane.changeVisibility(this, true);\n \n@@ -125,7 +125,8 @@ private boolean waitTermination(ThreadPoolExecutor executor) throws InterruptedE\n \t\t\t\t}\n \t\t\t\tif (isCancelled()) {\n \t\t\t\t\texecutor.shutdownNow();\n-\t\t\t\t\tprogressPane.changeLabel(this, task.getTitle() + \" (Canceling):\");\n+\t\t\t\t\tprogressPane.changeLabel(this, task.getTitle() + \" (Canceling)… \");\n+\t\t\t\t\tprogressPane.changeIndeterminate(this, true);\n \t\t\t\t\t// force termination\n \t\t\t\t\texecutor.awaitTermination(5, TimeUnit.SECONDS);\n \t\t\t\t\treturn false;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java b/jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java\n--- a/jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java\n+++ b/jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java\n@@ -19,6 +19,6 @@ protected void runJob() {\n \n \t@Override\n \tpublic String getInfoString() {\n-\t\treturn NLS.str(\"progress.decompile\");\n+\t\treturn NLS.str(\"progress.decompile\") + \"… \";\n \t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java\n--- a/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java\n+++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java\n@@ -68,6 +68,6 @@ protected List<StringRef> splitLines(JavaClass cls) {\n \n \t@Override\n \tpublic String getInfoString() {\n-\t\treturn NLS.str(\"progress.index\");\n+\t\treturn NLS.str(\"progress.index\") + \"… \";\n \t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/ProgressPanel.java b/jadx-gui/src/main/java/jadx/gui/ui/ProgressPanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/ProgressPanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/ProgressPanel.java\n@@ -79,6 +79,10 @@ public void propertyChange(PropertyChangeEvent evt) {\n \t\t\t\tsetVisible(((Boolean) evt.getNewValue()));\n \t\t\t\tbreak;\n \n+\t\t\tcase \"indeterminate\":\n+\t\t\t\tsetIndeterminate(((Boolean) evt.getNewValue()));\n+\t\t\t\tbreak;\n+\n \t\t\tcase \"cancel-visible\":\n \t\t\t\tcancelButton.setVisible(((Boolean) evt.getNewValue()));\n \t\t\t\tbreak;\n@@ -97,6 +101,10 @@ public void changeLabel(SwingWorker<?, ?> task, String label) {\n \t\ttask.firePropertyChange(\"label\", null, label);\n \t}\n \n+\tpublic void changeIndeterminate(SwingWorker<?, ?> task, boolean indeterminate) {\n+\t\ttask.firePropertyChange(\"indeterminate\", null, indeterminate);\n+\t}\n+\n \tpublic void changeVisibility(SwingWorker<?, ?> task, boolean visible) {\n \t\ttask.firePropertyChange(\"visible\", null, visible);\n \t}",
    "output": "Add dots for progress titles"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -200,16 +200,19 @@ private void processCommandLineArgs() {\n \t\t\topenFileOrProject();\n \t\t} else {\n \t\t\topen(Paths.get(settings.getFiles().get(0)));\n-\t\t\tif (settings.getCmdSelectClass() != null) {\n-\t\t\t\tJavaNode javaNode = wrapper.searchJavaClassByClassName(settings.getCmdSelectClass());\n-\t\t\t\tif (javaNode == null) {\n-\t\t\t\t\tJOptionPane.showMessageDialog(this,\n-\t\t\t\t\t\t\tNLS.str(\"msg.cmd_select_class_error\", settings.getCmdSelectClass()),\n-\t\t\t\t\t\t\tNLS.str(\"error_dialog.title\"), JOptionPane.ERROR_MESSAGE);\n-\t\t\t\t} else {\n-\t\t\t\t\tJNode node = cacheObject.getNodeCache().makeFrom(javaNode);\n-\t\t\t\t\ttabbedPane.codeJump(new JumpPosition(node.getRootClass(), node.getLine()));\n-\t\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void handleSelectClassOption() {\n+\t\tif (settings.getCmdSelectClass() != null) {\n+\t\t\tJavaNode javaNode = wrapper.searchJavaClassByClassName(settings.getCmdSelectClass());\n+\t\t\tif (javaNode == null) {\n+\t\t\t\tJOptionPane.showMessageDialog(this,\n+\t\t\t\t\t\tNLS.str(\"msg.cmd_select_class_error\", settings.getCmdSelectClass()),\n+\t\t\t\t\t\tNLS.str(\"error_dialog.title\"), JOptionPane.ERROR_MESSAGE);\n+\t\t\t} else {\n+\t\t\t\tJNode node = cacheObject.getNodeCache().makeFrom(javaNode);\n+\t\t\t\ttabbedPane.codeJump(new JumpPosition(node.getRootClass(), node.getLine()));\n \t\t\t}\n \t\t}\n \t}\n@@ -313,6 +316,7 @@ void open(Path path) {\n \t\t\t\t\t\tdeobfToggleBtn.setSelected(settings.isDeobfuscationOn());\n \t\t\t\t\t\tinitTree();\n \t\t\t\t\t\tupdate();\n+\t\t\t\t\t\thandleSelectClassOption();\n \t\t\t\t\t\trunBackgroundJobs();\n \t\t\t\t\t});\n \t\t}",
    "output": "Fix resolve --select-class option regression"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JavaClass.java b/jadx-core/src/main/java/jadx/api/JavaClass.java\n--- a/jadx-core/src/main/java/jadx/api/JavaClass.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java\n@@ -73,7 +73,7 @@ public ClassNode getClassNode() {\n \t\treturn cls;\n \t}\n \n-\tprivate void loadLists() {\n+\tprivate synchronized void loadLists() {\n \t\tif (listsLoaded) {\n \t\t\treturn;\n \t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java b/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n@@ -6,6 +6,9 @@\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import jadx.api.CodePosition;\n import jadx.api.JavaClass;\n import jadx.api.JavaNode;\n@@ -14,6 +17,7 @@\n import jadx.gui.utils.search.StringRef;\n \n public class CodeUsageInfo {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(CodeUsageInfo.class);\n \n \tpublic static class UsageInfo {\n \t\tprivate final List<CodeNode> usageList = new ArrayList<>();\n@@ -36,11 +40,15 @@ public CodeUsageInfo(JNodeCache nodeCache) {\n \tprivate final Map<JNode, UsageInfo> usageMap = new ConcurrentHashMap<>();\n \n \tpublic void processClass(JavaClass javaClass, CodeLinesInfo linesInfo, List<StringRef> lines) {\n-\t\tMap<CodePosition, JavaNode> usage = javaClass.getUsageMap();\n-\t\tfor (Map.Entry<CodePosition, JavaNode> entry : usage.entrySet()) {\n-\t\t\tCodePosition codePosition = entry.getKey();\n-\t\t\tJavaNode javaNode = entry.getValue();\n-\t\t\taddUsage(nodeCache.makeFrom(javaNode), javaClass, linesInfo, codePosition, lines);\n+\t\ttry {\n+\t\t\tMap<CodePosition, JavaNode> usage = javaClass.getUsageMap();\n+\t\t\tfor (Map.Entry<CodePosition, JavaNode> entry : usage.entrySet()) {\n+\t\t\t\tCodePosition codePosition = entry.getKey();\n+\t\t\t\tJavaNode javaNode = entry.getValue();\n+\t\t\t\taddUsage(nodeCache.makeFrom(javaNode), javaClass, linesInfo, codePosition, lines);\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"Code usage process failed for class: {}\", javaClass, e);\n \t\t}\n \t}",
    "output": "Fix resolve exceptions during index"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java\n@@ -9,7 +9,6 @@\n \n import jadx.api.ICodeInfo;\n import jadx.api.ResourceFile;\n-import jadx.core.codegen.CodeWriter;\n \n public class ResContainer implements Comparable<ResContainer> {\n \n@@ -34,7 +33,7 @@ public static ResContainer resourceFileLink(ResourceFile resFile) {\n \t\treturn new ResContainer(resFile.getName(), Collections.emptyList(), resFile, DataType.RES_LINK);\n \t}\n \n-\tpublic static ResContainer resourceTable(String name, List<ResContainer> subFiles, CodeWriter rootContent) {\n+\tpublic static ResContainer resourceTable(String name, List<ResContainer> subFiles, ICodeInfo rootContent) {\n \t\treturn new ResContainer(name, subFiles, rootContent, DataType.RES_TABLE);\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -10,6 +10,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.api.ICodeInfo;\n import jadx.core.codegen.CodeWriter;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.nodes.FieldNode;\n@@ -73,12 +74,12 @@ public ResContainer decodeFiles(InputStream inputStream) throws IOException {\n \t\tValuesParser vp = new ValuesParser(root, strings, resStorage.getResourcesNames());\n \t\tResXmlGen resGen = new ResXmlGen(resStorage, vp);\n \n-\t\tCodeWriter content = makeXmlDump();\n+\t\tICodeInfo content = makeXmlDump();\n \t\tList<ResContainer> xmlFiles = resGen.makeResourcesXml();\n \t\treturn ResContainer.resourceTable(\"res\", xmlFiles, content);\n \t}\n \n-\tpublic CodeWriter makeXmlDump() {\n+\tpublic ICodeInfo makeXmlDump() {\n \t\tCodeWriter writer = new CodeWriter();\n \t\twriter.startLine(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\");\n \t\twriter.startLine(\"<resources>\");\n@@ -94,8 +95,7 @@ public CodeWriter makeXmlDump() {\n \t\t}\n \t\twriter.decIndent();\n \t\twriter.startLine(\"</resources>\");\n-\t\twriter.finish();\n-\t\treturn writer;\n+\t\treturn writer.finish();\n \t}\n \n \tpublic ResourceStorage getResStorage() {",
    "output": "Fix resolve class cast exception introduced in CodeWriter refactoring"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/NLS.java b/jadx-gui/src/main/java/jadx/gui/utils/NLS.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/NLS.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/NLS.java\n@@ -34,6 +34,7 @@ public class NLS {\n \t\tLANG_LOCALES.add(new LangLocale(\"en\", \"US\")); // As default language\n \t\tLANG_LOCALES.add(new LangLocale(\"zh\", \"CN\"));\n \t\tLANG_LOCALES.add(new LangLocale(\"es\", \"ES\"));\n+\t\tLANG_LOCALES.add(new LangLocale(\"de\", \"DE\"));\n \n \t\tLANG_LOCALES.forEach(NLS::load);",
    "output": "Add Deutsch to locales list"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n@@ -82,6 +82,10 @@ private static void checkInsn(MethodNode mth, InsnNode insn, List<InsnNode> toRe\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n+\t\t\t// don't inline const values in synchronized statement\n+\t\t\tif (checkForSynchronizeBlock(insn, sVar)) {\n+\t\t\t\treturn;\n+\t\t\t}\n \t\t} else if (insnType == InsnType.CONST_STR) {\n \t\t\tif (sVar.isUsedInPhi()) {\n \t\t\t\treturn;\n@@ -108,6 +112,20 @@ private static void checkInsn(MethodNode mth, InsnNode insn, List<InsnNode> toRe\n \t\treplaceConst(mth, insn, constArg, toRemove);\n \t}\n \n+\tprivate static boolean checkForSynchronizeBlock(InsnNode insn, SSAVar ssaVar) {\n+\t\tfor (RegisterArg reg : ssaVar.getUseList()) {\n+\t\t\tInsnNode parentInsn = reg.getParentInsn();\n+\t\t\tif (parentInsn != null) {\n+\t\t\t\tInsnType insnType = parentInsn.getType();\n+\t\t\t\tif (insnType == InsnType.MONITOR_ENTER || insnType == InsnType.MONITOR_EXIT) {\n+\t\t\t\t\tinsn.add(AFlag.DONT_INLINE);\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tprivate static boolean checkForFinallyBlock(SSAVar sVar) {\n \t\tList<SSAVar> ssaVars = sVar.getCodeVar().getSsaVars();\n \t\tif (ssaVars.size() <= 1) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -608,6 +608,7 @@ private static void traverseMonitorExits(SynchronizedRegion region, InsnArg arg,\n \t\tvisited.add(block);\n \t\tfor (InsnNode insn : block.getInstructions()) {\n \t\t\tif (insn.getType() == InsnType.MONITOR_EXIT\n+\t\t\t\t\t&& insn.getArgsCount() > 0\n \t\t\t\t\t&& insn.getArg(0).equals(arg)) {\n \t\t\t\texits.add(block);\n \t\t\t\tregion.getExitInsns().add(insn);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java\n--- a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxClassNodeAssertions.java\n@@ -16,6 +16,8 @@ public JadxCodeAssertions code() {\n \t\tisNotNull();\n \t\tICodeInfo code = actual.getCode();\n \t\tassertThat(code).isNotNull();\n-\t\treturn new JadxCodeAssertions(code.getCodeStr());\n+\t\tString codeStr = code.getCodeStr();\n+\t\tassertThat(codeStr).isNotBlank();\n+\t\treturn new JadxCodeAssertions(codeStr);\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestNestedSynchronize.java b/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestNestedSynchronize.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestNestedSynchronize.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestNestedSynchronize.java\n@@ -0,0 +1,30 @@\n+package jadx.tests.integration.synchronize;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestNestedSynchronize extends SmaliTest {\n+\n+\t// @formatter:off\n+\t/*\n+\t\tpublic final void test() {\n+\t\t\tObject obj = null;\n+\t\t\tObject obj2 = null;\n+\t\t\tsynchronized (obj) {\n+\t\t\t\tsynchronized (obj2) {\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tassertThat(getClassNodeFromSmali())\n+\t\t\t\t.code()\n+\t\t\t\t.countString(2, \"synchronized\");\n+\t}\n+}",
    "output": "Fix don't inline constants in synchronized statement"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -660,7 +660,7 @@ public void actionPerformed(ActionEvent e) {\n \t\tAction exitAction = new AbstractAction(NLS.str(\"file.exit\"), ICON_CLOSE) {\n \t\t\t@Override\n \t\t\tpublic void actionPerformed(ActionEvent e) {\n-\t\t\t\tdispose();\n+\t\t\t\tcloseWindow();\n \t\t\t}\n \t\t};",
    "output": "Fix correct app close on menu exit action"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -40,7 +40,7 @@\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n import static jadx.core.dex.nodes.ProcessState.LOADED;\n-import static jadx.core.dex.nodes.ProcessState.UNLOADED;\n+import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;\n \n public class ClassNode extends LineAttrNode implements ILoadable, ICodeNode {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ClassNode.class);\n@@ -262,23 +262,33 @@ public void ensureProcessed() {\n \t\t}\n \t}\n \n-\tpublic synchronized ICodeInfo decompile() {\n+\tpublic ICodeInfo decompile() {\n+\t\treturn decompile(true);\n+\t}\n+\n+\tpublic ICodeInfo getCode() {\n+\t\treturn decompile(true);\n+\t}\n+\n+\tpublic ICodeInfo reloadCode() {\n+\t\treturn decompile(false);\n+\t}\n+\n+\tprivate synchronized ICodeInfo decompile(boolean searchInCache) {\n \t\tICodeCache codeCache = root().getCodeCache();\n \t\tClassNode topParentClass = getTopParentClass();\n \t\tString clsRawName = topParentClass.getRawName();\n-\t\tICodeInfo code = codeCache.get(clsRawName);\n-\t\tif (code != null) {\n-\t\t\treturn code;\n+\t\tif (searchInCache) {\n+\t\t\tICodeInfo code = codeCache.get(clsRawName);\n+\t\t\tif (code != null) {\n+\t\t\t\treturn code;\n+\t\t\t}\n \t\t}\n \t\tICodeInfo codeInfo = ProcessClass.generateCode(topParentClass);\n \t\tcodeCache.add(clsRawName, codeInfo);\n \t\treturn codeInfo;\n \t}\n \n-\tpublic ICodeInfo getCode() {\n-\t\treturn decompile();\n-\t}\n-\n \t@Override\n \tpublic void load() {\n \t\tfor (MethodNode mth : getMethods()) {\n@@ -300,7 +310,7 @@ public void unload() {\n \t\tinnerClasses.forEach(ClassNode::unload);\n \t\tfields.forEach(FieldNode::unloadAttributes);\n \t\tunloadAttributes();\n-\t\tsetState(UNLOADED);\n+\t\tsetState(NOT_LOADED);\n \t}\n \n \tprivate void buildCache() {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ProcessState.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ProcessState.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ProcessState.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ProcessState.java\n@@ -4,15 +4,13 @@ public enum ProcessState {\n \tNOT_LOADED,\n \tLOADED,\n \tPROCESS_STARTED,\n-\tPROCESS_COMPLETE,\n-\tGENERATED,\n-\tUNLOADED;\n+\tPROCESS_COMPLETE;\n \n \tpublic boolean isLoaded() {\n \t\treturn this != NOT_LOADED;\n \t}\n \n \tpublic boolean isProcessed() {\n-\t\treturn this == PROCESS_COMPLETE || this == GENERATED || this == UNLOADED;\n+\t\treturn this == PROCESS_COMPLETE;\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java\n--- a/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/utils/assertj/JadxCodeAssertions.java\n@@ -51,4 +51,11 @@ public JadxCodeAssertions containsLines(int commonIndent, String... lines) {\n \t\t}\n \t\treturn countString(1, sb.toString());\n \t}\n+\n+\tpublic JadxCodeAssertions print() {\n+\t\tSystem.out.println(\"-----------------------------------------------------------\");\n+\t\tSystem.out.println(actual);\n+\t\tSystem.out.println(\"-----------------------------------------------------------\");\n+\t\treturn this;\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestClassReGen.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestClassReGen.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestClassReGen.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestClassReGen.java\n@@ -0,0 +1,41 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;\n+\n+public class TestClassReGen extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tprivate int intField = 5;\n+\n+\t\tpublic static class A {\n+\t\t}\n+\n+\t\tpublic int test() {\n+\t\t\treturn 0;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tassertThat(cls.getCode())\n+\t\t\t\t.containsOnlyOnce(\"private int intField = 5;\")\n+\t\t\t\t.containsOnlyOnce(\"public static class A {\")\n+\t\t\t\t.containsOnlyOnce(\"public int test() {\");\n+\n+\t\tcls.getInnerClasses().get(0).getClassInfo().changeShortName(\"ARenamed\");\n+\t\tcls.searchMethodByShortName(\"test\").getMethodInfo().setAlias(\"testRenamed\");\n+\t\tcls.searchFieldByName(\"intField\").getFieldInfo().setAlias(\"intFieldRenamed\");\n+\n+\t\tassertThat(cls.reloadCode())\n+\t\t\t\t.print()\n+\t\t\t\t.containsOnlyOnce(\"private int intFieldRenamed = 5;\")\n+\t\t\t\t.containsOnlyOnce(\"public static class ARenamed {\")\n+\t\t\t\t.containsOnlyOnce(\"public int testRenamed() {\");\n+\t}\n+}",
    "output": "Fix allow to regenerate class code"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -41,7 +41,7 @@ public class BinaryXMLParser extends CommonBinaryParser {\n \n \tprivate final Map<Integer, String> styleMap = new HashMap<>();\n \tprivate final Map<Integer, String> resNames;\n-\tprivate final Map<String, String> nsMap = new HashMap<>();\n+\tprivate Map<String, String> nsMap;\n \tprivate Set<String> nsMapGenerated;\n \tprivate final Map<String, String> tagAttrDeobfNames = new HashMap<>();\n \n@@ -86,11 +86,13 @@ public synchronized CodeWriter parse(InputStream inputStream) throws IOException\n \t\t\treturn ResourcesLoader.loadToCodeWriter(inputStream);\n \t\t}\n \t\tnsMapGenerated = new HashSet<>();\n+\t\tnsMap = new HashMap<>();\n \t\twriter = new CodeWriter();\n \t\twriter.add(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\");\n \t\tfirstElement = true;\n \t\tdecode();\n \t\twriter.finish();\n+\t\tnsMap = null;\n \t\treturn writer;\n \t}",
    "output": "Fix reset nsMap in parse method (PR #798 #796) Fixes injection of xmlns: attributes from other files"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -23,6 +23,7 @@\n import jadx.core.dex.nodes.FieldNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.RootNode;\n+import jadx.core.utils.files.FileUtils;\n import jadx.core.utils.files.InputFile;\n \n public class RenameVisitor extends AbstractVisitor {\n@@ -35,9 +36,7 @@ public void init(RootNode root) {\n \t\t}\n \t\tInputFile firstInputFile = dexNodes.get(0).getDexFile().getInputFile();\n \t\tPath inputFilePath = firstInputFile.getFile().getAbsoluteFile().toPath();\n-\n-\t\tString inputName = inputFilePath.getFileName().toString();\n-\t\tString baseName = inputName.substring(0, inputName.lastIndexOf('.'));\n+\t\tString baseName = FileUtils.getPathBaseName(inputFilePath);\n \t\tPath deobfMapPath = inputFilePath.getParent().resolve(baseName + \".jobf\");\n \n \t\tJadxArgs args = root.getArgs();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n@@ -232,6 +232,15 @@ private static boolean isZipFileCanBeOpen(File file) {\n \t\t}\n \t}\n \n+\tpublic static String getPathBaseName(Path file) {\n+\t\tString fileName = file.getFileName().toString();\n+\t\tint extEndIndex = fileName.lastIndexOf('.');\n+\t\tif (extEndIndex == -1) {\n+\t\t\treturn fileName;\n+\t\t}\n+\t\treturn fileName.substring(0, extEndIndex);\n+\t}\n+\n \tpublic static File toFile(String path) {\n \t\tif (path == null) {\n \t\t\treturn null;",
    "output": "Fix resolve error if input file don't has extension"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -10,6 +10,7 @@\n import java.util.Set;\n \n import com.android.dx.rop.code.AccessFlags;\n+import com.google.common.collect.Streams;\n \n import jadx.api.JadxArgs;\n import jadx.core.dex.attributes.AFlag;\n@@ -130,7 +131,8 @@ public void addClassDeclaration(CodeWriter clsCode) {\n \t\tannotationGen.addForClass(clsCode);\n \t\tinsertRenameInfo(clsCode, cls);\n \t\tCodeGenUtils.addSourceFileInfo(clsCode, cls);\n-\t\tclsCode.startLine(af.makeString());\n+\t\tclsCode.startLineWithNum(cls.getSourceLine());\n+\t\tclsCode.add(af.makeString());\n \t\tif (af.isInterface()) {\n \t\t\tif (af.isAnnotation()) {\n \t\t\t\tclsCode.add('@');\n@@ -222,21 +224,32 @@ public void addClassBody(CodeWriter clsCode) throws CodegenException {\n \t\tclsDeclLine = clsCode.getLine();\n \t\tclsCode.incIndent();\n \t\taddFields(clsCode);\n-\t\taddInnerClasses(clsCode, cls);\n-\t\taddMethods(clsCode);\n+\t\taddInnerClsAndMethods(clsCode);\n \t\tclsCode.decIndent();\n \t\tclsCode.startLine('}');\n \t}\n \n-\tprivate void addInnerClasses(CodeWriter code, ClassNode cls) throws CodegenException {\n-\t\tfor (ClassNode innerCls : cls.getInnerClasses()) {\n-\t\t\tif (innerCls.contains(AFlag.DONT_GENERATE)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+\tprivate void addInnerClsAndMethods(CodeWriter clsCode) {\n+\t\tStreams.concat(cls.getInnerClasses().stream(), cls.getMethods().stream())\n+\t\t\t\t.filter(node -> !node.contains(AFlag.DONT_GENERATE))\n+\t\t\t\t.sorted(Comparator.comparingInt(LineAttrNode::getSourceLine))\n+\t\t\t\t.forEach(node -> {\n+\t\t\t\t\tif (node instanceof ClassNode) {\n+\t\t\t\t\t\taddInnerClass(clsCode, (ClassNode) node);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddMethod(clsCode, (MethodNode) node);\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t}\n+\n+\tprivate void addInnerClass(CodeWriter code, ClassNode innerCls) {\n+\t\ttry {\n \t\t\tClassGen inClGen = new ClassGen(innerCls, getParentGen());\n \t\t\tcode.newLine();\n \t\t\tinClGen.addClassCode(code);\n \t\t\timports.addAll(inClGen.getImports());\n+\t\t} catch (Exception e) {\n+\t\t\tErrorsCounter.classError(innerCls, \"Inner class code generation error\", e);\n \t\t}\n \t}\n \n@@ -249,38 +262,26 @@ private boolean isInnerClassesPresents() {\n \t\treturn false;\n \t}\n \n-\tprivate void addMethods(CodeWriter code) {\n-\t\tList<MethodNode> methods = sortMethodsByLine(cls.getMethods());\n-\t\tfor (MethodNode mth : methods) {\n-\t\t\tif (mth.contains(AFlag.DONT_GENERATE)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tif (code.getLine() != clsDeclLine) {\n-\t\t\t\tcode.newLine();\n-\t\t\t}\n-\t\t\tint savedIndent = code.getIndent();\n-\t\t\ttry {\n-\t\t\t\taddMethod(code, mth);\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tif (mth.getParentClass().getTopParentClass().contains(AFlag.RESTART_CODEGEN)) {\n-\t\t\t\t\tthrow new JadxRuntimeException(\"Method generation error\", e);\n-\t\t\t\t}\n-\t\t\t\tcode.newLine().add(\"/*\");\n-\t\t\t\tcode.newLine().addMultiLine(ErrorsCounter.methodError(mth, \"Method generation error\", e));\n-\t\t\t\tUtils.appendStackTrace(code, e);\n-\t\t\t\tcode.newLine().add(\"*/\");\n-\t\t\t\tcode.setIndent(savedIndent);\n-\t\t\t\tmth.addError(\"Method generation error: \" + e.getMessage(), e);\n+\tprivate void addMethod(CodeWriter code, MethodNode mth) {\n+\t\tif (code.getLine() != clsDeclLine) {\n+\t\t\tcode.newLine();\n+\t\t}\n+\t\tint savedIndent = code.getIndent();\n+\t\ttry {\n+\t\t\taddMethodCode(code, mth);\n+\t\t} catch (Exception e) {\n+\t\t\tif (mth.getParentClass().getTopParentClass().contains(AFlag.RESTART_CODEGEN)) {\n+\t\t\t\tthrow new JadxRuntimeException(\"Method generation error\", e);\n \t\t\t}\n+\t\t\tcode.newLine().add(\"/*\");\n+\t\t\tcode.newLine().addMultiLine(ErrorsCounter.methodError(mth, \"Method generation error\", e));\n+\t\t\tUtils.appendStackTrace(code, e);\n+\t\t\tcode.newLine().add(\"*/\");\n+\t\t\tcode.setIndent(savedIndent);\n+\t\t\tmth.addError(\"Method generation error: \" + e.getMessage(), e);\n \t\t}\n \t}\n \n-\tprivate static List<MethodNode> sortMethodsByLine(List<MethodNode> methods) {\n-\t\tList<MethodNode> out = new ArrayList<>(methods);\n-\t\tout.sort(Comparator.comparingInt(LineAttrNode::getSourceLine));\n-\t\treturn out;\n-\t}\n-\n \tprivate boolean isMethodsPresents() {\n \t\tfor (MethodNode mth : cls.getMethods()) {\n \t\t\tif (!mth.contains(AFlag.DONT_GENERATE)) {\n@@ -290,7 +291,7 @@ private boolean isMethodsPresents() {\n \t\treturn false;\n \t}\n \n-\tpublic void addMethod(CodeWriter code, MethodNode mth) throws CodegenException {\n+\tpublic void addMethodCode(CodeWriter code, MethodNode mth) throws CodegenException {\n \t\tCodeGenUtils.addComments(code, mth);\n \t\tif (mth.getAccessFlags().isAbstract() || mth.getAccessFlags().isNative()) {\n \t\t\tMethodGen mthGen = new MethodGen(this, mth);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n@@ -8,9 +8,12 @@\n \n import org.jetbrains.annotations.Nullable;\n \n+import com.google.common.collect.Streams;\n+\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.DeclareVariablesAttr;\n+import jadx.core.dex.attributes.nodes.LineAttrNode;\n import jadx.core.dex.instructions.ArithNode;\n import jadx.core.dex.instructions.ArithOp;\n import jadx.core.dex.instructions.InsnType;\n@@ -20,6 +23,7 @@\n import jadx.core.dex.instructions.mods.ConstructorInsn;\n import jadx.core.dex.instructions.mods.TernaryInsn;\n import jadx.core.dex.nodes.BlockNode;\n+import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.InsnContainer;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n@@ -44,6 +48,14 @@\n )\n public class PrepareForCodeGen extends AbstractVisitor {\n \n+\t@Override\n+\tpublic boolean visit(ClassNode cls) throws JadxException {\n+\t\tif (cls.root().getArgs().isDebugInfo()) {\n+\t\t\tsetClassSourceLine(cls);\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n \t@Override\n \tpublic void visit(MethodNode mth) throws JadxException {\n \t\tList<BlockNode> blocks = mth.getBasicBlocks();\n@@ -246,4 +258,26 @@ private ConstructorInsn searchConstructorCall(MethodNode mth) {\n \t\t}\n \t\treturn null;\n \t}\n+\n+\t/**\n+\t * Use source line from top method\n+\t */\n+\tprivate void setClassSourceLine(ClassNode cls) {\n+\t\tfor (ClassNode innerClass : cls.getInnerClasses()) {\n+\t\t\tsetClassSourceLine(innerClass);\n+\t\t}\n+\n+\t\tint minLine = Streams.concat(\n+\t\t\t\tcls.getMethods().stream(),\n+\t\t\t\tcls.getInnerClasses().stream(),\n+\t\t\t\tcls.getFields().stream())\n+\t\t\t\t.filter(mth -> !mth.contains(AFlag.DONT_GENERATE))\n+\t\t\t\t.filter(mth -> mth.getSourceLine() != 0)\n+\t\t\t\t.mapToInt(LineAttrNode::getSourceLine)\n+\t\t\t\t.min()\n+\t\t\t\t.orElse(0);\n+\t\tif (minLine != 0) {\n+\t\t\tcls.setSourceLine(minLine - 1);\n+\t\t}\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers2.java b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers2.java\n@@ -39,7 +39,7 @@ public void test() {\n \n \t\tClassNode cls = getClassNode(TestCls.class);\n \t\tMap<Integer, Integer> lineMapping = cls.getCode().getLineMapping();\n-\t\tassertEquals(\"{8=18, 11=22, 12=23, 13=24, 14=28, 16=25, 17=26, 18=28, 21=31, 22=32}\",\n+\t\tassertEquals(\"{5=17, 8=18, 11=22, 12=23, 13=24, 14=28, 16=25, 17=26, 18=28, 21=31, 22=32}\",\n \t\t\t\tlineMapping.toString());\n \t}\n }",
    "output": "Fix sort inner classes and methods by source lines"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -332,6 +332,20 @@ private static InsnNode convertStringBuilderChain(MethodNode mth, InvokeNode toS\n \t\t\t\t}\n \t\t\t\targs.add(arg);\n \t\t\t}\n+\n+\t\t\tboolean stringArgFound = false;\n+\t\t\tfor (InsnArg arg : args) {\n+\t\t\t\tif (arg.getType().equals(ArgType.STRING)) {\n+\t\t\t\t\tstringArgFound = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (!stringArgFound) {\n+\t\t\t\t// TODO: convert one arg to string using `String.valueOf()`\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\t// all check passed\n \t\t\tremoveStringBuilderInsns(mth, toStrInsn, chain);\n \n \t\t\tInsnNode concatInsn = new InsnNode(InsnType.STR_CONCAT, args);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestStringBuilderElimination4Neg.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestStringBuilderElimination4Neg.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestStringBuilderElimination4Neg.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestStringBuilderElimination4Neg.java\n@@ -0,0 +1,33 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestStringBuilderElimination4Neg extends IntegrationTest {\n+\n+\tpublic static class TestCls<K, V> {\n+\t\tprivate K k;\n+\t\tprivate V v;\n+\n+\t\tpublic String test() {\n+\t\t\tStringBuilder sb = new StringBuilder();\n+\t\t\tsb.append(k);\n+\t\t\tsb.append('=');\n+\t\t\tsb.append(v);\n+\t\t\treturn sb.toString();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"sb.append('=');\"));\n+\t}\n+}",
    "output": "Fix don't eliminate StringBuilder if no String arg present"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/NameGen.java b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n@@ -139,7 +139,11 @@ private String makeArgName(CodeVar var) {\n \t}\n \n \tprivate String getFallbackName(CodeVar var) {\n-\t\treturn getFallbackName(var.getSsaVars().get(0).getAssign());\n+\t\tList<SSAVar> ssaVars = var.getSsaVars();\n+\t\tif (ssaVars.isEmpty()) {\n+\t\t\treturn \"v\";\n+\t\t}\n+\t\treturn getFallbackName(ssaVars.get(0).getAssign());\n \t}\n \n \tprivate String getFallbackName(RegisterArg arg) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java\n@@ -19,7 +19,9 @@ public static CodeVar fromMthArg(RegisterArg mthArg) {\n \t\tvar.setName(mthArg.getName());\n \t\tvar.setDeclared(true);\n \t\tvar.setThis(mthArg.isThis());\n-\t\tvar.setSsaVars(Collections.singletonList(new SSAVar(mthArg.getRegNum(), 0, mthArg)));\n+\t\tSSAVar ssaVar = new SSAVar(mthArg.getRegNum(), 0, mthArg);\n+\t\tssaVar.setCodeVar(var);\n+\t\tvar.setSsaVars(Collections.singletonList(ssaVar));\n \t\treturn var;\n \t}",
    "output": "Fix resolve code generation error for interface methods"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n@@ -323,7 +323,9 @@ public boolean isDeepEquals(InsnNode other) {\n \t}\n \n \tprotected final <T extends InsnNode> T copyCommonParams(T copy) {\n-\t\tcopy.setResult(result);\n+\t\tif (result != null) {\n+\t\t\tcopy.setResult(result.duplicate());\n+\t\t}\n \t\tif (copy.getArgsCount() == 0) {\n \t\t\tfor (InsnArg arg : this.getArguments()) {\n \t\t\t\tif (arg.isInsnWrap()) {",
    "output": "Fix duplicate result arg on instruction copy"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n@@ -677,7 +677,7 @@ private static InsnNode duplicateReturnInsn(InsnNode returnInsn) {\n \t\tInsnNode insn = new InsnNode(returnInsn.getType(), returnInsn.getArgsCount());\n \t\tif (returnInsn.getArgsCount() == 1) {\n \t\t\tRegisterArg arg = (RegisterArg) returnInsn.getArg(0);\n-\t\t\tinsn.addArg(InsnArg.reg(arg.getRegNum(), arg.getInitType()));\n+\t\t\tinsn.addArg(arg.duplicate());\n \t\t}\n \t\tinsn.copyAttributesFrom(returnInsn);\n \t\tinsn.setOffset(returnInsn.getOffset());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n@@ -12,7 +12,6 @@\n import jadx.core.dex.attributes.nodes.PhiListAttr;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.PhiInsn;\n-import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n import jadx.core.dex.instructions.args.SSAVar;\n@@ -383,25 +382,18 @@ private static boolean inlinePhiInsn(MethodNode mth, BlockNode block, PhiInsn ph\n \t\tList<RegisterArg> useList = resVar.getUseList();\n \t\tfor (RegisterArg useArg : new ArrayList<>(useList)) {\n \t\t\tInsnNode useInsn = useArg.getParentInsn();\n-\t\t\tif (useInsn == null || useInsn == phi) {\n+\t\t\tif (useInsn == null || useInsn == phi || useArg.getRegNum() != arg.getRegNum()) {\n \t\t\t\treturn false;\n \t\t\t}\n+\t\t\t// replace SSAVar in 'useArg' to SSAVar from 'arg'\n+\t\t\t// no need to replace whole RegisterArg\n \t\t\tuseArg.getSVar().removeUse(useArg);\n-\t\t\tRegisterArg inlArg = arg.duplicate();\n-\t\t\tif (!useInsn.replaceArg(useArg, inlArg)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tinlArg.getSVar().use(inlArg);\n-\t\t\tinlArg.setName(useArg.getName());\n-\t\t\tArgType type = useArg.getImmutableType();\n-\t\t\tif (type != null) {\n-\t\t\t\tinlArg.setType(type);\n-\t\t\t}\n+\t\t\targ.getSVar().use(useArg);\n \t\t}\n \t\tif (block.contains(AType.EXC_HANDLER)) {\n \t\t\t// don't inline into exception handler\n \t\t\tInsnNode assignInsn = arg.getAssignInsn();\n-\t\t\tif (assignInsn != null) {\n+\t\t\tif (assignInsn != null && !assignInsn.isConstInsn()) {\n \t\t\t\tassignInsn.add(AFlag.DONT_INLINE);\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inline/TestConstInline.java b/jadx-core/src/test/java/jadx/tests/integration/inline/TestConstInline.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inline/TestConstInline.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inline/TestConstInline.java\n@@ -0,0 +1,38 @@\n+package jadx.tests.integration.inline;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestConstInline extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic boolean test() {\n+\t\t\ttry {\n+\t\t\t\treturn f(0);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic boolean f(int i) {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"return f(0);\"));\n+\t\tassertThat(code, containsOne(\"return false;\"));\n+\t\tassertThat(code, not(containsString(\" = \")));\n+\t}\n+}",
    "output": "Fix preserve arg type on PHI insn inline"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -769,7 +769,7 @@ void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,\n \t\t\t\tif (!firstArg) {\n \t\t\t\t\tcode.add(\", \");\n \t\t\t\t}\n-\t\t\t\tboolean cast = overloaded && processOverloadedArg(code, insn, callMth, arg, i - startArgNum);\n+\t\t\t\tboolean cast = addArgCast(code, insn, callMth, arg, i - startArgNum, overloaded);\n \t\t\t\tif (!cast && i == argsCount - 1 && processVarArg(code, callMth, arg)) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n@@ -781,42 +781,47 @@ void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,\n \t}\n \n \t/**\n-\t * Add additional cast for overloaded method argument.\n+\t * Add additional cast for method argument.\n \t */\n-\tprivate boolean processOverloadedArg(CodeWriter code, InsnNode insn, MethodNode callMth, InsnArg arg, int origPos) {\n-\t\tList<ArgType> argTypes = callMth.getArgTypes();\n-\t\tArgType origType = argTypes.get(origPos);\n-\t\tif (origType.isGenericType() && !callMth.getParentClass().equals(mth.getParentClass())) {\n-\t\t\t// cancel cast\n-\t\t\treturn false;\n-\t\t}\n+\tprivate boolean addArgCast(CodeWriter code, InsnNode insn, @Nullable MethodNode callMth,\n+\t\t\tInsnArg arg, int origPos, boolean overloaded) {\n \t\tArgType castType = null;\n-\t\tif (insn instanceof CallMthInterface && origType.containsGenericType()) {\n-\t\t\tArgType clsType;\n-\t\t\tCallMthInterface mthCall = (CallMthInterface) insn;\n-\t\t\tRegisterArg instanceArg = mthCall.getInstanceArg();\n-\t\t\tif (instanceArg != null) {\n-\t\t\t\tclsType = instanceArg.getType();\n-\t\t\t} else {\n-\t\t\t\tclsType = mthCall.getCallMth().getDeclClass().getType();\n+\t\tif (callMth != null) {\n+\t\t\tList<ArgType> argTypes = callMth.getArgTypes();\n+\t\t\tArgType origType = argTypes.get(origPos);\n+\t\t\tif (origType.isGenericType() && !callMth.getParentClass().equals(mth.getParentClass())) {\n+\t\t\t\t// cancel cast\n+\t\t\t\treturn false;\n \t\t\t}\n-\t\t\tArgType replacedType = TypeUtils.replaceClassGenerics(root, clsType, origType);\n-\t\t\tif (replacedType != null) {\n-\t\t\t\tcastType = replacedType;\n+\t\t\tif (insn instanceof CallMthInterface && origType.containsGenericType()) {\n+\t\t\t\tArgType clsType;\n+\t\t\t\tCallMthInterface mthCall = (CallMthInterface) insn;\n+\t\t\t\tRegisterArg instanceArg = mthCall.getInstanceArg();\n+\t\t\t\tif (instanceArg != null) {\n+\t\t\t\t\tclsType = instanceArg.getType();\n+\t\t\t\t} else {\n+\t\t\t\t\tclsType = mthCall.getCallMth().getDeclClass().getType();\n+\t\t\t\t}\n+\t\t\t\tArgType replacedType = TypeUtils.replaceClassGenerics(root, clsType, origType);\n+\t\t\t\tif (replacedType != null) {\n+\t\t\t\t\tcastType = replacedType;\n+\t\t\t\t}\n+\t\t\t\tif (castType == null) {\n+\t\t\t\t\tArgType invReplType = TypeUtils.replaceMethodGenerics(root, insn, origType);\n+\t\t\t\t\tif (invReplType != null) {\n+\t\t\t\t\t\tcastType = invReplType;\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n \t\t\tif (castType == null) {\n-\t\t\t\tArgType invReplType = TypeUtils.replaceMethodGenerics(root, insn, origType);\n-\t\t\t\tif (invReplType != null) {\n-\t\t\t\t\tcastType = invReplType;\n-\t\t\t\t}\n+\t\t\t\tcastType = origType;\n \t\t\t}\n-\t\t}\n-\t\tif (castType == null) {\n-\t\t\tcastType = origType;\n+\t\t} else {\n+\t\t\tcastType = arg.getType();\n \t\t}\n \t\t// TODO: check castType for left type variables\n \n-\t\tif (isCastNeeded(arg, castType)) {\n+\t\tif (isCastNeeded(arg, castType, overloaded)) {\n \t\t\tcode.add('(');\n \t\t\tuseType(code, castType);\n \t\t\tcode.add(\") \");\n@@ -825,7 +830,7 @@ private boolean processOverloadedArg(CodeWriter code, InsnNode insn, MethodNode\n \t\treturn false;\n \t}\n \n-\tprivate boolean isCastNeeded(InsnArg arg, ArgType origType) {\n+\tprivate boolean isCastNeeded(InsnArg arg, ArgType origType, boolean overloaded) {\n \t\tArgType argType = arg.getType();\n \t\tif (arg.isLiteral() && ((LiteralArg) arg).getLiteral() == 0\n \t\t\t\t&& (argType.isObject() || argType.isArray())) {\n@@ -834,7 +839,7 @@ private boolean isCastNeeded(InsnArg arg, ArgType origType) {\n \t\tif (argType.equals(origType)) {\n \t\t\treturn false;\n \t\t}\n-\t\treturn true;\n+\t\treturn overloaded;\n \t}\n \n \t/**\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke2.java b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke2.java\n@@ -0,0 +1,22 @@\n+package jadx.tests.integration.invoke;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestCastInOverloadedInvoke2 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\n+\t\tClassNode cls = getClassNodeFromSmali();\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"new Intent().putExtra(\\\"param\\\", (Parcelable) null);\"));\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing2.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing2.java\n@@ -39,11 +39,10 @@ public void test() {\n \t\tassertThat(code, containsOne(\"l = 0L;\"));\n \n \t\t// checks for 'check' method\n-\t\tassertThat(code, containsOne(\"test(null)\"));\n+\t\tassertThat(code, containsOne(\"test((Long) null)\")); // TODO: cast not needed\n \t\tassertThat(code, containsOne(\"test(0L)\"));\n \t\tassertThat(code, countString(2, \"is(0L)\"));\n \t\tassertThat(code, containsOne(\"test(7L)\"));\n \t\tassertThat(code, containsOne(\"is(7L)\"));\n-\n \t}\n }",
    "output": "Fix force cast for null args in method invoke (temp fix for #724)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java\n@@ -6,10 +6,11 @@\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.trycatch.ExceptionHandler;\n import jadx.core.utils.exceptions.JadxOverflowException;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public class DepthRegionTraversal {\n \n-\tprivate static final int ITERATIVE_LIMIT = 500;\n+\tprivate static final int ITERATIVE_LIMIT_MULTIPLIER = 5;\n \n \tprivate DepthRegionTraversal() {\n \t}\n@@ -21,17 +22,21 @@ public static void traverse(MethodNode mth, IRegionVisitor visitor) {\n \tpublic static void traverseIterative(MethodNode mth, IRegionIterativeVisitor visitor) {\n \t\tboolean repeat;\n \t\tint k = 0;\n+\t\tint limit = ITERATIVE_LIMIT_MULTIPLIER * mth.getBasicBlocks().size();\n \t\tdo {\n \t\t\trepeat = traverseIterativeStepInternal(mth, visitor, mth.getRegion());\n-\t\t\tif (k++ > ITERATIVE_LIMIT) {\n-\t\t\t\tthrow new JadxOverflowException(\"Iterative traversal limit reached, method: \" + mth);\n+\t\t\tif (k++ > limit) {\n+\t\t\t\tthrow new JadxRuntimeException(\"Iterative traversal limit reached: \"\n+\t\t\t\t\t\t+ \"limit: \" + limit + \", visitor: \" + visitor.getClass().getName()\n+\t\t\t\t\t\t+ \", blocks count: \" + mth.getBasicBlocks().size());\n \t\t\t}\n \t\t} while (repeat);\n \t}\n \n \tpublic static void traverseIncludingExcHandlers(MethodNode mth, IRegionIterativeVisitor visitor) {\n \t\tboolean repeat;\n \t\tint k = 0;\n+\t\tint limit = ITERATIVE_LIMIT_MULTIPLIER * mth.getBasicBlocks().size();\n \t\tdo {\n \t\t\trepeat = traverseIterativeStepInternal(mth, visitor, mth.getRegion());\n \t\t\tif (!repeat) {\n@@ -42,8 +47,10 @@ public static void traverseIncludingExcHandlers(MethodNode mth, IRegionIterative\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif (k++ > ITERATIVE_LIMIT) {\n-\t\t\t\tthrow new JadxOverflowException(\"Iterative traversal limit reached, method: \" + mth);\n+\t\t\tif (k++ > limit) {\n+\t\t\t\tthrow new JadxRuntimeException(\"Iterative traversal limit reached: \"\n+\t\t\t\t\t\t+ \"limit: \" + limit + \", visitor: \" + visitor.getClass().getName()\n+\t\t\t\t\t\t+ \", blocks count: \" + mth.getBasicBlocks().size());\n \t\t\t}\n \t\t} while (repeat);\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java\n@@ -24,6 +24,10 @@ public class IfRegionVisitor extends AbstractVisitor {\n \n \t@Override\n \tpublic void visit(MethodNode mth) {\n+\t\tif (mth.isNoCode()) {\n+\t\t\treturn;\n+\t\t}\n+\n \t\tDepthRegionTraversal.traverseIterative(mth, TERNARY_VISITOR);\n \t\tDepthRegionTraversal.traverse(mth, PROCESS_IF_REGION_VISITOR);\n \t\tDepthRegionTraversal.traverseIterative(mth, REMOVE_REDUNDANT_ELSE_VISITOR);",
    "output": "Fix increase region iterative traversal limit"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -325,6 +325,10 @@ private JavaClass getJavaClassByNode(ClassNode cls) {\n \t\t\t\treturn javaClass;\n \t\t\t}\n \t\t}\n+\t\t// class or parent classes can be excluded from generation\n+\t\tif (cls.hasNotGeneratedParent()) {\n+\t\t\treturn null;\n+\t\t}\n \t\tthrow new JadxRuntimeException(\"JavaClass not found by ClassNode: \" + cls);\n \t}",
    "output": "Fix search if class contains not generated inner class"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n@@ -38,10 +38,18 @@ public class JadxProject {\n \n \tprivate int projectVersion = 0;\n \n+\t// Don't remove. Used in json serialization\n+\tpublic JadxProject() {\n+\t}\n+\n \tpublic JadxProject(JadxSettings settings) {\n \t\tthis.settings = settings;\n \t}\n \n+\tpublic void setSettings(JadxSettings settings) {\n+\t\tthis.settings = settings;\n+\t}\n+\n \tpublic Path getProjectPath() {\n \t\treturn projectPath;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java\n@@ -54,8 +54,8 @@ private JadxSettingsAdapter() {\n \t}\n \n \tpublic static JadxSettings load() {\n+\t\tString jsonSettings = PREFS.get(JADX_GUI_KEY, \"\");\n \t\ttry {\n-\t\t\tString jsonSettings = PREFS.get(JADX_GUI_KEY, \"\");\n \t\t\tJadxSettings settings = fromString(jsonSettings);\n \t\t\tif (settings == null) {\n \t\t\t\tLOG.debug(\"Created new settings.\");\n@@ -68,7 +68,7 @@ public static JadxSettings load() {\n \t\t\t}\n \t\t\treturn settings;\n \t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Error load settings\", e);\n+\t\t\tLOG.error(\"Error load settings. Settings will reset.\\n Loaded json string: {}\", jsonSettings, e);\n \t\t\treturn new JadxSettings();\n \t\t}\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/WindowLocation.java b/jadx-gui/src/main/java/jadx/gui/settings/WindowLocation.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/WindowLocation.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/WindowLocation.java\n@@ -3,10 +3,12 @@\n import java.awt.*;\n \n public class WindowLocation {\n+\tprivate String windowId;\n+\tprivate Rectangle bounds;\n \n-\tprivate final String windowId;\n-\n-\tprivate final Rectangle bounds;\n+\t// Don't remove. Used in json serialization\n+\tpublic WindowLocation() {\n+\t}\n \n \tpublic WindowLocation(String windowId, Rectangle bounds) {\n \t\tthis.windowId = windowId;\n@@ -17,10 +19,18 @@ public String getWindowId() {\n \t\treturn windowId;\n \t}\n \n+\tpublic void setWindowId(String windowId) {\n+\t\tthis.windowId = windowId;\n+\t}\n+\n \tpublic Rectangle getBounds() {\n \t\treturn bounds;\n \t}\n \n+\tpublic void setBounds(Rectangle bounds) {\n+\t\tthis.bounds = bounds;\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn \"WindowLocation{\"\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/LangLocale.java b/jadx-gui/src/main/java/jadx/gui/utils/LangLocale.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/LangLocale.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/LangLocale.java\n@@ -3,7 +3,11 @@\n import java.util.Locale;\n \n public class LangLocale {\n-\tprivate final Locale locale;\n+\tprivate Locale locale;\n+\n+\t// Don't remove. Used in json serialization\n+\tpublic LangLocale() {\n+\t}\n \n \tpublic LangLocale(Locale locale) {\n \t\tthis.locale = locale;\n@@ -17,6 +21,14 @@ public Locale get() {\n \t\treturn locale;\n \t}\n \n+\tpublic Locale getLocale() {\n+\t\treturn locale;\n+\t}\n+\n+\tpublic void setLocale(Locale locale) {\n+\t\tthis.locale = locale;\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn NLS.str(\"language.name\", this);",
    "output": "Add default contructor for classes serialized with GSON"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -199,28 +199,39 @@ private List<ArgType> parseSignature() {\n \t\t\t\tif (argsTypes.isEmpty()) {\n \t\t\t\t\treturn null;\n \t\t\t\t}\n-\t\t\t\tif (!mthInfo.isConstructor()) {\n-\t\t\t\t\tLOG.warn(\"Wrong signature parse result: {} -> {}, not generic version: {}\", sp, argsTypes, mthArgs);\n-\t\t\t\t\treturn null;\n-\t\t\t\t} else if (getParentClass().getAccessFlags().isEnum()) {\n-\t\t\t\t\t// TODO:\n-\t\t\t\t\targsTypes.add(0, mthArgs.get(0));\n-\t\t\t\t\targsTypes.add(1, mthArgs.get(1));\n-\t\t\t\t} else {\n-\t\t\t\t\t// add synthetic arg for outer class\n-\t\t\t\t\targsTypes.add(0, mthArgs.get(0));\n-\t\t\t\t}\n-\t\t\t\tif (argsTypes.size() != mthArgs.size()) {\n+\t\t\t\tif (!tryFixArgsCounts(argsTypes, mthArgs)) {\n+\t\t\t\t\tif (LOG.isDebugEnabled()) {\n+\t\t\t\t\t\tLOG.debug(\"Incorrect method signature, types: ({}), method: {}\", Utils.listToString(argsTypes), this);\n+\t\t\t\t\t}\n \t\t\t\t\treturn null;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn argsTypes;\n-\t\t} catch (JadxRuntimeException e) {\n-\t\t\tLOG.error(\"Method signature parse error: {}\", this, e);\n+\t\t} catch (Exception e) {\n+\t\t\taddWarningComment(\"Failed to parse method signature: \" + sp.getSignature(), e);\n \t\t\treturn null;\n \t\t}\n \t}\n \n+\tprivate boolean tryFixArgsCounts(List<ArgType> argsTypes, List<ArgType> mthArgs) {\n+\t\tif (!mthInfo.isConstructor()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (getParentClass().getAccessFlags().isEnum()) {\n+\t\t\tif (mthArgs.size() >= 2) {\n+\t\t\t\t// TODO:\n+\t\t\t\targsTypes.add(0, mthArgs.get(0));\n+\t\t\t\targsTypes.add(1, mthArgs.get(1));\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (!mthArgs.isEmpty()) {\n+\t\t\t\t// add synthetic arg for outer class\n+\t\t\t\targsTypes.add(0, mthArgs.get(0));\n+\t\t\t}\n+\t\t}\n+\t\treturn argsTypes.size() == mthArgs.size();\n+\t}\n+\n \tprivate void initArguments(List<ArgType> args) {\n \t\tint pos;\n \t\tif (noCode) {\n@@ -687,6 +698,20 @@ public void addWarn(String warnStr) {\n \t\tErrorsCounter.methodWarn(this, warnStr);\n \t}\n \n+\tpublic void addWarningComment(String warn) {\n+\t\taddWarningComment(warn, null);\n+\t}\n+\n+\tpublic void addWarningComment(String warn, @Nullable Throwable exc) {\n+\t\tString commentStr = \"JADX WARN: \" + warn;\n+\t\taddAttr(AType.COMMENTS, commentStr);\n+\t\tif (exc != null) {\n+\t\t\tLOG.warn(\"{} in {}\", warn, this, exc);\n+\t\t} else {\n+\t\t\tLOG.warn(\"{} in {}\", warn, this);\n+\t\t}\n+\t}\n+\n \tpublic void addComment(String commentStr) {\n \t\taddAttr(AType.COMMENTS, commentStr);\n \t\tLOG.info(\"{} in {}\", commentStr, this);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n@@ -292,6 +292,10 @@ private static String mergeSignature(List<String> list) {\n \t\treturn sb.toString();\n \t}\n \n+\tpublic String getSignature() {\n+\t\treturn sign;\n+\t}\n+\n \tprivate String debugString() {\n \t\tif (pos >= sign.length()) {\n \t\t\treturn sign;",
    "output": "Fix handle incorrect args count in signature"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java\n@@ -27,7 +27,7 @@\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.instructions.args.ArgType;\n-import jadx.core.utils.exceptions.JadxRuntimeException;\n+import jadx.core.utils.ErrorsCounter;\n import jadx.core.utils.files.DexFile;\n \n public class DexNode implements IDexNode {\n@@ -56,15 +56,33 @@ public void loadClasses() {\n \t\tfor (ClassDef cls : dexBuf.classDefs()) {\n \t\t\ttry {\n \t\t\t\taddClassNode(new ClassNode(this, cls));\n-\t\t\t} catch (JadxRuntimeException e) {\n-\t\t\t\t// TODO: Add dummy class node displaying the error message\n-\t\t\t\tLOG.error(\"Class loading failed - {}\", e.getMessage(), e);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\taddDummyClass(cls, e);\n \t\t\t}\n \t\t}\n \t\t// sort classes by name, expect top classes before inner\n \t\tclasses.sort(Comparator.comparing(ClassNode::getFullName));\n \t}\n \n+\tprivate void addDummyClass(ClassDef classDef, Exception exc) {\n+\t\tint typeIndex = classDef.getTypeIndex();\n+\t\tString name = null;\n+\t\ttry {\n+\t\t\tClassInfo clsInfo = ClassInfo.fromDex(this, typeIndex);\n+\t\t\tif (clsInfo != null) {\n+\t\t\t\tname = clsInfo.getShortName();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"Failed to get name for class with type {}\", typeIndex, e);\n+\t\t}\n+\t\tif (name == null || name.isEmpty()) {\n+\t\t\tname = \"CLASS_\" + typeIndex;\n+\t\t}\n+\t\tClassNode clsNode = new ClassNode(this, name, classDef.getAccessFlags());\n+\t\tErrorsCounter.classError(clsNode, \"Load error\", exc);\n+\t\taddClassNode(clsNode);\n+\t}\n+\n \tpublic void addClassNode(ClassNode clsNode) {\n \t\tclasses.add(clsNode);\n \t\tclsMap.put(clsNode.getClassInfo(), clsNode);",
    "output": "Add dummy class if class loading exception occur"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java\n@@ -9,6 +9,8 @@\n \n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.android.dex.ClassData;\n import com.android.dex.ClassData.Method;\n@@ -25,9 +27,11 @@\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.core.utils.files.DexFile;\n \n public class DexNode implements IDexNode {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DexNode.class);\n \n \tpublic static final int NO_INDEX = -1;\n \n@@ -50,7 +54,12 @@ public DexNode(RootNode root, DexFile input, int dexId) {\n \n \tpublic void loadClasses() {\n \t\tfor (ClassDef cls : dexBuf.classDefs()) {\n-\t\t\taddClassNode(new ClassNode(this, cls));\n+\t\t\ttry {\n+\t\t\t\taddClassNode(new ClassNode(this, cls));\n+\t\t\t} catch (JadxRuntimeException e) {\n+\t\t\t\t// TODO: Add dummy class node displaying the error message\n+\t\t\t\tLOG.error(\"Class loading failed - {}\", e.getMessage(), e);\n+\t\t\t}\n \t\t}\n \t\t// sort classes by name, expect top classes before inner\n \t\tclasses.sort(Comparator.comparing(ClassNode::getFullName));",
    "output": "Fix don't stop loading classes in case of an error"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n@@ -1,6 +1,7 @@\n package jadx.core.dex.attributes;\n \n public enum AFlag {\n+\tMTH_ENTER_BLOCK,\n \tTRY_ENTER,\n \tTRY_LEAVE,\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java\n@@ -39,7 +39,7 @@ public class BlockProcessor extends AbstractVisitor {\n \n \t@Override\n \tpublic void visit(MethodNode mth) {\n-\t\tif (mth.isNoCode()) {\n+\t\tif (mth.isNoCode() || mth.getBasicBlocks().isEmpty()) {\n \t\t\treturn;\n \t\t}\n \t\tprocessBlocksTree(mth);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n@@ -77,6 +77,7 @@ private static void splitBasicBlocks(MethodNode mth) {\n \t\tInsnNode prevInsn = null;\n \t\tMap<Integer, BlockNode> blocksMap = new HashMap<>();\n \t\tBlockNode curBlock = startNewBlock(mth, 0);\n+\t\tcurBlock.add(AFlag.MTH_ENTER_BLOCK);\n \t\tmth.setEnterBlock(curBlock);\n \n \t\t// split into blocks\n@@ -331,7 +332,8 @@ private static void removeInsns(MethodNode mth) {\n \tstatic boolean removeEmptyDetachedBlocks(MethodNode mth) {\n \t\treturn mth.getBasicBlocks().removeIf(block -> block.getInstructions().isEmpty()\n \t\t\t\t&& block.getPredecessors().isEmpty()\n-\t\t\t\t&& block.getSuccessors().isEmpty());\n+\t\t\t\t&& block.getSuccessors().isEmpty()\n+\t\t\t\t&& !block.contains(AFlag.MTH_ENTER_BLOCK));\n \t}\n \n \tprivate static boolean removeUnreachableBlocks(MethodNode mth) {\n@@ -385,7 +387,8 @@ private static boolean canRemoveBlock(BlockNode block) {\n \t\treturn block.getInstructions().isEmpty()\n \t\t\t\t&& block.isAttrStorageEmpty()\n \t\t\t\t&& block.getSuccessors().size() <= 1\n-\t\t\t\t&& !block.getPredecessors().isEmpty();\n+\t\t\t\t&& !block.getPredecessors().isEmpty()\n+\t\t\t\t&& !block.contains(AFlag.MTH_ENTER_BLOCK);\n \t}\n \n \tprivate static void collectSuccessors(BlockNode startBlock, Set<BlockNode> toRemove) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java\n@@ -39,7 +39,7 @@ public class RegionMakerVisitor extends AbstractVisitor {\n \n \t@Override\n \tpublic void visit(MethodNode mth) throws JadxException {\n-\t\tif (mth.isNoCode()) {\n+\t\tif (mth.isNoCode() || mth.getBasicBlocks().isEmpty()) {\n \t\t\treturn;\n \t\t}\n \t\tRegionMaker rm = new RegionMaker(mth);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestAllNops.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestAllNops.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestAllNops.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestAllNops.java\n@@ -0,0 +1,22 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsLines;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestAllNops extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tClassNode cls = getClassNodeFromSmali();\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsLines(1, \"private boolean test() {\", \"}\"));\n+\t\tassertThat(code, containsLines(1, \"private boolean testWithTryCatch() {\", \"}\"));\n+\t}\n+}",
    "output": "Fix handle methods with all NOPs"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/ProcessClass.java b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n--- a/jadx-core/src/main/java/jadx/core/ProcessClass.java\n+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n@@ -14,7 +14,6 @@\n import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;\n import static jadx.core.dex.nodes.ProcessState.PROCESS_COMPLETE;\n import static jadx.core.dex.nodes.ProcessState.PROCESS_STARTED;\n-import static jadx.core.dex.nodes.ProcessState.UNLOADED;\n \n public final class ProcessClass {\n \n@@ -27,8 +26,7 @@ public static void process(ClassNode cls) {\n \t\t\tprocess(topParentClass);\n \t\t\treturn;\n \t\t}\n-\t\tif (cls.getState() == PROCESS_COMPLETE\n-\t\t\t\t|| cls.getState() == UNLOADED) {\n+\t\tif (cls.getState().isProcessed()) {\n \t\t\t// nothing to do\n \t\t\treturn;\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -591,10 +591,8 @@ private void filledNewArray(FilledNewArrayNode insn, CodeWriter code) throws Cod\n \tprivate void makeConstructor(ConstructorInsn insn, CodeWriter code)\n \t\t\tthrows CodegenException {\n \t\tClassNode cls = mth.dex().resolveClass(insn.getClassType());\n-\t\tif (cls != null) {\n-\t\t\tcls.loadAndProcess();\n-\t\t}\n \t\tif (cls != null && cls.isAnonymous() && !fallback) {\n+\t\t\tcls.ensureProcessed();\n \t\t\tinlineAnonymousConstructor(code, cls, insn);\n \t\t\treturn;\n \t\t}\n@@ -787,21 +785,10 @@ void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,\n \t */\n \tprivate boolean processOverloadedArg(CodeWriter code, InsnNode insn, MethodNode callMth, InsnArg arg, int origPos) {\n \t\tList<ArgType> argTypes = callMth.getArgTypes();\n-\t\tif (argTypes == null) {\n-\t\t\t// try to load class\n-\t\t\tcallMth.getParentClass().loadAndProcess();\n-\t\t\targTypes = callMth.getArgTypes();\n-\t\t}\n-\t\tArgType origType;\n-\t\tif (argTypes == null) {\n-\t\t\tmth.addComment(\"JADX INFO: used method not loaded: \" + callMth + \", types can be incorrect\");\n-\t\t\torigType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);\n-\t\t} else {\n-\t\t\torigType = argTypes.get(origPos);\n-\t\t\tif (origType.isGenericType() && !callMth.getParentClass().equals(mth.getParentClass())) {\n-\t\t\t\t// cancel cast\n-\t\t\t\treturn false;\n-\t\t\t}\n+\t\tArgType origType = argTypes.get(origPos);\n+\t\tif (origType.isGenericType() && !callMth.getParentClass().equals(mth.getParentClass())) {\n+\t\t\t// cancel cast\n+\t\t\treturn false;\n \t\t}\n \t\tArgType castType = null;\n \t\tif (insn instanceof CallMthInterface && origType.containsGenericType()) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -110,31 +110,37 @@ public ClassNode(DexNode dex, ClassDef cls) {\n \t\t\t}\n \n \t\t\tloadAnnotations(cls);\n-\n+\t\t\tinitAccessFlags(cls);\n \t\t\tparseClassSignature();\n \t\t\tsetFieldsTypesFromSignature();\n+\t\t\tmethods.forEach(MethodNode::initMethodTypes);\n \n \t\t\tint sfIdx = cls.getSourceFileIndex();\n \t\t\tif (sfIdx != DexNode.NO_INDEX) {\n \t\t\t\tString fileName = dex.getString(sfIdx);\n \t\t\t\taddSourceFilenameAttr(fileName);\n \t\t\t}\n \n-\t\t\t// restore original access flags from dalvik annotation if present\n-\t\t\tint accFlagsValue;\n-\t\t\tAnnotation a = getAnnotation(Consts.DALVIK_INNER_CLASS);\n-\t\t\tif (a != null) {\n-\t\t\t\taccFlagsValue = (Integer) a.getValues().get(\"accessFlags\");\n-\t\t\t} else {\n-\t\t\t\taccFlagsValue = cls.getAccessFlags();\n-\t\t\t}\n-\t\t\tthis.accessFlags = new AccessInfo(accFlagsValue, AFType.CLASS);\n \t\t\tbuildCache();\n \t\t} catch (Exception e) {\n \t\t\tthrow new JadxRuntimeException(\"Error decode class: \" + clsInfo, e);\n \t\t}\n \t}\n \n+\t/**\n+\t * Restore original access flags from Dalvik annotation if present\n+\t */\n+\tprivate void initAccessFlags(ClassDef cls) {\n+\t\tint accFlagsValue;\n+\t\tAnnotation a = getAnnotation(Consts.DALVIK_INNER_CLASS);\n+\t\tif (a != null) {\n+\t\t\taccFlagsValue = (Integer) a.getValues().get(\"accessFlags\");\n+\t\t} else {\n+\t\t\taccFlagsValue = cls.getAccessFlags();\n+\t\t}\n+\t\tthis.accessFlags = new AccessInfo(accFlagsValue, AFType.CLASS);\n+\t}\n+\n \t// empty synthetic class\n \tpublic ClassNode(DexNode dex, String name, int accessFlags) {\n \t\tthis.dex = dex;\n@@ -247,8 +253,13 @@ private void addSourceFilenameAttr(String fileName) {\n \t\tthis.addAttr(new SourceFileAttr(fileName));\n \t}\n \n-\tpublic void loadAndProcess() {\n-\t\tProcessClass.process(this);\n+\tpublic void ensureProcessed() {\n+\t\tClassNode topClass = getTopParentClass();\n+\t\tProcessState topState = topClass.getState();\n+\t\tif (!topState.isProcessed()) {\n+\t\t\tthrow new JadxRuntimeException(\"Expected class to be processed at this point,\"\n+\t\t\t\t\t+ \" class: \" + topClass + \", state: \" + topState);\n+\t\t}\n \t}\n \n \tpublic synchronized ICodeInfo decompile() {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -121,14 +121,15 @@ public void load() throws DecodeException {\n \t\t\tif (noCode) {\n \t\t\t\tregsCount = 0;\n \t\t\t\tcodeSize = 0;\n-\t\t\t\tinitMethodTypes();\n+\t\t\t\t// TODO: registers not needed without code\n+\t\t\t\tinitArguments(this.argTypes);\n \t\t\t\treturn;\n \t\t\t}\n \n \t\t\tDexNode dex = parentClass.dex();\n \t\t\tCode mthCode = dex.readCode(methodData);\n \t\t\tthis.regsCount = mthCode.getRegistersSize();\n-\t\t\tinitMethodTypes();\n+\t\t\tinitArguments(this.argTypes);\n \n \t\t\tInsnDecoder decoder = new InsnDecoder(this);\n \t\t\tdecoder.decodeInsns(mthCode);\n@@ -172,15 +173,14 @@ public void checkInstructions() {\n \t\t}\n \t}\n \n-\tprivate void initMethodTypes() {\n+\tpublic void initMethodTypes() {\n \t\tList<ArgType> types = parseSignature();\n \t\tif (types == null) {\n \t\t\tthis.retType = mthInfo.getReturnType();\n \t\t\tthis.argTypes = mthInfo.getArgumentsTypes();\n \t\t} else {\n \t\t\tthis.argTypes = types;\n \t\t}\n-\t\tinitArguments(this.argTypes);\n \t}\n \n \t@Nullable\n@@ -253,11 +253,11 @@ private void initArguments(List<ArgType> args) {\n \t\t}\n \t}\n \n-\t/**\n-\t * Return null only if method not yet loaded\n-\t */\n-\t@Nullable\n+\t@NotNull\n \tpublic List<ArgType> getArgTypes() {\n+\t\tif (argTypes == null) {\n+\t\t\tthrow new JadxRuntimeException(\"Method types not initialized: \" + this);\n+\t\t}\n \t\treturn argTypes;\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ProcessState.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ProcessState.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ProcessState.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ProcessState.java\n@@ -6,5 +6,13 @@ public enum ProcessState {\n \tPROCESS_STARTED,\n \tPROCESS_COMPLETE,\n \tGENERATED,\n-\tUNLOADED\n+\tUNLOADED;\n+\n+\tpublic boolean isLoaded() {\n+\t\treturn this != NOT_LOADED;\n+\t}\n+\n+\tpublic boolean isProcessed() {\n+\t\treturn this == PROCESS_COMPLETE || this == GENERATED || this == UNLOADED;\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -276,7 +276,6 @@ public List<ArgType> getMethodArgTypes(MethodInfo callMth) {\n \tpublic List<GenericInfo> getClassGenerics(ArgType type) {\n \t\tClassNode classNode = resolveClass(ClassInfo.fromType(this, type));\n \t\tif (classNode != null) {\n-\t\t\tclassNode.loadAndProcess();\n \t\t\treturn classNode.getGenerics();\n \t\t}\n \t\tNClass clsDetails = getClsp().getClsDetails(type);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n@@ -275,7 +275,6 @@ private static void processAnonymousConstructor(MethodNode mth, ConstructorInsn\n \t\tif (!mth.getParentClass().getInnerClasses().contains(classNode)) {\n \t\t\treturn;\n \t\t}\n-\t\tclassNode.loadAndProcess();\n \t\tMap<InsnArg, FieldNode> argsMap = getArgsToFieldsMapping(callMthNode, co);\n \t\tif (argsMap.isEmpty() && !callMthNode.getArgRegs().isEmpty()) {\n \t\t\treturn;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n@@ -27,6 +27,7 @@\n import jadx.api.JadxArgs;\n import jadx.api.JadxDecompiler;\n import jadx.api.JadxInternalAccess;\n+import jadx.core.ProcessClass;\n import jadx.core.codegen.CodeGen;\n import jadx.core.codegen.CodeWriter;\n import jadx.core.dex.attributes.AFlag;\n@@ -223,7 +224,7 @@ private void insertResources(RootNode root) {\n \t}\n \n \tprotected void decompileWithoutUnload(JadxDecompiler jadx, ClassNode cls) {\n-\t\tcls.loadAndProcess();\n+\t\tProcessClass.process(cls);\n \t\tgenerateClsCode(cls);\n \t\t// don't unload class\n \t}",
    "output": "Fix don't run class process from visitors to avoid deadlock"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -292,61 +292,105 @@ synchronized BinaryXMLParser getXmlParser() {\n \t\treturn xmlParser;\n \t}\n \n-\tMap<ClassNode, JavaClass> getClassesMap() {\n-\t\treturn classesMap;\n+\tprivate void loadJavaClass(JavaClass javaClass) {\n+\t\tjavaClass.getMethods().forEach(mth -> methodsMap.put(mth.getMethodNode(), mth));\n+\t\tjavaClass.getFields().forEach(fld -> fieldsMap.put(fld.getFieldNode(), fld));\n+\n+\t\tfor (JavaClass innerCls : javaClass.getInnerClasses()) {\n+\t\t\tclassesMap.put(innerCls.getClassNode(), innerCls);\n+\t\t\tloadJavaClass(innerCls);\n+\t\t}\n \t}\n \n-\tMap<MethodNode, JavaMethod> getMethodsMap() {\n-\t\treturn methodsMap;\n+\t@Nullable(\"For not generated classes\")\n+\tprivate JavaClass getJavaClassByNode(ClassNode cls) {\n+\t\tJavaClass javaClass = classesMap.get(cls);\n+\t\tif (javaClass != null) {\n+\t\t\treturn javaClass;\n+\t\t}\n+\t\t// load parent class if inner\n+\t\tClassNode parentClass = cls.getTopParentClass();\n+\t\tif (parentClass.contains(AFlag.DONT_GENERATE)) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tif (parentClass != cls) {\n+\t\t\tJavaClass parentJavaClass = classesMap.get(parentClass);\n+\t\t\tif (parentJavaClass == null) {\n+\t\t\t\tgetClasses();\n+\t\t\t\tparentJavaClass = classesMap.get(parentClass);\n+\t\t\t}\n+\t\t\tloadJavaClass(parentJavaClass);\n+\t\t\tjavaClass = classesMap.get(cls);\n+\t\t\tif (javaClass != null) {\n+\t\t\t\treturn javaClass;\n+\t\t\t}\n+\t\t}\n+\t\tthrow new JadxRuntimeException(\"JavaClass not found by ClassNode: \" + cls);\n \t}\n \n-\tJavaMethod getJavaMethodByNode(MethodNode mth) {\n+\t@Nullable\n+\tprivate JavaMethod getJavaMethodByNode(MethodNode mth) {\n \t\tJavaMethod javaMethod = methodsMap.get(mth);\n \t\tif (javaMethod != null) {\n \t\t\treturn javaMethod;\n \t\t}\n \t\t// parent class not loaded yet\n-\t\tJavaClass javaClass = classesMap.get(mth.getParentClass());\n-\t\tif (javaClass != null) {\n-\t\t\tjavaClass.decompile();\n-\t\t\treturn methodsMap.get(mth);\n+\t\tJavaClass javaClass = getJavaClassByNode(mth.getParentClass().getTopParentClass());\n+\t\tif (javaClass == null) {\n+\t\t\treturn null;\n \t\t}\n-\t\treturn null;\n-\t}\n-\n-\tMap<FieldNode, JavaField> getFieldsMap() {\n-\t\treturn fieldsMap;\n+\t\tloadJavaClass(javaClass);\n+\t\tjavaMethod = methodsMap.get(mth);\n+\t\tif (javaMethod != null) {\n+\t\t\treturn javaMethod;\n+\t\t}\n+\t\tif (mth.getParentClass().hasNotGeneratedParent()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tthrow new JadxRuntimeException(\"JavaMethod not found by MethodNode: \" + mth);\n \t}\n \n-\tJavaField getJavaFieldByNode(FieldNode fld) {\n+\t@Nullable\n+\tprivate JavaField getJavaFieldByNode(FieldNode fld) {\n \t\tJavaField javaField = fieldsMap.get(fld);\n \t\tif (javaField != null) {\n \t\t\treturn javaField;\n \t\t}\n \t\t// parent class not loaded yet\n-\t\tJavaClass javaClass = classesMap.get(fld.getParentClass());\n-\t\tif (javaClass != null) {\n-\t\t\tjavaClass.decompile();\n-\t\t\treturn fieldsMap.get(fld);\n+\t\tJavaClass javaClass = getJavaClassByNode(fld.getParentClass().getTopParentClass());\n+\t\tif (javaClass == null) {\n+\t\t\treturn null;\n \t\t}\n-\t\treturn null;\n+\t\tloadJavaClass(javaClass);\n+\t\tjavaField = fieldsMap.get(fld);\n+\t\tif (javaField != null) {\n+\t\t\treturn javaField;\n+\t\t}\n+\t\tif (fld.getParentClass().hasNotGeneratedParent()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tthrow new JadxRuntimeException(\"JavaField not found by FieldNode: \" + fld);\n \t}\n \n \t@Nullable\n \tJavaNode convertNode(Object obj) {\n \t\tif (!(obj instanceof LineAttrNode)) {\n \t\t\treturn null;\n \t\t}\n+\t\tLineAttrNode node = (LineAttrNode) obj;\n+\t\tif (node.contains(AFlag.DONT_GENERATE)) {\n+\t\t\treturn null;\n+\t\t}\n \t\tif (obj instanceof ClassNode) {\n-\t\t\treturn getClassesMap().get(obj);\n+\t\t\treturn getJavaClassByNode((ClassNode) obj);\n \t\t}\n \t\tif (obj instanceof MethodNode) {\n \t\t\treturn getJavaMethodByNode(((MethodNode) obj));\n \t\t}\n \t\tif (obj instanceof FieldNode) {\n \t\t\treturn getJavaFieldByNode((FieldNode) obj);\n \t\t}\n-\t\treturn null;\n+\t\tthrow new JadxRuntimeException(\"Unexpected node type: \" + obj);\n \t}\n \n \t@Nullable\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JavaClass.java b/jadx-core/src/main/java/jadx/api/JavaClass.java\n--- a/jadx-core/src/main/java/jadx/api/JavaClass.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java\n@@ -10,7 +10,6 @@\n import org.jetbrains.annotations.Nullable;\n \n import jadx.core.dex.attributes.AFlag;\n-import jadx.core.dex.attributes.nodes.LineAttrNode;\n import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.FieldNode;\n@@ -78,7 +77,6 @@ private void loadLists() {\n \t\tlistsLoaded = true;\n \t\tdecompile();\n \n-\t\tJadxDecompiler rootDecompiler = getRootDecompiler();\n \t\tint inClsCount = cls.getInnerClasses().size();\n \t\tif (inClsCount != 0) {\n \t\t\tList<JavaClass> list = new ArrayList<>(inClsCount);\n@@ -87,7 +85,6 @@ private void loadLists() {\n \t\t\t\t\tJavaClass javaClass = new JavaClass(inner, this);\n \t\t\t\t\tjavaClass.loadLists();\n \t\t\t\t\tlist.add(javaClass);\n-\t\t\t\t\trootDecompiler.getClassesMap().put(inner, javaClass);\n \t\t\t\t}\n \t\t\t}\n \t\t\tthis.innerClasses = Collections.unmodifiableList(list);\n@@ -100,7 +97,6 @@ private void loadLists() {\n \t\t\t\tif (!f.contains(AFlag.DONT_GENERATE)) {\n \t\t\t\t\tJavaField javaField = new JavaField(f, this);\n \t\t\t\t\tflds.add(javaField);\n-\t\t\t\t\trootDecompiler.getFieldsMap().put(f, javaField);\n \t\t\t\t}\n \t\t\t}\n \t\t\tthis.fields = Collections.unmodifiableList(flds);\n@@ -113,7 +109,6 @@ private void loadLists() {\n \t\t\t\tif (!m.contains(AFlag.DONT_GENERATE)) {\n \t\t\t\t\tJavaMethod javaMethod = new JavaMethod(this, m);\n \t\t\t\t\tmths.add(javaMethod);\n-\t\t\t\t\trootDecompiler.getMethodsMap().put(m, javaMethod);\n \t\t\t\t}\n \t\t\t}\n \t\t\tmths.sort(Comparator.comparing(JavaMethod::getName));\n@@ -145,11 +140,9 @@ public Map<CodePosition, JavaNode> getUsageMap() {\n \t\tfor (Map.Entry<CodePosition, Object> entry : map.entrySet()) {\n \t\t\tCodePosition codePosition = entry.getKey();\n \t\t\tObject obj = entry.getValue();\n-\t\t\tif (obj instanceof LineAttrNode) {\n-\t\t\t\tJavaNode node = getRootDecompiler().convertNode(obj);\n-\t\t\t\tif (node != null) {\n-\t\t\t\t\tresultMap.put(codePosition, node);\n-\t\t\t\t}\n+\t\t\tJavaNode node = getRootDecompiler().convertNode(obj);\n+\t\t\tif (node != null) {\n+\t\t\t\tresultMap.put(codePosition, node);\n \t\t\t}\n \t\t}\n \t\treturn resultMap;\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JavaField.java b/jadx-core/src/main/java/jadx/api/JavaField.java\n--- a/jadx-core/src/main/java/jadx/api/JavaField.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaField.java\n@@ -46,6 +46,10 @@ public int getDecompiledLine() {\n \t\treturn field.getDecompiledLine();\n \t}\n \n+\tFieldNode getFieldNode() {\n+\t\treturn field;\n+\t}\n+\n \t@Override\n \tpublic int hashCode() {\n \t\treturn field.hashCode();\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JavaMethod.java b/jadx-core/src/main/java/jadx/api/JavaMethod.java\n--- a/jadx-core/src/main/java/jadx/api/JavaMethod.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java\n@@ -74,6 +74,10 @@ public int getDecompiledLine() {\n \t\treturn mth.getDecompiledLine();\n \t}\n \n+\tMethodNode getMethodNode() {\n+\t\treturn mth;\n+\t}\n+\n \t@Override\n \tpublic int hashCode() {\n \t\treturn mth.hashCode();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -414,6 +414,17 @@ public ClassNode getTopParentClass() {\n \t\treturn parent == this ? this : parent.getTopParentClass();\n \t}\n \n+\tpublic boolean hasNotGeneratedParent() {\n+\t\tif (contains(AFlag.DONT_GENERATE)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tClassNode parent = getParentClass();\n+\t\tif (parent == this) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn parent.hasNotGeneratedParent();\n+\t}\n+\n \tpublic List<ClassNode> getInnerClasses() {\n \t\treturn innerClasses;\n \t}\n@@ -543,4 +554,5 @@ public boolean equals(Object o) {\n \tpublic String toString() {\n \t\treturn clsInfo.getFullName();\n \t}\n+\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/JadxGUI.java b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxGUI.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java\n@@ -5,6 +5,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.cli.LogHelper;\n import jadx.gui.settings.JadxSettings;\n import jadx.gui.settings.JadxSettingsAdapter;\n import jadx.gui.ui.MainWindow;\n@@ -18,6 +19,7 @@ public static void main(String[] args) {\n \t\ttry {\n \t\t\tLogCollector.register();\n \t\t\tfinal JadxSettings settings = JadxSettingsAdapter.load();\n+\t\t\tsettings.setLogLevel(LogHelper.LogLevelEnum.INFO);\n \t\t\t// overwrite loaded settings by command line arguments\n \t\t\tif (!settings.overrideProvided(args)) {\n \t\t\t\treturn;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -23,6 +23,7 @@\n \n import jadx.api.JadxArgs;\n import jadx.cli.JadxCLIArgs;\n+import jadx.cli.LogHelper;\n import jadx.gui.ui.MainWindow;\n import jadx.gui.ui.codearea.EditorTheme;\n import jadx.gui.utils.FontUtils;\n@@ -40,7 +41,8 @@ public class JadxSettings extends JadxCLIArgs {\n \n \tstatic final Set<String> SKIP_FIELDS = new HashSet<>(Arrays.asList(\n \t\t\t\"files\", \"input\", \"outDir\", \"outDirSrc\", \"outDirRes\", \"outputFormat\",\n-\t\t\t\"verbose\", \"printVersion\", \"printHelp\"));\n+\t\t\t\"verbose\", \"quiet\", \"logLevel\",\n+\t\t\t\"printVersion\", \"printHelp\"));\n \n \tprivate Path lastSaveProjectPath = USER_HOME;\n \tprivate Path lastOpenFilePath = USER_HOME;\n@@ -359,6 +361,10 @@ public void setFont(@Nullable Font font) {\n \t\t}\n \t}\n \n+\tpublic void setLogLevel(LogHelper.LogLevelEnum level) {\n+\t\tthis.logLevel = level;\n+\t}\n+\n \tpublic String getEditorThemePath() {\n \t\treturn editorThemePath;\n \t}",
    "output": "Fix make correct class members loading in jadx api"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java\n@@ -15,6 +15,8 @@\n import jadx.gui.treemodel.JClass;\n import jadx.gui.treemodel.JNode;\n import jadx.gui.ui.ContentPanel;\n+import jadx.gui.ui.MainWindow;\n+import jadx.gui.utils.JNodeCache;\n import jadx.gui.utils.JumpPosition;\n \n /**\n@@ -109,14 +111,31 @@ public JumpPosition getDefPosForNodeAtOffset(int offset) {\n \t\tif (pos == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tJNode jNode = contentPanel.getTabbedPane().getMainWindow().getCacheObject().getNodeCache().makeFrom(foundNode);\n+\t\tJNode jNode = convertJavaNode(foundNode);\n \t\treturn new JumpPosition(jNode.getRootClass(), pos.getLine());\n \t}\n \n+\tprivate JNode convertJavaNode(JavaNode javaNode) {\n+\t\tJNodeCache nodeCache = getMainWindow().getCacheObject().getNodeCache();\n+\t\treturn nodeCache.makeFrom(javaNode);\n+\t}\n+\n+\t@Nullable\n+\tpublic JNode getJNodeAtOffset(int offset) {\n+\t\tJavaNode javaNode = getJavaNodeAtOffset(offset);\n+\t\tif (javaNode != null) {\n+\t\t\treturn convertJavaNode(javaNode);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \t/**\n \t * Search referenced java node by offset in {@code jCls} code\n \t */\n \tpublic JavaNode getJavaNodeAtOffset(int offset) {\n+\t\tif (offset == -1) {\n+\t\t\treturn null;\n+\t\t}\n \t\ttry {\n \t\t\t// TODO: add direct mapping for code offset to CodeWriter (instead of line and line offset pair)\n \t\t\tint line = this.getLineOfOffset(offset);\n@@ -128,7 +147,11 @@ public JavaNode getJavaNodeAtOffset(int offset) {\n \t\treturn null;\n \t}\n \n+\tpublic MainWindow getMainWindow() {\n+\t\treturn contentPanel.getTabbedPane().getMainWindow();\n+\t}\n+\n \tprivate JadxDecompiler getDecompiler() {\n-\t\treturn contentPanel.getTabbedPane().getMainWindow().getWrapper().getDecompiler();\n+\t\treturn getMainWindow().getWrapper().getDecompiler();\n \t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FindUsageAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FindUsageAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/FindUsageAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/FindUsageAction.java\n@@ -2,11 +2,13 @@\n \n import java.awt.event.ActionEvent;\n \n-import jadx.gui.ui.MainWindow;\n+import org.jetbrains.annotations.Nullable;\n+\n+import jadx.gui.treemodel.JNode;\n import jadx.gui.ui.UsageDialog;\n import jadx.gui.utils.NLS;\n \n-public final class FindUsageAction extends JNodeMenuAction {\n+public final class FindUsageAction extends JNodeMenuAction<JNode> {\n \tprivate static final long serialVersionUID = 4692546569977976384L;\n \n \tpublic FindUsageAction(CodeArea codeArea) {\n@@ -15,11 +17,16 @@ public FindUsageAction(CodeArea codeArea) {\n \n \t@Override\n \tpublic void actionPerformed(ActionEvent e) {\n-\t\tif (jumpPos == null) {\n+\t\tif (node == null) {\n \t\t\treturn;\n \t\t}\n-\t\tMainWindow mainWindow = codeArea.getContentPanel().getTabbedPane().getMainWindow();\n-\t\tUsageDialog usageDialog = new UsageDialog(mainWindow, jumpPos.getNode());\n+\t\tUsageDialog usageDialog = new UsageDialog(codeArea.getMainWindow(), node);\n \t\tusageDialog.setVisible(true);\n \t}\n+\n+\t@Nullable\n+\t@Override\n+\tpublic JNode getNodeByOffset(int offset) {\n+\t\treturn codeArea.getJNodeAtOffset(offset);\n+\t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/GoToDeclarationAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/GoToDeclarationAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/GoToDeclarationAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/GoToDeclarationAction.java\n@@ -2,12 +2,12 @@\n \n import java.awt.event.ActionEvent;\n \n-import javax.swing.*;\n-import javax.swing.event.PopupMenuEvent;\n+import org.jetbrains.annotations.Nullable;\n \n+import jadx.gui.utils.JumpPosition;\n import jadx.gui.utils.NLS;\n \n-public final class GoToDeclarationAction extends JNodeMenuAction {\n+public final class GoToDeclarationAction extends JNodeMenuAction<JumpPosition> {\n \tprivate static final long serialVersionUID = -1186470538894941301L;\n \n \tpublic GoToDeclarationAction(CodeArea codeArea) {\n@@ -16,15 +16,14 @@ public GoToDeclarationAction(CodeArea codeArea) {\n \n \t@Override\n \tpublic void actionPerformed(ActionEvent e) {\n-\t\tif (jumpPos != null) {\n-\t\t\tcodeArea.getContentPanel().getTabbedPane().codeJump(jumpPos);\n+\t\tif (node != null) {\n+\t\t\tcodeArea.getContentPanel().getTabbedPane().codeJump(node);\n \t\t}\n \t}\n \n+\t@Nullable\n \t@Override\n-\tpublic void popupMenuWillBecomeVisible(PopupMenuEvent e) {\n-\t\tsuper.popupMenuWillBecomeVisible(e);\n-\n-\t\tputValue(Action.SMALL_ICON, jumpPos == null ? null : jumpPos.getNode().getIcon());\n+\tpublic JumpPosition getNodeByOffset(int offset) {\n+\t\treturn codeArea.getDefPosForNodeAtOffset(offset);\n \t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/JNodeMenuAction.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/JNodeMenuAction.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/JNodeMenuAction.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/JNodeMenuAction.java\n@@ -10,13 +10,11 @@\n import org.fife.ui.rsyntaxtextarea.Token;\n import org.jetbrains.annotations.Nullable;\n \n-import jadx.gui.utils.JumpPosition;\n-\n-public abstract class JNodeMenuAction extends AbstractAction implements PopupMenuListener {\n+public abstract class JNodeMenuAction<T> extends AbstractAction implements PopupMenuListener {\n \n \tprotected final transient CodeArea codeArea;\n \t@Nullable\n-\tprotected transient JumpPosition jumpPos;\n+\tprotected transient T node;\n \n \tpublic JNodeMenuAction(String name, CodeArea codeArea) {\n \t\tsuper(name);\n@@ -26,19 +24,22 @@ public JNodeMenuAction(String name, CodeArea codeArea) {\n \t@Override\n \tpublic abstract void actionPerformed(ActionEvent e);\n \n+\t@Nullable\n+\tpublic abstract T getNodeByOffset(int offset);\n+\n \t@Override\n \tpublic void popupMenuWillBecomeVisible(PopupMenuEvent e) {\n-\t\tjumpPos = getJumpPos();\n-\t\tsetEnabled(jumpPos != null);\n+\t\tnode = getNode();\n+\t\tsetEnabled(node != null);\n \t}\n \n \t@Nullable\n-\tprivate JumpPosition getJumpPos() {\n+\tprivate T getNode() {\n \t\tPoint pos = codeArea.getMousePosition();\n \t\tif (pos != null) {\n \t\t\tToken token = codeArea.viewToToken(pos);\n \t\t\tint offset = codeArea.adjustOffsetForToken(token);\n-\t\t\treturn codeArea.getDefPosForNodeAtOffset(offset);\n+\t\t\treturn getNodeByOffset(offset);\n \t\t}\n \t\treturn null;\n \t}",
    "output": "Fix yet another fix for broken find usage action"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -38,6 +38,7 @@\n import javax.swing.tree.TreeSelectionModel;\n \n import org.fife.ui.rsyntaxtextarea.Theme;\n+import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -480,9 +481,8 @@ private void toggleDeobfuscation() {\n \t\treOpenFile();\n \t}\n \n-\tprivate void treeClickAction() {\n+\tprivate void nodeClickAction(@Nullable Object obj) {\n \t\ttry {\n-\t\t\tObject obj = tree.getLastSelectedPathComponent();\n \t\t\tif (obj == null) {\n \t\t\t\treturn;\n \t\t\t}\n@@ -507,14 +507,23 @@ private void treeClickAction() {\n \t}\n \n \tprivate void treeRightClickAction(MouseEvent e) {\n-\t\tTreePath path = tree.getPathForLocation(e.getX(), e.getY());\n+\t\tObject obj = getJNodeUnderMouse(e);\n+\t\tif (obj instanceof JPackage) {\n+\t\t\tJPackagePopUp menu = new JPackagePopUp((JPackage) obj);\n+\t\t\tmenu.show(e.getComponent(), e.getX(), e.getY());\n+\t\t}\n+\t}\n+\n+\t@Nullable\n+\tprivate JNode getJNodeUnderMouse(MouseEvent mouseEvent) {\n+\t\tTreePath path = tree.getPathForLocation(mouseEvent.getX(), mouseEvent.getY());\n \t\tif (path != null) {\n \t\t\tObject obj = path.getLastPathComponent();\n-\t\t\tif (obj instanceof JPackage) {\n-\t\t\t\tJPackagePopUp menu = new JPackagePopUp((JPackage) obj);\n-\t\t\t\tmenu.show(e.getComponent(), e.getX(), e.getY());\n+\t\t\tif (obj instanceof JNode) {\n+\t\t\t\treturn (JNode) obj;\n \t\t\t}\n \t\t}\n+\t\treturn null;\n \t}\n \n \tprivate void syncWithEditor() {\n@@ -806,18 +815,18 @@ private void initUI() {\n \t\ttree.addMouseListener(new MouseAdapter() {\n \t\t\t@Override\n \t\t\tpublic void mouseClicked(MouseEvent e) {\n-\t\t\t\tif (SwingUtilities.isRightMouseButton(e)) {\n+\t\t\t\tif (SwingUtilities.isLeftMouseButton(e)) {\n+\t\t\t\t\tnodeClickAction(getJNodeUnderMouse(e));\n+\t\t\t\t} else if (SwingUtilities.isRightMouseButton(e)) {\n \t\t\t\t\ttreeRightClickAction(e);\n-\t\t\t\t} else {\n-\t\t\t\t\ttreeClickAction();\n \t\t\t\t}\n \t\t\t}\n \t\t});\n \t\ttree.addKeyListener(new KeyAdapter() {\n \t\t\t@Override\n \t\t\tpublic void keyPressed(KeyEvent e) {\n \t\t\t\tif (e.getKeyCode() == KeyEvent.VK_ENTER) {\n-\t\t\t\t\ttreeClickAction();\n+\t\t\t\t\tnodeClickAction(tree.getLastSelectedPathComponent());\n \t\t\t\t}\n \t\t\t}\n \t\t});",
    "output": "Fix ignore mouse click on empty space in tree"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java\n@@ -8,4 +8,9 @@ public interface CallMthInterface {\n \tMethodInfo getCallMth();\n \n \tRegisterArg getInstanceArg();\n+\n+\t/**\n+\t * Return offset to match method args from {@link #getCallMth()}\n+\t */\n+\tint getFirstArgOffset();\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java\n@@ -18,7 +18,7 @@ public class InvokeNode extends InsnNode implements CallMthInterface {\n \tprivate final MethodInfo mth;\n \n \tpublic InvokeNode(MethodInfo mth, DecodedInstruction insn, InvokeType type, boolean isRange, int resReg) {\n-\t\tsuper(InsnType.INVOKE, mth.getArgsCount() + (type != InvokeType.STATIC ? 1 : 0));\n+\t\tsuper(InsnType.INVOKE, mth.getArgsCount() + (type == InvokeType.STATIC ? 0 : 1));\n \t\tthis.mth = mth;\n \t\tthis.type = type;\n \n@@ -66,6 +66,11 @@ public RegisterArg getInstanceArg() {\n \t\treturn null;\n \t}\n \n+\t@Override\n+\tpublic int getFirstArgOffset() {\n+\t\treturn type == InvokeType.STATIC ? 0 : 1;\n+\t}\n+\n \t@Override\n \tpublic InsnNode copy() {\n \t\treturn copyCommonParams(new InvokeNode(mth, type, getArgsCount()));\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n@@ -92,6 +92,11 @@ public boolean isSelf() {\n \t\treturn callType == CallType.SELF;\n \t}\n \n+\t@Override\n+\tpublic int getFirstArgOffset() {\n+\t\treturn 0;\n+\t}\n+\n \t@Override\n \tpublic boolean isSame(InsnNode obj) {\n \t\tif (this == obj) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n@@ -143,7 +143,7 @@ protected InsnArg removeArg(int index) {\n \t\treturn arg;\n \t}\n \n-\tprotected int getArgIndex(InsnArg arg) {\n+\tpublic int getArgIndex(InsnArg arg) {\n \t\tint count = getArgsCount();\n \t\tfor (int i = 0; i < count; i++) {\n \t\t\tif (arg == arguments.get(i)) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n@@ -4,6 +4,8 @@\n import java.util.List;\n \n import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.info.MethodInfo;\n+import jadx.core.dex.instructions.CallMthInterface;\n import jadx.core.dex.instructions.ConstStringNode;\n import jadx.core.dex.instructions.IndexInsnNode;\n import jadx.core.dex.instructions.InsnType;\n@@ -203,6 +205,10 @@ private static boolean replaceArg(MethodNode mth, RegisterArg arg, InsnArg const\n \t\t\t}\n \t\t\tif (fieldNode != null) {\n \t\t\t\tlitArg.wrapInstruction(mth, new IndexInsnNode(InsnType.SGET, fieldNode.getFieldInfo(), 0));\n+\t\t\t} else {\n+\t\t\t\tif (needExplicitCast(useInsn, litArg)) {\n+\t\t\t\t\tlitArg.add(AFlag.EXPLICIT_PRIMITIVE_TYPE);\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tif (!useInsn.replaceArg(arg, constArg.duplicate())) {\n@@ -214,4 +220,19 @@ private static boolean replaceArg(MethodNode mth, RegisterArg arg, InsnArg const\n \t\t}\n \t\treturn true;\n \t}\n+\n+\tprivate static boolean needExplicitCast(InsnNode insn, LiteralArg arg) {\n+\t\tif (insn instanceof CallMthInterface) {\n+\t\t\tCallMthInterface callInsn = (CallMthInterface) insn;\n+\t\t\tMethodInfo callMth = callInsn.getCallMth();\n+\t\t\tint offset = callInsn.getFirstArgOffset();\n+\t\t\tint argIndex = insn.getArgIndex(arg);\n+\t\t\tArgType argType = callMth.getArgumentsTypes().get(argIndex - offset);\n+\t\t\tif (argType.isPrimitive()) {\n+\t\t\t\targ.setType(argType);\n+\t\t\t\treturn argType.equals(ArgType.BYTE);\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/enums/TestInnerEnums.java b/jadx-core/src/test/java/jadx/tests/integration/enums/TestInnerEnums.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/enums/TestInnerEnums.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestInnerEnums.java\n@@ -14,9 +14,9 @@ public class TestInnerEnums extends IntegrationTest {\n \tpublic static class TestCls {\n \n \t\tpublic enum Numbers {\n-\t\t\tONE(1, NumString.ONE), TWO(2, NumString.TWO);\n+\t\t\tONE((byte) 1, NumString.ONE), TWO((byte) 2, NumString.TWO);\n \n-\t\t\tprivate final int num;\n+\t\t\tprivate final byte num;\n \t\t\tprivate final NumString str;\n \n \t\t\tpublic enum NumString {\n@@ -33,7 +33,7 @@ public String getName() {\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tNumbers(int n, NumString str) {\n+\t\t\tNumbers(byte n, NumString str) {\n \t\t\t\tthis.num = n;\n \t\t\t\tthis.str = str;\n \t\t\t}\n@@ -63,7 +63,7 @@ public void test() {\n \t\tClassNode cls = getClassNode(TestCls.class);\n \t\tString code = cls.getCode().toString();\n \n-\t\tassertThat(code, containsOne(\"ONE(1, NumString.ONE)\"));\n+\t\tassertThat(code, containsOne(\"ONE((byte) 1, NumString.ONE)\"));\n \t\tassertThat(code, containsOne(\"ONE(\\\"one\\\")\"));\n \t}\n }",
    "output": "Add explicit cast for byte literal in method invoke"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -1,10 +1,12 @@\n package jadx.core.codegen;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.Comparator;\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Set;\n \n import com.android.dx.rop.code.AccessFlags;\n@@ -148,7 +150,7 @@ public void addClassDeclaration(CodeWriter clsCode) {\n \t\tArgType sup = cls.getSuperClass();\n \t\tif (sup != null\n \t\t\t\t&& !sup.equals(ArgType.OBJECT)\n-\t\t\t\t&& !sup.getObject().equals(ArgType.ENUM.getObject())) {\n+\t\t\t\t&& !cls.isEnum()) {\n \t\t\tclsCode.add(\"extends \");\n \t\t\tuseClass(clsCode, sup);\n \t\t\tclsCode.add(' ');\n@@ -513,6 +515,9 @@ private String useClassInternal(ClassInfo useCls, ClassInfo extClsInfo) {\n \t\tif (isClassInnerFor(useCls, extClsInfo)) {\n \t\t\treturn shortName;\n \t\t}\n+\t\tif (extClsInfo.isInner()) {\n+\t\t\treturn expandInnerClassName(useCls, extClsInfo);\n+\t\t}\n \t\tif (isBothClassesInOneTopClass(useCls, extClsInfo)) {\n \t\t\treturn shortName;\n \t\t}\n@@ -550,6 +555,26 @@ private String useClassInternal(ClassInfo useCls, ClassInfo extClsInfo) {\n \t\treturn shortName;\n \t}\n \n+\tprivate String expandInnerClassName(ClassInfo useCls, ClassInfo extClsInfo) {\n+\t\tList<ClassInfo> clsList = new ArrayList<>();\n+\t\tclsList.add(extClsInfo);\n+\t\tClassInfo parentCls = extClsInfo.getParentClass();\n+\t\tboolean addImport = true;\n+\t\twhile (parentCls != null) {\n+\t\t\tif (parentCls == useCls || isClassInnerFor(useCls, parentCls)) {\n+\t\t\t\taddImport = false;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tclsList.add(parentCls);\n+\t\t\tparentCls = parentCls.getParentClass();\n+\t\t}\n+\t\tCollections.reverse(clsList);\n+\t\tif (addImport) {\n+\t\t\taddImport(clsList.get(0));\n+\t\t}\n+\t\treturn Utils.listToString(clsList, \".\", ClassInfo::getAliasShortName);\n+\t}\n+\n \tprivate void addImport(ClassInfo classInfo) {\n \t\tif (parentGen != null) {\n \t\t\tparentGen.addImport(classInfo);\n@@ -579,7 +604,7 @@ private static boolean isBothClassesInOneTopClass(ClassInfo useCls, ClassInfo ex\n \tprivate static boolean isClassInnerFor(ClassInfo inner, ClassInfo parent) {\n \t\tif (inner.isInner()) {\n \t\t\tClassInfo p = inner.getParentClass();\n-\t\t\treturn p.equals(parent) || isClassInnerFor(p, parent);\n+\t\t\treturn Objects.equals(p, parent) || isClassInnerFor(p, parent);\n \t\t}\n \t\treturn false;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -44,13 +44,19 @@ public class EnumVisitor extends AbstractVisitor {\n \n \t@Override\n \tpublic boolean visit(ClassNode cls) throws JadxException {\n-\t\tif (!cls.isEnum()) {\n+\t\tif (!convertToEnum(cls)) {\n \t\t\tAccessInfo accessFlags = cls.getAccessFlags();\n \t\t\tif (accessFlags.isEnum()) {\n \t\t\t\tcls.setAccessFlags(accessFlags.remove(AccessFlags.ACC_ENUM));\n-\t\t\t\tcls.addAttr(AType.COMMENTS, \"'enum' access flag removed\");\n+\t\t\t\tcls.addAttr(AType.COMMENTS, \"'enum' modifier removed\");\n \t\t\t}\n-\t\t\treturn true;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate boolean convertToEnum(ClassNode cls) {\n+\t\tif (!cls.isEnum()) {\n+\t\t\treturn false;\n \t\t}\n \t\t// search class init method\n \t\tMethodNode staticMethod = null;\n@@ -63,7 +69,7 @@ public boolean visit(ClassNode cls) throws JadxException {\n \t\t}\n \t\tif (staticMethod == null) {\n \t\t\tErrorsCounter.classWarn(cls, \"Enum class init method not found\");\n-\t\t\treturn true;\n+\t\t\treturn false;\n \t\t}\n \n \t\tArgType clsType = cls.getClassInfo().getType();\n@@ -167,7 +173,7 @@ public boolean visit(ClassNode cls) throws JadxException {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\treturn false;\n+\t\treturn true;\n \t}\n \n \tprivate static void processEnumInnerCls(ConstructorInsn co, EnumField field, ClassNode innerCls) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/enums/TestInnerEnums.java b/jadx-core/src/test/java/jadx/tests/integration/enums/TestInnerEnums.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/enums/TestInnerEnums.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestInnerEnums.java\n@@ -0,0 +1,69 @@\n+package jadx.tests.integration.enums;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class TestInnerEnums extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic enum Numbers {\n+\t\t\tONE(1, NumString.ONE), TWO(2, NumString.TWO);\n+\n+\t\t\tprivate final int num;\n+\t\t\tprivate final NumString str;\n+\n+\t\t\tpublic enum NumString {\n+\t\t\t\tONE(\"one\"), TWO(\"two\");\n+\n+\t\t\t\tprivate final String name;\n+\n+\t\t\t\tNumString(String name) {\n+\t\t\t\t\tthis.name = name;\n+\t\t\t\t}\n+\n+\t\t\t\tpublic String getName() {\n+\t\t\t\t\treturn name;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tNumbers(int n, NumString str) {\n+\t\t\t\tthis.num = n;\n+\t\t\t\tthis.str = str;\n+\t\t\t}\n+\n+\t\t\tpublic int getNum() {\n+\t\t\t\treturn num;\n+\t\t\t}\n+\n+\t\t\tpublic NumString getNumStr() {\n+\t\t\t\treturn str;\n+\t\t\t}\n+\n+\t\t\tpublic String getName() {\n+\t\t\t\treturn str.getName();\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertEquals(1, Numbers.ONE.getNum());\n+\t\t\tassertEquals(Numbers.NumString.ONE, Numbers.ONE.getNumStr());\n+\t\t\tassertEquals(\"one\", Numbers.ONE.getName());\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"ONE(1, NumString.ONE)\"));\n+\t\tassertThat(code, containsOne(\"ONE(\\\"one\\\")\"));\n+\t}\n+}",
    "output": "Fix convert inner enums and fix inner classes reference"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JavaClass.java b/jadx-core/src/main/java/jadx/api/JavaClass.java\n--- a/jadx-core/src/main/java/jadx/api/JavaClass.java\n+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java\n@@ -25,6 +25,7 @@ public final class JavaClass implements JavaNode {\n \tprivate List<JavaClass> innerClasses = Collections.emptyList();\n \tprivate List<JavaField> fields = Collections.emptyList();\n \tprivate List<JavaMethod> methods = Collections.emptyList();\n+\tprivate boolean listsLoaded;\n \n \tJavaClass(ClassNode classNode, JadxDecompiler decompiler) {\n \t\tthis.decompiler = decompiler;\n@@ -59,7 +60,6 @@ public synchronized void decompile() {\n \t\t}\n \t\tif (cls.getCode() == null) {\n \t\t\tcls.decompile();\n-\t\t\tload();\n \t\t}\n \t}\n \n@@ -75,21 +75,28 @@ public synchronized String getSmali() {\n \n \tpublic synchronized void unload() {\n \t\tcls.unload();\n+\t\tlistsLoaded = false;\n \t}\n \n \tpublic ClassNode getClassNode() {\n \t\treturn cls;\n \t}\n \n-\tprivate void load() {\n+\tprivate void loadLists() {\n+\t\tif (listsLoaded) {\n+\t\t\treturn;\n+\t\t}\n+\t\tlistsLoaded = true;\n+\t\tdecompile();\n+\n \t\tJadxDecompiler rootDecompiler = getRootDecompiler();\n \t\tint inClsCount = cls.getInnerClasses().size();\n \t\tif (inClsCount != 0) {\n \t\t\tList<JavaClass> list = new ArrayList<>(inClsCount);\n \t\t\tfor (ClassNode inner : cls.getInnerClasses()) {\n \t\t\t\tif (!inner.contains(AFlag.DONT_GENERATE)) {\n \t\t\t\t\tJavaClass javaClass = new JavaClass(inner, this);\n-\t\t\t\t\tjavaClass.load();\n+\t\t\t\t\tjavaClass.loadLists();\n \t\t\t\t\tlist.add(javaClass);\n \t\t\t\t\trootDecompiler.getClassesMap().put(inner, javaClass);\n \t\t\t\t}\n@@ -205,17 +212,17 @@ public AccessInfo getAccessInfo() {\n \t}\n \n \tpublic List<JavaClass> getInnerClasses() {\n-\t\tdecompile();\n+\t\tloadLists();\n \t\treturn innerClasses;\n \t}\n \n \tpublic List<JavaField> getFields() {\n-\t\tdecompile();\n+\t\tloadLists();\n \t\treturn fields;\n \t}\n \n \tpublic List<JavaMethod> getMethods() {\n-\t\tdecompile();\n+\t\tloadLists();\n \t\treturn methods;\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/ProcessClass.java b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n--- a/jadx-core/src/main/java/jadx/core/ProcessClass.java\n+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java\n@@ -5,7 +5,6 @@\n import jadx.api.ICodeInfo;\n import jadx.core.codegen.CodeGen;\n import jadx.core.dex.nodes.ClassNode;\n-import jadx.core.dex.nodes.ProcessState;\n import jadx.core.dex.visitors.DepthTraversal;\n import jadx.core.dex.visitors.IDexTreeVisitor;\n import jadx.core.utils.ErrorsCounter;\n@@ -22,28 +21,16 @@ private ProcessClass() {\n \t}\n \n \tpublic static void process(ClassNode cls) {\n-\t\tprocess(cls, false);\n-\t}\n-\n-\t@NotNull\n-\tpublic static ICodeInfo generateCode(ClassNode cls) {\n-\t\tICodeInfo codeInfo = process(cls, true);\n-\t\tif (codeInfo == null) {\n-\t\t\tthrow new JadxRuntimeException(\"Failed to generate code for class: \" + cls.getFullName());\n-\t\t}\n-\t\treturn codeInfo;\n-\t}\n-\n-\tprivate static ICodeInfo process(ClassNode cls, boolean generateCode) {\n \t\tClassNode topParentClass = cls.getTopParentClass();\n \t\tif (topParentClass != cls) {\n-\t\t\treturn process(topParentClass, generateCode);\n+\t\t\tprocess(topParentClass);\n+\t\t\treturn;\n \t\t}\n-\t\tif (!generateCode && cls.getState() == PROCESS_COMPLETE) {\n+\t\tif (cls.getState() == PROCESS_COMPLETE) {\n \t\t\t// nothing to do\n-\t\t\treturn null;\n+\t\t\treturn;\n \t\t}\n-\t\tsynchronized (getSyncObj(cls)) {\n+\t\tsynchronized (cls.getClassInfo()) {\n \t\t\ttry {\n \t\t\t\tif (cls.getState() == NOT_LOADED) {\n \t\t\t\t\tcls.load();\n@@ -55,27 +42,26 @@ private static ICodeInfo process(ClassNode cls, boolean generateCode) {\n \t\t\t\t\t}\n \t\t\t\t\tcls.setState(PROCESS_COMPLETE);\n \t\t\t\t}\n-\t\t\t\tif (generateCode && cls.getState() == PROCESS_COMPLETE) {\n-\t\t\t\t\tprocessDependencies(cls);\n-\t\t\t\t\tICodeInfo code = CodeGen.generate(cls);\n-\t\t\t\t\tcls.setState(ProcessState.GENERATED);\n-\t\t\t\t\t// TODO: unload class (need to build dependency tree or allow to load class several times)\n-\t\t\t\t\treturn code;\n-\t\t\t\t}\n \t\t\t} catch (Throwable e) {\n \t\t\t\tErrorsCounter.classError(cls, e.getClass().getSimpleName(), e);\n \t\t\t}\n \t\t}\n-\t\treturn null;\n \t}\n \n-\tprivate static Object getSyncObj(ClassNode cls) {\n-\t\treturn cls.getClassInfo();\n-\t}\n+\t@NotNull\n+\tpublic static ICodeInfo generateCode(ClassNode cls) {\n+\t\tClassNode topParentClass = cls.getTopParentClass();\n+\t\tif (topParentClass != cls) {\n+\t\t\treturn generateCode(topParentClass);\n+\t\t}\n+\t\ttry {\n+\t\t\tprocess(cls);\n+\t\t\tcls.getDependencies().forEach(ProcessClass::process);\n \n-\tprivate static void processDependencies(ClassNode cls) {\n-\t\tfor (ClassNode depCls : cls.getDependencies()) {\n-\t\t\tprocess(depCls, false);\n+\t\t\t// TODO: unload class (need to build dependency tree or allow to load class several times)\n+\t\t\treturn CodeGen.generate(cls);\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow new JadxRuntimeException(\"Failed to generate code for class: \" + cls.getFullName(), e);\n \t\t}\n \t}\n }",
    "output": "Remove synchronization lock for code generation"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -40,6 +40,7 @@\n import jadx.core.dex.instructions.args.InsnWrapArg;\n import jadx.core.dex.instructions.args.LiteralArg;\n import jadx.core.dex.instructions.args.Named;\n+import jadx.core.dex.instructions.args.NamedArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n import jadx.core.dex.instructions.args.SSAVar;\n import jadx.core.dex.instructions.mods.ConstructorInsn;\n@@ -874,6 +875,13 @@ private boolean inlineMethod(MethodNode callMthNode, InvokeNode insn, CodeWriter\n \t\tif (Consts.DEBUG) {\n \t\t\tcode.add(\"/* inline method: \").add(callMthNode.toString()).add(\"*/\").startLine();\n \t\t}\n+\t\tif (forceAssign(inl, insn, callMthNode)) {\n+\t\t\tArgType varType = callMthNode.getReturnType();\n+\t\t\tuseType(code, varType);\n+\t\t\tcode.add(' ');\n+\t\t\tcode.add(mgen.getNameGen().assignNamedArg(new NamedArg(\"unused\", varType)));\n+\t\t\tcode.add(\" = \");\n+\t\t}\n \t\tif (callMthNode.getMethodInfo().getArgumentsTypes().isEmpty()) {\n \t\t\tmakeInsn(inl, code, Flags.BODY_ONLY);\n \t\t} else {\n@@ -907,6 +915,19 @@ private boolean inlineMethod(MethodNode callMthNode, InvokeNode insn, CodeWriter\n \t\treturn true;\n \t}\n \n+\tprivate boolean forceAssign(InsnNode inlineInsn, InvokeNode parentInsn, MethodNode callMthNode) {\n+\t\tif (parentInsn.getResult() != null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (parentInsn.contains(AFlag.WRAPPED)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (callMthNode.getReturnType().equals(ArgType.VOID)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n \tprivate void makeTernary(TernaryInsn insn, CodeWriter code, Set<Flags> state) throws CodegenException {\n \t\tboolean wrap = state.contains(Flags.BODY_ONLY);\n \t\tif (wrap) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inline/TestGetterInlineNegative.java b/jadx-core/src/test/java/jadx/tests/integration/inline/TestGetterInlineNegative.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inline/TestGetterInlineNegative.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inline/TestGetterInlineNegative.java\n@@ -0,0 +1,43 @@\n+package jadx.tests.integration.inline;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestGetterInlineNegative extends SmaliTest {\n+\n+\t// @formatter:off\n+\t/*\n+\t\tpublic class TestGetterInlineNegative {\n+\t\t\tpublic static final String field = \"some string\";\n+\n+\t\t\tpublic static synthetic String getter() {\n+\t\t\t\treturn field;\n+\t\t\t}\n+\n+\t\t\tpublic void test() {\n+\t\t\t\tgetter(); // inline will produce 'field;' and fail to compile with 'not a statement' error\n+\t\t\t}\n+\n+\t\t\tpublic String test2() {\n+\t\t\t\treturn getter();\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmali();\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, not(containsString(indent() + \"field;\")));\n+\t\tassertThat(code, containsOne(\"return field;\"));\n+\t}\n+}",
    "output": "Add assign for inlined getter methods"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java\n@@ -3,6 +3,7 @@\n import com.android.dx.rop.code.AccessFlags;\n \n import jadx.core.Consts;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public class AccessInfo {\n \n@@ -63,6 +64,10 @@ public boolean isPrivate() {\n \t\treturn (accFlags & AccessFlags.ACC_PRIVATE) != 0;\n \t}\n \n+\tpublic boolean isPackagePrivate() {\n+\t\treturn (accFlags & VISIBILITY_FLAGS) == 0;\n+\t}\n+\n \tpublic boolean isAbstract() {\n \t\treturn (accFlags & AccessFlags.ACC_ABSTRACT) != 0;\n \t}\n@@ -188,6 +193,22 @@ public String makeString() {\n \t\treturn code.toString();\n \t}\n \n+\tpublic String visibilityName() {\n+\t\tif (isPackagePrivate()) {\n+\t\t\treturn \"package-private\";\n+\t\t}\n+\t\tif (isPublic()) {\n+\t\t\treturn \"public\";\n+\t\t}\n+\t\tif (isPrivate()) {\n+\t\t\treturn \"private\";\n+\t\t}\n+\t\tif (isProtected()) {\n+\t\t\treturn \"protected\";\n+\t\t}\n+\t\tthrow new JadxRuntimeException(\"Unknown visibility flags: \" + getVisibility());\n+\t}\n+\n \tpublic String rawString() {\n \t\tswitch (type) {\n \t\t\tcase CLASS:\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n@@ -38,7 +38,7 @@ public static void changeVisibility(ICodeNode node, int newVisFlag) {\n \t\tAccessInfo newAccFlags = accessFlags.changeVisibility(newVisFlag);\n \t\tif (newAccFlags != accessFlags) {\n \t\t\tnode.setAccessFlags(newAccFlags);\n-\t\t\tnode.addAttr(AType.COMMENTS, \"access modifiers changed from: \" + accessFlags.getVisibility().rawString());\n+\t\t\tnode.addAttr(AType.COMMENTS, \"access modifiers changed from: \" + accessFlags.visibilityName());\n \t\t}\n \t}",
    "output": "Use nice name for 'package-private' in modifiers change message"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/DeboxingVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/DeboxingVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/DeboxingVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DeboxingVisitor.java\n@@ -14,6 +14,7 @@\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n+import jadx.core.dex.instructions.args.SSAVar;\n import jadx.core.dex.nodes.BlockNode;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n@@ -90,14 +91,16 @@ private InsnNode checkForReplace(InvokeNode insnNode) {\n \t\tif (valueOfMths.contains(callMth)) {\n \t\t\tRegisterArg resArg = insnNode.getResult();\n \t\t\tInsnArg arg = insnNode.getArg(0);\n-\t\t\tif (arg.isLiteral() && checkArgUsage(resArg)) {\n+\t\t\tif (arg.isLiteral()) {\n \t\t\t\tArgType primitiveType = callMth.getArgumentsTypes().get(0);\n \t\t\t\tArgType boxType = callMth.getReturnType();\n \t\t\t\tif (isNeedExplicitCast(resArg, primitiveType, boxType)) {\n \t\t\t\t\targ.add(AFlag.EXPLICIT_PRIMITIVE_TYPE);\n \t\t\t\t}\n-\t\t\t\tresArg.setType(primitiveType);\n \t\t\t\targ.setType(primitiveType);\n+\t\t\t\tif (canChangeTypeToPrimitive(resArg)) {\n+\t\t\t\t\tresArg.setType(primitiveType);\n+\t\t\t\t}\n \n \t\t\t\tInsnNode constInsn = new InsnNode(InsnType.CONST, 1);\n \t\t\t\tconstInsn.addArg(arg);\n@@ -122,17 +125,23 @@ private boolean isNeedExplicitCast(RegisterArg resArg, ArgType primitiveType, Ar\n \t\treturn false;\n \t}\n \n-\tprivate boolean checkArgUsage(RegisterArg arg) {\n-\t\tfor (RegisterArg useArg : arg.getSVar().getUseList()) {\n-\t\t\tInsnNode parentInsn = useArg.getParentInsn();\n-\t\t\tif (parentInsn == null) {\n+\tprivate boolean canChangeTypeToPrimitive(RegisterArg arg) {\n+\t\tfor (SSAVar ssaVar : arg.getSVar().getCodeVar().getSsaVars()) {\n+\t\t\tRegisterArg assignArg = ssaVar.getAssign();\n+\t\t\tif (assignArg.contains(AFlag.IMMUTABLE_TYPE)) {\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tif (parentInsn.getType() == InsnType.INVOKE) {\n-\t\t\t\tInvokeNode invokeNode = (InvokeNode) parentInsn;\n-\t\t\t\tif (useArg.equals(invokeNode.getInstanceArg())) {\n+\t\t\tfor (RegisterArg useArg : ssaVar.getUseList()) {\n+\t\t\t\tInsnNode parentInsn = useArg.getParentInsn();\n+\t\t\t\tif (parentInsn == null) {\n \t\t\t\t\treturn false;\n \t\t\t\t}\n+\t\t\t\tif (parentInsn.getType() == InsnType.INVOKE) {\n+\t\t\t\t\tInvokeNode invokeNode = (InvokeNode) parentInsn;\n+\t\t\t\t\tif (useArg.equals(invokeNode.getInstanceArg())) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn true;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing2.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing2.java\n@@ -0,0 +1,49 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static jadx.tests.api.utils.JadxMatchers.countString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class TestDeboxing2 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic long test(Long l) {\n+\t\t\tif (l == null) {\n+\t\t\t\tl = 0L;\n+\t\t\t}\n+\t\t\treturn l;\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(test(null), is(0L));\n+\t\t\tassertThat(test(0L), is(0L));\n+\t\t\tassertThat(test(7L), is(7L));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"long test(Long l)\"));\n+\t\tassertThat(code, containsOne(\"if (l == null) {\"));\n+\t\tassertThat(code, containsOne(\"l = 0L;\"));\n+\n+\t\t// checks for 'check' method\n+\t\tassertThat(code, containsOne(\"test(null)\"));\n+\t\tassertThat(code, containsOne(\"test(0L)\"));\n+\t\tassertThat(code, countString(2, \"is(0L)\"));\n+\t\tassertThat(code, containsOne(\"test(7L)\"));\n+\t\tassertThat(code, containsOne(\"is(7L)\"));\n+\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing3.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestDeboxing3.java\n@@ -0,0 +1,60 @@\n+package jadx.tests.integration.others;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.NotYetImplemented;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestDeboxing3 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic static class Pair<F, S> {\n+\t\t\tpublic F first;\n+\t\t\tpublic S second;\n+\t\t}\n+\n+\t\tprivate Map<String, Pair<Long, String>> cache = new HashMap<>();\n+\n+\t\tpublic boolean test(String id, Long l) {\n+\t\t\tif (l == null) {\n+\t\t\t\tl = 900000L;\n+\t\t\t}\n+\t\t\tPair<Long, String> pair = this.cache.get(id);\n+\t\t\tif (pair == null) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\treturn pair.first + l > System.currentTimeMillis();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"l = 900000L;\"));\n+\t}\n+\n+\t@Test\n+\t@NotYetImplemented(\"Full deboxing and generics propagation\")\n+\tpublic void testFull() {\n+\t\tnoDebugInfo();\n+\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"Pair<Long, String> pair = this.cache.get(id);\"));\n+\t\tassertThat(code, containsOne(\"return pair.first + l > System.currentTimeMillis();\"));\n+\n+\t}\n+}",
    "output": "Fix don't override type of method parameter in const deboxing"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -602,7 +602,7 @@ private void makeConstructor(ConstructorInsn insn, CodeWriter code)\n \t\t\tcode.add(\"new \");\n \t\t\tuseClass(code, insn.getClassType());\n \t\t\tArgType argType = insn.getResult().getSVar().getCodeVar().getType();\n-\t\t\tif (argType.isGeneric()) {\n+\t\t\tif (argType != null && argType.isGeneric()) {\n \t\t\t\tcode.add('<');\n \t\t\t\tif (insn.contains(AFlag.EXPLICIT_GENERICS)) {\n \t\t\t\t\tboolean first = true;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -165,11 +165,12 @@ private void addMethodArguments(CodeWriter code, List<RegisterArg> args) {\n \t\t\t\tcode.add(\"final \");\n \t\t\t}\n \t\t\tArgType argType;\n-\t\t\tif (var.getType() == ArgType.UNKNOWN) {\n+\t\t\tArgType varType = var.getType();\n+\t\t\tif (varType == null || varType == ArgType.UNKNOWN) {\n \t\t\t\t// occur on decompilation errors\n \t\t\t\targType = mthArg.getInitType();\n \t\t\t} else {\n-\t\t\t\targType = var.getType();\n+\t\t\t\targType = varType;\n \t\t\t}\n \t\t\tif (!it.hasNext() && mth.getAccessFlags().isVarArgs()) {\n \t\t\t\t// change last array argument to varargs\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n@@ -330,7 +330,7 @@ protected final <T extends InsnNode> T copyCommonParams(T copy) {\n \t\t\t\t\tInsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();\n \t\t\t\t\tcopy.addArg(InsnArg.wrapArg(wrapInsn.copy()));\n \t\t\t\t} else {\n-\t\t\t\t\tcopy.addArg(arg);\n+\t\t\t\t\tcopy.addArg(arg.duplicate());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -27,7 +27,6 @@\n import jadx.core.utils.ErrorsCounter;\n import jadx.core.utils.StringUtils;\n import jadx.core.utils.android.AndroidResourcesUtils;\n-import jadx.core.utils.exceptions.DecodeException;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.core.utils.files.DexFile;\n import jadx.core.utils.files.InputFile;\n@@ -232,14 +231,6 @@ public ArgType getMethodGenericReturnType(MethodInfo callMth) {\n \t\tMethodNode methodNode = deepResolveMethod(callMth);\n \t\tif (methodNode != null) {\n \t\t\tArgType returnType = methodNode.getReturnType();\n-\t\t\tif (returnType == null) {\n-\t\t\t\ttry {\n-\t\t\t\t\tmethodNode.load();\n-\t\t\t\t\treturnType = methodNode.getReturnType();\n-\t\t\t\t} catch (DecodeException e) {\n-\t\t\t\t\tLOG.error(\"Method load error\", e);\n-\t\t\t\t}\n-\t\t\t}\n \t\t\tif (returnType != null && (returnType.isGeneric() || returnType.isGenericType())) {\n \t\t\t\treturn returnType;\n \t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java\n@@ -1,5 +1,6 @@\n package jadx.core.dex.visitors;\n \n+import java.util.ArrayList;\n import java.util.List;\n \n import com.android.dx.rop.code.AccessFlags;\n@@ -93,7 +94,14 @@ private static void addInlineAttr(MethodNode mth, InsnNode insn) {\n \t\t\tif (Consts.DEBUG) {\n \t\t\t\tmth.addAttr(AType.COMMENTS, \"Removed for inline\");\n \t\t\t} else {\n-\t\t\t\tmth.addAttr(new MethodInlineAttr(insn));\n+\t\t\t\tInsnNode copy = insn.copy();\n+\t\t\t\t// unbind SSA variables from copy instruction\n+\t\t\t\tList<RegisterArg> regArgs = new ArrayList<>();\n+\t\t\t\tcopy.getRegisterArgs(regArgs);\n+\t\t\t\tfor (RegisterArg regArg : regArgs) {\n+\t\t\t\t\tcopy.replaceArg(regArg, regArg.duplicate(regArg.getRegNum(), null));\n+\t\t\t\t}\n+\t\t\t\tmth.addAttr(new MethodInlineAttr(copy));\n \t\t\t\tmth.add(AFlag.DONT_GENERATE);\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -43,6 +43,7 @@\n import jadx.core.utils.ErrorsCounter;\n import jadx.core.utils.InsnRemover;\n import jadx.core.utils.RegionUtils;\n+import jadx.core.utils.exceptions.JadxOverflowException;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n import static jadx.core.dex.visitors.regions.IfMakerHelper.confirmMerge;\n@@ -86,7 +87,7 @@ public Region makeRegion(BlockNode startBlock, RegionStack stack) {\n \t\t\tnext = traverse(r, next, stack);\n \t\t\tregionsCount++;\n \t\t\tif (regionsCount > regionsLimit) {\n-\t\t\t\tthrow new JadxRuntimeException(\"Regions count limit reached\");\n+\t\t\t\tthrow new JadxOverflowException(\"Regions count limit reached\");\n \t\t\t}\n \t\t}\n \t\treturn r;",
    "output": "Fix resolve some multi-thread issues"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -303,13 +303,11 @@ private static void initTryCatches(MethodNode mth, Code mthCode, InsnNode[] insn\n \t\t\t// resolve nested try blocks:\n \t\t\t// inner block contains all handlers from outer block => remove these handlers from inner block\n \t\t\t// each handler must be only in one try/catch block\n-\t\t\tfor (TryCatchBlock ct1 : catches) {\n-\t\t\t\tfor (TryCatchBlock ct2 : catches) {\n-\t\t\t\t\tif (ct1 != ct2 && ct2.containsAllHandlers(ct1)) {\n-\t\t\t\t\t\tfor (ExceptionHandler h : ct1.getHandlers()) {\n-\t\t\t\t\t\t\tct2.removeHandler(mth, h);\n-\t\t\t\t\t\t\th.setTryBlock(ct1);\n-\t\t\t\t\t\t}\n+\t\t\tfor (TryCatchBlock outerTry : catches) {\n+\t\t\t\tfor (TryCatchBlock innerTry : catches) {\n+\t\t\t\t\tif (outerTry != innerTry\n+\t\t\t\t\t\t\t&& innerTry.containsAllHandlers(outerTry)) {\n+\t\t\t\t\t\tinnerTry.removeSameHandlers(outerTry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n@@ -522,6 +520,10 @@ public ExceptionHandler addExceptionHandler(ExceptionHandler handler) {\n \t\treturn handler;\n \t}\n \n+\tpublic boolean clearExceptionHandlers() {\n+\t\treturn exceptionHandlers.removeIf(ExceptionHandler::isRemoved);\n+\t}\n+\n \tpublic Iterable<ExceptionHandler> getExceptionHandlers() {\n \t\treturn exceptionHandlers;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java b/jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java\n--- a/jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java\n@@ -32,6 +32,8 @@ public class ExceptionHandler {\n \tprivate TryCatchBlock tryBlock;\n \tprivate boolean isFinally;\n \n+\tprivate boolean removed = false;\n+\n \tpublic ExceptionHandler(int addr, @Nullable ClassInfo type) {\n \t\tthis.handleOffset = addr;\n \t\taddCatchType(type);\n@@ -138,6 +140,14 @@ public void setFinally(boolean isFinally) {\n \t\tthis.isFinally = isFinally;\n \t}\n \n+\tpublic boolean isRemoved() {\n+\t\treturn removed;\n+\t}\n+\n+\tpublic void markForRemove() {\n+\t\tthis.removed = true;\n+\t}\n+\n \t@Override\n \tpublic boolean equals(Object o) {\n \t\tif (this == o) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java\n--- a/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java\n@@ -52,6 +52,17 @@ public ExceptionHandler addHandler(MethodNode mth, int addr, @Nullable ClassInfo\n \t\treturn addedHandler;\n \t}\n \n+\t/**\n+\t * Use only before BlockSplitter\n+\t */\n+\tpublic void removeSameHandlers(TryCatchBlock outerTry) {\n+\t\tfor (ExceptionHandler handler : outerTry.getHandlers()) {\n+\t\t\tif (handlers.remove(handler)) {\n+\t\t\t\thandler.setTryBlock(outerTry);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tpublic void removeHandler(MethodNode mth, ExceptionHandler handler) {\n \t\tfor (Iterator<ExceptionHandler> it = handlers.iterator(); it.hasNext();) {\n \t\t\tExceptionHandler h = it.next();\n@@ -78,9 +89,14 @@ private void unbindHandler(ExceptionHandler handler) {\n \t\t\t}\n \t\t\tSplitterBlockAttr splitter = handler.getHandlerBlock().get(AType.SPLITTER_BLOCK);\n \t\t\tif (splitter != null) {\n-\t\t\t\tsplitter.getBlock().remove(AType.SPLITTER_BLOCK);\n+\t\t\t\tBlockNode splitterBlock = splitter.getBlock();\n+\t\t\t\tsplitterBlock.remove(AType.SPLITTER_BLOCK);\n+\t\t\t\tfor (BlockNode successor : splitterBlock.getSuccessors()) {\n+\t\t\t\t\tsuccessor.remove(AType.SPLITTER_BLOCK);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\thandler.markForRemove();\n \t}\n \n \tprivate void removeWholeBlock(MethodNode mth) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java\n@@ -43,9 +43,12 @@ public void visit(MethodNode mth) {\n \t\t\treturn;\n \t\t}\n \t\ttry {\n+\t\t\tmth.clearExceptionHandlers();\n+\n \t\t\tfor (ExceptionHandler excHandler : mth.getExceptionHandlers()) {\n \t\t\t\tprocessExceptionHandler(mth, excHandler);\n \t\t\t}\n+\t\t\tmth.clearExceptionHandlers();\n \t\t} catch (Exception e) {\n \t\t\tLOG.warn(\"Undo finally extract visitor, mth: {}\", mth, e);\n \t\t\ttry {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n@@ -69,6 +69,16 @@ public static void makeDirs(@Nullable File dir) {\n \t\t}\n \t}\n \n+\tpublic static boolean deleteDir(File dir) {\n+\t\tFile[] content = dir.listFiles();\n+\t\tif (content != null) {\n+\t\t\tfor (File file : content) {\n+\t\t\t\tdeleteDir(file);\n+\t\t\t}\n+\t\t}\n+\t\treturn dir.delete();\n+\t}\n+\n \tprivate static final Path TEMP_ROOT_DIR = createTempRootDir();\n \n \tprivate static Path createTempRootDir() {",
    "output": "Fix improve exception handler remove"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -88,6 +88,7 @@ public MethodNode(ClassNode classNode, Method mthData, boolean isVirtual) {\n \n \t@Override\n \tpublic void unload() {\n+\t\tregsCount = -1;\n \t\tif (noCode) {\n \t\t\treturn;\n \t\t}\n@@ -106,6 +107,10 @@ public void unload() {\n \n \t@Override\n \tpublic void load() throws DecodeException {\n+\t\tif (regsCount != -1) {\n+\t\t\t// method already loaded\n+\t\t\treturn;\n+\t\t}\n \t\ttry {\n \t\t\tif (noCode) {\n \t\t\t\tregsCount = 0;",
    "output": "Fix protect method from second load"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourceType.java b/jadx-core/src/main/java/jadx/api/ResourceType.java\n--- a/jadx-core/src/main/java/jadx/api/ResourceType.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourceType.java\n@@ -5,8 +5,9 @@ public enum ResourceType {\n \tMANIFEST(\"AndroidManifest.xml\"),\n \tXML(\".xml\"),\n \tARSC(\".arsc\"),\n-\tFONT(\".ttf\"),\n+\tFONT(\".ttf\", \".otf\"),\n \tIMG(\".png\", \".gif\", \".jpg\"),\n+\tMEDIA(\".mp3\", \".wav\"),\n \tLIB(\".so\"),\n \tUNKNOWN;\n \n@@ -23,7 +24,7 @@ public String[] getExts() {\n \tpublic static ResourceType getFileType(String fileName) {\n \t\tfor (ResourceType type : ResourceType.values()) {\n \t\t\tfor (String ext : type.getExts()) {\n-\t\t\t\tif (fileName.endsWith(ext)) {\n+\t\t\t\tif (fileName.toLowerCase().endsWith(ext)) {\n \t\t\t\t\treturn type;\n \t\t\t\t}\n \t\t\t}",
    "output": "Fix compare files extension in case insensitive way"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n@@ -15,7 +15,7 @@ public class ConstructorInsn extends InsnNode implements CallMthInterface {\n \tprivate final CallType callType;\n \tprivate final RegisterArg instanceArg;\n \n-\tprivate enum CallType {\n+\tpublic enum CallType {\n \t\tCONSTRUCTOR, // just new instance\n \t\tSUPER, // super call\n \t\tTHIS, // call constructor from other constructor\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n@@ -1,9 +1,16 @@\n package jadx.core.dex.visitors;\n \n+import java.util.Collections;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Set;\n+\n+import org.jetbrains.annotations.Nullable;\n \n import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.attributes.nodes.DeclareVariablesAttr;\n import jadx.core.dex.instructions.ArithNode;\n import jadx.core.dex.instructions.ArithOp;\n import jadx.core.dex.instructions.InsnType;\n@@ -13,16 +20,16 @@\n import jadx.core.dex.instructions.mods.ConstructorInsn;\n import jadx.core.dex.instructions.mods.TernaryInsn;\n import jadx.core.dex.nodes.BlockNode;\n-import jadx.core.dex.nodes.IBlock;\n-import jadx.core.dex.nodes.IRegion;\n+import jadx.core.dex.nodes.InsnContainer;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.dex.regions.Region;\n import jadx.core.dex.regions.conditions.IfCondition;\n import jadx.core.dex.regions.conditions.IfCondition.Mode;\n-import jadx.core.dex.visitors.regions.AbstractRegionVisitor;\n-import jadx.core.dex.visitors.regions.DepthRegionTraversal;\n import jadx.core.dex.visitors.regions.variables.ProcessVariables;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n+import jadx.core.utils.BlockUtils;\n+import jadx.core.utils.InsnList;\n import jadx.core.utils.exceptions.JadxException;\n \n /**\n@@ -52,7 +59,7 @@ public void visit(MethodNode mth) throws JadxException {\n \t\t\tremoveParenthesis(block);\n \t\t\tmodifyArith(block);\n \t\t}\n-\t\tcommentOutInsnsInConstructor(mth);\n+\t\tmoveConstructorInConstructor(mth);\n \t}\n \n \tprivate static void removeInstructions(BlockNode block) {\n@@ -179,15 +186,52 @@ private static void modifyArith(BlockNode block) {\n \t\t}\n \t}\n \n-\tprivate void commentOutInsnsInConstructor(MethodNode mth) {\n+\t/**\n+\t * Check that 'super' or 'this' call in constructor is a first instruction.\n+\t * Otherwise move to top and add a warning if code breaks.\n+\t */\n+\tprivate void moveConstructorInConstructor(MethodNode mth) {\n \t\tif (mth.isConstructor()) {\n \t\t\tConstructorInsn constrInsn = searchConstructorCall(mth);\n \t\t\tif (constrInsn != null && !constrInsn.contains(AFlag.DONT_GENERATE)) {\n-\t\t\t\tDepthRegionTraversal.traverse(mth, new ConstructorRegionVisitor(constrInsn));\n+\t\t\t\tRegion oldRootRegion = mth.getRegion();\n+\t\t\t\tboolean firstInsn = BlockUtils.isFirstInsn(mth, constrInsn);\n+\t\t\t\tDeclareVariablesAttr declVarsAttr = oldRootRegion.get(AType.DECLARE_VARIABLES);\n+\t\t\t\tif (firstInsn && declVarsAttr == null) {\n+\t\t\t\t\t// move not needed\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\t// move constructor instruction to new root region\n+\t\t\t\tString callType = constrInsn.getCallType().toString().toLowerCase();\n+\t\t\t\tBlockNode blockByInsn = BlockUtils.getBlockByInsn(mth, constrInsn);\n+\t\t\t\tif (blockByInsn == null) {\n+\t\t\t\t\tmth.addWarn(\"Failed to move \" + callType + \" instruction to top\");\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tInsnList.remove(blockByInsn, constrInsn);\n+\n+\t\t\t\tRegion region = new Region(null);\n+\t\t\t\tregion.add(new InsnContainer(Collections.singletonList(constrInsn)));\n+\t\t\t\tregion.add(oldRootRegion);\n+\t\t\t\tmth.setRegion(region);\n+\n+\t\t\t\tif (!firstInsn) {\n+\t\t\t\t\tSet<RegisterArg> regArgs = new HashSet<>();\n+\t\t\t\t\tconstrInsn.getRegisterArgs(regArgs);\n+\t\t\t\t\tregArgs.remove(mth.getThisArg());\n+\t\t\t\t\tregArgs.removeAll(mth.getArguments(false));\n+\t\t\t\t\tif (!regArgs.isEmpty()) {\n+\t\t\t\t\t\tmth.addWarn(\"Illegal instructions before constructor call\");\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tmth.addComment(\"JADX INFO: \" + callType + \" call moved to the top of the method (can break code semantics)\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n+\t@Nullable\n \tprivate ConstructorInsn searchConstructorCall(MethodNode mth) {\n \t\tfor (BlockNode block : mth.getBasicBlocks()) {\n \t\t\tfor (InsnNode insn : block.getInstructions()) {\n@@ -202,72 +246,4 @@ private ConstructorInsn searchConstructorCall(MethodNode mth) {\n \t\t}\n \t\treturn null;\n \t}\n-\n-\tprivate static final class ConstructorRegionVisitor extends AbstractRegionVisitor {\n-\t\tprivate final ConstructorInsn constrInsn;\n-\t\tprivate int regionDepth;\n-\t\tprivate boolean found;\n-\t\tprivate boolean brokenCode;\n-\t\tprivate int commentedCount;\n-\n-\t\tpublic ConstructorRegionVisitor(ConstructorInsn constrInsn) {\n-\t\t\tthis.constrInsn = constrInsn;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean enterRegion(MethodNode mth, IRegion region) {\n-\t\t\tif (found) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tregionDepth++;\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void leaveRegion(MethodNode mth, IRegion region) {\n-\t\t\tif (!found) {\n-\t\t\t\tregionDepth--;\n-\t\t\t\tregion.add(AFlag.COMMENT_OUT);\n-\t\t\t\tcommentedCount++;\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void processBlock(MethodNode mth, IBlock container) {\n-\t\t\tif (found) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tfor (InsnNode insn : container.getInstructions()) {\n-\t\t\t\tif (insn == constrInsn) {\n-\t\t\t\t\tfound = true;\n-\t\t\t\t\taddMethodMsg(mth);\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tinsn.add(AFlag.COMMENT_OUT);\n-\t\t\t\tcommentedCount++;\n-\t\t\t\tif (!brokenCode) {\n-\t\t\t\t\tRegisterArg resArg = insn.getResult();\n-\t\t\t\t\tif (resArg != null) {\n-\t\t\t\t\t\tfor (RegisterArg arg : resArg.getSVar().getUseList()) {\n-\t\t\t\t\t\t\tif (arg.getParentInsn() == constrInsn) {\n-\t\t\t\t\t\t\t\tbrokenCode = true;\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tprivate void addMethodMsg(MethodNode mth) {\n-\t\t\tif (commentedCount > 0) {\n-\t\t\t\tString msg = \"Illegal instructions before constructor call commented (this can break semantics)\";\n-\t\t\t\tif (brokenCode || regionDepth > 1) {\n-\t\t\t\t\tmth.addWarn(msg);\n-\t\t\t\t} else {\n-\t\t\t\t\tmth.addComment(\"JADX WARN: \" + msg);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -574,6 +574,14 @@ public static List<InsnNode> collectAllInsns(List<BlockNode> blocks) {\n \t\treturn insns;\n \t}\n \n+\tpublic static boolean isFirstInsn(MethodNode mth, InsnNode insn) {\n+\t\tBlockNode enterBlock = mth.getEnterBlock();\n+\t\tif (enterBlock == null || enterBlock.getInstructions().isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn enterBlock.getInstructions().get(0) == insn;\n+\t}\n+\n \t/**\n \t * Replace insn by index i in block,\n \t * for proper copy attributes, assume attributes are not overlap\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper.java\n@@ -37,6 +37,6 @@ public void test() {\n \t\tClassNode cls = getClassNodeFromSmaliFiles(\"B\");\n \t\tString code = cls.getCode().toString();\n \n-\t\tassertThat(code, containsOne(\"// checkNull(str);\"));\n+\t\tassertThat(code, containsOne(\"checkNull(str);\"));\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeThis.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeThis.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeThis.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeThis.java\n@@ -35,6 +35,6 @@ public void test() {\n \t\tClassNode cls = getClassNodeFromSmali();\n \t\tString code = cls.getCode().toString();\n \n-\t\tassertThat(code, containsOne(\"// checkNull(str);\"));\n+\t\tassertThat(code, containsOne(\"checkNull(str);\"));\n \t}\n }",
    "output": "Fix instead commenting move constructor call to the top"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java\n@@ -253,10 +253,6 @@ private static boolean processOneBranchTernary(MethodNode mth, IfRegion ifRegion\n \t}\n \n \tprivate static void replaceWithTernary(MethodNode mth, IfRegion ifRegion, BlockNode block, InsnNode insn) {\n-\t\tBlockNode header = ifRegion.getConditionBlocks().get(0);\n-\t\tif (!ifRegion.getParent().replaceSubBlock(ifRegion, header)) {\n-\t\t\treturn;\n-\t\t}\n \t\tRegisterArg resArg = insn.getResult();\n \t\tif (resArg.getSVar().getUseList().size() != 1) {\n \t\t\treturn;\n@@ -277,6 +273,10 @@ private static void replaceWithTernary(MethodNode mth, IfRegion ifRegion, BlockN\n \t\t}\n \n \t\t// all checks passed\n+\t\tBlockNode header = ifRegion.getConditionBlocks().get(0);\n+\t\tif (!ifRegion.getParent().replaceSubBlock(ifRegion, header)) {\n+\t\t\treturn;\n+\t\t}\n \t\tInsnList.remove(block, insn);\n \t\tTernaryInsn ternInsn = new TernaryInsn(ifRegion.getCondition(),\n \t\t\t\tphiInsn.getResult(), InsnArg.wrapInsnIntoArg(insn), otherArg);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n@@ -119,7 +119,8 @@ private static void printInsns(MethodNode mth, String indent, IBlock block) {\n \t\t\t\tCodeWriter code = new CodeWriter();\n \t\t\t\tig.makeInsn(insn, code);\n \t\t\t\tString insnStr = code.toString().substring(CodeWriter.NL.length());\n-\t\t\t\tLOG.debug(\"{}|> {}\\t{}\", indent, insnStr, insn.getAttributesString());\n+\t\t\t\tString attrStr = insn.isAttrStorageEmpty() ? \"\" : '\\t' + insn.getAttributesString();\n+\t\t\t\tLOG.debug(\"{}|> {}{}\", indent, insnStr, attrStr);\n \t\t\t} catch (CodegenException e) {\n \t\t\t\tLOG.debug(\"{}|>!! {}\", indent, insn);\n \t\t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryWithEmptyCatch.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryWithEmptyCatch.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryWithEmptyCatch.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryWithEmptyCatch.java\n@@ -0,0 +1,41 @@\n+package jadx.tests.integration.trycatch;\n+\n+import java.util.Properties;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestTryWithEmptyCatch extends IntegrationTest {\n+\n+\tpublic static class TestCls extends Exception {\n+\t\tprivate static final long serialVersionUID = -5723049816464070603L;\n+\t\tprivate Properties field;\n+\n+\t\tpublic TestCls(String str) {\n+\t\t\tsuper(str);\n+\t\t\tProperties properties = null;\n+\t\t\ttry {\n+\t\t\t\tif (str.contains(\"properties\")) {\n+\t\t\t\t\tproperties = new Properties();\n+\t\t\t\t}\n+\t\t\t} catch (Exception unused) {\n+\t\t\t\t// empty\n+\t\t\t}\n+\t\t\tthis.field = properties;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"try {\"));\n+\t\tassertThat(code, containsOne(\"if (\"));\n+\t}\n+}",
    "output": "Fix don't change AST before checks in ternary transform"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n@@ -256,6 +256,13 @@ private static boolean checkIterableForEach(MethodNode mth, LoopRegion loopRegio\n \t\tif (iterVar == null) {\n \t\t\treturn false;\n \t\t}\n+\t\tif (!usedOnlyInLoop(mth, loopRegion, iterVar)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (!assignOnlyInLoop(mth, loopRegion, iterVar)) {\n+\t\t\treturn false;\n+\t\t}\n+\n \t\tif (nextCall.contains(AFlag.WRAPPED)) {\n \t\t\tInsnArg wrapArg = BlockUtils.searchWrappedInsnParent(mth, nextCall);\n \t\t\tif (wrapArg != null && wrapArg.getParentInsn() != null) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection5.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection5.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection5.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopDetection5.java\n@@ -0,0 +1,52 @@\n+package jadx.tests.integration.loops;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+public class TestLoopDetection5 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic String test(String str) {\n+\t\t\tIterator<String> it = getStrings().iterator();\n+\t\t\tString otherStr = null;\n+\t\t\twhile (it.hasNext()) {\n+\t\t\t\totherStr = it.next();\n+\t\t\t\tif (otherStr.equalsIgnoreCase(str)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn otherStr;\n+\t\t}\n+\n+\t\tprivate List<String> getStrings() {\n+\t\t\treturn Arrays.asList(\"str\", \"otherStr\", \"STR\", \"OTHERSTR\");\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(test(\"OTHERSTR\"), is(\"otherStr\"));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, not(containsString(\"for (\")));\n+\t\tassertThat(code, containsOne(\"it.next();\"));\n+\t}\n+}",
    "output": "Fix check that iteration variable in for-each loop not used outside"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java\n@@ -99,6 +99,7 @@ private static boolean makeTernaryInsn(MethodNode mth, IfRegion ifRegion) {\n \t\t\tRegisterArg resArg;\n \t\t\tif (thenPhi.getArgsCount() == 2) {\n \t\t\t\tresArg = thenPhi.getResult();\n+\t\t\t\tInsnRemover.unbindResult(mth, thenInsn);\n \t\t\t} else {\n \t\t\t\tresArg = thenResArg;\n \t\t\t\tthenPhi.removeArg(elseResArg);\n@@ -107,6 +108,8 @@ private static boolean makeTernaryInsn(MethodNode mth, IfRegion ifRegion) {\n \t\t\t\t\tresArg, InsnArg.wrapArg(thenInsn), InsnArg.wrapArg(elseInsn));\n \t\t\tternInsn.setSourceLine(thenInsn.getSourceLine());\n \n+\t\t\tInsnRemover.unbindResult(mth, elseInsn);\n+\n \t\t\t// remove 'if' instruction\n \t\t\theader.getInstructions().clear();\n \t\t\theader.getInstructions().add(ternInsn);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/ProcessVariables.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/ProcessVariables.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/ProcessVariables.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/ProcessVariables.java\n@@ -14,6 +14,7 @@\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.DeclareVariablesAttr;\n+import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.CodeVar;\n import jadx.core.dex.instructions.args.RegisterArg;\n@@ -228,7 +229,9 @@ private static boolean isContainerContainsUsePlace(IContainer subBlock, UsePlace\n \tprivate static boolean checkDeclareAtAssign(SSAVar var) {\n \t\tRegisterArg arg = var.getAssign();\n \t\tInsnNode parentInsn = arg.getParentInsn();\n-\t\tif (parentInsn == null) {\n+\t\tif (parentInsn == null\n+\t\t\t\t|| parentInsn.contains(AFlag.WRAPPED)\n+\t\t\t\t|| parentInsn.getType() == InsnType.PHI) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!arg.equals(parentInsn.getResult())) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/CodeShrinkVisitor.java\n@@ -20,6 +20,7 @@\n import jadx.core.dex.visitors.ModVisitor;\n import jadx.core.utils.BlockUtils;\n import jadx.core.utils.InsnList;\n+import jadx.core.utils.InsnRemover;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n @JadxVisitor(\n@@ -67,7 +68,7 @@ private static void shrinkBlock(MethodNode mth, BlockNode block) {\n \t\t}\n \t\tif (!wrapList.isEmpty()) {\n \t\t\tfor (WrapInfo wrapInfo : wrapList) {\n-\t\t\t\tinline(wrapInfo.getArg(), wrapInfo.getInsn(), block);\n+\t\t\t\tinline(mth, wrapInfo.getArg(), wrapInfo.getInsn(), block);\n \t\t\t}\n \t\t}\n \t}\n@@ -106,19 +107,20 @@ private static void checkInline(MethodNode mth, BlockNode block, InsnList insnLi\n \t\t\tif (assignBlock != null\n \t\t\t\t\t&& assignInsn != arg.getParentInsn()\n \t\t\t\t\t&& canMoveBetweenBlocks(assignInsn, assignBlock, block, argsInfo.getInsn())) {\n-\t\t\t\tinline(arg, assignInsn, assignBlock);\n+\t\t\t\tinline(mth, arg, assignInsn, assignBlock);\n \t\t\t}\n \t\t}\n \t}\n \n-\tprivate static boolean inline(RegisterArg arg, InsnNode insn, BlockNode block) {\n+\tprivate static boolean inline(MethodNode mth, RegisterArg arg, InsnNode insn, BlockNode block) {\n \t\tInsnNode parentInsn = arg.getParentInsn();\n \t\tif (parentInsn != null && parentInsn.getType() == InsnType.RETURN) {\n \t\t\tparentInsn.setSourceLine(insn.getSourceLine());\n \t\t}\n \t\tboolean replaced = arg.wrapInstruction(insn) != null;\n \t\tif (replaced) {\n \t\t\tInsnList.remove(block, insn);\n+\t\t\tInsnRemover.unbindResult(mth, insn);\n \t\t}\n \t\treturn replaced;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/InsnRemover.java b/jadx-core/src/main/java/jadx/core/utils/InsnRemover.java\n--- a/jadx-core/src/main/java/jadx/core/utils/InsnRemover.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/InsnRemover.java\n@@ -8,6 +8,7 @@\n \n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.instructions.InsnType;\n+import jadx.core.dex.instructions.PhiInsn;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.InsnWrapArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n@@ -66,7 +67,7 @@ public void perform() {\n \t\ttoRemove.clear();\n \t}\n \n-\tpublic static void unbindInsn(MethodNode mth, InsnNode insn) {\n+\tpublic static void unbindInsn(@Nullable MethodNode mth, InsnNode insn) {\n \t\tfor (InsnArg arg : insn.getArguments()) {\n \t\t\tunbindArgUsage(mth, arg);\n \t\t}\n@@ -81,17 +82,41 @@ public static void unbindInsn(MethodNode mth, InsnNode insn) {\n \t\tinsn.add(AFlag.REMOVE);\n \t}\n \n-\tpublic static void unbindResult(MethodNode mth, InsnNode insn) {\n+\tpublic static void unbindResult(@Nullable MethodNode mth, InsnNode insn) {\n \t\tRegisterArg r = insn.getResult();\n \t\tif (r != null && r.getSVar() != null && mth != null) {\n \t\t\tSSAVar ssaVar = r.getSVar();\n-\t\t\tif (ssaVar.getUseCount() == 0) {\n-\t\t\t\tmth.removeSVar(ssaVar);\n+\t\t\tremoveSsaVar(mth, ssaVar);\n+\t\t}\n+\t}\n+\n+\tprivate static void removeSsaVar(MethodNode mth, SSAVar ssaVar) {\n+\t\tint useCount = ssaVar.getUseCount();\n+\t\tif (useCount == 0) {\n+\t\t\tmth.removeSVar(ssaVar);\n+\t\t\treturn;\n+\t\t}\n+\t\t// check if all usage only in PHI insns\n+\t\tboolean allPhis = true;\n+\t\tfor (RegisterArg arg : ssaVar.getUseList()) {\n+\t\t\tInsnNode parentInsn = arg.getParentInsn();\n+\t\t\tif (parentInsn == null || parentInsn.getType() != InsnType.PHI) {\n+\t\t\t\tallPhis = false;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tif (allPhis) {\n+\t\t\tfor (RegisterArg arg : new ArrayList<>(ssaVar.getUseList())) {\n+\t\t\t\tInsnNode parentInsn = arg.getParentInsn();\n+\t\t\t\tif (parentInsn != null) {\n+\t\t\t\t\t((PhiInsn) parentInsn).removeArg(arg);\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tmth.removeSVar(ssaVar);\n \t\t}\n \t}\n \n-\tpublic static void unbindArgUsage(MethodNode mth, InsnArg arg) {\n+\tpublic static void unbindArgUsage(@Nullable MethodNode mth, InsnArg arg) {\n \t\tif (arg instanceof RegisterArg) {\n \t\t\tRegisterArg reg = (RegisterArg) arg;\n \t\t\tSSAVar sVar = reg.getSVar();\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions14.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions14.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions14.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions14.java\n@@ -17,7 +17,7 @@ public static boolean test(Object a, Object b) {\n \t\t\tif (r) {\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tSystem.out.println(\"1\");\n+\t\t\tSystem.out.println(\"r=\" + r);\n \t\t\treturn true;\n \t\t}\n \t}\n@@ -29,6 +29,6 @@ public void test() {\n \n \t\tassertThat(code, containsOne(\"boolean r = a == null ? b != null : !a.equals(b);\"));\n \t\tassertThat(code, containsOne(\"if (r) {\"));\n-\t\tassertThat(code, containsOne(\"System.out.println(\\\"1\\\");\"));\n+\t\tassertThat(code, containsOne(\"System.out.println(\\\"r=\\\" + r);\"));\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernary4.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernary4.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernary4.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernary4.java\n@@ -0,0 +1,45 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestTernary4 extends SmaliTest {\n+\n+\t// @formatter:off\n+\t/*\n+\t\tprivate Set test(HashMap<String, Object> hashMap) {\n+\t\t\tboolean z;\n+\t\t\tHashSet hashSet = new HashSet();\n+\t\t\tsynchronized (this.defaultValuesByPath) {\n+\t\t\t\tfor (String next : this.defaultValuesByPath.keySet()) {\n+\t\t\t\t\tObject obj = hashMap.get(next);\n+\t\t\t\t\tif (obj != null) {\n+\t\t\t\t\t\tz = !getValueObject(next).equals(obj);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tz = this.valuesByPath.get(next) != null;;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (z) {\n+\t\t\t\t\t\thashSet.add(next);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn hashSet;\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmali();\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, not(containsString(\"r5\")));\n+\t\tassertThat(code, not(containsString(\"try\")));\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver3.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver3.java\n@@ -2,7 +2,6 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.tests.api.IntegrationTest;\n \n@@ -27,15 +26,6 @@ public void test() {\n \t\tClassNode cls = getClassNode(TestCls.class);\n \t\tString code = cls.getCode().toString();\n \n-\t\tassertThat(code, containsOne(\"s1.length() == s2.length() ? 0 : s1.length() < s2.length() ? -1 : 1;\"));\n-\t}\n-\n-\t@Test\n-\t@NotYetImplemented\n-\tpublic void test3() {\n-\t\tClassNode cls = getClassNode(TestCls.class);\n-\t\tString code = cls.getCode().toString();\n-\n \t\tassertThat(code, containsOne(\"return s1.length() == s2.length() ? 0 : s1.length() < s2.length() ? -1 : 1;\"));\n \t}",
    "output": "Fix unbind unused ssa variable after ternary conversion"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java\n@@ -27,30 +27,22 @@ protected String[] parseStringPoolNoType() throws IOException {\n \t\tint[] stylesOffset = is.readInt32Array(styleCount);\n \n \t\tis.checkPos(start + stringsStart, \"Expected strings start\");\n-\t\tlong stringsEnd = stylesStart == 0 ? chunkEnd : start + stylesStart;\n \t\tString[] strings = new String[stringCount];\n-\t\tbyte[] strArray = is.readInt8Array((int) (stringsEnd - is.getPos()));\n+\t\tbyte[] strData = is.readInt8Array((int) (chunkEnd - is.getPos()));\n \t\tif ((flags & UTF8_FLAG) != 0) {\n \t\t\t// UTF-8\n \t\t\tfor (int i = 0; i < stringCount; i++) {\n-\t\t\t\tstrings[i] = extractString8(strArray, stringsOffset[i]);\n+\t\t\t\tstrings[i] = extractString8(strData, stringsOffset[i]);\n \t\t\t}\n \t\t} else {\n \t\t\t// UTF-16\n \t\t\tfor (int i = 0; i < stringCount; i++) {\n \t\t\t\t// don't trust specified string length, read until \\0\n \t\t\t\t// stringsOffset can be same for different indexes\n-\t\t\t\tstrings[i] = extractString16(strArray, stringsOffset[i]);\n+\t\t\t\tstrings[i] = extractString16(strData, stringsOffset[i]);\n \t\t\t}\n \t\t}\n-\t\tif (stylesStart != 0) {\n-\t\t\tis.checkPos(start + stylesStart, \"Expected styles start\");\n-\t\t\tif (styleCount != 0) {\n-\t\t\t\t// TODO: implement styles parsing\n-\t\t\t}\n-\t\t}\n-\t\t// skip padding zeroes\n-\t\tis.skipToPos(chunkEnd, \"Skip string pool padding\");\n+\t\tis.checkPos(chunkEnd, \"Expected strings pool end\");\n \t\treturn strings;\n \t}",
    "output": "Fix read correct buffer size for string pool parsing"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java\n@@ -11,7 +11,6 @@ protected String[] parseStringPool() throws IOException {\n \t\treturn parseStringPoolNoType();\n \t}\n \n-\t@SuppressWarnings(\"unused\")\n \tprotected String[] parseStringPoolNoType() throws IOException {\n \t\tlong start = is.getPos() - 2;\n \t\tis.checkInt16(0x001c, \"String pool header size not 0x001c\");\n@@ -56,6 +55,9 @@ protected String[] parseStringPoolNoType() throws IOException {\n \t}\n \n \tprivate static String extractString8(byte[] strArray, int offset) {\n+\t\tif (offset >= strArray.length) {\n+\t\t\treturn \"STRING_DECODE_ERROR\";\n+\t\t}\n \t\tint start = offset + skipStrLen8(strArray, offset);\n \t\tint len = strArray[start++];\n \t\tif (len == 0) {",
    "output": "Fix skip string if parsing failed"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -346,7 +346,7 @@ private void preProcessClass(ClassNode cls) {\n \t\tClassInfo classInfo = cls.getClassInfo();\n \t\tString pkgFullName = classInfo.getPackage();\n \t\tPackageNode pkg = getPackageNode(pkgFullName, true);\n-\t\tdoPkg(pkg, pkgFullName);\n+\t\tprocessPackageFull(pkg, pkgFullName);\n \n \t\tString alias = deobfPresets.getForCls(classInfo);\n \t\tif (alias != null) {\n@@ -372,6 +372,24 @@ public String getClsAlias(ClassNode cls) {\n \t\treturn makeClsAlias(cls);\n \t}\n \n+\tpublic String getPkgAlias(ClassNode cls) {\n+\t\tClassInfo classInfo = cls.getClassInfo();\n+\t\tPackageNode pkg = null;\n+\t\tDeobfClsInfo deobfClsInfo = clsMap.get(classInfo);\n+\t\tif (deobfClsInfo != null) {\n+\t\t\tpkg = deobfClsInfo.getPkg();\n+\t\t} else {\n+\t\t\tString fullPkgName = classInfo.getPackage();\n+\t\t\tpkg = getPackageNode(fullPkgName, true);\n+\t\t\tprocessPackageFull(pkg, fullPkgName);\n+\t\t}\n+\t\tif (pkg.hasAnyAlias()) {\n+\t\t\treturn pkg.getFullAlias();\n+\t\t} else {\n+\t\t\treturn pkg.getFullName();\n+\t\t}\n+\t}\n+\n \tprivate String makeClsAlias(ClassNode cls) {\n \t\tClassInfo classInfo = cls.getClassInfo();\n \t\tString alias = null;\n@@ -472,7 +490,7 @@ public String makeMethodAlias(MethodNode mth) {\n \t\treturn alias;\n \t}\n \n-\tprivate void doPkg(PackageNode pkg, String fullName) {\n+\tprivate void processPackageFull(PackageNode pkg, String fullName) {\n \t\tif (pkgSet.contains(fullName)) {\n \t\t\treturn;\n \t\t}\n@@ -482,15 +500,19 @@ private void doPkg(PackageNode pkg, String fullName) {\n \t\tPackageNode parentPkg = pkg.getParentPackage();\n \t\twhile (!parentPkg.getName().isEmpty()) {\n \t\t\tif (!parentPkg.hasAlias()) {\n-\t\t\t\tdoPkg(parentPkg, parentPkg.getFullName());\n+\t\t\t\tprocessPackageFull(parentPkg, parentPkg.getFullName());\n \t\t\t}\n \t\t\tparentPkg = parentPkg.getParentPackage();\n \t\t}\n \n-\t\tString pkgName = pkg.getName();\n-\t\tif (!pkg.hasAlias() && shouldRename(pkgName)) {\n-\t\t\tString pkgAlias = String.format(\"p%03d%s\", pkgIndex++, prepareNamePart(pkgName));\n-\t\t\tpkg.setAlias(pkgAlias);\n+\t\tif (!pkg.hasAlias()) {\n+\t\t\tString pkgName = pkg.getName();\n+\t\t\tif ((args.isDeobfuscationOn() && shouldRename(pkgName))\n+\t\t\t\t\t|| (args.isRenameValid() && !NameMapper.isValidIdentifier(pkgName))\n+\t\t\t\t\t|| (args.isRenamePrintable() && !NameMapper.isAllCharsPrintable(pkgName))) {\n+\t\t\t\tString pkgAlias = String.format(\"p%03d%s\", pkgIndex++, prepareNamePart(pkg.getName()));\n+\t\t\t\tpkg.setAlias(pkgAlias);\n+\t\t\t}\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -95,25 +95,37 @@ private static void checkClassName(Deobfuscator deobfuscator, ClassNode cls, Jad\n \t\t\tclassInfo.changeShortName(newShortName);\n \t\t\tcls.addAttr(new RenameReasonAttr(cls).append(\"invalid class name\"));\n \t\t}\n-\t\tif (args.isRenameValid()) {\n-\t\t\tif (classInfo.isInner()) {\n-\t\t\t\tClassInfo parentClass = classInfo.getParentClass();\n-\t\t\t\twhile (parentClass != null) {\n-\t\t\t\t\tif (parentClass.getAliasShortName().equals(clsName)) {\n-\t\t\t\t\t\tString clsAlias = deobfuscator.getClsAlias(cls);\n-\t\t\t\t\t\tclassInfo.changeShortName(clsAlias);\n-\t\t\t\t\t\tcls.addAttr(new RenameReasonAttr(cls).append(\"collision with other inner class name\"));\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\tparentClass = parentClass.getParentClass();\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tif (classInfo.getAliasPkg().isEmpty()) {\n-\t\t\t\t\tclassInfo.changePkg(Consts.DEFAULT_PACKAGE_NAME);\n-\t\t\t\t\tcls.addAttr(new RenameReasonAttr(cls).append(\"default package\"));\n+\t\tif (classInfo.isInner() && args.isRenameValid()) {\n+\t\t\t// check inner classes names\n+\t\t\tClassInfo parentClass = classInfo.getParentClass();\n+\t\t\twhile (parentClass != null) {\n+\t\t\t\tif (parentClass.getAliasShortName().equals(clsName)) {\n+\t\t\t\t\tString clsAlias = deobfuscator.getClsAlias(cls);\n+\t\t\t\t\tclassInfo.changeShortName(clsAlias);\n+\t\t\t\t\tcls.addAttr(new RenameReasonAttr(cls).append(\"collision with other inner class name\"));\n+\t\t\t\t\tbreak;\n \t\t\t\t}\n+\t\t\t\tparentClass = parentClass.getParentClass();\n \t\t\t}\n \t\t}\n+\t\tcheckPackage(deobfuscator, cls, classInfo, args);\n+\t}\n+\n+\tprivate static void checkPackage(Deobfuscator deobfuscator, ClassNode cls, ClassInfo classInfo, JadxArgs args) {\n+\t\tif (classInfo.isInner()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tString aliasPkg = classInfo.getAliasPkg();\n+\t\tif (args.isRenameValid() && aliasPkg.isEmpty()) {\n+\t\t\tclassInfo.changePkg(Consts.DEFAULT_PACKAGE_NAME);\n+\t\t\tcls.addAttr(new RenameReasonAttr(cls).append(\"default package\"));\n+\t\t\treturn;\n+\t\t}\n+\t\tString fullPkgAlias = deobfuscator.getPkgAlias(cls);\n+\t\tif (!fullPkgAlias.equals(aliasPkg)) {\n+\t\t\tclassInfo.changePkg(fullPkgAlias);\n+\t\t\tcls.addAttr(new RenameReasonAttr(cls).append(\"invalid package\"));\n+\t\t}\n \t}\n \n \t@Nullable\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/CodeGenUtils.java b/jadx-core/src/main/java/jadx/core/utils/CodeGenUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/CodeGenUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/CodeGenUtils.java\n@@ -22,7 +22,7 @@ public static void addRenamedComment(CodeWriter code, AttrNode node, String orig\n \t\tcode.startLine(\"/* renamed from: \").add(origName);\n \t\tRenameReasonAttr renameReasonAttr = node.get(AType.RENAME_REASON);\n \t\tif (renameReasonAttr != null) {\n-\t\t\tcode.add(\" reason: \");\n+\t\t\tcode.add(\"  reason: \");\n \t\t\tcode.add(renameReasonAttr.getDescription());\n \t\t}\n \t\tcode.add(\" */\");\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedPackageNames.java b/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedPackageNames.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedPackageNames.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedPackageNames.java\n@@ -0,0 +1,59 @@\n+package jadx.tests.integration.names;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.not;\n+\n+public class TestReservedPackageNames extends SmaliTest {\n+\n+\t// @formatter:off\n+\t/*\n+\t\tpackage do.if;\n+\n+\t\tpublic class A {}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tList<ClassNode> clsList = loadFromSmaliFiles();\n+\t\tfor (ClassNode cls : clsList) {\n+\t\t\tString code = cls.getCode().toString();\n+\t\t\tassertThat(code, not(containsString(\"package do.if;\")));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testDeobf() {\n+\t\tenableDeobfuscation();\n+\t\tList<ClassNode> clsList = loadFromSmaliFiles();\n+\t\tfor (ClassNode cls : clsList) {\n+\t\t\tString code = cls.getCode().toString();\n+\t\t\tassertThat(code, not(containsString(\"package do.if;\")));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testRenameDisabled() {\n+\t\targs.setRenameCaseSensitive(false);\n+\t\targs.setRenameValid(false);\n+\t\targs.setRenamePrintable(false);\n+\n+\t\tdisableCompilation();\n+\n+\t\tList<ClassNode> clsList = loadFromSmaliFiles();\n+\t\tfor (ClassNode cls : clsList) {\n+\t\t\tString code = cls.getCode().toString();\n+\t\t\tif (cls.getShortName().equals(\"A\")) {\n+\t\t\t\tassertThat(code, containsString(\"package do.if;\"));\n+\t\t\t}\n+\t\t}\n+\t}\n+}",
    "output": "Fix rename packages with reserved names"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -50,24 +50,36 @@ public void visit(MethodNode mth) {\n \t\t\treturn;\n \t\t}\n \t\tfor (BlockNode block : mth.getBasicBlocks()) {\n-\t\t\tList<InsnNode> list = block.getInstructions();\n-\t\t\tfor (int i = 0; i < list.size(); i++) {\n-\t\t\t\tInsnNode modInsn = simplifyInsn(mth, list.get(i));\n-\t\t\t\tif (modInsn != null) {\n-\t\t\t\t\tif (i != 0 && modInsn.contains(AFlag.ARITH_ONEARG)) {\n-\n-\t\t\t\t\t\tInsnNode mergedNode = simplifyOneArgConsecutive(\n-\t\t\t\t\t\t\t\tlist.get(i - 1), list.get(i), (ArithNode) modInsn);\n-\n-\t\t\t\t\t\tif (mergedNode != null) {\n-\t\t\t\t\t\t\tlist.remove(i - 1);\n-\t\t\t\t\t\t\tmodInsn = mergedNode;\n-\t\t\t\t\t\t\ti--;\n-\t\t\t\t\t\t}\n+\t\t\tsimplifyBlock(mth, block);\n+\t\t}\n+\t}\n+\n+\tprivate static void simplifyBlock(MethodNode mth, BlockNode block) {\n+\t\tList<InsnNode> list = block.getInstructions();\n+\t\tfor (int i = 0; i < list.size(); i++) {\n+\t\t\tInsnNode insn = list.get(i);\n+\t\t\tint insnCount = list.size();\n+\t\t\tInsnNode modInsn = simplifyInsn(mth, insn);\n+\t\t\tif (modInsn != null) {\n+\t\t\t\tif (i != 0 && modInsn.contains(AFlag.ARITH_ONEARG)) {\n+\t\t\t\t\tInsnNode mergedNode = simplifyOneArgConsecutive(\n+\t\t\t\t\t\t\tlist.get(i - 1), list.get(i), (ArithNode) modInsn);\n+\n+\t\t\t\t\tif (mergedNode != null) {\n+\t\t\t\t\t\tlist.remove(i - 1);\n+\t\t\t\t\t\tmodInsn = mergedNode;\n+\t\t\t\t\t\ti--;\n \t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (i < list.size() && list.get(i) == insn) {\n \t\t\t\t\tlist.set(i, modInsn);\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif (list.size() < insnCount) {\n+\t\t\t\t// some insns removed => restart block processing\n+\t\t\t\tsimplifyBlock(mth, block);\n+\t\t\t\treturn;\n+\t\t\t}\n \t\t}\n \t}",
    "output": "Fix support instructions removing in SimplifyVisitor"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n@@ -92,7 +92,7 @@ private static void moveStaticFieldsInit(ClassNode cls) {\n \t\t\t\tList<InsnNode> initInsns = getFieldAssigns(classInitMth, field, InsnType.SPUT);\n \t\t\t\tif (initInsns.size() == 1) {\n \t\t\t\t\tInsnNode insn = initInsns.get(0);\n-\t\t\t\t\tif (checkInsn(insn)) {\n+\t\t\t\t\tif (checkInsn(cls, insn)) {\n \t\t\t\t\t\tInsnArg arg = insn.getArg(0);\n \t\t\t\t\t\tif (arg instanceof InsnWrapArg) {\n \t\t\t\t\t\t\t((InsnWrapArg) arg).getWrapInsn().add(AFlag.DECLARE_VAR);\n@@ -137,7 +137,7 @@ private static void moveCommonFieldsInit(ClassNode cls) {\n \t\t\t// TODO: check not only first block\n \t\t\tBlockNode blockNode = constrMth.getBasicBlocks().get(0);\n \t\t\tfor (InsnNode insn : blockNode.getInstructions()) {\n-\t\t\t\tif (insn.getType() == InsnType.IPUT && checkInsn(insn)) {\n+\t\t\t\tif (insn.getType() == InsnType.IPUT && checkInsn(cls, insn)) {\n \t\t\t\t\tinfo.getPutInsns().add(insn);\n \t\t\t\t} else if (!info.getPutInsns().isEmpty()) {\n \t\t\t\t\tbreak;\n@@ -199,7 +199,22 @@ private static boolean compareInsns(List<InsnNode> base, List<InsnNode> other) {\n \t\treturn true;\n \t}\n \n-\tprivate static boolean checkInsn(InsnNode insn) {\n+\tprivate static boolean checkInsn(ClassNode cls, InsnNode insn) {\n+\t\tif (insn instanceof IndexInsnNode) {\n+\t\t\tFieldInfo fieldInfo = (FieldInfo) ((IndexInsnNode) insn).getIndex();\n+\t\t\tif (!fieldInfo.getDeclClass().equals(cls.getClassInfo())) {\n+\t\t\t\t// exclude fields from super classes\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tFieldNode fieldNode = cls.dex().resolveField(fieldInfo);\n+\t\t\tif (fieldNode == null) {\n+\t\t\t\t// exclude inherited fields (not declared in this class)\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\n \t\tInsnArg arg = insn.getArg(0);\n \t\tif (arg.isInsnWrap()) {\n \t\t\tInsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInit3.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInit3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInit3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInit3.java\n@@ -0,0 +1,57 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class TestFieldInit3 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic abstract static class A {\n+\t\t\tpublic int field = 4;\n+\t\t}\n+\n+\t\tpublic static final class B extends A {\n+\t\t\tpublic B() {\n+\t\t\t\t// IPUT for A.field\n+\t\t\t\tsuper.field = 7;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic static final class C extends A {\n+\t\t\tpublic int other = 11;\n+\n+\t\t\tpublic C() {\n+\t\t\t\t// IPUT for C.field not A.field !!!\n+\t\t\t\tthis.field = 9;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic static final class D extends A {\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(new B().field, is(7));\n+\t\t\tassertThat(new C().field, is(9));\n+\t\t\tassertThat(new C().other, is(11));\n+\t\t\tassertThat(new D().field, is(4));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"public int field = 4;\"));\n+\t\tassertThat(code, containsOne(\"field = 7;\"));\n+\t\tassertThat(code, containsOne(\"field = 9;\"));\n+\t\tassertThat(code, containsOne(\"public int other = 11;\"));\n+\t}\n+}",
    "output": "Fix incorrect init values of inherited fields"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MarkFinallyVisitor.java\n@@ -5,6 +5,7 @@\n import java.util.List;\n import java.util.Set;\n \n+import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -271,13 +272,24 @@ private static InsnsSlice searchFromFirstBlock(BlockNode dupBlock, BlockNode sta\n \t\tif (dupSlice == null) {\n \t\t\treturn null;\n \t\t}\n-\t\tif (dupSlice.isComplete()) {\n-\t\t\treturn dupSlice;\n-\t\t}\n-\t\tif (!checkBlocksTree(dupBlock, startBlock, dupSlice, extractInfo)) {\n+\t\tif (!dupSlice.isComplete()\n+\t\t\t\t&& !checkBlocksTree(dupBlock, startBlock, dupSlice, extractInfo)) {\n \t\t\treturn null;\n \t\t}\n-\t\treturn dupSlice;\n+\t\treturn checkSlice(dupSlice);\n+\t}\n+\n+\t@Nullable\n+\tprivate static InsnsSlice checkSlice(InsnsSlice slice) {\n+\t\tList<InsnNode> insnsList = slice.getInsnsList();\n+\t\t// ignore slice with only one 'if' insn\n+\t\tif (insnsList.size() == 1) {\n+\t\t\tInsnNode insnNode = insnsList.get(0);\n+\t\t\tif (insnNode.getType() == InsnType.IF) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\t\treturn slice;\n \t}\n \n \t/**\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally10.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally10.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally10.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally10.java\n@@ -0,0 +1,22 @@\n+package jadx.tests.integration.trycatch;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.not;\n+\n+public class TestTryCatchFinally10 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tClassNode cls = getClassNodeFromSmali();\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, not(containsString(\"boolean z = null;\")));\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally9.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally9.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally9.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchFinally9.java\n@@ -0,0 +1,46 @@\n+package jadx.tests.integration.trycatch;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Scanner;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.NotYetImplemented;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.not;\n+\n+public class TestTryCatchFinally9 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic String test() throws IOException {\n+\t\t\tInputStream input = null;\n+\t\t\ttry {\n+\t\t\t\tinput = this.getClass().getResourceAsStream(\"resource\");\n+\t\t\t\tScanner scanner = new Scanner(input).useDelimiter(\"\\\\A\");\n+\t\t\t\treturn scanner.hasNext() ? scanner.next() : \"\";\n+\t\t\t} finally {\n+\t\t\t\tif (input != null) {\n+\t\t\t\t\tinput.close();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\t@NotYetImplemented(\"finally extraction\")\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, not(containsString(\"JADX INFO: finally extract failed\")));\n+\t\tassertThat(code, not(containsString(\"throw\")));\n+\t\tassertThat(code, containsOne(\"} finally {\"));\n+\t\tassertThat(code, containsOne(\"if (input != null) {\"));\n+\t}\n+}",
    "output": "Fix ignore finally extraction with only one 'if' instruction"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -807,11 +807,22 @@ private boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnAr\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n+\t\tif (isCastNeeded(arg, origType)) {\n+\t\t\tcode.add('(');\n+\t\t\tuseType(code, origType);\n+\t\t\tcode.add(\") \");\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprivate boolean isCastNeeded(InsnArg arg, ArgType origType) {\n \t\tArgType argType = arg.getType();\n-\t\tif (argType.equals(origType)\n-\t\t\t\t// null cast to object\n-\t\t\t\t&& (!arg.isLiteral() || ((LiteralArg) arg).getLiteral() != 0\n-\t\t\t\t\t\t|| (!argType.isArray() && !argType.isObject()))) {\n+\t\tif (arg.isLiteral() && ((LiteralArg) arg).getLiteral() == 0\n+\t\t\t\t&& (argType.isObject() || argType.isArray())) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (argType.equals(origType)) {\n \t\t\treturn false;\n \t\t}\n \t\tif (origType.isGeneric()) {\n@@ -828,9 +839,6 @@ private boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnAr\n \t\t\t\t((InsnWrapArg) arg).getWrapInsn().add(AFlag.EXPLICIT_GENERICS);\n \t\t\t}\n \t\t}\n-\t\tcode.add('(');\n-\t\tuseType(code, origType);\n-\t\tcode.add(\") \");\n \t\treturn true;\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestCastOfNull.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestCastOfNull.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestCastOfNull.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestCastOfNull.java\n@@ -1,5 +1,7 @@\n package jadx.tests.integration.others;\n \n+import java.util.List;\n+\n import org.junit.jupiter.api.Test;\n \n import jadx.core.dex.nodes.ClassNode;\n@@ -15,13 +17,17 @@ public static class TestCls {\n \t\tpublic void test() {\n \t\t\tm((long[]) null);\n \t\t\tm((String) null);\n+\t\t\tm((List<String>) null);\n \t\t}\n \n \t\tpublic void m(long[] a) {\n \t\t}\n \n \t\tpublic void m(String s) {\n \t\t}\n+\n+\t\tpublic void m(List<String> list) {\n+\t\t}\n \t}\n \n \t@Test\n@@ -31,5 +37,6 @@ public void test() {\n \n \t\tassertThat(code, containsOne(\"m((long[]) null);\"));\n \t\tassertThat(code, containsOne(\"m((String) null);\"));\n+\t\tassertThat(code, containsOne(\"m((List<String>) null);\"));\n \t}\n }",
    "output": "Fix always cast null objects in overloaded method"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n@@ -156,7 +156,7 @@ public String toString() {\n \t}\n \n \tprivate static class ObjectType extends KnownType {\n-\t\tprivate final String objName;\n+\t\tprotected final String objName;\n \n \t\tpublic ObjectType(String obj) {\n \t\t\tthis.objName = Utils.cleanObjectName(obj);\n@@ -269,15 +269,18 @@ public GenericObject(String obj, ArgType[] generics) {\n \t\t\tsuper(obj);\n \t\t\tthis.outerType = null;\n \t\t\tthis.generics = generics;\n-\t\t\tthis.hash = obj.hashCode() + 31 * Arrays.hashCode(generics);\n+\t\t\tthis.hash = calcHash();\n \t\t}\n \n \t\tpublic GenericObject(GenericObject outerType, String innerName, ArgType[] generics) {\n \t\t\tsuper(outerType.getObject() + '$' + innerName);\n \t\t\tthis.outerType = outerType;\n \t\t\tthis.generics = generics;\n-\t\t\tthis.hash = outerType.hashCode() + 31 * innerName.hashCode()\n-\t\t\t\t\t+ 31 * 31 * Arrays.hashCode(generics);\n+\t\t\tthis.hash = calcHash();\n+\t\t}\n+\n+\t\tprivate int calcHash() {\n+\t\t\treturn objName.hashCode() + 31 * Arrays.hashCode(generics);\n \t\t}\n \n \t\t@Override\n\ndiff --git a/jadx-core/src/test/java/jadx/core/dex/instructions/args/ArgTypeTest.java b/jadx-core/src/test/java/jadx/core/dex/instructions/args/ArgTypeTest.java\n--- a/jadx-core/src/test/java/jadx/core/dex/instructions/args/ArgTypeTest.java\n+++ b/jadx-core/src/test/java/jadx/core/dex/instructions/args/ArgTypeTest.java\n@@ -0,0 +1,16 @@\n+package jadx.core.dex.instructions.args;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ArgTypeTest {\n+\n+\t@Test\n+\tvoid testEqualsOfGenericTypes() {\n+\t\tArgType first = ArgType.generic(\"java.lang.List\", ArgType.STRING);\n+\t\tArgType second = ArgType.generic(\"Ljava/lang/List;\", ArgType.STRING);\n+\n+\t\tassertEquals(first, second);\n+\t}\n+}",
    "output": "Fix make correct hash calculation for GenericObject type"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n@@ -20,6 +20,7 @@\n import org.slf4j.LoggerFactory;\n \n import com.android.dex.Dex;\n+import com.android.dex.DexException;\n \n import jadx.core.utils.AsmUtils;\n import jadx.core.utils.exceptions.DecodeException;\n@@ -52,20 +53,20 @@ private void searchDexFiles(boolean skipSources) throws IOException, DecodeExcep\n \t\tString fileName = file.getName();\n \n \t\tif (fileName.endsWith(\".dex\")) {\n-\t\t\taddDexFile(fileName, new Dex(file), file.toPath());\n+\t\t\taddDexFile(fileName, file.toPath());\n \t\t\treturn;\n \t\t}\n \t\tif (fileName.endsWith(\".smali\")) {\n \t\t\tPath output = FileUtils.createTempFile(\".dex\");\n \t\t\tSmaliOptions options = new SmaliOptions();\n \t\t\toptions.outputDexFile = output.toAbsolutePath().toString();\n \t\t\tSmali.assemble(options, file.getAbsolutePath());\n-\t\t\taddDexFile(\"\", new Dex(output.toFile()), output);\n+\t\t\taddDexFile(fileName, output);\n \t\t\treturn;\n \t\t}\n \t\tif (fileName.endsWith(\".class\")) {\n \t\t\tfor (Path path : loadFromClassFile(file)) {\n-\t\t\t\taddDexFile(path);\n+\t\t\t\taddDexFile(fileName, path);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n@@ -80,7 +81,7 @@ private void searchDexFiles(boolean skipSources) throws IOException, DecodeExcep\n \t\t\t}\n \t\t\tif (fileName.endsWith(\".jar\")) {\n \t\t\t\tfor (Path path : loadFromJar(file.toPath())) {\n-\t\t\t\t\taddDexFile(path);\n+\t\t\t\t\taddDexFile(fileName, path);\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n@@ -96,18 +97,6 @@ private void searchDexFiles(boolean skipSources) throws IOException, DecodeExcep\n \t\tLOG.warn(\"No dex files found in {}\", file);\n \t}\n \n-\tprivate void addDexFile(Path path) throws IOException {\n-\t\taddDexFile(path.getFileName().toString(), path);\n-\t}\n-\n-\tprivate void addDexFile(String fileName, Path path) throws IOException {\n-\t\taddDexFile(fileName, new Dex(Files.readAllBytes(path)), path);\n-\t}\n-\n-\tprivate void addDexFile(String fileName, Dex dexBuf, Path path) {\n-\t\tdexFiles.add(new DexFile(this, fileName, dexBuf, path));\n-\t}\n-\n \tprivate boolean loadFromZip(String ext) throws IOException, DecodeException {\n \t\tint index = 0;\n \t\ttry (ZipFile zf = new ZipFile(file)) {\n@@ -127,9 +116,8 @@ private boolean loadFromZip(String ext) throws IOException, DecodeException {\n \t\t\t\t\t\t\t|| entryName.endsWith(instantRunDexSuffix)) {\n \t\t\t\t\t\tswitch (ext) {\n \t\t\t\t\t\t\tcase \".dex\":\n-\t\t\t\t\t\t\t\tPath path = makeDexBuf(entryName, inputStream);\n-\t\t\t\t\t\t\t\tif (path != null) {\n-\t\t\t\t\t\t\t\t\taddDexFile(entryName, path);\n+\t\t\t\t\t\t\t\tPath path = copyToTmpDex(entryName, inputStream);\n+\t\t\t\t\t\t\t\tif (addDexFile(entryName, path)) {\n \t\t\t\t\t\t\t\t\tindex++;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tbreak;\n@@ -163,8 +151,32 @@ private boolean loadFromZip(String ext) throws IOException, DecodeException {\n \t\treturn index > 0;\n \t}\n \n+\tprivate boolean addDexFile(String entryName, @Nullable Path filePath) {\n+\t\tif (filePath == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tDex dexBuf = loadDexBufFromPath(filePath, entryName);\n+\t\tif (dexBuf == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tdexFiles.add(new DexFile(this, entryName, dexBuf, filePath));\n+\t\treturn true;\n+\t}\n+\n+\t@Nullable\n+\tprivate Dex loadDexBufFromPath(Path path, String entryName) {\n+\t\ttry {\n+\t\t\treturn new Dex(Files.readAllBytes(path));\n+\t\t} catch (DexException e) {\n+\t\t\tLOG.error(\"Failed to load dex file: {}, error: {}\", entryName, e.getMessage());\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"Failed to load dex file: {}, error: {}\", entryName, e.getMessage(), e);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \t@Nullable\n-\tprivate Path makeDexBuf(String entryName, InputStream inputStream) {\n+\tprivate Path copyToTmpDex(String entryName, InputStream inputStream) {\n \t\ttry {\n \t\t\tPath path = FileUtils.createTempFile(\".dex\");\n \t\t\tFiles.copy(inputStream, path, StandardCopyOption.REPLACE_EXISTING);\n\ndiff --git a/jadx-core/src/test/java/jadx/core/utils/files/InputFileTest.java b/jadx-core/src/test/java/jadx/core/utils/files/InputFileTest.java\n--- a/jadx-core/src/test/java/jadx/core/utils/files/InputFileTest.java\n+++ b/jadx-core/src/test/java/jadx/core/utils/files/InputFileTest.java\n@@ -0,0 +1,37 @@\n+package jadx.core.utils.files;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.utils.exceptions.DecodeException;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+class InputFileTest {\n+\tprivate static final String TEST_SAMPLES_DIR = \"test-samples/\";\n+\n+\t@Test\n+\tpublic void testApkWithFakeDex() throws IOException, DecodeException {\n+\t\tFile sample = getFileFromSampleDir(\"app-with-fake-dex.apk\");\n+\n+\t\tList<InputFile> list = new ArrayList<>();\n+\t\tInputFile.addFilesFrom(sample, list, false);\n+\t\tassertThat(list, hasSize(1));\n+\t\tInputFile inputFile = list.get(0);\n+\t\tassertThat(inputFile.getDexFiles(), hasSize(1));\n+\t}\n+\n+\tprivate static File getFileFromSampleDir(String fileName) {\n+\t\tURL resource = InputFileTest.class.getClassLoader().getResource(TEST_SAMPLES_DIR + fileName);\n+\t\tassertThat(resource, notNullValue());\n+\t\tString pathStr = resource.getFile();\n+\t\treturn new File(pathStr);\n+\t}\n+}",
    "output": "Fix ignore incorrect dex files in apk"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/ArgsInfo.java b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/ArgsInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/ArgsInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/shrink/ArgsInfo.java\n@@ -93,14 +93,21 @@ private boolean canMove(int from, int to) {\n \t\t\t\tmovedSet.set(arg.getRegNum());\n \t\t\t}\n \t\t}\n+\t\tboolean canReorder = startInfo.insn.canReorder();\n \t\tfor (int i = start; i < to; i++) {\n \t\t\tArgsInfo argsInfo = argsList.get(i);\n \t\t\tif (argsInfo.getInlinedInsn() == this) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tInsnNode curInsn = argsInfo.insn;\n-\t\t\tif (!curInsn.canReorder() || usedArgAssign(curInsn, movedSet)) {\n-\t\t\t\treturn false;\n+\t\t\tif (canReorder) {\n+\t\t\t\tif (usedArgAssign(curInsn, movedSet)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (!curInsn.canReorder() || usedArgAssign(curInsn, movedSet)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn true;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions18.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions18.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions18.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions18.java\n@@ -0,0 +1,37 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestConditions18 extends SmaliTest {\n+\n+\t// @formatter:off\n+\t/*\n+\t\tpublic static class TestConditions18 {\n+\t\t\tprivate Map map;\n+\n+\t\t\tpublic boolean test(Object obj) {\n+\t\t\t\treturn this == obj || ((obj instanceof TestConditions18) && st(this.map, ((TestConditions18) obj).map));\n+\t\t\t}\n+\n+\t\t\tprivate static boolean st(Object obj, Object obj2) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmali();\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"return this == obj\"\n+\t\t\t\t+ \" || ((obj instanceof TestConditions18) && st(this.map, ((TestConditions18) obj).map));\"));\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inline/TestInlineInLoop.java b/jadx-core/src/test/java/jadx/tests/integration/inline/TestInlineInLoop.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inline/TestInlineInLoop.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inline/TestInlineInLoop.java\n@@ -1,47 +0,0 @@\n-package jadx.tests.integration.inline;\n-\n-import org.junit.jupiter.api.Test;\n-\n-import jadx.core.dex.nodes.ClassNode;\n-import jadx.tests.api.IntegrationTest;\n-\n-import static jadx.tests.api.utils.JadxMatchers.containsOne;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-\n-public class TestInlineInLoop extends IntegrationTest {\n-\n-\tpublic static class TestCls {\n-\t\tpublic static void main(String[] args) {\n-\t\t\tint a = 0;\n-\t\t\tint b = 4;\n-\t\t\tint c = 0;\n-\t\t\twhile (a < 12) {\n-\t\t\t\tif (b + a < 9 && b < 8) {\n-\t\t\t\t\tif (b >= 2 && a > -1 && b < 6) {\n-\t\t\t\t\t\tSystem.out.println(\"OK\");\n-\t\t\t\t\t\tc = b + 1;\n-\t\t\t\t\t}\n-\t\t\t\t\tc = b;\n-\t\t\t\t}\n-\t\t\t\tc = b;\n-\t\t\t\tb++;\n-\t\t\t\tb = c;\n-\t\t\t\ta++;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Test\n-\tpublic void test() {\n-\t\tClassNode cls = getClassNode(TestCls.class);\n-\t\tString code = cls.getCode().toString();\n-\n-\t\t// TODO: remove unused variables from test\n-\t\tassertThat(code, containsOne(\"int c = b + 1\"));\n-\t\tassertThat(code, containsOne(\"int c2 = b;\"));\n-\t\tassertThat(code, containsOne(\"int c3 = b;\"));\n-\t\tassertThat(code, containsOne(\"int b2 = b + 1;\"));\n-\t\tassertThat(code, containsOne(\"b = c3\"));\n-\t\tassertThat(code, containsOne(\"a++\"));\n-\t}\n-}",
    "output": "Fix adjust insn reorder check in code shrink visitor"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java\n@@ -21,6 +21,7 @@\n import jadx.core.dex.regions.conditions.IfRegion;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n import jadx.core.utils.InsnList;\n+import jadx.core.utils.InsnRemover;\n \n /**\n  * Convert 'if' to ternary operation\n@@ -41,7 +42,14 @@ private static boolean makeTernaryInsn(MethodNode mth, IfRegion ifRegion) {\n \t\t}\n \t\tIContainer thenRegion = ifRegion.getThenRegion();\n \t\tIContainer elseRegion = ifRegion.getElseRegion();\n-\t\tif (thenRegion == null || elseRegion == null) {\n+\t\tif (thenRegion == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (elseRegion == null) {\n+\t\t\tif (mth.isConstructor()) {\n+\t\t\t\t// force ternary conversion to inline all code in 'super' or 'this' calls\n+\t\t\t\treturn processOneBranchTernary(mth, ifRegion);\n+\t\t\t}\n \t\t\treturn false;\n \t\t}\n \t\tBlockNode tb = getTernaryInsnBlock(thenRegion);\n@@ -219,4 +227,62 @@ private static boolean checkLineStats(InsnNode t, InsnNode e) {\n \t\t}\n \t\treturn false;\n \t}\n+\n+\t/**\n+\t * Convert one variable change with only 'then' branch:\n+\t * 'if (c) {r = a;}' to 'r = c ? a : r'\n+\t * Also convert only if 'r' used only once\n+\t */\n+\tprivate static boolean processOneBranchTernary(MethodNode mth, IfRegion ifRegion) {\n+\t\tIContainer thenRegion = ifRegion.getThenRegion();\n+\t\tBlockNode block = getTernaryInsnBlock(thenRegion);\n+\t\tif (block != null) {\n+\t\t\tInsnNode insn = block.getInstructions().get(0);\n+\t\t\tRegisterArg result = insn.getResult();\n+\t\t\tif (result != null) {\n+\t\t\t\treplaceWithTernary(mth, ifRegion, block, insn);\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprivate static void replaceWithTernary(MethodNode mth, IfRegion ifRegion, BlockNode block, InsnNode insn) {\n+\t\tBlockNode header = ifRegion.getConditionBlocks().get(0);\n+\t\tif (!ifRegion.getParent().replaceSubBlock(ifRegion, header)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tRegisterArg resArg = insn.getResult();\n+\t\tif (resArg.getSVar().getUseList().size() != 1) {\n+\t\t\treturn;\n+\t\t}\n+\t\tPhiInsn phiInsn = resArg.getSVar().getOnlyOneUseInPhi();\n+\t\tif (phiInsn == null || phiInsn.getArgsCount() != 2) {\n+\t\t\treturn;\n+\t\t}\n+\t\tRegisterArg otherArg = null;\n+\t\tfor (InsnArg arg : phiInsn.getArguments()) {\n+\t\t\tif (arg != resArg && arg instanceof RegisterArg) {\n+\t\t\t\totherArg = (RegisterArg) arg;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tif (otherArg == null) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// all checks passed\n+\t\tInsnList.remove(block, insn);\n+\t\tTernaryInsn ternInsn = new TernaryInsn(ifRegion.getCondition(),\n+\t\t\t\tphiInsn.getResult(), InsnArg.wrapArg(insn), otherArg);\n+\t\tternInsn.setSourceLine(insn.getSourceLine());\n+\n+\t\tInsnRemover.unbindInsn(mth, phiInsn);\n+\t\theader.getInstructions().clear();\n+\t\theader.getInstructions().add(ternInsn);\n+\n+\t\tclearConditionBlocks(ifRegion.getConditionBlocks(), header);\n+\n+\t\t// shrink method again\n+\t\tCodeShrinkVisitor.shrinkMethod(mth);\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryOneBranchInConstructor.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryOneBranchInConstructor.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryOneBranchInConstructor.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryOneBranchInConstructor.java\n@@ -0,0 +1,51 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestTernaryOneBranchInConstructor extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic TestCls(String str, int i) {\n+\t\t\tthis(str == null ? 0 : i);\n+\t\t}\n+\n+\t\tpublic TestCls(int i) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"this(str == null ? 0 : i);\"));\n+\t\tassertThat(code, not(containsString(\"//\")));\n+\t}\n+\n+\tpublic static class TestCls2 {\n+\t\tpublic TestCls2(String str, int i) {\n+\t\t\tthis(i == 1 ? str : \"\", i == 0 ? \"\" : str);\n+\t\t}\n+\n+\t\tpublic TestCls2(String a, String b) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test2() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls2.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"this(i == 1 ? str : \\\"\\\", i == 0 ? \\\"\\\" : str);\"));\n+\t\tassertThat(code, not(containsString(\"//\")));\n+\t}\n+}",
    "output": "Fix force one branch ternary in constructors"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -227,6 +227,9 @@ protected void makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws Codeg\n \t\t\t\t\tif (attachInsns) {\n \t\t\t\t\t\tcode.attachLineAnnotation(insn);\n \t\t\t\t\t}\n+\t\t\t\t\tif (insn.contains(AFlag.COMMENT_OUT)) {\n+\t\t\t\t\t\tcode.add(\"// \");\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (insn.getResult() != null) {\n \t\t\t\t\tSSAVar var = insn.getResult().getSVar();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n@@ -15,9 +15,11 @@ public enum AFlag {\n \tDONT_WRAP,\n \tDONT_INLINE,\n \tDONT_GENERATE, // process as usual, but don't output to generated code\n+\tCOMMENT_OUT, // process as usual, but comment insn in generated code\n+\tREMOVE, // can be completely removed\n+\n \tRESTART_CODEGEN,\n \tDONT_RENAME, // do not rename during deobfuscation\n-\tREMOVE, // can be completely removed\n \tADDED_TO_REGION,\n \n \tFINALLY_INSNS,\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n@@ -2,21 +2,26 @@\n \n import java.util.Iterator;\n import java.util.List;\n+import java.util.Objects;\n \n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.instructions.ArithNode;\n import jadx.core.dex.instructions.ArithOp;\n import jadx.core.dex.instructions.InsnType;\n+import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.InsnWrapArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n import jadx.core.dex.instructions.mods.ConstructorInsn;\n import jadx.core.dex.instructions.mods.TernaryInsn;\n import jadx.core.dex.nodes.BlockNode;\n+import jadx.core.dex.nodes.IBlock;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.regions.conditions.IfCondition;\n import jadx.core.dex.regions.conditions.IfCondition.Mode;\n+import jadx.core.dex.visitors.regions.AbstractRegionVisitor;\n+import jadx.core.dex.visitors.regions.DepthRegionTraversal;\n import jadx.core.dex.visitors.regions.variables.ProcessVariables;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n import jadx.core.utils.exceptions.JadxException;\n@@ -33,6 +38,8 @@\n )\n public class PrepareForCodeGen extends AbstractVisitor {\n \n+\tpublic static final SuperCallRegionVisitor SUPER_CALL_REGION_VISITOR = new SuperCallRegionVisitor();\n+\n \t@Override\n \tpublic void visit(MethodNode mth) throws JadxException {\n \t\tList<BlockNode> blocks = mth.getBasicBlocks();\n@@ -48,6 +55,7 @@ public void visit(MethodNode mth) throws JadxException {\n \t\t\tremoveParenthesis(block);\n \t\t\tmodifyArith(block);\n \t\t}\n+\t\tcommentOutInsnsBeforeSuper(mth);\n \t}\n \n \tprivate static void removeInstructions(BlockNode block) {\n@@ -171,4 +179,33 @@ private static void modifyArith(BlockNode block) {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tprivate void commentOutInsnsBeforeSuper(MethodNode mth) {\n+\t\tif (mth.isConstructor() && !Objects.equals(mth.getParentClass().getSuperClass(), ArgType.OBJECT)) {\n+\t\t\tDepthRegionTraversal.traverse(mth, SUPER_CALL_REGION_VISITOR);\n+\t\t}\n+\t}\n+\n+\tprivate static final class SuperCallRegionVisitor extends AbstractRegionVisitor {\n+\t\t@Override\n+\t\tpublic void processBlock(MethodNode mth, IBlock container) {\n+\t\t\tfor (InsnNode insn : container.getInstructions()) {\n+\t\t\t\tInsnType insnType = insn.getType();\n+\t\t\t\tif ((insnType == InsnType.CONSTRUCTOR) && ((ConstructorInsn) insn).isSuper()) {\n+\t\t\t\t\t// found super call\n+\t\t\t\t\tcommentOutInsns(container, insn);\n+\t\t\t\t\t// TODO: process all previous regions (in case of branching before super call)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate static void commentOutInsns(IBlock container, InsnNode superInsn) {\n+\t\t\tfor (InsnNode insn : container.getInstructions()) {\n+\t\t\t\tif (insn == superInsn) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tinsn.add(AFlag.COMMENT_OUT);\n+\t\t\t}\n+\t\t}\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestInsnsBeforeSuper.java\n@@ -0,0 +1,41 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestInsnsBeforeSuper extends SmaliTest {\n+\t// @formatter:off\n+\t/*\n+\t\tpublic class A {\n+\t\t\tpublic A(String s) {\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic class B extends A {\n+\t\t\tpublic B(String str) {\n+\t\t\t\tcheckNull(str);\n+\t\t\t\tsuper(str);\n+\t\t\t}\n+\n+\t\t\tpublic void checkNull(Object o) {\n+\t\t\t\tif (o == null) {\n+\t\t\t\t\tthrow new NullPointerException();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmaliFiles(\"B\");\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"// checkNull(str);\"));\n+\t}\n+}",
    "output": "Fix comment out instructions before super call in constructor"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -29,6 +29,7 @@\n import jadx.core.dex.instructions.GotoNode;\n import jadx.core.dex.instructions.IfNode;\n import jadx.core.dex.instructions.InsnDecoder;\n+import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.SwitchNode;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n@@ -332,7 +333,7 @@ private static void initTryCatches(MethodNode mth, Code mthCode, InsnNode[] insn\n \t\t\tInsnNode insn = null;\n \t\t\twhile (offset <= end && offset >= 0) {\n \t\t\t\tinsn = insnByOffset[offset];\n-\t\t\t\tif (insn != null) {\n+\t\t\t\tif (insn != null && insn.getType() != InsnType.NOP) {\n \t\t\t\t\tif (tryBlockStarted) {\n \t\t\t\t\t\tcatchBlock.addInsn(insn);\n \t\t\t\t\t} else if (insn.canThrowException()) {\n@@ -343,9 +344,7 @@ private static void initTryCatches(MethodNode mth, Code mthCode, InsnNode[] insn\n \t\t\t\t}\n \t\t\t\toffset = InsnDecoder.getNextInsnOffset(insnByOffset, offset);\n \t\t\t}\n-\t\t\tif (insnByOffset[end] != null) {\n-\t\t\t\tinsnByOffset[end].add(AFlag.TRY_LEAVE);\n-\t\t\t} else if (insn != null) {\n+\t\t\tif (tryBlockStarted && insn != null) {\n \t\t\t\tinsn.add(AFlag.TRY_LEAVE);\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java\n@@ -31,6 +31,13 @@ protected ClassNode getClassNodeFromSmali(String file, String clsName) {\n \t\treturn getClassNodeFromFile(outDex, clsName);\n \t}\n \n+\t/**\n+\t * Preferred method for one file smali test\n+\t */\n+\tprotected ClassNode getClassNodeFromSmali() {\n+\t\treturn getClassNodeFromSmaliWithPkg(getTestPkg(), getTestName());\n+\t}\n+\n \tprotected ClassNode getClassNodeFromSmali(String clsName) {\n \t\treturn getClassNodeFromSmali(clsName, clsName);\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchLastInsn.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchLastInsn.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchLastInsn.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchLastInsn.java\n@@ -0,0 +1,35 @@\n+package jadx.tests.integration.trycatch;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestTryCatchLastInsn extends SmaliTest {\n+\n+\t// @formatter:off\n+\t/*\n+\t\tpublic Exception test() {\n+\t\t\t? r1 = \"result\"; // String\n+\t\t\ttry {\n+\t\t\t\tr1 = call(); // Exception\n+\t\t\t} catch(Exception e) {\n+\t\t\t\tSystem.out.println(r1); // String\n+\t\t\t\tr1 = e;\n+\t\t\t}\n+\t\t\treturn r1;\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmali();\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"return call();\"));\n+\t}\n+}",
    "output": "Fix ignore NOPs in try-catch"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -1,6 +1,7 @@\n package jadx.core.dex.visitors;\n \n import java.nio.file.Path;\n+import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n@@ -152,7 +153,14 @@ private static void checkFields(Deobfuscator deobfuscator, ClassNode cls, JadxAr\n \t}\n \n \tprivate static void checkMethods(Deobfuscator deobfuscator, ClassNode cls, JadxArgs args) {\n-\t\tfor (MethodNode mth : cls.getMethods()) {\n+\t\tList<MethodNode> methods = new ArrayList<>(cls.getMethods().size());\n+\t\tfor (MethodNode method : cls.getMethods()) {\n+\t\t\tif (!method.getAccessFlags().isConstructor()) {\n+\t\t\t\tmethods.add(method);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfor (MethodNode mth : methods) {\n \t\t\tString alias = mth.getAlias();\n \n \t\t\tboolean notValid = args.isRenameValid() && !NameMapper.isValidIdentifier(alias);\n@@ -162,12 +170,10 @@ private static void checkMethods(Deobfuscator deobfuscator, ClassNode cls, JadxA\n \t\t\t\tmth.addAttr(new RenameReasonAttr(mth, notValid, notPrintable));\n \t\t\t}\n \t\t}\n-\t\tSet<String> names = new HashSet<>();\n-\t\tfor (MethodNode mth : cls.getMethods()) {\n+\t\tSet<String> names = new HashSet<>(methods.size());\n+\t\tfor (MethodNode mth : methods) {\n \t\t\tAccessInfo accessFlags = mth.getAccessFlags();\n-\t\t\tif (accessFlags.isConstructor()\n-\t\t\t\t\t|| accessFlags.isBridge()\n-\t\t\t\t\t|| accessFlags.isSynthetic()\n+\t\t\tif (accessFlags.isBridge() || accessFlags.isSynthetic()\n \t\t\t\t\t|| mth.contains(AFlag.DONT_GENERATE) /* this flag not set yet */) {\n \t\t\t\tcontinue;\n \t\t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicatedNames.java b/jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicatedNames.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicatedNames.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicatedNames.java\n@@ -50,6 +50,6 @@ private void commonChecks() {\n \t\tassertThat(code, containsOne(\"this.f0fieldName\"));\n \n \t\tassertThat(code, containsOne(\"public Object run() {\"));\n-\t\tassertThat(code, containsOne(\"public String m1run() {\"));\n+\t\tassertThat(code, containsOne(\"public String m0run() {\"));\n \t}\n }",
    "output": "Fix don't rename constructors"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -954,6 +954,9 @@ public IRegion processTryCatchBlocks(MethodNode mth) {\n \t\t\tSet<BlockNode> exits = new HashSet<>();\n \t\t\tfor (BlockNode splitter : splitters) {\n \t\t\t\tfor (BlockNode handler : blocks) {\n+\t\t\t\t\tif (handler.contains(AFlag.REMOVE)) {\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \t\t\t\t\tList<BlockNode> s = splitter.getSuccessors();\n \t\t\t\t\tif (s.isEmpty()) {\n \t\t\t\t\t\tLOG.debug(ErrorsCounter.formatMsg(mth, \"No successors for splitter: \" + splitter));\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -432,6 +432,9 @@ public static BlockNode getPathCross(MethodNode mth, BlockNode b1, BlockNode b2)\n \t\tif (b1 == null || b2 == null) {\n \t\t\treturn null;\n \t\t}\n+\t\tif (b1.getDomFrontier() == null || b2.getDomFrontier() == null) {\n+\t\t\treturn null;\n+\t\t}\n \t\tBitSet b = new BitSet();\n \t\tb.or(b1.getDomFrontier());\n \t\tb.and(b2.getDomFrontier());",
    "output": "Fix prevent NPE while processing try/catch regions"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java\n@@ -65,11 +65,11 @@ public static String literalToString(long lit, ArgType type, StringUtils stringU\n \t\t\t\t}\n \t\t\t\treturn stringUtils.unescapeChar(ch);\n \t\t\tcase BYTE:\n-\t\t\t\treturn formatByte((byte) lit);\n+\t\t\t\treturn formatByte(lit);\n \t\t\tcase SHORT:\n-\t\t\t\treturn formatShort((short) lit);\n+\t\t\t\treturn formatShort(lit);\n \t\t\tcase INT:\n-\t\t\t\treturn formatInteger((int) lit);\n+\t\t\t\treturn formatInteger(lit);\n \t\t\tcase LONG:\n \t\t\t\treturn formatLong(lit);\n \t\t\tcase FLOAT:\n@@ -90,34 +90,34 @@ public static String literalToString(long lit, ArgType type, StringUtils stringU\n \t\t}\n \t}\n \n-\tpublic static String formatShort(short s) {\n-\t\tif (s == Short.MAX_VALUE) {\n+\tpublic static String formatShort(long l) {\n+\t\tif (l == Short.MAX_VALUE) {\n \t\t\treturn \"Short.MAX_VALUE\";\n \t\t}\n-\t\tif (s == Short.MIN_VALUE) {\n+\t\tif (l == Short.MIN_VALUE) {\n \t\t\treturn \"Short.MIN_VALUE\";\n \t\t}\n-\t\treturn Short.toString(s);\n+\t\treturn Long.toString(l);\n \t}\n \n-\tpublic static String formatByte(byte b) {\n-\t\tif (b == Byte.MAX_VALUE) {\n+\tpublic static String formatByte(long l) {\n+\t\tif (l == Byte.MAX_VALUE) {\n \t\t\treturn \"Byte.MAX_VALUE\";\n \t\t}\n-\t\tif (b == Byte.MIN_VALUE) {\n+\t\tif (l == Byte.MIN_VALUE) {\n \t\t\treturn \"Byte.MIN_VALUE\";\n \t\t}\n-\t\treturn Byte.toString(b);\n+\t\treturn Long.toString(l);\n \t}\n \n-\tpublic static String formatInteger(int i) {\n-\t\tif (i == Integer.MAX_VALUE) {\n+\tpublic static String formatInteger(long l) {\n+\t\tif (l == Integer.MAX_VALUE) {\n \t\t\treturn \"Integer.MAX_VALUE\";\n \t\t}\n-\t\tif (i == Integer.MIN_VALUE) {\n+\t\tif (l == Integer.MIN_VALUE) {\n \t\t\treturn \"Integer.MIN_VALUE\";\n \t\t}\n-\t\treturn Integer.toString(i);\n+\t\treturn Long.toString(l);\n \t}\n \n \tpublic static String formatLong(long l) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver9.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver9.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver9.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver9.java\n@@ -0,0 +1,39 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.not;\n+\n+public class TestTypeResolver9 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic int test(byte b) {\n+\t\t\treturn 16777216 * b;\n+\t\t}\n+\n+\t\tpublic int test2(byte[] array, int offset) {\n+\t\t\treturn (array[offset] * 128) + (array[offset + 1] & 0xFF);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"return 16777216 * b;\"));\n+\t\tassertThat(code, not(containsString(\"Byte.MIN_VALUE\")));\n+\t}\n+\n+\t@Test\n+\tpublic void testNoDebug() {\n+\t\tnoDebugInfo();\n+\t\tgetClassNode(TestCls.class);\n+\t}\n+}",
    "output": "Fix workaround for primitive values if type resolved incorrectly"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -241,17 +241,21 @@ public void addFallbackMethodCode(CodeWriter code) {\n \t}\n \n \tpublic static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[] insnArr, boolean addLabels) {\n+\t\tcode.incIndent();\n \t\tInsnGen insnGen = new InsnGen(getFallbackMethodGen(mth), true);\n \t\tInsnNode prevInsn = null;\n \t\tfor (InsnNode insn : insnArr) {\n-\t\t\tif (insn == null || insn.getType() == InsnType.NOP) {\n+\t\t\tif (insn == null) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (addLabels && needLabel(insn, prevInsn)) {\n \t\t\t\tcode.decIndent();\n \t\t\t\tcode.startLine(getLabelName(insn.getOffset()) + ':');\n \t\t\t\tcode.incIndent();\n \t\t\t}\n+\t\t\tif (insn.getType() == InsnType.NOP) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\ttry {\n \t\t\t\tcode.startLine();\n \t\t\t\tRegisterArg resArg = insn.getResult();\n@@ -272,6 +276,7 @@ public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[]\n \t\t\t}\n \t\t\tprevInsn = insn;\n \t\t}\n+\t\tcode.decIndent();\n \t}\n \n \tprivate static boolean needLabel(InsnNode insn, InsnNode prevInsn) {",
    "output": "Add labels from NOP instructions in fallback mode"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -559,7 +559,11 @@ private void oneArgInsn(CodeWriter code, InsnNode insn, Set<Flags> state, char o\n \n \tprivate void fallbackOnlyInsn(InsnNode insn) throws CodegenException {\n \t\tif (!fallback) {\n-\t\t\tthrow new CodegenException(insn.getType() + \" can be used only in fallback mode\");\n+\t\t\tString msg = insn.getType() + \" instruction can be used only in fallback mode\";\n+\t\t\tCodegenException e = new CodegenException(msg);\n+\t\t\tmth.addError(msg, e);\n+\t\t\tmth.getParentClass().getTopParentClass().add(AFlag.RESTART_CODEGEN);\n+\t\t\tthrow e;\n \t\t}\n \t}",
    "output": "Fix regenerate method code if unexpected instruction is found"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -36,6 +36,7 @@\n import jadx.core.utils.ErrorsCounter;\n import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.CodegenException;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public class ClassGen {\n \n@@ -261,6 +262,9 @@ private void addMethods(CodeWriter code) {\n \t\t\ttry {\n \t\t\t\taddMethod(code, mth);\n \t\t\t} catch (Exception e) {\n+\t\t\t\tif (mth.getParentClass().getTopParentClass().contains(AFlag.RESTART_CODEGEN)) {\n+\t\t\t\t\tthrow new JadxRuntimeException(\"Method generation error\", e);\n+\t\t\t\t}\n \t\t\t\tcode.newLine().add(\"/*\");\n \t\t\t\tcode.newLine().addMultiLine(ErrorsCounter.methodError(mth, \"Method generation error\", e));\n \t\t\t\tUtils.appendStackTrace(code, e);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java\n@@ -3,6 +3,7 @@\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.utils.exceptions.CodegenException;\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n \n public class CodeGen {\n \n@@ -11,7 +12,18 @@ public static void generate(ClassNode cls) throws CodegenException {\n \t\t\tcls.setCode(CodeWriter.EMPTY);\n \t\t} else {\n \t\t\tClassGen clsGen = new ClassGen(cls, cls.root().getArgs());\n-\t\t\tcls.setCode(clsGen.makeClass());\n+\t\t\tCodeWriter code;\n+\t\t\ttry {\n+\t\t\t\tcode = clsGen.makeClass();\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tif (cls.contains(AFlag.RESTART_CODEGEN)) {\n+\t\t\t\t\tcls.remove(AFlag.RESTART_CODEGEN);\n+\t\t\t\t\tcode = clsGen.makeClass();\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new JadxRuntimeException(\"Code generation error\", e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcls.setCode(code);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -591,6 +591,14 @@ private void makeConstructor(ConstructorInsn insn, CodeWriter code)\n \t}\n \n \tprivate void inlineAnonymousConstructor(CodeWriter code, ClassNode cls, ConstructorInsn insn) throws CodegenException {\n+\t\tif (this.mth.getParentClass() == cls) {\n+\t\t\tcls.remove(AFlag.ANONYMOUS_CLASS);\n+\t\t\tcls.remove(AFlag.DONT_GENERATE);\n+\t\t\tmth.getParentClass().getTopParentClass().add(AFlag.RESTART_CODEGEN);\n+\t\t\tthrow new CodegenException(\"Anonymous inner class unlimited recursion detected.\"\n+\t\t\t\t\t+ \" Convert class to inner: \" + cls.getClassInfo().getFullName());\n+\t\t}\n+\n \t\tcls.add(AFlag.DONT_GENERATE);\n \t\tArgType parent;\n \t\tif (cls.getInterfaces().size() == 1) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -206,6 +206,9 @@ public void addInstructions(CodeWriter code) throws CodegenException {\n \t\t\t\tclassGen.insertDecompilationProblems(code, mth);\n \t\t\t\taddInstructions(code);\n \t\t\t} catch (Exception e) {\n+\t\t\t\tif (mth.getParentClass().getTopParentClass().contains(AFlag.RESTART_CODEGEN)) {\n+\t\t\t\t\tthrow e;\n+\t\t\t\t}\n \t\t\t\tmth.addError(\"Method code generation error\", e);\n \t\t\t\tclassGen.insertDecompilationProblems(code, mth);\n \t\t\t\taddInstructions(code);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n@@ -15,6 +15,7 @@ public enum AFlag {\n \tDONT_WRAP,\n \tDONT_INLINE,\n \tDONT_GENERATE, // process as usual, but don't output to generated code\n+\tRESTART_CODEGEN,\n \tDONT_RENAME, // do not rename during deobfuscation\n \tREMOVE, // can be completely removed\n \tADDED_TO_REGION,\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n@@ -183,6 +183,9 @@ private static List<Path> loadFromJar(Path jar) throws DecodeException {\n \t\t\tif (pathList.isEmpty()) {\n \t\t\t\tthrow new JadxException(\"Empty dx output\");\n \t\t\t}\n+\t\t\tif (LOG.isDebugEnabled()) {\n+\t\t\t\tLOG.debug(\"result dex files: {}\", pathList);\n+\t\t\t}\n \t\t\treturn pathList;\n \t\t} catch (Exception e) {\n \t\t\tthrow new DecodeException(\"java class to dex conversion error:\\n \" + e.getMessage(), e);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java b/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java\n@@ -41,7 +41,7 @@ public List<Path> convert(Path jar) throws JadxException {\n \t\ttry (ByteArrayOutputStream out = new ByteArrayOutputStream();\n \t\t\t\tByteArrayOutputStream errOut = new ByteArrayOutputStream()) {\n \t\t\tDxContext context = new DxContext(out, errOut);\n-\t\t\tPath dir = FileUtils.createTempDir(jar.getFileName().toString());\n+\t\t\tPath dir = FileUtils.createTempDir(\"jar-to-dex-\");\n \t\t\tDxArgs args = new DxArgs(\n \t\t\t\t\tcontext,\n \t\t\t\t\tdir.toAbsolutePath().toString(),\n@@ -58,7 +58,6 @@ public List<Path> convert(Path jar) throws JadxException {\n \t\t\t\t\tchild.toFile().deleteOnExit();\n \t\t\t\t}\n \t\t\t}\n-\t\t\tdir.toFile().deleteOnExit();\n \t\t\treturn list;\n \t\t} catch (Exception e) {\n \t\t\tthrow new JadxException(\"dx exception: \" + e.getMessage(), e);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java\n@@ -49,6 +49,10 @@ protected ClassNode getClassNodeFromSmaliFiles(String pkg, String testName, Stri\n \t\treturn getClassNodeFromFile(outDex, pkg + '.' + clsName);\n \t}\n \n+\tprotected ClassNode getClassNodeFromSmaliFiles(String clsName) {\n+\t\treturn searchCls(loadFromSmaliFiles(), getTestPkg() + '.' + clsName);\n+\t}\n+\n \tprotected List<ClassNode> loadFromSmaliFiles() {\n \t\tFile outDex = createTempFile(\".dex\");\n \t\tcompileSmali(outDex, collectSmaliFiles(getTestPkg(), getTestName()));\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inner/TestIncorrectAnonymousClass.java b/jadx-core/src/test/java/jadx/tests/integration/inner/TestIncorrectAnonymousClass.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inner/TestIncorrectAnonymousClass.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestIncorrectAnonymousClass.java\n@@ -0,0 +1,38 @@\n+package jadx.tests.integration.inner;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static jadx.tests.api.utils.JadxMatchers.countString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestIncorrectAnonymousClass extends SmaliTest {\n+\n+\t// @formatter:off\n+\t/*\n+\t\tpublic static class TestCls {\n+\t\t\tpublic final class 1 {\n+\t\t\t\tpublic void invoke() {\n+\t\t\t\t\tnew 1(); // cause infinite self inline\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tpublic void test() {\n+\t\t\t\tnew 1();\n+\t\t\t}\n+\t\t}\n+\t*/\n+\t// @formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmaliFiles(\"TestCls\");\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"public final class AnonymousClass1 {\"));\n+\t\tassertThat(code, countString(2, \"new AnonymousClass1();\"));\n+\t}\n+}",
    "output": "Fix handle anonymous class self inlining"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -329,10 +329,10 @@ private void addMethod(CodeWriter code, MethodNode mth) throws CodegenException\n \t\t}\n \t}\n \n-\tprivate void insertDecompilationProblems(CodeWriter code, AttrNode node) {\n+\tpublic void insertDecompilationProblems(CodeWriter code, AttrNode node) {\n \t\tList<JadxError> errors = node.getAll(AType.JADX_ERROR);\n \t\tif (!errors.isEmpty()) {\n-\t\t\terrors.stream().sorted().forEach(err -> {\n+\t\t\terrors.stream().distinct().sorted().forEach(err -> {\n \t\t\t\tcode.startLine(\"/*  JADX ERROR: \").add(err.getError());\n \t\t\t\tThrowable cause = err.getCause();\n \t\t\t\tif (cause != null) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -30,6 +30,7 @@\n import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.CodegenException;\n import jadx.core.utils.exceptions.DecodeException;\n+import jadx.core.utils.exceptions.JadxOverflowException;\n \n public class MethodGen {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(MethodGen.class);\n@@ -197,8 +198,18 @@ public void addInstructions(CodeWriter code) throws CodegenException {\n \t\t\t\t\t.add(mth.getMethodInfo().getReturnType().toString())\n \t\t\t\t\t.add(\"\\\");\");\n \t\t} else {\n-\t\t\tRegionGen regionGen = new RegionGen(this);\n-\t\t\tregionGen.makeRegion(code, mth.getRegion());\n+\t\t\ttry {\n+\t\t\t\tRegionGen regionGen = new RegionGen(this);\n+\t\t\t\tregionGen.makeRegion(code, mth.getRegion());\n+\t\t\t} catch (StackOverflowError | BootstrapMethodError e) {\n+\t\t\t\tmth.addError(\"Method code generation error\", new JadxOverflowException(\"StackOverflow\"));\n+\t\t\t\tclassGen.insertDecompilationProblems(code, mth);\n+\t\t\t\taddInstructions(code);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tmth.addError(\"Method code generation error\", e);\n+\t\t\t\tclassGen.insertDecompilationProblems(code, mth);\n+\t\t\t\taddInstructions(code);\n+\t\t\t}\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/JadxError.java b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/JadxError.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/JadxError.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/JadxError.java\n@@ -1,18 +1,18 @@\n package jadx.core.dex.attributes.nodes;\n \n+import java.util.Objects;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n import jadx.core.utils.Utils;\n \n-public class JadxError {\n+public class JadxError implements Comparable<JadxError> {\n \n \tprivate final String error;\n \tprivate final Throwable cause;\n \n-\tpublic JadxError(Throwable cause) {\n-\t\tthis(null, cause);\n-\t}\n-\n \tpublic JadxError(String error, Throwable cause) {\n-\t\tthis.error = error;\n+\t\tthis.error = Objects.requireNonNull(error);\n \t\tthis.cause = cause;\n \t}\n \n@@ -24,6 +24,28 @@ public Throwable getCause() {\n \t\treturn cause;\n \t}\n \n+\t@Override\n+\tpublic int compareTo(@NotNull JadxError o) {\n+\t\treturn this.error.compareTo(o.getError());\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tJadxError other = (JadxError) o;\n+\t\treturn error.equals(other.error);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn error.hashCode();\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\tStringBuilder str = new StringBuilder();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -659,14 +659,28 @@ public void addComment(String commentStr) {\n \t\tLOG.info(\"{} in {}\", commentStr, this);\n \t}\n \n-\tpublic void addError(String errStr, Exception e) {\n+\tpublic void addError(String errStr, Throwable e) {\n \t\tErrorsCounter.methodError(this, errStr, e);\n \t}\n \n \tpublic MethodInfo getMethodInfo() {\n \t\treturn mthInfo;\n \t}\n \n+\t/**\n+\t * Stat method.\n+\t * Calculate instructions count as a measure of method size\n+\t */\n+\tpublic long countInsns() {\n+\t\tif (instructions != null) {\n+\t\t\treturn instructions.length;\n+\t\t}\n+\t\tif (blocks != null) {\n+\t\t\treturn blocks.stream().mapToLong(block -> block.getInstructions().size()).sum();\n+\t\t}\n+\t\treturn -1;\n+\t}\n+\n \t@Override\n \tpublic int hashCode() {\n \t\treturn mthInfo.hashCode();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java\n@@ -143,7 +143,7 @@ private static int getInsnOffsetByArg(InsnArg arg) {\n \tpublic static void applyDebugInfo(MethodNode mth, SSAVar ssaVar, ArgType type, String varName) {\n \t\tTypeUpdateResult result = mth.root().getTypeUpdate().applyWithWiderAllow(ssaVar, type);\n \t\tif (result == TypeUpdateResult.REJECT) {\n-\t\t\tif (LOG.isDebugEnabled()) {\n+\t\t\tif (Consts.DEBUG) {\n \t\t\t\tLOG.debug(\"Reject debug info of type: {} and name: '{}' for {}, mth: {}\", type, varName, ssaVar, mth);\n \t\t\t}\n \t\t} else {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeSearch.java\n@@ -232,7 +232,9 @@ private void fillTypeCandidates(SSAVar ssaVar) {\n \t\tint size = candidateTypes.size();\n \t\tif (size == 0) {\n \t\t\tthrow new JadxRuntimeException(\"No candidate types for var: \" + ssaVar.getDetailedVarInfo(mth)\n-\t\t\t\t\t+ \"\\n  assigns: \" + assigns + \"\\n  uses: \" + uses);\n+\t\t\t\t\t+ \"\\n  assigns: \" + assigns\n+\t\t\t\t\t+ \"\\n  uses: \" + uses\n+\t\t\t\t\t+ \"\\n  mth insns count: \" + mth.countInsns());\n \t\t}\n \t\tif (size == 1) {\n \t\t\tvarInfo.setTypeResolved(true);",
    "output": "Fix improve errors handling"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java\n@@ -1,9 +1,10 @@\n package jadx.core.dex.instructions;\n \n-import java.util.LinkedHashMap;\n-import java.util.Map;\n+import java.util.ArrayList;\n+import java.util.List;\n \n import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n \n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.instructions.args.ArgType;\n@@ -17,11 +18,12 @@\n \n public final class PhiInsn extends InsnNode {\n \n-\tprivate final Map<RegisterArg, BlockNode> blockBinds;\n+\t// map arguments to blocks (in same order as in arguments list)\n+\tprivate final List<BlockNode> blockBinds;\n \n \tpublic PhiInsn(int regNum, int predecessors) {\n \t\tsuper(InsnType.PHI, predecessors);\n-\t\tthis.blockBinds = new LinkedHashMap<>(predecessors);\n+\t\tthis.blockBinds = new ArrayList<>(predecessors);\n \t\tsetResult(InsnArg.reg(regNum, ArgType.UNKNOWN));\n \t\tadd(AFlag.DONT_INLINE);\n \t\tadd(AFlag.DONT_GENERATE);\n@@ -34,19 +36,24 @@ public RegisterArg bindArg(BlockNode pred) {\n \t}\n \n \tpublic void bindArg(RegisterArg arg, BlockNode pred) {\n-\t\tif (blockBinds.containsValue(pred)) {\n+\t\tif (blockBinds.contains(pred)) {\n \t\t\tthrow new JadxRuntimeException(\"Duplicate predecessors in PHI insn: \" + pred + \", \" + this);\n \t\t}\n-\t\taddArg(arg);\n-\t\tblockBinds.put(arg, pred);\n+\t\tsuper.addArg(arg);\n+\t\tblockBinds.add(pred);\n \t}\n \n+\t@Nullable\n \tpublic BlockNode getBlockByArg(RegisterArg arg) {\n-\t\treturn blockBinds.get(arg);\n+\t\tint index = getArgIndex(arg);\n+\t\tif (index == -1) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn blockBinds.get(index);\n \t}\n \n-\tpublic Map<RegisterArg, BlockNode> getBlockBinds() {\n-\t\treturn blockBinds;\n+\tpublic BlockNode getBlockByArgIndex(int argIndex) {\n+\t\treturn blockBinds.get(argIndex);\n \t}\n \n \t@Override\n@@ -57,39 +64,52 @@ public RegisterArg getArg(int n) {\n \n \t@Override\n \tpublic boolean removeArg(InsnArg arg) {\n-\t\tif (!(arg instanceof RegisterArg)) {\n+\t\tint index = getArgIndex(arg);\n+\t\tif (index == -1) {\n \t\t\treturn false;\n \t\t}\n-\t\tRegisterArg reg = (RegisterArg) arg;\n-\t\tif (super.removeArg(reg)) {\n-\t\t\tblockBinds.remove(reg);\n-\t\t\treg.getSVar().removeUse(reg);\n-\t\t\tInsnRemover.fixUsedInPhiFlag(reg);\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn false;\n+\t\tremoveArg(index);\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tprotected RegisterArg removeArg(int index) {\n+\t\tRegisterArg reg = (RegisterArg) super.removeArg(index);\n+\t\tblockBinds.remove(index);\n+\t\tInsnRemover.fixUsedInPhiFlag(reg);\n+\t\treturn reg;\n \t}\n \n \t@Override\n \tpublic boolean replaceArg(InsnArg from, InsnArg to) {\n \t\tif (!(from instanceof RegisterArg) || !(to instanceof RegisterArg)) {\n \t\t\treturn false;\n \t\t}\n-\t\tBlockNode pred = getBlockByArg((RegisterArg) from);\n+\n+\t\tint argIndex = getArgIndex(from);\n+\t\tif (argIndex == -1) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tBlockNode pred = getBlockByArgIndex(argIndex);\n \t\tif (pred == null) {\n \t\t\tthrow new JadxRuntimeException(\"Unknown predecessor block by arg \" + from + \" in PHI: \" + this);\n \t\t}\n-\t\tif (removeArg(from)) {\n-\t\t\tRegisterArg reg = (RegisterArg) to;\n-\t\t\tbindArg(reg, pred);\n-\t\t\treg.getSVar().setUsedInPhi(this);\n-\t\t}\n+\t\tremoveArg(argIndex);\n+\n+\t\tRegisterArg reg = (RegisterArg) to;\n+\t\tbindArg(reg, pred);\n+\t\treg.getSVar().setUsedInPhi(this);\n \t\treturn true;\n \t}\n \n+\t@Override\n+\tpublic void addArg(InsnArg arg) {\n+\t\tthrow new JadxRuntimeException(\"Direct addArg is forbidden for PHI insn, bindArg must be used\");\n+\t}\n+\n \t@Override\n \tpublic void setArg(int n, InsnArg arg) {\n-\t\tthrow new JadxRuntimeException(\"Unsupported operation for PHI node\");\n+\t\tthrow new JadxRuntimeException(\"Direct setArg is forbidden for PHI insn, bindArg must be used\");\n \t}\n \n \t@Override\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n@@ -139,15 +139,29 @@ public boolean replaceArg(InsnArg from, InsnArg to) {\n \t}\n \n \tprotected boolean removeArg(InsnArg arg) {\n+\t\tint index = getArgIndex(arg);\n+\t\tif (index == -1) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tremoveArg(index);\n+\t\treturn true;\n+\t}\n+\n+\tprotected InsnArg removeArg(int index) {\n+\t\tInsnArg arg = arguments.get(index);\n+\t\targuments.remove(index);\n+\t\tInsnRemover.unbindArgUsage(null, arg);\n+\t\treturn arg;\n+\t}\n+\n+\tprotected int getArgIndex(InsnArg arg) {\n \t\tint count = getArgsCount();\n \t\tfor (int i = 0; i < count; i++) {\n \t\t\tif (arg == arguments.get(i)) {\n-\t\t\t\targuments.remove(i);\n-\t\t\t\tInsnRemover.unbindArgUsage(null, arg);\n-\t\t\t\treturn true;\n+\t\t\t\treturn i;\n \t\t\t}\n \t\t}\n-\t\treturn false;\n+\t\treturn -1;\n \t}\n \n \tprotected void addReg(DecodedInstruction insn, int i, ArgType type) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -3,7 +3,6 @@\n import java.util.ArrayList;\n import java.util.LinkedHashSet;\n import java.util.List;\n-import java.util.Map;\n import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n@@ -318,10 +317,12 @@ private boolean tryInsertAdditionalInsn(MethodNode mth, SSAVar var) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n-\t\tfor (Map.Entry<RegisterArg, BlockNode> entry : phiInsn.getBlockBinds().entrySet()) {\n-\t\t\tRegisterArg reg = entry.getKey();\n+\n+\t\tint argsCount = phiInsn.getArgsCount();\n+\t\tfor (int argIndex = 0; argIndex < argsCount; argIndex++) {\n+\t\t\tRegisterArg reg = phiInsn.getArg(argIndex);\n \t\t\tif (reg.getSVar() == var) {\n-\t\t\t\tBlockNode blockNode = entry.getValue();\n+\t\t\t\tBlockNode blockNode = phiInsn.getBlockByArgIndex(argIndex);\n \t\t\t\tInsnNode lastInsn = BlockUtils.getLastInsn(blockNode);\n \t\t\t\tif (lastInsn != null && BlockSplitter.makeSeparate(lastInsn.getType())) {\n \t\t\t\t\tif (Consts.DEBUG) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n@@ -162,9 +162,6 @@ private static void checkPHI(MethodNode mth) {\n \t\t\t\tif (insn.getType() == InsnType.PHI) {\n \t\t\t\t\tPhiInsn phi = (PhiInsn) insn;\n \t\t\t\t\tphis.add(phi);\n-\t\t\t\t\tif (phi.getArgsCount() != phi.getBlockBinds().size()) {\n-\t\t\t\t\t\tthrow new JadxRuntimeException(\"Incorrect args and binds in PHI\");\n-\t\t\t\t\t}\n \t\t\t\t\tif (phi.getArgsCount() == 0) {\n \t\t\t\t\t\tthrow new JadxRuntimeException(\"No args and binds in PHI\");\n \t\t\t\t\t}",
    "output": "Fix correct arg replace in PHI instruction"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -769,12 +769,14 @@ private boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnAr\n \t\t\treturn false;\n \t\t}\n \t\tif (origType.isGeneric()) {\n-\t\t\tif (!argType.isGeneric() && arg.isInsnWrap()) {\n-\t\t\t\t((InsnWrapArg) arg).getWrapInsn().getResult().setType(\n-\t\t\t\t\t\tArgType.generic(argType.getObject(), origType.getGenericTypes()));\n-\t\t\t}\n-\t\t\tif (origType.getObject().equals(argType.getObject())) {\n-\t\t\t\treturn false;\n+\t\t\tif (argType.isObject()) {\n+\t\t\t\tif (!argType.isGeneric() && arg.isInsnWrap()) {\n+\t\t\t\t\t((InsnWrapArg) arg).getWrapInsn().getResult().setType(\n+\t\t\t\t\t\t\tArgType.generic(argType.getObject(), origType.getGenericTypes()));\n+\t\t\t\t}\n+\t\t\t\tif (origType.getObject().equals(argType.getObject())) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n \t\t\t}\n \t\t\tif (arg.isInsnWrap()) {\n \t\t\t\t((InsnWrapArg) arg).getWrapInsn().add(AFlag.EXPLICIT_GENERICS);",
    "output": "Fix UnsupportedOperationException in overloaded method process"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -32,7 +32,7 @@ public void init(RootNode root) {\n \t\t\treturn;\n \t\t}\n \t\tInputFile firstInputFile = dexNodes.get(0).getDexFile().getInputFile();\n-\t\tPath inputFilePath = firstInputFile.getFile().toPath();\n+\t\tPath inputFilePath = firstInputFile.getFile().getAbsoluteFile().toPath();\n \n \t\tString inputName = inputFilePath.getFileName().toString();\n \t\tString baseName = inputName.substring(0, inputName.lastIndexOf('.'));",
    "output": "Fix NPE if loading local file from CLI (`jadx sample.apk`)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n@@ -151,6 +151,12 @@ private TypeUpdateResult requestUpdate(TypeUpdateInfo updateInfo, InsnArg arg, A\n \t\t\treturn CHANGED;\n \t\t}\n \t\tupdateInfo.requestUpdate(arg, candidateType);\n+\t\tif (updateInfo.getUpdates().size() > 500) {\n+\t\t\tif (Consts.DEBUG) {\n+\t\t\t\tLOG.error(\"Type update error: too deep update tree\");\n+\t\t\t}\n+\t\t\treturn REJECT;\n+\t\t}\n \t\ttry {\n \t\t\tTypeUpdateResult result = runListeners(updateInfo, arg, candidateType);\n \t\t\tif (result == REJECT) {",
    "output": "Fix prevent stack overflow in type inference if update tree is too deep"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n@@ -157,7 +157,7 @@ private TypeUpdateResult requestUpdate(TypeUpdateInfo updateInfo, InsnArg arg, A\n \t\t\t\tupdateInfo.rollbackUpdate(arg);\n \t\t\t}\n \t\t\treturn result;\n-\t\t} catch (StackOverflowError overflow) {\n+\t\t} catch (StackOverflowError | BootstrapMethodError error) {\n \t\t\tthrow new JadxOverflowException(\"Type update terminated with stack overflow, arg: \" + arg);\n \t\t}\n \t}",
    "output": "Fix stack overflow cause lamdba throw BootstrapMethodError in JDK 8"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n@@ -117,8 +117,8 @@ public void codeJump(JumpPosition pos) {\n \t@Nullable\n \tprivate JumpPosition getCurrentPosition() {\n \t\tContentPanel selectedCodePanel = getSelectedCodePanel();\n-\t\tif (selectedCodePanel instanceof CodeContentPanel) {\n-\t\t\treturn ((CodeContentPanel) selectedCodePanel).getCodeArea().getCurrentPosition();\n+\t\tif (selectedCodePanel instanceof AbstractCodeContentPanel) {\n+\t\t\treturn ((AbstractCodeContentPanel) selectedCodePanel).getCodeArea().getCurrentPosition();\n \t\t}\n \t\treturn null;\n \t}",
    "output": "Fix back button was defect since #653"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/RenameReasonAttr.java b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/RenameReasonAttr.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/RenameReasonAttr.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/RenameReasonAttr.java\n@@ -35,11 +35,11 @@ public RenameReasonAttr(AttrNode node, boolean notValid, boolean notPrintable) {\n \t\t}\n \t}\n \n-\tprivate RenameReasonAttr notValid() {\n+\tpublic RenameReasonAttr notValid() {\n \t\treturn append(\"not valid java name\");\n \t}\n \n-\tprivate RenameReasonAttr notPrintable() {\n+\tpublic RenameReasonAttr notPrintable() {\n \t\treturn append(\"contains not printable characters\");\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -79,6 +79,13 @@ private static void checkClassName(Deobfuscator deobfuscator, ClassNode cls, Jad\n \t\tString clsName = classInfo.getAliasShortName();\n \n \t\tString newShortName = fixClsShortName(args, clsName);\n+\t\tif (newShortName == null) {\n+\t\t\t// rename failed, use deobfuscator\n+\t\t\tString deobfName = deobfuscator.getClsAlias(cls);\n+\t\t\tclassInfo.changeShortName(deobfName);\n+\t\t\tcls.addAttr(new RenameReasonAttr(cls).notPrintable());\n+\t\t\treturn;\n+\t\t}\n \t\tif (!newShortName.equals(clsName)) {\n \t\t\tclassInfo.changeShortName(newShortName);\n \t\t\tcls.addAttr(new RenameReasonAttr(cls).append(\"invalid class name\"));\n@@ -104,6 +111,7 @@ private static void checkClassName(Deobfuscator deobfuscator, ClassNode cls, Jad\n \t\t}\n \t}\n \n+\t@Nullable\n \tprivate static String fixClsShortName(JadxArgs args, String clsName) {\n \t\tchar firstChar = clsName.charAt(0);\n \t\tboolean renameValid = args.isRenameValid();\n@@ -116,6 +124,9 @@ private static String fixClsShortName(JadxArgs args, String clsName) {\n \t\tString cleanClsName = args.isRenamePrintable()\n \t\t\t\t? NameMapper.removeInvalidChars(clsName, \"C\")\n \t\t\t\t: clsName;\n+\t\tif (cleanClsName.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n \t\tif (renameValid && !NameMapper.isValidIdentifier(cleanClsName)) {\n \t\t\treturn 'C' + cleanClsName;\n \t\t}",
    "output": "Fix rename class if all chars not printable"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n--- a/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n@@ -3,7 +3,9 @@\n import java.io.PrintStream;\n import java.lang.reflect.Field;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n@@ -66,9 +68,9 @@ public void printUsage() {\n \t\t\t\tmaxNamesLen = len;\n \t\t\t}\n \t\t}\n-\t\tJadxCLIArgs args = new JadxCLIArgs();\n-\t\tField[] fields = args.getClass().getDeclaredFields();\n-\t\tfor (Field f : fields) {\n+\n+\t\tJadxCLIArgs args = (JadxCLIArgs) jc.getObjects().get(0);\n+\t\tfor (Field f : getFields(args.getClass())) {\n \t\t\tString name = f.getName();\n \t\t\tParameterDescription p = paramsMap.get(name);\n \t\t\tif (p == null) {\n@@ -85,6 +87,21 @@ public void printUsage() {\n \t\tout.println(\"  jadx -d out classes.dex\");\n \t}\n \n+\t/**\n+\t * Get all declared fields of the specified class and all super classes\n+\t *\n+\t * @param clazz\n+\t * @return\n+\t */\n+\tprivate List<Field> getFields(Class<?> clazz) {\n+\t\tList<Field> fieldList = new LinkedList<>();\n+\t\twhile (clazz != null) {\n+\t\t\tfieldList.addAll(Arrays.asList(clazz.getDeclaredFields()));\n+\t\t\tclazz = clazz.getSuperclass();\n+\t\t}\n+\t\treturn fieldList;\n+\t}\n+\n \tprivate void addDefaultValue(JadxCLIArgs args, Field f, StringBuilder opt) {\n \t\tClass<?> fieldType = f.getType();\n \t\tif (fieldType == int.class) {",
    "output": "Fix printUsage for jadx-gui now shows the new gui only parameter(s)"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n@@ -1,16 +1,11 @@\n package jadx.cli;\n \n-import java.io.File;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import jadx.api.JadxArgs;\n import jadx.api.JadxDecompiler;\n import jadx.core.utils.exceptions.JadxArgsValidateException;\n-import jadx.core.utils.files.FileUtils;\n \n public class JadxCLI {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(JadxCLI.class);\n@@ -32,7 +27,6 @@ public static void main(String[] args) {\n \n \tstatic int processAndSave(JadxCLIArgs inputArgs) {\n \t\tJadxArgs args = inputArgs.toJadxArgs();\n-\t\targs.setFsCaseSensitive(getFsCaseSensitivity(args));\n \t\tJadxDecompiler jadx = new JadxDecompiler(args);\n \t\ttry {\n \t\t\tjadx.load();\n@@ -50,14 +44,4 @@ static int processAndSave(JadxCLIArgs inputArgs) {\n \t\t}\n \t\treturn errorsCount;\n \t}\n-\n-\tprivate static boolean getFsCaseSensitivity(JadxArgs args) {\n-\t\tList<File> testDirList = new ArrayList<>(3);\n-\t\ttestDirList.add(args.getOutDir());\n-\t\ttestDirList.add(args.getOutDirSrc());\n-\t\tif (!args.getInputFiles().isEmpty()) {\n-\t\t\ttestDirList.add(args.getInputFiles().get(0));\n-\t\t}\n-\t\treturn FileUtils.isCaseSensitiveFS(testDirList);\n-\t}\n }\n\ndiff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n@@ -85,6 +85,9 @@ public class JadxCLIArgs {\n \t@Parameter(names = { \"--deobf-use-sourcename\" }, description = \"use source file name as class name alias\")\n \tprotected boolean deobfuscationUseSourceNameAsAlias = true;\n \n+\t@Parameter(names = { \"--fs-case-sensitive\" }, description = \"treat filesystem as case sensitive, false by default\")\n+\tprotected boolean fsCaseSensitive = false;\n+\n \t@Parameter(names = { \"--cfg\" }, description = \"save methods control flow graph to dot file\")\n \tprotected boolean cfgOutput = false;\n \n@@ -190,6 +193,7 @@ public JadxArgs toJadxArgs() {\n \t\targs.setRenameCaseSensitive(isRenameCaseSensitive());\n \t\targs.setRenameValid(isRenameValid());\n \t\targs.setRenamePrintable(isRenamePrintable());\n+\t\targs.setFsCaseSensitive(fsCaseSensitive);\n \t\treturn args;\n \t}\n \n@@ -321,8 +325,11 @@ public void setRenamePrintable(boolean renamePrintable) {\n \t\t}\n \t}\n \n-\tstatic class RenameConverter implements IStringConverter<Set<RenameEnum>> {\n+\tpublic boolean isFsCaseSensitive() {\n+\t\treturn fsCaseSensitive;\n+\t}\n \n+\tstatic class RenameConverter implements IStringConverter<Set<RenameEnum>> {\n \t\tprivate final String paramName;\n \n \t\tRenameConverter(String paramName) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n@@ -13,13 +13,11 @@\n import java.util.Enumeration;\n import java.util.List;\n import java.util.Objects;\n-import java.util.Optional;\n import java.util.jar.JarEntry;\n import java.util.jar.JarOutputStream;\n import java.util.zip.ZipEntry;\n import java.util.zip.ZipFile;\n \n-import org.apache.commons.io.IOCase;\n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n@@ -188,52 +186,6 @@ private static boolean isZipFileCanBeOpen(File file) {\n \t\t}\n \t}\n \n-\t/**\n-\t * Checks dirs in order, fist success result returned\n-\t */\n-\tpublic static boolean isCaseSensitiveFS(List<File> testDirList) {\n-\t\tfor (File dir : testDirList) {\n-\t\t\tOptional<Boolean> result = isCaseSensitiveFSInternal(dir);\n-\t\t\tif (result.isPresent()) {\n-\t\t\t\treturn result.get();\n-\t\t\t}\n-\t\t}\n-\t\treturn IOCase.SYSTEM.isCaseSensitive();\n-\t}\n-\n-\tpublic static boolean isCaseSensitiveFS(File testDir) {\n-\t\tOptional<Boolean> result = isCaseSensitiveFSInternal(testDir);\n-\t\treturn result.orElseGet(IOCase.SYSTEM::isCaseSensitive);\n-\t}\n-\n-\tprivate static Optional<Boolean> isCaseSensitiveFSInternal(@Nullable File testDir) {\n-\t\tif (testDir != null && testDir.exists() && testDir.isDirectory()) {\n-\t\t\tFile caseCheckUpper = new File(testDir, \"CaseCheck\");\n-\t\t\tFile caseCheckLow = new File(testDir, \"casecheck\");\n-\t\t\ttry {\n-\t\t\t\tmakeDirs(testDir);\n-\t\t\t\tif (caseCheckUpper.createNewFile()) {\n-\t\t\t\t\tboolean caseSensitive = !caseCheckLow.exists();\n-\t\t\t\t\tLOG.debug(\"Filesystem at {} is {}case-sensitive\", testDir.getAbsolutePath(),\n-\t\t\t\t\t\t\t(caseSensitive ? \"\" : \"NOT \"));\n-\t\t\t\t\treturn Optional.of(caseSensitive);\n-\t\t\t\t} else {\n-\t\t\t\t\tLOG.debug(\"Failed to create file: {}\", caseCheckUpper.getAbsolutePath());\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tLOG.debug(\"Failed to detect filesystem case-sensitivity by file creation\", e);\n-\t\t\t} finally {\n-\t\t\t\ttry {\n-\t\t\t\t\tFiles.deleteIfExists(caseCheckUpper.toPath());\n-\t\t\t\t\tFiles.deleteIfExists(caseCheckLow.toPath());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t// ignore\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn Optional.empty();\n-\t}\n-\n \tpublic static File toFile(String path) {\n \t\tif (path == null) {\n \t\t\treturn null;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n@@ -18,7 +18,6 @@\n import jadx.api.JavaClass;\n import jadx.api.JavaPackage;\n import jadx.api.ResourceFile;\n-import jadx.core.utils.files.FileUtils;\n import jadx.gui.settings.JadxSettings;\n \n public class JadxWrapper {\n@@ -37,8 +36,6 @@ public void openFile(File file) {\n \t\ttry {\n \t\t\tJadxArgs jadxArgs = settings.toJadxArgs();\n \t\t\tjadxArgs.setInputFile(file);\n-\t\t\t// output folder not known yet => use input dir as a best choice\n-\t\t\tjadxArgs.setFsCaseSensitive(FileUtils.isCaseSensitiveFS(file.getParentFile()));\n \n \t\t\tthis.decompiler = new JadxDecompiler(jadxArgs);\n \t\t\tthis.decompiler.load();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -281,6 +281,10 @@ public void setInlineAnonymousClasses(boolean inlineAnonymousClasses) {\n \t\tthis.inlineAnonymousClasses = inlineAnonymousClasses;\n \t}\n \n+\tpublic void setFsCaseSensitive(boolean fsCaseSensitive) {\n+\t\tthis.fsCaseSensitive = fsCaseSensitive;\n+\t}\n+\n \tpublic boolean isAutoStartJobs() {\n \t\treturn autoStartJobs;\n \t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -353,6 +353,13 @@ private SettingsGroup makeDecompilationGroup() {\n \t\t\tneedReload();\n \t\t});\n \n+\t\tJCheckBox fsCaseSensitive = new JCheckBox();\n+\t\tfsCaseSensitive.setSelected(settings.isFsCaseSensitive());\n+\t\tfsCaseSensitive.addItemListener(e -> {\n+\t\t\tsettings.setFsCaseSensitive(e.getStateChange() == ItemEvent.SELECTED);\n+\t\t\tneedReload();\n+\t\t});\n+\n \t\tSettingsGroup other = new SettingsGroup(NLS.str(\"preferences.decompile\"));\n \t\tother.addRow(NLS.str(\"preferences.threads\"), threadsCount);\n \t\tother.addRow(NLS.str(\"preferences.excludedPackages\"), NLS.str(\"preferences.excludedPackages.tooltip\"),\n@@ -364,6 +371,7 @@ private SettingsGroup makeDecompilationGroup() {\n \t\tother.addRow(NLS.str(\"preferences.respectBytecodeAccessModifiers\"), respectBytecodeAccessModifiers);\n \t\tother.addRow(NLS.str(\"preferences.useImports\"), useImports);\n \t\tother.addRow(NLS.str(\"preferences.inlineAnonymous\"), inlineAnonymous);\n+\t\tother.addRow(NLS.str(\"preferences.fsCaseSensitive\"), fsCaseSensitive);\n \t\tother.addRow(NLS.str(\"preferences.fallback\"), fallback);\n \t\tother.addRow(NLS.str(\"preferences.skipResourcesDecode\"), resourceDecode);\n \t\treturn other;",
    "output": "Fix treat filesystem as case insensitive by default, option added for change"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -370,7 +370,7 @@ private void addFields(CodeWriter code) throws CodegenException {\n \t\t\tif (fv != null) {\n \t\t\t\tcode.add(\" = \");\n \t\t\t\tif (fv.getValue() == null) {\n-\t\t\t\t\tcode.add(TypeGen.literalToString(0, f.getType(), cls));\n+\t\t\t\t\tcode.add(TypeGen.literalToString(0, f.getType(), cls, fallback));\n \t\t\t\t} else {\n \t\t\t\t\tif (fv.getValueType() == InitType.CONST) {\n \t\t\t\t\t\tannotationGen.encodeValue(code, fv.getValue());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -138,7 +138,7 @@ public void declareVar(CodeWriter code, CodeVar codeVar) {\n \t}\n \n \tprivate String lit(LiteralArg arg) {\n-\t\treturn TypeGen.literalToString(arg.getLiteral(), arg.getType(), mth);\n+\t\treturn TypeGen.literalToString(arg.getLiteral(), arg.getType(), mth, fallback);\n \t}\n \n \tprivate void instanceField(CodeWriter code, FieldInfo field, InsnArg arg) throws CodegenException {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -148,7 +148,13 @@ private void addMethodArguments(CodeWriter code, List<RegisterArg> args) {\n \t\t\tif (var.isFinal()) {\n \t\t\t\tcode.add(\"final \");\n \t\t\t}\n-\t\t\tArgType argType = var.getType();\n+\t\t\tArgType argType;\n+\t\t\tif (var.getType() == ArgType.UNKNOWN) {\n+\t\t\t\t// occur on decompilation errors\n+\t\t\t\targType = mthArg.getInitType();\n+\t\t\t} else {\n+\t\t\t\targType = var.getType();\n+\t\t\t}\n \t\t\tif (!it.hasNext() && mth.getAccessFlags().isVarArgs()) {\n \t\t\t\t// change last array argument to varargs\n \t\t\t\tif (argType.isArray()) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java\n@@ -266,7 +266,7 @@ private CodeWriter makeSwitch(SwitchRegion sw, CodeWriter code) throws CodegenEx\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} else if (k instanceof Integer) {\n-\t\t\t\t\tcode.add(TypeGen.literalToString((Integer) k, arg.getType(), mth));\n+\t\t\t\t\tcode.add(TypeGen.literalToString((Integer) k, arg.getType(), mth, fallback));\n \t\t\t\t} else {\n \t\t\t\t\tthrow new JadxRuntimeException(\"Unexpected key in switch: \" + (k != null ? k.getClass() : null));\n \t\t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java\n@@ -33,14 +33,14 @@ public static String signature(ArgType type) {\n \t *\n \t * @throws JadxRuntimeException for incorrect type or literal value\n \t */\n-\tpublic static String literalToString(long lit, ArgType type, IDexNode dexNode) {\n-\t\treturn literalToString(lit, type, dexNode.root().getStringUtils());\n+\tpublic static String literalToString(long lit, ArgType type, IDexNode dexNode, boolean fallback) {\n+\t\treturn literalToString(lit, type, dexNode.root().getStringUtils(), fallback);\n \t}\n \n-\tpublic static String literalToString(long lit, ArgType type, StringUtils stringUtils) {\n+\tpublic static String literalToString(long lit, ArgType type, StringUtils stringUtils, boolean fallback) {\n \t\tif (type == null || !type.isTypeKnown()) {\n \t\t\tString n = Long.toString(lit);\n-\t\t\tif (Math.abs(lit) > 100) {\n+\t\t\tif (fallback && Math.abs(lit) > 100) {\n \t\t\t\tStringBuilder sb = new StringBuilder();\n \t\t\t\tsb.append(n).append(\"(0x\").append(Long.toHexString(lit));\n \t\t\t\tif (type == null || type.contains(PrimitiveType.FLOAT)) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java\n@@ -70,7 +70,7 @@ public boolean equals(Object o) {\n \t@Override\n \tpublic String toString() {\n \t\ttry {\n-\t\t\tString value = TypeGen.literalToString(literal, getType(), DEF_STRING_UTILS);\n+\t\t\tString value = TypeGen.literalToString(literal, getType(), DEF_STRING_UTILS, true);\n \t\t\tif (getType().equals(ArgType.BOOLEAN) && (value.equals(\"true\") || value.equals(\"false\"))) {\n \t\t\t\treturn value;\n \t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java\n@@ -5,11 +5,15 @@\n \n import org.jetbrains.annotations.Nullable;\n \n+import com.android.dx.rop.code.AccessFlags;\n+\n import jadx.core.codegen.TypeGen;\n import jadx.core.deobf.NameMapper;\n import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.EnumClassAttr;\n import jadx.core.dex.attributes.nodes.EnumClassAttr.EnumField;\n+import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.info.MethodInfo;\n@@ -41,6 +45,11 @@ public class EnumVisitor extends AbstractVisitor {\n \t@Override\n \tpublic boolean visit(ClassNode cls) throws JadxException {\n \t\tif (!cls.isEnum()) {\n+\t\t\tAccessInfo accessFlags = cls.getAccessFlags();\n+\t\t\tif (accessFlags.isEnum()) {\n+\t\t\t\tcls.setAccessFlags(accessFlags.remove(AccessFlags.ACC_ENUM));\n+\t\t\t\tcls.addAttr(AType.COMMENTS, \"'enum' access flag removed\");\n+\t\t\t}\n \t\t\treturn true;\n \t\t}\n \t\t// search class init method\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n@@ -28,7 +28,7 @@ public void visit(MethodNode mth) {\n \t\t\treturn;\n \t\t}\n \t\tint newVisFlag = fixVisibility(mth);\n-\t\tif (newVisFlag != 0) {\n+\t\tif (newVisFlag != -1) {\n \t\t\tchangeVisibility(mth, newVisFlag);\n \t\t}\n \t}\n@@ -38,7 +38,7 @@ public static void changeVisibility(ICodeNode node, int newVisFlag) {\n \t\tAccessInfo newAccFlags = accessFlags.changeVisibility(newVisFlag);\n \t\tif (newAccFlags != accessFlags) {\n \t\t\tnode.setAccessFlags(newAccFlags);\n-\t\t\tnode.addAttr(AType.COMMENTS, \"access modifiers changed from: \" + accessFlags.rawString());\n+\t\t\tnode.addAttr(AType.COMMENTS, \"access modifiers changed from: \" + accessFlags.getVisibility().rawString());\n \t\t}\n \t}\n \n@@ -52,9 +52,15 @@ private static int fixVisibility(MethodNode mth) {\n \t\t\t\t// make abstract methods public\n \t\t\t\treturn AccessFlags.ACC_PUBLIC;\n \t\t\t}\n+\t\t\t// enum constructor can't be public\n+\t\t\tif (accessFlags.isConstructor()\n+\t\t\t\t\t&& accessFlags.isPublic()\n+\t\t\t\t\t&& mth.getParentClass().isEnum()) {\n+\t\t\t\treturn 0;\n+\t\t\t}\n \t\t\tif (accessFlags.isConstructor() || accessFlags.isStatic()) {\n \t\t\t\t// TODO: make public if used outside\n-\t\t\t\treturn 0;\n+\t\t\t\treturn -1;\n \t\t\t}\n \t\t\t// make other direct methods private\n \t\t\treturn AccessFlags.ACC_PRIVATE;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n@@ -103,7 +103,9 @@ private static boolean checkForIndexedLoop(MethodNode mth, LoopRegion loopRegion\n \t\t}\n \t\tRegisterArg initArg = phiInsn.getArg(0);\n \t\tInsnNode initInsn = initArg.getAssignInsn();\n-\t\tif (initInsn == null || initArg.getSVar().getUseCount() != 1) {\n+\t\tif (initInsn == null\n+\t\t\t\t|| initInsn.contains(AFlag.DONT_GENERATE)\n+\t\t\t\t|| initArg.getSVar().getUseCount() != 1) {\n \t\t\treturn false;\n \t\t}\n \t\tif (!usedOnlyInLoop(mth, loopRegion, arg)) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums3.java b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums3.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums3.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnums3.java\n@@ -44,6 +44,6 @@ public void test() {\n \t\tassertThat(code, containsOne(\"ONE(1)\"));\n \t\t// assertThat(code, containsOne(\"THREE(three)\"));\n \t\t// assertThat(code, containsOne(\"assertTrue(Numbers.ONE.getNum() == 1);\"));\n-\t\tassertThat(code, containsOne(\"private Numbers(int n) {\"));\n+\t\tassertThat(code, containsOne(\"Numbers(int n) {\"));\n \t}\n }",
    "output": "Fix improve generated code on errors"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/NameGen.java b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n@@ -1,6 +1,6 @@\n package jadx.core.codegen;\n \n-import java.util.LinkedHashSet;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -30,7 +30,7 @@ public class NameGen {\n \n \tprivate static final Map<String, String> OBJ_ALIAS;\n \n-\tprivate final Set<String> varNames = new LinkedHashSet<>();\n+\tprivate final Set<String> varNames = new HashSet<>();\n \tprivate final MethodNode mth;\n \tprivate final boolean fallback;\n \n@@ -67,6 +67,8 @@ private void addNamesUsedInClass() {\n \t\tfor (ClassNode innerClass : parentClass.getInnerClasses()) {\n \t\t\tvarNames.add(innerClass.getAlias().getShortName());\n \t\t}\n+\t\t// add all root package names to avoid collisions with full class names\n+\t\tvarNames.addAll(mth.root().getCacheStorage().getRootPkgs());\n \t}\n \n \tpublic String assignArg(CodeVar var) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -19,6 +19,7 @@\n import jadx.core.dex.info.InfoStorage;\n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.visitors.typeinference.TypeUpdate;\n+import jadx.core.utils.CacheStorage;\n import jadx.core.utils.ErrorsCounter;\n import jadx.core.utils.StringUtils;\n import jadx.core.utils.android.AndroidResourcesUtils;\n@@ -36,6 +37,7 @@ public class RootNode {\n \tprivate final StringUtils stringUtils;\n \tprivate final ConstStorage constValues;\n \tprivate final InfoStorage infoStorage = new InfoStorage();\n+\tprivate final CacheStorage cacheStorage = new CacheStorage();\n \tprivate final TypeUpdate typeUpdate;\n \n \tprivate ClspGraph clsp;\n@@ -222,6 +224,10 @@ public InfoStorage getInfoStorage() {\n \t\treturn infoStorage;\n \t}\n \n+\tpublic CacheStorage getCacheStorage() {\n+\t\treturn cacheStorage;\n+\t}\n+\n \tpublic JadxArgs getArgs() {\n \t\treturn args;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -67,9 +67,7 @@ private void checkClasses(RootNode root, JadxArgs args) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif (args.isRenameValid()) {\n-\t\t\tcheckFieldsCollisionWithRootPackage(classes);\n-\t\t}\n+\t\tprocessRootPackages(root, classes);\n \t}\n \n \tprivate void checkClassName(ClassNode cls, JadxArgs args) {\n@@ -140,12 +138,17 @@ private void checkMethods(ClassNode cls, JadxArgs args) {\n \t\t}\n \t}\n \n-\tprivate void checkFieldsCollisionWithRootPackage(List<ClassNode> classes) {\n+\tprivate void processRootPackages(RootNode root, List<ClassNode> classes) {\n \t\tSet<String> rootPkgs = collectRootPkgs(classes);\n-\t\tfor (ClassNode cls : classes) {\n-\t\t\tfor (FieldNode field : cls.getFields()) {\n-\t\t\t\tif (rootPkgs.contains(field.getAlias())) {\n-\t\t\t\t\tdeobfuscator.forceRenameField(field);\n+\t\troot.getCacheStorage().setRootPkgs(rootPkgs);\n+\n+\t\tif (root.getArgs().isRenameValid()) {\n+\t\t\t// rename field if collide with any root package\n+\t\t\tfor (ClassNode cls : classes) {\n+\t\t\t\tfor (FieldNode field : cls.getFields()) {\n+\t\t\t\t\tif (rootPkgs.contains(field.getAlias())) {\n+\t\t\t\t\t\tdeobfuscator.forceRenameField(field);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/CacheStorage.java b/jadx-core/src/main/java/jadx/core/utils/CacheStorage.java\n--- a/jadx-core/src/main/java/jadx/core/utils/CacheStorage.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/CacheStorage.java\n@@ -0,0 +1,17 @@\n+package jadx.core.utils;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+public class CacheStorage {\n+\n+\tprivate Set<String> rootPkgs = Collections.emptySet();\n+\n+\tpublic Set<String> getRootPkgs() {\n+\t\treturn rootPkgs;\n+\t}\n+\n+\tpublic void setRootPkgs(Set<String> rootPkgs) {\n+\t\tthis.rootPkgs = rootPkgs;\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/TestLocalVarCollideWithPackage.java b/jadx-core/src/test/java/jadx/tests/integration/names/TestLocalVarCollideWithPackage.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/TestLocalVarCollideWithPackage.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestLocalVarCollideWithPackage.java\n@@ -0,0 +1,71 @@\n+package jadx.tests.integration.names;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.not;\n+\n+public class TestLocalVarCollideWithPackage extends SmaliTest {\n+\t//@formatter:off\n+\t/*\n+\t\t-----------------------------------------------------------\n+\t\tpackage first;\n+\n+\t\timport pkg.Second;\n+\n+\t\tpublic class A {\n+\t\t\tpublic String test() {\n+\t\t\t\tSecond second = new Second();\n+\t\t\t\tsecond.A.call(); // collision\n+\t\t\t\treturn second.str;\n+\t\t\t}\n+\t\t}\n+\t\t-----------------------------------------------------------\n+\t\tpackage pkg;\n+\n+\t\tpublic class Second {\n+\t\t\tpublic String str;\n+\t\t}\n+\t\t-----------------------------------------------------------\n+\t\tpackage second;\n+\n+\t\tpublic class A {\n+\t\t}\n+\t\t-----------------------------------------------------------\n+\t*/\n+\t//@formatter:on\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tList<ClassNode> clsList = loadFromSmaliFiles();\n+\t\tClassNode firstA = searchCls(clsList, \"first.A\");\n+\t\tString code = firstA.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"second.A.call();\"));\n+\t\tassertThat(code, not(containsString(\"Second second = new Second();\")));\n+\t}\n+\n+\t@Test\n+\tpublic void testNoDebug() {\n+\t\tnoDebugInfo();\n+\t\tloadFromSmaliFiles();\n+\t}\n+\n+\t@Test\n+\tpublic void testWithoutImports() {\n+\t\tgetArgs().setUseImports(false);\n+\t\tloadFromSmaliFiles();\n+\t}\n+\n+\t@Test\n+\tpublic void testWithDeobfuscation() {\n+\t\tenableDeobfuscation();\n+\t\tloadFromSmaliFiles();\n+\t}\n+}",
    "output": "Fix avoid local variables collision with full class names"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -1,7 +1,6 @@\n package jadx.api;\n \n import java.io.File;\n-import java.io.IOException;\n import java.io.StringWriter;\n import java.nio.file.Path;\n import java.util.ArrayList;\n@@ -35,6 +34,7 @@\n import jadx.core.dex.visitors.IDexTreeVisitor;\n import jadx.core.dex.visitors.SaveCode;\n import jadx.core.export.ExportGradleProject;\n+import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.core.utils.files.InputFile;\n import jadx.core.xmlgen.BinaryXMLParser;\n@@ -308,8 +308,7 @@ void processClass(ClassNode cls) {\n \n \tvoid generateSmali(ClassNode cls) {\n \t\tPath path = cls.dex().getDexFile().getPath();\n-\t\tString className = cls.getAlias().makeRawFullName();\n-\t\tclassName = 'L' + className.replace('.', '/') + ';';\n+\t\tString className = Utils.makeQualifiedObjectName(cls.getClassInfo().getType().getObject());\n \t\ttry {\n \t\t\tDexBackedDexFile dexFile = DexFileFactory.loadDexFile(path.toFile(), Opcodes.getDefault());\n \t\t\tboolean decompiled = false;\n@@ -326,7 +325,7 @@ void generateSmali(ClassNode cls) {\n \t\t\tif (!decompiled) {\n \t\t\t\tLOG.error(\"Failed to find smali class {}\", className);\n \t\t\t}\n-\t\t} catch (IOException e) {\n+\t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Error generating smali\", e);\n \t\t}\n \t}",
    "output": "Fix search smali class by original name"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java\n@@ -46,6 +46,7 @@ public InvokeType getInvokeType() {\n \t\treturn type;\n \t}\n \n+\t@Override\n \tpublic MethodInfo getCallMth() {\n \t\treturn mth;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n@@ -81,6 +81,7 @@ void setSVar(@NotNull SSAVar sVar) {\n \t\t}\n \t}\n \n+\t@Override\n \tpublic String getName() {\n \t\tif (isThis()) {\n \t\t\treturn THIS_ARG_NAME;\n@@ -91,6 +92,7 @@ public String getName() {\n \t\treturn sVar.getName();\n \t}\n \n+\t@Override\n \tpublic void setName(String name) {\n \t\tif (sVar != null && name != null) {\n \t\t\tsVar.setName(name);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/ITypeBound.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/ITypeBound.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/ITypeBound.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/ITypeBound.java\n@@ -1,9 +1,15 @@\n package jadx.core.dex.visitors.typeinference;\n \n+import org.jetbrains.annotations.Nullable;\n+\n import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.instructions.args.RegisterArg;\n \n public interface ITypeBound {\n \tBoundEnum getBound();\n \n \tArgType getType();\n+\n+\t@Nullable\n+\tRegisterArg getArg();\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundConst.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundConst.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundConst.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeBoundConst.java\n@@ -3,14 +3,22 @@\n import java.util.Objects;\n \n import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.instructions.args.RegisterArg;\n \n public final class TypeBoundConst implements ITypeBound {\n \tprivate final BoundEnum bound;\n \tprivate final ArgType type;\n+\tprivate final RegisterArg arg;\n+\n \n \tpublic TypeBoundConst(BoundEnum bound, ArgType type) {\n+\t\tthis(bound, type, null);\n+\t}\n+\n+\tpublic TypeBoundConst(BoundEnum bound, ArgType type, RegisterArg arg) {\n \t\tthis.bound = bound;\n \t\tthis.type = type;\n+\t\tthis.arg = arg;\n \t}\n \n \t@Override\n@@ -23,6 +31,11 @@ public ArgType getType() {\n \t\treturn type;\n \t}\n \n+\t@Override\n+\tpublic RegisterArg getArg() {\n+\t\treturn arg;\n+\t}\n+\n \t@Override\n \tpublic boolean equals(Object o) {\n \t\tif (this == o) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -21,6 +21,7 @@\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.PhiInsn;\n import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.instructions.args.CodeVar;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.LiteralArg;\n import jadx.core.dex.instructions.args.PrimitiveType;\n@@ -81,7 +82,11 @@ public void visit(MethodNode mth) {\n \t\t\t\tresolved = false;\n \t\t\t}\n \t\t}\n-\t\tif (!resolved) {\n+\t\tif (resolved) {\n+\t\t\tfor (SSAVar var : new ArrayList<>(mth.getSVars())) {\n+\t\t\t\tprocessIncompatiblePrimitives(mth, var);\n+\t\t\t}\n+\t\t} else {\n \t\t\tfor (SSAVar var : new ArrayList<>(mth.getSVars())) {\n \t\t\t\ttryInsertAdditionalInsn(mth, var);\n \t\t\t}\n@@ -249,7 +254,7 @@ private ITypeBound makeUseBound(RegisterArg regArg) {\n \t\tif (insn == null) {\n \t\t\treturn null;\n \t\t}\n-\t\treturn new TypeBoundConst(BoundEnum.USE, regArg.getInitType());\n+\t\treturn new TypeBoundConst(BoundEnum.USE, regArg.getInitType(), regArg);\n \t}\n \n \tprivate boolean tryPossibleTypes(SSAVar var, ArgType type) {\n@@ -375,4 +380,39 @@ private boolean tryWiderObjects(MethodNode mth, SSAVar var) {\n \t\t}\n \t\treturn false;\n \t}\n+\n+\tprivate void processIncompatiblePrimitives(MethodNode mth, SSAVar var) {\n+\t\tif (var.getAssign().getType() == ArgType.BOOLEAN) {\n+\t\t\t for (ITypeBound bound : var.getTypeInfo().getBounds()) {\n+\t\t\t\t if (bound.getBound() == BoundEnum.USE\n+\t\t\t\t\t\t && bound.getType().isPrimitive() && bound.getType() != ArgType.BOOLEAN) {\n+\t\t\t\t\t InsnNode insn = bound.getArg().getParentInsn();\n+\t\t\t\t\t if (insn.getType() == InsnType.CAST) {\n+\t\t\t\t\t\t continue;\n+\t\t\t\t\t };\n+\n+\t\t\t\t\t IndexInsnNode castNode = new IndexInsnNode(InsnType.CAST, bound.getType(), 1);\n+\t\t\t\t\t castNode.addArg(bound.getArg());\n+\t\t\t\t\t castNode.setResult(InsnArg.reg(bound.getArg().getRegNum(), bound.getType()));\n+\n+\t\t\t\t\t SSAVar newVar = mth.makeNewSVar(castNode.getResult().getRegNum(), castNode.getResult());\n+\t\t\t\t\t CodeVar codeVar = new CodeVar();\n+\t\t\t\t\t codeVar.setType(bound.getType());\n+\t\t\t\t\t newVar.setCodeVar(codeVar);\n+\t\t\t\t\t newVar.getTypeInfo().setType(bound.getType());\n+\n+\t\t\t\t\t for (int i = insn.getArgsCount() - 1; i >= 0; i--) {\n+\t\t\t\t\t\t if (insn.getArg(i) == bound.getArg()) {\n+\t\t\t\t\t\t\t insn.setArg(i, castNode.getResult().duplicate());\n+\t\t\t\t\t\t\t break;\n+\t\t\t\t\t\t }\n+\t\t\t\t\t }\n+\n+\t\t\t\t\t BlockNode blockNode = BlockUtils.getBlockByInsn(mth, insn);\n+\t\t\t\t\t List<InsnNode> insnList = blockNode.getInstructions();\n+\t\t\t\t\t insnList.add(insnList.indexOf(insn), castNode);\n+\t\t\t\t }\n+\t\t\t }\n+\t\t}\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToInt.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToInt.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToInt.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBooleanToInt.java\n@@ -5,26 +5,24 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.tests.api.SmaliTest;\n \n-public class TestBooleanToInt2 extends SmaliTest {\n+public class TestBooleanToInt extends SmaliTest {\n \n \t/**\n     \tprivate boolean showConsent;\n \n     \tpublic void write(int b) {\n     \t}\n \n-    \tpublic void writeToParcel(TestBooleanToInt2 testBooleanToInt2) {\n-        \ttestBooleanToInt2.write(this.showConsent ? 1 : 0);\n+    \tpublic void writeToParcel(TestBooleanToInt testBooleanToInt) {\n+        \ttestBooleanToInt.write(this.showConsent ? 1 : 0);\n     \t}\n \t */\n \t@Test\n-\t@NotYetImplemented\n \tpublic void test() {\n-\t\tClassNode cls = getClassNodeFromSmaliWithPath(\"conditions\", \"TestBooleanToInt2\");\n+\t\tClassNode cls = getClassNodeFromSmaliWithPath(\"conditions\", \"TestBooleanToInt\");\n \t\tString code = cls.getCode().toString();\n \n \t\tassertThat(code, containsString(\"write(this.showConsent ? 1 : 0);\"));",
    "output": "Fix byte to number without cast"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -967,6 +967,7 @@ private void closeWindow() {\n \t\tsettings.setMainWindowExtendedState(getExtendedState());\n \t\tcancelBackgroundJobs();\n \t\tdispose();\n+\t\tSystem.exit(0);\n \t}\n \n \tpublic JadxWrapper getWrapper() {",
    "output": "Fix closing jadx main window terminates JVM"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java\n--- a/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java\n+++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java\n@@ -168,7 +168,7 @@ void save(Path path) throws IOException {\n \t\t\t\tsave(outputStream);\n \t\t\t}\n \t\t} else if (outputName.endsWith(\".jar\")) {\n-\t\t\tPath temp = Files.createTempFile(\"jadx\", \".zip\");\n+\t\t\tPath temp = FileUtils.createTempFile(\".zip\");\n \t\t\tFiles.copy(path, temp, StandardCopyOption.REPLACE_EXISTING);\n \n \t\t\ttry (ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(path));\n@@ -185,8 +185,6 @@ void save(Path path) throws IOException {\n \t\t\t\t\tentry = in.getNextEntry();\n \t\t\t\t}\n \t\t\t}\n-\t\t\tFiles.delete(temp);\n-\n \t\t} else {\n \t\t\tthrow new JadxRuntimeException(\"Unknown file format: \" + outputName);\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n@@ -65,24 +65,13 @@ public static void makeDirs(@Nullable File dir) {\n \t\t}\n \t}\n \n-\tpublic static File createTempFile(String suffix) {\n-\t\tFile temp;\n+\tpublic static Path createTempFile(String suffix) {\n \t\ttry {\n-\t\t\ttemp = File.createTempFile(\"jadx-tmp-\", System.nanoTime() + '-' + suffix);\n-\t\t\ttemp.deleteOnExit();\n-\t\t} catch (IOException e) {\n-\t\t\tthrow new JadxRuntimeException(\"Failed to create temp file with suffix: \" + suffix);\n-\t\t}\n-\t\treturn temp;\n-\t}\n-\n-\tpublic static File createTempDir(String suffix) {\n-\t\ttry {\n-\t\t\tPath path = Files.createTempDirectory(\"jadx-tmp-\" + System.nanoTime() + '-' + suffix);\n+\t\t\tPath path = Files.createTempFile(\"jadx-tmp-\", suffix);\n \t\t\tpath.toFile().deleteOnExit();\n-\t\t\treturn path.toFile();\n+\t\t\treturn path;\n \t\t} catch (IOException e) {\n-\t\t\tthrow new JadxRuntimeException(\"Failed to create temp directory with suffix: \" + suffix);\n+\t\t\tthrow new JadxRuntimeException(\"Failed to create temp file with suffix: \" + suffix);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n@@ -4,9 +4,9 @@\n import static jadx.core.utils.files.FileUtils.isZipDexFile;\n \n import java.io.File;\n-import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.OutputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.StandardCopyOption;\n@@ -58,7 +58,7 @@ private void searchDexFiles(boolean skipSources) throws IOException, DecodeExcep\n \t\t\treturn;\n \t\t}\n \t\tif (fileName.endsWith(\".smali\")) {\n-\t\t\tPath output = Files.createTempFile(\"jadx\", \".dex\");\n+\t\t\tPath output = FileUtils.createTempFile(\".dex\");\n \t\t\tSmaliOptions options = new SmaliOptions();\n \t\t\toptions.outputDexFile = output.toAbsolutePath().toString();\n \t\t\tSmali.assemble(options, file.getAbsolutePath());\n@@ -134,7 +134,7 @@ private boolean loadFromZip(String ext) throws IOException, DecodeException {\n \n \t\t\t\t\t\t\tcase \".jar\":\n \t\t\t\t\t\t\t\tindex++;\n-\t\t\t\t\t\t\t\tPath jarFile = Files.createTempFile(entryName, \".jar\");\n+\t\t\t\t\t\t\t\tPath jarFile = FileUtils.createTempFile(entryName);\n \t\t\t\t\t\t\t\tFiles.copy(inputStream, jarFile, StandardCopyOption.REPLACE_EXISTING);\n \t\t\t\t\t\t\t\tfor (Dex dex : loadFromJar(jarFile)) {\n \t\t\t\t\t\t\t\t\taddDexFile(entryName, dex);\n@@ -145,11 +145,11 @@ private boolean loadFromZip(String ext) throws IOException, DecodeException {\n \t\t\t\t\t\t\t\tthrow new JadxRuntimeException(\"Unexpected extension in zip: \" + ext);\n \t\t\t\t\t\t}\n \t\t\t\t\t} else if (entryName.equals(\"instant-run.zip\") && ext.equals(\".dex\")) {\n-\t\t\t\t\t\tFile jarFile = FileUtils.createTempFile(\"instant-run.zip\");\n-\t\t\t\t\t\ttry (FileOutputStream fos = new FileOutputStream(jarFile)) {\n+\t\t\t\t\t\tPath jarFile = FileUtils.createTempFile(\"instant-run.zip\");\n+\t\t\t\t\t\ttry (OutputStream fos = Files.newOutputStream(jarFile)) {\n \t\t\t\t\t\t\tIOUtils.copy(inputStream, fos);\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tInputFile tempFile = new InputFile(jarFile);\n+\t\t\t\t\t\tInputFile tempFile = new InputFile(jarFile.toFile());\n \t\t\t\t\t\ttempFile.loadFromZip(ext);\n \t\t\t\t\t\tList<DexFile> dexFiles = tempFile.getDexFiles();\n \t\t\t\t\t\tif (!dexFiles.isEmpty()) {\n@@ -196,7 +196,7 @@ private static List<Dex> loadFromJar(Path jar) throws DecodeException {\n \t}\n \n \tprivate static List<Dex> loadFromClassFile(File file) throws IOException, DecodeException {\n-\t\tPath outFile = Files.createTempFile(\"cls\", \".jar\");\n+\t\tPath outFile = FileUtils.createTempFile(\".jar\");\n \t\ttry (JarOutputStream jo = new JarOutputStream(Files.newOutputStream(outFile))) {\n \t\t\tString clsName = AsmUtils.getNameFromClassFile(file);\n \t\t\tif (clsName == null || !ZipSecurity.isValidZipEntryName(clsName)) {\n\ndiff --git a/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java\n--- a/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java\n+++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java\n@@ -66,7 +66,7 @@ private void checkOutDirs(String outDir, String srcDir, String resDir) {\n \n \tprivate JadxArgs makeArgs() {\n \t\tJadxArgs args = new JadxArgs();\n-\t\targs.getInputFiles().add(FileUtils.createTempFile(\"some.apk\"));\n+\t\targs.getInputFiles().add(FileUtils.createTempFile(\"some.apk\").toFile());\n \t\treturn args;\n \t}\n }",
    "output": "Fix always use FileUtils.createTempFile"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -762,7 +762,10 @@ private boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnAr\n \t\t\t}\n \t\t}\n \t\tArgType argType = arg.getType();\n-\t\tif (argType.equals(origType)) {\n+\t\tif (argType.equals(origType)\n+\t\t\t\t// null cast to object\n+\t\t\t\t&& (!arg.isLiteral() || ((LiteralArg) arg).getLiteral() != 0\n+\t\t\t\t\t\t|| (!argType.isArray() && !argType.isObject()))) {\n \t\t\treturn false;\n \t\t}\n \t\tif (origType.isGeneric()) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestCastOfNull.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestCastOfNull.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestCastOfNull.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestCastOfNull.java\n@@ -0,0 +1,35 @@\n+package jadx.tests.integration.others;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.NotYetImplemented;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+public class TestCastOfNull extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic void test() {\n+\t\t\tm((long[]) null);\n+\t\t\tm((String) null);\n+\t\t}\n+\n+\t\tpublic void m(long[] a) {\n+\t\t}\n+\t\tpublic void m(String s) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"m((long[]) null);\"));\n+\t\tassertThat(code, containsOne(\"m((String) null);\"));\n+\t}\n+}",
    "output": "Add cast for null in overloaded methods"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n@@ -9,6 +9,7 @@\n import java.io.InputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.List;\n@@ -134,7 +135,7 @@ private boolean loadFromZip(String ext) throws IOException, DecodeException {\n \t\t\t\t\t\t\tcase \".jar\":\n \t\t\t\t\t\t\t\tindex++;\n \t\t\t\t\t\t\t\tPath jarFile = Files.createTempFile(entryName, \".jar\");\n-\t\t\t\t\t\t\t\tFiles.copy(inputStream, jarFile);\n+\t\t\t\t\t\t\t\tFiles.copy(inputStream, jarFile, StandardCopyOption.REPLACE_EXISTING);\n \t\t\t\t\t\t\t\tfor (Dex dex : loadFromJar(jarFile)) {\n \t\t\t\t\t\t\t\t\taddDexFile(entryName, dex);\n \t\t\t\t\t\t\t\t}",
    "output": "Fix loading aar/jar files"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n@@ -78,13 +78,26 @@ public void addTreeExpansion(String[] expansion) {\n \n \tpublic void removeTreeExpansion(String[] expansion) {\n \t\tfor (Iterator<String[]> it = treeExpansions.iterator(); it.hasNext(); ) {\n-\t\t\tif (Arrays.equals(it.next(), expansion)) {\n+\t\t\tif (isParentOfExpansion(expansion, it.next())) {\n \t\t\t\tit.remove();\n \t\t\t}\n \t\t}\n \t\tchanged();\n \t}\n \n+\tprivate boolean isParentOfExpansion(String[] parent, String[] child) {\n+\t\tif (Arrays.equals(parent, child)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tfor (int i = child.length - parent.length; i > 0; i--) {\n+\t\t\tString[] arr = Arrays.copyOfRange(child, i, child.length);\n+\t\t\tif (Arrays.equals(parent, arr)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tprivate void changed() {\n \t\tif (settings.isAutoSaveProject()) {\n \t\t\tsave();",
    "output": "Remove tree children expansions as well"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java\n@@ -4,6 +4,7 @@\n import java.util.LinkedList;\n import java.util.Queue;\n \n+import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.instructions.ArithNode;\n import jadx.core.dex.instructions.IfOp;\n import jadx.core.dex.instructions.InsnType;\n@@ -155,7 +156,7 @@ private void addAndOr(CodeWriter code, CondStack stack, IfCondition condition) t\n \t}\n \n \tprivate boolean isWrapNeeded(IfCondition condition) {\n-\t\tif (condition.isCompare()) {\n+\t\tif (condition.isCompare() || condition.contains(AFlag.DONT_WRAP)) {\n \t\t\treturn false;\n \t\t}\n \t\treturn condition.getMode() != Mode.NOT;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n--- a/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n@@ -8,6 +8,9 @@\n import java.util.List;\n import java.util.Objects;\n \n+import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.attributes.AttributeStorage;\n+import jadx.core.dex.attributes.EmptyAttrStorage;\n import jadx.core.dex.instructions.ArithNode;\n import jadx.core.dex.instructions.ArithOp;\n import jadx.core.dex.instructions.IfNode;\n@@ -31,6 +34,10 @@ public enum Mode {\n \t\tOR\n \t}\n \n+\tprivate static final AttributeStorage EMPTY_ATTR_STORAGE = new EmptyAttrStorage();\n+\n+\tprivate AttributeStorage storage = EMPTY_ATTR_STORAGE;\n+\n \tprivate final Mode mode;\n \tprivate final List<IfCondition> args;\n \tprivate final Compare compare;\n@@ -262,6 +269,23 @@ public List<RegisterArg> getRegisterArgs() {\n \t\treturn list;\n \t}\n \n+\tpublic void add(AFlag flag) {\n+\t\tinitStorage().add(flag);\n+\t}\n+\n+\tpublic boolean contains(AFlag flag) {\n+\t\treturn storage.contains(flag);\n+\t}\n+\n+\tprivate AttributeStorage initStorage() {\n+\t\tAttributeStorage store = storage;\n+\t\tif (store == EMPTY_ATTR_STORAGE) {\n+\t\t\tstore = new AttributeStorage();\n+\t\t\tstorage = store;\n+\t\t}\n+\t\treturn store;\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\tswitch (mode) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java\n@@ -11,9 +11,12 @@\n import jadx.core.dex.instructions.args.InsnWrapArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n import jadx.core.dex.instructions.mods.ConstructorInsn;\n+import jadx.core.dex.instructions.mods.TernaryInsn;\n import jadx.core.dex.nodes.BlockNode;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.dex.regions.conditions.IfCondition;\n+import jadx.core.dex.regions.conditions.IfCondition.Mode;\n import jadx.core.dex.visitors.regions.variables.ProcessVariables;\n import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;\n import jadx.core.utils.exceptions.JadxException;\n@@ -104,7 +107,7 @@ private static void removeParenthesis(BlockNode block) {\n \t}\n \n \t/**\n-\t * Remove parenthesis for wrapped insn  in arith '+' or '-'\n+\t * Remove parenthesis for wrapped insn in arith '+' or '-'\n \t * ('(a + b) +c' => 'a + b + c')\n \t */\n \tprivate static void removeParenthesis(InsnNode insn) {\n@@ -124,6 +127,9 @@ private static void removeParenthesis(InsnNode insn) {\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n+\t\t\tif (insn.getType() == InsnType.TERNARY) {\n+\t\t\t\tremoveParenthesis(((TernaryInsn) insn).getCondition());\n+\t\t\t}\n \t\t\tfor (InsnArg arg : insn.getArguments()) {\n \t\t\t\tif (arg.isInsnWrap()) {\n \t\t\t\t\tInsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();\n@@ -133,6 +139,15 @@ private static void removeParenthesis(InsnNode insn) {\n \t\t}\n \t}\n \n+\tprivate static void removeParenthesis(IfCondition cond) {\n+\t\tMode mode = cond.getMode();\n+\t\tfor (IfCondition c : cond.getArgs()) {\n+\t\t\tif (c.getMode() == mode) {\n+\t\t\t\tc.add(AFlag.DONT_WRAP);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t/**\n \t * Replace arithmetic operation with short form\n \t * ('a = a + 2' => 'a += 2')\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions16.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions16.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions16.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions16.java\n@@ -2,7 +2,6 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.tests.api.IntegrationTest;\n \n@@ -27,19 +26,10 @@ public void check() {\n \t}\n \n \t@Test\n-\t@NotYetImplemented\n \tpublic void test() {\n \t\tClassNode cls = getClassNode(TestCls.class);\n \t\tString code = cls.getCode().toString();\n \n \t\tassertThat(code, containsOne(\"return a < 0 || (b % 2 != 0 && a > 28) || b < 0;\"));\n \t}\n-\n-\t@Test\n-\tpublic void test2() {\n-\t\tClassNode cls = getClassNode(TestCls.class);\n-\t\tString code = cls.getCode().toString();\n-\n-\t\tassertThat(code, containsOne(\"return a < 0 || ((b % 2 != 0 && a > 28) || b < 0);\"));\n-\t}\n }",
    "output": "Remove redundant cast over similar conditions"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n--- a/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n@@ -12,6 +12,7 @@\n import jadx.core.dex.instructions.ArithOp;\n import jadx.core.dex.instructions.IfNode;\n import jadx.core.dex.instructions.IfOp;\n+import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnWrapArg;\n import jadx.core.dex.instructions.args.LiteralArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n@@ -221,21 +222,23 @@ private static IfCondition simplifyCmpOp(Compare c) {\n \t\t\t\tbreak;\n \n \t\t\tcase ARITH:\n-\t\t\t\tArithOp arithOp = ((ArithNode) wrapInsn).getOp();\n-\t\t\t\tif (arithOp == ArithOp.OR || arithOp == ArithOp.AND) {\n-\t\t\t\t\tIfOp ifOp = c.getInsn().getOp();\n-\t\t\t\t\tboolean isTrue = ifOp == IfOp.NE && lit == 0\n+\t\t\t\tif (c.getB().getType() == ArgType.BOOLEAN) {\n+\t\t\t\t\tArithOp arithOp = ((ArithNode) wrapInsn).getOp();\n+\t\t\t\t\tif (arithOp == ArithOp.OR || arithOp == ArithOp.AND) {\n+\t\t\t\t\t\tIfOp ifOp = c.getInsn().getOp();\n+\t\t\t\t\t\tboolean isTrue = ifOp == IfOp.NE && lit == 0\n \t\t\t\t\t\t\t|| ifOp == IfOp.EQ && lit == 1;\n \n-\t\t\t\t\tIfOp op = isTrue ? IfOp.NE : IfOp.EQ;\n-\t\t\t\t\tMode mode = isTrue && arithOp == ArithOp.OR ||\n+\t\t\t\t\t\tIfOp op = isTrue ? IfOp.NE : IfOp.EQ;\n+\t\t\t\t\t\tMode mode = isTrue && arithOp == ArithOp.OR ||\n \t\t\t\t\t\t\t!isTrue && arithOp == ArithOp.AND ? Mode.OR : Mode.AND;\n \n-\t\t\t\t\tIfNode if1 = new IfNode(op, -1, wrapInsn.getArg(0), LiteralArg.FALSE);\n-\t\t\t\t\tIfNode if2 = new IfNode(op, -1, wrapInsn.getArg(1), LiteralArg.FALSE);\n-\t\t\t\t\treturn new IfCondition(mode,\n+\t\t\t\t\t\tIfNode if1 = new IfNode(op, -1, wrapInsn.getArg(0), LiteralArg.FALSE);\n+\t\t\t\t\t\tIfNode if2 = new IfNode(op, -1, wrapInsn.getArg(1), LiteralArg.FALSE);\n+\t\t\t\t\t\treturn new IfCondition(mode,\n \t\t\t\t\t\t\tArrays.asList(new IfCondition(new Compare(if1)),\n \t\t\t\t\t\t\t\t\tnew IfCondition(new Compare(if2))));\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\tbreak;\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions17.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions17.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions17.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions17.java\n@@ -0,0 +1,35 @@\n+package jadx.tests.integration.conditions;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+public class TestConditions17 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic static final int SOMETHING = 2;\n+\n+\t\tpublic static void test(int a) {\n+\t\t\tif ((a & SOMETHING) != 0) {\n+\t\t\t\tprint(1);\n+\t\t\t}\n+\t\t\tprint(2);\n+\t\t}\n+\n+\t\tpublic static void print(Object o) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\" & \"));\n+\t}\n+}",
    "output": "Fix bitwise or/and with non-boolean"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -1,9 +1,6 @@\n package jadx.gui.settings;\n \n-import java.awt.Font;\n-import java.awt.GraphicsDevice;\n-import java.awt.GraphicsEnvironment;\n-import java.awt.Window;\n+import java.awt.*;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.util.ArrayList;\n@@ -23,9 +20,9 @@\n import jadx.api.JadxArgs;\n import jadx.cli.JadxCLIArgs;\n import jadx.gui.ui.codearea.EditorTheme;\n+import jadx.gui.utils.FontUtils;\n import jadx.gui.utils.LangLocale;\n import jadx.gui.utils.NLS;\n-import jadx.gui.utils.Utils;\n \n public class JadxSettings extends JadxCLIArgs {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(JadxSettings.class);\n@@ -295,22 +292,21 @@ public Font getFont() {\n \t\tif (fontStr.isEmpty()) {\n \t\t\treturn DEFAULT_FONT;\n \t\t}\n-\t\treturn Font.decode(fontStr);\n+\t\ttry {\n+\t\t\treturn FontUtils.loadByStr(fontStr);\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.warn(\"Failed to load font: {}, reset to default\", fontStr, e);\n+\t\t\tsetFont(DEFAULT_FONT);\n+\t\t\treturn DEFAULT_FONT;\n+\t\t}\n \t}\n \n \tpublic void setFont(@Nullable Font font) {\n \t\tif (font == null) {\n \t\t\tthis.fontStr = \"\";\n-\t\t\treturn;\n-\t\t}\n-\t\tStringBuilder sb = new StringBuilder();\n-\t\tsb.append(font.getFontName());\n-\t\tString fontStyleName = Utils.getFontStyleName(font.getStyle()).replaceAll(\" \", \"\");\n-\t\tif (!fontStyleName.isEmpty()) {\n-\t\t\tsb.append('-').append(fontStyleName.toUpperCase());\n+\t\t} else {\n+\t\t\tthis.fontStr = FontUtils.convertToStr(font);\n \t\t}\n-\t\tsb.append('-').append(font.getSize());\n-\t\tthis.fontStr = sb.toString();\n \t}\n \n \tpublic String getEditorThemePath() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -14,6 +14,7 @@\n \n import jadx.gui.ui.MainWindow;\n import jadx.gui.ui.codearea.EditorTheme;\n+import jadx.gui.utils.FontUtils;\n import jadx.gui.utils.LangLocale;\n import jadx.gui.utils.NLS;\n import jadx.gui.utils.Utils;\n@@ -267,7 +268,7 @@ public void mouseClicked(MouseEvent e) {\n \n \tprivate String getFontLabelStr() {\n \t\tFont font = settings.getFont();\n-\t\tString fontStyleName = Utils.getFontStyleName(font.getStyle());\n+\t\tString fontStyleName = FontUtils.convertFontStyleToString(font.getStyle());\n \t\treturn NLS.str(\"preferences.font\") + \": \" + font.getFontName() + ' ' + fontStyleName + ' ' + font.getSize();\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -90,6 +90,7 @@\n import jadx.gui.update.JadxUpdate.IUpdateCallback;\n import jadx.gui.update.data.Release;\n import jadx.gui.utils.CacheObject;\n+import jadx.gui.utils.FontUtils;\n import jadx.gui.utils.JumpPosition;\n import jadx.gui.utils.Link;\n import jadx.gui.utils.NLS;\n@@ -154,7 +155,7 @@ public MainWindow(JadxSettings settings) {\n \t\tthis.cacheObject = new CacheObject();\n \n \t\tresetCache();\n-\t\tregisterBundledFonts();\n+\t\tFontUtils.registerBundledFonts();\n \t\tinitUI();\n \t\tinitMenuAndToolbar();\n \t\tUtils.setWindowIcons(this);\n@@ -931,13 +932,6 @@ public void setLocationAndPosition() {\n \t\tsetSize((int) (w * WINDOW_RATIO), (int) (h * WINDOW_RATIO));\n \t}\n \n-\tpublic static void registerBundledFonts() {\n-\t\tGraphicsEnvironment grEnv = GraphicsEnvironment.getLocalGraphicsEnvironment();\n-\t\tif (Utils.FONT_HACK != null) {\n-\t\t\tgrEnv.registerFont(Utils.FONT_HACK);\n-\t\t}\n-\t}\n-\n \tprivate void setEditorTheme(String editorThemePath) {\n \t\ttry {\n \t\t\teditorTheme = Theme.load(getClass().getResourceAsStream(editorThemePath));\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/FontUtils.java b/jadx-gui/src/main/java/jadx/gui/utils/FontUtils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/FontUtils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/FontUtils.java\n@@ -0,0 +1,88 @@\n+package jadx.gui.utils;\n+\n+import java.awt.*;\n+import java.io.InputStream;\n+\n+import javax.swing.text.StyleContext;\n+\n+import org.jetbrains.annotations.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import jadx.core.utils.exceptions.JadxRuntimeException;\n+\n+public class FontUtils {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(FontUtils.class);\n+\n+\tpublic static final Font FONT_HACK = openFontTTF(\"Hack-Regular\");\n+\n+\tpublic static void registerBundledFonts() {\n+\t\tGraphicsEnvironment grEnv = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+\t\tif (FontUtils.FONT_HACK != null) {\n+\t\t\tgrEnv.registerFont(FontUtils.FONT_HACK);\n+\t\t}\n+\t}\n+\n+\tpublic static Font loadByStr(String fontDesc) {\n+\t\tString[] parts = fontDesc.split(\"-\");\n+\t\tif (parts.length != 3) {\n+\t\t\tthrow new JadxRuntimeException(\"Unsupported font description format: \" + fontDesc);\n+\t\t}\n+\t\tString name = parts[0];\n+\t\tint style = parseFontStyle(parts[1]);\n+\t\tint size = Integer.parseInt(parts[2]);\n+\n+\t\tStyleContext sc = StyleContext.getDefaultStyleContext();\n+\t\tFont font = sc.getFont(name, style, size);\n+\t\tif (font == null) {\n+\t\t\tthrow new JadxRuntimeException(\"Font not found: \" + fontDesc);\n+\t\t}\n+\t\treturn font;\n+\t}\n+\n+\tpublic static String convertToStr(Font font) {\n+\t\treturn font.getFontName()\n+\t\t\t\t+ '-' + convertFontStyleToString(font.getStyle())\n+\t\t\t\t+ '-' + font.getSize();\n+\t}\n+\n+\tpublic static String convertFontStyleToString(int style) {\n+\t\tif (style == 0) {\n+\t\t\treturn \"plain\";\n+\t\t}\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tif ((style & Font.BOLD) != 0) {\n+\t\t\tsb.append(\"bold\");\n+\t\t}\n+\t\tif ((style & Font.ITALIC) != 0) {\n+\t\t\tsb.append(\" italic\");\n+\t\t}\n+\t\treturn sb.toString().trim();\n+\t}\n+\n+\tprivate static int parseFontStyle(String str) {\n+\t\tint style = 0;\n+\t\tif (str.contains(\"bold\")) {\n+\t\t\tstyle |= Font.BOLD;\n+\t\t}\n+\t\tif (str.contains(\"italic\")) {\n+\t\t\tstyle |= Font.ITALIC;\n+\t\t}\n+\t\treturn style;\n+\t}\n+\n+\t@Nullable\n+\tpublic static Font openFontTTF(String name) {\n+\t\tString fontPath = \"/fonts/\" + name + \".ttf\";\n+\t\ttry (InputStream is = Utils.class.getResourceAsStream(fontPath)) {\n+\t\t\tFont font = Font.createFont(Font.TRUETYPE_FONT, is);\n+\t\t\treturn font.deriveFont(12f);\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"Failed load font by path: {}\", fontPath, e);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprivate FontUtils() {\n+\t}\n+}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/Utils.java b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n@@ -28,8 +28,6 @@ public class Utils {\n \tprivate static final ImageIcon ICON_ABSTRACT = openIcon(\"abstract_co\");\n \tprivate static final ImageIcon ICON_NATIVE = openIcon(\"native_co\");\n \n-\tpublic static final Font FONT_HACK = openFontTTF(\"Hack-Regular\");\n-\n \t/**\n \t * The minimum about of memory in bytes we are trying to keep free, otherwise the application may run out of heap\n \t * which ends up in a Java garbage collector running \"amok\" (CPU utilization 100% for each core and the UI is\n@@ -60,18 +58,6 @@ public static Image openImage(String path) {\n \t\treturn Toolkit.getDefaultToolkit().createImage(resource);\n \t}\n \n-\t@Nullable\n-\tpublic static Font openFontTTF(String name) {\n-\t\tString fontPath = \"/fonts/\" + name + \".ttf\";\n-\t\ttry (InputStream is = Utils.class.getResourceAsStream(fontPath)) {\n-\t\t\tFont font = Font.createFont(Font.TRUETYPE_FONT, is);\n-\t\t\treturn font.deriveFont(12f);\n-\t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Failed load font by path: {}\", fontPath, e);\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\n \tpublic static void addKeyBinding(JComponent comp, KeyStroke key, String id, Action action) {\n \t\tcomp.getInputMap().put(key, id);\n \t\tcomp.getActionMap().put(id, action);\n@@ -180,21 +166,6 @@ public static void setClipboardString(String text) {\n \t\t}\n \t}\n \n-\t@NotNull\n-\tpublic static String getFontStyleName(int style) {\n-\t\tif (style == 0) {\n-\t\t\treturn \"plain\";\n-\t\t}\n-\t\tStringBuilder sb = new StringBuilder();\n-\t\tif ((style & Font.BOLD) != 0) {\n-\t\t\tsb.append(\"bold\");\n-\t\t}\n-\t\tif ((style & Font.ITALIC) != 0) {\n-\t\t\tsb.append(\" italic\");\n-\t\t}\n-\t\treturn sb.toString().trim();\n-\t}\n-\n \tpublic static void setWindowIcons(Window window) {\n \t\tList<Image> icons = new ArrayList<>();\n \t\ticons.add(Utils.openImage(\"/logos/jadx-logo-16px.png\"));",
    "output": "Use same font loader as code viewer"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -17,6 +17,7 @@\n import jadx.core.dex.instructions.ArithOp;\n import jadx.core.dex.instructions.CallMthInterface;\n import jadx.core.dex.instructions.ConstStringNode;\n+import jadx.core.dex.instructions.FilledNewArrayNode;\n import jadx.core.dex.instructions.IfNode;\n import jadx.core.dex.instructions.IndexInsnNode;\n import jadx.core.dex.instructions.InsnType;\n@@ -124,7 +125,7 @@ private static InsnNode simplifyInsn(MethodNode mth, InsnNode insn) {\n \t\t\t\tbreak;\n \n \t\t\tcase CONSTRUCTOR:\n-\t\t\t\tsimplfyConstructor(mth.root(), (ConstructorInsn) insn);\n+\t\t\t\tsimplifyStringConstructor(mth.root(), (ConstructorInsn) insn);\n \t\t\t\tbreak;\n \n \t\t\tdefault:\n@@ -133,42 +134,44 @@ private static InsnNode simplifyInsn(MethodNode mth, InsnNode insn) {\n \t\treturn null;\n \t}\n \n-\tprivate static void simplfyConstructor(RootNode root, ConstructorInsn insn) {\n-\t\tif (insn.getArgsCount() != 0\n-\t\t\t\t&& insn.getCallMth().getDeclClass().getType().equals(ArgType.STRING)) {\n-\t\t\tInsnArg arg = insn.getArg(0);\n-\t\t\tInsnNode node = arg.isInsnWrap()\n-\t\t\t\t\t? ((InsnWrapArg) arg).getWrapInsn()\n-\t\t\t\t\t: insn;\n-\t\t    if (node.getArgsCount() != 0) {\n-\t\t    \tArgType argType = node.getArg(0).getType();\n-\t\t    \tif (node.getType() == InsnType.FILLED_NEW_ARRAY\n-\t\t    \t\t\t&& (argType == ArgType.BYTE || argType == ArgType.CHAR)) {\n-\t\t    \t\tint printable = 0;\n-\t\t    \t\tbyte[] arr = new byte[node.getArgsCount()];\n-\t\t    \t\tfor (int i = 0; i < arr.length; i++) {\n-\t\t    \t\t\tarr[i] = (byte) ((LiteralArg) node.getArg(i)).getLiteral();\n-\t\t    \t\t\tif (NameMapper.isPrintableChar(arr[i])) {\n-\t\t    \t\t\t\tprintable++;\n-\t\t    \t\t\t}\n-\t\t    \t\t}\n-\t\t    \t\tif (printable >= arr.length - printable) {\n-\t\t    \t\t\tInsnWrapArg wa = new InsnWrapArg(new ConstStringNode(new String(arr)));\n-\t\t    \t\t\tif (insn.getArgsCount() == 1) {\n-\t\t    \t\t\t\tinsn.setArg(0, wa);\n-\t\t    \t\t\t} else {\n-\t\t    \t\t\t\tMethodInfo mi = MethodInfo.externalMth(\n-\t\t    \t\t\t\t\t\tClassInfo.fromType(root, ArgType.STRING),\n-\t\t    \t\t\t\t\t\t\"getBytes\",\n-\t\t    \t\t\t\t\t\tCollections.emptyList(),\n-\t\t    \t\t\t\t\t\tArgType.array(ArgType.BYTE));\n-\t\t    \t\t\t\tInvokeNode in = new InvokeNode(mi, InvokeType.VIRTUAL, 1);\n-\t\t    \t\t\t\tin.addArg(wa);\n-\t\t    \t\t\t\tinsn.setArg(0, new InsnWrapArg(in));\n-\t\t    \t\t\t}\n-\t\t    \t\t}\n-\t\t    \t}\n-\t\t    }\n+\tprivate static void simplifyStringConstructor(RootNode root, ConstructorInsn insn) {\n+\t\tif (insn.getCallMth().getDeclClass().getType().equals(ArgType.STRING)\n+\t\t\t\t&& insn.getArgsCount() != 0\n+\t\t\t\t&& insn.getArg(0).isInsnWrap()) {\n+\t\t\tInsnNode arrInsn = ((InsnWrapArg) insn.getArg(0)).getWrapInsn();\n+\t\t\tif (arrInsn.getType() == InsnType.FILLED_NEW_ARRAY\n+\t\t\t\t\t&& arrInsn.getArgsCount() != 0) {\n+\t\t\t\tArgType elemType = ((FilledNewArrayNode) arrInsn).getElemType();\n+\t\t\t\tif (elemType == ArgType.BYTE || elemType == ArgType.CHAR) {\n+\t\t\t\t\tint printable = 0;\n+\t\t\t\t\tbyte[] arr = new byte[arrInsn.getArgsCount()];\n+\t\t\t\t\tfor (int i = 0; i < arr.length; i++) {\n+\t\t\t\t\t\tInsnArg arrArg = arrInsn.getArg(i);\n+\t\t\t\t\t\tif (!arrArg.isLiteral()) {\n+\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tarr[i] = (byte) ((LiteralArg) arrArg).getLiteral();\n+\t\t\t\t\t\tif (NameMapper.isPrintableChar(arr[i])) {\n+\t\t\t\t\t\t\tprintable++;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (printable >= arr.length - printable) {\n+\t\t\t\t\t\tInsnWrapArg wa = new InsnWrapArg(new ConstStringNode(new String(arr)));\n+\t\t\t\t\t\tif (insn.getArgsCount() == 1) {\n+\t\t\t\t\t\t\tinsn.setArg(0, wa);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tMethodInfo mi = MethodInfo.externalMth(\n+\t\t\t\t\t\t\t\t\tClassInfo.fromType(root, ArgType.STRING),\n+\t\t\t\t\t\t\t\t\t\"getBytes\",\n+\t\t\t\t\t\t\t\t\tCollections.emptyList(),\n+\t\t\t\t\t\t\t\t\tArgType.array(ArgType.BYTE));\n+\t\t\t\t\t\t\tInvokeNode in = new InvokeNode(mi, InvokeType.VIRTUAL, 1);\n+\t\t\t\t\t\t\tin.addArg(wa);\n+\t\t\t\t\t\t\tinsn.setArg(0, new InsnWrapArg(in));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConstructor.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConstructor.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConstructor.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConstructor.java\n@@ -83,4 +83,17 @@ public void testNegative() {\n \n \t\tassertThat(code, containsOne(\"tag = new String();\"));\n \t}\n+\n+\tpublic static class TestClsNegative2 {\n+\t\tpublic byte b = 32;\n+\t\tpublic String tag = new String(new byte[] { 31, b });\n+\t}\n+\n+\t@Test\n+\tpublic void testNegative2() {\n+\t\tClassNode cls = getClassNode(TestClsNegative2.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"tag = new String(new byte[]{31, this.b});\"));\n+\t}\n }",
    "output": "Fix resolve check cast exception in string constructor simplify"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -332,7 +332,7 @@ private void addMethod(CodeWriter code, MethodNode mth) throws CodegenException\n \tprivate void insertDecompilationProblems(CodeWriter code, AttrNode node) {\n \t\tList<JadxError> errors = node.getAll(AType.JADX_ERROR);\n \t\tif (!errors.isEmpty()) {\n-\t\t\terrors.forEach(err -> {\n+\t\t\terrors.stream().sorted().forEach(err -> {\n \t\t\t\tcode.startLine(\"/*  JADX ERROR: \").add(err.getError());\n \t\t\t\tThrowable cause = err.getCause();\n \t\t\t\tif (cause != null) {\n@@ -345,8 +345,8 @@ private void insertDecompilationProblems(CodeWriter code, AttrNode node) {\n \t\t}\n \t\tList<String> warns = node.getAll(AType.JADX_WARN);\n \t\tif (!warns.isEmpty()) {\n-\t\t\twarns.stream().distinct()\n-\t\t\t\t\t.forEach(warn -> code.startLine(\"/* JADX WARNING: \").addMultiLine(warn).add(\" */\"));\n+\t\t\twarns.stream().distinct().sorted()\n+\t\t\t\t.forEach(warn -> code.startLine(\"/* JADX WARNING: \").addMultiLine(warn).add(\" */\"));\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java\n@@ -2,6 +2,7 @@\n \n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.EnumSet;\n import java.util.IdentityHashMap;\n import java.util.List;\n@@ -121,6 +122,7 @@ public String toString() {\n \t\tif (list.isEmpty()) {\n \t\t\treturn \"\";\n \t\t}\n+\t\tlist.sort(String::compareTo);\n \t\treturn \"A[\" + Utils.listToString(list) + ']';\n \t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -3,10 +3,8 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n \n import com.android.dex.ClassData;\n import com.android.dex.ClassData.Field;\n@@ -60,7 +58,7 @@ public class ClassNode extends LineAttrNode implements ILoadable, ICodeNode {\n \tprivate ClassNode parentClass;\n \n \tprivate ProcessState state = ProcessState.NOT_LOADED;\n-\tprivate final Set<ClassNode> dependencies = new HashSet<>();\n+\tprivate List<ClassNode> dependencies = Collections.emptyList();\n \n \t// cache maps\n \tprivate Map<MethodInfo, MethodNode> mthInfoMap = Collections.emptyMap();\n@@ -527,10 +525,14 @@ public void setState(ProcessState state) {\n \t\tthis.state = state;\n \t}\n \n-\tpublic Set<ClassNode> getDependencies() {\n+\tpublic List<ClassNode> getDependencies() {\n \t\treturn dependencies;\n \t}\n \n+\tpublic void setDependencies(List<ClassNode> dependencies) {\n+\t\tthis.dependencies = dependencies;\n+\t}\n+\n \t@Override\n \tpublic int hashCode() {\n \t\treturn clsInfo.hashCode();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java\n@@ -1,5 +1,9 @@\n package jadx.core.dex.visitors;\n \n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.Set;\n \n import jadx.core.dex.attributes.AType;\n@@ -26,12 +30,16 @@ public class DependencyCollector extends AbstractVisitor {\n \t@Override\n \tpublic boolean visit(ClassNode cls) throws JadxException {\n \t\tDexNode dex = cls.dex();\n-\t\tSet<ClassNode> depList = cls.getDependencies();\n-\t\tprocessClass(cls, dex, depList);\n+\t\tSet<ClassNode> depSet = new HashSet<>();\n+\t\tprocessClass(cls, dex, depSet);\n \t\tfor (ClassNode inner : cls.getInnerClasses()) {\n-\t\t\tprocessClass(inner, dex, depList);\n+\t\t\tprocessClass(inner, dex, depSet);\n \t\t}\n-\t\tdepList.remove(cls);\n+\t\tdepSet.remove(cls);\n+\n+\t\tList<ClassNode> depList = new ArrayList<>(depSet);\n+\t\tdepList.sort(Comparator.comparing(c -> c.getClassInfo().getFullName()));\n+\t\tcls.setDependencies(depList);\n \t\treturn false;\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -90,18 +90,15 @@ public void visit(MethodNode mth) {\n \t}\n \n \tprivate void runMultiVariableSearch(MethodNode mth) {\n-\t\tlong startTime = System.currentTimeMillis();\n \t\tTypeSearch typeSearch = new TypeSearch(mth);\n-\t\tboolean success;\n \t\ttry {\n-\t\t\tsuccess = typeSearch.run();\n+\t\t\tboolean success = typeSearch.run();\n+\t\t\tif (!success) {\n+\t\t\t\tmth.addWarn(\"Multi-variable type inference failed\");\n+\t\t\t}\n \t\t} catch (Exception e) {\n-\t\t\tsuccess = false;\n \t\t\tmth.addWarn(\"Multi-variable type inference failed. Error: \" + Utils.getStackTrace(e));\n \t\t}\n-\t\tlong time = System.currentTimeMillis() - startTime;\n-\t\tmth.addComment(\"JADX DEBUG: Multi-variable type inference result: \" + (success ? \"success\" : \"failure\")\n-\t\t\t               + \", time: \" + time + \" ms\");\n \t}\n \n \tprivate boolean setImmutableType(SSAVar ssaVar) {",
    "output": "Fix produce more deterministic code"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java\n@@ -227,10 +227,6 @@ private static void processAnonymousConstructor(MethodNode mth, ConstructorInsn\n \t\tif (callMthNode == null) {\n \t\t\treturn;\n \t\t}\n-\t\tMap<InsnArg, FieldNode> argsMap = getArgsToFieldsMapping(callMthNode, co);\n-\t\tif (argsMap.isEmpty() && !callMthNode.getArguments(true).isEmpty()) {\n-\t\t\treturn;\n-\t\t}\n \n \t\tClassNode classNode = callMthNode.getParentClass();\n \t\tif (!classNode.contains(AFlag.ANONYMOUS_CLASS)) {\n@@ -242,6 +238,10 @@ private static void processAnonymousConstructor(MethodNode mth, ConstructorInsn\n \t\tif (!mth.getParentClass().getInnerClasses().contains(classNode)) {\n \t\t\treturn;\n \t\t}\n+\t\tMap<InsnArg, FieldNode> argsMap = getArgsToFieldsMapping(callMthNode, co);\n+\t\tif (argsMap.isEmpty() && !callMthNode.getArguments(true).isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n \n \t\tfor (Map.Entry<InsnArg, FieldNode> entry : argsMap.entrySet()) {\n \t\t\tFieldNode field = entry.getValue();",
    "output": "Fix resolve NPE due to not yet processed class"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -8,10 +8,12 @@\n import java.awt.Font;\n import java.awt.GraphicsDevice;\n import java.awt.GraphicsEnvironment;\n+import java.awt.Toolkit;\n import java.awt.dnd.DnDConstants;\n import java.awt.dnd.DropTarget;\n import java.awt.event.ActionEvent;\n import java.awt.event.ActionListener;\n+import java.awt.event.InputEvent;\n import java.awt.event.KeyAdapter;\n import java.awt.event.KeyEvent;\n import java.awt.event.MouseAdapter;\n@@ -560,7 +562,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t\t}\n \t\t};\n \t\topenAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"file.open_action\"));\n-\t\topenAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_O, KeyEvent.CTRL_DOWN_MASK));\n+\t\topenAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_O, Utils.ctrlButton()));\n \n \t\tnewProjectAction = new AbstractAction(NLS.str(\"file.new_project\")) {\n \t\t\t@Override\n@@ -593,7 +595,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t\t}\n \t\t};\n \t\tsaveAllAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"file.save_all\"));\n-\t\tsaveAllAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_S, KeyEvent.CTRL_DOWN_MASK));\n+\t\tsaveAllAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_S, Utils.ctrlButton()));\n \n \t\tAction exportAction = new AbstractAction(NLS.str(\"file.export_gradle\"), ICON_EXPORT) {\n \t\t\t@Override\n@@ -602,7 +604,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t\t}\n \t\t};\n \t\texportAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"file.export_gradle\"));\n-\t\texportAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_E, KeyEvent.CTRL_DOWN_MASK));\n+\t\texportAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_E, Utils.ctrlButton()));\n \n \t\tJMenu recentProjects = new JMenu(NLS.str(\"menu.recent_projects\"));\n \t\trecentProjects.addMenuListener(new RecentProjectsMenuListener(recentProjects));\n@@ -615,7 +617,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t};\n \t\tprefsAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"menu.preferences\"));\n \t\tprefsAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_P,\n-\t\t\t\tKeyEvent.CTRL_DOWN_MASK | KeyEvent.SHIFT_DOWN_MASK));\n+\t\t\t\tUtils.ctrlButton() | KeyEvent.SHIFT_DOWN_MASK));\n \n \t\tAction exitAction = new AbstractAction(NLS.str(\"file.exit\"), ICON_CLOSE) {\n \t\t\t@Override\n@@ -642,7 +644,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t\t}\n \t\t};\n \t\tsyncAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"menu.sync\"));\n-\t\tsyncAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_T, KeyEvent.CTRL_DOWN_MASK));\n+\t\tsyncAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_T, Utils.ctrlButton()));\n \n \t\tAction textSearchAction = new AbstractAction(NLS.str(\"menu.text_search\"), ICON_SEARCH) {\n \t\t\t@Override\n@@ -652,7 +654,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t};\n \t\ttextSearchAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"menu.text_search\"));\n \t\ttextSearchAction.putValue(Action.ACCELERATOR_KEY,\n-\t\t\t\tgetKeyStroke(KeyEvent.VK_F, KeyEvent.CTRL_DOWN_MASK | KeyEvent.SHIFT_DOWN_MASK));\n+\t\t\t\tgetKeyStroke(KeyEvent.VK_F, Utils.ctrlButton() | KeyEvent.SHIFT_DOWN_MASK));\n \n \t\tAction clsSearchAction = new AbstractAction(NLS.str(\"menu.class_search\"), ICON_FIND) {\n \t\t\t@Override\n@@ -661,7 +663,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t\t}\n \t\t};\n \t\tclsSearchAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"menu.class_search\"));\n-\t\tclsSearchAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_N, KeyEvent.CTRL_DOWN_MASK));\n+\t\tclsSearchAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_N, Utils.ctrlButton()));\n \n \t\tAction deobfAction = new AbstractAction(NLS.str(\"menu.deobfuscation\"), ICON_DEOBF) {\n \t\t\t@Override\n@@ -671,7 +673,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t};\n \t\tdeobfAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"preferences.deobfuscation\"));\n \t\tdeobfAction.putValue(Action.ACCELERATOR_KEY,\n-\t\t\t\tgetKeyStroke(KeyEvent.VK_D, KeyEvent.CTRL_DOWN_MASK | KeyEvent.ALT_DOWN_MASK));\n+\t\t\t\tgetKeyStroke(KeyEvent.VK_D, Utils.ctrlButton() | KeyEvent.ALT_DOWN_MASK));\n \n \t\tdeobfToggleBtn = new JToggleButton(deobfAction);\n \t\tdeobfToggleBtn.setSelected(settings.isDeobfuscationOn());\n@@ -688,7 +690,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t};\n \t\tlogAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"menu.log\"));\n \t\tlogAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_L,\n-\t\t\t\tKeyEvent.CTRL_DOWN_MASK | KeyEvent.SHIFT_DOWN_MASK));\n+\t\t\t\tUtils.ctrlButton() | KeyEvent.SHIFT_DOWN_MASK));\n \n \t\tAction aboutAction = new AbstractAction(NLS.str(\"menu.about\"), ICON_JADX) {\n \t\t\t@Override\n@@ -705,7 +707,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t};\n \t\tbackAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"nav.back\"));\n \t\tbackAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_LEFT,\n-\t\t\t\tKeyEvent.CTRL_DOWN_MASK | KeyEvent.ALT_DOWN_MASK));\n+\t\t\t\tUtils.ctrlButton() | KeyEvent.ALT_DOWN_MASK));\n \n \t\tAction forwardAction = new AbstractAction(NLS.str(\"nav.forward\"), ICON_FORWARD) {\n \t\t\t@Override\n@@ -715,7 +717,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t};\n \t\tforwardAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"nav.forward\"));\n \t\tforwardAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_RIGHT,\n-\t\t\t\tKeyEvent.CTRL_DOWN_MASK | KeyEvent.ALT_DOWN_MASK));\n+\t\t\t\tUtils.ctrlButton() | KeyEvent.ALT_DOWN_MASK));\n \n \t\tJMenu file = new JMenu(NLS.str(\"menu.file\"));\n \t\tfile.setMnemonic(KeyEvent.VK_F);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodePanel.java\n@@ -32,7 +32,7 @@ public CodePanel(TabbedPane panel, JNode jnode) {\n \t\tadd(searchBar, BorderLayout.NORTH);\n \t\tadd(scrollPane);\n \n-\t\tKeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_F, InputEvent.CTRL_DOWN_MASK);\n+\t\tKeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_F, Utils.ctrlButton());\n \t\tUtils.addKeyBinding(codeArea, key, \"SearchAction\", new SearchAction());\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/TextStandardActions.java b/jadx-gui/src/main/java/jadx/gui/utils/TextStandardActions.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/TextStandardActions.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/TextStandardActions.java\n@@ -100,9 +100,9 @@ void addPopupItems() {\n \t}\n \n \tprivate void addKeyActions() {\n-\t\tKeyStroke undoKey = KeyStroke.getKeyStroke(KeyEvent.VK_Z, InputEvent.CTRL_DOWN_MASK);\n+\t\tKeyStroke undoKey = KeyStroke.getKeyStroke(KeyEvent.VK_Z, Utils.ctrlButton());\n \t\ttextComponent.getInputMap().put(undoKey, undoAction);\n-\t\tKeyStroke redoKey = KeyStroke.getKeyStroke(KeyEvent.VK_R, InputEvent.CTRL_DOWN_MASK);\n+\t\tKeyStroke redoKey = KeyStroke.getKeyStroke(KeyEvent.VK_R, Utils.ctrlButton());\n \t\ttextComponent.getInputMap().put(redoKey, redoAction);\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/Utils.java b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n@@ -5,6 +5,7 @@\n import java.awt.datatransfer.Clipboard;\n import java.awt.datatransfer.StringSelection;\n import java.awt.datatransfer.Transferable;\n+import java.awt.event.InputEvent;\n import java.io.InputStream;\n import java.net.URL;\n import java.util.ArrayList;\n@@ -202,4 +203,13 @@ public static void setWindowIcons(Window window) {\n \t\ticons.add(Utils.openImage(\"/logos/jadx-logo.png\"));\n \t\twindow.setIconImages(icons);\n \t}\n+\t\n+\tpublic static int ctrlButton() {\n+\t\tif (System.getProperty(\"os.name\").toLowerCase().contains(\"mac\")) {\n+ \t\t\treturn Toolkit.getDefaultToolkit().getMenuShortcutKeyMask();\n+ \t\t}\n+ \t\telse {\n+ \t\t\treturn InputEvent.CTRL_DOWN_MASK;\n+ \t\t}\n+\t}\n }",
    "output": "Use command (CMD) button for MacOS"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -221,6 +221,9 @@ private void parseEntry(PackageChunk pkg, int typeId, int entryId, EntryConfig c\n \t\tint resRef = pkg.getId() << 24 | typeId << 16 | entryId;\n \t\tString typeName = pkg.getTypeStrings()[typeId - 1];\n \t\tString keyName = pkg.getKeyStrings()[key];\n+\t\tif(keyName.isEmpty()) {\n+\t\t\tkeyName = \"RES_\" + resRef; // autogenerate key name\n+\t\t}\n \t\tResourceEntry ri = new ResourceEntry(resRef, pkg.getName(), typeName, keyName);\n \t\tri.setConfig(config);",
    "output": "Fix generates XML key names if empty"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -249,7 +249,7 @@ public List<JavaPackage> getPackages() {\n \t\t}\n \t\tCollections.sort(packages);\n \t\tfor (JavaPackage pkg : packages) {\n-\t\t\tpkg.getClasses().sort(Comparator.comparing(JavaClass::getName));\n+\t\t\tpkg.getClasses().sort(Comparator.comparing(JavaClass::getName, String.CASE_INSENSITIVE_ORDER));\n \t\t}\n \t\treturn Collections.unmodifiableList(packages);\n \t}",
    "output": "Fix sort classes by case insensitivity"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -862,6 +862,7 @@ private void makeTernary(TernaryInsn insn, CodeWriter code, Set<Flags> state) th\n \t\t} else {\n \t\t\tcondGen.wrap(code, insn.getCondition());\n \t\t\tcode.add(\" ? \");\n+\t\t\taddCastIfNeeded(code, first, second);\n \t\t\taddArg(code, first, false);\n \t\t\tcode.add(\" : \");\n \t\t\taddArg(code, second, false);\n@@ -871,6 +872,26 @@ private void makeTernary(TernaryInsn insn, CodeWriter code, Set<Flags> state) th\n \t\t}\n \t}\n \n+\tprivate void addCastIfNeeded(CodeWriter code, InsnArg first, InsnArg second) {\n+\t\tif (first.isLiteral() && second.isLiteral()) {\n+\t\t\tif (first.getType() == ArgType.BYTE) {\n+\t\t\t\tlong lit1 = ((LiteralArg) first).getLiteral();\n+\t\t\t\tlong lit2 = ((LiteralArg) second).getLiteral();\n+\t\t\t\tif (lit1 != Byte.MAX_VALUE && lit1 != Byte.MIN_VALUE\n+\t\t\t\t\t\t&& lit2 != Byte.MAX_VALUE && lit2 != Byte.MIN_VALUE) {\n+\t\t\t\t\tcode.add(\"(byte) \");\n+\t\t\t\t}\n+\t\t\t} else if (first.getType() == ArgType.SHORT) {\n+\t\t\t\tlong lit1 = ((LiteralArg) first).getLiteral();\n+\t\t\t\tlong lit2 = ((LiteralArg) second).getLiteral();\n+\t\t\t\tif (lit1 != Short.MAX_VALUE && lit1 != Short.MIN_VALUE\n+\t\t\t\t\t\t&& lit2 != Short.MAX_VALUE && lit2 != Short.MIN_VALUE) {\n+\t\t\t\t\tcode.add(\"(short) \");\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tprivate void makeArith(ArithNode insn, CodeWriter code, Set<Flags> state) throws CodegenException {\n \t\tif (insn.contains(AFlag.ARITH_ONEARG)) {\n \t\t\tmakeArithOneArg(insn, code);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestCast.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestCast.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestCast.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestCast.java\n@@ -0,0 +1,61 @@\n+package jadx.tests.integration.conditions;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+public class TestCast extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tbyte myByte;\n+\t\tshort myShort;\n+\n+\t\tpublic void test1(boolean a) {\n+\t\t\twrite(a ? (byte) 0 : 1);\n+\t\t}\n+\n+\t\tpublic void test2(boolean a) {\n+\t\t\twrite(a ? 0 : myByte);\n+\t\t}\n+\n+\t\tpublic void test3(boolean a) {\n+\t\t\twrite(a ? 0 : Byte.MAX_VALUE);\n+\t\t}\n+\n+\t\tpublic void test4(boolean a) {\n+\t\t\twrite(a ? (short) 0 : 1);\n+\t\t}\n+\n+\t\tpublic void test5(boolean a) {\n+\t\t\twrite(a ? myShort : 0);\n+\t\t}\n+\n+\t\tpublic void test6(boolean a) {\n+\t\t\twrite(a ? Short.MIN_VALUE : 0);\n+\t\t}\n+\n+\t\tpublic void write(byte b) {\n+\t\t}\n+\t\tpublic void write(short b) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"write(a ? (byte) 0 : 1);\"));\n+\t\tassertThat(code, containsString(\"write(a ? 0 : this.myByte);\"));\n+\t\tassertThat(code, containsString(\"write(a ? 0 : Byte.MAX_VALUE);\"));\n+\n+\t\tassertThat(code, containsString(\"write(a ? (short) 0 : 1);\"));\n+\t\tassertThat(code, containsString(\"write(a ? this.myShort : 0);\"));\n+\t\tassertThat(code, containsString(\"write(a ? Short.MIN_VALUE : 0);\"));\n+\t}\n+}",
    "output": "Add primitive cast in ternary for byte and short"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -569,6 +569,21 @@ private void makeConstructor(ConstructorInsn insn, CodeWriter code)\n \t\t} else {\n \t\t\tcode.add(\"new \");\n \t\t\tuseClass(code, insn.getClassType());\n+\t\t\tArgType argType = insn.getResult().getSVar().getCodeVar().getType();\n+\t\t\tif (argType.isGeneric()) {\n+\t\t\t\tcode.add('<');\n+\t\t\t\tif (insn.contains(AFlag.EXPLICIT_GENERICS)) {\n+\t\t\t\t\tboolean first = true;\n+\t\t\t\t\tfor (ArgType type : argType.getGenericTypes()) {\n+\t\t\t\t\t\tif (!first) {\n+\t\t\t\t\t\t\tcode.add(',');\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tmgen.getClassGen().useType(code, type);\n+\t\t\t\t\t\tfirst = false;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tcode.add('>');\n+\t\t\t}\n \t\t}\n \t\tMethodNode callMth = mth.dex().resolveMethod(insn.getCallMth());\n \t\tgenerateMethodArguments(code, insn, 0, callMth);\n@@ -749,9 +764,17 @@ private boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnAr\n \t\tif (argType.equals(origType)) {\n \t\t\treturn false;\n \t\t}\n-\t\tif (origType.isGeneric()\n-\t\t\t\t&& origType.getObject().equals(argType.getObject())) {\n-\t\t\treturn false;\n+\t\tif (origType.isGeneric()) {\n+\t\t\tif (!argType.isGeneric() && arg.isInsnWrap()) {\n+\t\t\t\t((InsnWrapArg) arg).getWrapInsn().getResult().setType(\n+\t\t\t\t\t\tArgType.generic(argType.getObject(), origType.getGenericTypes()));\n+\t\t\t}\n+\t\t\tif (origType.getObject().equals(argType.getObject())) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (arg.isInsnWrap()) {\n+\t\t\t\t((InsnWrapArg) arg).getWrapInsn().add(AFlag.EXPLICIT_GENERICS);\n+\t\t\t}\n \t\t}\n \t\tcode.add('(');\n \t\tuseType(code, origType);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n@@ -48,5 +48,7 @@ public enum AFlag {\n \n \tFALL_THROUGH,\n \n+\tEXPLICIT_GENERICS,\n+\n \tINCONSISTENT_CODE, // warning about incorrect decompilation\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java\n@@ -5,7 +5,6 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.tests.api.IntegrationTest;\n \n@@ -55,18 +54,6 @@ public void test() {\n \t\tClassNode cls = getClassNode(TestCls.class);\n \t\tString code = cls.getCode().toString();\n \n-\t\tassertThat(code, containsOne(\"call(new ArrayList());\"));\n-\t\tassertThat(code, containsOne(\"call((List<String>) new ArrayList());\"));\n-\n-\t\tassertThat(code, containsOne(\"call((String) obj);\"));\n-\t}\n-\n-\t@Test\n-\t@NotYetImplemented\n-\tpublic void testNYI() {\n-\t\tClassNode cls = getClassNode(TestCls.class);\n-\t\tString code = cls.getCode().toString();\n-\n \t\tassertThat(code, containsOne(\"call(new ArrayList<>());\"));\n \t\tassertThat(code, containsOne(\"call((List<String>) new ArrayList<String>());\"));\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesUsageWithLoops.java b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesUsageWithLoops.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesUsageWithLoops.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesUsageWithLoops.java\n@@ -15,11 +15,10 @@ public class TestVariablesUsageWithLoops extends IntegrationTest {\n \n \tpublic static class TestEnhancedFor {\n \n-\t\t@SuppressWarnings(\"rawtypes\")\n \t\tpublic void test() {\n-\t\t\tList list;\n+\t\t\tList<Object> list;\n \t\t\tsynchronized (this) {\n-\t\t\t\tlist = new ArrayList();\n+\t\t\t\tlist = new ArrayList<>();\n \t\t\t}\n \t\t\tfor (Object o : list) {\n \t\t\t\tSystem.out.println(o);\n@@ -32,15 +31,15 @@ public void testEnhancedFor() {\n \t\tClassNode cls = getClassNode(TestEnhancedFor.class);\n \t\tString code = cls.getCode().toString();\n \n-\t\tassertThat(code, containsString(\"     list = new ArrayList\"));\n+\t\tassertThat(code, containsString(\"     list = new ArrayList<>\"));\n \t}\n \n \tpublic static class TestForLoop {\n \n \t\tpublic void test() {\n-\t\t\tList list;\n+\t\t\tList<Object> list;\n \t\t\tsynchronized (this) {\n-\t\t\t\tlist = new ArrayList();\n+\t\t\t\tlist = new ArrayList<>();\n \t\t\t}\n \t\t\tfor (int i = 0; i < list.size(); i++) {\n \t\t\t\tSystem.out.println(i);\n@@ -53,6 +52,6 @@ public void testForLoop() {\n \t\tClassNode cls = getClassNode(TestForLoop.class);\n \t\tString code = cls.getCode().toString();\n \n-\t\tassertThat(code, containsString(\"     list = new ArrayList\"));\n+\t\tassertThat(code, containsString(\"     list = new ArrayList<>\"));\n \t}\n }",
    "output": "Fix generics constructor types"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -1,5 +1,7 @@\n package jadx.core.codegen;\n \n+import static jadx.core.utils.android.AndroidResourcesUtils.handleAppResField;\n+\n import java.util.ArrayList;\n import java.util.EnumSet;\n import java.util.Iterator;\n@@ -41,6 +43,7 @@\n import jadx.core.dex.instructions.args.LiteralArg;\n import jadx.core.dex.instructions.args.Named;\n import jadx.core.dex.instructions.args.RegisterArg;\n+import jadx.core.dex.instructions.args.SSAVar;\n import jadx.core.dex.instructions.mods.ConstructorInsn;\n import jadx.core.dex.instructions.mods.TernaryInsn;\n import jadx.core.dex.nodes.ClassNode;\n@@ -52,8 +55,6 @@\n import jadx.core.utils.exceptions.CodegenException;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n-import static jadx.core.utils.android.AndroidResourcesUtils.handleAppResField;\n-\n public class InsnGen {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(InsnGen.class);\n \n@@ -219,9 +220,13 @@ protected void makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws Codeg\n \t\t\t\tif (flag != Flags.INLINE) {\n \t\t\t\t\tcode.startLineWithNum(insn.getSourceLine());\n \t\t\t\t}\n-\t\t\t\tif (insn.getResult() != null && !insn.contains(AFlag.ARITH_ONEARG)) {\n-\t\t\t\t\tassignVar(code, insn);\n-\t\t\t\t\tcode.add(\" = \");\n+\t\t\t\tif (insn.getResult() != null) {\n+\t\t\t\t\tSSAVar var = insn.getResult().getSVar();\n+\t\t\t\t\tif ((var == null || var.getUseCount() != 0 || insn.getType() != InsnType.CONSTRUCTOR)\n+\t\t\t\t\t\t\t&& !insn.contains(AFlag.ARITH_ONEARG)) {\n+\t\t\t\t\t\tassignVar(code, insn);\n+\t\t\t\t\t\tcode.add(\" = \");\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tmakeInsnBody(code, insn, state);\n \t\t\t\tif (flag != Flags.INLINE) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/annotations/TestAnnotationsMix.java b/jadx-core/src/test/java/jadx/tests/integration/annotations/TestAnnotationsMix.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/annotations/TestAnnotationsMix.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/annotations/TestAnnotationsMix.java\n@@ -10,7 +10,6 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.tests.api.IntegrationTest;\n \n@@ -112,8 +111,7 @@ public void testNoDebug() {\n \t}\n \n \t@Test\n-\t@NotYetImplemented\n-\tpublic void testNYI() {\n+\tpublic void testDeclaration() {\n \t\tClassNode cls = getClassNode(TestCls.class);\n \t\tString code = cls.getCode().toString();\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass13.java b/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass13.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass13.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass13.java\n@@ -2,7 +2,6 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.tests.api.IntegrationTest;\n \n public class TestAnonymousClass13 extends IntegrationTest {\n@@ -16,7 +15,6 @@ public void test() {\n \t}\n \n \t@Test\n-\t@NotYetImplemented\n \tpublic void test() {\n \t\tgetClassNode(TestCls.class);\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestConstructorInvoke.java b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestConstructorInvoke.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestConstructorInvoke.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestConstructorInvoke.java\n@@ -1,49 +0,0 @@\n-package jadx.tests.integration.invoke;\n-\n-import org.junit.jupiter.api.Test;\n-\n-import jadx.NotYetImplemented;\n-import jadx.core.dex.nodes.ClassNode;\n-import jadx.tests.api.IntegrationTest;\n-\n-import static jadx.tests.api.utils.JadxMatchers.containsOne;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-\n-public class TestConstructorInvoke extends IntegrationTest {\n-\n-\tvoid test(String root, String name) {\n-\t\tViewHolder holder = new ViewHolder(root, name);\n-\t}\n-\n-\tprivate final class ViewHolder {\n-\t\tprivate ViewHolder(String root, String name) {\n-\t\t}\n-\t}\n-\n-\t@Test\n-\t@NotYetImplemented(\"Variable lost name from debug info\")\n-\tpublic void test() {\n-\t\tClassNode cls = getClassNode(TestConstructorInvoke.class);\n-\t\tString code = cls.getCode().toString();\n-\n-\t\tassertThat(code, containsOne(indent() + \"ViewHolder holder = new ViewHolder(root, name);\"));\n-\t}\n-\n-\t// Remove after fix above @NYI\n-\t@Test\n-\tpublic void test2() {\n-\t\tClassNode cls = getClassNode(TestConstructorInvoke.class);\n-\t\tString code = cls.getCode().toString();\n-\n-\t\tassertThat(code, containsOne(indent() + \"ViewHolder viewHolder = new ViewHolder(root, name);\"));\n-\t}\n-\n-\t@Test\n-\tpublic void testNoDebug() {\n-\t\tnoDebugInfo();\n-\t\tClassNode cls = getClassNode(TestConstructorInvoke.class);\n-\t\tString code = cls.getCode().toString();\n-\n-\t\tassertThat(code, containsOne(indent() + \"ViewHolder viewHolder = new ViewHolder(\"));\n-\t}\n-}",
    "output": "Remove declaration of unused variable"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -740,13 +740,18 @@ private boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnAr\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n-\t\tif (!arg.getType().equals(origType)) {\n-\t\t\tcode.add('(');\n-\t\t\tuseType(code, origType);\n-\t\t\tcode.add(\") \");\n-\t\t\treturn true;\n+\t\tArgType argType = arg.getType();\n+\t\tif (argType.equals(origType)) {\n+\t\t\treturn false;\n \t\t}\n-\t\treturn false;\n+\t\tif (origType.isGeneric()\n+\t\t\t\t&& origType.getObject().equals(argType.getObject())) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tcode.add('(');\n+\t\tuseType(code, origType);\n+\t\tcode.add(\") \");\n+\t\treturn true;\n \t}\n \n \t/**\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java\n@@ -2,6 +2,10 @@\n \n import java.io.EOFException;\n \n+import org.jetbrains.annotations.NotNull;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import com.android.dex.Code;\n import com.android.dx.io.OpcodeInfo;\n import com.android.dx.io.Opcodes;\n@@ -10,10 +14,8 @@\n import com.android.dx.io.instructions.PackedSwitchPayloadDecodedInstruction;\n import com.android.dx.io.instructions.ShortArrayCodeInput;\n import com.android.dx.io.instructions.SparseSwitchPayloadDecodedInstruction;\n-import org.jetbrains.annotations.NotNull;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n+import jadx.core.Consts;\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.instructions.args.ArgType;\n@@ -119,9 +121,13 @@ private InsnNode decode(DecodedInstruction insn, int offset) throws DecodeExcept\n \t\t\t\treturn constStrInsn;\n \n \t\t\tcase Opcodes.CONST_CLASS:\n-\t\t\t\tInsnNode constClsInsn = new ConstClassNode(dex.getType(insn.getIndex()));\n-\t\t\t\tconstClsInsn.setResult(InsnArg.reg(insn, 0, ArgType.CLASS));\n+\t\t\t\t{\n+\t\t\t\tArgType clsType = dex.getType(insn.getIndex());\n+\t\t\t\tInsnNode constClsInsn = new ConstClassNode(clsType);\n+\t\t\t\tconstClsInsn.setResult(\n+\t\t\t\t\t\tInsnArg.reg(insn, 0, ArgType.generic(Consts.CLASS_CLASS, clsType)));\n \t\t\t\treturn constClsInsn;\n+\t\t\t\t}\n \n \t\t\tcase Opcodes.MOVE:\n \t\t\tcase Opcodes.MOVE_16:\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n@@ -83,7 +83,7 @@ public static ArgType generic(String sign) {\n \t\treturn new SignatureParser(sign).consumeType();\n \t}\n \n-\tpublic static ArgType generic(String obj, ArgType[] generics) {\n+\tpublic static ArgType generic(String obj, ArgType... generics) {\n \t\treturn new GenericObject(obj, generics);\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n@@ -326,7 +326,7 @@ private static boolean fixIterableType(MethodNode mth, InsnArg iterableArg, Regi\n \t\t\treturn true;\n \t\t}\n \t\t// TODO: add checks\n-\t\titerableType = ArgType.generic(iterableType.getObject(), new ArgType[]{varType});\n+\t\titerableType = ArgType.generic(iterableType.getObject(), varType);\n \t\titerableArg.setType(iterableType);\n \t\treturn true;\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java b/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n--- a/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n+++ b/jadx-core/src/test/java/jadx/core/dex/visitors/typeinference/TypeCompareTest.java\n@@ -76,7 +76,7 @@ public void compareGenerics() {\n \n \t\tArgType keyType = ArgType.genericType(\"K\");\n \t\tArgType valueType = ArgType.genericType(\"V\");\n-\t\tArgType mapGeneric = ArgType.generic(mapCls.getObject(), new ArgType[]{keyType, valueType});\n+\t\tArgType mapGeneric = ArgType.generic(mapCls.getObject(), keyType, valueType);\n \n \t\tcheck(mapGeneric, mapCls, TypeCompareEnum.NARROW_BY_GENERIC);\n \t\tcheck(mapCls, mapGeneric, TypeCompareEnum.WIDER_BY_GENERIC);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/functional/SignatureParserTest.java b/jadx-core/src/test/java/jadx/tests/functional/SignatureParserTest.java\n--- a/jadx-core/src/test/java/jadx/tests/functional/SignatureParserTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/functional/SignatureParserTest.java\n@@ -43,12 +43,12 @@ private static void checkType(String str, ArgType type) {\n \t@Test\n \tpublic void testGenerics() {\n \t\tcheckType(\"TD;\", genericType(\"D\"));\n-\t\tcheckType(\"La<TV;Lb;>;\", generic(\"La;\", new ArgType[]{genericType(\"V\"), object(\"b\")}));\n-\t\tcheckType(\"La<Lb<Lc;>;>;\", generic(\"La;\", new ArgType[]{generic(\"Lb;\", new ArgType[]{object(\"Lc;\")})}));\n-\t\tcheckType(\"La/b/C<Ld/E<Lf/G;>;>;\", generic(\"La/b/C;\", new ArgType[]{generic(\"Ld/E;\", new ArgType[]{object(\"Lf/G;\")})}));\n-\t\tcheckType(\"La<TD;>.c;\", genericInner(generic(\"La;\", new ArgType[]{genericType(\"D\")}), \"c\", null));\n-\t\tcheckType(\"La<TD;>.c/d;\", genericInner(generic(\"La;\", new ArgType[]{genericType(\"D\")}), \"c.d\", null));\n-\t\tcheckType(\"La<Lb;>.c<TV;>;\", genericInner(generic(\"La;\", new ArgType[]{object(\"Lb;\")}), \"c\", new ArgType[]{genericType(\"V\")}));\n+\t\tcheckType(\"La<TV;Lb;>;\", generic(\"La;\", genericType(\"V\"), object(\"b\")));\n+\t\tcheckType(\"La<Lb<Lc;>;>;\", generic(\"La;\", generic(\"Lb;\", object(\"Lc;\"))));\n+\t\tcheckType(\"La/b/C<Ld/E<Lf/G;>;>;\", generic(\"La/b/C;\", generic(\"Ld/E;\", object(\"Lf/G;\"))));\n+\t\tcheckType(\"La<TD;>.c;\", genericInner(generic(\"La;\", genericType(\"D\")), \"c\", null));\n+\t\tcheckType(\"La<TD;>.c/d;\", genericInner(generic(\"La;\", genericType(\"D\")), \"c.d\", null));\n+\t\tcheckType(\"La<Lb;>.c<TV;>;\", genericInner(generic(\"La;\", object(\"Lb;\")), \"c\", new ArgType[]{genericType(\"V\")}));\n \t}\n \n \t@Test\n@@ -107,7 +107,7 @@ public void testMethodArgs() {\n \t\tList<ArgType> argTypes = new SignatureParser(\"(Ljava/util/List<*>;)V\").consumeMethodArgs();\n \n \t\tassertThat(argTypes, hasSize(1));\n-\t\tassertThat(argTypes.get(0), is(generic(\"Ljava/util/List;\", new ArgType[]{wildcard()})));\n+\t\tassertThat(argTypes.get(0), is(generic(\"Ljava/util/List;\", wildcard())));\n \t}\n \n \t@Test\n@@ -117,7 +117,7 @@ public void testMethodArgs2() {\n \t\tassertThat(argTypes, hasSize(1));\n \t\tArgType argType = argTypes.get(0);\n \t\tassertThat(argType.getObject().indexOf('/'), is(-1));\n-\t\tassertThat(argType, is(genericInner(generic(\"La/b/C;\", new ArgType[]{genericType(\"T\")}), \"d.E\", null)));\n+\t\tassertThat(argType, is(genericInner(generic(\"La/b/C;\", genericType(\"T\")), \"d.E\", (ArgType[]) null)));\n \t}\n \n \t@Test\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics7.java b/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics7.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics7.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics7.java\n@@ -0,0 +1,34 @@\n+package jadx.tests.integration.generics;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+public class TestGenerics7 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic void test() {\n+\t\t\tdeclare(String.class);\n+\t\t}\n+\n+\t\tpublic <T> T declare(Class<T> cls) {\n+\t    \treturn null;\n+\t    }\n+\n+\t\tpublic void declare(Object cls) {\n+\t    }\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"declare(String.class);\"));\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java\n@@ -55,7 +55,7 @@ public void test() {\n \t\tClassNode cls = getClassNode(TestCls.class);\n \t\tString code = cls.getCode().toString();\n \n-\t\tassertThat(code, containsOne(\"call((ArrayList<String>) new ArrayList());\"));\n+\t\tassertThat(code, containsOne(\"call(new ArrayList());\"));\n \t\tassertThat(code, containsOne(\"call((List<String>) new ArrayList());\"));\n \n \t\tassertThat(code, containsOne(\"call((String) obj);\"));",
    "output": "Remove generics cast when object types match"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n@@ -51,7 +51,8 @@ private static void checkStaticFieldsInit(ClassNode cls) {\n \t\tMethodNode clinit = cls.getClassInitMth();\n \t\tif (clinit == null\n \t\t\t\t|| !clinit.getAccessFlags().isStatic()\n-\t\t\t\t|| clinit.isNoCode()) {\n+\t\t\t\t|| clinit.isNoCode()\n+\t\t\t\t|| clinit.getBasicBlocks() == null) {\n \t\t\treturn;\n \t\t}\n \n@@ -235,7 +236,7 @@ private static List<MethodNode> getConstructorsList(ClassNode cls) {\n \t}\n \n \tprivate static List<InsnNode> getFieldAssigns(MethodNode mth, FieldNode field, InsnType putInsn) {\n-\t\tif (mth.isNoCode()) {\n+\t\tif (mth.isNoCode() || mth.getBasicBlocks() == null) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n \t\tList<InsnNode> assignInsns = new ArrayList<>();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n@@ -218,7 +218,7 @@ private static void processEnumSwitch(MethodNode mth, SwitchNode insn) {\n \n \tprivate static void initClsEnumMap(ClassNode enumCls) {\n \t\tMethodNode clsInitMth = enumCls.getClassInitMth();\n-\t\tif (clsInitMth == null || clsInitMth.isNoCode()) {\n+\t\tif (clsInitMth == null || clsInitMth.isNoCode() || clsInitMth.getBasicBlocks() == null) {\n \t\t\treturn;\n \t\t}\n \t\tEnumMapAttr mapAttr = new EnumMapAttr();",
    "output": "Fix handle NPE for methods with removed instructions"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n--- a/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n@@ -6,6 +6,7 @@\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.Objects;\n \n import jadx.core.dex.instructions.ArithNode;\n import jadx.core.dex.instructions.ArithOp;\n@@ -118,7 +119,7 @@ public static IfCondition invert(IfCondition cond) {\n \t\t\tcase COMPARE:\n \t\t\t\treturn new IfCondition(cond.getCompare().invert());\n \t\t\tcase TERNARY:\n-\t\t\t\treturn ternary(not(cond.first()), cond.third(), cond.second());\n+\t\t\t\treturn ternary(cond.first(), not(cond.second()), not(cond.third()));\n \t\t\tcase NOT:\n \t\t\t\treturn cond.first();\n \t\t\tcase AND:\n@@ -137,6 +138,9 @@ public static IfCondition not(IfCondition cond) {\n \t\tif (cond.getMode() == Mode.NOT) {\n \t\t\treturn cond.first();\n \t\t}\n+\t\tif (cond.getCompare() != null) {\n+\t\t\treturn new IfCondition(cond.compare.invert());\n+\t\t}\n \t\treturn new IfCondition(Mode.NOT, Collections.singletonList(cond));\n \t}\n \n@@ -281,4 +285,30 @@ public String toString() {\n \t\t}\n \t\treturn \"??\";\n \t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (!(obj instanceof IfCondition)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tIfCondition other = (IfCondition) obj;\n+\t\tif (mode != other.mode) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Objects.equals(other.args, other.args)\n+\t\t\t&& Objects.equals(compare, other.compare);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tint result = super.hashCode();\n+\t\tresult = 31 * result + mode.hashCode();\n+\t\tresult = 31 * result + args.hashCode();\n+\t\tresult = 31 * result + (compare != null ? compare.hashCode() : 0);\n+\t\treturn result;\n+\t}\n+\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf.java\n@@ -18,7 +18,7 @@ public boolean test1(boolean a, boolean b, boolean c) {\n \t\t}\n \n \t\tpublic int test2(boolean a, boolean b, boolean c) {\n-\t\t\treturn (a ? b : c) ? 1 : 2;\n+\t\t\treturn (!a ? c : b) ? 1 : 2;\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf2.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf2.java\n@@ -0,0 +1,42 @@\n+package jadx.tests.integration.conditions;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsLines;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+public class TestTernaryInIf2 extends SmaliTest {\n+\n+\tpublic static class TestCls {\n+\t    private String a;\n+\t    private String b;\n+\n+\t    public boolean equals(TestCls other) {\n+\t    \tif (this.a == null ? other.a == null : this.a.equals(other.a)) {\n+    \t\t\tif (this.b == null ? other.b == null : this.b.equals(other.b)) {\n+    \t\t\t\treturn true;\n+    \t\t\t}\n+\t    \t}\n+\t    \treturn false;\n+\t    }\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsLines(2, \"if (this.a != null ? this.a.equals(other.a) : other.a == null) {\"));\n+\t\tassertThat(code, containsLines(3, \"if (this.b != null ? this.b.equals(other.b) : other.b == null) {\"));\n+\t\tassertThat(code, containsLines(4, \"return true;\"));\n+\t\tassertThat(code, containsLines(2, \"return false;\"));\n+\t}\n+\n+\t@Test\n+\tpublic void test2() {\n+\t\tgetClassNodeFromSmaliWithPath(\"conditions\", \"TestTernaryInIf2\");\n+\t}\n+}",
    "output": "Fix conditions in ternary if"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -83,18 +83,22 @@ private void initUI() {\n \t\tJButton saveBtn = new JButton(NLS.str(\"preferences.save\"));\n \t\tsaveBtn.addActionListener(event -> {\n \t\t\tsettings.sync();\n-\t\t\tif (needReload) {\n-\t\t\t\tmainWindow.reOpenFile();\n-\t\t\t}\n-\t\t\tif (!settings.getLangLocale().equals(prevLang)) {\n-\t\t\t\tJOptionPane.showMessageDialog(\n-\t\t\t\t\t\tthis,\n-\t\t\t\t\t\tNLS.str(\"msg.language_changed\", settings.getLangLocale()),\n-\t\t\t\t\t\tNLS.str(\"msg.language_changed_title\", settings.getLangLocale()),\n-\t\t\t\t\t\tJOptionPane.INFORMATION_MESSAGE\n-\t\t\t\t);\n-\t\t\t}\n-\t\t\tdispose();\n+\t\t\tenableComponents(this, false);\n+\n+\t\t\tSwingUtilities.invokeLater(() -> {\n+\t\t\t\tif (needReload) {\n+\t\t\t\t\tmainWindow.reOpenFile();\n+\t\t\t\t}\n+\t\t\t\tif (!settings.getLangLocale().equals(prevLang)) {\n+\t\t\t\t\tJOptionPane.showMessageDialog(\n+\t\t\t\t\t\t\tthis,\n+\t\t\t\t\t\t\tNLS.str(\"msg.language_changed\", settings.getLangLocale()),\n+\t\t\t\t\t\t\tNLS.str(\"msg.language_changed_title\", settings.getLangLocale()),\n+\t\t\t\t\t\t\tJOptionPane.INFORMATION_MESSAGE\n+\t\t\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t\tdispose();\n+\t\t\t});\n \t\t});\n \t\tJButton cancelButton = new JButton(NLS.str(\"preferences.cancel\"));\n \t\tcancelButton.addActionListener(event -> {\n@@ -139,6 +143,15 @@ private void initUI() {\n \t\tgetRootPane().setDefaultButton(saveBtn);\n \t}\n \n+\tprivate static void enableComponents(Container container, boolean enable) {\n+        for (Component component : container.getComponents()) {\n+            if (component instanceof Container) {\n+                enableComponents((Container) component, enable);\n+            }\n+            component.setEnabled(enable);\n+        }\n+    }\n+\n \tprivate SettingsGroup makeDeobfuscationGroup() {\n \t\tJCheckBox deobfOn = new JCheckBox();\n \t\tdeobfOn.setSelected(settings.isDeobfuscationOn());",
    "output": "Fix disable all components on saving the settings"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n@@ -92,6 +92,10 @@ private static void moveStaticFieldsInit(ClassNode cls) {\n \t\t\t\tif (initInsns.size() == 1) {\n \t\t\t\t\tInsnNode insn = initInsns.get(0);\n \t\t\t\t\tif (checkInsn(insn)) {\n+\t\t\t\t\t\tInsnArg arg = insn.getArg(0);\n+\t\t\t\t\t\tif (arg instanceof InsnWrapArg) {\n+\t\t\t\t\t\t\t((InsnWrapArg) arg).getWrapInsn().add(AFlag.DECLARE_VAR);\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tInsnRemover.remove(classInitMth, insn);\n \t\t\t\t\t\taddFieldInitAttr(classInitMth, field, insn);\n \t\t\t\t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInitField.java b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInitField.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInitField.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInitField.java\n@@ -11,7 +11,8 @@ public class TestArrayInitField extends IntegrationTest {\n \n \tpublic static class TestCls {\n \n-\t\tbyte[] bytes = new byte[]{10, 20, 30};\n+\t\tstatic byte[] a = new byte[]{10, 20, 30};\n+\t\tbyte[] b = new byte[]{40, 50, 60};\n \t}\n \n \t@Test\n@@ -20,5 +21,6 @@ public void test() {\n \t\tString code = cls.getCode().toString();\n \n \t\tassertThat(code, containsString(\"= {10, 20, 30};\"));\n+\t\tassertThat(code, containsString(\"= {40, 50, 60};\"));\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitInTryCatch.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitInTryCatch.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitInTryCatch.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitInTryCatch.java\n@@ -82,6 +82,6 @@ public void test3() {\n \t\tClassNode cls = getClassNode(TestCls3.class);\n \t\tString code = cls.getCode().toString();\n \n-\t\tassertThat(code, containsOne(\"public static final String[] a = new String[]{\\\"a\\\"};\"));\n+\t\tassertThat(code, containsOne(\"public static final String[] a = {\\\"a\\\"};\"));\n \t}\n }",
    "output": "Remove static field redundant array type when initialized"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -226,6 +226,9 @@ private void collectClassHierarchy(ClassNode cls, Set<ClassNode> collected) {\n \t}\n \n \tprivate void processClass(ClassNode cls) {\n+\t\tif (isR(cls.getParentClass())) {\n+\t\t\treturn;\n+\t\t}\n \t\tClassInfo clsInfo = cls.getClassInfo();\n \t\tString fullName = getClassFullName(clsInfo);\n \t\tif (!fullName.equals(clsInfo.getFullName())) {\n@@ -559,4 +562,27 @@ public Map<MethodInfo, String> getMthMap() {\n \tpublic PackageNode getRootPackage() {\n \t\treturn rootPackage;\n \t}\n+\n+\tprivate static boolean isR(ClassNode cls) {\n+\t\tif (!cls.getClassInfo().getShortName().equals(\"R\")) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (!cls.getMethods().isEmpty() || !cls.getFields().isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tfor (ClassNode inner : cls.getInnerClasses()) {\n+\t\t\tfor (MethodNode m : inner.getMethods()) {\n+\t\t\t\tif (!m.getMethodInfo().isConstructor() && !m.getMethodInfo().isClassInit()) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor (FieldNode field : cls.getFields()) {\n+\t\t\t\tArgType type = field.getType();\n+\t\t\t\tif (type != ArgType.INT && (!type.isArray() || type.getArrayElement() != ArgType.INT)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n }",
    "output": "Fix don't rename R class in deobfuscation"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java b/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java\n@@ -156,7 +156,7 @@ private FieldNode getResourceField(Integer value, DexNode dex) {\n \t\tString typeName = parts[0];\n \t\tString fieldName = parts[1];\n \t\tfor (ClassNode innerClass : appResClass.getInnerClasses()) {\n-\t\t\tif (innerClass.getShortName().equals(typeName)) {\n+\t\t\tif (innerClass.getClassInfo().getShortName().equals(typeName)) {\n \t\t\t\treturn innerClass.searchFieldByName(fieldName);\n \t\t\t}\n \t\t}",
    "output": "Fix search in resource classes by original name, not by alias"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java\n@@ -165,6 +165,10 @@ private static void moveCommonFieldsInit(ClassNode cls) {\n \t\t// all checks passed\n \t\tfor (InitInfo info : infoList) {\n \t\t\tfor (InsnNode putInsn : info.getPutInsns()) {\n+\t\t\t\tInsnArg arg = putInsn.getArg(0);\n+\t\t\t\tif (arg instanceof InsnWrapArg) {\n+\t\t\t\t\t((InsnWrapArg) arg).getWrapInsn().add(AFlag.DECLARE_VAR);\n+\t\t\t\t}\n \t\t\t\tInsnRemover.remove(info.getConstrMth(), putInsn);\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInitField.java b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInitField.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInitField.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInitField.java\n@@ -0,0 +1,24 @@\n+package jadx.tests.integration.arrays;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestArrayInitField extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tbyte[] bytes = new byte[]{10, 20, 30};\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"= {10, 20, 30};\"));\n+\t}\n+}",
    "output": "Remove field redundant array type when initialized"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n@@ -1,30 +1,33 @@\n package jadx.core.utils.files;\n \n+import static jadx.core.utils.files.FileUtils.isApkFile;\n+import static jadx.core.utils.files.FileUtils.isZipDexFile;\n+\n import java.io.File;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.List;\n import java.util.jar.JarOutputStream;\n import java.util.zip.ZipEntry;\n import java.util.zip.ZipFile;\n \n-import com.android.dex.Dex;\n import org.apache.commons.io.IOUtils;\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.android.dex.Dex;\n+\n import jadx.core.utils.AsmUtils;\n import jadx.core.utils.exceptions.DecodeException;\n import jadx.core.utils.exceptions.JadxException;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n-import static jadx.core.utils.files.FileUtils.isApkFile;\n-import static jadx.core.utils.files.FileUtils.isZipDexFile;\n-\n public class InputFile {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(InputFile.class);\n \n@@ -52,7 +55,9 @@ private void searchDexFiles(boolean skipSources) throws IOException, DecodeExcep\n \t\t\treturn;\n \t\t}\n \t\tif (fileName.endsWith(\".class\")) {\n-\t\t\taddDexFile(loadFromClassFile(file));\n+\t\t\tfor (Dex dex : loadFromClassFile(file)) {\n+\t\t\t\taddDexFile(dex);\n+\t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif (isApkFile(file) || isZipDexFile(file)) {\n@@ -65,7 +70,9 @@ private void searchDexFiles(boolean skipSources) throws IOException, DecodeExcep\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tif (fileName.endsWith(\".jar\")) {\n-\t\t\t\taddDexFile(loadFromJar(file));\n+\t\t\t\tfor (Dex dex : loadFromJar(file.toPath())) {\n+\t\t\t\t\taddDexFile(dex);\n+\t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tif (fileName.endsWith(\".aar\")) {\n@@ -116,11 +123,11 @@ private boolean loadFromZip(String ext) throws IOException, DecodeException {\n \n \t\t\t\t\t\t\tcase \".jar\":\n \t\t\t\t\t\t\t\tindex++;\n-\t\t\t\t\t\t\t\tFile jarFile = FileUtils.createTempFile(entryName);\n-\t\t\t\t\t\t\t\ttry (FileOutputStream fos = new FileOutputStream(jarFile)) {\n-\t\t\t\t\t\t\t\t\tIOUtils.copy(inputStream, fos);\n+\t\t\t\t\t\t\t\tPath jarFile = Files.createTempFile(entryName, \".jar\");\n+\t\t\t\t\t\t\t\tFiles.copy(inputStream, jarFile);\n+\t\t\t\t\t\t\t\tfor (Dex dex : loadFromJar(jarFile)) {\n+\t\t\t\t\t\t\t\t\taddDexFile(entryName, dex);\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\taddDexFile(entryName, loadFromJar(jarFile));\n \t\t\t\t\t\t\t\tbreak;\n \n \t\t\t\t\t\t\tdefault:\n@@ -155,15 +162,19 @@ private Dex makeDexBuf(String entryName, InputStream inputStream) {\n \t\t}\n \t}\n \n-\tprivate static Dex loadFromJar(File jarFile) throws DecodeException {\n+\tprivate static List<Dex> loadFromJar(Path jar) throws DecodeException {\n \t\tJavaToDex j2d = new JavaToDex();\n \t\ttry {\n-\t\t\tLOG.info(\"converting to dex: {} ...\", jarFile.getName());\n-\t\t\tbyte[] ba = j2d.convert(jarFile.getAbsolutePath());\n-\t\t\tif (ba.length == 0) {\n+\t\t\tLOG.info(\"converting to dex: {} ...\", jar.getFileName());\n+\t\t\tList<byte[]> byteList = j2d.convert(jar);\n+\t\t\tif (byteList.isEmpty()) {\n \t\t\t\tthrow new JadxException(\"Empty dx output\");\n \t\t\t}\n-\t\t\treturn new Dex(ba);\n+\t\t\tList<Dex> dexList = new ArrayList<>(byteList.size());\n+\t\t\tfor (byte[] b : byteList) {\n+\t\t\t\tdexList.add(new Dex(b));\n+\t\t\t}\n+\t\t\treturn dexList;\n \t\t} catch (Exception e) {\n \t\t\tthrow new DecodeException(\"java class to dex conversion error:\\n \" + e.getMessage(), e);\n \t\t} finally {\n@@ -173,9 +184,9 @@ private static Dex loadFromJar(File jarFile) throws DecodeException {\n \t\t}\n \t}\n \n-\tprivate static Dex loadFromClassFile(File file) throws IOException, DecodeException {\n-\t\tFile outFile = FileUtils.createTempFile(\"cls.jar\");\n-\t\ttry (JarOutputStream jo = new JarOutputStream(new FileOutputStream(outFile))) {\n+\tprivate static List<Dex> loadFromClassFile(File file) throws IOException, DecodeException {\n+\t\tPath outFile = Files.createTempFile(\"cls\", \".jar\");\n+\t\ttry (JarOutputStream jo = new JarOutputStream(Files.newOutputStream(outFile))) {\n \t\t\tString clsName = AsmUtils.getNameFromClassFile(file);\n \t\t\tif (clsName == null || !ZipSecurity.isValidZipEntryName(clsName)) {\n \t\t\t\tthrow new IOException(\"Can't read class name from file: \" + file);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java b/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java\n@@ -1,6 +1,11 @@\n package jadx.core.utils.files;\n \n import java.io.ByteArrayOutputStream;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n \n import com.android.dx.command.dexer.DxContext;\n import com.android.dx.command.dexer.Main;\n@@ -13,11 +18,12 @@ public class JavaToDex {\n \tprivate static final String CHARSET_NAME = \"UTF-8\";\n \n \tprivate static class DxArgs extends Arguments {\n-\t\tpublic DxArgs(DxContext context, String dexFile, String[] input) {\n+\t\tpublic DxArgs(DxContext context, String dexDir, String[] input) {\n \t\t\tsuper(context);\n-\t\t\toutName = dexFile;\n+\t\t\toutName = dexDir;\n \t\t\tfileNames = input;\n \t\t\tjarOutput = false;\n+\t\t\tmultiDex = true;\n \n \t\t\toptimize = true;\n \t\t\tlocalInfo = true;\n@@ -31,17 +37,29 @@ public DxArgs(DxContext context, String dexFile, String[] input) {\n \n \tprivate String dxErrors;\n \n-\tpublic byte[] convert(String javaFile) throws JadxException {\n+\tpublic List<byte[]> convert(Path jar) throws JadxException {\n \t\ttry (ByteArrayOutputStream out = new ByteArrayOutputStream();\n \t\t     ByteArrayOutputStream errOut = new ByteArrayOutputStream()) {\n \t\t\tDxContext context = new DxContext(out, errOut);\n-\t\t\tDxArgs args = new DxArgs(context, \"-\", new String[]{javaFile});\n-\t\t\tint result = (new Main(context)).runDx(args);\n+\t\t\tPath dir = Files.createTempDirectory(\"jadx\");\n+\t\t\tDxArgs args = new DxArgs(\n+\t\t\t\t\tcontext,\n+\t\t\t\t\tdir.toAbsolutePath().toString(),\n+\t\t\t\t\tnew String[]{jar.toAbsolutePath().toString()});\n+\t\t\tint result = new Main(context).runDx(args);\n \t\t\tdxErrors = errOut.toString(CHARSET_NAME);\n \t\t\tif (result != 0) {\n \t\t\t\tthrow new JadxException(\"Java to dex conversion error, code: \" + result);\n \t\t\t}\n-\t\t\treturn out.toByteArray();\n+\t\t\tList<byte[]> list = new ArrayList<>();\n+\t        try (DirectoryStream<Path> ds = Files.newDirectoryStream(dir)) {\n+\t            for (Path child : ds) {\n+\t            \tlist.add(Files.readAllBytes(child));\n+\t            \tFiles.delete(child);\n+\t            }\n+\t        }\n+\t        Files.delete(dir);\n+\t        return list;\n \t\t} catch (Exception e) {\n \t\t\tthrow new JadxException(\"dx exception: \" + e.getMessage(), e);\n \t\t}",
    "output": "Fix handle big .jar files (using multi-dex option)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -532,8 +532,10 @@ private void fallbackOnlyInsn(InsnNode insn) throws CodegenException {\n \t}\n \n \tprivate void filledNewArray(FilledNewArrayNode insn, CodeWriter code) throws CodegenException {\n-\t\tcode.add(\"new \");\n-\t\tuseType(code, insn.getArrayType());\n+\t\tif (!insn.contains(AFlag.DECLARE_VAR)) {\n+\t\t\tcode.add(\"new \");\n+\t\t\tuseType(code, insn.getArrayType());\n+\t\t}\n \t\tcode.add('{');\n \t\tint c = insn.getArgsCount();\n \t\tfor (int i = 0; i < c; i++) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInit.java b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInit.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInit.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInit.java\n@@ -0,0 +1,34 @@\n+package jadx.tests.integration.arrays;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestArrayInit extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tbyte[] bytes;\n+\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tpublic void test() {\n+\t\t\tbyte[] arr = new byte[]{10, 20, 30};\n+\t\t}\n+\n+\t\tpublic void test2() {\n+\t\t\tbytes = new byte[]{10, 20, 30};\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"= {10, 20, 30};\"));\n+\t\tassertThat(code, containsString(\"this.bytes = new byte[]{10, 20, 30};\"));\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inline/TestInline2.java b/jadx-core/src/test/java/jadx/tests/integration/inline/TestInline2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inline/TestInline2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inline/TestInline2.java\n@@ -29,7 +29,7 @@ public void test() {\n \t\tClassNode cls = getClassNode(TestCls.class);\n \t\tString code = cls.getCode().toString();\n \n-\t\tassertThat(code, containsOne(\"int[] a = new int[]{1, 2, 4, 6, 8};\"));\n+\t\tassertThat(code, containsOne(\"int[] a = {1, 2, 4, 6, 8};\"));\n \t\tassertThat(code, containsOne(\"for (int i = 0; i < a.length; i += 2) {\"));\n \t\tassertThat(code, containsOne(\"for (long i2 = (long) b; i2 > 0; i2--) {\"));\n \t}",
    "output": "Remove redundant array type when initialized with declaration"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java\n@@ -91,11 +91,13 @@ public void saveAs(Path path) {\n \t}\n \n \tpublic void save() {\n-\t\ttry (BufferedWriter writer = Files.newBufferedWriter(getProjectPath())) {\n-\t\t\twriter.write(GSON.toJson(this));\n-\t\t\tsaved = true;\n-\t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Error saving project\", e);\n+\t\tif (getProjectPath() != null) {\n+\t\t\ttry (BufferedWriter writer = Files.newBufferedWriter(getProjectPath())) {\n+\t\t\t\twriter.write(GSON.toJson(this));\n+\t\t\t\tsaved = true;\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tLOG.error(\"Error saving project\", e);\n+\t\t\t}\n \t\t}\n \t}",
    "output": "Fix NPE if the autosave is enabled and project is initial"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n@@ -6,10 +6,12 @@\n import java.util.List;\n import java.util.Objects;\n \n+import org.jetbrains.annotations.Nullable;\n+\n import com.android.dx.io.instructions.DecodedInstruction;\n import com.rits.cloning.Cloner;\n-import org.jetbrains.annotations.Nullable;\n \n+import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.nodes.LineAttrNode;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.args.ArgType;\n@@ -195,6 +197,12 @@ public boolean isConstInsn() {\n \t}\n \n \tpublic boolean canReorder() {\n+\t\tif (contains(AFlag.DONT_GENERATE)) {\n+\t\t\tif (getType() == InsnType.MONITOR_EXIT) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t}\n \t\tswitch (getType()) {\n \t\t\tcase CONST:\n \t\t\tcase CONST_STR:\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestFinally2.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestFinally2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestFinally2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestFinally2.java\n@@ -6,7 +6,6 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.tests.api.IntegrationTest;\n \n@@ -59,14 +58,7 @@ public void test() {\n \t\tString code = cls.getCode().toString();\n \n \t\tassertThat(code, containsOne(\"decode(inputStream);\"));\n-\t}\n-\n-\t@Test\n-\t@NotYetImplemented\n-\tpublic void test2() {\n-\t\tClassNode cls = getClassNode(TestCls.class);\n-\t\tString code = cls.getCode().toString();\n-\n+\t\tassertThat(code, containsOne(\"return new Result(400);\"));\n \t\tassertThat(code, not(containsOne(\"result =\")));\n \t}\n }",
    "output": "Fix ignore not generated insns in CodeShrinker visitor"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/ArithOp.java b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithOp.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/ArithOp.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithOp.java\n@@ -25,4 +25,10 @@ public String getSymbol() {\n \t\treturn this.symbol;\n \t}\n \n+\tpublic boolean noWrapWith(ArithOp other) {\n+\t\treturn (this == ADD && other == ADD)\n+\t\t\t\t|| (this == MUL && other == MUL)\n+\t\t\t\t|| (this == AND && other == AND)\n+\t\t\t\t|| (this == OR && other == OR);\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n@@ -9,6 +9,8 @@\n import org.slf4j.LoggerFactory;\n \n import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.instructions.ArithNode;\n+import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.utils.InsnUtils;\n \n@@ -111,6 +113,12 @@ public InsnArg wrapInstruction(InsnNode insn) {\n \t\tinsn.add(AFlag.WRAPPED);\n \t\tInsnArg arg = wrapArg(insn);\n \t\tparent.setArg(i, arg);\n+\n+\t\tif (insn.getType() == InsnType.ARITH && parent.getType() == InsnType.ARITH\n+\t\t\t\t&& ((ArithNode) insn).getOp().noWrapWith(((ArithNode) parent).getOp())) {\n+\t\t\tinsn.add(AFlag.DONT_WRAP);\n+\t\t}\n+\n \t\treturn arg;\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/arith/TestArith2.java b/jadx-core/src/test/java/jadx/tests/integration/arith/TestArith2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/arith/TestArith2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/arith/TestArith2.java\n@@ -6,7 +6,6 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.tests.api.IntegrationTest;\n \n@@ -21,6 +20,22 @@ public int test1(int a) {\n \t\tpublic int test2(int a, int b, int c) {\n \t\t\treturn a + b + c;\n \t\t}\n+\n+\t\tpublic boolean test3(boolean a, boolean b, boolean c) {\n+\t\t\treturn a | b | c;\n+\t\t}\n+\n+\t\tpublic boolean test4(boolean a, boolean b, boolean c) {\n+\t\t\treturn a & b & c;\n+\t\t}\n+\n+\t\tpublic int substract(int a, int b, int c) {\n+\t\t\treturn a - (b - c);\n+\t\t}\n+\n+\t\tpublic int divide(int a, int b, int c) {\n+\t\t\treturn a / (b / c);\n+\t\t}\n \t}\n \n \t@Test\n@@ -30,15 +45,20 @@ public void test() {\n \n \t\tassertThat(code, containsString(\"return (a + 2) * 3;\"));\n \t\tassertThat(code, not(containsString(\"a + 2 * 3\")));\n-\t}\n-\n-\t@Test\n-\t@NotYetImplemented\n-\tpublic void test2() {\n-\t\tClassNode cls = getClassNode(TestCls.class);\n-\t\tString code = cls.getCode().toString();\n \n \t\tassertThat(code, containsString(\"return a + b + c;\"));\n \t\tassertThat(code, not(containsString(\"return (a + b) + c;\")));\n+\n+\t\tassertThat(code, containsString(\"return a | b | c;\"));\n+\t\tassertThat(code, not(containsString(\"return (a | b) | c;\")));\n+\n+\t\tassertThat(code, containsString(\"return a & b & c;\"));\n+\t\tassertThat(code, not(containsString(\"return (a & b) & c;\")));\n+\n+\t\tassertThat(code, containsString(\"return a - (b - c);\"));\n+\t\tassertThat(code, not(containsString(\"return a - b - c;\")));\n+\n+\t\tassertThat(code, containsString(\"return a / (b / c);\"));\n+\t\tassertThat(code, not(containsString(\"return a / b / c;\")));\n \t}\n }",
    "output": "Remove redundant wrapping for same arith operations"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -214,6 +214,9 @@ private void parseEntry(PackageChunk pkg, int typeId, int entryId, EntryConfig c\n \t\tint size = is.readInt16();\n \t\tint flags = is.readInt16();\n \t\tint key = is.readInt32();\n+\t\tif (key == -1) {\n+\t\t\treturn;\n+\t\t}\n \n \t\tint resRef = pkg.getId() << 24 | typeId << 16 | entryId;\n \t\tString typeName = pkg.getTypeStrings()[typeId - 1];",
    "output": "Fix ignore resource entry with -1 key"
  },
  {
    "input": "diff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryAfterDeclaration.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryAfterDeclaration.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryAfterDeclaration.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryAfterDeclaration.java\n@@ -13,7 +13,20 @@\n import static jadx.tests.api.utils.JadxMatchers.containsOne;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n-public class TryAfterDeclaration extends IntegrationTest {\n+public class TestTryAfterDeclaration extends IntegrationTest {\n+\n+\tstatic class TestClass {\n+\t\tpublic static void consume() throws IOException {\n+\t\t\tInputStream bis = null;\n+\t\t\ttry {\n+\t\t\t\tbis = new FileInputStream(\"1.txt\");\n+\t\t\t\twhile (bis != null) {\n+\t\t\t\t\tSystem.out.println(\"c\");\n+\t\t\t\t}\n+\t\t\t} catch (final IOException e) {\n+\t\t\t}\n+\t\t}\n+\t}\n \n \t/**\n \t * Issue #62.\n@@ -28,16 +41,4 @@ public void test62() {\n \t}\n }\n \n-class TestClass {\n-\tpublic static void consume() throws IOException {\n-\t\tInputStream bis = null;\n-\t\ttry {\n-\t\t\tbis = new FileInputStream(\"1.txt\");\n-\t\t\twhile (bis != null) {\n-\t\t\t\tSystem.out.println(\"c\");\n-\t\t\t}\n-\t\t} catch (final IOException e) {\n-\t\t}\n-\t}\n-}",
    "output": "Fix move test class and rename GUI message"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -49,12 +49,36 @@ public void visit(MethodNode mth) {\n \t\t\tfor (int i = 0; i < list.size(); i++) {\n \t\t\t\tInsnNode modInsn = simplifyInsn(mth, list.get(i));\n \t\t\t\tif (modInsn != null) {\n+\t\t\t\t\tif (i != 0 && modInsn.contains(AFlag.ARITH_ONEARG)) {\n+\n+\t\t\t\t\t\tInsnNode mergedNode = simplifyOneArgConsecutive(\n+\t\t\t\t\t\t\t\tlist.get(i - 1), list.get(i), (ArithNode) modInsn);\n+\n+\t\t\t\t\t\tif (mergedNode != null) {\n+\t\t\t\t\t\t\tlist.remove(i - 1);\n+\t\t\t\t\t\t\tmodInsn = mergedNode;\n+\t\t\t\t\t\t\ti--;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t\tlist.set(i, modInsn);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n+\tprivate static InsnNode simplifyOneArgConsecutive(InsnNode insn1, InsnNode insn2, ArithNode modInsn) {\n+\t\tif (insn1.getType() == InsnType.IGET\n+\t\t\t\t&& insn2.getType() == InsnType.IPUT\n+\t\t\t\t&& insn1.getResult().getSVar().getUseCount() == 2\n+\t\t\t\t&& insn2.getArg(1).equals(insn1.getResult())) {\n+\n+\t\t\tFieldInfo field = (FieldInfo) ((IndexInsnNode) insn2).getIndex();\n+\t\t\tFieldArg fArg = new FieldArg(field, new InsnWrapArg(insn1));\n+\t\t\treturn new ArithNode(modInsn.getOp(), fArg, modInsn.getArg(1));\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \tprivate static InsnNode simplifyInsn(MethodNode mth, InsnNode insn) {\n \t\tif (insn.contains(AFlag.DONT_GENERATE)) {\n \t\t\treturn null;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/arith/TestFieldIncrement2.java b/jadx-core/src/test/java/jadx/tests/integration/arith/TestFieldIncrement2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/arith/TestFieldIncrement2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/arith/TestFieldIncrement2.java\n@@ -2,7 +2,6 @@\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.tests.api.IntegrationTest;\n \n@@ -33,15 +32,6 @@ public void test() {\n \t\tString code = cls.getCode().toString();\n \n \t\tassertThat(code, containsString(\"this.a.f += n;\"));\n-\t\tassertThat(code, containsString(\"a2.f *= n;\"));\n-\t}\n-\n-\t@Test\n-\t@NotYetImplemented\n-\tpublic void test2() {\n-\t\tClassNode cls = getClassNode(TestCls.class);\n-\t\tString code = cls.getCode().toString();\n-\n \t\tassertThat(code, containsString(\"this.a.f *= n;\"));\n \t}\n }",
    "output": "Fix field increment"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n@@ -125,6 +125,7 @@ private static boolean checkForIndexedLoop(MethodNode mth, LoopRegion loopRegion\n \t\t// all checks passed\n \t\tinitInsn.add(AFlag.DONT_GENERATE);\n \t\tincrInsn.add(AFlag.DONT_GENERATE);\n+\n \t\tLoopType arrForEach = checkArrayForEach(mth, loopRegion, initInsn, incrInsn, condition);\n \t\tif (arrForEach != null) {\n \t\t\tloopRegion.setType(arrForEach);\n@@ -281,6 +282,8 @@ private static boolean checkIterableForEach(MethodNode mth, LoopRegion loopRegio\n \t\t}\n \n \t\tassignInsn.add(AFlag.DONT_GENERATE);\n+\t\tassignInsn.getResult().add(AFlag.DONT_GENERATE);\n+\n \t\tfor (InsnNode insnNode : toSkip) {\n \t\t\tinsnNode.add(AFlag.DONT_GENERATE);\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/CollectUsageRegionVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/CollectUsageRegionVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/CollectUsageRegionVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/CollectUsageRegionVisitor.java\n@@ -18,13 +18,8 @@\n import jadx.core.dex.visitors.regions.TracedRegionVisitor;\n \n class CollectUsageRegionVisitor extends TracedRegionVisitor {\n-\tprivate final List<RegisterArg> args;\n-\tprivate final Map<SSAVar, VarUsage> usageMap;\n-\n-\tpublic CollectUsageRegionVisitor() {\n-\t\tthis.usageMap = new LinkedHashMap<>();\n-\t\tthis.args = new ArrayList<>();\n-\t}\n+\tprivate final List<RegisterArg> args = new ArrayList<>();\n+\tprivate final Map<SSAVar, VarUsage> usageMap = new LinkedHashMap<>();\n \n \tpublic Map<SSAVar, VarUsage> getUsageMap() {\n \t\treturn usageMap;\n@@ -37,9 +32,6 @@ public void processBlockTraced(MethodNode mth, IBlock block, IRegion curRegion)\n \t\tint len = block.getInstructions().size();\n \t\tfor (int i = 0; i < len; i++) {\n \t\t\tInsnNode insn = block.getInstructions().get(i);\n-\t\t\tif (insn.contains(AFlag.DONT_GENERATE)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n \t\t\tprocessInsn(insn, usePlace);\n \t\t}\n \t}\n@@ -73,11 +65,10 @@ void processInsn(InsnNode insn, UsePlace usePlace) {\n \t\targs.clear();\n \t\tinsn.getRegisterArgs(args);\n \t\tfor (RegisterArg arg : args) {\n-\t\t\tif (arg.contains(AFlag.DONT_GENERATE)) {\n-\t\t\t\tcontinue;\n+\t\t\tif (!arg.contains(AFlag.DONT_GENERATE)) {\n+\t\t\t\tVarUsage usage = getUsage(arg.getSVar());\n+\t\t\t\tusage.getUses().add(usePlace);\n \t\t\t}\n-\t\t\tVarUsage usage = getUsage(arg.getSVar());\n-\t\t\tusage.getUses().add(usePlace);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables7.java b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables7.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables7.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables7.java\n@@ -1,38 +0,0 @@\n-package jadx.tests.integration.variables;\n-\n-import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.hamcrest.Matchers.containsString;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import org.junit.jupiter.api.Test;\n-\n-import jadx.NotYetImplemented;\n-import jadx.core.dex.nodes.ClassNode;\n-import jadx.tests.api.IntegrationTest;\n-\n-public class TestVariables7 extends IntegrationTest {\n-\n-\tpublic static class TestCls {\n-\n-\t\tpublic void test() {\n-\t\t\tList list;\n-\t\t\tsynchronized (this) {\n-\t\t\t\tlist = new ArrayList();\n-\t\t\t}\n-\t\t\tfor (Object o : list) {\n-\t\t\t\tSystem.out.println(o);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Test\n-\t@NotYetImplemented\n-\tpublic void test() {\n-\t\tClassNode cls = getClassNode(TestCls.class);\n-\t\tString code = cls.getCode().toString();\n-\n-\t\tassertThat(code, containsString(\"     list = new ArrayList\"));\n-\t}\n-}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesUsageWithLoops.java b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesUsageWithLoops.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesUsageWithLoops.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesUsageWithLoops.java\n@@ -0,0 +1,57 @@\n+package jadx.tests.integration.variables;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+public class TestVariablesUsageWithLoops extends IntegrationTest {\n+\n+\tpublic static class TestEnhancedFor {\n+\n+\t\tpublic void test() {\n+\t\t\tList list;\n+\t\t\tsynchronized (this) {\n+\t\t\t\tlist = new ArrayList();\n+\t\t\t}\n+\t\t\tfor (Object o : list) {\n+\t\t\t\tSystem.out.println(o);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testEnhancedFor() {\n+\t\tClassNode cls = getClassNode(TestEnhancedFor.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"     list = new ArrayList\"));\n+\t}\n+\n+\tpublic static class TestForLoop {\n+\n+\t\tpublic void test() {\n+\t\t\tList list;\n+\t\t\tsynchronized (this) {\n+\t\t\t\tlist = new ArrayList();\n+\t\t\t}\n+\t\t\tfor (int i = 0; i < list.size(); i++) {\n+\t\t\t\tSystem.out.println(i);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testForLoop() {\n+\t\tClassNode cls = getClassNode(TestForLoop.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"     list = new ArrayList\"));\n+\t}\n+}",
    "output": "Fix variable usage with enhanced for loop"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/Jadx.java b/jadx-core/src/main/java/jadx/core/Jadx.java\n--- a/jadx-core/src/main/java/jadx/core/Jadx.java\n+++ b/jadx-core/src/main/java/jadx/core/Jadx.java\n@@ -1,5 +1,6 @@\n package jadx.core;\n \n+import java.io.InputStream;\n import java.net.URL;\n import java.util.ArrayList;\n import java.util.Enumeration;\n@@ -126,10 +127,12 @@ public static String getVersion() {\n \t\t\tif (classLoader != null) {\n \t\t\t\tEnumeration<URL> resources = classLoader.getResources(\"META-INF/MANIFEST.MF\");\n \t\t\t\twhile (resources.hasMoreElements()) {\n-\t\t\t\t\tManifest manifest = new Manifest(resources.nextElement().openStream());\n-\t\t\t\t\tString ver = manifest.getMainAttributes().getValue(\"jadx-version\");\n-\t\t\t\t\tif (ver != null) {\n-\t\t\t\t\t\treturn ver;\n+\t\t\t\t\ttry (InputStream is = resources.nextElement().openStream()) {\n+\t\t\t\t\t\tManifest manifest = new Manifest(is);\n+\t\t\t\t\t\tString ver = manifest.getMainAttributes().getValue(\"jadx-version\");\n+\t\t\t\t\t\tif (ver != null) {\n+\t\t\t\t\t\t\treturn ver;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}",
    "output": "Fix close resource"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java\n@@ -33,6 +33,21 @@ private MethodInfo(DexNode dex, int mthIndex) {\n \t\tshortId = makeSignature(true);\n \t}\n \n+\tprivate MethodInfo(ClassInfo declClass, String name, List<ArgType> args, ArgType retType) {\n+\t\tthis.name = name;\n+\t\talias = name;\n+\t\taliasFromPreset = false;\n+\t\tthis.declClass = declClass;\n+\n+\t\tthis.args = args;\n+\t\tthis.retType = retType;\n+\t\tshortId = makeSignature(true);\n+\t}\n+\n+\tpublic static MethodInfo externalMth(ClassInfo declClass, String name, List<ArgType> args, ArgType retType) {\n+\t\treturn new MethodInfo(declClass, name, args, retType);\n+\t}\n+\n \tpublic static MethodInfo fromDex(DexNode dex, int mthIndex) {\n \t\tMethodInfo mth = dex.root().getInfoStorage().getMethod(dex, mthIndex);\n \t\tif (mth != null) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java\n@@ -36,7 +36,7 @@ public InvokeNode(MethodInfo mth, DecodedInstruction insn, InvokeType type, bool\n \t\t}\n \t}\n \n-\tprivate InvokeNode(MethodInfo mth, InvokeType invokeType, int argsCount) {\n+\tpublic InvokeNode(MethodInfo mth, InvokeType invokeType, int argsCount) {\n \t\tsuper(InsnType.INVOKE, argsCount);\n \t\tthis.mth = mth;\n \t\tthis.type = invokeType;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -8,7 +8,9 @@\n import org.slf4j.LoggerFactory;\n \n import jadx.core.Consts;\n+import jadx.core.deobf.NameMapper;\n import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.info.MethodInfo;\n import jadx.core.dex.instructions.ArithNode;\n@@ -19,6 +21,7 @@\n import jadx.core.dex.instructions.IndexInsnNode;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.InvokeNode;\n+import jadx.core.dex.instructions.InvokeType;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.FieldArg;\n import jadx.core.dex.instructions.args.InsnArg;\n@@ -29,6 +32,7 @@\n import jadx.core.dex.nodes.BlockNode;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.regions.conditions.IfCondition;\n \n public class SimplifyVisitor extends AbstractVisitor {\n@@ -95,12 +99,55 @@ private static InsnNode simplifyInsn(MethodNode mth, InsnNode insn) {\n \t\t\t\t}\n \t\t\t\tbreak;\n \n+\t\t\tcase CONSTRUCTOR:\n+\t\t\t\tsimplfyConstructor(mth.root(), (ConstructorInsn) insn);\n+\t\t\t\tbreak;\n+\n \t\t\tdefault:\n \t\t\t\tbreak;\n \t\t}\n \t\treturn null;\n \t}\n \n+\tprivate static void simplfyConstructor(RootNode root, ConstructorInsn insn) {\n+\t\tif (insn.getArgsCount() != 0\n+\t\t\t\t&& insn.getCallMth().getDeclClass().getType().equals(ArgType.STRING)) {\n+\t\t\tInsnArg arg = insn.getArg(0);\n+\t\t\tInsnNode node = arg.isInsnWrap()\n+\t\t\t\t\t? ((InsnWrapArg) arg).getWrapInsn()\n+\t\t\t\t\t: insn;\n+\t\t    if (node.getArgsCount() != 0) {\n+\t\t    \tArgType argType = node.getArg(0).getType();\n+\t\t    \tif (node.getType() == InsnType.FILLED_NEW_ARRAY\n+\t\t    \t\t\t&& (argType == ArgType.BYTE || argType == ArgType.CHAR)) {\n+\t\t    \t\tint printable = 0;\n+\t\t    \t\tbyte[] arr = new byte[node.getArgsCount()];\n+\t\t    \t\tfor (int i = 0; i < arr.length; i++) {\n+\t\t    \t\t\tarr[i] = (byte) ((LiteralArg) node.getArg(i)).getLiteral();\n+\t\t    \t\t\tif (NameMapper.isPrintableChar(arr[i])) {\n+\t\t    \t\t\t\tprintable++;\n+\t\t    \t\t\t}\n+\t\t    \t\t}\n+\t\t    \t\tif (printable >= arr.length - printable) {\n+\t\t    \t\t\tInsnWrapArg wa = new InsnWrapArg(new ConstStringNode(new String(arr)));\n+\t\t    \t\t\tif (insn.getArgsCount() == 1) {\n+\t\t    \t\t\t\tinsn.setArg(0, wa);\n+\t\t    \t\t\t} else {\n+\t\t    \t\t\t\tMethodInfo mi = MethodInfo.externalMth(\n+\t\t    \t\t\t\t\t\tClassInfo.fromType(root, ArgType.STRING),\n+\t\t    \t\t\t\t\t\t\"getBytes\",\n+\t\t    \t\t\t\t\t\tCollections.emptyList(),\n+\t\t    \t\t\t\t\t\tArgType.array(ArgType.BYTE));\n+\t\t    \t\t\t\tInvokeNode in = new InvokeNode(mi, InvokeType.VIRTUAL, 1);\n+\t\t    \t\t\t\tin.addArg(wa);\n+\t\t    \t\t\t\tinsn.setArg(0, new InsnWrapArg(in));\n+\t\t    \t\t\t}\n+\t\t    \t\t}\n+\t\t    \t}\n+\t\t    }\n+\t\t}\n+\t}\n+\n \tprivate static InsnNode processCast(MethodNode mth, InsnNode insn) {\n \t\tInsnArg castArg = insn.getArg(0);\n \t\tArgType argType = castArg.getType();\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConstructor.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConstructor.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConstructor.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestStringConstructor.java\n@@ -0,0 +1,86 @@\n+package jadx.tests.integration.others;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+public class TestStringConstructor extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic String tag = new String(new byte[] {'a', 'b', 'c'});\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"abc\"));\n+\t}\n+\n+\tpublic static class TestCls2 {\n+\t\tpublic String tag = new String(new byte[] {'a', 'b', 'c'}, StandardCharsets.UTF_8);\n+\t}\n+\n+\t@Test\n+\tpublic void test2() {\n+\t\tClassNode cls = getClassNode(TestCls2.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"new String(\\\"abc\\\".getBytes(), StandardCharsets.UTF_8)\"));\n+\t}\n+\n+\tpublic static class TestCls3 {\n+\t\tpublic String tag = new String(new byte[] {1, 2, 3, 'a', 'b', 'c'});\n+\t}\n+\n+\t@Test\n+\tpublic void test3() {\n+\t\tClassNode cls = getClassNode(TestCls3.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"\\\\u0001\\\\u0002\\\\u0003abc\"));\n+\t}\n+\n+\tpublic static class TestCls4 {\n+\t\tpublic String tag = new String(new char[] {1, 2, 3, 'a', 'b', 'c'});\n+\t}\n+\n+\t@Test\n+\tpublic void test4() {\n+\t\tClassNode cls = getClassNode(TestCls4.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"\\\\u0001\\\\u0002\\\\u0003abc\"));\n+\t}\n+\n+\tpublic static class TestCls5 {\n+\t\tpublic String tag = new String(new char[] {1, 2, 3, 'a', 'b'});\n+\t}\n+\n+\t@Test\n+\tpublic void test5() {\n+\t\tClassNode cls = getClassNode(TestCls5.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"{1, 2, 3, 'a', 'b'}\"));\n+\t}\n+\n+\tpublic static class TestClsNegative {\n+\t\tpublic String tag = new String();\n+\t}\n+\n+\t@Test\n+\tpublic void testNegative() {\n+\t\tClassNode cls = getClassNode(TestClsNegative.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"tag = new String();\"));\n+\t}\n+}",
    "output": "Fix better String constructor from byte and char arrays"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -733,6 +733,10 @@ private boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnAr\n \t\t\torigType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);\n \t\t} else {\n \t\t\torigType = arguments.get(origPos).getInitType();\n+\t\t\tif (origType.isGenericType() && !callMth.getParentClass().equals(mth.getParentClass())) {\n+\t\t\t\t// cancel cast\n+\t\t\t\treturn false;\n+\t\t\t}\n \t\t}\n \t\tif (!arg.getType().equals(origType)) {\n \t\t\tcode.add('(');\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvokeWithGenerics.java b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvokeWithGenerics.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvokeWithGenerics.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvokeWithGenerics.java\n@@ -0,0 +1,45 @@\n+package jadx.tests.integration.invoke;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.anyOf;\n+\n+public class TestSuperInvokeWithGenerics extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic class A<T extends Exception, V> {\n+\t\t\tpublic A(T t) {\n+\t\t\t\tSystem.out.println(\"t\" + t);\n+\t\t\t}\n+\n+\t\t\tpublic A(V v) {\n+\t\t\t\tSystem.out.println(\"v\" + v);\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic class B extends A<Exception, String> {\n+\t\t\tpublic B(String s) {\n+\t\t\t\tsuper(s);\n+\t\t\t}\n+\n+\t\t\tpublic B(Exception e) {\n+\t\t\t\tsuper(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"super(e);\"));\n+\t\tassertThat(code, containsOne(\"super(s);\"));\n+\t}\n+}",
    "output": "Fix don't cast overloaded methods with generics from other class"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java\n@@ -97,7 +97,7 @@ public static String formatShort(short s) {\n \t\tif (s == Short.MIN_VALUE) {\n \t\t\treturn \"Short.MIN_VALUE\";\n \t\t}\n-\t\treturn \"(short) \" + s;\n+\t\treturn Short.toString(s);\n \t}\n \n \tpublic static String formatByte(byte b) {\n@@ -107,7 +107,7 @@ public static String formatByte(byte b) {\n \t\tif (b == Byte.MIN_VALUE) {\n \t\t\treturn \"Byte.MIN_VALUE\";\n \t\t}\n-\t\treturn \"(byte) \" + b;\n+\t\treturn Byte.toString(b);\n \t}\n \n \tpublic static String formatInteger(int i) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestRedundantType.java b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestRedundantType.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestRedundantType.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestRedundantType.java\n@@ -0,0 +1,77 @@\n+package jadx.tests.integration.arrays;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestRedundantType extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic byte[] method() {\n+\t        return new byte[]{10, 11, 12};\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"return new byte[]{10, 11, 12};\"));\n+\t}\n+\n+\tpublic static class TestByte {\n+\n+\t\tpublic byte[] method() {\n+\t\t\tbyte[] arr = new byte[50];\n+\t\t\tarr[10] = 126;\n+\t\t\tarr[20] = 127;\n+\t\t\tarr[30] = (byte) 128;\n+\t\t\tarr[40] = (byte) 129;\n+\t        return arr;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testByte() {\n+\t\tClassNode cls = getClassNode(TestByte.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"arr[10] = 126\"));\n+\t\tassertThat(code, containsString(\"arr[20] = Byte.MAX_VALUE\"));\n+\t\tassertThat(code, containsString(\"arr[30] = Byte.MIN_VALUE\"));\n+\t\tassertThat(code, containsString(\"arr[40] = -127\"));\n+\t\tassertEquals(-127, new TestByte().method()[40]);\n+\t}\n+\n+\tpublic static class TestShort {\n+\n+\t\tpublic short[] method() {\n+\t\t\tshort[] arr = new short[50];\n+\t\t\tarr[10] = 32766;\n+\t\t\tarr[20] = 32767;\n+\t\t\tarr[30] = (short) 32768;\n+\t\t\tarr[40] = (short) 32769;\n+\t        return arr;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testShort() {\n+\t\tClassNode cls = getClassNode(TestShort.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\"arr[10] = 32766\"));\n+\t\tassertThat(code, containsString(\"arr[20] = Short.MAX_VALUE\"));\n+\t\tassertThat(code, containsString(\"arr[30] = Short.MIN_VALUE\"));\n+\t\tassertThat(code, containsString(\"arr[40] = -32767\"));\n+\t\tassertEquals(-32767, new TestShort().method()[40]);\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver4.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver4.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver4.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver4.java\n@@ -41,7 +41,7 @@ public void test() {\n \t\tClassNode cls = getClassNode(TestCls.class);\n \t\tString code = cls.getCode().toString();\n \n-\t\tassertThat(code, containsOne(\"(strArray[end] != (byte) 0 || strArray[end + 1] != (byte) 0)\"));\n+\t\tassertThat(code, containsOne(\"(strArray[end] != 0 || strArray[end + 1] != 0)\"));\n \t}\n \n \t@Test",
    "output": "Fix redundant byte and short cast"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -756,7 +756,7 @@ public void menuCanceled(MenuEvent e) {\n \t}\n \n \tprivate class JPackagePopUp extends JPopupMenu {\n-\t\tJMenuItem excludeItem = new JCheckBoxMenuItem(\"Exclude\");\n+\t\tJMenuItem excludeItem = new JCheckBoxMenuItem(NLS.str(\"popup.exclude\"));\n \n \t\tpublic JPackagePopUp(JPackage pkg) {\n \t\t\texcludeItem.setSelected(!pkg.isEnabled());\n\ndiff --git a/jadx-gui/src/test/java/jadx/gui/TestI18n.java b/jadx-gui/src/test/java/jadx/gui/TestI18n.java\n--- a/jadx-gui/src/test/java/jadx/gui/TestI18n.java\n+++ b/jadx-gui/src/test/java/jadx/gui/TestI18n.java\n@@ -0,0 +1,64 @@\n+package jadx.gui;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+public class TestI18n {\n+\n+\tprivate List<String> reference;\n+\tprivate String referenceName;\n+\n+\t@Test\n+\tpublic void filesExactlyMatch() throws IOException {\n+\t\tPath path = Paths.get(\"./src/main/resources/i18n\");\n+\t\tassertTrue(Files.exists(path));\n+\t\tFiles.list(path).forEach(p -> {\n+\t\t\tList<String> lines;\n+\t\t\ttry {\n+\t\t\t\tlines = Files.readAllLines(p);\n+\t\t\t\tif (reference == null) {\n+\t\t\t\t\treference = lines;\n+\t\t\t\t\treferenceName = p.getFileName().toString();\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tcompareToReference(p);\n+\t\t\t\t}\n+\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tAssertions.fail(\"Error \" + e.getMessage());\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate void compareToReference(Path path) throws IOException {\n+\t\tList<String> lines = Files.readAllLines(path);\n+\t\tfor (int i = 0; i < reference.size(); i++) {\n+\t\t\tString line = trimComment(reference.get(i));\n+\t\t\tint p0 = line.indexOf('=');\n+\t\t\tif (p0 != -1) {\n+\t\t\t\tString prefix = line.substring(0, p0 + 1);\n+\t\t\t\tif (i >= lines.size() || !trimComment(lines.get(i)).startsWith(prefix)) {\n+\t\t\t\t\tfail(path, i + 1);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (lines.size() != reference.size()) {\n+\t\t\tfail(path, reference.size());\n+\t\t}\n+\t}\n+\n+\tprivate static String trimComment(String string) {\n+\t\treturn string.startsWith(\"#\") ? string.substring(1) : string;\n+\t}\n+\n+\tprivate void fail(Path path, int line) {\n+\t\tAssertions.fail(\"I18n files \" + path.getFileName() + \" and \" + referenceName + \" differ in line \" + line);\n+\t}\n+}",
    "output": "Add missing translations keys, and ensure all files match"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n--- a/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java\n@@ -7,9 +7,10 @@\n import java.util.LinkedList;\n import java.util.List;\n \n+import jadx.core.dex.instructions.ArithNode;\n+import jadx.core.dex.instructions.ArithOp;\n import jadx.core.dex.instructions.IfNode;\n import jadx.core.dex.instructions.IfOp;\n-import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.args.InsnWrapArg;\n import jadx.core.dex.instructions.args.LiteralArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n@@ -142,7 +143,10 @@ public static IfCondition not(IfCondition cond) {\n \tpublic static IfCondition simplify(IfCondition cond) {\n \t\tif (cond.isCompare()) {\n \t\t\tCompare c = cond.getCompare();\n-\t\t\tsimplifyCmpOp(c);\n+\t\t\tIfCondition i = simplifyCmpOp(c);\n+\t\t\tif (i != null) {\n+\t\t\t\treturn i;\n+\t\t\t}\n \t\t\tif (c.getOp() == IfOp.EQ && c.getB().isLiteral() && c.getB().equals(LiteralArg.FALSE)) {\n \t\t\t\tcond = not(new IfCondition(c.invert()));\n \t\t\t} else {\n@@ -190,20 +194,53 @@ public static IfCondition simplify(IfCondition cond) {\n \t\treturn cond;\n \t}\n \n-\tprivate static void simplifyCmpOp(Compare c) {\n+\tprivate static IfCondition simplifyCmpOp(Compare c) {\n \t\tif (!c.getA().isInsnWrap()) {\n-\t\t\treturn;\n+\t\t\treturn null;\n \t\t}\n-\t\tif (!c.getB().isLiteral() || ((LiteralArg) c.getB()).getLiteral() != 0) {\n-\t\t\treturn;\n+\t\tif (!c.getB().isLiteral()) {\n+\t\t\treturn null;\n \t\t}\n+\t\tlong lit = ((LiteralArg) c.getB()).getLiteral();\n+\t\tif (lit != 0 && lit != 1) {\n+\t\t\treturn null;\n+\t\t}\n+\n \t\tInsnNode wrapInsn = ((InsnWrapArg) c.getA()).getWrapInsn();\n-\t\tInsnType type = wrapInsn.getType();\n-\t\tif (type != InsnType.CMP_L && type != InsnType.CMP_G) {\n-\t\t\treturn;\n+\t\tswitch (wrapInsn.getType()) {\n+\t\t\tcase CMP_L:\n+\t\t\tcase CMP_G:\n+\t\t\t\tif (lit == 0) {\n+\t\t\t\t\tIfNode insn = c.getInsn();\n+\t\t\t\t\tinsn.changeCondition(insn.getOp(), wrapInsn.getArg(0), wrapInsn.getArg(1));\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\n+\t\t\tcase ARITH:\n+\t\t\t\tArithOp arithOp = ((ArithNode) wrapInsn).getOp();\n+\t\t\t\tif (arithOp == ArithOp.OR || arithOp == ArithOp.AND) {\n+\t\t\t\t\tIfOp ifOp = c.getInsn().getOp();\n+\t\t\t\t\tboolean isTrue = ifOp == IfOp.NE && lit == 0\n+\t\t\t\t\t\t\t|| ifOp == IfOp.EQ && lit == 1;\n+\n+\t\t\t\t\tIfOp op = isTrue ? IfOp.NE : IfOp.EQ;\n+\t\t\t\t\tMode mode = isTrue && arithOp == ArithOp.OR ||\n+\t\t\t\t\t\t\t!isTrue && arithOp == ArithOp.AND ? Mode.OR : Mode.AND;\n+\n+\t\t\t\t\tIfNode if1 = new IfNode(op, -1, wrapInsn.getArg(0), LiteralArg.FALSE);\n+\t\t\t\t\tIfNode if2 = new IfNode(op, -1, wrapInsn.getArg(1), LiteralArg.FALSE);\n+\t\t\t\t\treturn new IfCondition(mode,\n+\t\t\t\t\t\t\tArrays.asList(new IfCondition(new Compare(if1)),\n+\t\t\t\t\t\t\t\t\tnew IfCondition(new Compare(if2))));\n+\t\t\t\t}\n+\t\t\tbreak;\n+\n+\t\tdefault:\n+\t\t\tbreak;\n \t\t}\n-\t\tIfNode insn = c.getInsn();\n-\t\tinsn.changeCondition(insn.getOp(), wrapInsn.getArg(0), wrapInsn.getArg(1));\n+\n+\n+\t\treturn null;\n \t}\n \n \tpublic List<RegisterArg> getRegisterArgs() {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBitwiseAnd.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBitwiseAnd.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBitwiseAnd.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBitwiseAnd.java\n@@ -0,0 +1,92 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestBitwiseAnd extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tprivate boolean a;\n+\t\tprivate boolean b;\n+\n+\t\tpublic void test() {\n+\t\t\tif ((a & b) != false) {\n+\t\t\t\ttest();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"if (this.a && this.b) {\"));\n+\t}\n+\n+\tpublic static class TestCls2 {\n+\t\tprivate boolean a;\n+\t\tprivate boolean b;\n+\n+\t\tpublic void test() {\n+\t\t\tif ((a & b) != true) {\n+\t\t\t\ttest();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test2() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls2.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"if (!this.a || !this.b) {\"));\n+\t}\n+\n+\tpublic static class TestCls3 {\n+\t\tprivate boolean a;\n+\t\tprivate boolean b;\n+\n+\t\tpublic void test() {\n+\t\t\tif ((a & b) == false) {\n+\t\t\t\ttest();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test3() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls3.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"if (!this.a || !this.b) {\"));\n+\t}\n+\n+\tpublic static class TestCls4 {\n+\t\tprivate boolean a;\n+\t\tprivate boolean b;\n+\n+\t\tpublic void test() {\n+\t\t\tif ((a & b) == true) {\n+\t\t\t\ttest();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test4() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls4.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"if (this.a && this.b) {\"));\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBitwiseOr.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBitwiseOr.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBitwiseOr.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBitwiseOr.java\n@@ -0,0 +1,92 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+public class TestBitwiseOr extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tprivate boolean a;\n+\t\tprivate boolean b;\n+\n+\t\tpublic void test() {\n+\t\t\tif ((a | b) != false) {\n+\t\t\t\ttest();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"if (this.a || this.b) {\"));\n+\t}\n+\n+\tpublic static class TestCls2 {\n+\t\tprivate boolean a;\n+\t\tprivate boolean b;\n+\n+\t\tpublic void test() {\n+\t\t\tif ((a | b) != true) {\n+\t\t\t\ttest();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test2() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls2.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"if (!this.a && !this.b) {\"));\n+\t}\n+\n+\tpublic static class TestCls3 {\n+\t\tprivate boolean a;\n+\t\tprivate boolean b;\n+\n+\t\tpublic void test() {\n+\t\t\tif ((a | b) == false) {\n+\t\t\t\ttest();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test3() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls3.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"if (!this.a && !this.b) {\"));\n+\t}\n+\n+\tpublic static class TestCls4 {\n+\t\tprivate boolean a;\n+\t\tprivate boolean b;\n+\n+\t\tpublic void test() {\n+\t\t\tif ((a | b) == true) {\n+\t\t\t\ttest();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test4() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls4.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"if (this.a || this.b) {\"));\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions17.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions17.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions17.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestConditions17.java\n@@ -1,33 +0,0 @@\n-package jadx.tests.integration.conditions;\n-\n-import org.junit.jupiter.api.Test;\n-\n-import jadx.NotYetImplemented;\n-import jadx.core.dex.nodes.ClassNode;\n-import jadx.tests.api.IntegrationTest;\n-\n-import static jadx.tests.api.utils.JadxMatchers.containsOne;\n-import static org.hamcrest.MatcherAssert.assertThat;\n-\n-public class TestConditions17 extends IntegrationTest {\n-\n-\tpublic static class TestCls {\n-\t\tprivate boolean a;\n-\t\tprivate boolean b;\n-\n-\t\tpublic void test() {\n-\t\t\tif ((a | b) != false) {\n-\t\t\t\ttest();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Test\n-\t@NotYetImplemented\n-\tpublic void test202() {\n-\t\tClassNode cls = getClassNode(TestCls.class);\n-\t\tString code = cls.getCode().toString();\n-\n-\t\tassertThat(code, containsOne(\"a || b\"));\n-\t}\n-}",
    "output": "Fix handle boolean condition with bitwise OR and AND"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -1,6 +1,9 @@\n package jadx.gui.settings;\n \n-import java.awt.*;\n+import java.awt.Font;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Window;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.HashMap;\n@@ -142,14 +145,25 @@ public void saveWindowPos(Window window) {\n \n \tpublic boolean loadWindowPos(Window window) {\n \t\tWindowLocation pos = windowPos.get(window.getClass().getSimpleName());\n-\t\tif (pos == null) {\n+\t\tif (pos == null || !isContainedInAnyScreen(pos)) {\n \t\t\treturn false;\n \t\t}\n+\n \t\twindow.setLocation(pos.getX(), pos.getY());\n \t\twindow.setSize(pos.getWidth(), pos.getHeight());\n \t\treturn true;\n \t}\n \n+\tprivate static boolean isContainedInAnyScreen(WindowLocation pos) {\n+\t\tfor (GraphicsDevice gd : GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices()) {\n+\t\t\tif (gd.getDefaultConfiguration().getBounds().contains(\n+\t\t\t\t\tpos.getX(), pos.getY(), pos.getWidth(), pos.getHeight())) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \tpublic boolean isShowHeapUsageBar() {\n \t\treturn showHeapUsageBar;\n \t}",
    "output": "Fix detect if a window is opened inside a visible screen"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -50,19 +50,23 @@ public void init(RootNode root) {\n \t}\n \n \tprivate void checkClasses(RootNode root, boolean caseSensitive) {\n-\t\tSet<String> clsNames = new HashSet<>();\n-\t\tfor (ClassNode cls : root.getClasses(true)) {\n+\t\tList<ClassNode> classes = root.getClasses(true);\n+\t\tfor (ClassNode cls : classes) {\n \t\t\tcheckClassName(cls);\n \t\t\tcheckFields(cls);\n \t\t\tcheckMethods(cls);\n-\t\t\tif (!caseSensitive) {\n-\t\t\t\tClassInfo classInfo = cls.getClassInfo();\n-\t\t\t\tString clsFileName = classInfo.getAlias().getFullPath();\n-\t\t\t\tif (!clsNames.add(clsFileName.toLowerCase())) {\n+\t\t}\n+\t\tif (!caseSensitive) {\n+\t\t\tSet<String> clsFullPaths = new HashSet<>(classes.size());\n+\t\t\tfor (ClassNode cls : classes) {\n+\t\t\t\tClassInfo clsInfo = cls.getClassInfo();\n+\t\t\t\tClassInfo aliasClsInfo = clsInfo.getAlias();\n+\t\t\t\tif (!clsFullPaths.add(aliasClsInfo.getFullPath().toLowerCase())) {\n \t\t\t\t\tString newShortName = deobfuscator.getClsAlias(cls);\n-\t\t\t\t\tString newFullName = classInfo.makeFullClsName(newShortName, true);\n-\t\t\t\t\tclassInfo.rename(cls.root(), newFullName);\n-\t\t\t\t\tclsNames.add(classInfo.getAlias().getFullPath().toLowerCase());\n+\t\t\t\t\tString newFullName = aliasClsInfo.makeFullClsName(newShortName, true);\n+\n+\t\t\t\t\tclsInfo.rename(root, newFullName);\n+\t\t\t\t\tclsFullPaths.add(clsInfo.getAlias().getFullPath().toLowerCase());\n \t\t\t\t}\n \t\t\t}\n \t\t}",
    "output": "Use alias as a base for class rename if file system is case sensitive"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java\n@@ -57,7 +57,8 @@ public ArgType getType() {\n \t\tif (sVar != null) {\n \t\t\treturn sVar.getTypeInfo().getType();\n \t\t}\n-\t\tthrow new JadxRuntimeException(\"Register type unknown, SSA variable not initialized: r\" + regNum);\n+\t\tLOG.warn(\"Register type unknown, SSA variable not initialized: r{}\", regNum);\n+\t\treturn type;\n \t}\n \n \tpublic ArgType getInitType() {",
    "output": "Fix change exception to soft warning for getType in RegisterArg"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -277,7 +277,8 @@ private void makeInsnBody(CodeWriter code, InsnNode insn, Set<Flags> state) thro\n \t\t\t\tbreak;\n \n \t\t\tcase NOT:\n-\t\t\t\toneArgInsn(code, insn, state, '~');\n+\t\t\t\tchar op = insn.getArg(0).getType() == ArgType.BOOLEAN ? '!' : '~';\n+\t\t\t\toneArgInsn(code, insn, state, op);\n \t\t\t\tbreak;\n \n \t\t\tcase RETURN:\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -4,18 +4,26 @@\n import java.util.Collections;\n import java.util.List;\n \n-import jadx.core.dex.instructions.*;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import jadx.core.Consts;\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.info.MethodInfo;\n+import jadx.core.dex.instructions.ArithNode;\n+import jadx.core.dex.instructions.ArithOp;\n+import jadx.core.dex.instructions.CallMthInterface;\n+import jadx.core.dex.instructions.ConstStringNode;\n+import jadx.core.dex.instructions.IfNode;\n+import jadx.core.dex.instructions.IndexInsnNode;\n+import jadx.core.dex.instructions.InsnType;\n+import jadx.core.dex.instructions.InvokeNode;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.FieldArg;\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.InsnWrapArg;\n import jadx.core.dex.instructions.args.LiteralArg;\n+import jadx.core.dex.instructions.args.RegisterArg;\n import jadx.core.dex.instructions.mods.ConstructorInsn;\n import jadx.core.dex.instructions.mods.TernaryInsn;\n import jadx.core.dex.nodes.BlockNode;\n@@ -54,7 +62,7 @@ private static InsnNode simplifyInsn(MethodNode mth, InsnNode insn) {\n \t\t}\n \t\tswitch (insn.getType()) {\n \t\t\tcase ARITH:\n-\t\t\t\treturn simplifyArith(insn);\n+\t\t\t\treturn simplifyArith((ArithNode) insn);\n \n \t\t\tcase IF:\n \t\t\t\tsimplifyIf((IfNode) insn);\n@@ -64,7 +72,7 @@ private static InsnNode simplifyInsn(MethodNode mth, InsnNode insn) {\n \t\t\t\tbreak;\n \n \t\t\tcase INVOKE:\n-\t\t\t\treturn convertInvoke(mth, insn);\n+\t\t\t\treturn convertInvoke(mth, (InvokeNode) insn);\n \n \t\t\tcase IPUT:\n \t\t\tcase SPUT:\n@@ -151,8 +159,8 @@ private static void simplifyTernary(TernaryInsn insn) {\n \t * @param insn\n \t * @return\n \t */\n-\tprivate static InsnNode convertInvoke(MethodNode mth, InsnNode insn) {\n-\t\tMethodInfo callMth = ((InvokeNode) insn).getCallMth();\n+\tprivate static InsnNode convertInvoke(MethodNode mth, InvokeNode insn) {\n+\t\tMethodInfo callMth = insn.getCallMth();\n \n \t\t// If this is a 'new StringBuilder(xxx).append(yyy).append(zzz).toString(),\n \t\t// convert it to STRING_CONCAT pseudo instruction.\n@@ -225,8 +233,7 @@ private static InsnNode convertInvoke(MethodNode mth, InsnNode insn) {\n \t\treturn null;\n \t}\n \n-\tprivate static InsnNode simplifyArith(InsnNode insn) {\n-\t\tArithNode arith = (ArithNode) insn;\n+\tprivate static InsnNode simplifyArith(ArithNode arith) {\n \t\tif (arith.getArgsCount() != 2) {\n \t\t\treturn null;\n \t\t}\n@@ -245,9 +252,17 @@ private static InsnNode simplifyArith(InsnNode insn) {\n \t\t\t// fix 'c + (-1)' => 'c - (1)'\n \t\t\tif (arith.getOp() == ArithOp.ADD && lit < 0) {\n \t\t\t\treturn new ArithNode(ArithOp.SUB,\n-\t\t\t\t\t\tarith.getResult(), insn.getArg(0),\n+\t\t\t\t\t\tarith.getResult(), arith.getArg(0),\n \t\t\t\t\t\tInsnArg.lit(-lit, litArg.getType()));\n \t\t\t}\n+\t\t\tInsnArg firstArg = arith.getArg(0);\n+\t\t\tif (arith.getOp() == ArithOp.XOR && firstArg.getType() == ArgType.BOOLEAN\n+\t\t\t\t\t&& (lit == 0 || lit == 1)) {\n+\t\t\t\tInsnNode node = new InsnNode(lit == 0 ? InsnType.MOVE : InsnType.NOT, 1);\n+\t\t\t\tnode.setResult(arith.getResult());\n+\t\t\t\tnode.addArg(firstArg);\n+\t\t\t\treturn node;\n+\t\t\t}\n \t\t}\n \t\treturn null;\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestXor.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestXor.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestXor.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestXor.java\n@@ -1,34 +1,58 @@\n package jadx.tests.integration.conditions;\n \n import static jadx.tests.api.utils.JadxMatchers.containsOne;\n-import static org.hamcrest.CoreMatchers.not;\n import static org.hamcrest.MatcherAssert.assertThat;\n \n import org.junit.jupiter.api.Test;\n \n-import jadx.NotYetImplemented;\n import jadx.core.dex.nodes.ClassNode;\n-import jadx.tests.api.IntegrationTest;\n+import jadx.tests.api.SmaliTest;\n \n-public class TestXor extends IntegrationTest {\n+public class TestXor extends SmaliTest {\n \n \tpublic static class TestCls {\n-\t\tpublic boolean test() {\n-\t\t\treturn test2() ^ true;\n+\t\tpublic boolean test1() {\n+\t\t\treturn test() ^ true;\n+\t\t}\n+\n+\t\tpublic boolean test2(boolean v) {\n+\t\t\treturn v ^ true;\n \t\t}\n \n-\t\tpublic boolean test2() {\n+\t\tpublic boolean test() {\n \t\t\treturn true;\n \t\t}\n \t}\n \n \t@Test\n-\t@NotYetImplemented\n-\tpublic void test409() {\n+\tpublic void test() {\n \t\tClassNode cls = getClassNode(TestCls.class);\n \t\tString code = cls.getCode().toString();\n \n-\t\tassertThat(code, not(containsOne(\"1\")));\n+\t\tassertThat(code, containsOne(\"return !test();\"));\n+\t\tassertThat(code, containsOne(\"return !v;\"));\n+\t}\n+\n+\t@Test\n+\tpublic void smali() {\n+\t\t/*\n+    \t\tpublic boolean test1() {\n+\t\t\t\treturn test() ^ true;\n+\t\t\t}\n+\n+\t\t\tpublic boolean test2() {\n+\t\t\t\treturn test() ^ false;\n+\t\t\t}\n+\n+\t\t\tpublic boolean test() {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t */\n+\t\tClassNode cls = getClassNodeFromSmaliWithPath(\"conditions\", \"TestXor\");\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"return !test();\"));\n+\t\tassertThat(code, containsOne(\"return test();\"));\n \t}\n \n }",
    "output": "Fix xor with boolean"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java\n@@ -138,6 +138,9 @@ protected ParserConstants() {\n \tprotected static final int FLAG_COMPLEX = 0x0001;\n \t// If set, this resource has been declared public, so libraries are allowed to reference it.\n \tprotected static final int FLAG_PUBLIC = 0x0002;\n+\t// If set, this is a weak resource and may be overriden by strong resources of the same name/type.\n+\t// This is only useful during linking with other resource tables.\n+\tprotected static final int FLAG_WEAK = 0x0004;\n \n \t/**\n \t * ResTable_map\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java\n@@ -2,7 +2,6 @@\n \n import java.io.IOException;\n import java.io.InputStream;\n-import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n@@ -216,8 +215,7 @@ private void parseTypeChunk(long start, PackageChunk pkg) throws IOException {\n \t}\n \n \tprivate void parseEntry(PackageChunk pkg, int typeId, int entryId, EntryConfig config) throws IOException {\n-\t\t/* int size = */\n-\t\tis.readInt16();\n+\t\tint size = is.readInt16();\n \t\tint flags = is.readInt16();\n \t\tint key = is.readInt32();\n \n@@ -227,17 +225,17 @@ private void parseEntry(PackageChunk pkg, int typeId, int entryId, EntryConfig c\n \t\tResourceEntry ri = new ResourceEntry(resRef, pkg.getName(), typeName, keyName);\n \t\tri.setConfig(config);\n \n-\t\tif ((flags & FLAG_COMPLEX) == 0) {\n-\t\t\tri.setSimpleValue(parseValue());\n-\t\t} else {\n+\t\tif ((flags & FLAG_COMPLEX) != 0 || size == 16) {\n \t\t\tint parentRef = is.readInt32();\n-\t\t\tri.setParentRef(parentRef);\n \t\t\tint count = is.readInt32();\n+\t\t\tri.setParentRef(parentRef);\n \t\t\tList<RawNamedValue> values = new ArrayList<>(count);\n \t\t\tfor (int i = 0; i < count; i++) {\n \t\t\t\tvalues.add(parseValueMap());\n \t\t\t}\n \t\t\tri.setNamedValues(values);\n+\t\t} else {\n+\t\t\tri.setSimpleValue(parseValue());\n \t\t}\n \t\tresStorage.add(ri);\n \t}\n@@ -256,9 +254,8 @@ private RawValue parseValue() throws IOException {\n \t}\n \n \tprivate EntryConfig parseConfig() throws IOException {\n+\t\tlong start = is.getPos();\n \t\tint size = is.readInt32();\n-\t\tint read = 28;\n-\n \t\tif (size < 28) {\n \t\t\tthrow new IOException(\"Config size < 28\");\n \t\t}\n@@ -273,19 +270,18 @@ private EntryConfig parseConfig() throws IOException {\n \n \t\tbyte orientation = (byte) is.readInt8();\n \t\tbyte touchscreen = (byte) is.readInt8();\n-\n \t\tint density = is.readInt16();\n \n \t\tbyte keyboard = (byte) is.readInt8();\n \t\tbyte navigation = (byte) is.readInt8();\n \t\tbyte inputFlags = (byte) is.readInt8();\n-\t\t/* inputPad0 */is.readInt8();\n+\t\tis.readInt8(); // inputPad0\n \n \t\tshort screenWidth = (short) is.readInt16();\n \t\tshort screenHeight = (short) is.readInt16();\n \n \t\tshort sdkVersion = (short) is.readInt16();\n-\t\t/* minorVersion, now must always be 0 */is.readInt16();\n+\t\tis.readInt16(); // minorVersion must always be 0\n \n \t\tbyte screenLayout = 0;\n \t\tbyte uiMode = 0;\n@@ -294,23 +290,20 @@ private EntryConfig parseConfig() throws IOException {\n \t\t\tscreenLayout = (byte) is.readInt8();\n \t\t\tuiMode = (byte) is.readInt8();\n \t\t\tsmallestScreenWidthDp = (short) is.readInt16();\n-\t\t\tread = 32;\n \t\t}\n \n \t\tshort screenWidthDp = 0;\n \t\tshort screenHeightDp = 0;\n \t\tif (size >= 36) {\n \t\t\tscreenWidthDp = (short) is.readInt16();\n \t\t\tscreenHeightDp = (short) is.readInt16();\n-\t\t\tread = 36;\n \t\t}\n \n \t\tchar[] localeScript = null;\n \t\tchar[] localeVariant = null;\n \t\tif (size >= 48) {\n \t\t\tlocaleScript = readScriptOrVariantChar(4).toCharArray();\n \t\t\tlocaleVariant = readScriptOrVariantChar(8).toCharArray();\n-\t\t\tread = 48;\n \t\t}\n \n \t\tbyte screenLayout2 = 0;\n@@ -319,36 +312,9 @@ private EntryConfig parseConfig() throws IOException {\n \t\t\tscreenLayout2 = (byte) is.readInt8();\n \t\t\tcolorMode = (byte) is.readInt8();\n \t\t\tis.readInt16(); // reserved padding\n-\t\t\tread = 52;\n \t\t}\n \n-\t\tif (size >= 56) {\n-\t\t\tis.readInt32();\n-\t\t\tread = 56;\n-\t\t}\n-\n-\t\tint exceedingSize = size - KNOWN_CONFIG_BYTES;\n-\t\tif (exceedingSize > 0) {\n-\t\t\tbyte[] buf = new byte[exceedingSize];\n-\t\t\tread += exceedingSize;\n-\t\t\tis.readFully(buf);\n-\t\t\tBigInteger exceedingBI = new BigInteger(1, buf);\n-\n-\t\t\tif (exceedingBI.equals(BigInteger.ZERO)) {\n-\t\t\t\tLOG.info(String\n-\t\t\t\t\t\t.format(\"Config flags size > %d, but exceeding bytes are all zero, so it should be ok.\",\n-\t\t\t\t\t\t\t\tKNOWN_CONFIG_BYTES));\n-\t\t\t} else {\n-\t\t\t\tLOG.warn(String.format(\"Config flags size > %d. Size = %d. Exceeding bytes: 0x%X.\",\n-\t\t\t\t\t\tKNOWN_CONFIG_BYTES, size, exceedingBI));\n-\t\t\t\tisInvalid = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tint remainingSize = size - read;\n-\t\tif (remainingSize > 0) {\n-\t\t\tis.skip(remainingSize);\n-\t\t}\n+\t\tis.skipToPos(start + size, \"Config skip trailing bytes\");\n \n \t\treturn new EntryConfig(mcc, mnc, language, country,\n \t\t\t\torientation, touchscreen, density, keyboard, navigation,\n@@ -358,7 +324,7 @@ private EntryConfig parseConfig() throws IOException {\n \t\t\t\tcolorMode, isInvalid, size);\n \t}\n \n-\tprivate char[] unpackLocaleOrRegion(byte in0, byte in1, char base) throws IOException {\n+\tprivate char[] unpackLocaleOrRegion(byte in0, byte in1, char base) {\n \t\t// check high bit, if so we have a packed 3 letter code\n \t\tif (((in0 >> 7) & 1) == 1) {\n \t\t\tint first = in1 & 0x1F;\n@@ -367,23 +333,22 @@ private char[] unpackLocaleOrRegion(byte in0, byte in1, char base) throws IOExce\n \n \t\t\t// since this function handles languages & regions, we add the value(s) to the base char\n \t\t\t// which is usually 'a' or '0' depending on language or region.\n-\t\t\treturn new char[] { (char) (first + base), (char) (second + base), (char) (third + base) };\n+\t\t\treturn new char[]{(char) (first + base), (char) (second + base), (char) (third + base)};\n \t\t}\n-\t\treturn new char[] { (char) in0, (char) in1 };\n+\t\treturn new char[]{(char) in0, (char) in1};\n \t}\n \n \tprivate String readScriptOrVariantChar(int length) throws IOException {\n-\t\tStringBuilder string = new StringBuilder(16);\n-\n-\t\twhile(length-- != 0) {\n+\t\tlong start = is.getPos();\n+\t\tStringBuilder sb = new StringBuilder(16);\n+\t\tfor (int i = 0; i < length; i++) {\n \t\t\tshort ch = (short) is.readInt8();\n \t\t\tif (ch == 0) {\n \t\t\t\tbreak;\n \t\t\t}\n-\t\t\tstring.append((char) ch);\n+\t\t\tsb.append((char) ch);\n \t\t}\n-\t\tis.skip(length);\n-\n-\t\treturn string.toString();\n+\t\tis.skipToPos(start + length, \"readScriptOrVariantChar\");\n+\t\treturn sb.toString();\n \t}\n }",
    "output": "Fix skip trailing bytes in resource table decoding"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n@@ -88,7 +88,8 @@ public List<JavaClass> getIncludedClasses() {\n \n \t\treturn classList.stream().filter(cls -> {\n \t\t\tfor (String exclude : excludedPackages) {\n-\t\t\t\tif (cls.getFullName().startsWith(exclude)) {\n+\t\t\t\tif (cls.getFullName().equals(exclude)\n+\t\t\t\t\t\t|| cls.getFullName().startsWith(exclude + '.')) {\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \t\t\t}\n@@ -98,11 +99,15 @@ public List<JavaClass> getIncludedClasses() {\n \n \tpublic List<String> getExcludedPackages() {\n \t\tString excludedPackages = settings.getExcludedPackages().trim();\n+\t\tif (excludedPackages.isEmpty()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n \t\treturn Arrays.asList(excludedPackages.split(\"[ ]+\"));\n \t}\n \n \tpublic void addExcludedPackage(String packageToExclude) {\n-\t\tsettings.setExcludedPackages(settings.getExcludedPackages() + ' ' + packageToExclude);\n+\t\tString newExclusion = settings.getExcludedPackages() + ' ' + packageToExclude;\n+\t\tsettings.setExcludedPackages(newExclusion.trim());\n \t\tsettings.sync();\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java\n@@ -46,7 +46,8 @@ public JPackage(String name, JadxWrapper wrapper) {\n \tprivate void setEnabled(JadxWrapper wrapper) {\n \t\tList<String> excludedPackages = wrapper.getExcludedPackages();\n \t\tthis.enabled = excludedPackages.isEmpty()\n-\t\t\t\t|| excludedPackages.stream().filter(p -> !p.isEmpty()).noneMatch(p -> name.startsWith(p));\n+\t\t\t\t|| excludedPackages.stream().filter(p -> !p.isEmpty())\n+\t\t\t\t\t.noneMatch(p -> name.equals(p) || name.startsWith(p + '.'));\n \t}\n \n \tpublic final void update() {",
    "output": "Fix exclusion disablement should be exact package match"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n@@ -126,7 +126,7 @@ public static boolean isAllCharsPrintable(String str) {\n \t * </ul><p>\n \t */\n \tpublic static String removeInvalidCharsMiddle(String name) {\n-\t\tif (isValidIdentifier(name) && isAllCharsPrintable(name)) {\n+\t\tif (isValidIdentifier(name)) {\n \t\t\treturn name;\n \t\t}\n \t\tint len = name.length();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -92,10 +92,11 @@ private String fixClsShortName(String clsName) {\n \t\tif (firstChar == '$') {\n \t\t\treturn 'C' + NameMapper.removeInvalidCharsMiddle(clsName);\n \t\t}\n-\t\tif (!NameMapper.isValidIdentifier(clsName)) {\n-\t\t\treturn 'C' + clsName;\n+\t\tString cleanClsName = NameMapper.removeInvalidChars(clsName, \"C\");\n+\t\tif (!NameMapper.isValidIdentifier(cleanClsName)) {\n+\t\t\treturn 'C' + cleanClsName;\n \t\t}\n-\t\treturn NameMapper.removeInvalidChars(clsName, \"C\");\n+\t\treturn cleanClsName;\n \t}\n \n \tprivate void checkFields(ClassNode cls) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/TestClassNameWithInvalidChar.java b/jadx-core/src/test/java/jadx/tests/integration/names/TestClassNameWithInvalidChar.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/TestClassNameWithInvalidChar.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestClassNameWithInvalidChar.java\n@@ -0,0 +1,36 @@\n+package jadx.tests.integration.names;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import jadx.api.JadxDecompiler;\n+import jadx.api.JadxInternalAccess;\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.core.dex.nodes.RootNode;\n+import jadx.tests.api.SmaliTest;\n+\n+public class TestClassNameWithInvalidChar extends SmaliTest {\n+\t/*\n+\t\tpublic class do- {}\n+\t\tpublic class i-f {}\n+\t*/\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tJadxDecompiler d = loadSmaliFiles(\"names\", \"TestClassNameWithInvalidChar\");\n+\t\tRootNode root = JadxInternalAccess.getRoot(d);\n+\t\tfor (ClassNode cls : root.getClasses(false)) {\n+\t\t\tdecompileAndCheckCls(d, cls);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testWithDeobfuscation() {\n+\t\tenableDeobfuscation();\n+\n+\t\tJadxDecompiler d = loadSmaliFiles(\"names\", \"TestClassNameWithInvalidChar\");\n+\t\tRootNode root = JadxInternalAccess.getRoot(d);\n+\t\tfor (ClassNode cls : root.getClasses(false)) {\n+\t\t\tdecompileAndCheckCls(d, cls);\n+\t\t}\n+\t}\n+}",
    "output": "Remove invalid chars from class names"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n@@ -116,7 +116,7 @@ private static boolean checkForIndexedLoop(MethodNode mth, LoopRegion loopRegion\n \t\t// all checks passed\n \t\tinitInsn.add(AFlag.SKIP);\n \t\tincrInsn.add(AFlag.SKIP);\n-\t\tLoopType arrForEach = checkArrayForEach(mth, initInsn, incrInsn, condition);\n+\t\tLoopType arrForEach = checkArrayForEach(mth, loopRegion, initInsn, incrInsn, condition);\n \t\tif (arrForEach != null) {\n \t\t\tloopRegion.setType(arrForEach);\n \t\t\treturn true;\n@@ -125,7 +125,7 @@ private static boolean checkForIndexedLoop(MethodNode mth, LoopRegion loopRegion\n \t\treturn true;\n \t}\n \n-\tprivate static LoopType checkArrayForEach(MethodNode mth, InsnNode initInsn, InsnNode incrInsn,\n+\tprivate static LoopType checkArrayForEach(MethodNode mth, LoopRegion loopRegion, InsnNode initInsn, InsnNode incrInsn,\n \t                                          IfCondition condition) {\n \t\tif (!(incrInsn instanceof ArithNode)) {\n \t\t\treturn null;\n@@ -186,6 +186,9 @@ private static LoopType checkArrayForEach(MethodNode mth, InsnNode initInsn, Ins\n \t\tif (iterVar == null) {\n \t\t\treturn null;\n \t\t}\n+\t\tif (!usedOnlyInLoop(mth, loopRegion, iterVar)) {\n+\t\t\treturn null;\n+\t\t}\n \n \t\t// array for each loop confirmed\n \t\tlen.add(AFlag.SKIP);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/loops/TestIndexedLoop.java b/jadx-core/src/test/java/jadx/tests/integration/loops/TestIndexedLoop.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/loops/TestIndexedLoop.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestIndexedLoop.java\n@@ -0,0 +1,71 @@\n+package jadx.tests.integration.loops;\n+\n+import java.io.File;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestIndexedLoop extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic File test(File[] files) {\n+\t\t\tFile file = null;\n+\t\t\tif (files != null) {\n+\t\t\t\tint length = files.length;\n+\t\t\t\tif (length == 0) {\n+\t\t\t\t\tfile = null;\n+\t\t\t\t} else {\n+\t\t\t\t\tfor (int i = 0; i < length; i++) {\n+\t\t\t\t\t\tfile = files[i];\n+\t\t\t\t\t\tif (file.getName().equals(\"f\")) {\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfile = null;\n+\t\t\t}\n+\t\t\tif (file != null) {\n+\t\t\t\tfile.deleteOnExit();\n+\t\t\t}\n+\t\t\treturn file;\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertThat(test(null), nullValue());\n+\t\t\tassertThat(test(new File[]{}), nullValue());\n+\n+\t\t\tFile file = new File(\"f\");\n+\t\t\tassertThat(test(new File[]{new File(\"a\"), file}), is(file));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, not(containsString(\"for (File file :\")));\n+\t\tassertThat(code, containsOne(\"for (int i = 0; i < length; i++) {\"));\n+\t}\n+\n+\t@Test\n+\tpublic void testNoDebug() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, not(containsString(\"for (File file :\")));\n+\t\tassertThat(code, containsOne(\"for (int i = 0; i < length; i++) {\"));\n+\t}\n+}",
    "output": "Fix check variable usage before convert indexed loop to for-each variant"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -11,6 +11,7 @@\n import java.util.Set;\n import java.util.TreeSet;\n \n+import jadx.core.dex.attributes.AFlag;\n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n@@ -225,6 +226,8 @@ private void processClass(ClassNode cls) {\n \t\t\tclsInfo.rename(cls.dex().root(), fullName);\n \t\t}\n \t\tfor (FieldNode field : cls.getFields()) {\n+\t\t\tif (field.contains(AFlag.DONT_RENAME))\n+\t\t\t    continue;\n \t\t\trenameField(field);\n \t\t}\n \t\tfor (MethodNode mth : cls.getMethods()) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n--- a/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java\n@@ -19,6 +19,7 @@ public enum AFlag {\n \tDONT_SHRINK,\n \tDONT_INLINE,\n \tDONT_GENERATE,\n+\tDONT_RENAME, // do not rename during deobfuscation\n \tSKIP,\n \tREMOVE,\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n@@ -6,6 +6,7 @@\n import java.util.TreeMap;\n \n import com.android.dx.rop.code.AccessFlags;\n+import jadx.core.dex.attributes.AFlag;\n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n@@ -124,6 +125,7 @@ private static void addResourceFields(ClassNode resCls, ResourceStorage resStora\n \t\t\tif (fieldNode != null\n \t\t\t\t\t&& !fieldNode.getName().equals(resName)\n \t\t\t\t\t&& NameMapper.isValidIdentifier(resName)) {\n+\t\t\t\tfieldNode.add(AFlag.DONT_RENAME);\n \t\t\t\tfieldNode.getFieldInfo().setAlias(resName);\n \t\t\t}\n \t\t}",
    "output": "Fix don't rename R class fields alias"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java\n@@ -34,7 +34,7 @@ public final void initUI() {\n \t\tversion.setAlignmentX(0.5f);\n \n \t\tString javaVm = System.getProperty(\"java.vm.name\");\n-\t\tString javaVer = System.getProperty(\"java.vm.version\");\n+\t\tString javaVer = System.getProperty(\"java.version\");\n \n \t\tjavaVm = javaVm == null ? \"\" : javaVm;",
    "output": "Fix show java version, instead of VM version in about dialog"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java\n@@ -15,6 +15,8 @@\n import jadx.core.xmlgen.entry.ResourceEntry;\n import jadx.core.xmlgen.entry.ValuesParser;\n \n+import static jadx.core.xmlgen.ParserConstants.PLURALS_MAP;\n+\n public class ResXmlGen {\n \n \tprivate static final Set<String> SKIP_RES_TYPES = new HashSet<>(Arrays.asList(\n@@ -147,16 +149,22 @@ private void addItem(CodeWriter cw, String itemTag, String typeName, RawNamedVal\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif (typeName.equals(\"attr\")) {\n-\t\t\tif (nameStr != null) {\n-\t\t\t\taddSimpleValue(cw, typeName, itemTag, nameStr, valueStr, \"\");\n-\t\t\t}\n-\t\t} else if (typeName.equals(\"style\")) {\n-\t\t\tif (nameStr != null) {\n-\t\t\t\taddSimpleValue(cw, typeName, itemTag, nameStr, \"\", valueStr);\n-\t\t\t}\n-\t\t} else {\n-\t\t\taddSimpleValue(cw, typeName, itemTag, null, null, valueStr);\n+\t\tswitch (typeName) {\n+\t\t\tcase \"attr\":\n+\t\t\t\tif (nameStr != null)\n+\t\t\t\t\taddSimpleValue(cw, typeName, itemTag, nameStr, valueStr, \"\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"style\":\n+\t\t\t\tif (nameStr != null)\n+\t\t\t\t\taddSimpleValue(cw, typeName, itemTag, nameStr, \"\", valueStr);\n+\t\t\t\tbreak;\n+\t\t\tcase \"plurals\":\n+\t\t\t\tfinal String quantity = PLURALS_MAP.get(value.getNameRef());\n+\t\t\t\taddSimpleValue(cw, typeName, itemTag, \"quantity\", quantity, valueStr);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\taddSimpleValue(cw, typeName, itemTag, null, null, valueStr);\n+\t\t\t\tbreak;\n \t\t}\n \t}",
    "output": "Use quantity attribute for plurals"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -92,6 +92,9 @@ private String fixClsShortName(String clsName) {\n \t\tif (firstChar == '$') {\n \t\t\treturn 'C' + NameMapper.removeInvalidCharsMiddle(clsName);\n \t\t}\n+\t\tif (!NameMapper.isValidIdentifier(clsName)) {\n+\t\t\treturn 'C' + clsName;\n+\t\t}\n \t\treturn NameMapper.removeInvalidChars(clsName, \"C\");\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedClassNames.java b/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedClassNames.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedClassNames.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedClassNames.java\n@@ -0,0 +1,27 @@\n+package jadx.tests.integration.names;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.not;\n+import static org.junit.Assert.assertThat;\n+\n+import java.io.File;\n+\n+public class TestReservedClassNames extends SmaliTest {\n+\t/*\n+\t\tpublic class do {\n+\t\t}\n+\t*/\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmali(\"names\" + File.separatorChar + \"TestReservedClassNames\", \"do\");\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, not(containsString(\"public class do\")));\n+\t}\n+}",
    "output": "Fix rename class with reserved java keywords"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n@@ -107,7 +107,7 @@ public boolean overrideProvided(String[] args) {\n \t\treturn process(jcw);\n \t}\n \n-\tprivate boolean process(JCommanderWrapper jcw) {\n+\tprivate boolean process(JCommanderWrapper<?> jcw) {\n \t\tif (printHelp) {\n \t\t\tjcw.printUsage();\n \t\t\treturn false;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java\n@@ -151,7 +151,7 @@ public void encodeValue(CodeWriter code, Object val) {\n \t\t\tInsnGen.makeStaticFieldAccess(code, field, classGen);\n \t\t} else if (val instanceof Iterable) {\n \t\t\tcode.add('{');\n-\t\t\tIterator<?> it = ((Iterable) val).iterator();\n+\t\t\tIterator<?> it = ((Iterable<?>) val).iterator();\n \t\t\twhile (it.hasNext()) {\n \t\t\t\tObject obj = it.next();\n \t\t\t\tencodeValue(code, obj);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -144,7 +144,7 @@ public void addClassDeclaration(CodeWriter clsCode) {\n \t\tclsCode.attachDefinition(cls);\n \t\tclsCode.add(cls.getShortName());\n \n-\t\taddGenericMap(clsCode, cls.getGenericMap());\n+\t\taddGenericMap(clsCode, cls.getGenericMap(), true);\n \t\tclsCode.add(' ');\n \n \t\tArgType sup = cls.getSuperClass();\n@@ -175,7 +175,7 @@ public void addClassDeclaration(CodeWriter clsCode) {\n \t\t}\n \t}\n \n-\tpublic boolean addGenericMap(CodeWriter code, Map<ArgType, List<ArgType>> gmap) {\n+\tpublic boolean addGenericMap(CodeWriter code, Map<ArgType, List<ArgType>> gmap, boolean classDeclaration) {\n \t\tif (gmap == null || gmap.isEmpty()) {\n \t\t\treturn false;\n \t\t}\n@@ -200,6 +200,10 @@ public boolean addGenericMap(CodeWriter code, Map<ArgType, List<ArgType>> gmap)\n \t\t\t\t\t\tcode.add(g.getObject());\n \t\t\t\t\t} else {\n \t\t\t\t\t\tuseClass(code, g);\n+\n+\t\t\t\t\t\tif (classDeclaration && !cls.getAlias().isInner()) {\n+\t\t\t\t\t\t\taddImport(ClassInfo.extCls(cls.root(), g));\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tif (it.hasNext()) {\n \t\t\t\t\t\tcode.add(\" & \");\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -90,7 +90,7 @@ public boolean addDefinition(CodeWriter code) {\n \t\t\tcode.add(mth.isVirtual() ? \"/* virtual */ \" : \"/* direct */ \");\n \t\t}\n \n-\t\tif (classGen.addGenericMap(code, mth.getGenericMap())) {\n+\t\tif (classGen.addGenericMap(code, mth.getGenericMap(), false)) {\n \t\t\tcode.add(' ');\n \t\t}\n \t\tif (ai.isConstructor()) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/generics/TestImportGenericMap.java b/jadx-core/src/test/java/jadx/tests/integration/generics/TestImportGenericMap.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/generics/TestImportGenericMap.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/generics/TestImportGenericMap.java\n@@ -0,0 +1,40 @@\n+package jadx.tests.integration.generics;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.junit.Assert.assertThat;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+public class TestImportGenericMap extends IntegrationTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(SuperClass.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsString(\n+\t\t\t\t\"import \" + SuperClass.ToImport.class.getName().replace('$', '.') + ';'));\n+\t\tassertThat(code, not(containsString(\n+\t\t\t\t\"import \" + SuperClass.NotToImport.class.getName().replace('$', '.') + ';')));\n+\t}\n+}\n+\n+final class SuperClass<O extends SuperClass.ToImport> {\n+\n+    interface ToImport {\n+    }\n+\n+    interface NotToImport {\n+    }\n+\n+    static final class Class1<C extends NotToImport> {\n+    }\n+\n+    public <C extends NotToImport> SuperClass(Class1<C> zzf) {\n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Add missing import for class generics map"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n@@ -3,6 +3,7 @@\n import javax.swing.*;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n import java.util.Map;\n \n@@ -68,6 +69,14 @@ public final void update() {\n \t\t\t}\n \t\t} else {\n \t\t\tremoveAllChildren();\n+\n+\t\t\tComparator<JResource> typeComparator\n+\t\t\t\t= (r1, r2) -> r1.type.ordinal() - r2.type.ordinal();\n+\t\t\tComparator<JResource> nameComparator\n+\t\t\t\t= Comparator.comparing(JResource::getName, String.CASE_INSENSITIVE_ORDER);\n+\n+\t\t\tfiles.sort(typeComparator.thenComparing(nameComparator));\n+\n \t\t\tfor (JResource res : files) {\n \t\t\t\tres.update();\n \t\t\t\tadd(res);",
    "output": "Fix sort resources according to their type, then name"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java\n@@ -18,6 +18,7 @@\n import jadx.core.dex.nodes.FieldNode;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.dex.nodes.parser.FieldInitAttr;\n import jadx.core.utils.exceptions.JadxException;\n \n public class DependencyCollector extends AbstractVisitor {\n@@ -41,6 +42,12 @@ private static void processClass(ClassNode cls, DexNode dex, Set<ClassNode> depL\n \t\t}\n \t\tfor (FieldNode fieldNode : cls.getFields()) {\n \t\t\taddDep(dex, depList, fieldNode.getType());\n+\n+\t\t\t// process instructions from field init\n+\t\t\tFieldInitAttr fieldInitAttr = fieldNode.get(AType.FIELD_INIT);\n+\t\t\tif (fieldInitAttr != null && fieldInitAttr.getValueType() == FieldInitAttr.InitType.INSN) {\n+\t\t\t\tprocessInsn(dex, depList, fieldInitAttr.getInsn());\n+\t\t\t}\n \t\t}\n \t\t// TODO: process annotations and generics\n \t\tfor (MethodNode methodNode : cls.getMethods()) {",
    "output": "Fix process field init code in dependency collector"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n@@ -316,4 +316,24 @@ public InsnNode copy() {\n \t\t}\n \t\treturn INSN_CLONER.deepClone(this);\n \t}\n+\n+\tpublic boolean canThrowException() {\n+\t\tswitch (getType()) {\n+\t\t\tcase RETURN:\n+\t\t\tcase IF:\n+\t\t\tcase GOTO:\n+\t\t\tcase MOVE:\n+\t\t\tcase MOVE_EXCEPTION:\n+\t\t\tcase NEG:\n+\t\t\tcase CONST:\n+\t\t\tcase CONST_STR:\n+\t\t\tcase CONST_CLASS:\n+\t\t\tcase CMP_L:\n+\t\t\tcase CMP_G:\n+\t\t\t\treturn false;\n+\n+\t\t\tdefault:\n+\t\t\t\treturn true;\n+\t\t}\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -321,16 +321,24 @@ private static void initTryCatches(MethodNode mth, Code mthCode, InsnNode[] insn\n \t\t\tint offset = aTry.getStartAddress();\n \t\t\tint end = offset + aTry.getInstructionCount() - 1;\n \n-\t\t\tInsnNode insn = insnByOffset[offset];\n-\t\t\tinsn.add(AFlag.TRY_ENTER);\n+\t\t\tboolean tryBlockStarted = false;\n+\t\t\tInsnNode insn = null;\n \t\t\twhile (offset <= end && offset >= 0) {\n \t\t\t\tinsn = insnByOffset[offset];\n-\t\t\t\tcatchBlock.addInsn(insn);\n+\t\t\t\tif (insn != null) {\n+\t\t\t\t\tif (tryBlockStarted) {\n+\t\t\t\t\t\tcatchBlock.addInsn(insn);\n+\t\t\t\t\t} else if (insn.canThrowException()) {\n+\t\t\t\t\t\tinsn.add(AFlag.TRY_ENTER);\n+\t\t\t\t\t\tcatchBlock.addInsn(insn);\n+\t\t\t\t\t\ttryBlockStarted = true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t\toffset = InsnDecoder.getNextInsnOffset(insnByOffset, offset);\n \t\t\t}\n \t\t\tif (insnByOffset[end] != null) {\n \t\t\t\tinsnByOffset[end].add(AFlag.TRY_LEAVE);\n-\t\t\t} else {\n+\t\t\t} else if (insn != null) {\n \t\t\t\tinsn.add(AFlag.TRY_LEAVE);\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchStartOnMove.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchStartOnMove.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchStartOnMove.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchStartOnMove.java\n@@ -0,0 +1,33 @@\n+package jadx.tests.integration.trycatch;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestTryCatchStartOnMove extends SmaliTest {\n+\n+//\tprivate static void test(String s) {\n+//\t\ttry {\n+//\t\t\tcall(s);\n+//\t\t} catch (Exception unused) {\n+//\t\t\tSystem.out.println(\"Failed call for \" + s);\n+//\t\t}\n+//\t}\n+//\n+//\tprivate static void call(String s) {\n+//\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmaliWithPkg(\"trycatch\", \"TestTryCatchStartOnMove\");\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"try {\"));\n+\t\tassertThat(code, containsOne(\"} catch (Exception e) {\"));\n+\t\tassertThat(code, containsOne(\"System.out.println(\\\"Failed call for \\\" + str\"));\n+\t}\n+}",
    "output": "Fix move instruction out of try/catch"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n@@ -99,11 +99,17 @@ private static void addResourceFields(ClassNode resCls, ResourceStorage resStora\n \t\t\t}\n \t\t}\n \t\tfor (ResourceEntry resource : resStorage.getResources()) {\n+\t\t\tfinal String resTypeName = resource.getTypeName();\n \t\t\tClassNode typeCls = innerClsMap.computeIfAbsent(\n-\t\t\t\t\tresource.getTypeName(),\n+\t\t\t\t\tresTypeName,\n \t\t\t\t\tname -> addClassForResType(resCls, rClsExists, name)\n \t\t\t);\n-\t\t\tString resName = resource.getKeyName();\n+\t\t\tfinal String resName;\n+\t\t\tif (\"style\".equals(resTypeName)) {\n+\t\t\t\tresName = resource.getKeyName().replace('.', '_');\n+\t\t\t} else {\n+\t\t\t\tresName = resource.getKeyName();\n+\t\t\t}\n \t\t\tFieldNode rField = typeCls.searchFieldByName(resName);\n \t\t\tif (rField == null) {\n \t\t\t\tFieldInfo rFieldInfo = FieldInfo.from(typeCls.dex(), typeCls.getClassInfo(), resName, ArgType.INT);",
    "output": "Fix replace dot character with underscore in style resource name"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n@@ -1,18 +1,23 @@\n package jadx.core.utils.android;\n \n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.TreeMap;\n \n import com.android.dx.rop.code.AccessFlags;\n+import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import jadx.core.codegen.ClassGen;\n import jadx.core.codegen.CodeWriter;\n+import jadx.core.deobf.NameMapper;\n import jadx.core.dex.attributes.AType;\n+import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.info.ClassInfo;\n+import jadx.core.dex.info.ConstStorage;\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.nodes.ClassNode;\n@@ -86,32 +91,65 @@ private static ClassNode makeClass(RootNode root, String clsName, ResourceStorag\n \t}\n \n \tprivate static void addResourceFields(ClassNode resCls, ResourceStorage resStorage, boolean rClsExists) {\n+\t\tMap<Integer, FieldNode> resFieldsMap = fillResFieldsMap(resCls);\n \t\tMap<String, ClassNode> innerClsMap = new TreeMap<>();\n \t\tif (rClsExists) {\n \t\t\tfor (ClassNode innerClass : resCls.getInnerClasses()) {\n \t\t\t\tinnerClsMap.put(innerClass.getShortName(), innerClass);\n \t\t\t}\n \t\t}\n \t\tfor (ResourceEntry resource : resStorage.getResources()) {\n-\t\t\tClassNode typeCls = innerClsMap.computeIfAbsent(resource.getTypeName(), name -> {\n-\t\t\t\tClassNode newTypeCls = new ClassNode(resCls.dex(), resCls.getFullName() + \"$\" + name,\n-\t\t\t\t\t\tAccessFlags.ACC_PUBLIC | AccessFlags.ACC_STATIC | AccessFlags.ACC_FINAL);\n-\t\t\t\tresCls.addInnerClass(newTypeCls);\n-\t\t\t\tif (rClsExists) {\n-\t\t\t\t\tnewTypeCls.addAttr(AType.COMMENTS, \"added by JADX\");\n-\t\t\t\t}\n-\t\t\t\treturn newTypeCls;\n-\t\t\t});\n-\t\t\tFieldNode rField = typeCls.searchFieldByName(resource.getKeyName());\n+\t\t\tClassNode typeCls = innerClsMap.computeIfAbsent(\n+\t\t\t\t\tresource.getTypeName(),\n+\t\t\t\t\tname -> addClassForResType(resCls, rClsExists, name)\n+\t\t\t);\n+\t\t\tString resName = resource.getKeyName();\n+\t\t\tFieldNode rField = typeCls.searchFieldByName(resName);\n \t\t\tif (rField == null) {\n-\t\t\t\tFieldInfo rFieldInfo = FieldInfo.from(typeCls.dex(), typeCls.getClassInfo(), resource.getKeyName(), ArgType.INT);\n+\t\t\t\tFieldInfo rFieldInfo = FieldInfo.from(typeCls.dex(), typeCls.getClassInfo(), resName, ArgType.INT);\n \t\t\t\trField = new FieldNode(typeCls, rFieldInfo, AccessFlags.ACC_PUBLIC | AccessFlags.ACC_STATIC | AccessFlags.ACC_FINAL);\n \t\t\t\trField.addAttr(FieldInitAttr.constValue(resource.getId()));\n \t\t\t\ttypeCls.getFields().add(rField);\n \t\t\t\tif (rClsExists) {\n \t\t\t\t\trField.addAttr(AType.COMMENTS, \"added by JADX\");\n \t\t\t\t}\n \t\t\t}\n+\t\t\tFieldNode fieldNode = resFieldsMap.get(resource.getId());\n+\t\t\tif (fieldNode != null\n+\t\t\t\t\t&& !fieldNode.getName().equals(resName)\n+\t\t\t\t\t&& NameMapper.isValidIdentifier(resName)) {\n+\t\t\t\tfieldNode.getFieldInfo().setAlias(resName);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@NotNull\n+\tprivate static ClassNode addClassForResType(ClassNode resCls, boolean rClsExists, String typeName) {\n+\t\tClassNode newTypeCls = new ClassNode(resCls.dex(), resCls.getFullName() + \"$\" + typeName,\n+\t\t\t\tAccessFlags.ACC_PUBLIC | AccessFlags.ACC_STATIC | AccessFlags.ACC_FINAL);\n+\t\tresCls.addInnerClass(newTypeCls);\n+\t\tif (rClsExists) {\n+\t\t\tnewTypeCls.addAttr(AType.COMMENTS, \"added by JADX\");\n+\t\t}\n+\t\treturn newTypeCls;\n+\t}\n+\n+\t@NotNull\n+\tprivate static Map<Integer, FieldNode> fillResFieldsMap(ClassNode resCls) {\n+\t\tMap<Integer, FieldNode> resFieldsMap = new HashMap<>();\n+\t\tConstStorage constStorage = resCls.root().getConstValues();\n+\t\tMap<Object, FieldNode> constFields = constStorage.getGlobalConstFields();\n+\t\tfor (Map.Entry<Object, FieldNode> entry : constFields.entrySet()) {\n+\t\t\tObject key = entry.getKey();\n+\t\t\tFieldNode field = entry.getValue();\n+\t\t\tAccessInfo accessFlags = field.getAccessFlags();\n+\t\t\tif (field.getType().equals(ArgType.INT)\n+\t\t\t\t\t&& accessFlags.isStatic()\n+\t\t\t\t\t&& accessFlags.isFinal()\n+\t\t\t\t\t&& key instanceof Integer) {\n+\t\t\t\tresFieldsMap.put((Integer) key, field);\n+\t\t\t}\n \t\t}\n+\t\treturn resFieldsMap;\n \t}\n }",
    "output": "Fix rename R fields using resource names"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -15,8 +15,6 @@\n import jadx.api.ResourcesLoader;\n import jadx.core.codegen.CodeWriter;\n import jadx.core.dex.info.ConstStorage;\n-import jadx.core.dex.instructions.args.ArgType;\n-import jadx.core.dex.nodes.FieldNode;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.utils.StringUtils;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n@@ -40,7 +38,6 @@ public class BinaryXMLParser extends CommonBinaryParser {\n \tprivate static final boolean ATTR_NEW_LINE = false;\n \n \tprivate final Map<Integer, String> styleMap = new HashMap<>();\n-\tprivate final Map<Integer, FieldNode> localStyleMap = new HashMap<>();\n \tprivate final Map<Integer, String> resNames;\n \tprivate final Map<String, String> nsMap = new HashMap<>();\n \tprivate Set<String> nsMapGenerated;\n@@ -63,16 +60,7 @@ public BinaryXMLParser(RootNode rootNode) {\n \t\tthis.rootNode = rootNode;\n \t\ttry {\n \t\t\treadAndroidRStyleClass();\n-\t\t\t// add application constants\n \t\t\tConstStorage constStorage = rootNode.getConstValues();\n-\t\t\tMap<Object, FieldNode> constFields = constStorage.getGlobalConstFields();\n-\t\t\tfor (Map.Entry<Object, FieldNode> entry : constFields.entrySet()) {\n-\t\t\t\tObject key = entry.getKey();\n-\t\t\t\tFieldNode field = entry.getValue();\n-\t\t\t\tif (field.getType().equals(ArgType.INT) && key instanceof Integer) {\n-\t\t\t\t\tlocalStyleMap.put((Integer) key, field);\n-\t\t\t\t}\n-\t\t\t}\n \t\t\tresNames = constStorage.getResourcesNames();\n \t\t} catch (Exception e) {\n \t\t\tthrow new JadxRuntimeException(\"BinaryXMLParser init error\", e);\n@@ -381,38 +369,27 @@ private String getString(int strId) {\n \n \tprivate void decodeAttribute(int attributeNS, int attrValDataType, int attrValData,\n \t                             String shortNsName, String attrName) {\n-\n \t\tif (attrValDataType == TYPE_REFERENCE) {\n \t\t\t// reference custom processing\n \t\t\tString name = styleMap.get(attrValData);\n \t\t\tif (name != null) {\n \t\t\t\twriter.add(\"@style/\").add(name.replaceAll(\"_\", \".\"));\n \t\t\t} else {\n-\t\t\t\tFieldNode field = localStyleMap.get(attrValData);\n-\t\t\t\tif (field != null) {\n-\t\t\t\t\tString cls = field.getParentClass().getShortName().toLowerCase();\n+\t\t\t\tString resName = resNames.get(attrValData);\n+\t\t\t\tif (resName != null) {\n \t\t\t\t\twriter.add(\"@\");\n-\t\t\t\t\tif (\"id\".equals(cls)) {\n-\t\t\t\t\t\twriter.add('+');\n+\t\t\t\t\tif (resName.startsWith(\"id/\")) {\n+\t\t\t\t\t\twriter.add(\"+\");\n \t\t\t\t\t}\n-\t\t\t\t\twriter.add(cls).add(\"/\").add(field.getName());\n+\t\t\t\t\twriter.add(resName);\n \t\t\t\t} else {\n-\t\t\t\t\tString resName = resNames.get(attrValData);\n+\t\t\t\t\tresName = ValuesParser.getAndroidResMap().get(attrValData);\n \t\t\t\t\tif (resName != null) {\n-\t\t\t\t\t\twriter.add(\"@\");\n-\t\t\t\t\t\tif (resName.startsWith(\"id/\")) {\n-\t\t\t\t\t\t\twriter.add(\"+\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\twriter.add(resName);\n+\t\t\t\t\t\twriter.add(\"@android:\").add(resName);\n+\t\t\t\t\t} else if (attrValData == 0) {\n+\t\t\t\t\t\twriter.add(\"@null\");\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tresName = ValuesParser.getAndroidResMap().get(attrValData);\n-\t\t\t\t\t\tif (resName != null) {\n-\t\t\t\t\t\t\twriter.add(\"@android:\").add(resName);\n-\t\t\t\t\t\t} else if (attrValData == 0) {\n-\t\t\t\t\t\t\twriter.add(\"@null\");\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\twriter.add(\"0x\").add(Integer.toHexString(attrValData));\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\twriter.add(\"0x\").add(Integer.toHexString(attrValData));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}",
    "output": "Fix don't replace resources names with field names"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n@@ -59,8 +59,8 @@ private void searchDexFiles(boolean skipSources) throws IOException, DecodeExcep\n \t\t\tloadFromZip(\".dex\");\n \t\t\treturn;\n \t\t}\n-\t\tif (fileName.endsWith(\".jar\")) {\n-\t\t\t// check if jar contains '.dex' files\n+\t\tif (fileName.endsWith(\".jar\") || fileName.endsWith(\".aar\")) {\n+\t\t\t// check if jar/aar contains '.dex' files\n \t\t\tif (loadFromZip(\".dex\")) {\n \t\t\t\treturn;\n \t\t\t}",
    "output": "Fix restore support for AAR files (issue #95)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n@@ -47,10 +47,7 @@ public boolean visit(ClassNode cls) throws JadxException {\n \t\tfor (ClassNode inner : cls.getInnerClasses()) {\n \t\t\tvisit(inner);\n \t\t}\n-\t\tif (cls.getAccessFlags().isSynthetic()\n-\t\t\t\t&& cls.getFields().isEmpty()\n-\t\t\t\t&& cls.getMethods().isEmpty()\n-\t\t\t\t&& cls.getInnerClasses().isEmpty()) {\n+\t\tif (isEmptySyntheticClass(cls)) {\n \t\t\tcls.add(AFlag.DONT_GENERATE);\n \t\t\treturn false;\n \t\t}\n@@ -62,6 +59,13 @@ public boolean visit(ClassNode cls) throws JadxException {\n \t\treturn false;\n \t}\n \n+\tprivate static boolean isEmptySyntheticClass(ClassNode cls) {\n+\t\treturn cls.getAccessFlags().isSynthetic()\n+\t\t\t\t&& cls.getFields().isEmpty()\n+\t\t\t\t&& cls.getMethods().isEmpty()\n+\t\t\t\t&& cls.getInnerClasses().isEmpty();\n+\t}\n+\n \tprivate void markAnonymousClass(ClassNode cls) {\n \t\tif (cls.isAnonymous()) {\n \t\t\tcls.add(AFlag.ANONYMOUS_CLASS);\n@@ -173,7 +177,7 @@ private static boolean isRemovedClassInArgs(ClassNode cls, List<RegisterArg> mth\n \t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tif (argCls.contains(AFlag.DONT_GENERATE)) {\n+\t\t\t\tif (argCls.contains(AFlag.DONT_GENERATE) || isEmptySyntheticClass(argCls)) {\n \t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}",
    "output": "Fix check if synthetic class not yet processed but must be removed"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n@@ -295,15 +295,34 @@ private static boolean isMethodUnique(ClassNode cls, MethodNode mth) {\n \n \tprivate static void removeEmptyMethods(MethodNode mth) {\n \t\tAccessInfo af = mth.getAccessFlags();\n-\t\t// remove public empty constructors\n+\t\t// remove public empty constructors (static or default)\n \t\tif (af.isConstructor()\n \t\t\t\t&& (af.isPublic() || af.isStatic())\n-\t\t\t\t&& mth.getArguments(false).isEmpty()\n-\t\t\t\t&& !mth.contains(AType.JADX_ERROR)) {\n+\t\t\t\t&& mth.getArguments(false).isEmpty()) {\n \t\t\tList<BlockNode> bb = mth.getBasicBlocks();\n \t\t\tif (bb == null || bb.isEmpty() || BlockUtils.isAllBlocksEmpty(bb)) {\n-\t\t\t\tmth.add(AFlag.DONT_GENERATE);\n+\t\t\t\tif (af.isStatic() && mth.getMethodInfo().isClassInit()) {\n+\t\t\t\t\tmth.add(AFlag.DONT_GENERATE);\n+\t\t\t\t} else {\n+\t\t\t\t\t// don't remove default constructor if other constructors exists\n+\t\t\t\t\tif (mth.isDefaultConstructor() && !isNonDefaultConstructorExists(mth)) {\n+\t\t\t\t\t\tmth.add(AFlag.DONT_GENERATE);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n+\n+\tprivate static boolean isNonDefaultConstructorExists(MethodNode defCtor) {\n+\t\tClassNode parentClass = defCtor.getParentClass();\n+\t\tfor (MethodNode mth : parentClass.getMethods()) {\n+\t\t\tif (mth != defCtor\n+\t\t\t\t\t&& mth.getAccessFlags().isConstructor()\n+\t\t\t\t\t&& mth.getMethodInfo().isConstructor()\n+\t\t\t\t\t&& !mth.isDefaultConstructor()) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestDefConstructorNotRemoved.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestDefConstructorNotRemoved.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestDefConstructorNotRemoved.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestDefConstructorNotRemoved.java\n@@ -0,0 +1,60 @@\n+package jadx.tests.integration.others;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.not;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestDefConstructorNotRemoved extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tstatic {\n+\t\t\t// empty\n+\t\t}\n+\n+\t\tpublic static class A {\n+\t\t\tprivate final String s;\n+\n+\t\t\tpublic A() {\n+\t\t\t\ts = \"a\";\n+\t\t\t}\n+\n+\t\t\tpublic A(String str) {\n+\t\t\t\ts = str;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic static class B extends A {\n+\t\t\tpublic B() {\n+\t\t\t\tsuper();\n+\t\t\t}\n+\n+\t\t\tpublic B(String s) {\n+\t\t\t\tsuper(s);\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tnew A();\n+\t\t\tnew A(\"a\");\n+\t\t\tnew B();\n+\t\t\tnew B(\"b\");\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, not(containsString(\"super();\")));\n+\t\tassertThat(code, not(containsString(\"static {\")));\n+\t\tassertThat(code, containsOne(\"public B() {\"));\n+\t}\n+}",
    "output": "Fix don't remove empty default constructor if other constructors exists"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -262,6 +262,7 @@ private void addMethods(CodeWriter code) {\n \t\t\t\tcode.newLine().addMultiLine(Utils.getStackTrace(e));\n \t\t\t\tcode.newLine().add(\"*/\");\n \t\t\t\tcode.setIndent(savedIndent);\n+\t\t\t\tmth.addError(\"Method generation error: \" + e.getMessage(), e);\n \t\t\t}\n \t\t}\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -116,6 +116,8 @@ public boolean addDefinition(CodeWriter code) {\n \t\t\t} else {\n \t\t\t\tmth.addComment(\"JADX WARN: Incorrect number of args for enum constructor: \" + args.size() + \" (expected >= 2)\");\n \t\t\t}\n+\t\t} else if (mth.contains(AFlag.SKIP_FIRST_ARG)) {\n+\t\t\targs = args.subList(1, args.size());\n \t\t}\n \t\taddMethodArguments(code, args);\n \t\tcode.add(')');\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n@@ -82,12 +82,7 @@ public void use(RegisterArg arg) {\n \t}\n \n \tpublic void removeUse(RegisterArg arg) {\n-\t\tfor (int i = 0, useListSize = useList.size(); i < useListSize; i++) {\n-\t\t\tif (useList.get(i) == arg) {\n-\t\t\t\tuseList.remove(i);\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n+\t\tuseList.removeIf(registerArg -> registerArg == arg);\n \t}\n \n \tpublic void setUsedInPhi(@Nullable PhiInsn usedInPhi) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java\n@@ -248,9 +248,8 @@ public List<RegisterArg> getArguments(boolean includeThis) {\n \t\treturn argsList;\n \t}\n \n-\tpublic RegisterArg removeFirstArgument() {\n+\tpublic void skipFirstArgument() {\n \t\tthis.add(AFlag.SKIP_FIRST_ARG);\n-\t\treturn argsList.remove(0);\n \t}\n \n \t@Nullable\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n@@ -120,7 +120,7 @@ private static boolean removeFieldUsageFromConstructor(MethodNode mth, FieldNode\n \t\tif (!fieldInfo.equals(field.getFieldInfo()) || !putInsn.getArg(0).equals(arg)) {\n \t\t\treturn false;\n \t\t}\n-\t\tmth.removeFirstArgument();\n+\t\tmth.skipFirstArgument();\n \t\tInstructionRemover.remove(mth, block, insn);\n \t\t// other arg usage -> wrap with IGET insn\n \t\tif (arg.getSVar().getUseCount() != 0) {",
    "output": "Fix hide first argument instead remove for constructor in inner class"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n@@ -29,7 +29,7 @@\n public class BlockSplitter extends AbstractVisitor {\n \n \t// leave these instructions alone in block node\n-\tprivate static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(\n+\tpublic static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(\n \t\t\tInsnType.RETURN,\n \t\t\tInsnType.IF,\n \t\t\tInsnType.SWITCH,\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java\n@@ -62,16 +62,16 @@ public void processBlock(MethodNode mth, IBlock container) {\n \t\t\t\t\t\t&& !block.contains(AFlag.DONT_GENERATE)\n \t\t\t\t\t\t&& !block.contains(AFlag.REMOVE)) {\n \t\t\t\t\tString blockCode = getBlockInsnStr(mth, block);\n-\t\t\t\t\tmth.addWarn(\"Missing block: \" + block + \", code skipped:\" + CodeWriter.NL + blockCode);\n+\t\t\t\t\tmth.addWarn(\"Code restructure failed: missing block: \" + block + \", code lost:\" + blockCode);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\t// check loop conditions\n \t\tDepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {\n \t\t\t@Override\n \t\t\tpublic boolean enterRegion(MethodNode mth, IRegion region) {\n \t\t\t\tif (region instanceof LoopRegion) {\n+\t\t\t\t\t// check loop conditions\n \t\t\t\t\tBlockNode loopHeader = ((LoopRegion) region).getHeader();\n \t\t\t\t\tif (loopHeader != null && loopHeader.getInstructions().size() != 1) {\n \t\t\t\t\t\tmth.addWarn(\"Incorrect condition in loop: \" + loopHeader);\n@@ -82,8 +82,9 @@ public boolean enterRegion(MethodNode mth, IRegion region) {\n \t\t});\n \t}\n \n-\tprivate static String getBlockInsnStr(MethodNode mth, BlockNode block) {\n+\tprivate static String getBlockInsnStr(MethodNode mth, IBlock block) {\n \t\tCodeWriter code = new CodeWriter();\n+\t\tcode.newLine();\n \t\tcode.setIndent(3);\n \t\tMethodGen mg = MethodGen.getFallbackMethodGen(mth);\n \t\tInsnGen ig = new InsnGen(mg, true);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -35,7 +35,9 @@\n import jadx.core.dex.visitors.ConstInlineVisitor;\n import jadx.core.dex.visitors.InitCodeVariables;\n import jadx.core.dex.visitors.JadxVisitor;\n+import jadx.core.dex.visitors.blocksmaker.BlockSplitter;\n import jadx.core.dex.visitors.ssa.SSATransform;\n+import jadx.core.utils.BlockUtils;\n import jadx.core.utils.Utils;\n \n @JadxVisitor(\n@@ -139,7 +141,7 @@ private boolean applyImmutableType(SSAVar ssaVar, ArgType initType) {\n \t\tTypeUpdateResult result = typeUpdate.apply(ssaVar, initType);\n \t\tif (result == TypeUpdateResult.REJECT) {\n \t\t\tif (Consts.DEBUG) {\n-\t\t\t\tLOG.info(\"Initial immutable type set rejected: {} -> {}\", ssaVar, initType);\n+\t\t\t\tLOG.warn(\"Initial immutable type set rejected: {} -> {}\", ssaVar, initType);\n \t\t\t}\n \t\t\treturn false;\n \t\t}\n@@ -317,6 +319,15 @@ private boolean tryInsertAdditionalInsn(MethodNode mth, SSAVar var) {\n \t\tfor (Map.Entry<RegisterArg, BlockNode> entry : phiInsn.getBlockBinds().entrySet()) {\n \t\t\tRegisterArg reg = entry.getKey();\n \t\t\tif (reg.getSVar() == var) {\n+\t\t\t\tBlockNode blockNode = entry.getValue();\n+\t\t\t\tInsnNode lastInsn = BlockUtils.getLastInsn(blockNode);\n+\t\t\t\tif (lastInsn != null && BlockSplitter.SEPARATE_INSNS.contains(lastInsn.getType())) {\n+\t\t\t\t\tif (Consts.DEBUG) {\n+\t\t\t\t\t\tLOG.warn(\"Can't insert move for PHI in block with separate insn: {}\", lastInsn);\n+\t\t\t\t\t}\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\n \t\t\t\tint regNum = reg.getRegNum();\n \t\t\t\tRegisterArg resultArg = reg.duplicate(regNum, null);\n \t\t\t\tSSAVar newSsaVar = mth.makeNewSVar(regNum, resultArg);\n@@ -326,7 +337,7 @@ private boolean tryInsertAdditionalInsn(MethodNode mth, SSAVar var) {\n \t\t\t\tmoveInsn.setResult(resultArg);\n \t\t\t\tmoveInsn.addArg(arg);\n \t\t\t\tmoveInsn.add(AFlag.SYNTHETIC);\n-\t\t\t\tentry.getValue().getInstructions().add(moveInsn);\n+\t\t\t\tblockNode.getInstructions().add(moveInsn);\n \n \t\t\t\tphiInsn.replaceArg(reg, reg.duplicate(regNum, newSsaVar));\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n@@ -12,6 +12,7 @@\n import org.slf4j.LoggerFactory;\n \n import jadx.core.Consts;\n+import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n@@ -278,7 +279,7 @@ private TypeUpdateResult moveListener(TypeUpdateInfo updateInfo, InsnNode insn,\n \t\t\t\treturn REJECT;\n \t\t\t}\n \t\t} else {\n-\t\t\tallowReject = false;\n+\t\t\tallowReject = arg.isThis() || arg.contains(AFlag.IMMUTABLE_TYPE);\n \t\t}\n \n \t\tTypeUpdateResult result = updateTypeChecked(updateInfo, changeArg, candidateType);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java\n@@ -27,10 +27,13 @@\n import jadx.core.dex.nodes.IRegion;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n+import jadx.core.dex.visitors.AbstractVisitor;\n import jadx.core.dex.visitors.DotGraphVisitor;\n+import jadx.core.dex.visitors.IDexTreeVisitor;\n import jadx.core.dex.visitors.regions.DepthRegionTraversal;\n import jadx.core.dex.visitors.regions.TracedRegionVisitor;\n import jadx.core.utils.exceptions.CodegenException;\n+import jadx.core.utils.exceptions.JadxException;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n \n @Deprecated\n@@ -70,6 +73,15 @@ public void processBlockTraced(MethodNode mth, IBlock container, IRegion current\n \t\tLOG.debug(\" Found block: {} in regions: {}\", block, regions);\n \t}\n \n+\tpublic static IDexTreeVisitor printRegionsVisitor() {\n+\t\treturn new AbstractVisitor() {\n+\t\t\t@Override\n+\t\t\tpublic void visit(MethodNode mth) throws JadxException {\n+\t\t\t\tprintRegions(mth, true);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n \tpublic static void printRegions(MethodNode mth) {\n \t\tprintRegions(mth, false);\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf2.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf2.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf2.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf2.java\n@@ -0,0 +1,38 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestComplexIf2 extends SmaliTest {\n+\n+/*\n+    public void test() {\n+        if (this.isSaved) {\n+            throw new RuntimeException(\"Error\");\n+        }\n+        if (LoaderUtils.isContextLoaderAvailable()) {\n+            this.savedContextLoader = LoaderUtils.getContextClassLoader();\n+            ClassLoader loader = this;\n+            if (this.project != null && \"simple\".equals(this.project)) {\n+                loader = getClass().getClassLoader();\n+            }\n+            LoaderUtils.setContextClassLoader(loader);\n+            this.isSaved = true;\n+        }\n+    }\n+*/\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tClassNode cls = getClassNodeFromSmaliWithPkg(\"conditions\", \"TestComplexIf2\");\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"if (this.project != null && \\\"simple\\\".equals(this.project)) {\"));\n+\t}\n+}",
    "output": "Fix check block before insert additional move instruction for type inference"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n@@ -18,7 +18,6 @@\n import jadx.core.dex.instructions.args.PrimitiveType;\n import jadx.core.dex.instructions.args.RegisterArg;\n import jadx.core.dex.instructions.args.SSAVar;\n-import jadx.core.dex.instructions.args.Typed;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.utils.exceptions.JadxOverflowException;\n@@ -57,11 +56,11 @@ public TypeUpdateResult apply(SSAVar ssaVar, ArgType candidateType) {\n \t\tif (result == REJECT) {\n \t\t\treturn result;\n \t\t}\n-\t\tMap<InsnArg, ArgType> updates = updateInfo.getUpdates();\n+\t\tList<TypeUpdateEntry> updates = updateInfo.getUpdates();\n \t\tif (updates.isEmpty()) {\n \t\t\treturn SAME;\n \t\t}\n-\t\tupdates.forEach(Typed::setType);\n+\t\tupdates.forEach(TypeUpdateEntry::apply);\n \t\treturn CHANGED;\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateEntry.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateEntry.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateEntry.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateEntry.java\n@@ -0,0 +1,31 @@\n+package jadx.core.dex.visitors.typeinference;\n+\n+import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.instructions.args.InsnArg;\n+\n+public final class TypeUpdateEntry {\n+\tprivate final InsnArg arg;\n+\tprivate final ArgType type;\n+\n+\tpublic TypeUpdateEntry(InsnArg arg, ArgType type) {\n+\t\tthis.arg = arg;\n+\t\tthis.type = type;\n+\t}\n+\n+\tpublic void apply() {\n+\t\targ.setType(type);\n+\t}\n+\n+\tpublic InsnArg getArg() {\n+\t\treturn arg;\n+\t}\n+\n+\tpublic ArgType getType() {\n+\t\treturn type;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"TypeUpdateEntry{\" + arg + \" -> \" + type + '}';\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateInfo.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateInfo.java\n@@ -1,28 +1,35 @@\n package jadx.core.dex.visitors.typeinference;\n \n-import java.util.IdentityHashMap;\n-import java.util.Map;\n+import java.util.ArrayList;\n+import java.util.List;\n \n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n \n public class TypeUpdateInfo {\n-\n-\tprivate final Map<InsnArg, ArgType> updates = new IdentityHashMap<>();\n+\tprivate final List<TypeUpdateEntry> updates = new ArrayList<>();\n \n \tpublic void requestUpdate(InsnArg arg, ArgType changeType) {\n-\t\tupdates.put(arg, changeType);\n+\t\tupdates.add(new TypeUpdateEntry(arg, changeType));\n \t}\n \n \tpublic boolean isProcessed(InsnArg arg) {\n-\t\treturn updates.containsKey(arg);\n+\t\tif (updates.isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tfor (TypeUpdateEntry entry : updates) {\n+\t\t\tif (entry.getArg() == arg) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n \t}\n \n \tpublic void rollbackUpdate(InsnArg arg) {\n-\t\tupdates.remove(arg);\n+\t\tupdates.removeIf(updateEntry -> updateEntry.getArg() == arg);\n \t}\n \n-\tpublic Map<InsnArg, ArgType> getUpdates() {\n+\tpublic List<TypeUpdateEntry> getUpdates() {\n \t\treturn updates;\n \t}\n }",
    "output": "Fix change type update collection to produce deterministic results"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n@@ -252,6 +252,7 @@ private Map<InsnType, ITypeListener> initListenerRegistry() {\n \t\tregistry.put(InsnType.ARITH, this::suggestAllSameListener);\n \t\tregistry.put(InsnType.NEG, this::suggestAllSameListener);\n \t\tregistry.put(InsnType.NOT, this::suggestAllSameListener);\n+\t\tregistry.put(InsnType.CHECK_CAST, this::checkCastListener);\n \t\treturn registry;\n \t}\n \n@@ -263,20 +264,23 @@ private TypeUpdateResult sameFirstArgListener(TypeUpdateInfo updateInfo, InsnNod\n \tprivate TypeUpdateResult moveListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {\n \t\tboolean assignChanged = isAssign(insn, arg);\n \t\tInsnArg changeArg = assignChanged ? insn.getArg(0) : insn.getResult();\n-\t\tTypeUpdateResult result = updateTypeChecked(updateInfo, changeArg, candidateType);\n-\t\tif (result == REJECT && changeArg.getType().isTypeKnown()) {\n+\t\tboolean allowReject;\n+\t\tif (changeArg.getType().isTypeKnown()) {\n \t\t\t// allow result to be wider\n-\t\t\tif (assignChanged) {\n-\t\t\t\tTypeCompareEnum compareTypes = comparator.compareTypes(candidateType, changeArg.getType());\n-\t\t\t\tif (compareTypes.isWider() && inBounds(changeArg, candidateType)) {\n-\t\t\t\t\treturn CHANGED;\n-\t\t\t\t}\n+\t\t\tTypeCompareEnum compareTypes = comparator.compareTypes(candidateType, changeArg.getType());\n+\t\t\tboolean correctType = assignChanged ? compareTypes.isWider() : compareTypes.isNarrow();\n+\t\t\tif (correctType && inBounds(changeArg, candidateType)) {\n+\t\t\t\tallowReject = true;\n \t\t\t} else {\n-\t\t\t\tTypeCompareEnum compareTypes = comparator.compareTypes(changeArg.getType(), candidateType);\n-\t\t\t\tif (compareTypes.isWider() && inBounds(changeArg, candidateType)) {\n-\t\t\t\t\treturn CHANGED;\n-\t\t\t\t}\n+\t\t\t\treturn REJECT;\n \t\t\t}\n+\t\t} else {\n+\t\t\tallowReject = false;\n+\t\t}\n+\n+\t\tTypeUpdateResult result = updateTypeChecked(updateInfo, changeArg, candidateType);\n+\t\tif (result == REJECT && allowReject) {\n+\t\t\treturn CHANGED;\n \t\t}\n \t\treturn result;\n \t}\n@@ -324,6 +328,15 @@ private TypeUpdateResult suggestAllSameListener(TypeUpdateInfo updateInfo, InsnN\n \t\treturn allSame ? SAME : CHANGED;\n \t}\n \n+\tprivate TypeUpdateResult checkCastListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {\n+\t\tif (!isAssign(insn, arg)) {\n+\t\t\treturn SAME;\n+\t\t}\n+\t\tInsnArg insnArg = insn.getArg(0);\n+\t\tTypeUpdateResult result = updateTypeChecked(updateInfo, insnArg, candidateType);\n+\t\treturn result == REJECT ? SAME : result;\n+\t}\n+\n \tprivate TypeUpdateResult arrayGetListener(TypeUpdateInfo updateInfo, InsnNode insn, InsnArg arg, ArgType candidateType) {\n \t\tif (isAssign(insn, arg)) {\n \t\t\treturn updateTypeChecked(updateInfo, insn.getArg(0), ArgType.array(candidateType));\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver7.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver7.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver7.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver7.java\n@@ -0,0 +1,49 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestTypeResolver7 extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic void test(boolean a, boolean b) {\n+\t\t\tObject obj = null;\n+\t\t\tif (a) {\n+\t\t\t\tuse(b ? (Exception) getObj() : (Exception) obj);\n+\t\t\t} else {\n+\t\t\t\tRunnable r = (Runnable) obj;\n+\t\t\t\tif (b) {\n+\t\t\t\t\tr = (Runnable) getObj();\n+\t\t\t\t}\n+\t\t\t\tuse(r);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate Object getObj() {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprivate void use(Exception e) {}\n+\n+\t\tprivate void use(Runnable r) {}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"use(b ? (Exception) getObj() : null);\"));\n+\t}\n+\n+\t@Test\n+\tpublic void testNoDebug() {\n+\t\tnoDebugInfo();\n+\t\tgetClassNode(TestCls.class);\n+\t}\n+}",
    "output": "Add correct type propagation for check-cast and move instructions"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n@@ -54,6 +54,10 @@ public static ClassNode searchAppResClass(RootNode root, ResourceStorage resStor\n \t\t}\n \t\tLOG.info(\"App 'R' class not found, put all resources ids to : '{}'\", fullName);\n \t\tresCls = makeClass(root, fullName, resStorage);\n+\t\tif (resCls == null) {\n+\t\t\t// We are in an APK without code therefore we don't have to update an 'R' class with the resources\n+\t\t\treturn null;\n+\t\t}\n \t\taddResourceFields(resCls, resStorage, false);\n \t\treturn resCls;\n \t}\n@@ -81,18 +85,18 @@ private static ClassNode makeClass(RootNode root, String clsName, ResourceStorag\n \t\treturn rCls;\n \t}\n \n-\tprivate static void addResourceFields(ClassNode cls, ResourceStorage resStorage, boolean rClsExists) {\n+\tprivate static void addResourceFields(ClassNode resCls, ResourceStorage resStorage, boolean rClsExists) {\n \t\tMap<String, ClassNode> innerClsMap = new TreeMap<>();\n \t\tif (rClsExists) {\n-\t\t\tfor (ClassNode innerClass : cls.getInnerClasses()) {\n+\t\t\tfor (ClassNode innerClass : resCls.getInnerClasses()) {\n \t\t\t\tinnerClsMap.put(innerClass.getShortName(), innerClass);\n \t\t\t}\n \t\t}\n \t\tfor (ResourceEntry resource : resStorage.getResources()) {\n \t\t\tClassNode typeCls = innerClsMap.computeIfAbsent(resource.getTypeName(), name -> {\n-\t\t\t\tClassNode newTypeCls = new ClassNode(cls.dex(), cls.getFullName() + \"$\" + name,\n+\t\t\t\tClassNode newTypeCls = new ClassNode(resCls.dex(), resCls.getFullName() + \"$\" + name,\n \t\t\t\t\t\tAccessFlags.ACC_PUBLIC | AccessFlags.ACC_STATIC | AccessFlags.ACC_FINAL);\n-\t\t\t\tcls.addInnerClass(newTypeCls);\n+\t\t\t\tresCls.addInnerClass(newTypeCls);\n \t\t\t\tif (rClsExists) {\n \t\t\t\t\tnewTypeCls.addAttr(AType.COMMENTS, \"added by JADX\");\n \t\t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n@@ -77,8 +77,7 @@ private void searchDexFiles(boolean skipSources) throws IOException, DecodeExcep\n \t\tif (skipSources) {\n \t\t\treturn;\n \t\t}\n-\n-\t\tthrow new DecodeException(\"Unsupported input file format: \" + file);\n+\t\tLOG.warn(\"No dex files found in {}\", file);\n \t}\n \n \tprivate void addDexFile(Dex dexBuf) {",
    "output": "Fix allow APK files without code (no contained dex files)"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -483,21 +483,7 @@ private String prepareNamePart(String name) {\n \t\tif (name.length() > maxLength) {\n \t\t\treturn \"x\" + Integer.toHexString(name.hashCode());\n \t\t}\n-\t\tif (!NameMapper.isAllCharsPrintable(name)) {\n-\t\t\treturn removeInvalidChars(name);\n-\t\t}\n-\t\treturn name;\n-\t}\n-\n-\tprivate String removeInvalidChars(String name) {\n-\t\tStringBuilder sb = new StringBuilder();\n-\t\tfor (int i = 0; i < name.length(); i++) {\n-\t\t\tint ch = name.charAt(i);\n-\t\t\tif (NameMapper.isPrintableChar(ch)) {\n-\t\t\t\tsb.append((char) ch);\n-\t\t\t}\n-\t\t}\n-\t\treturn sb.toString();\n+\t\treturn NameMapper.removeInvalidCharsMiddle(name);\n \t}\n \n \tprivate void dumpClassAlias(ClassNode cls) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n@@ -91,6 +91,14 @@ public static boolean isValidFullIdentifier(String str) {\n \t\t\t\t&& isAllCharsPrintable(str);\n \t}\n \n+\tpublic static boolean isValidIdentifierStart(int codePoint) {\n+\t\treturn Character.isJavaIdentifierStart(codePoint);\n+\t}\n+\n+\tpublic static boolean isValidIdentifierPart(int codePoint) {\n+\t\treturn Character.isJavaIdentifierPart(codePoint);\n+\t}\n+\n \tpublic static boolean isPrintableChar(int c) {\n \t\treturn 32 <= c && c <= 126;\n \t}\n@@ -105,6 +113,49 @@ public static boolean isAllCharsPrintable(String str) {\n \t\treturn true;\n \t}\n \n+\t/**\n+\t * Return modified string with removed:\n+\t * <p><ul>\n+\t * <li> not printable chars (including unicode)\n+\t * <li> chars not valid for java identifier part\n+\t * </ul><p>\n+\t * Note: this 'middle' method must be used with prefixed string:\n+\t * <p><ul>\n+\t * <li> can leave invalid chars for java identifier start (i.e numbers)\n+\t * <li> result not checked for reserved words\n+\t * </ul><p>\n+\t */\n+\tpublic static String removeInvalidCharsMiddle(String name) {\n+\t\tif (isValidIdentifier(name) && isAllCharsPrintable(name)) {\n+\t\t\treturn name;\n+\t\t}\n+\t\tint len = name.length();\n+\t\tStringBuilder sb = new StringBuilder(len);\n+\t\tfor (int i = 0; i < len; i++) {\n+\t\t\tint codePoint = name.codePointAt(i);\n+\t\t\tif (isPrintableChar(codePoint) && isValidIdentifierPart(codePoint)) {\n+\t\t\t\tsb.append((char) codePoint);\n+\t\t\t}\n+\t\t}\n+\t\treturn sb.toString();\n+\t}\n+\n+\t/**\n+\t * Return string with removed invalid chars, see {@link #removeInvalidCharsMiddle}\n+\t * <p>\n+\t * Prepend prefix if first char is not valid as java identifier start char.\n+\t */\n+\tpublic static String removeInvalidChars(String name, String prefix) {\n+\t\tString result = removeInvalidCharsMiddle(name);\n+\t\tif (!result.isEmpty()) {\n+\t\t\tint codePoint = result.codePointAt(0);\n+\t\t\tif (!isValidIdentifierStart(codePoint)) {\n+\t\t\t\treturn prefix + result;\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n \tprivate NameMapper() {\n \t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -72,14 +72,9 @@ private void checkClassName(ClassNode cls) {\n \t\tClassInfo classInfo = cls.getClassInfo();\n \t\tClassInfo alias = classInfo.getAlias();\n \t\tString clsName = alias.getShortName();\n-\t\tString newShortName = null;\n-\t\tchar firstChar = clsName.charAt(0);\n-\t\tif (Character.isDigit(firstChar)) {\n-\t\t\tnewShortName = Consts.ANONYMOUS_CLASS_PREFIX + clsName;\n-\t\t} else if (firstChar == '$') {\n-\t\t\tnewShortName = \"C\" + clsName;\n-\t\t}\n-\t\tif (newShortName != null) {\n+\n+\t\tString newShortName = fixClsShortName(clsName);\n+\t\tif (!newShortName.equals(clsName)) {\n \t\t\tclassInfo.rename(cls.root(), alias.makeFullClsName(newShortName, true));\n \t\t}\n \t\tif (alias.getPackage().isEmpty()) {\n@@ -89,6 +84,17 @@ private void checkClassName(ClassNode cls) {\n \t\t}\n \t}\n \n+\tprivate String fixClsShortName(String clsName) {\n+\t\tchar firstChar = clsName.charAt(0);\n+\t\tif (Character.isDigit(firstChar)) {\n+\t\t\treturn Consts.ANONYMOUS_CLASS_PREFIX + NameMapper.removeInvalidCharsMiddle(clsName);\n+\t\t}\n+\t\tif (firstChar == '$') {\n+\t\t\treturn 'C' + NameMapper.removeInvalidCharsMiddle(clsName);\n+\t\t}\n+\t\treturn NameMapper.removeInvalidChars(clsName, \"C\");\n+\t}\n+\n \tprivate void checkFields(ClassNode cls) {\n \t\tSet<String> names = new HashSet<>();\n \t\tfor (FieldNode field : cls.getFields()) {\n\ndiff --git a/jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java b/jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java\n--- a/jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java\n+++ b/jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java\n@@ -0,0 +1,38 @@\n+package jadx.core.deobf;\n+\n+import org.junit.Test;\n+\n+import static jadx.core.deobf.NameMapper.isValidIdentifier;\n+import static jadx.core.deobf.NameMapper.removeInvalidChars;\n+import static jadx.core.deobf.NameMapper.removeInvalidCharsMiddle;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+public class NameMapperTest {\n+\n+\t@Test\n+\tpublic void validIdentifiers() {\n+\t\tassertThat(isValidIdentifier(\"ACls\"), is(true));\n+\t}\n+\n+\t@Test\n+\tpublic void notValidIdentifiers() {\n+\t\tassertThat(isValidIdentifier(\"1cls\"), is(false));\n+\t\tassertThat(isValidIdentifier(\"-cls\"), is(false));\n+\t\tassertThat(isValidIdentifier(\"A-cls\"), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testRemoveInvalidCharsMiddle() {\n+\t\tassertThat(removeInvalidCharsMiddle(\"1cls\"), is(\"1cls\"));\n+\t\tassertThat(removeInvalidCharsMiddle(\"-cls\"), is(\"cls\"));\n+\t\tassertThat(removeInvalidCharsMiddle(\"A-cls\"), is(\"Acls\"));\n+\t}\n+\n+\t@Test\n+\tpublic void testRemoveInvalidChars() {\n+\t\tassertThat(removeInvalidChars(\"1cls\", \"C\"), is(\"C1cls\"));\n+\t\tassertThat(removeInvalidChars(\"-cls\", \"C\"), is(\"cls\"));\n+\t\tassertThat(removeInvalidChars(\"A-cls\", \"C\"), is(\"Acls\"));\n+\t}\n+}",
    "output": "Remove invalid chars from class names"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/EliminatePhiNodes.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/EliminatePhiNodes.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/EliminatePhiNodes.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/EliminatePhiNodes.java\n@@ -1,5 +1,6 @@\n package jadx.core.dex.visitors.ssa;\n \n+import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n \n@@ -111,7 +112,7 @@ private void replaceMerge(MethodNode mth, BlockNode block, InsnNode insn) {\n \t\tif (assignParentInsn != null) {\n \t\t\tassignParentInsn.setResult(newAssignArg);\n \t\t}\n-\t\tfor (RegisterArg useArg : oldSVar.getUseList()) {\n+\t\tfor (RegisterArg useArg : new ArrayList<>(oldSVar.getUseList())) {\n \t\t\tRegisterArg newUseArg = useArg.duplicate(newRegNum, newSVar);\n \t\t\tInsnNode parentInsn = useArg.getParentInsn();\n \t\t\tif (parentInsn != null) {",
    "output": "Fix avoid ConcurrentModificationException in EliminatePhiNodes pass"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n@@ -1,7 +1,10 @@\n package jadx.core.dex.visitors.blocksmaker;\n \n+import java.util.ArrayDeque;\n+import java.util.Deque;\n import java.util.EnumSet;\n import java.util.HashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -47,6 +50,7 @@ public void visit(MethodNode mth) {\n \t\tremoveJumpAttr(mth);\n \t\tremoveInsns(mth);\n \t\tremoveEmptyDetachedBlocks(mth);\n+\t\tremoveUnreachableBlocks(mth);\n \t\tinitBlocksInTargetNodes(mth);\n \t}\n \n@@ -324,4 +328,37 @@ static boolean removeEmptyDetachedBlocks(MethodNode mth) {\n \t\t\t\t\t\t&& block.getSuccessors().isEmpty()\n \t\t);\n \t}\n+\n+\tprivate void removeUnreachableBlocks(MethodNode mth) {\n+\t\tSet<BlockNode> toRemove = new LinkedHashSet<>();\n+\t\tfor (BlockNode block : mth.getBasicBlocks()) {\n+\t\t\tif (block.getPredecessors().isEmpty() && block != mth.getEnterBlock()) {\n+\t\t\t\ttoRemove.add(block);\n+\t\t\t\tcollectSuccessors(block, toRemove);\n+\t\t\t}\n+\t\t}\n+\t\tif (!toRemove.isEmpty()) {\n+\t\t\tmth.getBasicBlocks().removeIf(toRemove::contains);\n+\n+\t\t\tint insnsCount = toRemove.stream().mapToInt(block -> block.getInstructions().size()).sum();\n+\t\t\tmth.addAttr(AType.COMMENTS, \"JADX INFO: unreachable blocks removed: \" + toRemove.size()\n+\t\t\t\t\t+ \", instructions: \" + insnsCount);\n+\t\t}\n+\t}\n+\n+\tprivate void collectSuccessors(BlockNode startBlock, Set<BlockNode> toRemove) {\n+\t\tDeque<BlockNode> stack = new ArrayDeque<>();\n+\t\tstack.add(startBlock);\n+\t\twhile (!stack.isEmpty()) {\n+\t\t\tBlockNode block = stack.pop();\n+\t\t\tif (!toRemove.contains(block)) {\n+\t\t\t\tfor (BlockNode successor : block.getSuccessors()) {\n+\t\t\t\t\tif (toRemove.containsAll(successor.getPredecessors())) {\n+\t\t\t\t\t\tstack.push(successor);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\ttoRemove.add(block);\n+\t\t}\n+\t}\n }",
    "output": "Remove unreachable blocks"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java\n--- a/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java\n@@ -53,13 +53,18 @@ private static void validateOutDirs(JadxArgs args) {\n \t\t\t} else {\n \t\t\t\toutDir = makeDirFromInput(args);\n \t\t\t}\n+\t\t\targs.setOutDir(outDir);\n+\t\t}\n+\t\tif (srcDir == null) {\n+\t\t\targs.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));\n+\t\t}\n+\t\tif (resDir == null) {\n+\t\t\targs.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));\n \t\t}\n-\t\targs.setOutDir(outDir);\n-\t\tsetFromOut(args);\n \n-\t\tcheckDir(args.getOutDir());\n-\t\tcheckDir(args.getOutDirSrc());\n-\t\tcheckDir(args.getOutDirRes());\n+\t\tcheckDir(args.getOutDir(), \"Output\");\n+\t\tcheckDir(args.getOutDirSrc(), \"Source output\");\n+\t\tcheckDir(args.getOutDirRes(), \"Resources output\");\n \t}\n \n \t@NotNull\n@@ -79,15 +84,6 @@ private static File makeDirFromInput(JadxArgs args) {\n \t\treturn outDir;\n \t}\n \n-\tprivate static void setFromOut(JadxArgs args) {\n-\t\tif (args.getOutDirSrc() == null) {\n-\t\t\targs.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));\n-\t\t}\n-\t\tif (args.getOutDirRes() == null) {\n-\t\t\targs.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));\n-\t\t}\n-\t}\n-\n \tprivate static void checkFile(File file) {\n \t\tif (!file.exists()) {\n \t\t\tthrow new JadxArgsValidateException(\"File not found \" + file.getAbsolutePath());\n@@ -97,9 +93,9 @@ private static void checkFile(File file) {\n \t\t}\n \t}\n \n-\tprivate static void checkDir(File dir) {\n+\tprivate static void checkDir(File dir, String desc) {\n \t\tif (dir != null && dir.exists() && !dir.isDirectory()) {\n-\t\t\tthrow new JadxArgsValidateException(\"Output directory exists as file \" + dir);\n+\t\t\tthrow new JadxArgsValidateException(desc + \" directory exists as file \" + dir);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n@@ -35,7 +35,7 @@ public void openFile(File file) {\n \t\t\tthis.decompiler.getArgs().setInputFiles(Collections.singletonList(file));\n \t\t\tthis.decompiler.load();\n \t\t} catch (Exception e) {\n-\t\t\tLOG.error(\"Error load file: {}\", file, e);\n+\t\t\tLOG.error(\"Jadx init error\", e);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -26,12 +26,12 @@ public class JadxSettings extends JadxCLIArgs {\n \n \tprivate static final String USER_HOME = System.getProperty(\"user.home\");\n \tprivate static final int RECENT_FILES_COUNT = 15;\n-\tprivate static final int CURRENT_SETTINGS_VERSION = 7;\n+\tprivate static final int CURRENT_SETTINGS_VERSION = 8;\n \n \tprivate static final Font DEFAULT_FONT = new RSyntaxTextArea().getFont();\n \n \tstatic final Set<String> SKIP_FIELDS = new HashSet<>(Arrays.asList(\n-\t\t\t\"files\", \"input\", \"outputDir\", \"verbose\", \"printHelp\"\n+\t\t\t\"files\", \"input\", \"outDir\", \"outDirSrc\", \"outDirRes\", \"verbose\", \"printVersion\", \"printHelp\"\n \t));\n \tprivate String lastOpenFilePath = USER_HOME;\n \tprivate String lastSaveFilePath = USER_HOME;\n@@ -323,6 +323,12 @@ private void upgradeSettings(int fromVersion) {\n \t\t\tif (getFont().getFontName().equals(\"Hack Regular\")) {\n \t\t\t\tsetFont(null);\n \t\t\t}\n+\t\t\tfromVersion++;\n+\t\t}\n+\t\tif (fromVersion == 7) {\n+\t\t\toutDir = null;\n+\t\t\toutDirSrc = null;\n+\t\t\toutDirRes = null;\n \t\t}\n \t\tsettingsVersion = CURRENT_SETTINGS_VERSION;\n \t\tsync();",
    "output": "Remove output directories from persistent settings"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -205,11 +205,11 @@ protected void useType(CodeWriter code, ArgType type) {\n \t\tmgen.getClassGen().useType(code, type);\n \t}\n \n-\tpublic boolean makeInsn(InsnNode insn, CodeWriter code) throws CodegenException {\n-\t\treturn makeInsn(insn, code, null);\n+\tpublic void makeInsn(InsnNode insn, CodeWriter code) throws CodegenException {\n+\t\tmakeInsn(insn, code, null);\n \t}\n \n-\tprotected boolean makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws CodegenException {\n+\tprotected void makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws CodegenException {\n \t\ttry {\n \t\t\tSet<Flags> state = EnumSet.noneOf(Flags.class);\n \t\t\tif (flag == Flags.BODY_ONLY || flag == Flags.BODY_ONLY_NOWRAP) {\n@@ -231,7 +231,6 @@ protected boolean makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws Co\n \t\t} catch (Exception th) {\n \t\t\tthrow new CodegenException(mth, \"Error generate insn: \" + insn, th);\n \t\t}\n-\t\treturn true;\n \t}\n \n \tprivate void makeInsnBody(CodeWriter code, InsnNode insn, Set<Flags> state) throws CodegenException {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -11,8 +11,10 @@\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.annotations.MethodParameters;\n+import jadx.core.dex.attributes.nodes.JumpInfo;\n import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.info.ClassInfo;\n+import jadx.core.dex.instructions.IfNode;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.CodeVar;\n@@ -136,7 +138,6 @@ private void addMethodArguments(CodeWriter code, List<RegisterArg> args) {\n \t\t\t} else {\n \t\t\t\tvar = ssaVar.getCodeVar();\n \t\t\t}\n-\t\t\tArgType argType = var.getType();\n \n \t\t\t// add argument annotation\n \t\t\tif (paramsAnnotation != null) {\n@@ -145,6 +146,7 @@ private void addMethodArguments(CodeWriter code, List<RegisterArg> args) {\n \t\t\tif (var.isFinal()) {\n \t\t\t\tcode.add(\"final \");\n \t\t\t}\n+\t\t\tArgType argType = var.getType();\n \t\t\tif (!it.hasNext() && mth.getAccessFlags().isVarArgs()) {\n \t\t\t\t// change last array argument to varargs\n \t\t\t\tif (argType.isArray()) {\n@@ -197,6 +199,7 @@ public void addFallbackMethodCode(CodeWriter code) {\n \t\tif (mth.getInstructions() == null) {\n \t\t\t// load original instructions\n \t\t\ttry {\n+\t\t\t\tmth.unload();\n \t\t\t\tmth.load();\n \t\t\t\tDepthTraversal.visit(new FallbackModeVisitor(), mth);\n \t\t\t} catch (DecodeException e) {\n@@ -218,27 +221,57 @@ public void addFallbackMethodCode(CodeWriter code) {\n \n \tpublic static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[] insnArr, boolean addLabels) {\n \t\tInsnGen insnGen = new InsnGen(getFallbackMethodGen(mth), true);\n+\t\tInsnNode prevInsn = null;\n \t\tfor (InsnNode insn : insnArr) {\n \t\t\tif (insn == null || insn.getType() == InsnType.NOP) {\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tif (addLabels && (insn.contains(AType.JUMP) || insn.contains(AType.EXC_HANDLER))) {\n+\t\t\tif (addLabels && needLabel(insn, prevInsn)) {\n \t\t\t\tcode.decIndent();\n \t\t\t\tcode.startLine(getLabelName(insn.getOffset()) + \":\");\n \t\t\t\tcode.incIndent();\n \t\t\t}\n \t\t\ttry {\n-\t\t\t\tif (insnGen.makeInsn(insn, code)) {\n-\t\t\t\t\tCatchAttr catchAttr = insn.get(AType.CATCH_BLOCK);\n-\t\t\t\t\tif (catchAttr != null) {\n-\t\t\t\t\t\tcode.add(\"\\t \" + catchAttr);\n+\t\t\t\tcode.startLine();\n+\t\t\t\tRegisterArg resArg = insn.getResult();\n+\t\t\t\tif (resArg != null) {\n+\t\t\t\t\tArgType varType = resArg.getInitType();\n+\t\t\t\t\tif (varType.isTypeKnown()) {\n+\t\t\t\t\t\tcode.add(varType.toString()).add(' ');\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tinsnGen.makeInsn(insn, code, InsnGen.Flags.INLINE);\n+\t\t\t\tCatchAttr catchAttr = insn.get(AType.CATCH_BLOCK);\n+\t\t\t\tif (catchAttr != null) {\n+\t\t\t\t\tcode.add(\"     // \" + catchAttr);\n+\t\t\t\t}\n \t\t\t} catch (CodegenException e) {\n \t\t\t\tLOG.debug(\"Error generate fallback instruction: \", e.getCause());\n \t\t\t\tcode.startLine(\"// error: \" + insn);\n \t\t\t}\n+\t\t\tprevInsn = insn;\n+\t\t}\n+\t}\n+\n+\tprivate static boolean needLabel(InsnNode insn, InsnNode prevInsn) {\n+\t\tif (insn.contains(AType.EXC_HANDLER)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (insn.contains(AType.JUMP)) {\n+\t\t\t// don't add label for ifs else branch\n+\t\t\tif (prevInsn != null && prevInsn.getType() == InsnType.IF) {\n+\t\t\t\tList<JumpInfo> jumps = insn.getAll(AType.JUMP);\n+\t\t\t\tif (jumps.size() == 1) {\n+\t\t\t\t\tJumpInfo jump = jumps.get(0);\n+\t\t\t\t\tif (jump.getSrc() == prevInsn.getOffset() && jump.getDest() == insn.getOffset()) {\n+\t\t\t\t\t\tint target = ((IfNode) prevInsn).getTarget();\n+\t\t\t\t\t\treturn insn.getOffset() == target;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true;\n \t\t}\n+\t\treturn false;\n \t}\n \n \t/**\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/fallback/TestFallbackMode.java b/jadx-core/src/test/java/jadx/tests/integration/fallback/TestFallbackMode.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/fallback/TestFallbackMode.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/fallback/TestFallbackMode.java\n@@ -5,6 +5,7 @@\n import jadx.core.dex.nodes.ClassNode;\n import jadx.tests.api.IntegrationTest;\n \n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n import static org.hamcrest.CoreMatchers.containsString;\n import static org.hamcrest.CoreMatchers.not;\n import static org.junit.Assert.assertThat;\n@@ -30,8 +31,10 @@ public void test() {\n \t\tString code = cls.getCode().toString();\n \n \t\tassertThat(code, containsString(\"public int test(int r2) {\"));\n-\t\tassertThat(code, containsString(\"r1 = this;\"));\n-\t\tassertThat(code, containsString(\"L_0x0004:\"));\n+\t\tassertThat(code, containsOne(\"r1 = this;\"));\n+\t\tassertThat(code, containsOne(\"L_0x0000:\"));\n+\t\tassertThat(code, containsOne(\"L_0x0007:\"));\n+\t\tassertThat(code, containsOne(\"int r2 = r2 + 1\"));\n \t\tassertThat(code, not(containsString(\"throw new UnsupportedOperationException\")));\n \t}\n }",
    "output": "Fix improve fallback mode dump (add types, remove label after if)"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -10,6 +10,7 @@\n import java.util.Set;\n \n import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;\n+import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -20,16 +21,14 @@\n import jadx.gui.utils.NLS;\n import jadx.gui.utils.Utils;\n \n-import static jadx.gui.utils.Utils.FONT_HACK;\n-\n public class JadxSettings extends JadxCLIArgs {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(JadxSettings.class);\n \n \tprivate static final String USER_HOME = System.getProperty(\"user.home\");\n \tprivate static final int RECENT_FILES_COUNT = 15;\n-\tprivate static final int CURRENT_SETTINGS_VERSION = 6;\n+\tprivate static final int CURRENT_SETTINGS_VERSION = 7;\n \n-\tprivate static final Font DEFAULT_FONT = FONT_HACK != null ? FONT_HACK : new RSyntaxTextArea().getFont();\n+\tprivate static final Font DEFAULT_FONT = new RSyntaxTextArea().getFont();\n \n \tstatic final Set<String> SKIP_FIELDS = new HashSet<>(Arrays.asList(\n \t\t\t\"files\", \"input\", \"outputDir\", \"verbose\", \"printHelp\"\n@@ -263,7 +262,11 @@ public Font getFont() {\n \t\treturn Font.decode(fontStr);\n \t}\n \n-\tpublic void setFont(Font font) {\n+\tpublic void setFont(@Nullable Font font) {\n+\t\tif (font == null) {\n+\t\t\tthis.fontStr = \"\";\n+\t\t\treturn;\n+\t\t}\n \t\tStringBuilder sb = new StringBuilder();\n \t\tsb.append(font.getFontName());\n \t\tString fontStyleName = Utils.getFontStyleName(font.getStyle()).replaceAll(\" \", \"\");\n@@ -314,6 +317,12 @@ private void upgradeSettings(int fromVersion) {\n \t\t}\n \t\tif (fromVersion == 5) {\n \t\t\tsetRespectBytecodeAccessModifiers(false);\n+\t\t\tfromVersion++;\n+\t\t}\n+\t\tif (fromVersion == 6) {\n+\t\t\tif (getFont().getFontName().equals(\"Hack Regular\")) {\n+\t\t\t\tsetFont(null);\n+\t\t\t}\n \t\t}\n \t\tsettingsVersion = CURRENT_SETTINGS_VERSION;\n \t\tsync();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -74,6 +74,7 @@ private void initUI() {\n \t\tJButton cancelButton = new JButton(NLS.str(\"preferences.cancel\"));\n \t\tcancelButton.addActionListener(event -> {\n \t\t\tJadxSettingsAdapter.fill(settings, startSettings);\n+\t\t\tmainWindow.loadSettings();\n \t\t\tdispose();\n \t\t});\n \n@@ -87,6 +88,8 @@ private void initUI() {\n \t\t\tif (res == JOptionPane.YES_OPTION) {\n \t\t\t\tString defaults = JadxSettingsAdapter.makeString(JadxSettings.makeDefault());\n \t\t\t\tJadxSettingsAdapter.fill(settings, defaults);\n+\t\t\t\tmainWindow.loadSettings();\n+\t\t\t\tneedReload();\n \t\t\t\tgetContentPane().removeAll();\n \t\t\t\tinitUI();\n \t\t\t\tpack();\n@@ -197,7 +200,6 @@ public void mouseClicked(MouseEvent e) {\n \t\t\t\t\tFont font = fontChooser.getSelectedFont();\n \t\t\t\t\tLOG.debug(\"Selected Font: {}\", font);\n \t\t\t\t\tsettings.setFont(font);\n-\t\t\t\t\tmainWindow.updateFont(font);\n \t\t\t\t\tmainWindow.loadSettings();\n \t\t\t\t\tfontLabel.setText(getFontLabelStr());\n \t\t\t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -652,10 +652,6 @@ public void setLocationAndPosition() {\n \t\tsetSize((int) (w * WINDOW_RATIO), (int) (h * WINDOW_RATIO));\n \t}\n \n-\tpublic void updateFont(Font font) {\n-\t\tsetFont(font);\n-\t}\n-\n \tpublic static void registerBundledFonts() {\n \t\tGraphicsEnvironment grEnv = GraphicsEnvironment.getLocalGraphicsEnvironment();\n \t\tif (Utils.FONT_HACK != null) {",
    "output": "Use system font as default instead bundled Hack (#442, #445)"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -104,7 +104,9 @@ private void initUI() {\n \t\tbuttonPane.add(cancelButton);\n \n \t\tContainer contentPane = getContentPane();\n-\t\tcontentPane.add(panel, BorderLayout.CENTER);\n+\t\tJScrollPane scrollPane = new JScrollPane(panel);\n+\t\tscrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n+\t\tcontentPane.add(scrollPane, BorderLayout.CENTER);\n \t\tcontentPane.add(buttonPane, BorderLayout.PAGE_END);\n \t\tgetRootPane().setDefaultButton(saveBtn);\n \t}",
    "output": "Add scroll to preferences dialog"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -18,6 +18,7 @@\n import jadx.gui.ui.codearea.EditorTheme;\n import jadx.gui.utils.LangLocale;\n import jadx.gui.utils.NLS;\n+import jadx.gui.utils.Utils;\n \n import static jadx.gui.utils.Utils.FONT_HACK;\n \n@@ -263,7 +264,14 @@ public Font getFont() {\n \t}\n \n \tpublic void setFont(Font font) {\n-\t\tthis.fontStr = font.getFontName() + addStyleName(font.getStyle()) + \"-\" + font.getSize();\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tsb.append(font.getFontName());\n+\t\tString fontStyleName = Utils.getFontStyleName(font.getStyle()).replaceAll(\" \", \"\");\n+\t\tif (!fontStyleName.isEmpty()) {\n+\t\t\tsb.append('-').append(fontStyleName.toUpperCase());\n+\t\t}\n+\t\tsb.append('-').append(font.getSize());\n+\t\tthis.fontStr = sb.toString();\n \t}\n \n \tpublic String getEditorThemePath() {\n@@ -274,19 +282,6 @@ public void setEditorThemePath(String editorThemePath) {\n \t\tthis.editorThemePath = editorThemePath;\n \t}\n \n-\tprivate static String addStyleName(int style) {\n-\t\tswitch (style) {\n-\t\t\tcase Font.BOLD:\n-\t\t\t\treturn \"-BOLD\";\n-\t\t\tcase Font.PLAIN:\n-\t\t\t\treturn \"-PLAIN\";\n-\t\t\tcase Font.ITALIC:\n-\t\t\t\treturn \"-ITALIC\";\n-\t\t\tdefault:\n-\t\t\t\treturn \"\";\n-\t\t}\n-\t}\n-\n \tprivate void upgradeSettings(int fromVersion) {\n \t\tLOG.debug(\"upgrade settings from version: {} to {}\", fromVersion, CURRENT_SETTINGS_VERSION);\n \t\tif (fromVersion == 0) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -16,6 +16,7 @@\n import jadx.gui.ui.codearea.EditorTheme;\n import jadx.gui.utils.LangLocale;\n import jadx.gui.utils.NLS;\n+import jadx.gui.utils.Utils;\n \n public class JadxSettingsWindow extends JDialog {\n \tprivate static final long serialVersionUID = -1804570470377354148L;\n@@ -164,21 +165,6 @@ private void enableComponentList(Collection<JComponent> connectedComponents, boo\n \n \tprivate SettingsGroup makeEditorGroup() {\n \t\tJButton fontBtn = new JButton(NLS.str(\"preferences.select_font\"));\n-\t\tfontBtn.addMouseListener(new MouseAdapter() {\n-\t\t\t@Override\n-\t\t\tpublic void mouseClicked(MouseEvent e) {\n-\t\t\t\tJFontChooser fontChooser = new JFontChooser();\n-\t\t\t\tfontChooser.setSelectedFont(settings.getFont());\n-\t\t\t\tint result = fontChooser.showDialog(JadxSettingsWindow.this);\n-\t\t\t\tif (result == JFontChooser.OK_OPTION) {\n-\t\t\t\t\tFont font = fontChooser.getSelectedFont();\n-\t\t\t\t\tLOG.debug(\"Selected Font: {}\", font);\n-\t\t\t\t\tsettings.setFont(font);\n-\t\t\t\t\tmainWindow.updateFont(font);\n-\t\t\t\t\tmainWindow.loadSettings();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n \n \t\tEditorTheme[] editorThemes = EditorTheme.getAllThemes();\n \t\tJComboBox<EditorTheme> themesCbx = new JComboBox<>(editorThemes);\n@@ -196,11 +182,34 @@ public void mouseClicked(MouseEvent e) {\n \t\t});\n \n \t\tSettingsGroup other = new SettingsGroup(NLS.str(\"preferences.editor\"));\n-\t\tother.addRow(NLS.str(\"preferences.font\"), fontBtn);\n+\t\tJLabel fontLabel = other.addRow(getFontLabelStr(), fontBtn);\n \t\tother.addRow(NLS.str(\"preferences.theme\"), themesCbx);\n+\n+\t\tfontBtn.addMouseListener(new MouseAdapter() {\n+\t\t\t@Override\n+\t\t\tpublic void mouseClicked(MouseEvent e) {\n+\t\t\t\tJFontChooser fontChooser = new JFontChooser();\n+\t\t\t\tfontChooser.setSelectedFont(settings.getFont());\n+\t\t\t\tint result = fontChooser.showDialog(JadxSettingsWindow.this);\n+\t\t\t\tif (result == JFontChooser.OK_OPTION) {\n+\t\t\t\t\tFont font = fontChooser.getSelectedFont();\n+\t\t\t\t\tLOG.debug(\"Selected Font: {}\", font);\n+\t\t\t\t\tsettings.setFont(font);\n+\t\t\t\t\tmainWindow.updateFont(font);\n+\t\t\t\t\tmainWindow.loadSettings();\n+\t\t\t\t\tfontLabel.setText(getFontLabelStr());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n \t\treturn other;\n \t}\n \n+\tprivate String getFontLabelStr() {\n+\t\tFont font = settings.getFont();\n+\t\tString fontStyleName = Utils.getFontStyleName(font.getStyle());\n+\t\treturn NLS.str(\"preferences.font\") + \": \" + font.getFontName() + \" \" + fontStyleName + \" \" + font.getSize();\n+\t}\n+\n \tprivate SettingsGroup makeDecompilationGroup() {\n \t\tJCheckBox fallback = new JCheckBox();\n \t\tfallback.setSelected(settings.isFallbackMode());\n@@ -342,11 +351,11 @@ public SettingsGroup(String title) {\n \t\t\tc.weighty = 1.0;\n \t\t}\n \n-\t\tpublic void addRow(String label, JComponent comp) {\n-\t\t\taddRow(label, null, comp);\n+\t\tpublic JLabel addRow(String label, JComponent comp) {\n+\t\t\treturn addRow(label, null, comp);\n \t\t}\n \n-\t\tpublic void addRow(String label, String tooltip, JComponent comp) {\n+\t\tpublic JLabel addRow(String label, String tooltip, JComponent comp) {\n \t\t\tc.gridy = row++;\n \t\t\tJLabel jLabel = new JLabel(label);\n \t\t\tjLabel.setLabelFor(comp);\n@@ -371,6 +380,7 @@ public void addRow(String label, String tooltip, JComponent comp) {\n \t\t\tadd(comp, c);\n \n \t\t\tcomp.addPropertyChangeListener(\"enabled\", evt -> jLabel.setEnabled((boolean) evt.getNewValue()));\n+\t\t\treturn jLabel;\n \t\t}\n \n \t\tpublic void end() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/Utils.java b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n@@ -8,6 +8,7 @@\n import java.io.InputStream;\n import java.net.URL;\n \n+import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -175,4 +176,19 @@ public static void setClipboardString(String text) {\n \t\t\tLOG.error(\"Failed copy string '{}' to clipboard\", text, e);\n \t\t}\n \t}\n+\n+\t@NotNull\n+\tpublic static String getFontStyleName(int style) {\n+\t\tif (style == 0) {\n+\t\t\treturn \"plain\";\n+\t\t}\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tif ((style & Font.BOLD) != 0) {\n+\t\t\tsb.append(\"bold\");\n+\t\t}\n+\t\tif ((style & Font.ITALIC) != 0) {\n+\t\t\tsb.append(\" italic\");\n+\t\t}\n+\t\treturn sb.toString().trim();\n+\t}\n }",
    "output": "Fix show current font in preferences"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -4,15 +4,15 @@\n import java.util.List;\n \n import com.android.dx.rop.code.AccessFlags;\n-import jadx.core.dex.info.ClassInfo;\n-import jadx.core.utils.Utils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.core.Consts;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.annotations.MethodParameters;\n import jadx.core.dex.info.AccessInfo;\n+import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.RegisterArg;\n@@ -24,6 +24,7 @@\n import jadx.core.dex.visitors.FallbackModeVisitor;\n import jadx.core.utils.ErrorsCounter;\n import jadx.core.utils.InsnUtils;\n+import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.CodegenException;\n import jadx.core.utils.exceptions.DecodeException;\n \n@@ -85,6 +86,9 @@ public boolean addDefinition(CodeWriter code) {\n \t\t}\n \t\tcode.startLineWithNum(mth.getSourceLine());\n \t\tcode.add(ai.makeString());\n+\t\tif (Consts.DEBUG) {\n+\t\t\tcode.add(mth.isVirtual() ? \"/* virtual */ \" : \"/* direct */ \");\n+\t\t}\n \n \t\tif (classGen.addGenericMap(code, mth.getGenericMap())) {\n \t\t\tcode.add(' ');\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n@@ -3,6 +3,8 @@\n import java.util.List;\n import java.util.Objects;\n \n+import com.android.dx.rop.code.AccessFlags;\n+\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.nodes.FieldReplaceAttr;\n@@ -31,7 +33,10 @@\n @JadxVisitor(\n \t\tname = \"ClassModifier\",\n \t\tdesc = \"Remove synthetic classes, methods and fields\",\n-\t\trunAfter = ModVisitor.class\n+\t\trunAfter = {\n+\t\t\t\tModVisitor.class,\n+\t\t\t\tFixAccessModifiers.class\n+\t\t}\n )\n public class ClassModifier extends AbstractVisitor {\n \n@@ -218,6 +223,10 @@ private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {\n \t\t\tMethodInfo callMth = ((InvokeNode) insn).getCallMth();\n \t\t\tMethodNode wrappedMth = mth.root().deepResolveMethod(callMth);\n \t\t\tif (wrappedMth != null) {\n+\t\t\t\tAccessInfo wrappedAccFlags = wrappedMth.getAccessFlags();\n+\t\t\t\tif (wrappedAccFlags.isStatic()) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n \t\t\t\tif (callMth.getArgsCount() != mth.getMethodInfo().getArgsCount()) {\n \t\t\t\t\treturn false;\n \t\t\t\t}\n@@ -235,8 +244,9 @@ private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {\n \t\t\t\tif (Objects.equals(wrappedMth.getAlias(), alias)) {\n \t\t\t\t\treturn true;\n \t\t\t\t}\n-\t\t\t\tif (!wrappedMth.isVirtual()) {\n-\t\t\t\t\treturn false;\n+\t\t\t\tif (!wrappedAccFlags.isPublic()) {\n+\t\t\t\t\t// must be public\n+\t\t\t\t\tFixAccessModifiers.changeVisibility(wrappedMth, AccessFlags.ACC_PUBLIC);\n \t\t\t\t}\n \t\t\t\twrappedMth.getMethodInfo().setAlias(alias);\n \t\t\t\treturn true;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java\n@@ -26,22 +26,27 @@ public void visit(MethodNode mth) {\n \t\tif (respectAccessModifiers) {\n \t\t\treturn;\n \t\t}\n-\t\tAccessInfo accessFlags = mth.getAccessFlags();\n-\t\tint newVisFlag = fixVisibility(mth, accessFlags);\n+\t\tint newVisFlag = fixVisibility(mth);\n \t\tif (newVisFlag != 0) {\n-\t\t\tAccessInfo newAccFlags = accessFlags.changeVisibility(newVisFlag);\n-\t\t\tif (newAccFlags != accessFlags) {\n-\t\t\t\tmth.setAccFlags(newAccFlags);\n-\t\t\t\tmth.addAttr(AType.COMMENTS, \"Access modifiers changed, original: \" + accessFlags.rawString());\n-\t\t\t}\n+\t\t\tchangeVisibility(mth, newVisFlag);\n+\t\t}\n+\t}\n+\n+\tpublic static void changeVisibility(MethodNode mth, int newVisFlag) {\n+\t\tAccessInfo accessFlags = mth.getAccessFlags();\n+\t\tAccessInfo newAccFlags = accessFlags.changeVisibility(newVisFlag);\n+\t\tif (newAccFlags != accessFlags) {\n+\t\t\tmth.setAccFlags(newAccFlags);\n+\t\t\tmth.addAttr(AType.COMMENTS, \"access modifiers changed from: \" + accessFlags.rawString());\n \t\t}\n \t}\n \n-\tprivate int fixVisibility(MethodNode mth, AccessInfo accessFlags) {\n+\tprivate static int fixVisibility(MethodNode mth) {\n \t\tif (mth.isVirtual()) {\n \t\t\t// make virtual methods public\n \t\t\treturn AccessFlags.ACC_PUBLIC;\n \t\t} else {\n+\t\t\tAccessInfo accessFlags = mth.getAccessFlags();\n \t\t\tif (accessFlags.isAbstract()) {\n \t\t\t\t// make abstract methods public\n \t\t\t\treturn AccessFlags.ACC_PUBLIC;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inner/TestInner2Samples.java b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInner2Samples.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inner/TestInner2Samples.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInner2Samples.java\n@@ -0,0 +1,77 @@\n+package jadx.tests.integration.inner;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.not;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestInner2Samples extends IntegrationTest {\n+\n+\tpublic static class TestInner2 {\n+\n+\t\tprivate String a;\n+\n+\t\tpublic class A {\n+\t\t\tpublic A() {\n+\t\t\t\ta = \"a\";\n+\t\t\t}\n+\n+\t\t\tpublic String a() {\n+\t\t\t\treturn a;\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate static String b;\n+\n+\t\tpublic static class B {\n+\t\t\tpublic B() {\n+\t\t\t\tb = \"b\";\n+\t\t\t}\n+\n+\t\t\tpublic String b() {\n+\t\t\t\treturn b;\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate String c;\n+\n+\t\tprivate void setC(String c) {\n+\t\t\tthis.c = c;\n+\t\t}\n+\n+\t\tpublic class C {\n+\t\t\tpublic String c() {\n+\t\t\t\tsetC(\"c\");\n+\t\t\t\treturn c;\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate static String d;\n+\n+\t\tprivate static void setD(String s) {\n+\t\t\td = s;\n+\t\t}\n+\n+\t\tpublic static class D {\n+\t\t\tpublic String d() {\n+\t\t\t\tsetD(\"d\");\n+\t\t\t\treturn d;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestInner2.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"setD(\\\"d\\\");\"));\n+\t\tassertThat(code, not(containsString(\"synthetic\")));\n+\t\tassertThat(code, not(containsString(\"access$\")));\n+\t}\n+}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/inner/TestSyntheticMthRename.java b/jadx-core/src/test/java/jadx/tests/integration/inner/TestSyntheticMthRename.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/inner/TestSyntheticMthRename.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestSyntheticMthRename.java\n@@ -0,0 +1,44 @@\n+package jadx.tests.integration.inner;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.not;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Issue: https://github.com/skylot/jadx/issues/397\n+ */\n+public class TestSyntheticMthRename extends SmaliTest {\n+\n+//\tpublic class TestCls {\n+//\t\tpublic interface I<R, P> {\n+//\t\t\tR call(P... p);\n+//\t\t}\n+//\n+//\t\tpublic static final class A implements I<String, Runnable> {\n+//\t\t\tpublic /* synthetic */ /* virtual */ Object call(Object[] objArr) {\n+//\t\t\t\treturn renamedCall((Runnable[]) objArr);\n+//\t\t\t}\n+//\n+//\t\t\tprivate /* varargs */ /* direct */ String renamedCall(Runnable... p) {\n+//\t\t\t\treturn \"str\";\n+//\t\t\t}\n+//\t\t}\n+//\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmaliFiles(\"inner\", \"TestSyntheticMthRename\", \"TestCls\",\n+\t\t\t\t\"TestCls\", \"TestCls$I\", \"TestCls$A\"\n+\t\t);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"public String call(Runnable... p) {\"));\n+\t\tassertThat(code, not(containsString(\"synthetic\")));\n+\t}\n+}",
    "output": "Fix improve bridge methods renaming"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java\n@@ -263,7 +263,18 @@ private static IfInfo mergeIfInfo(IfInfo first, IfInfo second, boolean followThe\n \t\tresult.setIfBlock(first.getIfBlock());\n \t\tresult.merge(first, second);\n \n-\t\tBlockNode otherPathBlock = followThenBranch ? first.getElseBlock() : first.getThenBlock();\n+\t\tBlockNode otherPathBlock;\n+\t\tif (followThenBranch) {\n+\t\t\totherPathBlock = first.getElseBlock();\n+\t\t\tif (!otherPathBlock.equals(result.getElseBlock())) {\n+\t\t\t\tresult.getSkipBlocks().add(otherPathBlock);\n+\t\t\t}\n+\t\t} else {\n+\t\t\totherPathBlock = first.getThenBlock();\n+\t\t\tif (!otherPathBlock.equals(result.getThenBlock())) {\n+\t\t\t\tresult.getSkipBlocks().add(otherPathBlock);\n+\t\t\t}\n+\t\t}\n \t\tskipSimplePath(otherPathBlock, result.getSkipBlocks());\n \t\treturn result;\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf.java b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf.java\n@@ -0,0 +1,39 @@\n+package jadx.tests.integration.conditions;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestComplexIf extends SmaliTest {\n+\n+/*\n+\tpublic final class TestComplexIf {\n+\t    private String a;\n+\t    private int b;\n+\t    private float c;\n+\n+\t    public final boolean test() {\n+\t        if (this.a.equals(\"GT-P6200\") || this.a.equals(\"GT-P6210\") || ... ) {\n+\t            return true;\n+\t        }\n+\t        if (this.a.equals(\"SM-T810\") || this.a.equals(\"SM-T813\") || ...) {\n+\t            return false;\n+\t        }\n+\t        return this.c > 160.0f ? true : this.c <= 0.0f && ((this.b & 15) == 4 ? 1 : null) != null;\n+\t    }\n+\t}\n+ */\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmaliWithPkg(\"conditions\", \"TestComplexIf\");\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"if (this.a.equals(\\\"GT-P6200\\\") || this.a.equals(\\\"GT-P6210\\\") || this.a.equals(\\\"A100\\\") \" +\n+\t\t\t\t\"|| this.a.equals(\\\"A101\\\") || this.a.equals(\\\"LIFETAB_S786X\\\") || this.a.equals(\\\"VS890 4G\\\")) {\"));\n+\t}\n+}",
    "output": "Fix skip duplicated block in complex if"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n@@ -176,6 +176,7 @@ private void searchFieldSubscribe() {\n \t\t\t\t.subscribeOn(Schedulers.single())\n \t\t\t\t.doOnNext(r -> LOG.debug(\"search event: {}\", r))\n \t\t\t\t.switchMap(text -> prepareSearch(text)\n+\t\t\t\t\t\t.doOnError(e -> LOG.error(\"Error prepare search: {}\", e.getMessage(), e))\n \t\t\t\t\t\t.subscribeOn(Schedulers.single())\n \t\t\t\t\t\t.toList()\n \t\t\t\t\t\t.toFlowable(), 1)\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/search/SimpleIndex.java b/jadx-gui/src/main/java/jadx/gui/utils/search/SimpleIndex.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/search/SimpleIndex.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/SimpleIndex.java\n@@ -12,10 +12,14 @@ public class SimpleIndex<T> implements SearchIndex<T> {\n \tprivate final List<String> keys = new ArrayList<>();\n \tprivate final List<T> values = new ArrayList<>();\n \n+\tprivate final Object syncData = new Object();\n+\n \t@Override\n \tpublic void put(String str, T value) {\n-\t\tkeys.add(str);\n-\t\tvalues.add(value);\n+\t\tsynchronized (syncData) {\n+\t\t\tkeys.add(str);\n+\t\t\tvalues.add(value);\n+\t\t}\n \t}\n \n \t@Override\n@@ -39,13 +43,15 @@ private boolean isMatched(String str, String searchStr, boolean caseInsensitive)\n \t@Override\n \tpublic Flowable<T> search(final String searchStr, final boolean caseInsensitive) {\n \t\treturn Flowable.create(emitter -> {\n-\t\t\tint size = size();\n-\t\t\tfor (int i = 0; i < size; i++) {\n-\t\t\t\tif (isMatched(keys.get(i), searchStr, caseInsensitive)) {\n-\t\t\t\t\temitter.onNext(values.get(i));\n-\t\t\t\t}\n-\t\t\t\tif (emitter.isCancelled()) {\n-\t\t\t\t\treturn;\n+\t\t\tsynchronized (syncData) {\n+\t\t\t\tint size = keys.size();\n+\t\t\t\tfor (int i = 0; i < size; i++) {\n+\t\t\t\t\tif (isMatched(keys.get(i), searchStr, caseInsensitive)) {\n+\t\t\t\t\t\temitter.onNext(values.get(i));\n+\t\t\t\t\t}\n+\t\t\t\t\tif (emitter.isCancelled()) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\temitter.onComplete();\n@@ -54,6 +60,8 @@ public Flowable<T> search(final String searchStr, final boolean caseInsensitive)\n \n \t@Override\n \tpublic int size() {\n-\t\treturn keys.size();\n+\t\tsynchronized (syncData) {\n+\t\t\treturn keys.size();\n+\t\t}\n \t}\n }",
    "output": "Add synchronization to SimpleIndex class"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java\n@@ -397,12 +397,14 @@ public Object getValueAt(int rowIndex, int columnIndex) {\n \n \tprotected class ResultsTableCellRenderer implements TableCellRenderer {\n \t\tprivate final JLabel emptyLabel = new JLabel();\n+\t\tprivate final Font font;\n \t\tprivate final Color codeSelectedColor;\n \t\tprivate final Color codeBackground;\n \t\tprivate final Map<Integer, Component> componentCache = new HashMap<>();\n \n \t\tpublic ResultsTableCellRenderer() {\n \t\t\tRSyntaxTextArea area = CodeArea.getDefaultArea(mainWindow);\n+\t\t\tthis.font = area.getFont();\n \t\t\tthis.codeSelectedColor = area.getSelectionColor();\n \t\t\tthis.codeBackground = area.getBackground();\n \t\t}\n@@ -414,7 +416,7 @@ public Component getTableCellRendererComponent(JTable table, Object obj, boolean\n \t\t\tComponent comp = componentCache.get(id);\n \t\t\tif (comp == null) {\n \t\t\t\tif (obj instanceof JNode) {\n-\t\t\t\t\tcomp = makeCell(table, (JNode) obj, column);\n+\t\t\t\t\tcomp = makeCell((JNode) obj, column);\n \t\t\t\t\tcomponentCache.put(id, comp);\n \t\t\t\t} else {\n \t\t\t\t\tcomp = emptyLabel;\n@@ -442,10 +444,10 @@ private void updateSelection(JTable table, Component comp, boolean isSelected) {\n \t\t\t}\n \t\t}\n \n-\t\tprivate Component makeCell(JTable table, JNode node, int column) {\n+\t\tprivate Component makeCell(JNode node, int column) {\n \t\t\tif (column == 0) {\n \t\t\t\tJLabel label = new JLabel(node.makeLongString() + \"  \", node.getIcon(), SwingConstants.LEFT);\n-\t\t\t\tlabel.setFont(table.getFont());\n+\t\t\t\tlabel.setFont(font);\n \t\t\t\tlabel.setOpaque(true);\n \t\t\t\tlabel.setToolTipText(label.getText());\n \t\t\t\treturn label;",
    "output": "Use editor font in search node column"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -17,8 +17,6 @@\n import jadx.gui.utils.LangLocale;\n import jadx.gui.utils.NLS;\n \n-import static jadx.gui.utils.Utils.FONT_HACK;\n-\n public class JadxSettingsWindow extends JDialog {\n \tprivate static final long serialVersionUID = -1804570470377354148L;\n \n@@ -38,7 +36,6 @@ public JadxSettingsWindow(MainWindow mainWindow, JadxSettings settings) {\n \t\tthis.prevLang = settings.getLangLocale();\n \n \t\tinitUI();\n-\t\tregisterBundledFonts();\n \n \t\tsetTitle(NLS.str(\"preferences.title\"));\n \t\tsetSize(400, 550);\n@@ -48,13 +45,6 @@ public JadxSettingsWindow(MainWindow mainWindow, JadxSettings settings) {\n \t\tsetLocationRelativeTo(null);\n \t}\n \n-\tpublic static void registerBundledFonts() {\n-\t\tGraphicsEnvironment grEnv = GraphicsEnvironment.getLocalGraphicsEnvironment();\n-\t\tif (FONT_HACK != null) {\n-\t\t\tgrEnv.registerFont(FONT_HACK);\n-\t\t}\n-\t}\n-\n \tprivate void initUI() {\n \t\tJPanel panel = new JPanel();\n \t\tpanel.setLayout(new BoxLayout(panel, BoxLayout.PAGE_AXIS));\n@@ -202,7 +192,6 @@ public void mouseClicked(MouseEvent e) {\n \t\t\tint i = themesCbx.getSelectedIndex();\n \t\t\tEditorTheme editorTheme = editorThemes[i];\n \t\t\tsettings.setEditorThemePath(editorTheme.getPath());\n-\t\t\tmainWindow.setEditorTheme(editorTheme.getPath());\n \t\t\tmainWindow.loadSettings();\n \t\t});\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -111,16 +111,11 @@ public MainWindow(JadxSettings settings) {\n \t\tthis.cacheObject = new CacheObject();\n \n \t\tresetCache();\n+\t\tregisterBundledFonts();\n \t\tinitUI();\n \t\tinitMenuAndToolbar();\n-\t\tapplySettings();\n-\t\tcheckForUpdate();\n-\t}\n-\n-\tprivate void applySettings() {\n-\t\tsetFont(settings.getFont());\n-\t\tsetEditorTheme(settings.getEditorThemePath());\n \t\tloadSettings();\n+\t\tcheckForUpdate();\n \t}\n \n \tpublic void open() {\n@@ -649,7 +644,14 @@ public void updateFont(Font font) {\n \t\tsetFont(font);\n \t}\n \n-\tpublic void setEditorTheme(String editorThemePath) {\n+\tpublic static void registerBundledFonts() {\n+\t\tGraphicsEnvironment grEnv = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+\t\tif (Utils.FONT_HACK != null) {\n+\t\t\tgrEnv.registerFont(Utils.FONT_HACK);\n+\t\t}\n+\t}\n+\n+\tprivate void setEditorTheme(String editorThemePath) {\n \t\ttry {\n \t\t\teditorTheme = Theme.load(getClass().getResourceAsStream(editorThemePath));\n \t\t} catch (Exception e) {\n@@ -667,6 +669,14 @@ public Theme getEditorTheme() {\n \t}\n \n \tpublic void loadSettings() {\n+\t\tFont font = settings.getFont();\n+\t\tFont largerFont = font.deriveFont(font.getSize() + 2.f);\n+\n+\t\tsetFont(largerFont);\n+\t\tsetEditorTheme(settings.getEditorThemePath());\n+\t\ttree.setFont(largerFont);\n+\t\ttree.setRowHeight(-1);\n+\n \t\ttabbedPane.loadSettings();\n \t}",
    "output": "Use editor font in files tree and fix bundled font loading"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java b/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java\n@@ -1,6 +1,7 @@\n package jadx.gui.ui;\n \n import jadx.gui.utils.NLS;\n+import jadx.gui.utils.Utils;\n \n import javax.swing.*;\n import java.awt.*;\n@@ -44,7 +45,7 @@ public void update() {\n \t\tsetValue(usedKB);\n \t\tsetString(String.format(textFormat, (usedKB / TWO_TO_20), maxGB));\n \n-\t\tif (used > r.maxMemory() * 0.8) {\n+\t\tif ((used + Utils.MIN_FREE_MEMORY) > r.maxMemory()) {\n \t\t\tsetForeground(RED);\n \t\t} else {\n \t\t\tsetForeground(GREEN);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/Utils.java b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n@@ -26,6 +26,16 @@ public class Utils {\n \n \tpublic static final Font FONT_HACK = openFontTTF(\"Hack-Regular\");\n \n+\t/**\n+\t * The minimum about of memory in bytes we are trying to keep free, otherwise the application may run out of heap\n+\t * which ends up in a Java garbage collector running \"amok\" (CPU utilization 100% for each core and the UI is\n+\t * not responsive).\n+\t *\n+\t * We can calculate and store this value here as the maximum heap is fixed for each JVM instance\n+\t * and can't be changed at runtime.\n+\t */\n+\tpublic static final long MIN_FREE_MEMORY = calculateMinFreeMemory();\n+\n \tprivate Utils() {\n \t}\n \n@@ -107,11 +117,21 @@ public static OverlayIcon makeIcon(AccessInfo af, Icon pub, Icon pri, Icon pro,\n \t\treturn overIcon;\n \t}\n \n+\t/**\n+\t * @return 20% of the maximum heap size limited to 512 MB (bytes)\n+\t */\n+\tpublic static long calculateMinFreeMemory() {\n+\t\tRuntime runtime = Runtime.getRuntime();\n+\t\tlong minFree = (long) (runtime.maxMemory() * 0.2);\n+\t\tminFree = Math.min(minFree, 512 * 1048576);\n+\t\treturn minFree;\n+\t}\n+\n \tpublic static boolean isFreeMemoryAvailable() {\n \t\tRuntime runtime = Runtime.getRuntime();\n \t\tlong maxMemory = runtime.maxMemory();\n-\t\tlong totalFree = runtime.freeMemory() + maxMemory - runtime.totalMemory();\n-\t\treturn totalFree > maxMemory * 0.2;\n+\t\tlong totalFree = runtime.freeMemory() + (maxMemory - runtime.totalMemory());\n+\t\treturn totalFree > MIN_FREE_MEMORY;\n \t}\n \n \tpublic static String memoryInfo() {",
    "output": "Fix limit the spare memory to max. 512MiB"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -243,6 +243,10 @@ public void renameField(FieldNode field) {\n \t\t}\n \t}\n \n+\tpublic void forceRenameField(FieldNode field) {\n+\t\tfield.getFieldInfo().setAlias(makeFieldAlias(field));\n+\t}\n+\n \tpublic void renameMethod(MethodNode mth) {\n \t\tString alias = getMethodAlias(mth);\n \t\tif (alias != null) {\n@@ -253,6 +257,13 @@ public void renameMethod(MethodNode mth) {\n \t\t}\n \t}\n \n+\tpublic void forceRenameMethod(MethodNode mth) {\n+\t\tmth.getMethodInfo().setAlias(makeMethodAlias(mth));\n+\t\tif (mth.isVirtual()) {\n+\t\t\tresolveOverriding(mth);\n+\t\t}\n+\t}\n+\n \tpublic void addPackagePreset(String origPkgName, String pkgAlias) {\n \t\tPackageNode pkg = getPackageNode(origPkgName, true);\n \t\tpkg.setAlias(pkgAlias);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java\n@@ -65,6 +65,10 @@ public boolean isRenamed() {\n \t\treturn !name.equals(alias);\n \t}\n \n+\tpublic boolean equalsNameAndType(FieldInfo other) {\n+\t\treturn name.equals(other.name) && type.equals(other.type);\n+\t}\n+\n \t@Override\n \tpublic boolean equals(Object o) {\n \t\tif (this == o) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java\n@@ -321,6 +321,15 @@ public FieldNode searchField(FieldInfo field) {\n \t\treturn null;\n \t}\n \n+\tpublic FieldNode searchFieldByNameAndType(FieldInfo field) {\n+\t\tfor (FieldNode f : fields) {\n+\t\t\tif (f.getFieldInfo().equalsNameAndType(field)) {\n+\t\t\t\treturn f;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \tpublic FieldNode searchFieldByName(String name) {\n \t\tfor (FieldNode f : fields) {\n \t\t\tif (f.getName().equals(name)) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java\n@@ -150,16 +150,15 @@ public FieldNode resolveField(FieldInfo field) {\n \n \t@Nullable\n \tFieldNode deepResolveField(@NotNull ClassNode cls, FieldInfo fieldInfo) {\n-\t\tFieldNode field = cls.searchFieldByName(fieldInfo.getName());\n+\t\tFieldNode field = cls.searchFieldByNameAndType(fieldInfo);\n \t\tif (field != null) {\n \t\t\treturn field;\n \t\t}\n-\t\tFieldNode found;\n \t\tArgType superClass = cls.getSuperClass();\n \t\tif (superClass != null) {\n \t\t\tClassNode superNode = resolveClass(superClass);\n \t\t\tif (superNode != null) {\n-\t\t\t\tfound = deepResolveField(superNode, fieldInfo);\n+\t\t\t\tFieldNode found = deepResolveField(superNode, fieldInfo);\n \t\t\t\tif (found != null) {\n \t\t\t\t\treturn found;\n \t\t\t\t}\n@@ -168,7 +167,7 @@ FieldNode deepResolveField(@NotNull ClassNode cls, FieldInfo fieldInfo) {\n \t\tfor (ArgType iFaceType : cls.getInterfaces()) {\n \t\t\tClassNode iFaceNode = resolveClass(iFaceType);\n \t\t\tif (iFaceNode != null) {\n-\t\t\t\tfound = deepResolveField(iFaceNode, fieldInfo);\n+\t\t\t\tFieldNode found = deepResolveField(iFaceNode, fieldInfo);\n \t\t\t\tif (found != null) {\n \t\t\t\t\treturn found;\n \t\t\t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -12,14 +12,14 @@\n import jadx.core.deobf.Deobfuscator;\n import jadx.core.deobf.NameMapper;\n import jadx.core.dex.attributes.AFlag;\n+import jadx.core.dex.info.AccessInfo;\n import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.DexNode;\n import jadx.core.dex.nodes.FieldNode;\n import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.nodes.RootNode;\n-import jadx.core.utils.exceptions.JadxException;\n import jadx.core.utils.files.FileUtils;\n import jadx.core.utils.files.InputFile;\n \n@@ -49,20 +49,12 @@ public void init(RootNode root) {\n \t\tcheckClasses(root, isCaseSensitive);\n \t}\n \n-\t@Override\n-\tpublic boolean visit(ClassNode cls) throws JadxException {\n-\t\tcheckFields(cls);\n-\t\tcheckMethods(cls);\n-\t\tfor (ClassNode inner : cls.getInnerClasses()) {\n-\t\t\tvisit(inner);\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n \tprivate void checkClasses(RootNode root, boolean caseSensitive) {\n \t\tSet<String> clsNames = new HashSet<>();\n \t\tfor (ClassNode cls : root.getClasses(true)) {\n \t\t\tcheckClassName(cls);\n+\t\t\tcheckFields(cls);\n+\t\t\tcheckMethods(cls);\n \t\t\tif (!caseSensitive) {\n \t\t\t\tClassInfo classInfo = cls.getClassInfo();\n \t\t\t\tString clsFileName = classInfo.getAlias().getFullPath();\n@@ -103,20 +95,24 @@ private void checkFields(ClassNode cls) {\n \t\t\tFieldInfo fieldInfo = field.getFieldInfo();\n \t\t\tString fieldName = fieldInfo.getAlias();\n \t\t\tif (!names.add(fieldName) || !NameMapper.isValidIdentifier(fieldName)) {\n-\t\t\t\tdeobfuscator.renameField(field);\n+\t\t\t\tdeobfuscator.forceRenameField(field);\n \t\t\t}\n \t\t}\n \t}\n \n \tprivate void checkMethods(ClassNode cls) {\n \t\tSet<String> names = new HashSet<>();\n \t\tfor (MethodNode mth : cls.getMethods()) {\n-\t\t\tif (mth.contains(AFlag.DONT_GENERATE) || mth.getAccessFlags().isConstructor()) {\n+\t\t\tAccessInfo accessFlags = mth.getAccessFlags();\n+\t\t\tif (accessFlags.isConstructor()\n+\t\t\t\t\t|| accessFlags.isBridge()\n+\t\t\t\t\t|| accessFlags.isSynthetic()\n+\t\t\t\t\t|| mth.contains(AFlag.DONT_GENERATE)) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tString signature = mth.getMethodInfo().makeSignature(false);\n \t\t\tif (!names.add(signature) || !NameMapper.isValidIdentifier(mth.getAlias())) {\n-\t\t\t\tdeobfuscator.renameMethod(mth);\n+\t\t\t\tdeobfuscator.forceRenameMethod(mth);\n \t\t\t}\n \t\t}\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicatedNames.java b/jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicatedNames.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicatedNames.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestDuplicatedNames.java\n@@ -0,0 +1,51 @@\n+package jadx.tests.integration.names;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestDuplicatedNames extends SmaliTest {\n+/*\n+\tpublic static class TestCls {\n+\n+\t\tpublic Object fieldName;\n+\t\tpublic String fieldName;\n+\n+\t\tpublic Object run() {\n+\t\t\treturn this.fieldName;\n+\t\t}\n+\n+\t\tpublic String run() {\n+\t\t\treturn this.fieldName;\n+\t\t}\n+\t}\n+*/\n+\t@Test\n+\tpublic void test() {\n+\t\tcommonChecks();\n+\t}\n+\n+\t@Test\n+\tpublic void testWithDeobf() {\n+\t\tenableDeobfuscation();\n+\t\tcommonChecks();\n+\t}\n+\n+\tprivate void commonChecks() {\n+\t\tClassNode cls = getClassNodeFromSmaliWithPath(\"names\", \"TestDuplicatedNames\");\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"Object fieldName;\"));\n+\t\tassertThat(code, containsOne(\"String f0fieldName\"));\n+\n+\t\tassertThat(code, containsOne(\"this.fieldName\"));\n+\t\tassertThat(code, containsOne(\"this.f0fieldName\"));\n+\n+\t\tassertThat(code, containsOne(\"public Object run() {\"));\n+\t\tassertThat(code, containsOne(\"public String m0run() {\"));\n+\t}\n+}",
    "output": "Fix force rename by checks from RenameVisitor"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java b/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java\n@@ -35,7 +35,7 @@ public HeapUsageBar() {\n \t\tsetMaximum(maxKB);\n \t\tmaxGB = maxKB / TWO_TO_20;\n \t\tupdate();\n-\t\ttimer = new Timer(1000, this);\n+\t\ttimer = new Timer(2000, this);\n \t}\n \n \tpublic void update() {\n@@ -44,7 +44,7 @@ public void update() {\n \t\tsetValue(usedKB);\n \t\tsetString(String.format(textFormat, (usedKB / TWO_TO_20), maxGB));\n \n-\t\tif (used > r.totalMemory() * 0.8) {\n+\t\tif (used > r.maxMemory() * 0.8) {\n \t\t\tsetForeground(RED);\n \t\t} else {\n \t\t\tsetForeground(GREEN);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java b/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java\n@@ -5,6 +5,7 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import jadx.api.CodePosition;\n import jadx.api.JavaClass;\n@@ -21,6 +22,10 @@ public static class UsageInfo {\n \t\tpublic List<CodeNode> getUsageList() {\n \t\t\treturn usageList;\n \t\t}\n+\n+\t\tpublic synchronized void addUsage(CodeNode codeNode) {\n+\t\t\tusageList.add(codeNode);\n+\t\t}\n \t}\n \n \tprivate final JNodeCache nodeCache;\n@@ -29,7 +34,7 @@ public CodeUsageInfo(JNodeCache nodeCache) {\n \t\tthis.nodeCache = nodeCache;\n \t}\n \n-\tprivate final Map<JNode, UsageInfo> usageMap = new HashMap<>();\n+\tprivate final Map<JNode, UsageInfo> usageMap = new ConcurrentHashMap<>();\n \n \tpublic void processClass(JavaClass javaClass, CodeLinesInfo linesInfo, List<StringRef> lines) {\n \t\tMap<CodePosition, JavaNode> usage = javaClass.getUsageMap();\n@@ -42,17 +47,13 @@ public void processClass(JavaClass javaClass, CodeLinesInfo linesInfo, List<Stri\n \n \tprivate void addUsage(JNode jNode, JavaClass javaClass,\n \t                      CodeLinesInfo linesInfo, CodePosition codePosition, List<StringRef> lines) {\n-\t\tUsageInfo usageInfo = usageMap.get(jNode);\n-\t\tif (usageInfo == null) {\n-\t\t\tusageInfo = new UsageInfo();\n-\t\t\tusageMap.put(jNode, usageInfo);\n-\t\t}\n-\t\tint line = codePosition.getLine();\n-\t\tJavaNode javaNodeByLine = linesInfo.getJavaNodeByLine(line);\n-\t\tStringRef codeLine = lines.get(line - 1);\n-\t\tJNode node = nodeCache.makeFrom(javaNodeByLine == null ? javaClass : javaNodeByLine);\n+        UsageInfo usageInfo = usageMap.computeIfAbsent(jNode, key -> new UsageInfo());\n+        int line = codePosition.getLine();\n+        JavaNode javaNodeByLine = linesInfo.getJavaNodeByLine(line);\n+        StringRef codeLine = lines.get(line - 1);\n+        JNode node = nodeCache.makeFrom(javaNodeByLine == null ? javaClass : javaNodeByLine);\n \t\tCodeNode codeNode = new CodeNode(node, line, codeLine);\n-\t\tusageInfo.getUsageList().add(codeNode);\n+\t\tusageInfo.addUsage(codeNode);\n \t}\n \n \tpublic List<CodeNode> getUsageList(JNode node) {",
    "output": "Add synchronizations to search index creation"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n@@ -221,6 +221,10 @@ private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {\n \t\t\t\tif (callMth.getArgsCount() != mth.getMethodInfo().getArgsCount()) {\n \t\t\t\t\treturn false;\n \t\t\t\t}\n+\t\t\t\t// rename method only from current class\n+\t\t\t\tif (!mth.getParentClass().equals(wrappedMth.getParentClass())) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n \t\t\t\t// all args must be registers passed from method args (allow only casts insns)\n \t\t\t\tfor (InsnArg arg : insn.getArguments()) {\n \t\t\t\t\tif (!registersAndCastsOnly(arg)) {",
    "output": "Fix rename method wrapped by synthetic only from same class"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -695,7 +695,7 @@ private static RegisterArg getCallMthArg(@Nullable MethodNode callMth, int num)\n \tprivate boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnArg arg, int origPos) {\n \t\tArgType origType;\n \t\tList<RegisterArg> arguments = callMth.getArguments(false);\n-\t\tif (arguments.isEmpty()) {\n+\t\tif (arguments == null || arguments.isEmpty()) {\n \t\t\tmth.addComment(\"JADX WARN: used method not loaded: \" + callMth + \", types can be incorrect\");\n \t\t\torigType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);\n \t\t} else {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n@@ -153,4 +153,8 @@ public static InsnArg wrapArg(InsnNode insn) {\n \tpublic boolean isThis() {\n \t\treturn contains(AFlag.THIS);\n \t}\n+\n+\tpublic InsnArg duplicate() {\n+\t\treturn this;\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java\n@@ -24,4 +24,19 @@ public void setType(ArgType type) {\n \t\t\tthrow new JadxRuntimeException(\"Can't change arg with immutable type\");\n \t\t}\n \t}\n+\n+\t@Override\n+\tpublic RegisterArg duplicate() {\n+\t\treturn duplicate(getRegNum(), getSVar());\n+\t}\n+\n+\t@Override\n+\tpublic RegisterArg duplicate(int regNum, SSAVar sVar) {\n+\t\tRegisterArg dup = new TypeImmutableArg(regNum, getInitType());\n+\t\tif (sVar != null) {\n+\t\t\tdup.setSVar(sVar);\n+\t\t}\n+\t\tdup.copyAttributesFrom(this);\n+\t\treturn dup;\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n@@ -8,6 +8,7 @@\n \n import com.android.dx.io.instructions.DecodedInstruction;\n import com.rits.cloning.Cloner;\n+import org.jetbrains.annotations.Nullable;\n \n import jadx.core.dex.attributes.nodes.LineAttrNode;\n import jadx.core.dex.instructions.InsnType;\n@@ -54,16 +55,27 @@ public static InsnNode wrapArg(InsnArg arg) {\n \t\treturn insn;\n \t}\n \n-\tpublic void setResult(RegisterArg res) {\n+\tpublic void setResult(@Nullable RegisterArg res) {\n \t\tif (res != null) {\n \t\t\tres.setParentInsn(this);\n+\t\t\tSSAVar ssaVar = res.getSVar();\n+\t\t\tif (ssaVar != null) {\n+\t\t\t\tssaVar.setAssign(res);\n+\t\t\t}\n \t\t}\n \t\tthis.result = res;\n \t}\n \n \tpublic void addArg(InsnArg arg) {\n-\t\targ.setParentInsn(this);\n \t\targuments.add(arg);\n+\t\targ.setParentInsn(this);\n+\t\tif (arg.isRegister()) {\n+\t\t\tRegisterArg reg = (RegisterArg) arg;\n+\t\t\tSSAVar ssaVar = reg.getSVar();\n+\t\t\tif (ssaVar != null) {\n+\t\t\t\tssaVar.use(reg);\n+\t\t\t}\n+\t\t}\n \t}\n \n \tpublic InsnType getType() {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java\n@@ -97,16 +97,21 @@ private static InsnNode processNewArray(MethodNode mth, List<InsnNode> instructi\n \t\t\t\t|| instructions.get(i + len).getType() != InsnType.APUT) {\n \t\t\treturn null;\n \t\t}\n-\t\tArgType arrType = newArrayInsn.getArrayType();\n-\t\tInsnNode filledArr = new FilledNewArrayNode(arrType.getArrayElement(), len);\n-\t\tfilledArr.setResult(newArrayInsn.getResult());\n \t\tfor (int j = 0; j < len; j++) {\n \t\t\tInsnNode put = instructions.get(i + 1 + j);\n \t\t\tif (put.getType() != InsnType.APUT) {\n \t\t\t\tLOG.debug(\"Not a APUT in expected new filled array: {}, method: {}\", put, mth);\n \t\t\t\treturn null;\n \t\t\t}\n-\t\t\tfilledArr.addArg(put.getArg(2));\n+\t\t}\n+\n+\t\t// checks complete, apply\n+\t\tArgType arrType = newArrayInsn.getArrayType();\n+\t\tInsnNode filledArr = new FilledNewArrayNode(arrType.getArrayElement(), len);\n+\t\tfilledArr.setResult(newArrayInsn.getResult().duplicate());\n+\t\tfor (int j = 0; j < len; j++) {\n+\t\t\tInsnNode put = instructions.get(i + 1 + j);\n+\t\t\tfilledArr.addArg(put.getArg(2).duplicate());\n \t\t\tremover.add(put);\n \t\t}\n \t\treturn filledArr;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/InstructionRemover.java b/jadx-core/src/main/java/jadx/core/utils/InstructionRemover.java\n--- a/jadx-core/src/main/java/jadx/core/utils/InstructionRemover.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/InstructionRemover.java\n@@ -53,14 +53,7 @@ public void perform() {\n \t\ttoRemove.clear();\n \t}\n \n-\tpublic static void unbindInsnList(MethodNode mth, List<InsnNode> unbind) {\n-\t\tfor (InsnNode rem : unbind) {\n-\t\t\tunbindInsn(mth, rem);\n-\t\t}\n-\t}\n-\n \tpublic static void unbindInsn(MethodNode mth, InsnNode insn) {\n-\t\tunbindResult(mth, insn);\n \t\tfor (InsnArg arg : insn.getArguments()) {\n \t\t\tunbindArgUsage(mth, arg);\n \t\t}\n@@ -71,6 +64,7 @@ public static void unbindInsn(MethodNode mth, InsnNode insn) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tunbindResult(mth, insn);\n \t\tinsn.add(AFlag.INCONSISTENT_CODE);\n \t}\n \n@@ -90,7 +84,10 @@ public static void fixUsedInPhiFlag(RegisterArg useReg) {\n \tpublic static void unbindResult(MethodNode mth, InsnNode insn) {\n \t\tRegisterArg r = insn.getResult();\n \t\tif (r != null && r.getSVar() != null && mth != null) {\n-\t\t\tmth.removeSVar(r.getSVar());\n+\t\t\tSSAVar ssaVar = r.getSVar();\n+\t\t\tif (ssaVar.getUseCount() == 0) {\n+\t\t\t\tmth.removeSVar(ssaVar);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -110,12 +107,15 @@ public static void unbindArgUsage(MethodNode mth, InsnArg arg) {\n \t// Don't use 'instrList.removeAll(toRemove)' because it will remove instructions by content\n \t// and here can be several instructions with same content\n \tprivate static void removeAll(MethodNode mth, List<InsnNode> insns, List<InsnNode> toRemove) {\n+\t\tif (toRemove == null || toRemove.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n \t\tfor (InsnNode rem : toRemove) {\n-\t\t\tunbindInsn(mth, rem);\n \t\t\tint insnsCount = insns.size();\n \t\t\tfor (int i = 0; i < insnsCount; i++) {\n \t\t\t\tif (insns.get(i) == rem) {\n \t\t\t\t\tinsns.remove(i);\n+\t\t\t\t\tunbindInsn(mth, rem);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n@@ -143,9 +143,6 @@ public static void remove(MethodNode mth, BlockNode block, InsnNode insn) {\n \t}\n \n \tpublic static void removeAll(MethodNode mth, BlockNode block, List<InsnNode> insns) {\n-\t\tif (insns.isEmpty()) {\n-\t\t\treturn;\n-\t\t}\n \t\tremoveAll(mth, block.getInstructions(), insns);\n \t}\n \n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables6.java b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables6.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables6.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables6.java\n@@ -0,0 +1,25 @@\n+package jadx.tests.integration.variables;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.not;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestVariables6 extends SmaliTest {\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tdisableCompilation();\n+\t\tClassNode cls = getClassNodeFromSmaliWithPath(\"variables\", \"TestVariables6\");\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, not(containsString(\"r4\")));\n+\t\tassertThat(code, not(containsString(\"r1v1\")));\n+\t\tassertThat(code, containsString(\"DateStringParser dateStringParser\"));\n+\t\tassertThat(code, containsString(\"FinancialInstrumentMetadataAttribute startYear = this.mFinancialInstrumentMetadataDefinition.getStartYear();\"));\n+\t}\n+}",
    "output": "Fix safe SSA variables replacement in filled new array instruction"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n@@ -180,6 +180,7 @@ private void searchFieldSubscribe() {\n \t\t\t\t\t\t.toList()\n \t\t\t\t\t\t.toFlowable(), 1)\n \t\t\t\t.observeOn(SwingSchedulers.edt())\n+\t\t\t\t.doOnError(e -> LOG.error(\"Error while searching: {}\", e.getMessage(), e))\n \t\t\t\t.subscribe(this::processSearchResults);\n \t}\n \n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java b/jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java\n@@ -23,7 +23,7 @@ public void put(String str, T value) {\n \t}\n \n \t@Override\n-\tpublic void put(StringRef str, T value) {\n+\tpublic synchronized void put(StringRef str, T value) {\n \t\tif (str == null || str.length() == 0) {\n \t\t\treturn;\n \t\t}",
    "output": "Fix unsynchronized search index creation results in NullPointerException upon performing search"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java\n@@ -0,0 +1,8 @@\n+package jadx.core.dex.instructions;\n+\n+import jadx.core.dex.info.MethodInfo;\n+\n+public interface CallMthInterface {\n+\n+\tpublic MethodInfo getCallMth();\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java\n@@ -9,7 +9,7 @@\n import jadx.core.utils.InsnUtils;\n import jadx.core.utils.Utils;\n \n-public class InvokeNode extends InsnNode {\n+public class InvokeNode extends InsnNode implements CallMthInterface {\n \n \tprivate final InvokeType type;\n \tprivate final MethodInfo mth;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java\n@@ -2,13 +2,14 @@\n \n import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.info.MethodInfo;\n+import jadx.core.dex.instructions.CallMthInterface;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.InvokeNode;\n import jadx.core.dex.instructions.args.RegisterArg;\n import jadx.core.dex.nodes.InsnNode;\n import jadx.core.dex.nodes.MethodNode;\n \n-public class ConstructorInsn extends InsnNode {\n+public class ConstructorInsn extends InsnNode implements CallMthInterface {\n \n \tprivate final MethodInfo callMth;\n \tprivate final CallType callType;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java\n@@ -4,19 +4,13 @@\n import java.util.Collections;\n import java.util.List;\n \n+import jadx.core.dex.instructions.*;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import jadx.core.Consts;\n import jadx.core.dex.info.FieldInfo;\n import jadx.core.dex.info.MethodInfo;\n-import jadx.core.dex.instructions.ArithNode;\n-import jadx.core.dex.instructions.ArithOp;\n-import jadx.core.dex.instructions.ConstStringNode;\n-import jadx.core.dex.instructions.IfNode;\n-import jadx.core.dex.instructions.IndexInsnNode;\n-import jadx.core.dex.instructions.InsnType;\n-import jadx.core.dex.instructions.InvokeNode;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.FieldArg;\n import jadx.core.dex.instructions.args.InsnArg;\n@@ -148,6 +142,15 @@ private static void simplifyTernary(TernaryInsn insn) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Simplify chains of calls to StringBuilder#append() plus constructor of StringBuilder.\n+\t * Those chains are usually automatically generated by the Java compiler when you create String\n+\t * concatenations like <code>\"text \" + 1 + \" text\"</code>.\n+\t *\n+\t * @param mth\n+\t * @param insn\n+\t * @return\n+\t */\n \tprivate static InsnNode convertInvoke(MethodNode mth, InsnNode insn) {\n \t\tMethodInfo callMth = ((InvokeNode) insn).getCallMth();\n \n@@ -201,7 +204,15 @@ private static InsnNode convertInvoke(MethodNode mth, InsnNode insn) {\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tfor (; argInd < len; argInd++) {  // Add the .append(xxx) arg string to concat\n-\t\t\t\t\t\t\tconcatInsn.addArg(chain.get(argInd).getArg(1));\n+\t\t\t\t\t\t\tInsnNode node = chain.get(argInd);\n+\t\t\t\t\t\t\tMethodInfo method = ((CallMthInterface) node).getCallMth();\n+\t\t\t\t\t\t\tif (!(node.getArgsCount() < 2 && method.isConstructor() || method.getName().equals(\"append\"))) {\n+\t\t\t\t\t\t\t\t// The chain contains other calls to StringBuilder methods than the constructor or append.\n+\t\t\t\t\t\t\t\t// We can't simplify such chains, therefore we leave them as they are.\n+\t\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t// process only constructor and append() calls\n+\t\t\t\t\t\t\tconcatInsn.addArg(node.getArg(1));\n \t\t\t\t\t\t}\n \t\t\t\t\t\tconcatInsn.setResult(insn.getResult());\n \t\t\t\t\t\treturn concatInsn;\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/SimplifyVisitorStringBuilderTest.java b/jadx-core/src/test/java/jadx/tests/integration/SimplifyVisitorStringBuilderTest.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/SimplifyVisitorStringBuilderTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/SimplifyVisitorStringBuilderTest.java\n@@ -0,0 +1,94 @@\n+package jadx.tests.integration;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.core.dex.visitors.SimplifyVisitor;\n+import jadx.core.utils.exceptions.JadxException;\n+import jadx.tests.api.IntegrationTest;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Test the StringBuilder simplification part of {@link SimplifyVisitor}\n+ *\n+ * @author Jan Peter Stotz\n+ */\n+public class SimplifyVisitorStringBuilderTest extends IntegrationTest {\n+\n+\tpublic static class TestCls1 {\n+\t\tpublic String test() {\n+\t\t\treturn new StringBuilder(\"[init]\").append(\"a1\").append('c').append(2).append(0l).append(1.0f).\n+\t\t\t\t\tappend(2.0d).append(true).toString();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test1() throws JadxException {\n+\t\tClassNode cls = getClassNode(SimplifyVisitorStringBuilderTest.TestCls1.class);\n+\t\tSimplifyVisitor visitor = new SimplifyVisitor();\n+\t\tvisitor.visit(cls);\n+\t\tString code = cls.getCode().toString();\n+\t\tassertThat(code, containsString(\"return \\\"[init]\\\" + \\\"a1\\\" + 'c' + 2 + 0 + 1.0f + 2.0d + true;\"));\n+\t}\n+\n+\tpublic static class TestCls2 {\n+\t\tpublic String test() {\n+\t\t\t// A chain with non-final variables\n+\t\t\tString sInit = \"[init]\";\n+\t\t\tString s = \"a1\";\n+\t\t\tchar c = 'c';\n+\t\t\tint i = 1;\n+\t\t\tlong l = 2;\n+\t\t\tfloat f = 1.0f;\n+\t\t\tdouble d = 2.0d;\n+\t\t\tboolean b = true;\n+\t\t\treturn new StringBuilder(sInit).append(s).append(c).append(i).append(l).append(f).\n+\t\t\t\t\tappend(d).append(b).toString();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test2() throws JadxException {\n+\t\tClassNode cls = getClassNode(SimplifyVisitorStringBuilderTest.TestCls2.class);\n+\t\tSimplifyVisitor visitor = new SimplifyVisitor();\n+\t\tvisitor.visit(cls);\n+\t\tString code = cls.getCode().toString();\n+\t\tassertThat(code, containsString(\"return \\\"[init]\\\" + \\\"a1\\\" + 'c' + 1 + 2 + 1.0f + 2.0d + true;\"));\n+\t}\n+\n+\tpublic static class TestClsStringUtilsReverse {\n+\n+\t\t/**\n+\t\t * Simplified version of org.apache.commons.lang3.StringUtils.reverse()\n+\t\t */\n+\t\tpublic static String reverse(final String str) {\n+\t\t\treturn new StringBuilder(str).reverse().toString();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test3() throws JadxException {\n+\t\tClassNode cls = getClassNode(SimplifyVisitorStringBuilderTest.TestClsStringUtilsReverse.class);\n+\t\tSimplifyVisitor visitor = new SimplifyVisitor();\n+\t\tvisitor.visit(cls);\n+\t\tString code = cls.getCode().toString();\n+\t\tassertThat(code, containsString(\"return new StringBuilder(str).reverse().toString();\"));\n+\t}\n+\n+\tpublic static class TestClsChainWithDelete {\n+\t\tpublic String test() {\n+\t\t\t// a chain we can't simplify\n+\t\t\treturn new StringBuilder(\"[init]\").append(\"a1\").delete(1, 2).toString();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testChainWithDelete() throws JadxException {\n+\t\tClassNode cls = getClassNode(TestClsChainWithDelete.class);\n+\t\tSimplifyVisitor visitor = new SimplifyVisitor();\n+\t\tvisitor.visit(cls);\n+\t\tString code = cls.getCode().toString();\n+\t\tassertThat(code, containsString(\"return new StringBuilder(\\\"[init]\\\").append(\\\"a1\\\").delete(1, 2).toString();\"));\n+\t}\n+}",
    "output": "Fix ArrayIndexOutOfBoundsException in string concatenation visitor"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java b/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java\n@@ -69,15 +69,17 @@ public void indexCode(JavaClass cls, CodeLinesInfo linesInfo, List<StringRef> li\n \t\t\tint count = lines.size();\n \t\t\tfor (int i = 0; i < count; i++) {\n \t\t\t\tStringRef line = lines.get(i);\n-\t\t\t\tif (line.length() != 0 && line.charAt(0) != '}') {\n-\t\t\t\t\tint lineNum = i + 1;\n-\t\t\t\t\tJavaNode node = linesInfo.getJavaNodeByLine(lineNum);\n-\t\t\t\t\tCodeNode codeNode = new CodeNode(nodeCache.makeFrom(node == null ? cls : node), lineNum, line);\n-\t\t\t\t\tif (strRefSupported) {\n-\t\t\t\t\t\tcodeIndex.put(line, codeNode);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tcodeIndex.put(line.toString(), codeNode);\n-\t\t\t\t\t}\n+\t\t\t\tint lineLength = line.length();\n+\t\t\t\tif (lineLength == 0 || (lineLength == 1 && line.charAt(0) == '}')) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tint lineNum = i + 1;\n+\t\t\t\tJavaNode node = linesInfo.getJavaNodeByLine(lineNum);\n+\t\t\t\tCodeNode codeNode = new CodeNode(nodeCache.makeFrom(node == null ? cls : node), lineNum, line);\n+\t\t\t\tif (strRefSupported) {\n+\t\t\t\t\tcodeIndex.put(line, codeNode);\n+\t\t\t\t} else {\n+\t\t\t\t\tcodeIndex.put(line.toString(), codeNode);\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (Exception e) {",
    "output": "Fix don't skip indexing code lines starting with '}'"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -4,6 +4,8 @@\n import java.util.List;\n \n import com.android.dx.rop.code.AccessFlags;\n+import jadx.core.dex.info.ClassInfo;\n+import jadx.core.utils.Utils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -165,8 +167,16 @@ public void addInstructions(CodeWriter code) throws CodegenException {\n \t\t\taddFallbackMethodCode(code);\n \t\t\tcode.startLine(\"*/\");\n \n+\t\t\tClassInfo clsAlias = mth.getParentClass().getAlias();\n+\n \t\t\tcode.startLine(\"throw new UnsupportedOperationException(\\\"Method not decompiled: \")\n-\t\t\t\t\t.add(mth.toString())\n+\t\t\t\t\t.add(clsAlias.makeFullClsName(clsAlias.getShortName(), true))\n+\t\t\t\t\t.add(\".\")\n+\t\t\t\t\t.add(mth.getAlias())\n+\t\t\t\t\t.add(\"(\")\n+\t\t\t\t\t.add(Utils.listToString(mth.getMethodInfo().getArgumentsTypes()))\n+\t\t\t\t\t.add(\"):\")\n+\t\t\t\t\t.add(mth.getMethodInfo().getReturnType().toString())\n \t\t\t\t\t.add(\"\\\");\");\n \t\t} else {\n \t\t\tRegionGen regionGen = new RegionGen(this);",
    "output": "Fix show method alias in \"method not decompiled\" messages"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n@@ -181,7 +181,6 @@ private boolean checkBound(ArgType candidateType, ITypeBound bound, ArgType boun\n \t\t\t\treturn true;\n \n \t\t\tcase WIDER:\n-\t\t\tcase WIDER_BY_GENERIC:\n \t\t\t\treturn bound.getBound() != BoundEnum.USE;\n \n \t\t\tcase NARROW:\n@@ -190,6 +189,7 @@ private boolean checkBound(ArgType candidateType, ITypeBound bound, ArgType boun\n \t\t\t\t}\n \t\t\t\treturn true;\n \n+\t\t\tcase WIDER_BY_GENERIC:\n \t\t\tcase NARROW_BY_GENERIC:\n \t\t\t\t// allow replace object to same object with known generic type\n \t\t\t\t// due to incomplete information about external methods and fields\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestGenerics.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestGenerics.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestGenerics.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestGenerics.java\n@@ -0,0 +1,39 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestGenerics extends IntegrationTest {\n+\n+\tpublic static class TestCls<T> {\n+\t\tprivate T data;\n+\n+\t\tpublic TestCls<T> data(T t) {\n+\t\t\tthis.data = t;\n+\t\t\treturn this;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"TestCls<T> data(T t) {\"));\n+\t}\n+\n+\t@Test\n+\tpublic void test2() {\n+//\t\tsetFallback();\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"TestCls<T> data(T t) {\"));\n+\t}\n+}",
    "output": "Fix don't reject type update for generics"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundJob.java b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundJob.java\n--- a/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundJob.java\n+++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundJob.java\n@@ -44,7 +44,7 @@ public ShutdownTask() {\n \t\t\t\tpublic Boolean call() throws Exception {\n \t\t\t\t\trunJob();\n \t\t\t\t\texecutor.shutdown();\n-\t\t\t\t\treturn executor.awaitTermination(5, TimeUnit.MINUTES);\n+\t\t\t\t\treturn executor.awaitTermination(5, TimeUnit.DAYS);\n \t\t\t\t}\n \t\t\t});\n \t\t}",
    "output": "Fix wait time for background jobs too short"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java\n@@ -1,13 +1,19 @@\n package jadx.core.dex.instructions.args;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n \n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n \n+import jadx.core.dex.attributes.AType;\n import jadx.core.dex.attributes.AttrNode;\n+import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;\n import jadx.core.dex.instructions.PhiInsn;\n+import jadx.core.dex.nodes.MethodNode;\n import jadx.core.dex.visitors.typeinference.TypeInfo;\n \n public class SSAVar extends AttrNode {\n@@ -146,4 +152,44 @@ public int hashCode() {\n \tpublic String toString() {\n \t\treturn \"r\" + regNum + \":\" + version + \" \" + typeInfo.getType();\n \t}\n+\n+\tpublic String getDetailedVarInfo(MethodNode mth) {\n+\t\tSet<ArgType> types = new HashSet<>();\n+\t\tSet<String> names = Collections.emptySet();\n+\n+\t\tList<RegisterArg> useArgs = new ArrayList<>(1 + useList.size());\n+\t\tuseArgs.add(assign);\n+\t\tuseArgs.addAll(useList);\n+\n+\t\tif (mth.contains(AType.LOCAL_VARS_DEBUG_INFO)) {\n+\t\t\tnames = new HashSet<>();\n+\t\t\tfor (RegisterArg arg : useArgs) {\n+\t\t\t\tRegDebugInfoAttr debugInfoAttr = arg.get(AType.REG_DEBUG_INFO);\n+\t\t\t\tif (debugInfoAttr != null) {\n+\t\t\t\t\tnames.add(debugInfoAttr.getName());\n+\t\t\t\t\ttypes.add(debugInfoAttr.getRegType());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tfor (RegisterArg arg : useArgs) {\n+\t\t\tArgType initType = arg.getInitType();\n+\t\t\tif (initType.isTypeKnown()) {\n+\t\t\t\ttypes.add(initType);\n+\t\t\t}\n+\t\t\tArgType type = arg.getType();\n+\t\t\tif (type.isTypeKnown()) {\n+\t\t\t\ttypes.add(type);\n+\t\t\t}\n+\t\t}\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tsb.append('r').append(regNum).append('v').append(version);\n+\t\tif (!names.isEmpty()) {\n+\t\t\tsb.append(\", names: \").append(names);\n+\t\t}\n+\t\tif (!types.isEmpty()) {\n+\t\t\tsb.append(\", types: \").append(types);\n+\t\t}\n+\t\treturn sb.toString();\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -60,7 +60,7 @@ public void visit(MethodNode mth) {\n \t\t\tif (type != null && !type.isTypeKnown()) {\n \t\t\t\tboolean changed = tryAllTypes(var, type);\n \t\t\t\tif (!changed) {\n-\t\t\t\t\tmth.addComment(\"JADX WARNING: type inference failed for: \" + var + \", bounds: \" + typeInfo.getBounds());\n+\t\t\t\t\tmth.addComment(\"JADX WARNING: type inference failed for: \" + var.getDetailedVarInfo(mth));\n \t\t\t\t}\n \t\t\t}\n \t\t});",
    "output": "Add more details for variable with type inference error"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java\n@@ -223,12 +223,13 @@ private static void setupConnections(MethodNode mth, Map<Integer, BlockNode> blo\n \t\t\t\t\tBlockNode thisBlock = getBlock(jump.getDest(), blocksMap);\n \t\t\t\t\tconnect(srcBlock, thisBlock);\n \t\t\t\t}\n-\t\t\t\tconnectExceptionHandlers(block, insn);\n+\t\t\t\tconnectExceptionHandlers(block, insn, blocksMap);\n \t\t\t}\n \t\t}\n \t}\n \n-\tprivate static void connectExceptionHandlers(BlockNode block, InsnNode insn) {\n+\tprivate static void connectExceptionHandlers(BlockNode block, InsnNode insn,\n+\t                                             Map<Integer, BlockNode> blocksMap) {\n \t\tCatchAttr catches = insn.get(AType.CATCH_BLOCK);\n \t\tSplitterBlockAttr spl = block.get(AType.SPLITTER_BLOCK);\n \t\tif (catches == null || spl == null) {\n@@ -237,7 +238,7 @@ private static void connectExceptionHandlers(BlockNode block, InsnNode insn) {\n \t\tBlockNode splitterBlock = spl.getBlock();\n \t\tboolean tryEnd = insn.contains(AFlag.TRY_LEAVE);\n \t\tfor (ExceptionHandler h : catches.getTryBlock().getHandlers()) {\n-\t\t\tBlockNode handlerBlock = h.getHandlerBlock();\n+\t\t\tBlockNode handlerBlock = initHandlerBlock(h, blocksMap);\n \t\t\t// skip self loop in handler\n \t\t\tif (splitterBlock != handlerBlock) {\n \t\t\t\tif (!handlerBlock.contains(AType.SPLITTER_BLOCK)) {\n@@ -251,6 +252,16 @@ private static void connectExceptionHandlers(BlockNode block, InsnNode insn) {\n \t\t}\n \t}\n \n+\tprivate static BlockNode initHandlerBlock(ExceptionHandler excHandler, Map<Integer, BlockNode> blocksMap) {\n+\t\tBlockNode handlerBlock = excHandler.getHandlerBlock();\n+\t\tif (handlerBlock != null) {\n+\t\t\treturn handlerBlock;\n+\t\t}\n+\t\tBlockNode blockByOffset = getBlock(excHandler.getHandleOffset(), blocksMap);\n+\t\texcHandler.setHandlerBlock(blockByOffset);\n+\t\treturn blockByOffset;\n+\t}\n+\n \tprivate static boolean isSplitByJump(InsnNode prevInsn, InsnNode currentInsn) {\n \t\tList<JumpInfo> pJumps = prevInsn.getAll(AType.JUMP);\n \t\tfor (JumpInfo jump : pJumps) {",
    "output": "Fix search exception handler splitter block by offset if jump source unknown"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -409,6 +409,9 @@ private String getFieldAlias(FieldNode field) {\n \t@Nullable\n \tprivate String getMethodAlias(MethodNode mth) {\n \t\tMethodInfo methodInfo = mth.getMethodInfo();\n+\t\tif (methodInfo.isClassInit() || methodInfo.isConstructor()) {\n+\t\t\treturn null;\n+\t\t}\n \t\tString alias = mthMap.get(methodInfo);\n \t\tif (alias != null) {\n \t\t\treturn alias;",
    "output": "Fix don't rename constructors and class init methods in deobfuscator"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n@@ -116,14 +116,16 @@ private void dumpMapping() throws IOException {\n \t\t\t}\n \t\t}\n \t\tfor (FieldInfo fld : deobfuscator.getFldMap().keySet()) {\n-\t\t\tlist.add(String.format(\"f %s = %s\", fld.getFullId(), fld.getAlias()));\n+\t\t\tlist.add(String.format(\"f %s = %s\", fld.getRawFullId(), fld.getAlias()));\n \t\t}\n \t\tfor (MethodInfo mth : deobfuscator.getMthMap().keySet()) {\n-\t\t\tlist.add(String.format(\"m %s = %s\", mth.getFullId(), mth.getAlias()));\n+\t\t\tlist.add(String.format(\"m %s = %s\", mth.getRawFullId(), mth.getAlias()));\n \t\t}\n \t\tCollections.sort(list);\n \t\tFileUtils.writeLines(deobfMapFile, MAP_FILE_CHARSET, list);\n-\t\tlist.clear();\n+\t\tif (LOG.isDebugEnabled()) {\n+\t\t\tLOG.debug(\"Deobfuscation map file saved as: {}\", deobfMapFile);\n+\t\t}\n \t}\n \n \tprivate static void dfsPackageName(List<String> list, String prefix, PackageNode node) {\n@@ -140,11 +142,11 @@ public String getForCls(ClassInfo cls) {\n \t}\n \n \tpublic String getForFld(FieldInfo fld) {\n-\t\treturn fldPresetMap.get(fld.getFullId());\n+\t\treturn fldPresetMap.get(fld.getRawFullId());\n \t}\n \n \tpublic String getForMth(MethodInfo mth) {\n-\t\treturn mthPresetMap.get(mth.getFullId());\n+\t\treturn mthPresetMap.get(mth.getRawFullId());\n \t}\n \n \tpublic void clear() {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java\n@@ -57,6 +57,10 @@ public String getFullId() {\n \t\treturn declClass.getFullName() + \".\" + name + \":\" + TypeGen.signature(type);\n \t}\n \n+\tpublic String getRawFullId() {\n+\t\treturn declClass.makeRawFullName() + \".\" + name + \":\" + TypeGen.signature(type);\n+\t}\n+\n \tpublic boolean isRenamed() {\n \t\treturn !name.equals(alias);\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java\n@@ -68,6 +68,10 @@ public String getFullId() {\n \t\treturn declClass.getFullName() + \".\" + shortId;\n \t}\n \n+\tpublic String getRawFullId() {\n+\t\treturn declClass.makeRawFullName() + \".\" + shortId;\n+\t}\n+\n \t/**\n \t * Method name and signature\n \t */",
    "output": "Use '$' for inner classes also in methods and fields"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -602,11 +602,8 @@ private void makeInvoke(InvokeNode insn, CodeWriter code) throws CodegenExceptio\n \n \t\t// inline method\n \t\tMethodNode callMthNode = mth.root().deepResolveMethod(callMth);\n-\t\tif (callMthNode != null) {\n-\t\t\tif (inlineMethod(callMthNode, insn, code)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tcallMth = callMthNode.getMethodInfo();\n+\t\tif (callMthNode != null && inlineMethod(callMthNode, insn, code)) {\n+\t\t\treturn;\n \t\t}\n \n \t\tint k = 0;\n@@ -640,8 +637,10 @@ private void makeInvoke(InvokeNode insn, CodeWriter code) throws CodegenExceptio\n \t\t}\n \t\tif (callMthNode != null) {\n \t\t\tcode.attachAnnotation(callMthNode);\n+\t\t\tcode.add(callMthNode.getAlias());\n+\t\t} else {\n+\t\t\tcode.add(callMth.getAlias());\n \t\t}\n-\t\tcode.add(callMth.getAlias());\n \t\tgenerateMethodArguments(code, insn, k, callMthNode);\n \t}\n \n@@ -694,7 +693,14 @@ private static RegisterArg getCallMthArg(@Nullable MethodNode callMth, int num)\n \t * Add additional cast for overloaded method argument.\n \t */\n \tprivate boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnArg arg, int origPos) {\n-\t\tArgType origType = callMth.getArguments(false).get(origPos).getInitType();\n+\t\tArgType origType;\n+\t\tList<RegisterArg> arguments = callMth.getArguments(false);\n+\t\tif (arguments.isEmpty()) {\n+\t\t\tmth.addComment(\"JADX WARN: used method not loaded: \" + callMth + \", types can be incorrect\");\n+\t\t\torigType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);\n+\t\t} else {\n+\t\t\torigType = arguments.get(origPos).getInitType();\n+\t\t}\n \t\tif (!arg.getType().equals(origType)) {\n \t\t\tcode.add('(');\n \t\t\tuseType(code, origType);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java\n@@ -11,6 +11,7 @@\n import jadx.core.dex.instructions.args.InsnArg;\n import jadx.core.dex.instructions.args.InsnWrapArg;\n import jadx.core.dex.instructions.args.RegisterArg;\n+import jadx.core.dex.instructions.mods.ConstructorInsn;\n import jadx.core.dex.nodes.BlockNode;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.DexNode;\n@@ -90,6 +91,9 @@ private static void processCustomInsn(DexNode dex, Set<ClassNode> depList, InsnN\n \t\t} else if (insn instanceof InvokeNode) {\n \t\t\tClassInfo declClass = ((InvokeNode) insn).getCallMth().getDeclClass();\n \t\t\taddDep(dex, depList, declClass);\n+\t\t} else if (insn instanceof ConstructorInsn) {\n+\t\t\tClassInfo declClass = ((ConstructorInsn) insn).getCallMth().getDeclClass();\n+\t\t\taddDep(dex, depList, declClass);\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/CodegenUtils.java b/jadx-core/src/main/java/jadx/core/utils/CodegenUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/CodegenUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/CodegenUtils.java\n@@ -8,7 +8,7 @@ public class CodegenUtils {\n \n \tpublic static void addComments(CodeWriter code, AttrNode node) {\n \t\tfor (String comment : node.getAll(AType.COMMENTS)) {\n-\t\t\tcode.startLine(\"/* \").add(comment).add(\" */\");\n+\t\t\tcode.startLine(\"/* \").addMultiLine(comment).add(\" */\");\n \t\t}\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestInheritedStaticInvoke.java b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestInheritedStaticInvoke.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestInheritedStaticInvoke.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestInheritedStaticInvoke.java\n@@ -0,0 +1,36 @@\n+package jadx.tests.integration.invoke;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestInheritedStaticInvoke extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tpublic static class A {\n+\t\t\tpublic static int a() {\n+\t\t\t\treturn 1;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic static class B extends A {\n+\t\t}\n+\n+\t\tpublic int test() {\n+\t\t\treturn B.a(); // not A.a()\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"return B.a();\"));\n+\t}\n+}",
    "output": "Use original call class for invoke inherited methods"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n@@ -112,7 +112,7 @@ private void dumpMapping() throws IOException {\n \t\tfor (DeobfClsInfo deobfClsInfo : deobfuscator.getClsMap().values()) {\n \t\t\tif (deobfClsInfo.getAlias() != null) {\n \t\t\t\tlist.add(String.format(\"c %s = %s\",\n-\t\t\t\t\t\tdeobfClsInfo.getCls().getClassInfo().getFullName(), deobfClsInfo.getAlias()));\n+\t\t\t\t\t\tdeobfClsInfo.getCls().getClassInfo().makeRawFullName(), deobfClsInfo.getAlias()));\n \t\t\t}\n \t\t}\n \t\tfor (FieldInfo fld : deobfuscator.getFldMap().keySet()) {\n@@ -136,7 +136,7 @@ private static void dfsPackageName(List<String> list, String prefix, PackageNode\n \t}\n \n \tpublic String getForCls(ClassInfo cls) {\n-\t\treturn clsPresetMap.get(cls.getFullName());\n+\t\treturn clsPresetMap.get(cls.makeRawFullName());\n \t}\n \n \tpublic String getForFld(FieldInfo fld) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n@@ -111,6 +111,10 @@ public String makeFullClsName(String shortName, boolean raw) {\n \t\treturn pkg.isEmpty() ? shortName : pkg + \".\" + shortName;\n \t}\n \n+\tpublic String makeRawFullName() {\n+\t\treturn makeFullClsName(this.name, true);\n+\t}\n+\n \tpublic String getFullPath() {\n \t\tClassInfo usedAlias = getAlias();\n \t\treturn usedAlias.getPackage().replace('.', File.separatorChar)",
    "output": "Use '$' as separator for inner classes in .jobf file"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n@@ -20,8 +20,13 @@\n \r\n import org.fife.ui.rsyntaxtextarea.SyntaxScheme;\r\n import org.fife.ui.rsyntaxtextarea.Token;\r\n+import org.jetbrains.annotations.Nullable;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n \r\n public class LineNumbers extends JPanel implements CaretListener {\r\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(LineNumbers.class);\r\n+\r\n \tprivate static final long serialVersionUID = -4978268673635308190L;\r\n \r\n \tprivate static final int NUM_HEIGHT = Integer.MAX_VALUE - 1000000;\r\n@@ -92,30 +97,42 @@ private void setPreferredWidth() {\n \t@Override\r\n \tpublic void paintComponent(Graphics g) {\r\n \t\tsuper.paintComponent(g);\r\n-\t\tg.setFont(codeArea.getFont());\r\n \t\tapplyRenderHints(g);\r\n \r\n-\t\tFontMetrics fontMetrics = codeArea.getFontMetrics(codeArea.getFont());\r\n+\t\tFont font = codeArea.getFont();\r\n+\t\tfont = font.deriveFont(font.getSize2D() - 1.0f);\r\n+\t\tg.setFont(font);\r\n+\r\n+\t\tDimension size = getSize();\r\n+\t\tg.setColor(codeArea.getBackground());\r\n+\t\tg.fillRect(0, 0, size.width, size.height);\r\n+\r\n+\t\tFontMetrics fontMetrics = codeArea.getFontMetrics(font);\r\n \t\tInsets insets = getInsets();\r\n-\t\tint availableWidth = getSize().width - insets.left - insets.right;\r\n+\t\tint availableWidth = size.width - insets.left - insets.right;\r\n \t\tRectangle clip = g.getClipBounds();\r\n \t\tint rowStartOffset = codeArea.viewToModel(new Point(0, clip.y));\r\n \t\tint endOffset = codeArea.viewToModel(new Point(0, clip.y + clip.height));\r\n \r\n \t\twhile (rowStartOffset <= endOffset) {\r\n \t\t\ttry {\r\n-\t\t\t\tif (isCurrentLine(rowStartOffset)) {\r\n-\t\t\t\t\tg.setColor(currentColor);\r\n-\t\t\t\t} else {\r\n-\t\t\t\t\tg.setColor(numberColor);\r\n-\t\t\t\t}\r\n \t\t\t\tString lineNumber = getTextLineNumber(rowStartOffset);\r\n-\t\t\t\tint stringWidth = fontMetrics.stringWidth(lineNumber);\r\n-\t\t\t\tint x = availableWidth - stringWidth + insets.left;\r\n-\t\t\t\tint y = getOffsetY(rowStartOffset, fontMetrics);\r\n-\t\t\t\tg.drawString(lineNumber, x, y);\r\n+\t\t\t\tif (lineNumber != null) {\r\n+\t\t\t\t\tif (isCurrentLine(rowStartOffset)) {\r\n+\t\t\t\t\t\tg.setColor(currentColor);\r\n+\t\t\t\t\t} else {\r\n+\t\t\t\t\t\tg.setColor(numberColor);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tint stringWidth = fontMetrics.stringWidth(lineNumber);\r\n+\t\t\t\t\tint x = availableWidth - stringWidth + insets.left;\r\n+\t\t\t\t\tint y = getOffsetY(rowStartOffset, fontMetrics);\r\n+\t\t\t\t\tg.drawString(lineNumber, x, y);\r\n+\t\t\t\t}\r\n \t\t\t\trowStartOffset = Utilities.getRowEnd(codeArea, rowStartOffset) + 1;\r\n \t\t\t} catch (Exception e) {\r\n+\t\t\t\tif (LOG.isDebugEnabled()) {\r\n+\t\t\t\t\tLOG.debug(\"Line numbers draw error\", e);\r\n+\t\t\t\t}\r\n \t\t\t\tbreak;\r\n \t\t\t}\r\n \t\t}\r\n@@ -140,22 +157,23 @@ private boolean isCurrentLine(int rowStartOffset) {\n \t\treturn root.getElementIndex(rowStartOffset) == root.getElementIndex(caretPosition);\r\n \t}\r\n \r\n+\t@Nullable\r\n \tprotected String getTextLineNumber(int rowStartOffset) {\r\n \t\tElement root = codeArea.getDocument().getDefaultRootElement();\r\n \t\tint index = root.getElementIndex(rowStartOffset);\r\n \t\tElement line = root.getElement(index);\r\n-\t\tif (line.getStartOffset() == rowStartOffset) {\r\n-\t\t\tint lineNumber = index + 1;\r\n-\t\t\tif (useSourceLines) {\r\n-\t\t\t\tInteger sourceLine = codeArea.getSourceLine(lineNumber);\r\n-\t\t\t\tif (sourceLine != null) {\r\n-\t\t\t\t\treturn String.valueOf(sourceLine);\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\treturn String.valueOf(lineNumber);\r\n+\t\tif (line.getStartOffset() != rowStartOffset) {\r\n+\t\t\treturn null;\r\n+\t\t}\r\n+\t\tint lineNumber = index + 1;\r\n+\t\tif (useSourceLines) {\r\n+\t\t\tInteger sourceLine = codeArea.getSourceLine(lineNumber);\r\n+\t\t\tif (sourceLine == null) {\r\n+\t\t\t\treturn null;\r\n \t\t\t}\r\n+\t\t\treturn String.valueOf(sourceLine);\r\n \t\t}\r\n-\t\treturn \"\";\r\n+\t\treturn String.valueOf(lineNumber);\r\n \t}\r\n \r\n \tprivate int getOffsetY(int rowStartOffset, FontMetrics fontMetrics) throws BadLocationException {",
    "output": "Fix fill background before draw line numbers"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java\n@@ -112,7 +112,7 @@ private void dumpMapping() throws IOException {\n \t\tfor (DeobfClsInfo deobfClsInfo : deobfuscator.getClsMap().values()) {\n \t\t\tif (deobfClsInfo.getAlias() != null) {\n \t\t\t\tlist.add(String.format(\"c %s = %s\",\n-\t\t\t\t\t\tdeobfClsInfo.getCls().getClassInfo().getFullName(), deobfClsInfo.getAlias()));\n+\t\t\t\t\t\tdeobfClsInfo.getCls().getClassInfo().makeRawFullName(), deobfClsInfo.getAlias()));\n \t\t\t}\n \t\t}\n \t\tfor (FieldInfo fld : deobfuscator.getFldMap().keySet()) {\n@@ -136,7 +136,7 @@ private static void dfsPackageName(List<String> list, String prefix, PackageNode\n \t}\n \n \tpublic String getForCls(ClassInfo cls) {\n-\t\treturn clsPresetMap.get(cls.getFullName());\n+\t\treturn clsPresetMap.get(cls.makeRawFullName());\n \t}\n \n \tpublic String getForFld(FieldInfo fld) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n@@ -111,6 +111,10 @@ public String makeFullClsName(String shortName, boolean raw) {\n \t\treturn pkg.isEmpty() ? shortName : pkg + \".\" + shortName;\n \t}\n \n+\tpublic String makeRawFullName() {\n+\t\treturn makeFullClsName(this.name, true);\n+\t}\n+\n \tpublic String getFullPath() {\n \t\tClassInfo usedAlias = getAlias();\n \t\treturn usedAlias.getPackage().replace('.', File.separatorChar)",
    "output": "Use '$' as separator for inner classes in .jobf file"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -694,7 +694,7 @@ private static RegisterArg getCallMthArg(@Nullable MethodNode callMth, int num)\n \t * Add additional cast for overloaded method argument.\n \t */\n \tprivate boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnArg arg, int origPos) {\n-\t\tArgType origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);\n+\t\tArgType origType = callMth.getArguments(false).get(origPos).getInitType();\n \t\tif (!arg.getType().equals(origType)) {\n \t\t\tcode.add('(');\n \t\t\tuseType(code, origType);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java\n@@ -0,0 +1,54 @@\n+package jadx.tests.integration.invoke;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestCastInOverloadedInvoke extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic void test() {\n+\t\t\tcall(new ArrayList<>());\n+\t\t\tcall((List<String>) new ArrayList<String>());\n+\t\t}\n+\n+\t\tpublic void test2(Object obj) {\n+\t\t\tif (obj instanceof String) {\n+\t\t\t\tcall((String) obj);\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void call(String str) {\n+\t\t}\n+\n+\t\tpublic void call(List<String> list) {\n+\t\t}\n+\n+\t\tpublic void call(ArrayList<String> list) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+// \t\tTODO: implement more checks for casts in overloaded methods\n+//\t\tassertThat(code, containsOne(\"call(new ArrayList<>());\"));\n+\t\tassertThat(code, containsOne(\"call((ArrayList<String>) new ArrayList());\"));\n+\n+// \t\tTODO: fix generics in constructors\n+//\t\tassertThat(code, containsOne(\"call((List<String>) new ArrayList<String>());\"));\n+\t\tassertThat(code, containsOne(\"call((List<String>) new ArrayList());\"));\n+\n+\t\tassertThat(code, containsOne(\"call((String) obj);\"));\n+\t}\n+}",
    "output": "Use types with generics for overloaded method casts"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n@@ -526,6 +526,11 @@ public boolean canBeArray() {\n \t\treturn isArray() || (!isTypeKnown() && contains(PrimitiveType.ARRAY));\n \t}\n \n+\tpublic boolean canBePrimitive(PrimitiveType primitiveType) {\n+\t\treturn (isPrimitive() && getPrimitiveType() == primitiveType)\n+\t\t\t\t|| (!isTypeKnown() && contains(primitiveType));\n+\t}\n+\n \tpublic static ArgType convertFromPrimitiveType(PrimitiveType primitiveType) {\n \t\tswitch (primitiveType) {\n \t\t\tcase BOOLEAN:\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoApplyVisitor.java\n@@ -9,6 +9,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.core.Consts;\n import jadx.core.deobf.NameMapper;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n@@ -34,8 +35,8 @@\n import jadx.core.utils.exceptions.JadxException;\n \n @JadxVisitor(\n-\t\tname = \"Debug Info Parser\",\n-\t\tdesc = \"Parse debug information (variable names and types, instruction lines)\",\n+\t\tname = \"Debug Info Apply\",\n+\t\tdesc = \"Apply debug info to registers (type and names)\",\n \t\trunAfter = {\n \t\t\t\tSSATransform.class,\n \t\t\t\tTypeInferenceVisitor.class,\n@@ -101,7 +102,7 @@ private static void searchDebugInfoByOffset(MethodNode mth, SSAVar ssaVar) {\n \t\t\t\tint startAddr = localVar.getStartAddr();\n \t\t\t\tint endAddr = localVar.getEndAddr();\n \t\t\t\tif (isInside(startOffset, startAddr, endAddr) || isInside(endOffset, startAddr, endAddr)) {\n-\t\t\t\t\tif (LOG.isDebugEnabled()) {\n+\t\t\t\t\tif (Consts.DEBUG && LOG.isDebugEnabled()) {\n \t\t\t\t\t\tLOG.debug(\"Apply debug info by offset for: {} to {}\", ssaVar, localVar);\n \t\t\t\t\t}\n \t\t\t\t\tapplyDebugInfo(mth, ssaVar, localVar.getType(), localVar.getName());\n@@ -126,15 +127,15 @@ private static int getInsnOffsetByArg(InsnArg arg) {\n \t}\n \n \tpublic static void applyDebugInfo(MethodNode mth, SSAVar ssaVar, ArgType type, String varName) {\n-\t\tTypeUpdateResult result = mth.root().getTypeUpdate().apply(ssaVar, type);\n+\t\tif (NameMapper.isValidIdentifier(varName)) {\n+\t\t\tssaVar.setName(varName);\n+\t\t}\n+\t\tTypeUpdateResult result = mth.root().getTypeUpdate().applyDebug(ssaVar, type);\n \t\tif (result == TypeUpdateResult.REJECT) {\n \t\t\tif (LOG.isDebugEnabled()) {\n \t\t\t\tLOG.debug(\"Reject debug info of type: {} and name: '{}' for {}, mth: {}\", type, varName, ssaVar, mth);\n \t\t\t}\n \t\t} else {\n-\t\t\tif (NameMapper.isValidIdentifier(varName)) {\n-\t\t\t\tssaVar.setName(varName);\n-\t\t\t}\n \t\t\tdetachDebugInfo(ssaVar.getAssign());\n \t\t\tssaVar.getUseList().forEach(DebugInfoApplyVisitor::detachDebugInfo);\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeCompare.java\n@@ -193,9 +193,6 @@ public ArgTypeComparator getComparator() {\n \t\treturn comparator;\n \t}\n \n-\t/**\n-\t *\n-\t */\n \tprivate final class ArgTypeComparator implements Comparator<ArgType> {\n \t\t@Override\n \t\tpublic int compare(ArgType a, ArgType b) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n@@ -33,11 +33,22 @@ public final class TypeUpdate {\n \tprivate final TypeUpdateRegistry listenerRegistry;\n \tprivate final TypeCompare comparator;\n \n+\tprivate ThreadLocal<Boolean> applyDebug = new ThreadLocal<>();\n+\n \tpublic TypeUpdate(RootNode root) {\n \t\tthis.listenerRegistry = initListenerRegistry();\n \t\tthis.comparator = new TypeCompare(root);\n \t}\n \n+\tpublic TypeUpdateResult applyDebug(SSAVar ssaVar, ArgType candidateType) {\n+\t\ttry {\n+\t\t\tapplyDebug.set(true);\n+\t\t\treturn apply(ssaVar, candidateType);\n+\t\t} finally {\n+\t\t\tapplyDebug.set(false);\n+\t\t}\n+\t}\n+\n \tpublic TypeUpdateResult apply(SSAVar ssaVar, ArgType candidateType) {\n \t\tif (candidateType == null) {\n \t\t\treturn REJECT;\n@@ -71,6 +82,16 @@ private TypeUpdateResult updateTypeChecked(TypeUpdateInfo updateInfo, InsnArg ar\n \t\tif (arg.isTypeImmutable() && currentType != ArgType.UNKNOWN) {\n \t\t\treturn REJECT;\n \t\t}\n+\t\tTypeCompareEnum compareResult = comparator.compareTypes(candidateType, currentType);\n+\t\tif (compareResult == TypeCompareEnum.CONFLICT) {\n+\t\t\treturn REJECT;\n+\t\t}\n+\t\tif (compareResult == TypeCompareEnum.WIDER || compareResult == TypeCompareEnum.WIDER_BY_GENERIC) {\n+\t\t\t// allow wider types for apply from debug info\n+\t\t\tif (applyDebug.get() != Boolean.TRUE) {\n+\t\t\t\treturn REJECT;\n+\t\t\t}\n+\t\t}\n \t\tif (arg instanceof RegisterArg) {\n \t\t\tRegisterArg reg = (RegisterArg) arg;\n \t\t\treturn updateTypeForSsaVar(updateInfo, reg.getSVar(), candidateType);\n@@ -316,6 +337,14 @@ private TypeUpdateResult ifListener(TypeUpdateInfo updateInfo, InsnNode insn, In\n \t\t\tif (candidateType.isArray() && updateArgType.canBeArray()) {\n \t\t\t\treturn SAME;\n \t\t\t}\n+\t\t\tif (candidateType.isPrimitive()) {\n+\t\t\t\tif (updateArgType.canBePrimitive(candidateType.getPrimitiveType())) {\n+\t\t\t\t\treturn SAME;\n+\t\t\t\t}\n+\t\t\t\tif (updateArgType.isTypeKnown() && candidateType.getRegCount() == updateArgType.getRegCount()) {\n+\t\t\t\t\treturn SAME;\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestInlineInCatch.java b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestInlineInCatch.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestInlineInCatch.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestInlineInCatch.java\n@@ -19,6 +19,9 @@ public int test() {\n \t\t\tFile output = null;\n \t\t\ttry {\n \t\t\t\toutput = File.createTempFile(\"f\", \"a\", dir);\n+\t\t\t\tif (!output.exists()) {\n+\t\t\t\t\treturn 1;\n+\t\t\t\t}\n \t\t\t\treturn 0;\n \t\t\t} catch (Exception e) {\n \t\t\t\tif (output != null) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitivesInIf.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitivesInIf.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitivesInIf.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestPrimitivesInIf.java\n@@ -0,0 +1,47 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+public class TestPrimitivesInIf extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\n+\t\tpublic boolean test(String str) {\n+\t\t\tshort sh = Short.parseShort(str);\n+\t\t\tint i = Integer.parseInt(str);\n+\t\t\tSystem.out.println(sh + \" vs \" + i);\n+\t\t\treturn sh == i;\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tassertTrue(test(\"1\"));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"short sh = Short.parseShort(str);\"));\n+\t\tassertThat(code, containsOne(\"int i = Integer.parseInt(str);\"));\n+\t\tassertThat(code, containsOne(\"return sh == i;\"));\n+\t}\n+\n+\t@Test\n+\tpublic void test2() {\n+\t\tsetOutputCFG();\n+\t\tnoDebugInfo();\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"short parseShort = Short.parseShort(str);\"));\n+\t}\n+}",
    "output": "Fix allow override type with wider one only from debug info"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n@@ -20,8 +20,13 @@\n \r\n import org.fife.ui.rsyntaxtextarea.SyntaxScheme;\r\n import org.fife.ui.rsyntaxtextarea.Token;\r\n+import org.jetbrains.annotations.Nullable;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n \r\n public class LineNumbers extends JPanel implements CaretListener {\r\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(LineNumbers.class);\r\n+\r\n \tprivate static final long serialVersionUID = -4978268673635308190L;\r\n \r\n \tprivate static final int NUM_HEIGHT = Integer.MAX_VALUE - 1000000;\r\n@@ -92,30 +97,42 @@ private void setPreferredWidth() {\n \t@Override\r\n \tpublic void paintComponent(Graphics g) {\r\n \t\tsuper.paintComponent(g);\r\n-\t\tg.setFont(codeArea.getFont());\r\n \t\tapplyRenderHints(g);\r\n \r\n-\t\tFontMetrics fontMetrics = codeArea.getFontMetrics(codeArea.getFont());\r\n+\t\tFont font = codeArea.getFont();\r\n+\t\tfont = font.deriveFont(font.getSize2D() - 1.0f);\r\n+\t\tg.setFont(font);\r\n+\r\n+\t\tDimension size = getSize();\r\n+\t\tg.setColor(codeArea.getBackground());\r\n+\t\tg.fillRect(0, 0, size.width, size.height);\r\n+\r\n+\t\tFontMetrics fontMetrics = codeArea.getFontMetrics(font);\r\n \t\tInsets insets = getInsets();\r\n-\t\tint availableWidth = getSize().width - insets.left - insets.right;\r\n+\t\tint availableWidth = size.width - insets.left - insets.right;\r\n \t\tRectangle clip = g.getClipBounds();\r\n \t\tint rowStartOffset = codeArea.viewToModel(new Point(0, clip.y));\r\n \t\tint endOffset = codeArea.viewToModel(new Point(0, clip.y + clip.height));\r\n \r\n \t\twhile (rowStartOffset <= endOffset) {\r\n \t\t\ttry {\r\n-\t\t\t\tif (isCurrentLine(rowStartOffset)) {\r\n-\t\t\t\t\tg.setColor(currentColor);\r\n-\t\t\t\t} else {\r\n-\t\t\t\t\tg.setColor(numberColor);\r\n-\t\t\t\t}\r\n \t\t\t\tString lineNumber = getTextLineNumber(rowStartOffset);\r\n-\t\t\t\tint stringWidth = fontMetrics.stringWidth(lineNumber);\r\n-\t\t\t\tint x = availableWidth - stringWidth + insets.left;\r\n-\t\t\t\tint y = getOffsetY(rowStartOffset, fontMetrics);\r\n-\t\t\t\tg.drawString(lineNumber, x, y);\r\n+\t\t\t\tif (lineNumber != null) {\r\n+\t\t\t\t\tif (isCurrentLine(rowStartOffset)) {\r\n+\t\t\t\t\t\tg.setColor(currentColor);\r\n+\t\t\t\t\t} else {\r\n+\t\t\t\t\t\tg.setColor(numberColor);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tint stringWidth = fontMetrics.stringWidth(lineNumber);\r\n+\t\t\t\t\tint x = availableWidth - stringWidth + insets.left;\r\n+\t\t\t\t\tint y = getOffsetY(rowStartOffset, fontMetrics);\r\n+\t\t\t\t\tg.drawString(lineNumber, x, y);\r\n+\t\t\t\t}\r\n \t\t\t\trowStartOffset = Utilities.getRowEnd(codeArea, rowStartOffset) + 1;\r\n \t\t\t} catch (Exception e) {\r\n+\t\t\t\tif (LOG.isDebugEnabled()) {\r\n+\t\t\t\t\tLOG.debug(\"Line numbers draw error\", e);\r\n+\t\t\t\t}\r\n \t\t\t\tbreak;\r\n \t\t\t}\r\n \t\t}\r\n@@ -140,22 +157,23 @@ private boolean isCurrentLine(int rowStartOffset) {\n \t\treturn root.getElementIndex(rowStartOffset) == root.getElementIndex(caretPosition);\r\n \t}\r\n \r\n+\t@Nullable\r\n \tprotected String getTextLineNumber(int rowStartOffset) {\r\n \t\tElement root = codeArea.getDocument().getDefaultRootElement();\r\n \t\tint index = root.getElementIndex(rowStartOffset);\r\n \t\tElement line = root.getElement(index);\r\n-\t\tif (line.getStartOffset() == rowStartOffset) {\r\n-\t\t\tint lineNumber = index + 1;\r\n-\t\t\tif (useSourceLines) {\r\n-\t\t\t\tInteger sourceLine = codeArea.getSourceLine(lineNumber);\r\n-\t\t\t\tif (sourceLine != null) {\r\n-\t\t\t\t\treturn String.valueOf(sourceLine);\r\n-\t\t\t\t}\r\n-\t\t\t} else {\r\n-\t\t\t\treturn String.valueOf(lineNumber);\r\n+\t\tif (line.getStartOffset() != rowStartOffset) {\r\n+\t\t\treturn null;\r\n+\t\t}\r\n+\t\tint lineNumber = index + 1;\r\n+\t\tif (useSourceLines) {\r\n+\t\t\tInteger sourceLine = codeArea.getSourceLine(lineNumber);\r\n+\t\t\tif (sourceLine == null) {\r\n+\t\t\t\treturn null;\r\n \t\t\t}\r\n+\t\t\treturn String.valueOf(sourceLine);\r\n \t\t}\r\n-\t\treturn \"\";\r\n+\t\treturn String.valueOf(lineNumber);\r\n \t}\r\n \r\n \tprivate int getOffsetY(int rowStartOffset, FontMetrics fontMetrics) throws BadLocationException {",
    "output": "Fix fill background before draw line numbers"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java\n@@ -518,6 +518,14 @@ public static boolean isClsKnown(RootNode root, ArgType cls) {\n \t\treturn false;\n \t}\n \n+\tpublic boolean canBeObject() {\n+\t\treturn isObject() || (!isTypeKnown() && contains(PrimitiveType.OBJECT));\n+\t}\n+\n+\tpublic boolean canBeArray() {\n+\t\treturn isArray() || (!isTypeKnown() && contains(PrimitiveType.ARRAY));\n+\t}\n+\n \tpublic static ArgType convertFromPrimitiveType(PrimitiveType primitiveType) {\n \t\tswitch (primitiveType) {\n \t\t\tcase BOOLEAN:\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n@@ -306,7 +306,18 @@ private TypeUpdateResult ifListener(TypeUpdateInfo updateInfo, InsnNode insn, In\n \t\tInsnArg firstArg = insn.getArg(0);\n \t\tInsnArg secondArg = insn.getArg(1);\n \t\tInsnArg updateArg = firstArg == arg ? secondArg : firstArg;\n-\t\treturn updateTypeChecked(updateInfo, updateArg, candidateType);\n+\t\tTypeUpdateResult result = updateTypeChecked(updateInfo, updateArg, candidateType);\n+\t\tif (result == REJECT) {\n+\t\t\t// soft checks for objects and array - exact type not compared\n+\t\t\tArgType updateArgType = updateArg.getType();\n+\t\t\tif (candidateType.isObject() && updateArgType.canBeObject()) {\n+\t\t\t\treturn SAME;\n+\t\t\t}\n+\t\t\tif (candidateType.isArray() && updateArgType.canBeArray()) {\n+\t\t\t\treturn SAME;\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n \t}\n \n \tprivate static boolean isAssign(InsnNode insn, InsnArg arg) {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestConstTypeInference.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestConstTypeInference.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestConstTypeInference.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestConstTypeInference.java\n@@ -0,0 +1,64 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.IntegrationTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.hamcrest.Matchers.anyOf;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestConstTypeInference extends IntegrationTest {\n+\n+\tpublic static class TestCls {\n+\t\tprivate final int a;\n+\n+\t\tpublic TestCls() {\n+\t\t\tthis(0);\n+\t\t}\n+\n+\t\tpublic TestCls(int a) {\n+\t\t\tthis.a = a;\n+\t\t}\n+\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (obj == this) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (obj != null) {\n+\t\t\t\tif (getClass() == obj.getClass()) {\n+\t\t\t\t\tTestCls other = (TestCls) obj;\n+\t\t\t\t\treturn this.a == other.a;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tpublic void check() {\n+\t\t\tTestCls seven = new TestCls(7);\n+\t\t\tassertEquals(seven, seven);\n+\t\t\tassertNotEquals(seven, null);\n+\n+\t\t\tTestCls six = new TestCls(6);\n+\t\t\tassertNotEquals(seven, six);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNode(TestCls.class);\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"obj == this\"));\n+\t\tassertThat(code, anyOf(containsOne(\"obj == null\"), containsOne(\"obj != null\")));\n+\t}\n+\n+\t@Test\n+\tpublic void test2() {\n+\t\tnoDebugInfo();\n+\t\tgetClassNode(TestCls.class);\n+\t}\n+}",
    "output": "Use soft checks for objects and arrays in 'if' type listener"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -55,9 +55,13 @@ public void visit(MethodNode mth) {\n \n \t\t// try all possible types if var type is still unknown\n \t\tmth.getSVars().forEach(var -> {\n-\t\t\tArgType type = var.getTypeInfo().getType();\n+\t\t\tTypeInfo typeInfo = var.getTypeInfo();\n+\t\t\tArgType type = typeInfo.getType();\n \t\t\tif (type != null && !type.isTypeKnown()) {\n-\t\t\t\ttryAllTypes(var, type);\n+\t\t\t\tboolean changed = tryAllTypes(var, type);\n+\t\t\t\tif (!changed) {\n+\t\t\t\t\tmth.addComment(\"JADX WARNING: type inference failed for: \" + var + \", bounds: \" + typeInfo.getBounds());\n+\t\t\t\t}\n \t\t\t}\n \t\t});\n \t}\n@@ -153,14 +157,15 @@ private ITypeBound makeUseBound(RegisterArg regArg) {\n \t\treturn new TypeBoundConst(BoundEnum.USE, regArg.getInitType());\n \t}\n \n-\tprivate void tryAllTypes(SSAVar var, ArgType type) {\n+\tprivate boolean tryAllTypes(SSAVar var, ArgType type) {\n \t\tList<ArgType> types = makePossibleTypesList(type);\n \t\tfor (ArgType candidateType : types) {\n \t\t\tTypeUpdateResult result = typeUpdate.apply(var, candidateType);\n \t\t\tif (result == TypeUpdateResult.CHANGED) {\n-\t\t\t\tbreak;\n+\t\t\t\treturn true;\n \t\t\t}\n \t\t}\n+\t\treturn false;\n \t}\n \n \tprivate List<ArgType> makePossibleTypesList(ArgType type) {",
    "output": "Fix show type inference errors as method comments"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java\n@@ -10,6 +10,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.core.Consts;\n import jadx.core.dex.instructions.IndexInsnNode;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.LiteralArg;\n@@ -67,7 +68,7 @@ private void setBestType(SSAVar ssaVar) {\n \t\t\tif (assignArg.isTypeImmutable()) {\n \t\t\t\tArgType initType = assignArg.getInitType();\n \t\t\t\tTypeUpdateResult result = typeUpdate.apply(ssaVar, initType);\n-\t\t\t\tif (result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {\n+\t\t\t\tif (Consts.DEBUG && result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {\n \t\t\t\t\tLOG.debug(\"Initial immutable type set rejected: {} -> {}\", ssaVar, initType);\n \t\t\t\t}\n \t\t\t} else {\n@@ -85,7 +86,7 @@ private void calculateFromBounds(SSAVar ssaVar) {\n \t\tif (bestTypeOpt.isPresent()) {\n \t\t\tArgType candidateType = bestTypeOpt.get();\n \t\t\tTypeUpdateResult result = typeUpdate.apply(ssaVar, candidateType);\n-\t\t\tif (result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {\n+\t\t\tif (Consts.DEBUG && result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {\n \t\t\t\tif (ssaVar.getTypeInfo().getType().equals(candidateType)) {\n \t\t\t\t\tLOG.warn(\"Same type rejected: {} -> {}, bounds: {}\", ssaVar, candidateType, bounds);\n \t\t\t\t} else {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java\n@@ -7,10 +7,10 @@\n import java.util.Set;\n \n import org.jetbrains.annotations.NotNull;\n-import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.core.Consts;\n import jadx.core.dex.instructions.InsnType;\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.InsnArg;\n@@ -81,7 +81,7 @@ private TypeUpdateResult updateTypeChecked(TypeUpdateInfo updateInfo, InsnArg ar\n \tprivate TypeUpdateResult updateTypeForSsaVar(TypeUpdateInfo updateInfo, SSAVar ssaVar, ArgType candidateType) {\n \t\tTypeInfo typeInfo = ssaVar.getTypeInfo();\n \t\tif (!inBounds(typeInfo.getBounds(), candidateType)) {\n-\t\t\tif (LOG.isDebugEnabled()) {\n+\t\t\tif (Consts.DEBUG && LOG.isDebugEnabled()) {\n \t\t\t\tLOG.debug(\"Reject type '{}' for {} by bounds: {}\", candidateType, ssaVar, typeInfo.getBounds());\n \t\t\t}\n \t\t\treturn REJECT;\n@@ -153,7 +153,6 @@ private boolean inBounds(Set<ITypeBound> bounds, ArgType candidateType) {\n \t\treturn true;\n \t}\n \n-\t@Nullable\n \tprivate boolean checkBound(ArgType candidateType, ITypeBound bound, ArgType boundType) {\n \t\tTypeCompareEnum compareResult = comparator.compareTypes(candidateType, boundType);\n \t\tswitch (compareResult) {\n@@ -166,9 +165,7 @@ private boolean checkBound(ArgType candidateType, ITypeBound bound, ArgType boun\n \n \t\t\tcase NARROW:\n \t\t\t\tif (bound.getBound() == BoundEnum.ASSIGN) {\n-\t\t\t\t\tif (boundType.isTypeKnown() || !checkAssignForUnknown(boundType, candidateType)) {\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t\t}\n+\t\t\t\t\treturn !boundType.isTypeKnown() && checkAssignForUnknown(boundType, candidateType);\n \t\t\t\t}\n \t\t\t\treturn true;",
    "output": "Fix hide debug type inference logs"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java\n@@ -22,6 +22,7 @@\n import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;\n import jadx.core.utils.InstructionRemover;\n import jadx.core.utils.exceptions.JadxException;\n+import jadx.core.utils.exceptions.JadxOverflowException;\n \n @JadxVisitor(\n \t\tname = \"Constants Inline\",\n@@ -40,21 +41,23 @@ public void visit(MethodNode mth) throws JadxException {\n \t\tfor (BlockNode block : mth.getBasicBlocks()) {\n \t\t\ttoRemove.clear();\n \t\t\tfor (InsnNode insn : block.getInstructions()) {\n-\t\t\t\tif (checkInsn(mth, insn)) {\n-\t\t\t\t\ttoRemove.add(insn);\n-\t\t\t\t}\n+\t\t\t\tcheckInsn(mth, insn, toRemove);\n \t\t\t}\n \t\t\tInstructionRemover.removeAll(mth, block, toRemove);\n \t\t}\n \t}\n \n-\tprivate static boolean checkInsn(MethodNode mth, InsnNode insn) {\n-\t\tif (insn.getType() != InsnType.CONST || insn.contains(AFlag.DONT_INLINE)) {\n-\t\t\treturn false;\n+\tprivate static void checkInsn(MethodNode mth, InsnNode insn, List<InsnNode> toRemove) {\n+\t\tif (insn.contains(AFlag.DONT_INLINE)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tInsnType insnType = insn.getType();\n+\t\tif (insnType != InsnType.CONST && insnType != InsnType.MOVE) {\n+\t\t\treturn;\n \t\t}\n \t\tInsnArg arg = insn.getArg(0);\n \t\tif (!arg.isLiteral()) {\n-\t\t\treturn false;\n+\t\t\treturn;\n \t\t}\n \t\tlong lit = ((LiteralArg) arg).getLiteral();\n \n@@ -66,9 +69,9 @@ private static boolean checkInsn(MethodNode mth, InsnNode insn) {\n \t\t\t\t\tassignInsn.add(AFlag.DONT_INLINE);\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn false;\n+\t\t\treturn;\n \t\t}\n-\t\treturn replaceConst(mth, insn, lit);\n+\t\treplaceConst(mth, insn, lit, toRemove);\n \t}\n \n \t/**\n@@ -98,54 +101,60 @@ private static boolean checkObjectInline(SSAVar sVar) {\n \t\treturn false;\n \t}\n \n-\tprivate static boolean replaceConst(MethodNode mth, InsnNode constInsn, long literal) {\n-\t\tSSAVar sVar = constInsn.getResult().getSVar();\n-\t\tList<RegisterArg> use = new ArrayList<>(sVar.getUseList());\n+\tprivate static void replaceConst(MethodNode mth, InsnNode constInsn, long literal, List<InsnNode> toRemove) {\n+\t\tSSAVar ssaVar = constInsn.getResult().getSVar();\n+\t\tList<RegisterArg> useList = new ArrayList<>(ssaVar.getUseList());\n \t\tint replaceCount = 0;\n-\t\tfor (RegisterArg arg : use) {\n-\t\t\tInsnNode useInsn = arg.getParentInsn();\n-\t\t\tif (useInsn == null\n-\t\t\t\t\t|| useInsn.getType() == InsnType.PHI\n-\t\t\t\t\t|| useInsn.getType() == InsnType.MERGE\n-\t\t\t) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tLiteralArg litArg;\n-\t\t\tArgType argType = arg.getType();\n-\t\t\tif (argType.isObject() && literal != 0) {\n-\t\t\t\targType = ArgType.NARROW_NUMBERS;\n-\t\t\t}\n-\t\t\tif (use.size() == 1 || arg.isTypeImmutable()) {\n-\t\t\t\t// arg used only in one place\n-\t\t\t\tlitArg = InsnArg.lit(literal, argType);\n-\t\t\t} else if (useInsn.getType() == InsnType.MOVE\n-\t\t\t\t\t&& !useInsn.getResult().getType().isTypeKnown()) {\n-\t\t\t\t// save type for 'move' instructions (hard to find type in chains of 'move')\n-\t\t\t\tlitArg = InsnArg.lit(literal, argType);\n-\t\t\t} else {\n-\t\t\t\t// in most cases type not equal arg.getType()\n-\t\t\t\t// just set unknown type and run type fixer\n-\t\t\t\tlitArg = InsnArg.lit(literal, ArgType.UNKNOWN);\n-\t\t\t}\n-\t\t\tif (useInsn.replaceArg(arg, litArg)) {\n-\t\t\t\tlitArg.setType(arg.getInitType());\n+\t\tfor (RegisterArg arg : useList) {\n+\t\t\tif (replaceArg(mth, arg, literal, constInsn, toRemove)) {\n \t\t\t\treplaceCount++;\n-\t\t\t\tif (useInsn.getType() == InsnType.RETURN) {\n-\t\t\t\t\tuseInsn.setSourceLine(constInsn.getSourceLine());\n-\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (replaceCount == useList.size()) {\n+\t\t\ttoRemove.add(constInsn);\n+\t\t}\n+\t}\n \n-\t\t\t\tFieldNode f = null;\n-\t\t\t\tArgType litArgType = litArg.getType();\n-\t\t\t\tif (litArgType.isTypeKnown()) {\n-\t\t\t\t\tf = mth.getParentClass().getConstFieldByLiteralArg(litArg);\n-\t\t\t\t} else if (litArgType.contains(PrimitiveType.INT)) {\n-\t\t\t\t\tf = mth.getParentClass().getConstField((int) literal, false);\n-\t\t\t\t}\n-\t\t\t\tif (f != null) {\n-\t\t\t\t\tlitArg.wrapInstruction(new IndexInsnNode(InsnType.SGET, f.getFieldInfo(), 0));\n-\t\t\t\t}\n+\tprivate static boolean replaceArg(MethodNode mth, RegisterArg arg, long literal, InsnNode constInsn, List<InsnNode> toRemove) {\n+\t\tInsnNode useInsn = arg.getParentInsn();\n+\t\tif (useInsn == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tInsnType insnType = useInsn.getType();\n+\t\tif (insnType == InsnType.PHI || insnType == InsnType.MERGE) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tArgType argType = arg.getInitType();\n+\t\tif (argType.isObject() && literal != 0) {\n+\t\t\targType = ArgType.NARROW_NUMBERS;\n+\t\t}\n+\t\tLiteralArg litArg = InsnArg.lit(literal, argType);\n+\t\tif (!useInsn.replaceArg(arg, litArg)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// arg replaced, made some optimizations\n+\t\tlitArg.setType(arg.getInitType());\n+\n+\t\tFieldNode fieldNode = null;\n+\t\tArgType litArgType = litArg.getType();\n+\t\tif (litArgType.isTypeKnown()) {\n+\t\t\tfieldNode = mth.getParentClass().getConstFieldByLiteralArg(litArg);\n+\t\t} else if (litArgType.contains(PrimitiveType.INT)) {\n+\t\t\tfieldNode = mth.getParentClass().getConstField((int) literal, false);\n+\t\t}\n+\t\tif (fieldNode != null) {\n+\t\t\tlitArg.wrapInstruction(new IndexInsnNode(InsnType.SGET, fieldNode.getFieldInfo(), 0));\n+\t\t}\n+\n+\t\tif (insnType == InsnType.RETURN) {\n+\t\t\tuseInsn.setSourceLine(constInsn.getSourceLine());\n+\t\t} else if (insnType == InsnType.MOVE) {\n+\t\t\ttry {\n+\t\t\t\treplaceConst(mth, useInsn, literal, toRemove);\n+\t\t\t} catch (StackOverflowError e) {\n+\t\t\t\tthrow new JadxOverflowException(\"Stack overflow at const inline visitor\");\n \t\t\t}\n \t\t}\n-\t\treturn replaceCount == use.size();\n+\t\treturn true;\n \t}\n }\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java\n@@ -24,6 +24,10 @@ protected ClassNode getClassNodeFromSmaliWithPath(String path, String clsName) {\n \t\treturn getClassNodeFromSmali(path + File.separatorChar + clsName, clsName);\n \t}\n \n+\tprotected ClassNode getClassNodeFromSmaliWithPkg(String pkg, String clsName) {\n+\t\treturn getClassNodeFromSmali(pkg + File.separatorChar + clsName, pkg + '.' + clsName);\n+\t}\n+\n \tprotected ClassNode getClassNodeFromSmali(String clsName) {\n \t\treturn getClassNodeFromSmali(clsName, clsName);\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/types/TestConstInline.java b/jadx-core/src/test/java/jadx/tests/integration/types/TestConstInline.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/types/TestConstInline.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestConstInline.java\n@@ -0,0 +1,38 @@\n+package jadx.tests.integration.types;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestConstInline extends SmaliTest {\n+\n+//\t\tprivate static String test(boolean b) {\n+//\t\t\tList<String> list;\n+//\t\t\tString str;\n+//\t\t\tif (b) {\n+//\t\t\t\tlist = Collections.emptyList();\n+//\t\t\t\tstr = \"1\";\n+//\t\t\t} else {\n+//\t\t\t\tlist = null;\n+//\t\t\t\tstr = list; // not correct assign in java but bytecode allow it\n+//\t\t\t}\n+//\t\t\treturn use(list, str);\n+//\t\t}\n+//\n+//\t\tprivate static String use(List<String> list, String str) {\n+//\t\t\treturn list + str;\n+//\t\t}\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmaliWithPkg(\"types\", \"TestConstInline\");\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, containsOne(\"list = null;\"));\n+\t\tassertThat(code, containsOne(\"str = null;\"));\n+\t}\n+}",
    "output": "Fix inline constants in chained move instructions"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInference.java b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInference.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInference.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInference.java\n@@ -56,11 +56,13 @@ private static ArgType processType(DexNode dex, SSAVar var) {\n \t\t}\n \t\tArgType type = assign.getType();\n \t\tfor (RegisterArg arg : useList) {\n-\t\t\tArgType useType = arg.getType();\n-\t\t\tArgType newType = ArgType.merge(dex, type, useType);\n-\t\t\tif (newType != null) {\n-\t\t\t\ttype = newType;\n-\t\t\t}\n+\t\t    ArgType useType = arg.getType();\n+            if (!type.isTypeKnown() || !useType.isTypeKnown()) {\n+                ArgType newType = ArgType.merge(dex, type, useType);\n+                if (newType != null) {\n+                    type = newType;\n+                }\n+            }\n \t\t}\n \t\treturn type;\n \t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrays4.java b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrays4.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrays4.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrays4.java\n@@ -0,0 +1,34 @@\n+package jadx.tests.integration.arrays;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+import static jadx.tests.api.utils.JadxMatchers.containsOne;\n+import static org.junit.Assert.assertThat;\n+import org.junit.Test;\n+\n+public class TestArrays4 extends SmaliTest {\n+\n+    public static class TestCls {\n+        char[] payload;\n+\n+        public TestCls(byte[] bytes) {\n+            char[] a = toChars(bytes);\n+            this.payload = new char[a.length];\n+            System.arraycopy(a, 0, this.payload, 0, bytes.length);\n+        }\n+\n+        private static char[] toChars(byte[] bArr) {\n+            return new char[bArr.length];\n+        }\n+    }\n+\n+    @Test\n+    public void testArrayTypeInference() {\n+        noDebugInfo();\n+        ClassNode cls = getClassNode(TestCls.class);\n+        String code = cls.getCode().toString();\n+\n+        assertThat(code, containsOne(\"char[] toChars = toChars(bArr);\"));\n+    }\n+\n+}",
    "output": "Fix return type lost after type inference"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java\n@@ -285,6 +285,7 @@ public boolean isDeepEquals(InsnNode other) {\n \t\t\treturn true;\n \t\t}\n \t\treturn isSame(other)\n+\t\t\t\t&& Objects.equals(result, other.result)\n \t\t\t\t&& Objects.equals(arguments, other.arguments);\n \t}",
    "output": "Fix instruction deep equals must check result"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n@@ -42,7 +42,8 @@ public boolean visit(ClassNode cls) throws JadxException {\n \t\t}\n \t\tif (cls.getAccessFlags().isSynthetic()\n \t\t\t\t&& cls.getFields().isEmpty()\n-\t\t\t\t&& cls.getMethods().isEmpty()) {\n+\t\t\t\t&& cls.getMethods().isEmpty()\n+\t\t\t\t&& cls.getInnerClasses().isEmpty()) {\n \t\t\tcls.add(AFlag.DONT_GENERATE);\n \t\t\treturn false;\n \t\t}",
    "output": "Fix don't remove synthetic class with inner classes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java\n@@ -1,6 +1,7 @@\n package jadx.core.dex.visitors;\n \n import java.util.List;\n+import java.util.Objects;\n \n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.attributes.AType;\n@@ -216,16 +217,23 @@ private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {\n \t\t\tMethodInfo callMth = ((InvokeNode) insn).getCallMth();\n \t\t\tMethodNode wrappedMth = mth.root().deepResolveMethod(callMth);\n \t\t\tif (wrappedMth != null) {\n+\t\t\t\tif (callMth.getArgsCount() != mth.getMethodInfo().getArgsCount()) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n \t\t\t\t// all args must be registers passed from method args (allow only casts insns)\n \t\t\t\tfor (InsnArg arg : insn.getArguments()) {\n \t\t\t\t\tif (!registersAndCastsOnly(arg)) {\n \t\t\t\t\t\treturn false;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tString alias = mth.getAlias();\n-\t\t\t\tif (!wrappedMth.getAlias().equals(alias) && wrappedMth.isVirtual()) {\n-\t\t\t\t\twrappedMth.getMethodInfo().setAlias(alias);\n+\t\t\t\tif (Objects.equals(wrappedMth.getAlias(), alias)) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t\tif (!wrappedMth.isVirtual()) {\n+\t\t\t\t\treturn false;\n \t\t\t\t}\n+\t\t\t\twrappedMth.getMethodInfo().setAlias(alias);\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}",
    "output": "Fix don't remove synthetic method if args count or name not same"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -340,7 +340,7 @@ public void actionPerformed(ActionEvent e) {\n \t\t\t\topenFile();\n \t\t\t}\n \t\t};\n-\t\topenAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"file.open\"));\n+\t\topenAction.putValue(Action.SHORT_DESCRIPTION, NLS.str(\"file.open_action\"));\n \t\topenAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_O, KeyEvent.CTRL_DOWN_MASK));\n \n \t\tAction saveAllAction = new AbstractAction(NLS.str(\"file.save_all\"), ICON_SAVE_ALL) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/NLS.java b/jadx-gui/src/main/java/jadx/gui/utils/NLS.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/NLS.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/NLS.java\n@@ -1,102 +1,99 @@\n-package jadx.gui.utils;\n-\n-import java.nio.charset.Charset;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.ResourceBundle;\n-import java.util.Vector;\n-\n-import org.jetbrains.annotations.NotNull;\n-\n-public class NLS {\n-\tprivate static final Charset JAVA_CHARSET = Charset.forName(\"ISO-8859-1\");\n-\tprivate static final Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n-\n-\tprivate static Vector<LangLocale> i18nLocales = new Vector<>();\n-\n-\tprivate static Map<LangLocale, Map<String, String>> i18nMessagesMap = new HashMap<>();\n-\n-\t// Use these two fields to avoid invoking Map.get() method twice.\n-\tprivate static Map<String, String> localizedMessagesMap;\n-\tprivate static Map<String, String> fallbackMessagesMap;\n-\n-\tprivate static LangLocale currentLocale;\n-\tprivate static LangLocale localLocale;\n-\n-\tstatic {\n-\t\tlocalLocale = new LangLocale(Locale.getDefault());\n-\n-\t\ti18nLocales.add(new LangLocale(\"en\", \"US\")); // As default language\n-\t\ti18nLocales.add(new LangLocale(\"zh\", \"CN\"));\n-\t\ti18nLocales.add(new LangLocale(\"es\", \"ES\"));\n-\n-\t\ti18nLocales.forEach(NLS::load);\n-\n-\t\tLangLocale defLang = i18nLocales.get(0);\n-\t\tfallbackMessagesMap = i18nMessagesMap.get(defLang);\n-\t\tlocalizedMessagesMap = i18nMessagesMap.get(defLang);\n-\t}\n-\n-\tprivate NLS() {\n-\t}\n-\n-\tprivate static void load(LangLocale locale) {\n-\t\tResourceBundle bundle = ResourceBundle.getBundle(\"i18n/Messages\", locale.get());\n-\t\tMap<String, String> resMap = new HashMap<>();\n-\t\tfor (String key : bundle.keySet()) {\n-\t\t\tString str = bundle.getString(key);\n-\t\t\tresMap.put(key, convertCharset(str));\n-\t\t}\n-\t\ti18nMessagesMap.put(locale, resMap);\n-\t}\n-\n-\t@NotNull\n-\tprivate static String convertCharset(String str) {\n-\t\treturn new String(str.getBytes(JAVA_CHARSET), UTF8_CHARSET);\n-\t}\n-\n-\tpublic static String str(String key) {\n-\t\tString str = localizedMessagesMap.get(key);\n-\t\tif (str != null) {\n-\t\t\treturn str;\n-\t\t}\n-\t\treturn fallbackMessagesMap.get(key); // definitely exists\n-\t}\n-\n-\tpublic static String str(String key, LangLocale locale) {\n-\t\tMap<String, String> strings = i18nMessagesMap.get(locale);\n-\t\tif (strings != null) {\n-\t\t\tString str = strings.get(key);\n-\t\t\tif (str != null) {\n-\t\t\t\treturn str;\n-\t\t\t}\n-\t\t}\n-\t\treturn fallbackMessagesMap.get(key); // definitely exists\n-\t}\n-\n-\tpublic static void setLocale(LangLocale locale) {\n-\t\tif (i18nMessagesMap.containsKey(locale)) {\n-\t\t\tcurrentLocale = locale;\n-\t\t} else {\n-\t\t\tcurrentLocale = i18nLocales.get(0);\n-\t\t}\n-\t\tlocalizedMessagesMap = i18nMessagesMap.get(currentLocale);\n-\t}\n-\n-\tpublic static Vector<LangLocale> getI18nLocales() {\n-\t\treturn i18nLocales;\n-\t}\n-\n-\tpublic static LangLocale currentLocale() {\n-\t\treturn currentLocale;\n-\t}\n-\n-\tpublic static LangLocale defaultLocale() {\n-\t\tif (i18nMessagesMap.containsKey(localLocale)) {\n-\t\t\treturn localLocale;\n-\t\t}\n-\t\t// fallback to english if unsupported\n-\t\treturn i18nLocales.get(0);\n-\t}\n-}\n+package jadx.gui.utils;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.Reader;\r\n+import java.net.URL;\r\n+import java.nio.charset.Charset;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.util.*;\r\n+\r\n+import org.jetbrains.annotations.NotNull;\r\n+\r\n+public class NLS {\r\n+\r\n+\tprivate static Vector<LangLocale> i18nLocales = new Vector<>();\r\n+\r\n+\tprivate static Map<LangLocale, ResourceBundle> i18nMessagesMap = new HashMap<>();\r\n+\r\n+\t// Use these two fields to avoid invoking Map.get() method twice.\r\n+\tprivate static ResourceBundle localizedMessagesMap;\r\n+\tprivate static ResourceBundle fallbackMessagesMap;\r\n+\r\n+\tprivate static LangLocale currentLocale;\r\n+\tprivate static LangLocale localLocale;\r\n+\r\n+\tstatic {\r\n+\t\tlocalLocale = new LangLocale(Locale.getDefault());\r\n+\r\n+\t\ti18nLocales.add(new LangLocale(\"en\", \"US\")); // As default language\r\n+\t\ti18nLocales.add(new LangLocale(\"zh\", \"CN\"));\r\n+\t\ti18nLocales.add(new LangLocale(\"es\", \"ES\"));\r\n+\r\n+\t\ti18nLocales.forEach(NLS::load);\r\n+\r\n+\t\tLangLocale defLang = i18nLocales.get(0);\r\n+\t\tfallbackMessagesMap = i18nMessagesMap.get(defLang);\r\n+\t\tlocalizedMessagesMap = i18nMessagesMap.get(defLang);\r\n+\t}\r\n+\r\n+\tprivate NLS() {\r\n+\t}\r\n+\r\n+\tprivate static void load(LangLocale locale) {\r\n+\t\tResourceBundle bundle;\r\n+\t\tClassLoader classLoader = ClassLoader.getSystemClassLoader();\r\n+\t\tString resName = String.format(\"i18n/Messages_%s.properties\", locale.get());\r\n+\t\tURL bundleUrl = classLoader.getResource(resName);\r\n+\t\ttry (Reader reader = new InputStreamReader(bundleUrl.openStream(), StandardCharsets.UTF_8)) {\r\n+\t\t\tbundle = new PropertyResourceBundle(reader);\r\n+\t\t} catch (IOException e) {\r\n+\t\t\tthrow new RuntimeException(\"Failed to load \" + resName, e);\r\n+\t\t}\r\n+\t\ti18nMessagesMap.put(locale, bundle);\r\n+\t}\r\n+\r\n+\tpublic static String str(String key) {\r\n+\t\ttry {\r\n+\t\t\treturn localizedMessagesMap.getString(key);\r\n+\t\t} catch (MissingResourceException e) {\r\n+\t\t\treturn fallbackMessagesMap.getString(key); // definitely exists\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tpublic static String str(String key, LangLocale locale) {\r\n+\t\tResourceBundle bundle = i18nMessagesMap.get(locale);\r\n+\t\tif (bundle != null) {\r\n+\t\t\ttry {\r\n+\t\t\t\treturn bundle.getString(key);\r\n+\t\t\t} catch (MissingResourceException e) {\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn fallbackMessagesMap.getString(key); // definitely exists\r\n+\t}\r\n+\r\n+\tpublic static void setLocale(LangLocale locale) {\r\n+\t\tif (i18nMessagesMap.containsKey(locale)) {\r\n+\t\t\tcurrentLocale = locale;\r\n+\t\t} else {\r\n+\t\t\tcurrentLocale = i18nLocales.get(0);\r\n+\t\t}\r\n+\t\tlocalizedMessagesMap = i18nMessagesMap.get(currentLocale);\r\n+\t}\r\n+\r\n+\tpublic static Vector<LangLocale> getI18nLocales() {\r\n+\t\treturn i18nLocales;\r\n+\t}\r\n+\r\n+\tpublic static LangLocale currentLocale() {\r\n+\t\treturn currentLocale;\r\n+\t}\r\n+\r\n+\tpublic static LangLocale defaultLocale() {\r\n+\t\tif (i18nMessagesMap.containsKey(localLocale)) {\r\n+\t\t\treturn localLocale;\r\n+\t\t}\r\n+\t\t// fallback to english if unsupported\r\n+\t\treturn i18nLocales.get(0);\r\n+\t}\r\n+}",
    "output": "Fix loading of i18n resources as UTF-8 (see #363)"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -47,7 +47,10 @@ public class JadxSettings extends JadxCLIArgs {\n \n \tprivate Map<String, WindowLocation> windowPos = new HashMap<>();\n \n-\tpublic JadxSettings() {\n+\tpublic static JadxSettings makeDefault() {\n+\t\tJadxSettings jadxSettings = new JadxSettings();\n+\t\tjadxSettings.fixOnLoad();\n+\t\treturn jadxSettings;\n \t}\n \n \tpublic void sync() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java\n@@ -46,10 +46,13 @@ public static JadxSettings load() {\n \t\t\tJadxSettings settings = fromString(jsonSettings);\n \t\t\tif (settings == null) {\n \t\t\t\tLOG.debug(\"Created new settings.\");\n-\t\t\t\tsettings = new JadxSettings();\n+\t\t\t\tsettings = JadxSettings.makeDefault();\n+\t\t\t} else {\n+\t\t\t\tsettings.fixOnLoad();\n+\t\t\t}\n+\t\t\tif (LOG.isDebugEnabled()) {\n+\t\t\t\tLOG.debug(\"Loaded settings: {}\", makeString(settings));\n \t\t\t}\n-\t\t\tsettings.fixOnLoad();\n-\t\t\tLOG.debug(\"Loaded settings: {}\", makeString(settings));\n \t\t\treturn settings;\n \t\t} catch (Exception e) {\n \t\t\tLOG.error(\"Error load settings\", e);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -12,8 +12,8 @@\n import org.slf4j.LoggerFactory;\n import say.swing.JFontChooser;\n \n-import jadx.gui.ui.codearea.EditorTheme;\n import jadx.gui.ui.MainWindow;\n+import jadx.gui.ui.codearea.EditorTheme;\n import jadx.gui.utils.LangLocale;\n import jadx.gui.utils.NLS;\n \n@@ -94,7 +94,7 @@ private void initUI() {\n \t\t\t\t\tNLS.str(\"preferences.reset_title\"),\n \t\t\t\t\tJOptionPane.YES_NO_OPTION);\n \t\t\tif (res == JOptionPane.YES_OPTION) {\n-\t\t\t\tString defaults = JadxSettingsAdapter.makeString(new JadxSettings());\n+\t\t\t\tString defaults = JadxSettingsAdapter.makeString(JadxSettings.makeDefault());\n \t\t\t\tJadxSettingsAdapter.fill(settings, defaults);\n \t\t\t\tgetContentPane().removeAll();\n \t\t\t\tinitUI();",
    "output": "Fix on settings reset run upgrade method"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/ISettingsUpdater.java b/jadx-gui/src/main/java/jadx/gui/settings/ISettingsUpdater.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/ISettingsUpdater.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/ISettingsUpdater.java\n@@ -0,0 +1,5 @@\n+package jadx.gui.settings;\n+\n+public interface ISettingsUpdater {\n+\tvoid update(JadxSettings settings);\n+}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -54,6 +54,12 @@ public void sync() {\n \t\tJadxSettingsAdapter.store(this);\n \t}\n \n+\tpublic void partialSync(ISettingsUpdater updater) {\n+\t\tJadxSettings settings = JadxSettingsAdapter.load();\n+\t\tupdater.update(settings);\n+\t\tJadxSettingsAdapter.store(settings);\n+\t}\n+\n \tpublic void fixOnLoad() {\n \t\tif (threadsCount <= 0) {\n \t\t\tthreadsCount = JadxArgs.DEFAULT_THREADS_COUNT;\n@@ -75,7 +81,7 @@ public String getLastOpenFilePath() {\n \n \tpublic void setLastOpenFilePath(String lastOpenFilePath) {\n \t\tthis.lastOpenFilePath = lastOpenFilePath;\n-\t\tsync();\n+\t\tpartialSync(settings -> settings.lastOpenFilePath = JadxSettings.this.lastOpenFilePath);\n \t}\n \n \tpublic String getLastSaveFilePath() {\n@@ -84,7 +90,7 @@ public String getLastSaveFilePath() {\n \n \tpublic void setLastSaveFilePath(String lastSaveFilePath) {\n \t\tthis.lastSaveFilePath = lastSaveFilePath;\n-\t\tsync();\n+\t\tpartialSync(settings -> settings.lastSaveFilePath = JadxSettings.this.lastSaveFilePath);\n \t}\n \n \tpublic boolean isFlattenPackage() {\n@@ -93,7 +99,7 @@ public boolean isFlattenPackage() {\n \n \tpublic void setFlattenPackage(boolean flattenPackage) {\n \t\tthis.flattenPackage = flattenPackage;\n-\t\tsync();\n+\t\tpartialSync(settings -> settings.flattenPackage = JadxSettings.this.flattenPackage);\n \t}\n \n \tpublic boolean isCheckForUpdates() {\n@@ -116,7 +122,7 @@ public void addRecentFile(String filePath) {\n \t\tif (count > RECENT_FILES_COUNT) {\n \t\t\trecentFiles.subList(RECENT_FILES_COUNT, count).clear();\n \t\t}\n-\t\tsync();\n+\t\tpartialSync(settings -> settings.recentFiles = recentFiles);\n \t}\n \n \tpublic void saveWindowPos(Window window) {\n@@ -125,7 +131,7 @@ public void saveWindowPos(Window window) {\n \t\t\t\twindow.getWidth(), window.getHeight()\n \t\t);\n \t\twindowPos.put(pos.getWindowId(), pos);\n-\t\tsync();\n+\t\tpartialSync(settings -> settings.windowPos = windowPos);\n \t}\n \n \tpublic boolean loadWindowPos(Window window) {",
    "output": "Fix allow partial settings sync to not save command line options"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -341,7 +341,7 @@ private void insertDecompilationProblems(CodeWriter code, AttrNode node) {\n \t\t\t});\n \t\t}\n \t\tif (!warns.isEmpty()) {\n-\t\t\twarns.forEach(warn -> code.startLine(\"/* JADX WARNING: \").add(warn.getWarn()).add(\" */\"));\n+\t\t\twarns.forEach(warn -> code.startLine(\"/* JADX WARNING: \").addMultiLine(warn.getWarn()).add(\" */\"));\n \t\t}\n \t}",
    "output": "Fix correct code line number calculation"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n--- a/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java\n@@ -0,0 +1,105 @@\n+package jadx.cli;\n+\n+import java.io.PrintStream;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.ParameterDescription;\n+import com.beust.jcommander.ParameterException;\n+import com.beust.jcommander.Parameterized;\n+\n+import jadx.api.JadxDecompiler;\n+\n+public class JCommanderWrapper<T> {\n+\tprivate final JCommander jc;\n+\n+\tpublic JCommanderWrapper(T obj) {\n+\t\tthis.jc = JCommander.newBuilder().addObject(obj).build();\n+\t}\n+\n+\tpublic boolean parse(String[] args) {\n+\t\ttry {\n+\t\t\tjc.parse(args);\n+\t\t\treturn true;\n+\t\t} catch (ParameterException e) {\n+\t\t\tSystem.err.println(\"Arguments parse error: \" + e.getMessage());\n+\t\t\tprintUsage();\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tpublic void overrideProvided(T obj) {\n+\t\tList<ParameterDescription> fieldsParams = jc.getParameters();\n+\t\tList<ParameterDescription> parameters = new ArrayList<>(1 + fieldsParams.size());\n+\t\tparameters.add(jc.getMainParameterValue());\n+\t\tparameters.addAll(fieldsParams);\n+\t\tfor (ParameterDescription parameter : parameters) {\n+\t\t\tif (parameter.isAssigned()) {\n+\t\t\t\t// copy assigned field value to obj\n+\t\t\t\tParameterized parameterized = parameter.getParameterized();\n+\t\t\t\tObject val = parameterized.get(parameter.getObject());\n+\t\t\t\tparameterized.set(obj, val);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void printUsage() {\n+\t\t// print usage in not sorted fields order (by default its sorted by description)\n+\t\tPrintStream out = System.out;\n+\t\tout.println();\n+\t\tout.println(\"jadx - dex to java decompiler, version: \" + JadxDecompiler.getVersion());\n+\t\tout.println();\n+\t\tout.println(\"usage: jadx [options] \" + jc.getMainParameterDescription());\n+\t\tout.println(\"options:\");\n+\n+\t\tList<ParameterDescription> params = jc.getParameters();\n+\t\tMap<String, ParameterDescription> paramsMap = new LinkedHashMap<>(params.size());\n+\t\tint maxNamesLen = 0;\n+\t\tfor (ParameterDescription p : params) {\n+\t\t\tparamsMap.put(p.getParameterized().getName(), p);\n+\t\t\tint len = p.getNames().length();\n+\t\t\tif (len > maxNamesLen) {\n+\t\t\t\tmaxNamesLen = len;\n+\t\t\t}\n+\t\t}\n+\t\tJadxCLIArgs args = new JadxCLIArgs();\n+\t\tField[] fields = args.getClass().getDeclaredFields();\n+\t\tfor (Field f : fields) {\n+\t\t\tString name = f.getName();\n+\t\t\tParameterDescription p = paramsMap.get(name);\n+\t\t\tif (p == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tStringBuilder opt = new StringBuilder();\n+\t\t\topt.append(\"  \").append(p.getNames());\n+\t\t\taddSpaces(opt, maxNamesLen - opt.length() + 3);\n+\t\t\topt.append(\"- \").append(p.getDescription());\n+\t\t\taddDefaultValue(args, f, opt);\n+\t\t\tout.println(opt);\n+\t\t}\n+\t\tout.println(\"Example:\");\n+\t\tout.println(\"  jadx -d out classes.dex\");\n+\t}\n+\n+\tprivate void addDefaultValue(JadxCLIArgs args, Field f, StringBuilder opt) {\n+\t\tClass<?> fieldType = f.getType();\n+\t\tif (fieldType == int.class) {\n+\t\t\ttry {\n+\t\t\t\tint val = f.getInt(args);\n+\t\t\t\topt.append(\" (default: \").append(val).append(\")\");\n+\t\t\t} catch (Exception e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static void addSpaces(StringBuilder str, int count) {\n+\t\tfor (int i = 0; i < count; i++) {\n+\t\t\tstr.append(' ');\n+\t\t}\n+\t}\n+}\n\ndiff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n@@ -1,19 +1,12 @@\n package jadx.cli;\n \n-import java.io.PrintStream;\n-import java.lang.reflect.Field;\n import java.util.ArrayList;\n-import java.util.LinkedHashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.stream.Collectors;\n \n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.Appender;\n-import com.beust.jcommander.JCommander;\n import com.beust.jcommander.Parameter;\n-import com.beust.jcommander.ParameterDescription;\n-import com.beust.jcommander.ParameterException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -94,27 +87,26 @@ public class JadxCLIArgs {\n \tprotected boolean printHelp = false;\n \n \tpublic boolean processArgs(String[] args) {\n-\t\treturn parse(args) && process();\n+\t\tJCommanderWrapper<JadxCLIArgs> jcw = new JCommanderWrapper<>(this);\n+\t\treturn jcw.parse(args) && process(jcw);\n \t}\n \n-\tprivate boolean parse(String[] args) {\n-\t\ttry {\n-\t\t\tmakeJCommander().parse(args);\n-\t\t\treturn true;\n-\t\t} catch (ParameterException e) {\n-\t\t\tSystem.err.println(\"Arguments parse error: \" + e.getMessage());\n-\t\t\tprintUsage();\n+\t/**\n+\t * Set values only for options provided in cmd.\n+\t * Used to merge saved options and options passed in command line.\n+\t */\n+\tpublic boolean overrideProvided(String[] args) {\n+\t\tJCommanderWrapper<JadxCLIArgs> jcw = new JCommanderWrapper<>(new JadxCLIArgs());\n+\t\tif (!jcw.parse(args)) {\n \t\t\treturn false;\n \t\t}\n+\t\tjcw.overrideProvided(this);\n+\t\treturn process(jcw);\n \t}\n \n-\tprivate JCommander makeJCommander() {\n-\t\treturn JCommander.newBuilder().addObject(this).build();\n-\t}\n-\n-\tprivate boolean process() {\n+\tprivate boolean process(JCommanderWrapper jcw) {\n \t\tif (printHelp) {\n-\t\t\tprintUsage();\n+\t\t\tjcw.printUsage();\n \t\t\treturn false;\n \t\t}\n \t\tif (printVersion) {\n@@ -136,69 +128,12 @@ private boolean process() {\n \t\t\t}\n \t\t} catch (JadxException e) {\n \t\t\tSystem.err.println(\"ERROR: \" + e.getMessage());\n-\t\t\tprintUsage();\n+\t\t\tjcw.printUsage();\n \t\t\treturn false;\n \t\t}\n \t\treturn true;\n \t}\n \n-\tpublic void printUsage() {\n-\t\tJCommander jc = makeJCommander();\n-\t\t// print usage in not sorted fields order (by default its sorted by description)\n-\t\tPrintStream out = System.out;\n-\t\tout.println();\n-\t\tout.println(\"jadx - dex to java decompiler, version: \" + JadxDecompiler.getVersion());\n-\t\tout.println();\n-\t\tout.println(\"usage: jadx [options] \" + jc.getMainParameterDescription());\n-\t\tout.println(\"options:\");\n-\n-\t\tList<ParameterDescription> params = jc.getParameters();\n-\t\tMap<String, ParameterDescription> paramsMap = new LinkedHashMap<>(params.size());\n-\t\tint maxNamesLen = 0;\n-\t\tfor (ParameterDescription p : params) {\n-\t\t\tparamsMap.put(p.getParameterized().getName(), p);\n-\t\t\tint len = p.getNames().length();\n-\t\t\tif (len > maxNamesLen) {\n-\t\t\t\tmaxNamesLen = len;\n-\t\t\t}\n-\t\t}\n-\t\tJadxCLIArgs args = new JadxCLIArgs();\n-\t\tField[] fields = args.getClass().getDeclaredFields();\n-\t\tfor (Field f : fields) {\n-\t\t\tString name = f.getName();\n-\t\t\tParameterDescription p = paramsMap.get(name);\n-\t\t\tif (p == null) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tStringBuilder opt = new StringBuilder();\n-\t\t\topt.append(\"  \").append(p.getNames());\n-\t\t\taddSpaces(opt, maxNamesLen - opt.length() + 3);\n-\t\t\topt.append(\"- \").append(p.getDescription());\n-\t\t\taddDefaultValue(args, f, opt);\n-\t\t\tout.println(opt);\n-\t\t}\n-\t\tout.println(\"Example:\");\n-\t\tout.println(\"  jadx -d out classes.dex\");\n-\t}\n-\n-\tprivate void addDefaultValue(JadxCLIArgs args, Field f, StringBuilder opt) {\n-\t\tClass<?> fieldType = f.getType();\n-\t\tif (fieldType == int.class) {\n-\t\t\ttry {\n-\t\t\t\tint val = f.getInt(args);\n-\t\t\t\topt.append(\" (default: \").append(val).append(\")\");\n-\t\t\t} catch (Exception e) {\n-\t\t\t\t// ignore\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate static void addSpaces(StringBuilder str, int count) {\n-\t\tfor (int i = 0; i < count; i++) {\n-\t\t\tstr.append(' ');\n-\t\t}\n-\t}\n-\n \tpublic JadxArgs toJadxArgs() {\n \t\tJadxArgs args = new JadxArgs();\n \t\targs.setInputFiles(files.stream().map(FileUtils::toFile).collect(Collectors.toList()));\n\ndiff --git a/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java\n--- a/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java\n+++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java\n@@ -30,11 +30,35 @@ public void testSrcOption() {\n \t\tassertThat(parse(\"\").isSkipSources(), is(false));\n \t}\n \n+\t@Test\n+\tpublic void testOptionsOverride() {\n+\t\tassertThat(override(new JadxCLIArgs(), \"--no-imports\").isUseImports(), is(false));\n+\t\tassertThat(override(new JadxCLIArgs(), \"\").isUseImports(), is(true));\n+\n+\t\tJadxCLIArgs args = new JadxCLIArgs();\n+\t\targs.useImports = false;\n+\t\tassertThat(override(args, \"--no-imports\").isUseImports(), is(false));\n+\n+\t\targs = new JadxCLIArgs();\n+\t\targs.useImports = false;\n+\t\tassertThat(override(args, \"\").isUseImports(), is(false));\n+\t}\n+\n \tprivate JadxCLIArgs parse(String... args) {\n-\t\tJadxCLIArgs jadxArgs = new JadxCLIArgs();\n+\t\treturn parse(new JadxCLIArgs(), args);\n+\t}\n+\n+\tprivate JadxCLIArgs parse(JadxCLIArgs jadxArgs, String... args) {\n \t\tboolean res = jadxArgs.processArgs(args);\n \t\tassertThat(res, is(true));\n \t\tLOG.info(\"Jadx args: {}\", jadxArgs.toJadxArgs());\n \t\treturn jadxArgs;\n \t}\n+\n+\tprivate JadxCLIArgs override(JadxCLIArgs jadxArgs, String... args) {\n+\t\tboolean res = jadxArgs.overrideProvided(args);\n+\t\tassertThat(res, is(true));\n+\t\tLOG.info(\"Jadx args: {}\", jadxArgs.toJadxArgs());\n+\t\treturn jadxArgs;\n+\t}\n }\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/JadxGUI.java b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxGUI.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java\n@@ -19,7 +19,7 @@ public static void main(String[] args) {\n \t\t\tLogCollector.register();\n \t\t\tfinal JadxSettings settings = JadxSettingsAdapter.load();\n \t\t\t// overwrite loaded settings by command line arguments\n-\t\t\tif (!settings.processArgs(args)) {\n+\t\t\tif (!settings.overrideProvided(args)) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tif (!tryDefaultLookAndFeel()) {",
    "output": "Fix override settings by cmd options"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -26,7 +26,7 @@ public class JadxSettings extends JadxCLIArgs {\n \n \tprivate static final String USER_HOME = System.getProperty(\"user.home\");\n \tprivate static final int RECENT_FILES_COUNT = 15;\n-\tprivate static final int CURRENT_SETTINGS_VERSION = 4;\n+\tprivate static final int CURRENT_SETTINGS_VERSION = 5;\n \n \tprivate static final Font DEFAULT_FONT = FONT_HACK != null ? FONT_HACK : new RSyntaxTextArea().getFont();\n \n@@ -206,6 +206,10 @@ public void setReplaceConsts(boolean replaceConsts) {\n \t\tthis.replaceConsts = replaceConsts;\n \t}\n \n+\tpublic void setUseImports(boolean useImports) {\n+\t\tthis.useImports = useImports;\n+\t}\n+\n \tpublic boolean isAutoStartJobs() {\n \t\treturn autoStartJobs;\n \t}\n@@ -274,6 +278,10 @@ private void upgradeSettings(int fromVersion) {\n \t\t}\n \t\tif (fromVersion == 3) {\n \t\t\tsetLangLocale(NLS.defaultLocale());\n+\t\t\tfromVersion++;\n+\t\t}\n+\t\tif (fromVersion == 4) {\n+\t\t\tsetUseImports(true);\n \t\t}\n \t\tsettingsVersion = CURRENT_SETTINGS_VERSION;\n \t\tsync();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -260,12 +260,20 @@ private SettingsGroup makeDecompilationGroup() {\n \t\t\tneedReload();\n \t\t});\n \n+\t\tJCheckBox useImports = new JCheckBox();\n+\t\tuseImports.setSelected(settings.isUseImports());\n+\t\tuseImports.addItemListener(e -> {\n+\t\t\tsettings.setUseImports(e.getStateChange() == ItemEvent.SELECTED);\n+\t\t\tneedReload();\n+\t\t});\n+\n \t\tSettingsGroup other = new SettingsGroup(NLS.str(\"preferences.decompile\"));\n \t\tother.addRow(NLS.str(\"preferences.threads\"), threadsCount);\n \t\tother.addRow(NLS.str(\"preferences.start_jobs\"), autoStartJobs);\n \t\tother.addRow(NLS.str(\"preferences.showInconsistentCode\"), showInconsistentCode);\n \t\tother.addRow(NLS.str(\"preferences.escapeUnicode\"), escapeUnicode);\n \t\tother.addRow(NLS.str(\"preferences.replaceConsts\"), replaceConsts);\n+\t\tother.addRow(NLS.str(\"preferences.useImports\"), useImports);\n \t\tother.addRow(NLS.str(\"preferences.fallback\"), fallback);\n \t\tother.addRow(NLS.str(\"preferences.skipResourcesDecode\"), resourceDecode);\n \t\treturn other;",
    "output": "Add \"use imports\" option to preferences"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -182,7 +182,7 @@ public void mouseClicked(MouseEvent e) {\n \t\t\t\tint result = fontChooser.showDialog(JadxSettingsWindow.this);\n \t\t\t\tif (result == JFontChooser.OK_OPTION) {\n \t\t\t\t\tFont font = fontChooser.getSelectedFont();\n-\t\t\t\t\tLOG.info(\"Selected Font : {}\", font);\n+\t\t\t\t\tLOG.debug(\"Selected Font: {}\", font);\n \t\t\t\t\tsettings.setFont(font);\n \t\t\t\t\tmainWindow.updateFont(font);\n \t\t\t\t\tmainWindow.loadSettings();\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java b/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java\n@@ -25,6 +25,7 @@ public class LineNumbers extends JPanel implements CaretListener {\n \tprivate static final long serialVersionUID = -4978268673635308190L;\r\n \r\n \tprivate static final int NUM_HEIGHT = Integer.MAX_VALUE - 1000000;\r\n+\tprivate static final Map<?, ?> DESKTOP_HINTS = (Map<?, ?>) Toolkit.getDefaultToolkit().getDesktopProperty(\"awt.font.desktophints\");\r\n \r\n \tprivate CodeArea codeArea;\r\n \tprivate boolean useSourceLines = true;\r\n@@ -92,6 +93,7 @@ private void setPreferredWidth() {\n \tpublic void paintComponent(Graphics g) {\r\n \t\tsuper.paintComponent(g);\r\n \t\tg.setFont(codeArea.getFont());\r\n+\t\tapplyRenderHints(g);\r\n \r\n \t\tFontMetrics fontMetrics = codeArea.getFontMetrics(codeArea.getFont());\r\n \t\tInsets insets = getInsets();\r\n@@ -119,6 +121,19 @@ public void paintComponent(Graphics g) {\n \t\t}\r\n \t}\r\n \r\n+\tprivate void applyRenderHints(Graphics g) {\r\n+\t\tif (g instanceof Graphics2D) {\r\n+\t\t\tGraphics2D g2d = (Graphics2D) g;\r\n+\t\t\tif (DESKTOP_HINTS != null) {\r\n+\t\t\t\tg2d.setRenderingHints(DESKTOP_HINTS);\r\n+\t\t\t} else {\r\n+\t\t\t\tg2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\r\n+\t\t\t\tg2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\r\n+\t\t\t\tg2d.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n \tprivate boolean isCurrentLine(int rowStartOffset) {\r\n \t\tint caretPosition = codeArea.getCaretPosition();\r\n \t\tElement root = codeArea.getDocument().getDefaultRootElement();",
    "output": "Fix apply render hints for line numbers"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -78,7 +78,7 @@ public boolean addDefinition(CodeWriter code) {\n \t\t\tai = ai.remove(AccessFlags.ACC_PUBLIC);\n \t\t}\n \n-\t\tif (mth.getMethodInfo().isRenamed()) {\n+\t\tif (mth.getMethodInfo().isRenamed() && !ai.isConstructor()) {\n \t\t\tcode.startLine(\"/* renamed from: \").add(mth.getName()).add(\" */\");\n \t\t}\n \t\tcode.startLineWithNum(mth.getSourceLine());\n@@ -87,7 +87,7 @@ public boolean addDefinition(CodeWriter code) {\n \t\tif (classGen.addGenericMap(code, mth.getGenericMap())) {\n \t\t\tcode.add(' ');\n \t\t}\n-\t\tif (mth.getAccessFlags().isConstructor()) {\n+\t\tif (ai.isConstructor()) {\n \t\t\tcode.attachDefinition(mth);\n \t\t\tcode.add(classGen.getClassNode().getShortName()); // constructor\n \t\t} else {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -129,7 +129,7 @@ private void postProcess() {\n \t\t\tfor (MethodInfo mth : o.getMethods()) {\n \t\t\t\tif (aliasToUse == null) {\n \t\t\t\t\tif (mth.isRenamed() && !mth.isAliasFromPreset()) {\n-\t\t\t\t\t\tmth.setAlias(String.format(\"mo%d%s\", id, makeName(mth.getName())));\n+\t\t\t\t\t\tmth.setAlias(String.format(\"mo%d%s\", id, prepareNamePart(mth.getName())));\n \t\t\t\t\t}\n \t\t\t\t\taliasToUse = mth.getAlias();\n \t\t\t\t}\n@@ -350,7 +350,7 @@ private String makeClsAlias(ClassNode cls) {\n \n \t\tif (alias == null) {\n \t\t\tString clsName = classInfo.getShortName();\n-\t\t\talias = String.format(\"C%04d%s\", clsIndex++, makeName(clsName));\n+\t\t\talias = String.format(\"C%04d%s\", clsIndex++, prepareNamePart(clsName));\n \t\t}\n \t\tPackageNode pkg = getPackageNode(classInfo.getPackage(), true);\n \t\tclsMap.put(classInfo, new DeobfClsInfo(this, cls, pkg, alias));\n@@ -426,13 +426,13 @@ private String getMethodAlias(MethodNode mth) {\n \t}\n \n \tpublic String makeFieldAlias(FieldNode field) {\n-\t\tString alias = String.format(\"f%d%s\", fldIndex++, makeName(field.getName()));\n+\t\tString alias = String.format(\"f%d%s\", fldIndex++, prepareNamePart(field.getName()));\n \t\tfldMap.put(field.getFieldInfo(), alias);\n \t\treturn alias;\n \t}\n \n \tpublic String makeMethodAlias(MethodNode mth) {\n-\t\tString alias = String.format(\"m%d%s\", mthIndex++, makeName(mth.getName()));\n+\t\tString alias = String.format(\"m%d%s\", mthIndex++, prepareNamePart(mth.getName()));\n \t\tmthMap.put(mth.getMethodInfo(), alias);\n \t\treturn alias;\n \t}\n@@ -454,25 +454,21 @@ private void doPkg(PackageNode pkg, String fullName) {\n \n \t\tString pkgName = pkg.getName();\n \t\tif (!pkg.hasAlias() && shouldRename(pkgName)) {\n-\t\t\tString pkgAlias = String.format(\"p%03d%s\", pkgIndex++, makeName(pkgName));\n+\t\t\tString pkgAlias = String.format(\"p%03d%s\", pkgIndex++, prepareNamePart(pkgName));\n \t\t\tpkg.setAlias(pkgAlias);\n \t\t}\n \t}\n \n \tprivate boolean shouldRename(String s) {\n-\t\treturn s.length() > maxLength\n-\t\t\t\t|| s.length() < minLength\n-\t\t\t\t|| NameMapper.isReserved(s)\n-\t\t\t\t|| !NameMapper.isAllCharsPrintable(s);\n+\t\tint len = s.length();\n+\t\treturn len < minLength || len > maxLength\n+\t\t\t\t|| !NameMapper.isValidIdentifier(s);\n \t}\n \n-\tprivate String makeName(String name) {\n+\tprivate String prepareNamePart(String name) {\n \t\tif (name.length() > maxLength) {\n \t\t\treturn \"x\" + Integer.toHexString(name.hashCode());\n \t\t}\n-\t\tif (NameMapper.isReserved(name)) {\n-\t\t\treturn name;\n-\t\t}\n \t\tif (!NameMapper.isAllCharsPrintable(name)) {\n \t\t\treturn removeInvalidChars(name);\n \t\t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java\n@@ -79,12 +79,14 @@ public static boolean isReserved(String str) {\n \n \tpublic static boolean isValidIdentifier(String str) {\n \t\treturn notEmpty(str)\n+\t\t\t\t&& !isReserved(str)\n \t\t\t\t&& VALID_JAVA_IDENTIFIER.matcher(str).matches()\n \t\t\t\t&& isAllCharsPrintable(str);\n \t}\n \n \tpublic static boolean isValidFullIdentifier(String str) {\n \t\treturn notEmpty(str)\n+\t\t\t\t&& !isReserved(str)\n \t\t\t\t&& VALID_JAVA_FULL_IDENTIFIER.matcher(str).matches()\n \t\t\t\t&& isAllCharsPrintable(str);\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java\n@@ -10,6 +10,7 @@\n import jadx.api.JadxArgs;\n import jadx.core.Consts;\n import jadx.core.deobf.Deobfuscator;\n+import jadx.core.deobf.NameMapper;\n import jadx.core.dex.attributes.AFlag;\n import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.info.FieldInfo;\n@@ -100,7 +101,8 @@ private void checkFields(ClassNode cls) {\n \t\tSet<String> names = new HashSet<>();\n \t\tfor (FieldNode field : cls.getFields()) {\n \t\t\tFieldInfo fieldInfo = field.getFieldInfo();\n-\t\t\tif (!names.add(fieldInfo.getAlias())) {\n+\t\t\tString fieldName = fieldInfo.getAlias();\n+\t\t\tif (!names.add(fieldName) || !NameMapper.isValidIdentifier(fieldName)) {\n \t\t\t\tdeobfuscator.renameField(field);\n \t\t\t}\n \t\t}\n@@ -109,11 +111,11 @@ private void checkFields(ClassNode cls) {\n \tprivate void checkMethods(ClassNode cls) {\n \t\tSet<String> names = new HashSet<>();\n \t\tfor (MethodNode mth : cls.getMethods()) {\n-\t\t\tif (mth.contains(AFlag.DONT_GENERATE)) {\n+\t\t\tif (mth.contains(AFlag.DONT_GENERATE) || mth.getAccessFlags().isConstructor()) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tString signature = mth.getMethodInfo().makeSignature(false);\n-\t\t\tif (!names.add(signature)) {\n+\t\t\tif (!names.add(signature) || !NameMapper.isValidIdentifier(mth.getAlias())) {\n \t\t\t\tdeobfuscator.renameMethod(mth);\n \t\t\t}\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n@@ -27,6 +27,7 @@\n import jadx.core.dex.nodes.RootNode;\n import jadx.core.dex.visitors.DepthTraversal;\n import jadx.core.dex.visitors.IDexTreeVisitor;\n+import jadx.core.utils.exceptions.JadxException;\n import jadx.core.xmlgen.ResourceStorage;\n import jadx.core.xmlgen.entry.ResourceEntry;\n import jadx.tests.api.compiler.DynamicCompiler;\n@@ -137,20 +138,34 @@ private void insertResources(RootNode root) {\n \t}\n \n \tprotected void decompile(JadxDecompiler jadx, ClassNode cls) {\n-\t\tList<IDexTreeVisitor> passes = Jadx.getPassesList(jadx.getArgs());\n+\t\tList<IDexTreeVisitor> passes = getPassesList(jadx);\n \t\tProcessClass.process(cls, passes, new CodeGen());\n \t}\n \n-\tprotected void decompileWithoutUnload(JadxDecompiler d, ClassNode cls) {\n+\tprotected void decompileWithoutUnload(JadxDecompiler jadx, ClassNode cls) {\n \t\tcls.load();\n-\t\tList<IDexTreeVisitor> passes = Jadx.getPassesList(d.getArgs());\n+\t\tList<IDexTreeVisitor> passes = getPassesList(jadx);\n \t\tfor (IDexTreeVisitor visitor : passes) {\n \t\t\tDepthTraversal.visit(visitor, cls);\n \t\t}\n \t\tgenerateClsCode(cls);\n \t\t// don't unload class\n \t}\n \n+\tprivate List<IDexTreeVisitor> getPassesList(JadxDecompiler jadx) {\n+\t\tRootNode root = JadxInternalAccess.getRoot(jadx);\n+\t\tList<IDexTreeVisitor> passesList = Jadx.getPassesList(jadx.getArgs());\n+\t\tpassesList.forEach(pass -> {\n+\t\t\ttry {\n+\t\t\t\tpass.init(root);\n+\t\t\t} catch (JadxException e) {\n+\t\t\t\te.printStackTrace();\n+\t\t\t\tfail(e.getMessage());\n+\t\t\t}\n+\t\t});\n+\t\treturn passesList;\n+\t}\n+\n \tprotected void generateClsCode(ClassNode cls) {\n \t\ttry {\n \t\t\tnew CodeGen().visit(cls);\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedNames.java b/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedNames.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedNames.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedNames.java\n@@ -0,0 +1,32 @@\n+package jadx.tests.integration.names;\n+\n+import org.junit.Test;\n+\n+import jadx.core.dex.nodes.ClassNode;\n+import jadx.tests.api.SmaliTest;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.not;\n+import static org.junit.Assert.assertThat;\n+\n+public class TestReservedNames extends SmaliTest {\n+\t/*\n+\t\tpublic static class TestCls {\n+\n+\t\t\tpublic String do; // reserved name\n+\t\t\tpublic String 0f; // invalid identifier\n+\n+\t\t\tpublic String try() {\n+\t\t\t\treturn this.do;\n+\t\t\t}\n+\t\t}\n+\t*/\n+\n+\t@Test\n+\tpublic void test() {\n+\t\tClassNode cls = getClassNodeFromSmaliWithPath(\"names\", \"TestReservedNames\");\n+\t\tString code = cls.getCode().toString();\n+\n+\t\tassertThat(code, not(containsString(\"public String do;\")));\n+\t}\n+}",
    "output": "Fix force rename fields and methods with reserved names"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java\n@@ -5,7 +5,6 @@\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n-import java.io.IOException;\n import java.io.InputStream;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -66,14 +65,14 @@ public static ResContainer singleImageFile(String name, InputStream content) {\n \t\t}\n \t\treturn resContainer;\n \t}\n-\t\n+\n \tpublic static ResContainer singleBinaryFile(String name, InputStream content) {\n \t\tResContainer resContainer = new ResContainer(name, Collections.emptyList());\n \t\ttry {\n+\t\t\t// TODO: don't store binary files in memory\n \t\t\tresContainer.binary = new ByteArrayInputStream(IOUtils.toByteArray(content));\n-\t\t}\n-\t\tcatch(IOException e) {\n-\t\t\tLOG.warn(\"Contents of the binary resource '{}' not saved, got exception {}\", name, e);\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.warn(\"Contents of the binary resource '{}' not saved, got exception\", name, e);\n \t\t}\n \t\treturn resContainer;\n \t}\n@@ -94,7 +93,7 @@ public String getFileName() {\n \tpublic CodeWriter getContent() {\n \t\treturn content;\n \t}\n-\t\n+\n \t@Nullable\n \tpublic InputStream getBinary() {\n \t\treturn binary;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n@@ -15,6 +15,7 @@\n \n import jadx.api.ResourceFile;\n import jadx.core.codegen.CodeWriter;\n+import jadx.core.utils.files.FileUtils;\n import jadx.core.utils.files.ZipSecurity;\n \n import static jadx.core.utils.files.FileUtils.prepareFile;\n@@ -89,16 +90,16 @@ private void saveToFile(ResContainer rc, File outFile) {\n \t\t\treturn;\n \t\t}\n \t\tInputStream binary = rc.getBinary();\n-\t\tif(binary != null) {\n+\t\tif (binary != null) {\n \t\t\ttry {\n-\t\t\t\toutFile.getParentFile().mkdirs();\n-\t\t\t\tFileOutputStream binaryFileStream = new FileOutputStream(outFile);\n-\t\t\t\tIOUtils.copy(binary, binaryFileStream);\n-\t\t\t\tbinaryFileStream.close();\n-\t\t\t\tbinary.close();\n-\t\t\t}\n-\t\t\tcatch(IOException e) {\n-\t\t\t\tLOG.warn(\"Resource '{}' not saved, got exception {}\", rc.getName(), e);\n+\t\t\t\tFileUtils.makeDirsForFile(outFile);\n+\t\t\t\ttry (FileOutputStream binaryFileStream = new FileOutputStream(outFile)) {\n+\t\t\t\t\tIOUtils.copy(binary, binaryFileStream);\n+\t\t\t\t} finally {\n+\t\t\t\t\tbinary.close();\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tLOG.warn(\"Resource '{}' not saved, got exception\", rc.getName(), e);\n \t\t\t}\n \t\t\treturn;\n \t\t}",
    "output": "Fix resolve lint errors in resource save methods"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n@@ -10,12 +10,10 @@\n \n import org.apache.commons.io.FilenameUtils;\n import org.apache.commons.io.IOUtils;\n-import org.mockito.internal.util.io.IOUtil;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import jadx.api.ResourceFile;\n-import jadx.api.ResourceType;\n import jadx.core.codegen.CodeWriter;\n import jadx.core.utils.files.ZipSecurity;",
    "output": "Remove useless imports which prevented gradle build"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourceType.java b/jadx-core/src/main/java/jadx/api/ResourceType.java\n--- a/jadx-core/src/main/java/jadx/api/ResourceType.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourceType.java\n@@ -30,21 +30,4 @@ public static ResourceType getFileType(String fileName) {\n \t\t}\n \t\treturn UNKNOWN;\n \t}\n-\n-\tpublic static boolean isSupportedForUnpack(ResourceType type) {\n-\t\tswitch (type) {\n-\t\t\tcase CODE:\n-\t\t\tcase LIB:\n-\t\t\tcase FONT:\n-\t\t\tcase UNKNOWN:\n-\t\t\t\treturn false;\n-\n-\t\t\tcase MANIFEST:\n-\t\t\tcase XML:\n-\t\t\tcase ARSC:\n-\t\t\tcase IMG:\n-\t\t\t\treturn true;\n-\t\t}\n-\t\treturn false;\n-\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n--- a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n@@ -105,6 +105,12 @@ private static ResContainer loadContent(JadxDecompiler jadxRef, ResourceFile rf,\n \t\t\tcase IMG:\n \t\t\t\treturn ResContainer.singleImageFile(rf.getName(), inputStream);\n \n+\t\t\tcase CODE:\n+\t\t\tcase LIB:\n+\t\t\tcase FONT:\n+\t\t\tcase UNKNOWN:\n+\t\t\t\treturn ResContainer.singleBinaryFile(rf.getName(), inputStream);\n+\n \t\t\tdefault:\n \t\t\t\tif (size > LOAD_SIZE_LIMIT) {\n \t\t\t\t\treturn ResContainer.singleFile(rf.getName(),\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java\n@@ -5,11 +5,13 @@\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n+import org.apache.commons.io.IOUtils;\n import org.jetbrains.annotations.NotNull;\n import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n@@ -30,6 +32,8 @@ public class ResContainer implements Comparable<ResContainer> {\n \tprivate CodeWriter content;\n \t@Nullable\n \tprivate BufferedImage image;\n+\t@Nullable\n+\tprivate InputStream binary;\n \n \tprivate ResContainer(String name, List<ResContainer> subFiles) {\n \t\tthis.name = name;\n@@ -62,6 +66,17 @@ public static ResContainer singleImageFile(String name, InputStream content) {\n \t\t}\n \t\treturn resContainer;\n \t}\n+\t\n+\tpublic static ResContainer singleBinaryFile(String name, InputStream content) {\n+\t\tResContainer resContainer = new ResContainer(name, Collections.emptyList());\n+\t\ttry {\n+\t\t\tresContainer.binary = new ByteArrayInputStream(IOUtils.toByteArray(content));\n+\t\t}\n+\t\tcatch(IOException e) {\n+\t\t\tLOG.warn(\"Contents of the binary resource '{}' not saved, got exception {}\", name, e);\n+\t\t}\n+\t\treturn resContainer;\n+\t}\n \n \tpublic static ResContainer multiFile(String name) {\n \t\treturn new ResContainer(name, new ArrayList<>());\n@@ -79,6 +94,11 @@ public String getFileName() {\n \tpublic CodeWriter getContent() {\n \t\treturn content;\n \t}\n+\t\n+\t@Nullable\n+\tpublic InputStream getBinary() {\n+\t\treturn binary;\n+\t}\n \n \tpublic void setContent(@Nullable CodeWriter content) {\n \t\tthis.content = content;\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java\n@@ -3,10 +3,14 @@\n import javax.imageio.ImageIO;\n import java.awt.image.BufferedImage;\n import java.io.File;\n+import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.util.List;\n \n import org.apache.commons.io.FilenameUtils;\n+import org.apache.commons.io.IOUtils;\n+import org.mockito.internal.util.io.IOUtil;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -30,9 +34,6 @@ public ResourcesSaver(File outDir, ResourceFile resourceFile) {\n \n \t@Override\n \tpublic void run() {\n-\t\tif (!ResourceType.isSupportedForUnpack(resourceFile.getType())) {\n-\t\t\treturn;\n-\t\t}\n \t\tResContainer rc = resourceFile.loadContent();\n \t\tif (rc != null) {\n \t\t\tsaveResources(rc);\n@@ -89,6 +90,20 @@ private void saveToFile(ResContainer rc, File outFile) {\n \t\t\tcw.save(outFile);\n \t\t\treturn;\n \t\t}\n+\t\tInputStream binary = rc.getBinary();\n+\t\tif(binary != null) {\n+\t\t\ttry {\n+\t\t\t\toutFile.getParentFile().mkdirs();\n+\t\t\t\tFileOutputStream binaryFileStream = new FileOutputStream(outFile);\n+\t\t\t\tIOUtils.copy(binary, binaryFileStream);\n+\t\t\t\tbinaryFileStream.close();\n+\t\t\t\tbinary.close();\n+\t\t\t}\n+\t\t\tcatch(IOException e) {\n+\t\t\t\tLOG.warn(\"Resource '{}' not saved, got exception {}\", rc.getName(), e);\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n \t\tLOG.warn(\"Resource '{}' not saved, unknown type\", rc.getName());\n \t}\n }",
    "output": "Fix saves all resources"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -175,12 +175,12 @@ private ExecutorService getSaveExecutor(boolean saveSources, boolean saveResourc\n \t\t\tsourcesOutDir = args.getOutDirSrc();\n \t\t\tresOutDir = args.getOutDirRes();\n \t\t}\n-\t\tif (saveSources) {\n-\t\t\tappendSourcesSave(executor, sourcesOutDir);\n-\t\t}\n \t\tif (saveResources) {\n \t\t\tappendResourcesSave(executor, resOutDir);\n \t\t}\n+\t\tif (saveSources) {\n+\t\t\tappendSourcesSave(executor, sourcesOutDir);\n+\t\t}\n \t\treturn executor;\n \t}",
    "output": "Fix exports resources first"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -114,7 +114,7 @@ public void addRecentFile(String filePath) {\n \t\trecentFiles.add(0, filePath);\n \t\tint count = recentFiles.size();\n \t\tif (count > RECENT_FILES_COUNT) {\n-\t\t\trecentFiles.subList(0, count - RECENT_FILES_COUNT).clear();\n+\t\t\trecentFiles.subList(RECENT_FILES_COUNT, count).clear();\n \t\t}\n \t\tsync();\n \t}",
    "output": "Fix make correct size truncate for recent files list"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java\n@@ -55,16 +55,16 @@\n public class RegionMaker {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(RegionMaker.class);\n \n-\t// 'dumb' guard to prevent endless loop in regions processing\n-\tprivate static final int REGIONS_LIMIT = 1000 * 1000;\n-\n \tprivate final MethodNode mth;\n+\tprivate final int regionsLimit;\n \tprivate int regionsCount;\n \tprivate BitSet processedBlocks;\n \n \tpublic RegionMaker(MethodNode mth) {\n \t\tthis.mth = mth;\n-\t\tthis.processedBlocks = new BitSet(mth.getBasicBlocks().size());\n+\t\tint blocksCount = mth.getBasicBlocks().size();\n+\t\tthis.processedBlocks = new BitSet(blocksCount);\n+\t\tthis.regionsLimit = blocksCount * 100;\n \t}\n \n \tpublic Region makeRegion(BlockNode startBlock, RegionStack stack) {\n@@ -84,7 +84,7 @@ public Region makeRegion(BlockNode startBlock, RegionStack stack) {\n \t\twhile (next != null) {\n \t\t\tnext = traverse(r, next, stack);\n \t\t\tregionsCount++;\n-\t\t\tif (regionsCount > REGIONS_LIMIT) {\n+\t\t\tif (regionsCount > regionsLimit) {\n \t\t\t\tthrow new JadxRuntimeException(\"Regions count limit reached\");\n \t\t\t}\n \t\t}",
    "output": "Fix lower regions count limit"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -91,7 +91,6 @@ public void load() {\n \n \t\troot.initClassPath();\n \t\troot.loadResources(getResources());\n-\t\troot.initAppResClass();\n \n \t\tinitVisitors();\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -94,10 +94,7 @@ public void loadResources(List<ResourceFile> resources) {\n \t\tResourceStorage resStorage = parser.getResStorage();\n \t\tconstValues.setResourcesNames(resStorage.getResourcesNames());\n \t\tappPackage = resStorage.getAppPackage();\n-\t}\n-\n-\tpublic void initAppResClass() {\n-\t\tappResClass = AndroidResourcesUtils.searchAppResClass(this);\n+\t\tappResClass = AndroidResourcesUtils.searchAppResClass(this, resStorage);\n \t}\n \n \tpublic void initClassPath() {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java\n@@ -1,6 +1,11 @@\n package jadx.core.utils.android;\n \n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -11,6 +16,8 @@\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.dex.nodes.DexNode;\n import jadx.core.dex.nodes.RootNode;\n+import jadx.core.xmlgen.ResourceStorage;\n+import jadx.core.xmlgen.entry.ResourceEntry;\n \n /**\n  * Android resources specific handlers\n@@ -21,7 +28,7 @@ public class AndroidResourcesUtils {\n \tprivate AndroidResourcesUtils() {\n \t}\n \n-\tpublic static ClassNode searchAppResClass(RootNode root) {\n+\tpublic static ClassNode searchAppResClass(RootNode root, ResourceStorage resStorage) {\n \t\tString appPackage = root.getAppPackage();\n \t\tString fullName = appPackage != null ? appPackage + \".R\" : \"R\";\n \t\tClassNode resCls = root.searchClassByName(fullName);\n@@ -36,7 +43,7 @@ public static ClassNode searchAppResClass(RootNode root) {\n \t\t\tLOG.info(\"Found several 'R' class candidates: {}\", candidates);\n \t\t}\n \t\tLOG.warn(\"Unknown 'R' class, create references to '{}'\", fullName);\n-\t\treturn makeClass(root, fullName);\n+\t\treturn makeClass(root, fullName, resStorage);\n \t}\n \n \tpublic static boolean handleAppResField(CodeWriter code, ClassGen clsGen, ClassInfo declClass) {\n@@ -50,12 +57,48 @@ public static boolean handleAppResField(CodeWriter code, ClassGen clsGen, ClassI\n \t\treturn false;\n \t}\n \n-\tprivate static ClassNode makeClass(RootNode root, String clsName) {\n+\tprivate static ClassNode makeClass(RootNode root, String clsName, ResourceStorage resStorage) {\n \t\tList<DexNode> dexNodes = root.getDexNodes();\n \t\tif (dexNodes.isEmpty()) {\n \t\t\treturn null;\n \t\t}\n \t\tClassInfo r = ClassInfo.fromName(root, clsName);\n-\t\treturn new ClassNode(dexNodes.get(0), r);\n+\t\tClassNode classNode = new ClassNode(dexNodes.get(0), r);\n+\t\tgenerateMissingRCode(classNode, resStorage);\n+\t\treturn classNode;\n+\t}\n+\t\n+\tprivate static void generateMissingRCode(ClassNode cls, ResourceStorage resStorage) {\n+\t\tMap<String, List<ResourceEntry>> sortedMap = new HashMap<>();\n+\t\tfor(ResourceEntry ri : resStorage.getResources()) {\n+\t\t\tList<ResourceEntry> entries = sortedMap.get(ri.getTypeName());\n+\t\t\tif(entries == null) {\n+\t\t\t\tentries = new LinkedList<>();\n+\t\t\t\tsortedMap.put(ri.getTypeName(), entries);\n+\t\t\t}\n+\t\t\tentries.add(ri);\n+\t\t}\n+\t\t\n+\t\tSet<String> addedValues = new HashSet<>();\n+\t\tCodeWriter clsCode = new CodeWriter();\n+\t\tif (!\"\".equals(cls.getPackage())) {\n+\t\t\tclsCode.add(\"package \").add(cls.getPackage()).add(';').newLine();\n+\t\t}\n+\t\tclsCode.startLine(\"public final class \").add(cls.getShortName()).add(\" {\").incIndent();\n+\t\tfor(String typeName : sortedMap.keySet()) {\n+\t\t\tclsCode.startLine(\"public static final class \").add(typeName).add(\" {\").incIndent();\n+\t\t\tfor(ResourceEntry ri : sortedMap.get(typeName)) {\n+\t\t\t\tif(addedValues.add(ri.getTypeName() + \".\" + ri.getKeyName())) {\n+\t\t\t\t\tclsCode.startLine(\"public static final int \").add(ri.getKeyName()).add(\" = \")\n+\t\t\t\t\t\t.add(\"\" + ri.getId()).add(\";\");\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tclsCode.decIndent();\n+\t\t\tclsCode.add(\"}\");\n+\t\t}\n+\t\tclsCode.decIndent();\n+\t\tclsCode.add(\"}\");\n+\t\t\n+\t\tcls.setCode(clsCode);\n \t}\n }",
    "output": "Fix generates code of missing R class"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n@@ -225,9 +225,12 @@ public void mouseClicked(MouseEvent e) {\n \tprivate JPopupMenu createTabPopupMenu(final ContentPanel contentPanel) {\n \t\tJPopupMenu menu = new JPopupMenu();\n \n-\t\tJMenuItem copyRootClassName = new JMenuItem(NLS.str(\"tabs.copy_class_name\"));\n-\t\tcopyRootClassName.addActionListener(actionEvent -> copyRootClassName());\n-\t\tmenu.add(copyRootClassName);\n+\t\tif (getNodeFullName() != null) {\n+\t\t\tJMenuItem copyRootClassName = new JMenuItem(NLS.str(\"tabs.copy_class_name\"));\n+\t\t\tcopyRootClassName.addActionListener(actionEvent -> copyRootClassName());\n+\t\t\tmenu.add(copyRootClassName);\n+\t\t\tmenu.addSeparator();\n+\t\t}\n \n \t\tJMenuItem closeTab = new JMenuItem(NLS.str(\"tabs.close\"));\n \t\tcloseTab.addActionListener(e -> closeCodePanel(contentPanel));\n@@ -275,15 +278,25 @@ public void closeAllTabs() {\n \t}\n \n \tpublic void copyRootClassName() {\n+\t\tString name = getNodeFullName();\n+\t\tif (name != null) {\n+\t\t\tUtils.setClipboardString(name);\n+\t\t}\n+\t}\n+\n+\t@Nullable\n+\tprivate String getNodeFullName() {\n \t\tContentPanel selectedPanel = getSelectedCodePanel();\n \t\tif (selectedPanel != null) {\n \t\t\tJNode node = selectedPanel.getNode();\n \t\t\tJClass jClass = node.getRootClass();\n \t\t\tif (jClass != null) {\n-\t\t\t\tString name = jClass.getFullName();\n-\t\t\t\tUtils.setClipboardString(name);\n+\t\t\t\treturn jClass.getFullName();\n+\t\t\t} else {\n+\t\t\t\treturn node.getName();\n \t\t\t}\n \t\t}\n+\t\treturn null;\n \t}\n \n \tpublic void loadSettings() {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/Utils.java b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java\n@@ -141,9 +141,14 @@ public static char caseChar(char ch, boolean toLower) {\n \t\treturn toLower ? Character.toLowerCase(ch) : ch;\n \t}\n \n-\tpublic static void setClipboardString(String text){\n-\t\tClipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n-\t\tTransferable transferable = new StringSelection(text);\n-\t\tclipboard.setContents(transferable, null);\n+\tpublic static void setClipboardString(String text) {\n+\t\ttry {\n+\t\t\tClipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+\t\t\tTransferable transferable = new StringSelection(text);\n+\t\t\tclipboard.setContents(transferable, null);\n+\t\t\tLOG.debug(\"String '{}' copied to clipboard\", text);\n+\t\t} catch (Exception e) {\n+\t\t\tLOG.error(\"Failed copy string '{}' to clipboard\", text, e);\n+\t\t}\n \t}\n }",
    "output": "Fix show 'copy name' action only for supported nodes"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/CertificatePanel.java b/jadx-gui/src/main/java/jadx/gui/ui/CertificatePanel.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/CertificatePanel.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/CertificatePanel.java\n@@ -3,21 +3,26 @@\n import javax.swing.*;\n import java.awt.*;\n \n+import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;\n+\n import jadx.gui.treemodel.JNode;\n \n-public class CertificatePanel extends ContentPanel {\n-    CertificatePanel(TabbedPane panel, JNode jnode) {\n-        super(panel, jnode);\n-        setLayout(new BorderLayout());\n-        JTextArea textArea = new JTextArea(jnode.getContent());\n-        textArea.setFont(textArea.getFont().deriveFont(12f)); // will only change size to 12pt\n-        JScrollPane sp = new JScrollPane(textArea);\n-        add(sp);\n-    }\n+public final class CertificatePanel extends ContentPanel {\n+\tprivate static final long serialVersionUID = 8566591625905036877L;\n \n-    @Override\n-    public void loadSettings() {\n+\tprivate final RSyntaxTextArea textArea;\n \n+\tCertificatePanel(TabbedPane panel, JNode jnode) {\n+\t\tsuper(panel, jnode);\n+\t\tsetLayout(new BorderLayout());\n+\t\ttextArea = new RSyntaxTextArea(jnode.getContent());\n+\t\tloadSettings();\n+\t\tJScrollPane sp = new JScrollPane(textArea);\n+\t\tadd(sp);\n+\t}\n \n-    }\n+\t@Override\n+\tpublic void loadSettings() {\n+\t\tCodeArea.loadCommonSettings(getTabbedPane().getMainWindow(), textArea);\n+\t}\n }",
    "output": "Use correct font and style for certificate panel"
  },
  {
    "input": "diff --git a/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java\n--- a/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java\n@@ -8,6 +8,8 @@\n import java.security.SecureClassLoader;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n \n import static javax.tools.JavaFileObject.Kind;\n \n@@ -34,8 +36,8 @@ public ClassLoader getClassLoader(Location location) {\n \t}\n \n \tprivate class DynamicClassLoader extends SecureClassLoader {\n-\t\tprivate final Map<String, JavaClassObject> clsMap = new HashMap<>();\n-\t\tprivate final Map<String, Class<?>> clsCache = new HashMap<>();\n+\t\tprivate final Map<String, JavaClassObject> clsMap = new ConcurrentHashMap<>();\n+\t\tprivate final Map<String, Class<?>> clsCache = new ConcurrentHashMap<>();\n \n \t\t@Override\n \t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {",
    "output": "Make the Classloader threadsafe"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n@@ -205,6 +205,9 @@ private String getSyntaxByExtension(String name) {\n \t\tif (ext.equals(\"html\")) {\n \t\t\treturn SyntaxConstants.SYNTAX_STYLE_HTML;\n \t\t}\n+\t\tif(ext.equals(\"arsc\")) {\n+\t\t\treturn SyntaxConstants.SYNTAX_STYLE_XML;\n+\t\t}\n \t\treturn null;\n \t}",
    "output": "Change display style for resources.arsc"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java\n@@ -119,13 +119,6 @@ CodeWriter add(CodeWriter code) {\n \t\tbuf.append(code.buf);\n \t\treturn this;\n \t}\n-\t\n-\tpublic void updateContent(String newData) {\n-\t\toffset = newData.length();\n-\t\tbuf = new StringBuilder(newData);\n-\t\tline = newData.split(NL).length + 1;\n-\t\tcode = newData;\n-\t}\n \n \tpublic CodeWriter newLine() {\n \t\taddLine();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -251,8 +251,8 @@ private void parseElement() throws IOException {\n \t\t}\n \t\tisOneLine = true;\n \t\tisLastEnd = false;\n-\t\tcurrentTag = getValidTagAttributeName(getString(startNSName));\n-\t\tcurrentTag = deobfClassName(currentTag);\n+\t\tcurrentTag = deobfClassName(getString(startNSName));\n+\t\tcurrentTag = getValidTagAttributeName(currentTag);\n \t\twriter.startLine(\"<\").add(currentTag);\n \t\twriter.attachSourceLine(elementBegLineNumber);\n \t\tint attributeStart = is.readInt16();\n@@ -441,7 +441,8 @@ private void parseElementEnd() throws IOException {\n \t\tint comment = is.readInt32();\n \t\tint elementNS = is.readInt32();\n \t\tint elementNameId = is.readInt32();\n-\t\tString elemName = getValidTagAttributeName(getString(elementNameId));\n+\t\tString elemName = deobfClassName(getString(elementNameId));\n+\t\telemName = getValidTagAttributeName(elemName);\n \t\tif (currentTag.equals(elemName) && isOneLine && !isLastEnd) {\n \t\t\twriter.add(\"/>\");\n \t\t} else {",
    "output": "Fix errors"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/StringUtils.java b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java\n@@ -149,6 +149,9 @@ public static String escapeResStrValue(String str) {\n \t}\n \n \tprivate static String escapeXmlChar(char c) {\n+\t\tif(c >= 0 && c <= 0x1F) {\n+\t\t\treturn \"\\\\\" + (int) c;\n+\t\t}\n \t\tswitch (c) {\n \t\t\tcase '&':\n \t\t\t\treturn \"&amp;\";\n@@ -160,6 +163,8 @@ private static String escapeXmlChar(char c) {\n \t\t\t\treturn \"&quot;\";\n \t\t\tcase '\\'':\n \t\t\t\treturn \"&apos;\";\n+\t\t\tcase '\\\\':\n+\t\t\t\treturn \"\\\\\\\\\";\n \t\t\tdefault:\n \t\t\t\treturn null;\n \t\t}",
    "output": "Add more escape for unreadable characters so parser won't throw exceptions during parse"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -174,7 +174,11 @@ private void parseNameSpace() throws IOException {\n \t\tint comment = is.readInt32();\n \t\tint beginPrefix = is.readInt32();\n \t\tint beginURI = is.readInt32();\n-\t\tnsMap.computeIfAbsent(getString(beginURI), k -> getString(beginPrefix));\n+\t\t\n+\t\tString nsValue = getString(beginPrefix);\n+\t\tif(!nsMap.containsValue(nsValue)) {\n+\t\t\tnsMap.putIfAbsent(getString(beginURI), nsValue);\n+\t\t}\n \t\tnamespaceDepth++;\n \t}\n \n@@ -190,7 +194,11 @@ private void parseNameSpaceEnd() throws IOException {\n \t\tint endPrefix = is.readInt32();\n \t\tint endURI = is.readInt32();\n \t\tnamespaceDepth--;\n-\t\tnsMap.computeIfAbsent(getString(endURI), k -> getString(endPrefix));\n+\t\t\n+\t\tString nsValue = getString(endPrefix);\n+\t\tif(!nsMap.containsValue(nsValue)) {\n+\t\t\tnsMap.putIfAbsent(getString(endURI), nsValue);\n+\t\t}\n \t}\n \n \tprivate void parseCData() throws IOException {",
    "output": "Fix bug with NS declaration duplicates"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -4,7 +4,9 @@\n import java.io.InputStream;\n import java.lang.reflect.Field;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Set;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -40,6 +42,7 @@ public class BinaryXMLParser extends CommonBinaryParser {\n \tprivate final Map<Integer, FieldNode> localStyleMap = new HashMap<>();\n \tprivate final Map<Integer, String> resNames;\n \tprivate final Map<String, String> nsMap = new HashMap<>();\n+\tprivate Set<String> nsMapGenerated;\n \n \tprivate CodeWriter writer;\n \tprivate String[] strings;\n@@ -86,6 +89,7 @@ public synchronized CodeWriter parse(InputStream inputStream) throws IOException\n \t\tif (!isBinaryXml()) {\n \t\t\treturn ResourcesLoader.loadToCodeWriter(inputStream);\n \t\t}\n+\t\tnsMapGenerated = new HashSet<>();\n \t\twriter = new CodeWriter();\n \t\twriter.add(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\");\n \t\tfirstElement = true;\n@@ -317,11 +321,12 @@ private String getAttributeNS(int attributeNS) {\n \tprivate String generateNameForNS(String attrUrl) {\n \t\tfor(int i = 1; ; i++) {\n \t\t\tString attrName = \"ns\" + i;\n-\t\t\tif(!nsMap.containsValue(attrName)) {\n+\t\t\tif(!nsMap.containsValue(attrName) && !nsMapGenerated.contains(attrName)) {\n+\t\t\t\tnsMapGenerated.add(attrName);\n \t\t\t\t// do not add generated value to nsMap\n \t\t\t\t// because attrUrl might be used in a neighbor element, but never defined\n \t\t\t\twriter.add(\"xmlns:\").add(attrName)\n-\t\t\t\t\t.add(\"=\\\"\").add(attrUrl).add(\"\\\"\");\n+\t\t\t\t\t.add(\"=\\\"\").add(attrUrl).add(\"\\\" \");\n \t\t\t\treturn attrName;\n \t\t\t}\n \t\t}",
    "output": "Fix bugs"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -309,10 +309,23 @@ private String getAttributeNS(int attributeNS) {\n \t\t}\n \t\tString attrName = nsMap.get(attrUrl);\n \t\tif (attrName == null) {\n-\t\t\treturn \"NOT_FOUND_NS_0x\" + Integer.toHexString(attributeNS) + \"_\" + attrUrl;\n+\t\t\tattrName = generateNameForNS(attrUrl);\n \t\t}\n \t\treturn attrName;\n \t}\n+\t\n+\tprivate String generateNameForNS(String attrUrl) {\n+\t\tfor(int i = 1; ; i++) {\n+\t\t\tString attrName = \"ns\" + i;\n+\t\t\tif(!nsMap.containsValue(attrName)) {\n+\t\t\t\t// do not add generated value to nsMap\n+\t\t\t\t// because attrUrl might be used in a neighbor element, but never defined\n+\t\t\t\twriter.add(\"xmlns:\").add(attrName)\n+\t\t\t\t\t.add(\"=\\\"\").add(attrUrl).add(\"\\\"\");\n+\t\t\t\treturn attrName;\n+\t\t\t}\n+\t\t}\n+\t}\n \n \tprivate String getAttributeName(int id) {\n \t\tString str = getString(id);",
    "output": "Add define of unknown NSes"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n@@ -10,7 +10,7 @@ public class ZipSecurity {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ZipSecurity.class);\n \n \t// size of uncompressed zip entry shouldn't be bigger of compressed in MAX_SIZE_DIFF times\n-\tprivate static final int MAX_SIZE_DIFF = 25;\n+\tprivate static final int MAX_SIZE_DIFF = 100;\n \n \tprivate ZipSecurity() {}",
    "output": "Upgrade ZipSecurity.java Changes max diff size to prevent valid resources filtration"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/JadxGUI.java b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxGUI.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java\n@@ -5,6 +5,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.core.utils.exceptions.JadxException;\n import jadx.gui.settings.JadxSettings;\n import jadx.gui.settings.JadxSettingsAdapter;\n import jadx.gui.ui.MainWindow;\n@@ -24,8 +25,13 @@ public static void main(String[] args) {\n \t\t\tUIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n \t\t\tSwingUtilities.invokeLater(new Runnable() {\n \t\t\t\tpublic void run() {\n-\t\t\t\t\tMainWindow window = new MainWindow(jadxArgs);\n-\t\t\t\t\twindow.open();\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tMainWindow window = new MainWindow(jadxArgs);\n+\t\t\t\t\t\twindow.open();\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch(JadxException e) {\n+\t\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t});\n \t\t} catch (Throwable e) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n@@ -22,7 +22,7 @@ public class JadxWrapper {\n \tprivate final JadxDecompiler decompiler;\n \tprivate File openFile;\n \n-\tpublic JadxWrapper(IJadxArgs jadxArgs) {\n+\tpublic JadxWrapper(IJadxArgs jadxArgs) throws JadxException {\n \t\tthis.decompiler = new JadxDecompiler(jadxArgs);\n \t}\n \n@@ -53,7 +53,7 @@ public void run() {\n \t\t\t\t\t}\n \t\t\t\t\tprogressMonitor.close();\n \t\t\t\t\tLOG.info(\"done\");\n-\t\t\t\t} catch (InterruptedException e) {\n+\t\t\t\t} catch (InterruptedException|JadxException e) {\n \t\t\t\t\tLOG.error(\"Save interrupted\", e);\n \t\t\t\t\tThread.currentThread().interrupt();\n \t\t\t\t}\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java\n@@ -32,6 +32,7 @@\n import org.slf4j.LoggerFactory;\n \n import jadx.api.ResourceFile;\n+import jadx.core.utils.exceptions.JadxException;\n import jadx.gui.JadxWrapper;\n import jadx.gui.jobs.BackgroundWorker;\n import jadx.gui.jobs.DecompileJob;\n@@ -100,7 +101,7 @@ public class MainWindow extends JFrame {\n \tprivate transient ProgressPanel progressPane;\n \tprivate transient BackgroundWorker backgroundWorker;\n \n-\tpublic MainWindow(JadxSettings settings) {\n+\tpublic MainWindow(JadxSettings settings) throws JadxException {\n \t\tthis.wrapper = new JadxWrapper(settings);\n \t\tthis.settings = settings;\n \t\tthis.cacheObject = new CacheObject();\n\ndiff --git a/jadx-gui/src/test/java/jadx/gui/treemodel/JSourcesTest.java b/jadx-gui/src/test/java/jadx/gui/treemodel/JSourcesTest.java\n--- a/jadx-gui/src/test/java/jadx/gui/treemodel/JSourcesTest.java\n+++ b/jadx-gui/src/test/java/jadx/gui/treemodel/JSourcesTest.java\n@@ -12,6 +12,7 @@\n import jadx.api.JavaClass;\n import jadx.api.JavaPackage;\n import jadx.core.dex.nodes.ClassNode;\n+import jadx.core.utils.exceptions.JadxException;\n import jadx.gui.JadxWrapper;\n \n import static org.junit.Assert.assertEquals;\n@@ -24,7 +25,7 @@ public class JSourcesTest {\n \tprivate JadxDecompiler decompiler;\n \n \t@Before\n-\tpublic void init() {\n+\tpublic void init() throws JadxException {\n \t\tJRoot root = mock(JRoot.class);\n \t\twhen(root.isFlatPackages()).thenReturn(false);\n \t\tJadxWrapper wrapper = mock(JadxWrapper.class);",
    "output": "Fix build issues"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n@@ -48,7 +48,7 @@ public class JadxCLIArgs implements IJadxArgs {\n \tprotected boolean showInconsistentCode = false;\n \n \t@Parameter(names = {\"--no-imports\"}, converter = InvertedBooleanConverter.class,\n-\t\t\tdescription = \"disables use of imports, always writes entire package name\")\n+\t\t\tdescription = \"disable use of imports, always write entire package name\")\n \tprotected boolean useImports = true;\n \n \t@Parameter(names = \"--no-replace-consts\", converter = InvertedBooleanConverter.class,",
    "output": "Upgrade JadxCLIArgs.java"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxArgs.java b/jadx-core/src/main/java/jadx/api/JadxArgs.java\n--- a/jadx-core/src/main/java/jadx/api/JadxArgs.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java\n@@ -14,7 +14,7 @@ public class JadxArgs implements IJadxArgs {\n \tprivate boolean fallbackMode = false;\n \tprivate boolean showInconsistentCode = false;\n \t\n-\tprivate boolean useImports = false;\n+\tprivate boolean useImports = true;\n \n \tprivate boolean isSkipResources = false;\n \tprivate boolean isSkipSources = false;",
    "output": "Upgrade JadxArgs.java Changes flags to true"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n@@ -10,7 +10,7 @@ public class ZipSecurity {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ZipSecurity.class);\n \t\n \t// size of uncompressed zip entry shouldn't be bigger of compressed in MAX_SIZE_DIFF times\n-\tprivate static final int MAX_SIZE_DIFF = 10;\n+\tprivate static final int MAX_SIZE_DIFF = 25;\n \t\n \tprivate static boolean isInSubDirectory(File base, File file) {\n \t    if (file == null) {\n@@ -45,6 +45,8 @@ public static boolean isZipBomb(ZipEntry entry) {\n \t\tlong compressedSize   = entry.getCompressedSize();\n \t\tlong uncompressedSize = entry.getSize();\n \t\tif(compressedSize < 0 || uncompressedSize < 0) {\n+\t\t\tLOG.error(\"Zip bomp attack detected, invalid sizes: compressed {}, uncompressed {}, name {}\",\n+\t\t\t\t\tcompressedSize, uncompressedSize, entry.getName());\n \t\t\treturn true;\n \t\t}\n \t\tif(compressedSize * MAX_SIZE_DIFF < uncompressedSize) {",
    "output": "Change MAX_SIZE_DIFF in ZipSecurity, and adds extra logging"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java\n@@ -3,6 +3,7 @@\n import jadx.api.CodePosition;\n import jadx.core.dex.attributes.nodes.LineAttrNode;\n import jadx.core.utils.files.FileUtils;\n+import jadx.core.utils.files.ZipSecurity;\n \n import java.io.File;\n import java.io.PrintWriter;\n@@ -272,10 +273,16 @@ public String toString() {\n \t}\n \n \tpublic void save(File dir, String subDir, String fileName) {\n+\t\tif(!ZipSecurity.isValidZipEntryName(subDir) || !ZipSecurity.isValidZipEntryName(fileName)) {\n+\t\t\treturn;\n+\t\t}\n \t\tsave(dir, new File(subDir, fileName).getPath());\n \t}\n \n \tpublic void save(File dir, String fileName) {\n+\t\tif(!ZipSecurity.isValidZipEntryName(fileName)) {\n+\t\t\treturn;\n+\t\t}\n \t\tsave(new File(dir, fileName));\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java b/jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java\n@@ -4,6 +4,7 @@\n import jadx.core.codegen.CodeWriter;\n import jadx.core.dex.nodes.ClassNode;\n import jadx.core.utils.exceptions.CodegenException;\n+import jadx.core.utils.files.ZipSecurity;\n \n import java.io.File;\n \n@@ -25,7 +26,7 @@ public boolean visit(ClassNode cls) throws CodegenException {\n \tpublic static void save(File dir, IJadxArgs args, ClassNode cls) {\n \t\tCodeWriter clsCode = cls.getCode();\n \t\tString fileName = cls.getClassInfo().getFullPath() + \".java\";\n-\t\tif (args.isFallbackMode()) {\n+  \t\tif (args.isFallbackMode()) {\n \t\t\tfileName += \".jadx\";\n \t\t}\n \t\tclsCode.save(dir, fileName);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n@@ -10,7 +10,7 @@ public class ZipSecurity {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ZipSecurity.class);\n \t\n \t// size of uncompressed zip entry shouldn't be bigger of compressed in MAX_SIZE_DIFF times\n-\tprivate static final int MAX_SIZE_DIFF = 5;\n+\tprivate static final int MAX_SIZE_DIFF = 10;\n \t\n \tprivate static boolean isInSubDirectory(File base, File file) {\n \t    if (file == null) {\n@@ -32,11 +32,11 @@ public static boolean isValidZipEntryName(String entryName) {\n \t\t\tif(isInSubDirectory(currentPath, canonical)) {\n \t\t\t\treturn true;\n \t\t\t}\n-\t\t\tLOG.debug(\"Path traversal attack detected, invalid name: {}\", entryName);\n+\t\t\tLOG.error(\"Path traversal attack detected, invalid name: {}\", entryName);\n \t\t\treturn false;\n \t\t}\n \t\tcatch(Exception e) {\n-\t\t\tLOG.debug(\"Path traversal attack detected, invalid name: {}\", entryName);\n+\t\t\tLOG.error(\"Path traversal attack detected, invalid name: {}\", entryName);\n \t\t\treturn false;\n \t\t}\n \t}\n@@ -48,7 +48,8 @@ public static boolean isZipBomb(ZipEntry entry) {\n \t\t\treturn true;\n \t\t}\n \t\tif(compressedSize * MAX_SIZE_DIFF < uncompressedSize) {\n-\t\t\tLOG.debug(\"Zip bomp attack detected, invalid sizes: compressed {}, uncompressed {}\", compressedSize, uncompressedSize);\n+\t\t\tLOG.error(\"Zip bomp attack detected, invalid sizes: compressed {}, uncompressed {}, name {}\",\n+\t\t\t\t\tcompressedSize, uncompressedSize, entry.getName());\n \t\t\treturn true;\n \t\t}\n \t\treturn false;",
    "output": "Add more checks for file write ops"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourceFile.java b/jadx-core/src/main/java/jadx/api/ResourceFile.java\n--- a/jadx-core/src/main/java/jadx/api/ResourceFile.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java\n@@ -1,5 +1,6 @@\n package jadx.api;\n \n+import jadx.core.utils.files.ZipSecurity;\n import jadx.core.xmlgen.ResContainer;\n \n import java.io.File;\n@@ -34,7 +35,7 @@ public String toString() {\n \tprivate final ResourceType type;\n \tprivate ZipRef zipRef;\n \n-\tResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {\n+\tprotected ResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {\n \t\tthis.decompiler = decompiler;\n \t\tthis.name = name;\n \t\tthis.type = type;\n@@ -64,4 +65,11 @@ public ZipRef getZipRef() {\n \tpublic String toString() {\n \t\treturn \"ResourceFile{name='\" + name + '\\'' + \", type=\" + type + \"}\";\n \t}\n+\t\n+\tpublic static ResourceFile createResourceFileInstance(JadxDecompiler decompiler, String name, ResourceType type) {\n+\t\tif(!ZipSecurity.isValidZipEntryName(name)) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn new ResourceFile(decompiler, name, type);\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/api/ResourceFileContent.java b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java\n--- a/jadx-core/src/main/java/jadx/api/ResourceFileContent.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java\n@@ -1,13 +1,14 @@\n package jadx.api;\n \n import jadx.core.codegen.CodeWriter;\n+import jadx.core.utils.files.ZipSecurity;\n import jadx.core.xmlgen.ResContainer;\n \n public class ResourceFileContent extends ResourceFile {\n \n \tprivate final CodeWriter content;\n \n-\tpublic ResourceFileContent(String name, ResourceType type, CodeWriter content) {\n+\tprivate ResourceFileContent(String name, ResourceType type, CodeWriter content) {\n \t\tsuper(null, name, type);\n \t\tthis.content = content;\n \t}\n@@ -16,4 +17,11 @@ public ResourceFileContent(String name, ResourceType type, CodeWriter content) {\n \tpublic ResContainer loadContent() {\n \t\treturn ResContainer.singleFile(getName(), content);\n \t}\n+\t\n+\tpublic static ResourceFileContent createResourceFileContentInstance(String name, ResourceType type, CodeWriter content) {\n+\t\tif(!ZipSecurity.isValidZipEntryName(name)) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn new ResourceFileContent(name, type, content);\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n--- a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n@@ -157,8 +157,10 @@ private void loadFile(List<ResourceFile> list, File file) {\n \tprivate void addResourceFile(List<ResourceFile> list, File file) {\n \t\tString name = file.getAbsolutePath();\n \t\tResourceType type = ResourceType.getFileType(name);\n-\t\tResourceFile rf = new ResourceFile(jadxRef, name, type);\n-\t\tlist.add(rf);\n+\t\tResourceFile rf = ResourceFile.createResourceFileInstance(jadxRef, name, type);\n+\t\tif(rf != null) {\n+\t\t\tlist.add(rf);\n+\t\t}\n \t}\n \n \tprivate void addEntry(List<ResourceFile> list, File zipFile, ZipEntry entry) {\n@@ -167,9 +169,11 @@ private void addEntry(List<ResourceFile> list, File zipFile, ZipEntry entry) {\n \t\t}\n \t\tString name = entry.getName();\n \t\tResourceType type = ResourceType.getFileType(name);\n-\t\tResourceFile rf = new ResourceFile(jadxRef, name, type);\n-\t\trf.setZipRef(new ZipRef(zipFile, name));\n-\t\tlist.add(rf);\n+\t\tResourceFile rf = ResourceFile.createResourceFileInstance(jadxRef, name, type);\n+\t\tif(rf != null) {\n+\t\t\trf.setZipRef(new ZipRef(zipFile, name));\n+\t\t\tlist.add(rf);\n+\t\t}\n \t}\n \n \tpublic static CodeWriter loadToCodeWriter(InputStream is) throws IOException {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n@@ -3,7 +3,12 @@\n import java.io.File;\n import java.util.zip.ZipEntry;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n public class ZipSecurity {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(ZipSecurity.class);\n+\t\n \t// size of uncompressed zip entry shouldn't be bigger of compressed in MAX_SIZE_DIFF times\n \tprivate static final int MAX_SIZE_DIFF = 5;\n \t\n@@ -24,9 +29,14 @@ public static boolean isValidZipEntryName(String entryName) {\n \t\ttry {\n \t\t\tFile currentPath = new File(\".\").getCanonicalFile();\n \t\t\tFile canonical = new File(currentPath, entryName).getCanonicalFile();\n-\t\t\treturn isInSubDirectory(currentPath, canonical);\n+\t\t\tif(isInSubDirectory(currentPath, canonical)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tLOG.debug(\"Path traversal attack detected, invalid name: {}\", entryName);\n+\t\t\treturn false;\n \t\t}\n \t\tcatch(Exception e) {\n+\t\t\tLOG.debug(\"Path traversal attack detected, invalid name: {}\", entryName);\n \t\t\treturn false;\n \t\t}\n \t}\n@@ -37,7 +47,11 @@ public static boolean isZipBomb(ZipEntry entry) {\n \t\tif(compressedSize < 0 || uncompressedSize < 0) {\n \t\t\treturn true;\n \t\t}\n-\t\treturn compressedSize * MAX_SIZE_DIFF < uncompressedSize;\n+\t\tif(compressedSize * MAX_SIZE_DIFF < uncompressedSize) {\n+\t\t\tLOG.debug(\"Zip bomp attack detected, invalid sizes: compressed {}, uncompressed {}\", compressedSize, uncompressedSize);\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n \t}\n \t\n \tpublic static boolean isValidZipEntry(ZipEntry entry) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java\n@@ -101,8 +101,10 @@ private void addSubFiles(ResContainer rc, JResource root, int depth) {\n \t\t\t\tString resName = rc.getName();\n \t\t\t\tString[] path = resName.split(\"/\");\n \t\t\t\tString resShortName = path.length == 0 ? resName : path[path.length - 1];\n-\t\t\t\tResourceFileContent fileContent = new ResourceFileContent(resShortName, ResourceType.XML, cw);\n-\t\t\t\taddPath(path, root, new JResource(fileContent, resName, resShortName, JResType.FILE));\n+\t\t\t\tResourceFileContent fileContent = ResourceFileContent.createResourceFileContentInstance(resShortName, ResourceType.XML, cw);\n+\t\t\t\tif(fileContent != null) {\n+\t\t\t\t\taddPath(path, root, new JResource(fileContent, resName, resShortName, JResType.FILE));\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tList<ResContainer> subFiles = rc.getSubFiles();",
    "output": "Add checks for resources, and logs detected attacks"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n--- a/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java\n@@ -5,6 +5,7 @@\n import jadx.core.utils.Utils;\n import jadx.core.utils.exceptions.JadxException;\n import jadx.core.utils.files.InputFile;\n+import jadx.core.utils.files.ZipSecurity;\n import jadx.core.xmlgen.ResContainer;\n import jadx.core.xmlgen.ResTableParser;\n \n@@ -64,6 +65,10 @@ public static ResContainer decodeStream(ResourceFile rf, ResourceDecoder decoder\n \t\t\tif (entry == null) {\n \t\t\t\tthrow new IOException(\"Zip entry not found: \" + zipRef);\n \t\t\t}\n+\t\t\tif(!ZipSecurity.isValidZipEntry(entry)) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\t\n \t\t\tinputStream = new BufferedInputStream(zipFile.getInputStream(entry));\n \t\t\tresult = decoder.decode(entry.getSize(), inputStream);\n \t\t} catch (Exception e) {\n@@ -129,7 +134,9 @@ private void loadFile(List<ResourceFile> list, File file) {\n \t\t\tEnumeration<? extends ZipEntry> entries = zip.entries();\n \t\t\twhile (entries.hasMoreElements()) {\n \t\t\t\tZipEntry entry = entries.nextElement();\n-\t\t\t\taddEntry(list, file, entry);\n+\t\t\t\tif(ZipSecurity.isValidZipEntry(entry)) {\n+\t\t\t\t\taddEntry(list, file, entry);\n+\t\t\t\t}\n \t\t\t}\n \t\t} catch (IOException e) {\n \t\t\tLOG.debug(\"Not a zip file: {}\", file.getAbsolutePath());\n\ndiff --git a/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java\n--- a/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java\n+++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java\n@@ -6,6 +6,7 @@\n import jadx.core.utils.exceptions.DecodeException;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.core.utils.files.FileUtils;\n+import jadx.core.utils.files.ZipSecurity;\n \n import java.io.BufferedOutputStream;\n import java.io.DataInputStream;\n@@ -173,7 +174,7 @@ public void load(File input) throws IOException, DecodeException {\n \t\t\t\ttry {\n \t\t\t\t\tZipEntry entry = in.getNextEntry();\n \t\t\t\t\twhile (entry != null) {\n-\t\t\t\t\t\tif (entry.getName().endsWith(CLST_EXTENSION)) {\n+\t\t\t\t\t\tif (entry.getName().endsWith(CLST_EXTENSION) && ZipSecurity.isValidZipEntry(entry)) {\n \t\t\t\t\t\t\tload(in);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tentry = in.getNextEntry();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n@@ -88,6 +88,13 @@ private boolean loadFromZip(String ext) throws IOException, DecodeException {\n \t\t\tif (entry == null) {\n \t\t\t\tbreak;\n \t\t\t}\n+\t\t\t\n+\t\t\t// security check\n+\t\t\tif(!ZipSecurity.isValidZipEntry(entry)) {\n+\t\t\t\tindex++;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t\n \t\t\tInputStream inputStream = zf.getInputStream(entry);\n \t\t\ttry {\n \t\t\t\tif (ext.equals(\".dex\")) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java\n@@ -0,0 +1,47 @@\n+package jadx.core.utils.files;\n+\n+import java.io.File;\n+import java.util.zip.ZipEntry;\n+\n+public class ZipSecurity {\n+\t// size of uncompressed zip entry shouldn't be bigger of compressed in MAX_SIZE_DIFF times\n+\tprivate static final int MAX_SIZE_DIFF = 5;\n+\t\n+\tprivate static boolean isInSubDirectory(File base, File file) {\n+\t    if (file == null) {\n+\t        return false;\n+\t    }\n+\t    if (file.equals(base)) {\n+\t        return true;\n+\t    }\n+\n+\t    return isInSubDirectory(base, file.getParentFile());\n+\t}\n+\t\n+\t// checks that entry name contains no any traversals\n+\t// and prevents cases like \"../classes.dex\", to limit output only to the specified directory\n+\tpublic static boolean isValidZipEntryName(String entryName) {\n+\t\ttry {\n+\t\t\tFile currentPath = new File(\".\").getCanonicalFile();\n+\t\t\tFile canonical = new File(currentPath, entryName).getCanonicalFile();\n+\t\t\treturn isInSubDirectory(currentPath, canonical);\n+\t\t}\n+\t\tcatch(Exception e) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+\tpublic static boolean isZipBomb(ZipEntry entry) {\n+\t\tlong compressedSize   = entry.getCompressedSize();\n+\t\tlong uncompressedSize = entry.getSize();\n+\t\tif(compressedSize < 0 || uncompressedSize < 0) {\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn compressedSize * MAX_SIZE_DIFF < uncompressedSize;\n+\t}\n+\t\n+\tpublic static boolean isValidZipEntry(ZipEntry entry) {\n+\t\treturn isValidZipEntryName(entry.getName())\n+\t\t\t\t&& !isZipBomb(entry);\n+\t}\n+}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java\n@@ -3,7 +3,6 @@\n import jadx.core.utils.exceptions.JadxException;\n \n import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import java.io.IOException;\n import java.io.InputStream;\n@@ -72,7 +71,7 @@ private Document loadXML(String xml) throws JadxException, ParserConfigurationEx\n \t\t\tif (xmlStream == null) {\n \t\t\t\tthrow new JadxException(xml + \" not found in classpath\");\n \t\t\t}\n-\t\t\tDocumentBuilder dBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n+\t\t\tDocumentBuilder dBuilder = XmlSecurity.getSecureDbf().newDocumentBuilder();\n \t\t\tdoc = dBuilder.parse(xmlStream);\n \t\t} finally {\n \t\t\tclose(xmlStream);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/XmlSecurity.java b/jadx-core/src/main/java/jadx/core/xmlgen/XmlSecurity.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/XmlSecurity.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/XmlSecurity.java\n@@ -0,0 +1,26 @@\n+package jadx.core.xmlgen;\n+\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+\n+public class XmlSecurity {\n+\tprivate static DocumentBuilderFactory secureDbf = null;\n+\t\n+\tpublic static DocumentBuilderFactory getSecureDbf() throws ParserConfigurationException {\n+\t\tsynchronized(XmlSecurity.class) {\n+\t\t\tif(secureDbf == null) {\n+\t\t\t\tsecureDbf = DocumentBuilderFactory.newInstance();\n+\t\t\t\tsecureDbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n+\t\t\t\tsecureDbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n+\t            secureDbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+\t            secureDbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+\t            secureDbf.setFeature(\"http://apache.org/xml/features/dom/create-entity-ref-nodes\", false);\n+\t            secureDbf.setXIncludeAware(false);\n+\t            secureDbf.setExpandEntityReferences(false);\n+\t\t\t}\n+\t\t}\n+\t\treturn secureDbf;\n+\t}\n+\t\n+\t\n+}",
    "output": "Fix for ZIP and XML processors"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java\n@@ -453,15 +453,18 @@ public static BlockNode getPathCross(MethodNode mth, BlockNode b1, BlockNode b2)\n \t */\n \tpublic static List<BlockNode> collectBlocksDominatedBy(BlockNode dominator, BlockNode start) {\n \t\tList<BlockNode> result = new ArrayList<BlockNode>();\n-\t\tcollectWhileDominates(dominator, start, result);\n+\t\tHashSet<BlockNode> visited = new HashSet<BlockNode>();\n+\t\tcollectWhileDominates(dominator, start, result, visited);\n \t\treturn result;\n \t}\n \n-\tprivate static void collectWhileDominates(BlockNode dominator, BlockNode child, List<BlockNode> result) {\n+\tprivate static void collectWhileDominates(BlockNode dominator, BlockNode child, List<BlockNode> result, HashSet<BlockNode> visited) {\n+\t\tif (visited.contains(child)) return;\n+\t\tvisited.add(child);\n \t\tfor (BlockNode node : child.getCleanSuccessors()) {\n \t\t\tif (node.isDominator(dominator)) {\n \t\t\t\tresult.add(node);\n-\t\t\t\tcollectWhileDominates(dominator, node, result);\n+\t\t\t\tcollectWhileDominates(dominator, node, result, visited);\n \t\t\t}\n \t\t}\n \t}",
    "output": "Fix issue #184 please refer to https://github.com/skylot/jadx/issues/184"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java\n--- a/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java\n+++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java\n@@ -23,7 +23,7 @@\n public class ClspGraph {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(ClspGraph.class);\n \n-\tprivate final Map<String, Set<String>> ancestorCache = new WeakHashMap<String, Set<String>>();\n+\tprivate final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());\n \tprivate Map<String, NClass> nameMap;\n \n \tprivate final Set<String> missingClasses = new HashSet<String>();",
    "output": "Fix thread-safe bug wrap WeakHashMap with Collections.synchronizedMap, because it can be used by many worker threads."
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -66,9 +66,9 @@ public final class JadxDecompiler {\n \n \tprivate BinaryXMLParser xmlParser;\n \n-\tprivate Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();\n-\tprivate Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();\n-\tprivate Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();\n+\tprivate Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();\n+\tprivate Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();\n+\tprivate Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();\n \n \tpublic JadxDecompiler() {\n \t\tthis(new JadxArgs());",
    "output": "Fix thread-safe bug Change HashMap to ConcurrentHashMap, because it can be used by many worker threads."
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java\n@@ -339,6 +339,10 @@ private void addFields(CodeWriter code) throws CodegenException {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tannotationGen.addForField(code, f);\n+\n+\t\t\tif(f.getFieldInfo().isRenamed()) {\n+\t\t\t\tcode.startLine(\"/* renamed from: \").add(f.getName()).add(\" */\");\n+\t\t\t}\n \t\t\tcode.startLine(f.getAccessFlags().makeString());\n \t\t\tuseType(code, f.getType());\n \t\t\tcode.add(' ');\n@@ -586,9 +590,8 @@ private void insertSourceFileInfo(CodeWriter code, AttrNode node) {\n \n \tprivate void insertRenameInfo(CodeWriter code, ClassNode cls) {\n \t\tClassInfo classInfo = cls.getClassInfo();\n-\t\tif (classInfo.isRenamed()\n-\t\t\t\t&& !cls.getShortName().equals(cls.getAlias().getShortName())) {\n-\t\t\tcode.startLine(\"/* renamed from: \").add(classInfo.getFullName()).add(\" */\");\n+\t\tif (classInfo.isRenamed()) {\n+\t\t\tcode.startLine(\"/* renamed from: \").add(classInfo.getType().getObject()).add(\" */\");\n \t\t}\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java\n@@ -80,6 +80,10 @@ public boolean addDefinition(CodeWriter code) {\n \t\tif (clsAccFlags.isAnnotation()) {\n \t\t\tai = ai.remove(AccessFlags.ACC_PUBLIC);\n \t\t}\n+\n+\t\tif(mth.getMethodInfo().isRenamed()) {\n+\t\t\tcode.startLine(\"/* renamed from: \").add(mth.getName()).add(\" */\");\n+\t\t}\n \t\tcode.startLineWithNum(mth.getSourceLine());\n \t\tcode.add(ai.makeString());",
    "output": "Fix issue where deobfuscated classes,methods,and fields were not being commented with their original name."
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -16,7 +16,6 @@\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -111,22 +110,23 @@ private void process() {\n \tprivate void postProcess() {\n \t\tint id = 1;\n \t\tfor (OverridedMethodsNode o : ovrd) {\n-\n-\t\t\tIterator<MethodInfo> it = o.getMethods().iterator();\n-\t\t\tif (it.hasNext()) {\n-\t\t\t\tMethodInfo mth = it.next();\n-\n-\t\t\t\tif (mth.isRenamed() && !mth.isAliasFromPreset()) {\n-\t\t\t\t\tmth.setAlias(String.format(\"mo%d%s\", id, makeName(mth.getName())));\n+\t\t\tboolean aliasFromPreset = false;\n+\t\t\tString aliasToUse = null;\n+\t\t\tfor(MethodInfo mth : o.getMethods()){\n+\t\t\t\tif(mth.isAliasFromPreset()) {\n+\t\t\t\t\taliasToUse = mth.getAlias();\n+\t\t\t\t\taliasFromPreset = true;\n \t\t\t\t}\n-\t\t\t\tString firstMethodAlias = mth.getAlias();\n-\n-\t\t\t\twhile (it.hasNext()) {\n-\t\t\t\t\tmth = it.next();\n-\t\t\t\t\tif (!mth.getAlias().equals(firstMethodAlias)) {\n-\t\t\t\t\t\tmth.setAlias(firstMethodAlias);\n+\t\t\t}\n+\t\t\tfor(MethodInfo mth : o.getMethods()){\n+\t\t\t\tif(aliasToUse == null) {\n+\t\t\t\t\tif (mth.isRenamed() && !mth.isAliasFromPreset()) {\n+\t\t\t\t\t\tmth.setAlias(String.format(\"mo%d%s\", id, makeName(mth.getName())));\n \t\t\t\t\t}\n+\t\t\t\t\taliasToUse = mth.getAlias();\n \t\t\t\t}\n+\t\t\t\tmth.setAlias(aliasToUse);\n+\t\t\t\tmth.setAliasFromPreset(aliasFromPreset);\n \t\t\t}\n \n \t\t\tid++;",
    "output": "Fix issue where postProcess may overwrite Deobfuscated method names. The function will now check if the method name was aliased by Deobfuscation and if so it will use that name for all the overriden methods. Note: If the deobfuscation file contains two names for the same overriden method in two related Classes then the name that \"wins\" is non-deterministic."
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n@@ -35,12 +35,12 @@ public static ClassInfo fromType(DexNode dex, ArgType type) {\n \t\tif (type.isArray()) {\n \t\t\ttype = ArgType.OBJECT;\n \t\t}\n-\t\tClassInfo cls = dex.getInfoStorage().getCls(type);\n+\t\tClassInfo cls = dex.root().getInfoStorage().getCls(type);\n \t\tif (cls != null) {\n \t\t\treturn cls;\n \t\t}\n \t\tcls = new ClassInfo(dex, type);\n-\t\treturn dex.getInfoStorage().putCls(cls);\n+\t\treturn dex.root().getInfoStorage().putCls(cls);\n \t}\n \n \tpublic static ClassInfo fromDex(DexNode dex, int clsIndex) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java\n@@ -22,7 +22,7 @@ private FieldInfo(ClassInfo declClass, String name, ArgType type) {\n \n \tpublic static FieldInfo from(DexNode dex, ClassInfo declClass, String name, ArgType type) {\n \t\tFieldInfo field = new FieldInfo(declClass, name, type);\n-\t\treturn dex.getInfoStorage().getField(field);\n+\t\treturn dex.root().getInfoStorage().getField(field);\n \t}\n \n \tpublic static FieldInfo fromDex(DexNode dex, int index) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java b/jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java\n@@ -1,6 +1,7 @@\n package jadx.core.dex.info;\n \n import jadx.core.dex.instructions.args.ArgType;\n+import jadx.core.dex.nodes.DexNode;\n \n import java.util.HashMap;\n import java.util.Map;\n@@ -22,13 +23,17 @@ public ClassInfo putCls(ClassInfo cls) {\n \t\t}\n \t}\n \n-\tpublic MethodInfo getMethod(int mtdId) {\n-\t\treturn methods.get(mtdId);\n+\tprivate int generateMethodLookupId(DexNode dex, int mthId) {\n+\t\treturn (dex.getDexId()<<16)|mthId;\n \t}\n \n-\tpublic MethodInfo putMethod(int mthId, MethodInfo mth) {\n+\tpublic MethodInfo getMethod(DexNode dex, int mtdId) {\n+\t\treturn methods.get(generateMethodLookupId(dex,mtdId));\n+\t}\n+\n+\tpublic MethodInfo putMethod(DexNode dex, int mthId, MethodInfo mth) {\n \t\tsynchronized (methods) {\n-\t\t\tMethodInfo prev = methods.put(mthId, mth);\n+\t\t\tMethodInfo prev = methods.put(generateMethodLookupId(dex,mthId), mth);\n \t\t\treturn prev == null ? mth : prev;\n \t\t}\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java\n@@ -34,12 +34,12 @@ private MethodInfo(DexNode dex, int mthIndex) {\n \t}\n \n \tpublic static MethodInfo fromDex(DexNode dex, int mthIndex) {\n-\t\tMethodInfo mth = dex.getInfoStorage().getMethod(mthIndex);\n+\t\tMethodInfo mth = dex.root().getInfoStorage().getMethod(dex, mthIndex);\n \t\tif (mth != null) {\n \t\t\treturn mth;\n \t\t}\n \t\tmth = new MethodInfo(dex, mthIndex);\n-\t\treturn dex.getInfoStorage().putMethod(mthIndex, mth);\n+\t\treturn dex.root().getInfoStorage().putMethod(dex, mthIndex, mth);\n \t}\n \n \tpublic String makeSignature(boolean includeRetType) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java\n@@ -35,16 +35,16 @@ public class DexNode implements IDexNode {\n \tprivate final RootNode root;\n \tprivate final Dex dexBuf;\n \tprivate final DexFile file;\n+\tprivate final int dexId;\n \n \tprivate final List<ClassNode> classes = new ArrayList<ClassNode>();\n \tprivate final Map<ClassInfo, ClassNode> clsMap = new HashMap<ClassInfo, ClassNode>();\n \n-\tprivate final InfoStorage infoStorage = new InfoStorage();\n-\n-\tpublic DexNode(RootNode root, DexFile input) {\n+\tpublic DexNode(RootNode root, DexFile input, int dexId) {\n \t\tthis.root = root;\n \t\tthis.file = input;\n \t\tthis.dexBuf = input.getDexBuf();\n+\t\tthis.dexId = dexId;\n \t}\n \n \tpublic void loadClasses() throws DecodeException {\n@@ -153,10 +153,6 @@ public FieldNode resolveField(FieldInfo field) {\n \t\treturn null;\n \t}\n \n-\tpublic InfoStorage getInfoStorage() {\n-\t\treturn infoStorage;\n-\t}\n-\n \tpublic DexFile getDexFile() {\n \t\treturn file;\n \t}\n@@ -214,6 +210,10 @@ public DexNode dex() {\n \t\treturn this;\n \t}\n \n+\tpublic int getDexId() {\n+\t\treturn dexId;\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn \"DEX\";\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java\n@@ -7,6 +7,7 @@\n import jadx.core.clsp.ClspGraph;\n import jadx.core.dex.info.ClassInfo;\n import jadx.core.dex.info.ConstStorage;\n+import jadx.core.dex.info.InfoStorage;\n import jadx.core.utils.ErrorsCounter;\n import jadx.core.utils.StringUtils;\n import jadx.core.utils.android.AndroidResourcesUtils;\n@@ -34,6 +35,7 @@ public class RootNode {\n \tprivate final IJadxArgs args;\n \tprivate final StringUtils stringUtils;\n \tprivate final ConstStorage constValues;\n+\tprivate final InfoStorage infoStorage = new InfoStorage();\n \n \tprivate List<DexNode> dexNodes;\n \t@Nullable\n@@ -53,7 +55,7 @@ public void load(List<InputFile> inputFiles) throws DecodeException {\n \t\t\tfor (DexFile dexFile : input.getDexFiles()) {\n \t\t\t\ttry {\n \t\t\t\t\tLOG.debug(\"Load: {}\", dexFile);\n-\t\t\t\t\tDexNode dexNode = new DexNode(this, dexFile);\n+\t\t\t\t\tDexNode dexNode = new DexNode(this, dexFile, dexNodes.size());\n \t\t\t\t\tdexNodes.add(dexNode);\n \t\t\t\t} catch (Exception e) {\n \t\t\t\t\tthrow new DecodeException(\"Error decode file: \" + dexFile, e);\n@@ -197,4 +199,9 @@ public StringUtils getStringUtils() {\n \tpublic ConstStorage getConstValues() {\n \t\treturn constValues;\n \t}\n+\n+\tpublic InfoStorage getInfoStorage() {\n+\t\treturn infoStorage;\n+\t}\n+\n }",
    "output": "Fix issue where renamed classes/methods referenced in a different dex file would not be renamed properly. Deobfuscation only modified the Class info for the InfoStorage of the Dex file the class belonged to. If a class in another Dex file referenced it, it would not know of the rename. This commit moves InfoStorage to the RootNode. This allows all classes to know of each other regardless of the Dex file. A dexId field was added to the DexNode class to allow the the MethodInfo.fromDex function to continue to use method index to locate methods. The getMethod and putMethod functions in InfoStorage was modified to take a DexNode. The DexNode id is used to create a unique key used for the lookup into the methods HashMap."
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/NameGen.java b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java\n@@ -164,6 +164,7 @@ private String makeNameForObject(ArgType type) {\n \t\t\tif (vName != null) {\n \t\t\t\treturn vName;\n \t\t\t}\n+\t\t\treturn StringUtils.escape(shortName.toLowerCase());\n \t\t}\n \t\treturn StringUtils.escape(type.toString());\n \t}",
    "output": "Fix issue where name generation on variables of deobfuscated objects were sometimes based off of the original class name, and not the alias."
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n--- a/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java\n@@ -89,6 +89,10 @@ private void splitNames(DexNode dex, boolean canBeInner) {\n \t\tint sep = clsName.lastIndexOf('$');\n \t\tif (canBeInner && sep > 0 && sep != clsName.length() - 1) {\n \t\t\tString parClsName = pkg + \".\" + clsName.substring(0, sep);\n+\t\t\tif(pkg.length() == 0) {\n+\t\t\t\tparClsName = clsName.substring(0, sep);\n+\t\t\t}\n+\n \t\t\tparentClass = fromName(dex, parClsName);\n \t\t\tclsName = clsName.substring(sep + 1);\n \t\t} else {",
    "output": "Fix issue with inner classes and empty package name."
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java\n@@ -11,6 +11,11 @@\n import java.io.OutputStream;\n import java.util.jar.JarEntry;\n import java.util.jar.JarOutputStream;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n \n import org.jetbrains.annotations.NotNull;\n import org.slf4j.Logger;\n@@ -100,4 +105,93 @@ public static File prepareFile(File file) {\n \t\tmakeDirsForFile(file);\n \t\treturn file;\n \t}\n+\n+\t//add by qi\n+\tpublic static String bytesToHex(byte[] bytes) {\n+\t\tchar[] hexArray = \"0123456789abcdef\".toCharArray();\n+\t\tif (bytes == null || bytes.length <= 0) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tchar[] hexChars = new char[bytes.length * 2];\n+\t\tfor ( int j = 0; j < bytes.length; j++ ) {\n+\t\t\tint v = bytes[j] & 0xFF;\n+\t\t\thexChars[j * 2] = hexArray[v >>> 4];\n+\t\t\thexChars[j * 2 + 1] = hexArray[v & 0x0F];\n+\t\t}\n+\t\treturn new String(hexChars);\n+\t}\n+\n+\t//add by qi\n+\tpublic static boolean isZipfile(File file) {\n+\t\tboolean isZipfile = false;\n+\t\tInputStream is = null;\n+\t\ttry {\n+\t\t\tbyte[] headers = new byte[4];\n+\t\t\tis = new FileInputStream(file);\n+\t\t\tis.read(headers, 0, 4);\n+\t\t\tSystem.out.println(bytesToHex(headers));\n+\t\t\tString headerString = bytesToHex(headers);\n+\t\t\tif (headerString.equals(\"504b0304\")) {\n+\t\t\t\tisZipfile = true;\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\te.printStackTrace();\n+\t\t} finally {\n+\t\t\tif (is != null) {\n+\t\t\t\ttry {\n+\t\t\t\t\tis.close();\n+\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\te.printStackTrace();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn isZipfile;\n+\t}\n+\n+\t//add by qi\n+\tpublic static List<String> getZipfileList(File file) {\n+\t\tList<String> filelist = new ArrayList<String>();\n+\t\tZipFile zipFile = null;\n+\t\ttry {\n+\t\t\tzipFile = new ZipFile(file);\n+\t\t\tEnumeration<? extends ZipEntry> entries = zipFile.entries();\n+\n+\t\t\twhile(entries.hasMoreElements()){\n+\t\t\t\tZipEntry entry = entries.nextElement();\n+\t\t\t\tfilelist.add(entry.getName());\n+\t\t\t\tSystem.out.println(entry.getName());\n+\t\t\t}\n+\t\t} catch (IOException e) {\n+\t\t\te.printStackTrace();\n+\t\t\tSystem.out.println(e.getMessage());\n+\t\t}\n+\n+\t\treturn filelist;\n+\t}\n+\n+\t//add by qi\n+\tpublic static boolean isApkfile(File file) {\n+\t\tboolean isApkfile = false;\n+\t\tif (isZipfile(file)) {\n+\t\t\tList<String> filelist = getZipfileList(file);\n+\t\t\tif (filelist.contains(\"AndroidManifest.xml\") && filelist.contains(\"classes.dex\")) {\n+\t\t\t\tisApkfile = true;\n+\t\t\t}\n+\t\t}\n+\t\treturn isApkfile;\n+\t}\n+\n+\t//add by qi\n+\tpublic static boolean isZipDexfile(File file) {\n+\t\tboolean isZipDexFile = false;\n+\t\tif (isZipfile(file)) {\n+\t\t\tList<String> filelist = getZipfileList(file);\n+\t\t\tif (filelist.contains(\"classes.dex\")) {\n+\t\t\t\tisZipDexFile = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn isZipDexFile;\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n@@ -15,13 +15,14 @@\n import java.util.zip.ZipEntry;\n import java.util.zip.ZipFile;\n \n+\n import org.apache.commons.io.IOUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.android.dex.Dex;\n \n-import static jadx.core.utils.files.FileUtils.close;\n+import static jadx.core.utils.files.FileUtils.*;\n \n public class InputFile {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(InputFile.class);\n@@ -44,6 +45,7 @@ private InputFile(File file) throws IOException, DecodeException {\n \n \tprivate void searchDexFiles() throws IOException, DecodeException {\n \t\tString fileName = file.getName();\n+\n \t\tif (fileName.endsWith(\".dex\")) {\n \t\t\taddDexFile(new Dex(file));\n \t\t\treturn;\n@@ -52,7 +54,8 @@ private void searchDexFiles() throws IOException, DecodeException {\n \t\t\taddDexFile(loadFromClassFile(file));\n \t\t\treturn;\n \t\t}\n-\t\tif (fileName.endsWith(\".apk\") || fileName.endsWith(\".zip\")) {\n+\t\t//modifed by qi：add isApkfile() and isZipdexfile()\n+\t\tif (fileName.endsWith(\".apk\") || fileName.endsWith(\".zip\") || isApkfile(file) || isZipDexfile(file)) {\n \t\t\tloadFromZip(\".dex\");\n \t\t\treturn;\n \t\t}",
    "output": "Add file type detect, jadx file by file's header, not only file's extension"
  },
  {
    "input": "diff --git a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n--- a/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java\n@@ -247,7 +247,7 @@ void compile(ClassNode cls) {\n \t}\n \n \tpublic Object invoke(String method) throws Exception {\n-\t\treturn invoke(method, new Class[0]);\n+\t\treturn invoke(method, new Class<?>[0]);\n \t}\n \n \tpublic Object invoke(String method, Class[] types, Object... args) throws Exception {\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java\n--- a/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java\n@@ -35,7 +35,7 @@ public ClassLoader getClassLoader(Location location) {\n \n \tprivate class DynamicClassLoader extends SecureClassLoader {\n \t\tprivate final Map<String, JavaClassObject> clsMap = new HashMap<String, JavaClassObject>();\n-\t\tprivate final Map<String, Class> clsCache = new HashMap<String, Class>();\n+\t\tprivate final Map<String, Class<?>> clsCache = new HashMap<String, Class<?>>();\n \n \t\t@Override\n \t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n@@ -55,7 +55,7 @@ public Class<?> loadClass(String name) throws ClassNotFoundException {\n \t\t}\n \n \t\tpublic Class<?> replaceClass(String name) throws ClassNotFoundException {\n-\t\t\tClass cacheCls = clsCache.get(name);\n+\t\t\tClass<?> cacheCls = clsCache.get(name);\n \t\t\tif (cacheCls != null) {\n \t\t\t\treturn cacheCls;\n \t\t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java b/jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java\n--- a/jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java\n+++ b/jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java\n@@ -58,7 +58,7 @@ private Object getInstance() throws Exception {\n \t}\n \n \tpublic Method getMethod(String method, Class[] types) throws Exception {\n-\t\tfor (Class type : types) {\n+\t\tfor (Class<?> type : types) {\n \t\t\tcheckType(type);\n \t\t}\n \t\treturn getInstance().getClass().getMethod(method, types);\n@@ -68,7 +68,7 @@ public Object invoke(Method mth, Object... args) throws Exception {\n \t\treturn mth.invoke(getInstance(), args);\n \t}\n \n-\tprivate Class<?> checkType(Class type) throws ClassNotFoundException {\n+\tprivate Class<?> checkType(Class<?> type) throws ClassNotFoundException {\n \t\tif (type.isPrimitive()) {\n \t\t\treturn type;\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/functional/JadxVisitorsOrderTest.java b/jadx-core/src/test/java/jadx/tests/functional/JadxVisitorsOrderTest.java\n--- a/jadx-core/src/test/java/jadx/tests/functional/JadxVisitorsOrderTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/functional/JadxVisitorsOrderTest.java\n@@ -34,7 +34,7 @@ public void testOrder() {\n \t}\n \n \tprivate static List<String> check(List<IDexTreeVisitor> passes) {\n-\t\tList<Class> classList = new ArrayList<Class>(passes.size());\n+\t\tList<Class<?>> classList = new ArrayList<Class<?>>(passes.size());\n \t\tfor (IDexTreeVisitor pass : passes) {\n \t\t\tclassList.add(pass.getClass());\n \t\t}\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/integration/others/TestIssue13a.java b/jadx-core/src/test/java/jadx/tests/integration/others/TestIssue13a.java\n--- a/jadx-core/src/test/java/jadx/tests/integration/others/TestIssue13a.java\n+++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestIssue13a.java\n@@ -15,8 +15,8 @@ public class TestIssue13a extends IntegrationTest {\n \n \tpublic static class TestCls {\n \t\tprivate static final String TAG = \"Parcel\";\n-\t\tprivate static final HashMap<ClassLoader, HashMap<String, Parcelable.Creator>>\n-\t\t\t\tmCreators = new HashMap<ClassLoader, HashMap<String, Parcelable.Creator>>();\n+\t\tprivate static final HashMap<ClassLoader, HashMap<String, Parcelable.Creator<?>>>\n+\t\t\t\tmCreators = new HashMap<ClassLoader, HashMap<String, Parcelable.Creator<?>>>();\n \n \t\t@SuppressWarnings(\"unchecked\")\n \t\tpublic final <T extends Parcelable> T test(ClassLoader loader) {\n@@ -26,15 +26,15 @@ public final <T extends Parcelable> T test(ClassLoader loader) {\n \t\t\t}\n \t\t\tParcelable.Creator<T> creator;\n \t\t\tsynchronized (mCreators) {\n-\t\t\t\tHashMap<String, Parcelable.Creator> map = mCreators.get(loader);\n+\t\t\t\tHashMap<String, Parcelable.Creator<?>> map = mCreators.get(loader);\n \t\t\t\tif (map == null) {\n-\t\t\t\t\tmap = new HashMap<String, Parcelable.Creator>();\n+\t\t\t\t\tmap = new HashMap<String, Parcelable.Creator<?>>();\n \t\t\t\t\tmCreators.put(loader, map);\n \t\t\t\t}\n-\t\t\t\tcreator = map.get(name);\n+\t\t\t\tcreator = (Parcelable.Creator<T>) map.get(name);\n \t\t\t\tif (creator == null) {\n \t\t\t\t\ttry {\n-\t\t\t\t\t\tClass c = loader == null ?\n+\t\t\t\t\t\tClass<?> c = loader == null ?\n \t\t\t\t\t\t\t\tClass.forName(name) : Class.forName(name, true, loader);\n \t\t\t\t\t\tField f = c.getField(\"CREATOR\");\n \t\t\t\t\t\tcreator = (Parcelable.Creator) f.get(null);\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n@@ -71,7 +71,7 @@ private JResource getResourceByName(JResource rf, String name) {\n \t}\n \n \tpublic JNode searchClassInTree(JNode node) {\n-\t\tEnumeration en = this.breadthFirstEnumeration();\n+\t\tEnumeration<?> en = this.breadthFirstEnumeration();\n \t\twhile (en.hasMoreElements()) {\n \t\t\tObject obj = en.nextElement();\n \t\t\tif (node.equals(obj)) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java b/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java\n@@ -41,6 +41,7 @@ public final void initUI() {\n \n \t\tJPanel controlPane = new JPanel();\n \t\tcontrolPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n+\t\t@SuppressWarnings(\"unchecked\")\n \t\tfinal JComboBox cb = new JComboBox(LEVEL_ITEMS);\n \t\tcb.setSelectedItem(level);\n \t\tcb.addActionListener(new ActionListener() {",
    "output": "Fix console warnings during compilation (gradle build)"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n@@ -64,6 +64,9 @@ public class JadxCLIArgs implements IJadxArgs {\n \t@Parameter(names = {\"--deobf-rewrite-cfg\"}, description = \"force to save deobfuscation map\")\n \tprotected boolean deobfuscationForceSave = false;\n \n+\t@Parameter(names = {\"--deobf-use-sourcename\"}, description = \"use source file name as class name alias\")\n+\tprotected boolean deobfuscationUseSourceNameAsAlias = false;\n+\n \t@Parameter(names = {\"-h\", \"--help\"}, description = \"print this help\", help = true)\n \tprotected boolean printHelp = false;\n \n@@ -242,4 +245,9 @@ public int getDeobfuscationMaxLength() {\n \tpublic boolean isDeobfuscationForceSave() {\n \t\treturn deobfuscationForceSave;\n \t}\n+\n+\t@Override\n+\tpublic boolean useSourceNameAsClassAlias() {\n+\t\treturn deobfuscationUseSourceNameAsAlias;\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java\n--- a/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java\n+++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java\n@@ -68,4 +68,9 @@ public int getDeobfuscationMaxLength() {\n \tpublic boolean isDeobfuscationForceSave() {\n \t\treturn false;\n \t}\n+\n+\t@Override\n+\tpublic boolean useSourceNameAsClassAlias() {\n+\t\treturn false;\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/api/IJadxArgs.java b/jadx-core/src/main/java/jadx/api/IJadxArgs.java\n--- a/jadx-core/src/main/java/jadx/api/IJadxArgs.java\n+++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java\n@@ -28,4 +28,6 @@ public interface IJadxArgs {\n \tint getDeobfuscationMaxLength();\n \n \tboolean isDeobfuscationForceSave();\n+\n+\tboolean useSourceNameAsClassAlias();\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n--- a/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java\n@@ -45,6 +45,8 @@ public class Deobfuscator {\n \n \tprivate final int maxLength;\n \tprivate final int minLength;\n+\tprivate final boolean useSourceNameAsAlias;\n+\n \tprivate int pkgIndex = 0;\n \tprivate int clsIndex = 0;\n \tprivate int fldIndex = 0;\n@@ -56,6 +58,7 @@ public Deobfuscator(IJadxArgs args, @NotNull List<DexNode> dexNodes, File deobfM\n \n \t\tthis.minLength = args.getDeobfuscationMinLength();\n \t\tthis.maxLength = args.getDeobfuscationMaxLength();\n+\t\tthis.useSourceNameAsAlias = args.useSourceNameAsClassAlias();\n \n \t\tthis.deobfPresets = new DeobfPresets(this, deobfMapFile);\n \t}\n@@ -212,7 +215,12 @@ public String getClsAlias(ClassNode cls) {\n \n \tprivate String makeClsAlias(ClassNode cls) {\n \t\tClassInfo classInfo = cls.getClassInfo();\n-\t\tString alias = getAliasFromSourceFile(cls);\n+\t\tString alias = null;\n+\n+\t\tif (this.useSourceNameAsAlias) {\n+\t\t\talias = getAliasFromSourceFile(cls);\n+\t\t}\n+\n \t\tif (alias == null) {\n \t\t\tString clsName = classInfo.getShortName();\n \t\t\talias = String.format(\"C%04d%s\", clsIndex++, makeName(clsName));\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java\n@@ -132,6 +132,10 @@ public void setDeobfuscationForceSave(boolean deobfuscationForceSave) {\n \t\tthis.deobfuscationForceSave = deobfuscationForceSave;\n \t}\n \n+\tpublic void setUseSourceNameAsClassAlias(boolean useSourceNameAsAlias) {\n+\t\tthis.deobfuscationUseSourceNameAsAlias = useSourceNameAsAlias;\n+\t}\n+\n \tpublic Font getFont() {\n \t\tif (fontStr.isEmpty()) {\n \t\t\treturn DEFAULT_FONT;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n--- a/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java\n@@ -141,11 +141,21 @@ public void stateChanged(ChangeEvent e) {\n \t\t\t}\n \t\t});\n \n+\t\tJCheckBox deobfSourceAlias = new JCheckBox();\n+\t\tdeobfSourceAlias.setSelected(settings.useSourceNameAsClassAlias());\n+\t\tdeobfSourceAlias.addItemListener(new ItemListener() {\n+\t\t\tpublic void itemStateChanged(ItemEvent e) {\n+\t\t\t\tsettings.setUseSourceNameAsClassAlias(e.getStateChange() == ItemEvent.SELECTED);\n+\t\t\t\tneedReload();\n+\t\t\t}\n+\t\t});\n+\n \t\tSettingsGroup deobfGroup = new SettingsGroup(NLS.str(\"preferences.deobfuscation\"));\n \t\tdeobfGroup.addRow(NLS.str(\"preferences.deobfuscation_on\"), deobfOn);\n \t\tdeobfGroup.addRow(NLS.str(\"preferences.deobfuscation_force\"), deobfForce);\n \t\tdeobfGroup.addRow(NLS.str(\"preferences.deobfuscation_min_len\"), minLen);\n \t\tdeobfGroup.addRow(NLS.str(\"preferences.deobfuscation_max_len\"), maxLen);\n+\t\tdeobfGroup.addRow(NLS.str(\"preferences.deobfuscation_source_alias\"), deobfSourceAlias);\n \t\tdeobfGroup.end();\n \t\treturn deobfGroup;\n \t}",
    "output": "Make optional using source file name as alias for class name (some obfuscator\nset the source file property with wrong value and break deobfuscation)\ndefault: disabled"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -108,7 +108,25 @@ public void loadFiles(List<File> files) throws JadxException {\n \t\tparse();\n \t}\n \n+\tpublic void parseAndSaveXML() {\n+\t\tif (this.args.isXMLTest()) {\n+\t\t\tInputFile inf = inputFiles.get(0);\n+\t\t\ttry {\n+\t\t\t\tbyte[] buffer = InputFile.loadXMLBuffer(inf.getFile());\n+\t\t\t\tif (buffer != null) {\n+\t\t\t\t\tFile out = new File(outDir, \"AndroidManifest.xml\");\n+\t\t\t\t\tBinaryXMLParser bxp = new BinaryXMLParser(root);\n+\t\t\t\t\tbxp.parse(buffer, out);\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tLOG.info(\"Decompiling AndroidManifest.xml failed!\", e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tpublic void save() {\n+\t\tparseAndSaveXML();\n+\n \t\ttry {\n \t\t\tExecutorService ex = getSaveExecutor();\n \t\t\tex.shutdown();\n@@ -204,20 +222,6 @@ void parse() throws DecodeException {\n \t\troot = new RootNode();\n \t\tLOG.info(\"loading ...\");\n \t\troot.load(inputFiles);\n-\n-\t\tif (this.args.isXMLTest()) {\n-\t\t\tInputFile inf = inputFiles.get(0);\n-\t\t\ttry {\n-\t\t\t\tbyte[] buffer = InputFile.loadXMLBuffer(inf.getFile());\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tFile out = new File(args.getOutDir(), \"AndroidManifest.xml\");\n-\t\t\t\t\tBinaryXMLParser bxp = new BinaryXMLParser(root);\n-\t\t\t\t\tbxp.parse(buffer, out);\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tLOG.info(\"Decompiling AndroidManifest.xml failed!\", e);\n-\t\t\t}\n-\t\t}\n \t}\n \n \tvoid processClass(ClassNode cls) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n--- a/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java\n@@ -42,6 +42,7 @@ public void saveAll(final File dir, final ProgressMonitor progressMonitor) {\n \t\t\tpublic void run() {\n \t\t\t\ttry {\n \t\t\t\t\tdecompiler.setOutputDir(dir);\n+\t\t\t\t\tdecompiler.parseAndSaveXML();\n \t\t\t\t\tThreadPoolExecutor ex = (ThreadPoolExecutor) decompiler.getSaveExecutor();\n \t\t\t\t\tex.shutdown();\n \t\t\t\t\twhile (ex.isTerminating()) {",
    "output": "Fix save AndroidManifest.xml when jadx-gui used"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java\n@@ -47,6 +47,9 @@ public final class JadxCLIArgs implements IJadxArgs {\n \t@Parameter(names = {\"-h\", \"--help\"}, description = \"print this help\", help = true)\n \tprotected boolean printHelp = false;\n \n+\t@Parameter(names = {\"-x\", \"--xml\"}, description = \"try to decode the AndroidManifest.xml, save at current dir\")\n+\tprotected boolean xmlTest = false;\n+\n \tprivate final List<File> input = new ArrayList<File>(1);\n \tprivate File outputDir;\n \n@@ -164,6 +167,11 @@ public boolean isPrintHelp() {\n \t\treturn printHelp;\n \t}\n \n+\t@Override\n+\tpublic boolean isXMLTest() {\n+\t\treturn xmlTest;\n+\t}\n+\n \t@Override\n \tpublic int getThreadsCount() {\n \t\treturn threadsCount;\n\ndiff --git a/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java\n--- a/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java\n+++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java\n@@ -38,4 +38,9 @@ public boolean isShowInconsistentCode() {\n \tpublic boolean isVerbose() {\n \t\treturn false;\n \t}\n+\n+\t@Override\n+\tpublic boolean isXMLTest() {\n+\t\treturn false;\n+\t}\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/api/IJadxArgs.java b/jadx-core/src/main/java/jadx/api/IJadxArgs.java\n--- a/jadx-core/src/main/java/jadx/api/IJadxArgs.java\n+++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java\n@@ -16,4 +16,6 @@ public interface IJadxArgs {\n \tboolean isShowInconsistentCode();\n \n \tboolean isVerbose();\n+\n+\tboolean isXMLTest();\n }\n\ndiff --git a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n--- a/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java\n@@ -11,6 +11,7 @@\n import jadx.core.utils.exceptions.JadxException;\n import jadx.core.utils.exceptions.JadxRuntimeException;\n import jadx.core.utils.files.InputFile;\n+import jadx.core.xmlgen.BinaryXMLParser;\n \n import java.io.File;\n import java.io.IOException;\n@@ -202,6 +203,16 @@ void parse() throws DecodeException {\n \t\treset();\n \t\troot = new RootNode();\n \t\tLOG.info(\"loading ...\");\n+\t\tif(this.args.isXMLTest()) {\n+\t\t\tInputFile inf = inputFiles.get(0);\n+\t\t\ttry {\n+\t\t\t\tBinaryXMLParser bxp = new BinaryXMLParser(InputFile.loadXMLBuffer(inf.getFile()), \"./AndroidManifest.xml\");\n+\t\t\t\t//BinaryXMLParser bxp = new BinaryXMLParser(InputFile.loadXMLBuffer(inf.getFile()), \"AndroidManifest.xml\");\n+\t\t\t\tbxp.parse();\n+\t\t\t} catch(IOException ioe) {\n+\t\t\t\tLOG.info(\"Decompiling AndroidManifest.xml failed!\");\n+\t\t\t}\n+\t\t}\n \t\troot.load(inputFiles);\n \t}\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n@@ -74,6 +74,29 @@ private static Dex loadFromJar(File jarFile) throws DecodeException {\n \t\t}\n \t}\n \n+\tpublic static byte[] loadXMLBuffer(File file) throws IOException { // FIXME: Public.. Please fix\n+\t\tZipFile zf = new ZipFile(file);\n+\t\tZipEntry xml = zf.getEntry(\"AndroidManifest.xml\");\n+\t\tif(null == xml) {\n+\t\t\tzf.close();\n+\t\t\treturn null;\n+\t\t}\n+\t\tByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n+\t\tInputStream in = null;\n+\t\ttry {\n+\t\t\tin = zf.getInputStream(xml);\n+\t\t\tbyte[] buffer = new byte[(int) xml.getSize()]; // FIXME: long->int conversion loss\n+\t\t\tint count;\n+\t\t\twhile ((count = in.read(buffer)) != -1) {\n+\t\t\t\tbytesOut.write(buffer, 0, count);\n+\t\t\t}\n+\t\t} finally {\n+\t\t\tif(null != in) in.close();\n+\t\t\tzf.close();\n+\t\t}\n+\t\treturn bytesOut.toByteArray();\n+\t}\n+\n \tprivate static Dex loadFromZip(File file) throws IOException {\n \t\tZipFile zf = new ZipFile(file);\n \t\tZipEntry dex = zf.getEntry(\"classes.dex\");\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -76,7 +76,27 @@ public BinaryXMLParser(String xmlfilepath, String xmloutfilepath) {\n \t\t\t\tdie(\"IAE\");\n \t\t\t}\n \t\t}\n-\t\t\n+\t}\n+\n+\tpublic BinaryXMLParser(byte[] xmlfilebytes, String xmloutfilepath) {\n+\t\tSystem.out.println(\"XMLOUTFILEPATH: \" + xmloutfilepath);\n+\t\ttry {\n+\t\t\twriter = new PrintWriter(xmloutfilepath,\"UTF-8\");\n+\t\t} catch(FileNotFoundException fnfe) { die(\"FNFE\"); }\n+\t\tcatch(UnsupportedEncodingException uee) { die(\"UEE\"); }\n+\t\tif(null==writer) die(\"null==writer\");\n+\t\twriter.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\");\n+\t\tbytes = xmlfilebytes;\n+\t\tcount=0;\n+\t\tstyleMap = new HashMap<Integer, String>();\n+\t\tif(null==styleMap) die(\"null==styleMap\");\n+\t\tfor(Field f : android.R.style.class.getFields()) {\n+\t\t\ttry {\n+\t\t\t\tstyleMap.put(f.getInt(f.getType()),f.getName());\n+\t\t\t} catch(IllegalAccessException iae) {\n+\t\t\t\tdie(\"IAE\");\n+\t\t\t}\n+\t\t}\n \t}\n \n \tpublic void parse() {",
    "output": "Add option flag to make androidmanifest.xml decompiling optional."
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n@@ -8,15 +8,15 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-//import jadx.core.xmlgen.BinaryXMLParser;\n+import jadx.core.xmlgen.BinaryXMLParser;\n \n public class JadxCLI {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(JadxCLI.class);\n \n \tpublic static void main(String[] args) throws JadxException {\n-//\t\tBinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);\n-//\t\tbxp.parse();\n-//\t\tSystem.exit(4);\n+\t\tBinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);\n+\t\tbxp.parse();\n+\t\tSystem.exit(4);\n \t\ttry {\n \t\t\tJadxCLIArgs jadxArgs = new JadxCLIArgs();\n \t\t\tif (processArgs(jadxArgs, args)) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -232,7 +232,7 @@ private void parseElementEnd() {\n \t\tint elementNS = cInt32(bytes, count);\n \t\tint elementName = cInt32(bytes, count);\n \t\tif(currentTag==strings[elementName]) {\n-\t\t\twriter.println(\"/>\");\n+\t\t\twriter.println(\" />\");\n \t\t\twasOneLiner=true;\n \t\t} else {\n \t\t\tfor(int i=0; i<numtabs; i++) writer.print(\"\\t\");",
    "output": "Add a whitespace before oneLiner ends."
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n@@ -8,15 +8,15 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-//import jadx.core.xmlgen.BinaryXMLParser;\n+import jadx.core.xmlgen.BinaryXMLParser;\n \n public class JadxCLI {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(JadxCLI.class);\n \n \tpublic static void main(String[] args) throws JadxException {\n-\t\t//BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);\n-\t\t//bxp.parse();\n-\t\t//System.exit(4);\n+\t\tBinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);\n+\t\tbxp.parse();\n+\t\tSystem.exit(4);\n \t\ttry {\n \t\t\tJadxCLIArgs jadxArgs = new JadxCLIArgs();\n \t\t\tif (processArgs(jadxArgs, args)) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -28,6 +28,7 @@ public BinaryXMLParser(String xmlfilepath, String xmloutfilepath) {\n \t\t} catch(FileNotFoundException fnfe) { die(\"FNFE\"); }\n \t\tcatch(UnsupportedEncodingException uee) { die(\"UEE\"); }\n \t\tif(null==writer) die(\"null==writer\");\n+\t\twriter.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\");\n \t\tFile manifest = new File(xmlfilepath);\n \t\tif(null==manifest) die(\"null==manifest\");\n \t\tbytes = new byte[(int) manifest.length()];",
    "output": "Add xml header"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n@@ -10,7 +10,6 @@\n import javax.swing.tree.DefaultMutableTreeNode;\n \n public abstract class JNode extends DefaultMutableTreeNode {\n-\tprivate static final long serialVersionUID = 1337L; // TODO: Create your own serialvers with serialver/eclipse\n \tpublic static JNode makeFrom(JavaNode node) {\n \t\tif (node instanceof JavaClass) {\n \t\t\tJClass p = (JClass) makeFrom(node.getDeclaringClass());\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n@@ -124,7 +124,7 @@ private void addPackage(Map<String, JPackage> pkgs, JPackage pkg) {\n \t}\n \n \tpublic JClass searchClassInTree(JClass node) {\n-\t\tEnumeration<?> en = this.breadthFirstEnumeration();\n+\t\tEnumeration en = this.breadthFirstEnumeration();\n \t\twhile (en.hasMoreElements()) {\n \t\t\tObject obj = en.nextElement();\n \t\t\tif (node.equals(obj)) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n@@ -71,7 +71,7 @@ private static enum SearchOptions {\n \n \tprivate JTextField searchField;\n \tprivate ResultsModel resultsModel;\n-\tprivate JList<Object> resultsList;\n+\tprivate JList resultsList;\n \tprivate JProgressBar busyBar;\n \n \tpublic SearchDialog(Frame owner, TabbedPane tabbedPane, JadxWrapper wrapper) {\n@@ -171,7 +171,7 @@ public void run() {\n \t\t}\n \t}\n \n-\tprivate static class ResultsModel extends DefaultListModel<Object> {\n+\tprivate static class ResultsModel extends DefaultListModel {\n \t\tprivate static final long serialVersionUID = -7821286846923903208L;\n \n \t\tprivate void setResults(List<JavaNode> results) {\n@@ -186,7 +186,7 @@ private void setResults(List<JavaNode> results) {\n \t\t}\n \t}\n \n-\tprivate static class ResultsCellRenderer implements ListCellRenderer<Object> {\n+\tprivate static class ResultsCellRenderer implements ListCellRenderer {\n \t\tprivate final Color selectedBackground;\n \t\tprivate final Color selectedForeground;\n \n@@ -197,7 +197,7 @@ private static class ResultsCellRenderer implements ListCellRenderer<Object> {\n \t\t}\n \n \t\t@Override\n-\t\tpublic Component getListCellRendererComponent(JList<?> list,\n+\t\tpublic Component getListCellRendererComponent(JList list,\n \t\t                                              Object obj, int index, boolean isSelected, boolean cellHasFocus) {\n \t\t\tif (!(obj instanceof JNode)) {\n \t\t\t\treturn null;\n@@ -244,7 +244,7 @@ private void initUI() {\n \t\tcodeChBox.setEnabled(false);\n \n \t\tresultsModel = new ResultsModel();\n-\t\tresultsList = new JList<Object>(resultsModel);\n+\t\tresultsList = new JList(resultsModel);\n \t\tresultsList.setCellRenderer(new ResultsCellRenderer());\n \t\tresultsList.addMouseListener(new MouseAdapter() {\n \t\t\tpublic void mouseClicked(MouseEvent evt) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/Link.java b/jadx-gui/src/main/java/jadx/gui/utils/Link.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/Link.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/Link.java\n@@ -18,7 +18,6 @@\n import static java.awt.Desktop.Action;\n \n public class Link extends JLabel implements MouseListener {\n-\tprivate static final long serialVersionUID = 0L; // TODO: Generate random serialvers with serialver/eclipse\n \tprivate static final Logger LOG = LoggerFactory.getLogger(JLabel.class);\n \n \tprivate String url;",
    "output": "Remove old less-warnings branch commit changes."
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -16,7 +16,10 @@ public class BinaryXMLParser {\n \tprivate String[] strings;\n \tprivate int count;\n \tprivate String nsPrefix=\"ERROR\";\n+\tprivate String nsURI=\"ERROR\";\n+\tprivate String currentTag=\"ERROR\";\n \tprivate int numtabs=-1;\n+\tprivate boolean wasOneLiner=false;\n \tPrintWriter writer;\n \tpublic BinaryXMLParser(String xmlfilepath, String xmloutfilepath) {\n \t\t//System.out.println(xmlfilepath);\n@@ -126,6 +129,7 @@ private void parseNameSpace() {\n \t\tnsPrefix = strings[beginPrefix];\n \t\tint beginURI = cInt32(bytes, count);\n \t\t//System.out.println(\"URI: \" + strings[beginURI]);\n+\t\tnsURI=strings[beginURI];\n \t\t//System.out.println(\"COUNT: \"+Integer.toHexString(count));\n \t}\n \n@@ -141,6 +145,7 @@ private void parseNameSpaceEnd() {\n \t\t//System.out.println(\"Prefix: \" + strings[endPrefix]);\n \t\tnsPrefix = strings[endPrefix];\n \t\tint endURI = cInt32(bytes, count);\n+\t\tnsURI=strings[endURI];\n \t\t//System.out.println(\"URI: \" + strings[endURI]);\n \t}\n \n@@ -149,15 +154,20 @@ private void parseElement() {\n \t\tif(cInt16(bytes, count) != 0x0010) die(\"ELEMENT HEADER SIZE is not 0x10\");\n \t\t//if(cInt32(bytes, count) != 0x0060) die(\"ELEMENT CHUNK SIZE is not 0x60\");\n \t\tcount+=4;\n-\t\tint elementLineNumber = cInt32(bytes, count);\n-\t\t//System.out.println(\"elementLineNumber: \" + elementLineNumber);\n+\t\tint elementBegLineNumber = cInt32(bytes, count);\n+\t\t//System.out.println(\"ELEMENT BEG Line: \" + elementBegLineNumber + \" of \" + strings[startNSName]);\n \t\tint comment = cInt32(bytes, count);\n \t\t//System.out.println(\"Comment: 0x\" + Integer.toHexString(comment));\n \t\t//System.out.println(\"COUNT: \"+Integer.toHexString(count));\n \t\tint startNS = cInt32(bytes, count);\n \t\t//System.out.println(\"Namespace: 0x\" + Integer.toHexString(startNS));\n-\t\tint startNSName = cInt32(bytes, count); // what to do with this id?\n+\t\tint startNSName = cInt32(bytes, count); // actually is elementName...\n \t\t//System.out.println(\"Namespace name: \" + strings[startNSName]);\n+\t\tif(!wasOneLiner && !\"ERROR\".equals(currentTag) && !currentTag.equals(strings[startNSName])) {\n+\t\t\twriter.println(\">\");\n+\t\t}\n+\t\twasOneLiner=false;\n+\t\tcurrentTag=strings[startNSName];\n \t\tfor(int i=0; i<numtabs; i++) writer.print(\"\\t\");\n \t\twriter.print(\"<\" + strings[startNSName]);\n \t\tint attributeStart = cInt16(bytes, count);\n@@ -172,6 +182,7 @@ private void parseElement() {\n \t\t//System.out.println(\"startNS: classIndex: \" + classIndex);\n \t\tint styleIndex = cInt16(bytes, count);\n \t\t//System.out.println(\"startNS: styleIndex: \" + styleIndex);\n+\t\tif(\"manifest\".equals(strings[startNSName])) writer.print(\" xmlns:\\\"\"+nsURI+\"\\\"\");\n \t\tif(attributeCount>0) writer.print(\" \");\n \t\tfor(int i=0; i<attributeCount; i++) {\n \t\t\tint attributeNS = cInt32(bytes, count);\n@@ -183,7 +194,7 @@ private void parseElement() {\n \t\t\tif(cInt8(bytes, count) != 0) die(\"res0 is not 0\");\n \t\t\tint attrValDataType = cInt8(bytes, count);\n \t\t\tint attrValData = cInt32(bytes, count);\n-/*\n+/*(\n \t\t\tSystem.out.println(\"ai[\"+i+\"] ns: \" + attributeNS);\n \t\t\t//if(attributeNS!=-1) System.out.println(\"ai[\"+i+\"] Sns: \" + strings[attributeNS]);\n \t\t\tSystem.out.println(\"ai[\"+i+\"] name: \" + attributeName);\n@@ -193,35 +204,43 @@ private void parseElement() {\n \t\t\tSystem.out.println(\"ai[\"+i+\"] d: \" + attrValData);\n */\n \t\t\tif(attributeNS != -1) writer.print(nsPrefix+\":\");\n+\t\t\t//writer.print(strings[attributeName] + \"=\\\"\");\n \t\t\tif(attrValDataType==0x3) writer.print(strings[attributeName] + \"=\\\"\" + strings[attrValData]+\"\\\"\");\n \t\t\telse if(attrValDataType==0x10) writer.print(strings[attributeName] + \"=\\\"\" + attrValData+\"\\\"\");\n \t\t\telse if(attrValDataType==0x12) {\n \t\t\t\t// TODO: data is always -1, FIXME\n \t\t\t\tif(attrValData==0) writer.print(strings[attributeName] + \"=\\\"false\\\"\");\n \t\t\t\telse if(attrValData==1 || attrValData==-1) writer.print(strings[attributeName] + \"=\\\"true\\\"\");\n \t\t\t\telse writer.print(strings[attributeName] + \"=\\\"UNKNOWN\\\"\");\n-\t\t\t}\n+\t\t\t} else if(attrValDataType==0x1) writer.print(strings[attributeName] + \"=\\\"0x\" + Integer.toHexString(attrValData) + \"\\\"\");\n \t\t\telse writer.print(strings[attributeName] + \" = UNKNOWN DATA TYPE: \" + attrValDataType);\n-\t\t\twriter.print(\" \");\n+\t\t\tif((i+1)<attributeCount) writer.print(\" \");\n \t\t}\n-\t\twriter.println(\">\");\n+\t\t//writer.println(\">\");\n+\t\t//System.out.println(\"ELEMENT BEG Line: \" + elementBegLineNumber + \" of \" + strings[startNSName]);\n \t}\n \n \tprivate void parseElementEnd() {\n \t\tif(cInt16(bytes, count) != 0x0010) die(\"ELEMENT END header is not 0x0010\");\n \t\tif(cInt32(bytes, count) != 0x18) die(\"ELEMENT END header chunk is not 0x18 big\");\n \t\tint endLineNumber = cInt32(bytes, count);\n \t\t//if(endLineNumber!=2) die(\"NAMESPACE beginning line number != 2 not supported yet\");\n-\t\t//System.out.println(\"ELEMENT END Line:\" + endLineNumber);\n \t\tint comment = cInt32(bytes, count);\n \t\t//System.out.println(\"Comment: 0x\" + Integer.toHexString(comment));\n \t\tint elementNS = cInt32(bytes, count);\n \t\tint elementName = cInt32(bytes, count);\n-\t\tfor(int i=0; i<numtabs; i++) writer.print(\"\\t\");\n-\t\twriter.print(\"</\");\n-\t\tif(elementNS != -1) writer.print(strings[elementNS]+\":\");\n-\t\twriter.println(strings[elementName]+\">\");\n+\t\tif(currentTag==strings[elementName]) {\n+\t\t\twriter.println(\"/>\");\n+\t\t\twasOneLiner=true;\n+\t\t} else {\n+\t\t\tfor(int i=0; i<numtabs; i++) writer.print(\"\\t\");\n+\t\t\twriter.print(\"</\");\n+\t\t\tif(elementNS != -1) writer.print(strings[elementNS]+\":\");\n+\t\t\twriter.println(strings[elementName]+\">\");\n+\t\t}\n \t\tnumtabs-=1;\n+\t\t//System.out.println(\"ELEMENT END Line: \" + endLineNumber + \" of \" + strings[elementName]);\n+\t\t// TODO: Mind linenumbers for real original file ;)\n \t}\n \n \tprivate int cInt8(byte[] bytes, int offset) {",
    "output": "Fix XML oneLiners. Added another attribute value data type"
  },
  {
    "input": "diff --git a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n--- a/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java\n@@ -8,10 +8,15 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import jadx.core.xmlgen.BinaryXMLParser;\n+\n public class JadxCLI {\n \tprivate static final Logger LOG = LoggerFactory.getLogger(JadxCLI.class);\n \n \tpublic static void main(String[] args) throws JadxException {\n+\t\tBinaryXMLParser bxp = new BinaryXMLParser(args[0]);\n+\t\tbxp.parse();\n+\t\tSystem.exit(4);\n \t\ttry {\n \t\t\tJadxCLIArgs jadxArgs = new JadxCLIArgs();\n \t\t\tif (processArgs(jadxArgs, args)) {\n\ndiff --git a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n--- a/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java\n@@ -0,0 +1,187 @@\n+package jadx.core.xmlgen;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+\n+public class BinaryXMLParser {\n+\tprivate byte[] bytes;\n+\tprivate String[] strings;\n+\tprivate int count;\n+\tprivate String nsPrefix=\"ERROR\";\n+\tpublic BinaryXMLParser(String xmlfilepath) {\n+\t\tSystem.out.println(xmlfilepath);\n+\t\tFile manifest = new File(xmlfilepath);\n+\t\tif(null==manifest) die(\"null==manifest\");\n+\t\tbytes = new byte[(int) manifest.length()];\n+\t\ttry {\n+\t\t\tInputStream is = null;\n+\t\t\ttry {\n+\t\t\t\tis = new BufferedInputStream(new FileInputStream(manifest));\n+\t\t\t\tint total = 0;\n+\t\t\t\twhile(total < bytes.length) {\n+\t\t\t\t\tint remain = bytes.length - total;\n+\t\t\t\t\tint read = is.read(bytes, total, remain);\n+\t\t\t\t\tif(read > 0) total += read;\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\tis.close();\n+\t\t\t}\n+\t\t} catch(FileNotFoundException fnfe) { die(\"FILE NOT FOUND\"); }\n+\t\tcatch(IOException ioe) { die(\"IOE\"); }\n+\t\tcount=0;\n+\t}\n+\n+\tpublic void parse() {\n+\t\tif(cInt16(bytes, count) != 0x0003) die(\"Version is not 3\");\n+\t\tif(cInt16(bytes, count) != 0x0008) die(\"Size of header is not 8\");\n+\t\tif(cInt32(bytes, count) != bytes.length) die(\"Size of manifest doesn't match\");\n+\t\twhile(true) {\n+\t\t\tint type = cInt16(bytes, count);\n+\t\t\tif(type==0x0001) parseStringPool();\n+\t\t\telse if(type==0x0180) parseResourceMap();\n+\t\t\telse if(type==0x0100) parseNameSpace();\n+\t\t\telse if(type==0x0102) parseElement();\n+\t\t\telse die(\"Type: \" + Integer.toHexString(type) + \" not yet implemented\");\n+\t\t\tSystem.out.println(\"COUNT: \"+Integer.toHexString(count));\n+\t\t}\n+\t\t//die(\"Done\");\n+\t}\n+\n+\tprivate void parseStringPool() {\n+\t\tif(cInt16(bytes, count) != 0x001c) die(\"Header header size not 28\");\n+\t\tint hsize = cInt32(bytes, count);\n+\t\tint stringCount = cInt32(bytes, count);\n+\t\tint styleCount = cInt32(bytes, count);\n+\t\tint flags = cInt32(bytes, count);\n+\t\tint stringsStart = cInt32(bytes, count);\n+\t\tint stylesStart = cInt32(bytes, count);\n+/*\n+\t\tSystem.out.println(hsize);\n+\t\tSystem.out.println(stringCount);\n+\t\tSystem.out.println(styleCount);\n+\t\tSystem.out.println(flags);\n+\t\tSystem.out.println(stringsStart);\n+\t\tSystem.out.println(stylesStart);\n+*/\n+\t\tint[] stringsOffsets = new int[stringCount];\n+\t\tfor(int i=0; i<stringCount; i++) {\n+\t\t\tstringsOffsets[i] = cInt32(bytes, count);\n+\t\t\t//System.out.println(\"i[\"+i+\"]: \" + stringsOffsets[i]);\n+\t\t}\n+\t\tstrings = new String[stringCount];\n+\t\tfor(int i=0; i<stringCount; i++) {\n+\t\t\tint off = 8 + stringsStart + stringsOffsets[i];\n+\t\t\tint strlen = cInt16(bytes, off);\n+\t\t\t//System.out.println(\"strlen: \" + strlen);\n+\t\t\tbyte[] str = new byte[strlen*2];\n+\t\t\tSystem.arraycopy(bytes, count, str, 0, strlen*2);\n+\t\t\tcount+=strlen*2;\n+\t\t\tstrings[i] = new String(str, Charset.forName(\"UTF-16LE\"));\n+\t\t\tSystem.out.println(\"index i[\"+i+\"] string: \" + strings[i]);\n+\t\t\tcount+=2;\n+\t\t}\n+\t}\n+\n+\tprivate void parseResourceMap() {\n+\t\tif(cInt16(bytes, count) != 0x8) die(\"Header size of resmap is not 8!\");\n+\t\tint rhsize = cInt32(bytes, count);\n+\t\tSystem.out.println(\"RHeader Size: \" + rhsize);\n+\t\tint[] ids = new int[(rhsize-8)/4];\n+\t\tfor(int i=0; i<ids.length; i++) {\n+\t\t\tids[i]=cInt32(bytes, count);\n+\t\t\tSystem.out.println(\"i[\"+i+\"] ID: \"+ids[i]);\n+\t\t\tSystem.out.println(\"Hex: 0x0\" + Integer.toHexString(ids[i]) + \" should be: \" + strings[i]);\n+\t\t}\n+\t}\n+\n+\tprivate void parseNameSpace() {\n+\t\tif(cInt16(bytes, count) != 0x0010) die(\"NAMESPACE header is not 0x0010\");\n+\t\tif(cInt32(bytes, count) != 0x18) die(\"NAMESPACE header chunk is not 0x18 big\");\n+\t\tint beginLineNumber = cInt32(bytes, count);\n+\t\tif(beginLineNumber!=2) die(\"NAMESPACE beginning line number != 2 not supported yet\");\n+\t\tSystem.out.println(\"Comment: 0x\" + Integer.toHexString(cInt32(bytes, count)));\n+\t\tint beginPrefix = cInt32(bytes, count);\n+\t\tSystem.out.println(\"Prefix: \" + strings[beginPrefix]);\n+\t\tnsPrefix = strings[beginPrefix];\n+\t\tint beginURI = cInt32(bytes, count);\n+\t\tSystem.out.println(\"URI: \" + strings[beginURI]);\n+\t\tSystem.out.println(\"COUNT: \"+Integer.toHexString(count));\n+\t}\n+\n+\tprivate void parseElement() {\n+\t\tif(cInt16(bytes, count) != 0x0010) die(\"ELEMENT HEADER SIZE is not 0x10\");\n+\t\tif(cInt32(bytes, count) != 0x0060) die(\"ELEMENT CHUNK SIZE is not 0x60\");\n+\t\tint elementLineNumber = cInt32(bytes, count);\n+\t\tSystem.out.println(\"elementLineNumber: \" + elementLineNumber);\n+\t\tSystem.out.println(\"Comment: 0x\" + Integer.toHexString(cInt32(bytes, count)));\n+\t\tSystem.out.println(\"COUNT: \"+Integer.toHexString(count));\n+\t\tint startNS = cInt32(bytes, count);\n+\t\tSystem.out.println(\"Namespace: 0x\" + Integer.toHexString(startNS));\n+\t\tint startNSName = cInt32(bytes, count); // what to do with this id?\n+\t\tSystem.out.println(\"Namespace name: \" + strings[startNSName]);\n+\t\tint attributeStart = cInt16(bytes, count);\n+\t\tif(attributeStart != 0x14) die(\"startNS's attributeStart is not 0x14\");\n+\t\tint attributeSize = cInt16(bytes, count);\n+\t\tif(attributeSize != 0x14) die(\"startNS's attributeSize is not 0x14\");\n+\t\tint attributeCount = cInt16(bytes, count); \n+\t\tSystem.out.println(\"startNS: attributeCount: \" + attributeCount);\n+\t\tint idIndex = cInt16(bytes, count);\n+\t\tSystem.out.println(\"startNS: idIndex: \" + idIndex);\n+\t\tint classIndex = cInt16(bytes, count);\n+\t\tSystem.out.println(\"startNS: classIndex: \" + classIndex);\n+\t\tint styleIndex = cInt16(bytes, count);\n+\t\tSystem.out.println(\"startNS: styleIndex: \" + styleIndex);\n+\t\tfor(int i=0; i<attributeCount; i++) {\n+\t\t\tint attributeNS = cInt32(bytes, count);\n+\t\t\tint attributeName = cInt32(bytes, count);\n+\t\t\tint attributeRawValue = cInt32(bytes, count);\n+\t\t\tint attrValSize = cInt16(bytes, count);\n+\t\t\t//System.out.println(attrValSize);\n+\t\t\tif(attrValSize != 0x08) die(\"attrValSize != 0x08 not supported\");\n+\t\t\tif(cInt8(bytes, count) != 0) die(\"res0 is not 0\");\n+\t\t\tint attrValDataType = cInt8(bytes, count);\n+\t\t\tint attrValData = cInt32(bytes, count);\n+\t\t\tSystem.out.println(\"ai[\"+i+\"] ns: \" + attributeNS);\n+\t\t\tSystem.out.println(\"ai[\"+i+\"] name: \" + attributeName);\n+\t\t\tSystem.out.println(\"ai[\"+i+\"] rawval: \" + attributeRawValue);\n+\t\t\tSystem.out.println(\"ai[\"+i+\"] dt: \" + attrValDataType);\n+\t\t\tSystem.out.println(\"ai[\"+i+\"] d: \" + attrValData);\n+\t\t\tif(attributeNS != -1) System.out.print(nsPrefix+\":\");\n+\t\t\tif(attrValDataType==0x3) System.out.println(strings[attributeName] + \"=\" + strings[attrValData]);\n+\t\t\telse if(attrValDataType==0x10) System.out.println(strings[attributeName] + \"=\" + attrValData);\n+\t\t\telse System.out.println(\"UNKNOWN DATA TYPE: \" + attrValDataType);\n+\t\t}\n+\t}\n+\n+\tprivate int cInt8(byte[] bytes, int offset) {\n+\t\tbyte[] tmp = new byte[4];\n+\t\ttmp[3]=bytes[count++];\n+\t\treturn ByteBuffer.wrap(tmp).getInt();\n+\t}\n+\n+\tprivate int cInt16(byte[] bytes, int offset) {\n+\t\tbyte[] tmp = new byte[4];\n+\t\ttmp[3]=bytes[count++];\n+\t\ttmp[2]=bytes[count++];\n+\t\treturn ByteBuffer.wrap(tmp).getInt();\n+\t}\n+\n+\tprivate int cInt32(byte[] bytes, int offset) {\n+\t\tbyte[] tmp = new byte[4];\n+\t\tfor(int i=0;i <4; i++) tmp[3-i]=bytes[count+i];\n+\t\tcount+=4;\n+\t\treturn ByteBuffer.wrap(tmp).getInt();\n+\t}\n+\n+\tprivate void die(String message) {\n+\t\tSystem.err.println(message);\n+\t\tSystem.exit(3);\n+\t}\n+}",
    "output": "Add first implementation of the AndroidManifest XML Parser"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java\n@@ -10,7 +10,7 @@\n import javax.swing.tree.DefaultMutableTreeNode;\n \n public abstract class JNode extends DefaultMutableTreeNode {\n-\n+\tprivate static final long serialVersionUID = 1337L; // TODO: Create your own serialvers with serialver/eclipse\n \tpublic static JNode makeFrom(JavaNode node) {\n \t\tif (node instanceof JavaClass) {\n \t\t\tJClass p = (JClass) makeFrom(node.getDeclaringClass());\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n--- a/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java\n@@ -124,7 +124,7 @@ private void addPackage(Map<String, JPackage> pkgs, JPackage pkg) {\n \t}\n \n \tpublic JClass searchClassInTree(JClass node) {\n-\t\tEnumeration en = this.breadthFirstEnumeration();\n+\t\tEnumeration<?> en = this.breadthFirstEnumeration();\n \t\twhile (en.hasMoreElements()) {\n \t\t\tObject obj = en.nextElement();\n \t\t\tif (node.equals(obj)) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java\n@@ -71,7 +71,7 @@ private static enum SearchOptions {\n \n \tprivate JTextField searchField;\n \tprivate ResultsModel resultsModel;\n-\tprivate JList resultsList;\n+\tprivate JList<Object> resultsList;\n \tprivate JProgressBar busyBar;\n \n \tpublic SearchDialog(Frame owner, TabbedPane tabbedPane, JadxWrapper wrapper) {\n@@ -171,7 +171,7 @@ public void run() {\n \t\t}\n \t}\n \n-\tprivate static class ResultsModel extends DefaultListModel {\n+\tprivate static class ResultsModel extends DefaultListModel<Object> {\n \t\tprivate static final long serialVersionUID = -7821286846923903208L;\n \n \t\tprivate void setResults(List<JavaNode> results) {\n@@ -186,7 +186,7 @@ private void setResults(List<JavaNode> results) {\n \t\t}\n \t}\n \n-\tprivate static class ResultsCellRenderer implements ListCellRenderer {\n+\tprivate static class ResultsCellRenderer implements ListCellRenderer<Object> {\n \t\tprivate final Color selectedBackground;\n \t\tprivate final Color selectedForeground;\n \n@@ -197,7 +197,7 @@ private static class ResultsCellRenderer implements ListCellRenderer {\n \t\t}\n \n \t\t@Override\n-\t\tpublic Component getListCellRendererComponent(JList list,\n+\t\tpublic Component getListCellRendererComponent(JList<?> list,\n \t\t                                              Object obj, int index, boolean isSelected, boolean cellHasFocus) {\n \t\t\tif (!(obj instanceof JNode)) {\n \t\t\t\treturn null;\n@@ -244,7 +244,7 @@ private void initUI() {\n \t\tcodeChBox.setEnabled(false);\n \n \t\tresultsModel = new ResultsModel();\n-\t\tresultsList = new JList(resultsModel);\n+\t\tresultsList = new JList<Object>(resultsModel);\n \t\tresultsList.setCellRenderer(new ResultsCellRenderer());\n \t\tresultsList.addMouseListener(new MouseAdapter() {\n \t\t\tpublic void mouseClicked(MouseEvent evt) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/utils/Link.java b/jadx-gui/src/main/java/jadx/gui/utils/Link.java\n--- a/jadx-gui/src/main/java/jadx/gui/utils/Link.java\n+++ b/jadx-gui/src/main/java/jadx/gui/utils/Link.java\n@@ -18,6 +18,7 @@\n import static java.awt.Desktop.Action;\n \n public class Link extends JLabel implements MouseListener {\n+\tprivate static final long serialVersionUID = 0L; // TODO: Generate random serialvers with serialver/eclipse\n \tprivate static final Logger LOG = LoggerFactory.getLogger(JLabel.class);\n \n \tprivate String url;",
    "output": "Remove some warnings about collections without type specifiers."
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n--- a/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java\n@@ -40,7 +40,7 @@ private Dex loadDexBuffer() throws IOException, DecodeException {\n \t\tif (fileName.endsWith(\".class\")) {\n \t\t\treturn loadFromClassFile(file);\n \t\t}\n-\t\tif (fileName.endsWith(\".apk\")) {\n+\t\tif (fileName.endsWith(\".apk\") || fileName.endsWith(\".zip\")) {\n \t\t\tDex dex = loadFromZip(file);\n \t\t\tif (dex == null) {\n \t\t\t\tthrow new IOException(\"File 'classes.dex' not found in file: \" + file);",
    "output": "Add support for files ending in .zip."
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -535,6 +535,9 @@ private String makeArrayElements(FillArrayNode insn) throws CodegenException {\n \t\tif (!elType.isTypeKnown()) {\n \t\t\tLOG.warn(\"Unknown array element type: {} in mth: {}\", elType, mth);\n \t\t\telType = insnElementType.isTypeKnown() ? insnElementType : elType.selectFirst();\n+\t\t\tif (elType == null) {\n+\t\t\t\tthrow new JadxRuntimeException(\"Null array element type\");\n+\t\t\t}\n \t\t}\n \t\tinsn.mergeElementType(elType);\n \n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n--- a/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java\n@@ -7,6 +7,7 @@\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.jetbrains.annotations.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -20,6 +21,7 @@ public abstract class InsnArg extends Typed {\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(InsnArg.class);\n \n+\t@Nullable(\"Null for method arguments\")\n \tprotected InsnNode parentInsn;\n \n \tpublic static RegisterArg reg(int regNum, ArgType type) {\n@@ -70,6 +72,7 @@ public boolean isField() {\n \t\treturn false;\n \t}\n \n+\t@Nullable\n \tpublic InsnNode getParentInsn() {\n \t\treturn parentInsn;\n \t}\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java\n@@ -52,14 +52,14 @@ private static boolean checkInsn(MethodNode mth, InsnNode insn) {\n \t\tlong lit = ((LiteralArg) arg).getLiteral();\n \n \t\tSSAVar sVar = insn.getResult().getSVar();\n-\t\tif (lit == 0) {\n-\t\t\tif (checkObjectInline(sVar)) {\n-\t\t\t\tif (sVar.getUseCount() == 1) {\n-\t\t\t\t\tinsn.getResult().getAssignInsn().add(AFlag.DONT_INLINE);\n+\t\tif (lit == 0 && checkObjectInline(sVar)) {\n+\t\t\tif (sVar.getUseCount() == 1) {\n+\t\t\t\tInsnNode assignInsn = insn.getResult().getAssignInsn();\n+\t\t\t\tif (assignInsn != null) {\n+\t\t\t\t\tassignInsn.add(AFlag.DONT_INLINE);\n \t\t\t\t}\n-\t\t\t\treturn false;\n \t\t\t}\n-\n+\t\t\treturn false;\n \t\t}\n \t\tArgType resType = insn.getResult().getType();\n \t\t// make sure arg has correct type\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java\n@@ -468,6 +468,10 @@ private static void mergeReturnBlocks(MethodNode mth) {\n \t\tif (pred == null) {\n \t\t\treturn;\n \t\t}\n+\t\tIgnoreEdgeAttr edgeAttr = pred.get(AType.IGNORE_EDGE);\n+\t\tif (edgeAttr == null) {\n+\t\t\treturn;\n+\t\t}\n \t\tList<BlockNode> merge = new LinkedList<BlockNode>();\n \t\tfor (BlockNode blockNode : pred.getSuccessors()) {\n \t\t\tif (blockNode.contains(AFlag.RETURN)) {\n@@ -488,7 +492,6 @@ private static void mergeReturnBlocks(MethodNode mth) {\n \t\tif (origReturnBlock == null) {\n \t\t\treturn;\n \t\t}\n-\t\tIgnoreEdgeAttr edgeAttr = pred.get(AType.IGNORE_EDGE);\n \t\tfor (BlockNode mb : merge) {\n \t\t\tif (mb == origReturnBlock) {\n \t\t\t\tcontinue;\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java b/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java\n--- a/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java\n+++ b/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java\n@@ -102,7 +102,7 @@ private static <T> T get(String url, Type type) throws IOException {\n \t\tHttpURLConnection con = (HttpURLConnection) obj.openConnection();\n \t\tcon.setRequestMethod(\"GET\");\n \t\tif (con.getResponseCode() == 200) {\n-\t\t\tReader reader = new InputStreamReader(con.getInputStream());\n+\t\t\tReader reader = new InputStreamReader(con.getInputStream(), \"UTF-8\");\n \t\t\treturn GSON.fromJson(reader, type);\n \t\t}\n \t\treturn null;",
    "output": "Fix issues reported by coverity"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n--- a/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java\n@@ -526,7 +526,7 @@ private void fillArray(FillArrayNode insn, CodeWriter code) throws CodegenExcept\n \t\t\t);\n \t\t}\n \t\tif (!elType.isTypeKnown()) {\n-\t\t\tLOG.warn(\"Unknown array element type: {} in mth: {}\", elType);\n+\t\t\tLOG.warn(\"Unknown array element type: {} in mth: {}\", elType, mth);\n \t\t\telType = insnElementType.isTypeKnown() ? insnElementType : elType.selectFirst();\n \t\t}\n \t\tStringBuilder str = new StringBuilder();\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java\n@@ -171,6 +171,10 @@ private static LoopType checkArrayForEach(MethodNode mth, InsnNode initInsn, Ins\n \t\tif (!arrayArg.equals(arrGetInsn.getArg(0))) {\n \t\t\treturn null;\n \t\t}\n+\t\tRegisterArg iterVar = arrGetInsn.getResult();\n+\t\tif (iterVar == null) {\n+\t\t\treturn null;\n+\t\t}\n \n \t\t// array for each loop confirmed\n \t\tlen.add(AFlag.SKIP);\n@@ -179,8 +183,6 @@ private static LoopType checkArrayForEach(MethodNode mth, InsnNode initInsn, Ins\n \n \t\t// inline array variable\n \t\tCodeShrinker.shrinkMethod(mth);\n-\n-\t\tRegisterArg iterVar = arrGetInsn.getResult();\n \t\tif (arrGetInsn.contains(AFlag.WRAPPED)) {\n \t\t\tInsnArg wrapArg = BlockUtils.searchWrappedInsnParent(mth, arrGetInsn);\n \t\t\tif (wrapArg != null) {\n@@ -241,7 +243,7 @@ private static boolean checkIterableForEach(MethodNode mth, LoopRegion loopRegio\n \t\t} else {\n \t\t\ttoSkip.add(nextCall);\n \t\t}\n-\t\tif (!fixIterableType(iterableArg, iterVar)) {\n+\t\tif (iterVar == null || !fixIterableType(iterableArg, iterVar)) {\n \t\t\treturn false;\n \t\t}\n \n@@ -310,7 +312,7 @@ private static boolean argInLoop(MethodNode mth, LoopRegion loopRegion, Register\n \t\t}\n \t\tBlockNode block = BlockUtils.getBlockByInsn(mth, parentInsn);\n \t\tif (block == null) {\n-\t\t\tLOG.debug(\"Instruction not found: {}, mth: {}\", parentInsn, mth);\n+\t\t\tLOG.debug(\" LoopRegionVisitor: instruction not found: {}, mth: {}\", parentInsn, mth);\n \t\t\treturn false;\n \t\t}\n \t\treturn RegionUtils.isRegionContainsBlock(loopRegion, block);\n\ndiff --git a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n--- a/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java\n@@ -127,6 +127,9 @@ private static void renameVar(MethodNode mth, SSAVar[] vars, int[] vers, BlockNo\n \t\t\t\t\tthrow new JadxRuntimeException(\"Can't find predecessor for \" + block + \" \" + s);\n \t\t\t\t}\n \t\t\t\tfor (PhiInsn phiInsn : phiList.getList()) {\n+\t\t\t\t\tif (j >= phiInsn.getArgsCount()) {\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \t\t\t\t\tint regNum = phiInsn.getResult().getRegNum();\n \t\t\t\t\tSSAVar var = vars[regNum];\n \t\t\t\t\tif (var == null) {\n\ndiff --git a/jadx-gui/src/main/java/jadx/gui/ui/CodeArea.java b/jadx-gui/src/main/java/jadx/gui/ui/CodeArea.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/CodeArea.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/CodeArea.java\n@@ -64,6 +64,13 @@ class CodeArea extends RSyntaxTextArea {\n \n \tprivate boolean isJumpToken(Token token) {\n \t\tif (token.getType() == TokenTypes.IDENTIFIER) {\n+\t\t\t// fast skip\n+\t\t\tif (token.length() == 1) {\n+\t\t\t\tchar ch = token.getTextArray()[token.getTextOffset()];\n+\t\t\t\tif (ch == '.' || ch == ',' || ch == ';') {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tPosition pos = getPosition(cls, this, token.getOffset());\n \t\t\tif (pos != null) {\n \t\t\t\treturn true;",
    "output": "Fix minor issues"
  },
  {
    "input": "diff --git a/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n--- a/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java\n@@ -208,7 +208,7 @@ private ArgType[] consumeGenericArgs() {\n \t */\n \tpublic Map<ArgType, List<ArgType>> consumeGenericMap() {\n \t\tif (!lookAhead('<')) {\n-\t\t\treturn null;\n+\t\t\treturn Collections.emptyMap();\n \t\t}\n \t\tMap<ArgType, List<ArgType>> map = new LinkedHashMap<ArgType, List<ArgType>>(2);\n \t\tconsume('<');",
    "output": "Use spock framework for unit tests"
  },
  {
    "input": "diff --git a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n--- a/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java\n@@ -95,14 +95,6 @@ private CodePanel getCodePanel(JClass cls) {\n \t\treturn panel;\n \t}\n \n-\tprivate CodePanel getCodePanel(int index) {\n-\t\tComponent component = getComponent(index);\n-\t\tif (component instanceof CodePanel) {\n-\t\t\treturn (CodePanel) component;\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n \tCodePanel getSelectedCodePanel() {\n \t\treturn (CodePanel) getSelectedComponent();\n \t}",
    "output": "Remove unused private method getCodePanel(int)"
  },
  {
    "input": "diff --git a/jadx-core/src/test/java/jadx/tests/StringUtilsTest.java b/jadx-core/src/test/java/jadx/tests/StringUtilsTest.java\n--- a/jadx-core/src/test/java/jadx/tests/StringUtilsTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/StringUtilsTest.java\n@@ -1,10 +1,14 @@\n package jadx.tests;\n \n import jadx.core.utils.StringUtils;\n-import junit.framework.TestCase;\n \n-public class StringUtilsTest extends TestCase {\n+import org.junit.Test;\n \n+import static org.junit.Assert.assertEquals;\n+\n+public class StringUtilsTest {\n+\n+\t@Test\n \tpublic void testUnescape() {\n \t\tunescapeTest(\"\\n\", \"\\\\n\");\n \t\tunescapeTest(\"\\t\", \"\\\\t\");\n\ndiff --git a/jadx-core/src/test/java/jadx/tests/TypeMergeTest.java b/jadx-core/src/test/java/jadx/tests/TypeMergeTest.java\n--- a/jadx-core/src/test/java/jadx/tests/TypeMergeTest.java\n+++ b/jadx-core/src/test/java/jadx/tests/TypeMergeTest.java\n@@ -4,10 +4,12 @@\n import jadx.core.dex.instructions.args.ArgType;\n import jadx.core.dex.instructions.args.PrimitiveType;\n import jadx.core.utils.exceptions.DecodeException;\n-import junit.framework.TestCase;\n \n import java.io.IOException;\n \n+import org.junit.Before;\n+import org.junit.Test;\n+\n import static jadx.core.dex.instructions.args.ArgType.BOOLEAN;\n import static jadx.core.dex.instructions.args.ArgType.CHAR;\n import static jadx.core.dex.instructions.args.ArgType.INT;\n@@ -19,18 +21,21 @@\n import static jadx.core.dex.instructions.args.ArgType.genericType;\n import static jadx.core.dex.instructions.args.ArgType.object;\n import static jadx.core.dex.instructions.args.ArgType.unknown;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n \n-public class TypeMergeTest extends TestCase {\n+public class TypeMergeTest {\n \n-\tprivate void initClsp() throws IOException, DecodeException {\n+\t@Before\n+\tpublic void initClsp() throws IOException, DecodeException {\n \t\tClspGraph clsp = new ClspGraph();\n \t\tclsp.load();\n \t\tArgType.setClsp(clsp);\n \t}\n \n+\t@Test\n \tpublic void testMerge() throws IOException, DecodeException {\n-\t\tinitClsp();\n-\n \t\tfirst(INT, INT);\n \t\tfirst(BOOLEAN, INT);\n \t\treject(INT, LONG);\n\ndiff --git a/jadx-samples/src/main/java/jadx/samples/TestEnum.java b/jadx-samples/src/main/java/jadx/samples/TestEnum.java\n--- a/jadx-samples/src/main/java/jadx/samples/TestEnum.java\n+++ b/jadx-samples/src/main/java/jadx/samples/TestEnum.java\n@@ -9,7 +9,7 @@ public class TestEnum extends AbstractTest {\n \n \tpublic enum Direction {\n \t\tNORTH, SOUTH, EAST, WEST\n-\t};\n+\t}\n \n \tprivate static int three = 3;\n \n@@ -25,7 +25,7 @@ private Numbers(int n) {\n \t\tpublic int getNum() {\n \t\t\treturn num;\n \t\t}\n-\t};\n+\t}\n \n \tpublic enum Operation {\n \t\tPLUS {\n@@ -101,11 +101,28 @@ public static String getOp() {\n \n \tpublic enum Singleton {\n \t\tINSTANCE;\n+\n \t\tpublic String test(String arg) {\n \t\t\treturn arg.concat(\"test\");\n \t\t}\n \t}\n \n+\tpublic String testEnumSwitch(final Direction color) {\n+\t\tString d;\n+\t\tswitch (color) {\n+\t\t\tcase NORTH:\n+\t\t\t\td = \"N\";\n+\t\t\t\tbreak;\n+\t\t\tcase SOUTH:\n+\t\t\t\td = \"S\";\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\td = \"<>\";\n+\t\t\t\tbreak;\n+\t\t}\n+\t\treturn d;\n+\t}\n+\n \t@Override\n \tpublic boolean testRun() throws Exception {\n \t\tDirection d = Direction.EAST;\n\ndiff --git a/jadx-samples/src/main/java/jadx/samples/TestInvoke.java b/jadx-samples/src/main/java/jadx/samples/TestInvoke.java\n--- a/jadx-samples/src/main/java/jadx/samples/TestInvoke.java\n+++ b/jadx-samples/src/main/java/jadx/samples/TestInvoke.java\n@@ -37,15 +37,6 @@ private String testVarArgs2(char[]... args) {\n \t\treturn s;\n \t}\n \n-\t/* TODO\n-\tpublic TestInvoke testConstructor(int flag) {\n-\t\tif (getF() == flag)\n-\t\t\treturn new TestInvoke(flag);\n-\t\telse\n-\t\t\treturn this;\n-\t}\n-\t*/\n-\n \t@Override\n \tpublic boolean testRun() throws Exception {\n \t\tTestInvoke inv = new TestInvoke();\n@@ -58,7 +49,6 @@ public boolean testRun() throws Exception {\n \t\tassertTrue(inv.testVarArgs(\"a\", \"2\", \"III\"));\n \t\tassertTrue(inv.testVarArgs2(\"a\".toCharArray(), new char[] { '1', '2' }).equals(\"a12\"));\n \n-\t\t// assertTrue(testConstructor(f) != this);\n \t\treturn true;\n \t}",
    "output": "Upgrade tests"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/nodes/MethodNode.java b/src/main/java/jadx/dex/nodes/MethodNode.java\n--- a/src/main/java/jadx/dex/nodes/MethodNode.java\n+++ b/src/main/java/jadx/dex/nodes/MethodNode.java\n@@ -4,6 +4,7 @@\n import jadx.dex.attributes.AttrNode;\n import jadx.dex.attributes.AttributeFlag;\n import jadx.dex.attributes.JumpAttribute;\n+import jadx.dex.attributes.LoopAttr;\n import jadx.dex.attributes.annotations.Annotation;\n import jadx.dex.info.AccessInfo;\n import jadx.dex.info.AccessInfo.AFType;\n@@ -64,6 +65,7 @@ public class MethodNode extends AttrNode implements ILoadable {\n \n \tprivate IContainer region;\n \tprivate List<ExceptionHandler> exceptionHandlers;\n+\tprivate List<LoopAttr> loops = Collections.emptyList();\n \n \tpublic MethodNode(ClassNode classNode, Method mthData) {\n \t\tthis.mthInfo = MethodInfo.fromDex(classNode.dex(), mthData.getMethodIndex());\n@@ -411,6 +413,21 @@ public void addExitBlock(BlockNode exitBlock) {\n \t\tthis.exitBlocks.add(exitBlock);\n \t}\n \n+\tpublic void registerLoop(LoopAttr loop) {\n+\t\tif(loops.isEmpty()) {\n+\t\t\tloops = new ArrayList<LoopAttr>(5);\n+\t\t}\n+\t\tloops.add(loop);\n+\t}\n+\n+\tpublic LoopAttr getLoopForBlock(BlockNode block) {\n+\t\tfor (LoopAttr loop : loops) {\n+\t\t\tif(loop.getLoopBlocks().contains(block))\n+\t\t\t\treturn loop;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \tpublic ExceptionHandler addExceptionHandler(ExceptionHandler handler) {\n \t\tif (exceptionHandlers == null) {\n \t\t\texceptionHandlers = new ArrayList<ExceptionHandler>(2);\n\ndiff --git a/src/main/java/jadx/dex/visitors/BlockMakerVisitor.java b/src/main/java/jadx/dex/visitors/BlockMakerVisitor.java\n--- a/src/main/java/jadx/dex/visitors/BlockMakerVisitor.java\n+++ b/src/main/java/jadx/dex/visitors/BlockMakerVisitor.java\n@@ -180,6 +180,8 @@ private static void makeBasicBlocks(MethodNode mth) {\n \t\t\tif (i > 100)\n \t\t\t\tthrow new AssertionError(\"Can't fix method cfg: \" + mth);\n \t\t}\n+\n+\t\tregisterLoops(mth);\n \t}\n \n \tprivate static BlockNode getBlock(int offset, Map<Integer, BlockNode> blocksMap) {\n@@ -307,6 +309,16 @@ private static void markReturnBlocks(MethodNode mth) {\n \t\t}\n \t}\n \n+\tprivate static void registerLoops(MethodNode mth) {\n+\t\tfor (BlockNode block : mth.getBasicBlocks()) {\n+\t\t\tAttributesList attributes = block.getAttributes();\n+\t\t\tIAttribute loop = attributes.get(AttributeType.LOOP);\n+\t\t\tif(loop != null && attributes.contains(AttributeFlag.LOOP_START)) {\n+\t\t\t\tmth.registerLoop((LoopAttr) loop);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tprivate static boolean modifyBlocksTree(MethodNode mth) {\n \t\tfor (BlockNode block : mth.getBasicBlocks()) {\n \t\t\tif (block.getPredecessors().isEmpty() && block != mth.getEnterBlock()) {\n\ndiff --git a/src/main/java/jadx/dex/visitors/regions/FinishRegions.java b/src/main/java/jadx/dex/visitors/regions/FinishRegions.java\n--- a/src/main/java/jadx/dex/visitors/regions/FinishRegions.java\n+++ b/src/main/java/jadx/dex/visitors/regions/FinishRegions.java\n@@ -1,33 +1,50 @@\n package jadx.dex.visitors.regions;\n \n import jadx.dex.instructions.InsnType;\n+import jadx.dex.instructions.args.ArgType;\n+import jadx.dex.nodes.BlockNode;\n import jadx.dex.nodes.IBlock;\n import jadx.dex.nodes.IRegion;\n import jadx.dex.nodes.InsnNode;\n import jadx.dex.nodes.MethodNode;\n import jadx.dex.regions.LoopRegion;\n \n+import java.util.Iterator;\n import java.util.List;\n \n-public class FinishRegions implements IRegionVisitor {\n-\n+public class FinishRegions extends TracedRegionVisitor {\n \t@Override\n-\tpublic void processBlock(MethodNode mth, IBlock block) {\n+\tpublic void processBlockTraced(MethodNode mth, IBlock container, IRegion currentRegion) {\n+\t\tif (container.getClass() != BlockNode.class)\n+\t\t\treturn;\n+\n+\t\tBlockNode block = (BlockNode) container;\n \n-\t\t// remove return from class init method\n-\t\tif (mth.getMethodInfo().isClassInit()) {\n+\t\t// remove last return in void functions\n+\t\tif (block.getCleanSuccessors().isEmpty()\n+\t\t\t\t&& mth.getReturnType().equals(ArgType.VOID)) {\n \t\t\tList<InsnNode> insns = block.getInstructions();\n-\t\t\tif (insns.size() != 0) {\n-\t\t\t\tInsnNode last = insns.get(insns.size() - 1);\n-\t\t\t\tif (last.getType() == InsnType.RETURN) {\n-\t\t\t\t\tinsns.remove(insns.size() - 1);\n+\t\t\tint lastIndex = insns.size() - 1;\n+\t\t\tif (lastIndex != -1) {\n+\t\t\t\tInsnNode last = insns.get(lastIndex);\n+\t\t\t\tif (last.getType() == InsnType.RETURN\n+\t\t\t\t\t\t&& blockNotInLoop(mth, block)) {\n+\t\t\t\t\tinsns.remove(lastIndex);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n-\t@Override\n-\tpublic void enterRegion(MethodNode mth, IRegion region) {\n+\tprivate boolean blockNotInLoop(MethodNode mth, BlockNode block) {\n+\t\tif (mth.getLoopForBlock(block) != null)\n+\t\t\treturn false;\n+\n+\t\tfor (Iterator<IRegion> it = regionStack.descendingIterator(); it.hasNext(); ) {\n+\t\t\tIRegion region = it.next();\n+\t\t\tif (region.getClass() == LoopRegion.class)\n+\t\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n \t}\n \n \t@Override\n@@ -36,6 +53,6 @@ public void leaveRegion(MethodNode mth, IRegion region) {\n \t\t\tLoopRegion loop = (LoopRegion) region;\n \t\t\tloop.mergePreCondition();\n \t\t}\n+\t\tsuper.leaveRegion(mth, region);\n \t}\n-\n }\n\ndiff --git a/src/main/java/jadx/dex/visitors/regions/TracedRegionVisitor.java b/src/main/java/jadx/dex/visitors/regions/TracedRegionVisitor.java\n--- a/src/main/java/jadx/dex/visitors/regions/TracedRegionVisitor.java\n+++ b/src/main/java/jadx/dex/visitors/regions/TracedRegionVisitor.java\n@@ -4,11 +4,12 @@\n import jadx.dex.nodes.IRegion;\n import jadx.dex.nodes.MethodNode;\n \n-import java.util.Stack;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n \n public abstract class TracedRegionVisitor implements IRegionVisitor {\n \n-\tprivate final Stack<IRegion> regionStack = new Stack<IRegion>();\n+\tprotected final Deque<IRegion> regionStack = new ArrayDeque<IRegion>();\n \n \t@Override\n \tpublic void enterRegion(MethodNode mth, IRegion region) {\n@@ -27,5 +28,4 @@ public void processBlock(MethodNode mth, IBlock container) {\n \tpublic void leaveRegion(MethodNode mth, IRegion region) {\n \t\tregionStack.pop();\n \t}\n-\n }",
    "output": "Remove unneeded 'return' instructions"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/visitors/MethodInlinerVisitor.java b/src/main/java/jadx/dex/visitors/MethodInlinerVisitor.java\n--- a/src/main/java/jadx/dex/visitors/MethodInlinerVisitor.java\n+++ b/src/main/java/jadx/dex/visitors/MethodInlinerVisitor.java\n@@ -3,6 +3,7 @@\n import jadx.dex.attributes.AttributeFlag;\n import jadx.dex.attributes.IAttribute;\n import jadx.dex.attributes.MethodInlineAttr;\n+import jadx.dex.info.AccessInfo;\n import jadx.dex.instructions.InsnType;\n import jadx.dex.nodes.BlockNode;\n import jadx.dex.nodes.InsnNode;\n@@ -13,34 +14,30 @@ public class MethodInlinerVisitor extends AbstractVisitor {\n \n \t@Override\n \tpublic void visit(MethodNode mth) throws JadxException {\n-\t\tif (mth.getAccessFlags().isSynthetic() && mth.getAccessFlags().isStatic()) {\n-\t\t\tif (mth.getBasicBlocks().size() == 1) {\n-\t\t\t\tBlockNode block = mth.getBasicBlocks().get(0);\n-\t\t\t\t// synthetic field getter\n-\t\t\t\tif (block.getInstructions().size() == 1) {\n-\t\t\t\t\tInsnNode insn = block.getInstructions().get(0);\n-\t\t\t\t\tif (insn.getType() == InsnType.RETURN) {\n-\t\t\t\t\t\tInsnNode inl = new InsnNode(InsnType.ARGS, 1);\n-\t\t\t\t\t\tinl.addArg(insn.getArg(0));\n-\t\t\t\t\t\taddInlineAttr(mth, inl);\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// synthetic field setter\n-\t\t\t\tif (block.getInstructions().size() == 2) {\n-\t\t\t\t\tif (block.getInstructions().get(1).getType() == InsnType.RETURN) {\n-\t\t\t\t\t\tInsnNode insn = block.getInstructions().get(0);\n-\t\t\t\t\t\taddInlineAttr(mth, insn);\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n+\t\tAccessInfo accessFlags = mth.getAccessFlags();\n+\t\tif (accessFlags.isSynthetic() && accessFlags.isStatic()) {\n+\t\t\tif (mth.getBasicBlocks().size() == 2) {\n+\t\t\t\tBlockNode block = mth.getBasicBlocks().get(1);\n+\t\t\t\tif (block.getAttributes().contains(AttributeFlag.RETURN)) {\n+\t\t\t\t\tinlineMth(mth);\n \t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n \n-\t\t\t\t// synthetic method invoke\n-\t\t\t\tif (block.getInstructions().size() == 1) {\n-\t\t\t\t\tInsnNode insn = block.getInstructions().get(0);\n-\t\t\t\t\taddInlineAttr(mth, insn);\n-\t\t\t\t}\n+\tprivate static void inlineMth(MethodNode mth) {\n+\t\tBlockNode firstBlock = mth.getBasicBlocks().get(0);\n+\t\tif (firstBlock.getInstructions().isEmpty()) {\n+\t\t\t// synthetic field getter\n+\t\t\tBlockNode block = mth.getBasicBlocks().get(1);\n+\t\t\tInsnNode insn = block.getInstructions().get(0);\n+\t\t\tInsnNode inl = new InsnNode(InsnType.ARGS, 1);\n+\t\t\tinl.addArg(insn.getArg(0));\n+\t\t\taddInlineAttr(mth, inl);\n+\t\t} else {\n+\t\t\t// synthetic field setter or method invoke\n+\t\t\tif (firstBlock.getInstructions().size() == 1) {\n+\t\t\t\taddInlineAttr(mth, firstBlock.getInstructions().get(0));\n \t\t\t}\n \t\t}\n \t}\n@@ -50,5 +47,4 @@ private static void addInlineAttr(MethodNode mth, InsnNode insn) {\n \t\tmth.getAttributes().add(attr);\n \t\tmth.getAttributes().add(AttributeFlag.DONT_GENERATE);\n \t}\n-\n }\n\ndiff --git a/src/samples/java/jadx/samples/AbstractTest.java b/src/samples/java/jadx/samples/AbstractTest.java\n--- a/src/samples/java/jadx/samples/AbstractTest.java\n+++ b/src/samples/java/jadx/samples/AbstractTest.java\n@@ -10,6 +10,12 @@ public static void assertTrue(boolean condition) {\n \t\t}\n \t}\n \n+\tpublic static void assertTrue(boolean condition, String msg) {\n+\t\tif (!condition) {\n+\t\t\tthrow new AssertionError(msg);\n+\t\t}\n+\t}\n+\n \tpublic static void assertEquals(int a1, int a2) {\n \t\tif (a1 != a2) {\n \t\t\tthrow new AssertionError(a1 + \" != \" + a2);\n\ndiff --git a/src/samples/java/jadx/samples/TestInner2.java b/src/samples/java/jadx/samples/TestInner2.java\n--- a/src/samples/java/jadx/samples/TestInner2.java\n+++ b/src/samples/java/jadx/samples/TestInner2.java\n@@ -1,5 +1,7 @@\n package jadx.samples;\n \n+import java.lang.reflect.Method;\n+\n public class TestInner2 extends AbstractTest {\n \n \tprivate String a;\n@@ -26,12 +28,56 @@ public String b() {\n \t\t}\n \t}\n \n+\tprivate String c;\n+\n+\tprivate void setC(String c) {\n+\t\tthis.c = c;\n+\t}\n+\n+\tpublic class C {\n+\t\tpublic String c() {\n+\t\t\tsetC(\"c\");\n+\t\t\treturn c;\n+\t\t}\n+\t}\n+\n+\tprivate static String d;\n+\n+\tprivate static void setD(String s) {\n+\t\td = s;\n+\t}\n+\n+\tpublic static class D {\n+\t\tpublic String d() {\n+\t\t\tsetD(\"d\");\n+\t\t\treturn d;\n+\t\t}\n+\t}\n+\n+\t// value from java.lang.reflect.Modifier\n+\tstatic final int SYNTHETIC = 0x00001000;\n+\n \t@Override\n \tpublic boolean testRun() throws Exception {\n \t\tassertTrue((new A()).a().equals(\"a\"));\n \t\tassertTrue(a.equals(\"a\"));\n+\n \t\tassertTrue((new B()).b().equals(\"b\"));\n \t\tassertTrue(b.equals(\"b\"));\n+\n+\t\tassertTrue((new C()).c().equals(\"c\"));\n+\t\tassertTrue(c.equals(\"c\"));\n+\n+\t\tassertTrue((new D()).d().equals(\"d\"));\n+\t\tassertTrue(d.equals(\"d\"));\n+\n+\t\tMethod[] mths = TestInner2.class.getDeclaredMethods();\n+\t\tfor (Method mth : mths) {\n+\t\t\tif(mth.getName().startsWith(\"access$\")) {\n+\t\t\t\tint modifiers = mth.getModifiers();\n+\t\t\t\tassertTrue((modifiers & SYNTHETIC) != 0, \"Synthetic methods must be removed\");\n+\t\t\t}\n+\t\t}\n \t\treturn true;\n \t}",
    "output": "Fix sythetic methods inline"
  },
  {
    "input": "diff --git a/src/main/java/jadx/codegen/InsnGen.java b/src/main/java/jadx/codegen/InsnGen.java\n--- a/src/main/java/jadx/codegen/InsnGen.java\n+++ b/src/main/java/jadx/codegen/InsnGen.java\n@@ -571,7 +571,7 @@ private void makeArith(ArithNode insn, CodeWriter code, EnumSet<InsnGenState> st\n \t\t\tcode.add('(').add(v1).add(' ').add(op.getSymbol()).add(' ').add(v2).add(')');\n \t\t} else {\n \t\t\tString res = arg(insn.getResult());\n-\t\t\tif (res.equals(v1)) {\n+\t\t\tif (res.equals(v1) && insn.getResult().equals(insn.getArg(0))) {\n \t\t\t\tstate.add(InsnGenState.NO_RESULT);\n \t\t\t\t// \"++\" or \"--\"\n \t\t\t\tif (insn.getArg(1).isLiteral() && (op == ArithOp.ADD || op == ArithOp.SUB)) {\n\ndiff --git a/src/main/java/jadx/codegen/MethodGen.java b/src/main/java/jadx/codegen/MethodGen.java\n--- a/src/main/java/jadx/codegen/MethodGen.java\n+++ b/src/main/java/jadx/codegen/MethodGen.java\n@@ -194,7 +194,7 @@ private String getUniqVarName(String name) {\n \t\tString r;\n \t\tint i = 2;\n \t\tdo {\n-\t\t\tr = name + i;\n+\t\t\tr = name + \"_\" + i;\n \t\t\ti++;\n \t\t} while (varNames.contains(r));\n \t\tvarNames.add(r);\n\ndiff --git a/src/main/java/jadx/dex/visitors/DotGraphVisitor.java b/src/main/java/jadx/dex/visitors/DotGraphVisitor.java\n--- a/src/main/java/jadx/dex/visitors/DotGraphVisitor.java\n+++ b/src/main/java/jadx/dex/visitors/DotGraphVisitor.java\n@@ -9,6 +9,7 @@\n import jadx.dex.nodes.InsnNode;\n import jadx.dex.nodes.MethodNode;\n import jadx.dex.trycatch.ExceptionHandler;\n+import jadx.utils.BlockUtils;\n import jadx.utils.InsnUtils;\n import jadx.utils.Utils;\n \n@@ -131,9 +132,11 @@ private void processBlock(MethodNode mth, BlockNode block, CodeWriter dot, CodeW\n \t\tfor (BlockNode next : block.getDominatesOn())\n \t\t\tconn.startLine(makeName(block) + \" -> \" + makeName(next) + \"[style=dotted];\");\n \n-\t\t// // add all dominators connections\n-\t\t// for (BlockNode next : BlockUtils.bitsetToBlocks(mth, block.getDoms()))\n-\t\t// conn.startLine(makeName(block) + \" -> \" + makeName(next) + \"[style=dotted, color=green];\");\n+\t\t// add all dominators connections\n+\t\tif (false) {\n+\t\t\tfor (BlockNode next : BlockUtils.bitsetToBlocks(mth, block.getDoms()))\n+\t\t\t\tconn.startLine(makeName(block) + \" -> \" + makeName(next) + \"[style=dotted, color=green];\");\n+\t\t}\n \t}\n \n \tprivate String attributesString(IAttributeNode block) {\n@@ -180,6 +183,7 @@ private String escape(String string) {\n \t\t\t\t.replace(\"{\", \"\\\\{\").replace(\"}\", \"\\\\}\")\n \t\t\t\t.replace(\"\\\"\", \"\\\\\\\"\")\n \t\t\t\t.replace(\"-\", \"\\\\-\")\n+\t\t\t\t.replace(\"|\", \"\\\\|\")\n \t\t\t\t.replace(\"\\n\", NL);\n \t}\n }\n\ndiff --git a/src/main/java/jadx/dex/visitors/ModVisitor.java b/src/main/java/jadx/dex/visitors/ModVisitor.java\n--- a/src/main/java/jadx/dex/visitors/ModVisitor.java\n+++ b/src/main/java/jadx/dex/visitors/ModVisitor.java\n@@ -1,6 +1,7 @@\n package jadx.dex.visitors;\n \n import jadx.Consts;\n+import jadx.deobf.NameMapper;\n import jadx.dex.attributes.AttributeType;\n import jadx.dex.info.MethodInfo;\n import jadx.dex.instructions.IndexInsnNode;\n@@ -37,9 +38,10 @@ public void visit(MethodNode mth) {\n \t\t\treturn;\n \n \t\tremoveStep(mth);\n-\n \t\treplaceStep(mth);\n \n+\t\tcheckArgsNames(mth);\n+\n \t\tfor (BlockNode block : mth.getBasicBlocks()) {\n \t\t\tprocessExceptionHander(mth, block);\n \t\t}\n@@ -229,4 +231,14 @@ public static boolean replaceInsn(BlockNode block, InsnNode oldInsn, InsnNode ne\n \t\treplaceInsn(block, pos, newInsn);\n \t\treturn true;\n \t}\n+\n+\tprivate void checkArgsNames(MethodNode mth) {\n+\t\tfor(RegisterArg arg : mth.getArguments(false)) {\n+\t\t\tString name = arg.getTypedVar().getName();\n+\t\t\tif(name != null && NameMapper.isReserved(name)) {\n+\t\t\t\tname = name + \"_\" ;\n+\t\t\t\targ.getTypedVar().setName(name);\n+\t\t\t}\n+\t\t}\n+\t}\n }",
    "output": "Fix codegen for arith ops, rename reserved arg names in methods"
  },
  {
    "input": "diff --git a/src/main/java/jadx/codegen/RegionGen.java b/src/main/java/jadx/codegen/RegionGen.java\n--- a/src/main/java/jadx/codegen/RegionGen.java\n+++ b/src/main/java/jadx/codegen/RegionGen.java\n@@ -152,7 +152,7 @@ private CodeWriter makeLoop(LoopRegion region, CodeWriter code) throws CodegenEx\n \t}\n \n \tprivate void makeSynchronizedRegion(SynchronizedRegion cont, CodeWriter code) throws CodegenException {\n-\t\tcode.startLine(\"synchronized(\").add(arg(cont.getArg())).add(\") {\");\n+\t\tcode.startLine(\"synchronized(\").add(arg(cont.getInsn().getArg(0))).add(\") {\");\n \t\tmakeRegionIndent(code, cont.getRegion());\n \t\tcode.startLine('}');\n \t}\n\ndiff --git a/src/main/java/jadx/dex/regions/SynchronizedRegion.java b/src/main/java/jadx/dex/regions/SynchronizedRegion.java\n--- a/src/main/java/jadx/dex/regions/SynchronizedRegion.java\n+++ b/src/main/java/jadx/dex/regions/SynchronizedRegion.java\n@@ -1,24 +1,24 @@\n package jadx.dex.regions;\n \n-import jadx.dex.instructions.args.RegisterArg;\n import jadx.dex.nodes.IContainer;\n import jadx.dex.nodes.IRegion;\n+import jadx.dex.nodes.InsnNode;\n \n import java.util.List;\n \n public final class SynchronizedRegion extends AbstractRegion {\n \n-\tprivate final RegisterArg arg;\n+\tprivate final InsnNode insn;\n \tprivate final Region region;\n \n-\tpublic SynchronizedRegion(IRegion parent, RegisterArg arg) {\n+\tpublic SynchronizedRegion(IRegion parent, InsnNode insn) {\n \t\tsuper(parent);\n-\t\tthis.arg = arg;\n+\t\tthis.insn = insn;\n \t\tthis.region = new Region(this);\n \t}\n \n-\tpublic RegisterArg getArg() {\n-\t\treturn arg;\n+\tpublic InsnNode getInsn() {\n+\t\treturn insn;\n \t}\n \n \tpublic Region getRegion() {\n\ndiff --git a/src/main/java/jadx/dex/visitors/regions/RegionMaker.java b/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n--- a/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n+++ b/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n@@ -9,7 +9,7 @@\n import jadx.dex.instructions.IfNode;\n import jadx.dex.instructions.InsnType;\n import jadx.dex.instructions.SwitchNode;\n-import jadx.dex.instructions.args.RegisterArg;\n+import jadx.dex.instructions.args.InsnArg;\n import jadx.dex.nodes.BlockNode;\n import jadx.dex.nodes.IRegion;\n import jadx.dex.nodes.InsnNode;\n@@ -269,14 +269,13 @@ private BlockNode processLoop(IRegion curRegion, LoopAttr loop, RegionStack stac\n \tprivate static final Set<BlockNode> cacheSet = new HashSet<BlockNode>();\n \n \tprivate BlockNode processMonitorEnter(IRegion curRegion, BlockNode block, InsnNode insn, RegionStack stack) {\n-\t\tRegisterArg arg = (RegisterArg) insn.getArg(0);\n-\t\tSynchronizedRegion synchRegion = new SynchronizedRegion(curRegion, arg);\n+\t\tSynchronizedRegion synchRegion = new SynchronizedRegion(curRegion, insn);\n \t\tsynchRegion.getSubBlocks().add(block);\n \t\tcurRegion.getSubBlocks().add(synchRegion);\n \n \t\tSet<BlockNode> exits = new HashSet<BlockNode>();\n \t\tcacheSet.clear();\n-\t\ttraverseMonitorExits(arg, block, exits, cacheSet);\n+\t\ttraverseMonitorExits(insn.getArg(0), block, exits, cacheSet);\n \n \t\tblock = BlockUtils.getNextBlock(block);\n \t\tBlockNode exit;\n@@ -298,7 +297,7 @@ private BlockNode processMonitorEnter(IRegion curRegion, BlockNode block, InsnNo\n \t/**\n \t * Traverse from monitor-enter thru successors and collect blocks contains monitor-exit\n \t */\n-\tprivate void traverseMonitorExits(RegisterArg arg, BlockNode block, Set<BlockNode> exits, Set<BlockNode> visited) {\n+\tprivate void traverseMonitorExits(InsnArg arg, BlockNode block, Set<BlockNode> exits, Set<BlockNode> visited) {\n \t\tvisited.add(block);\n \t\tfor (InsnNode insn : block.getInstructions()) {\n \t\t\tif (insn.getType() == InsnType.MONITOR_EXIT",
    "output": "Fix issue for wraped synchronized argument"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/instructions/InsnDecoder.java b/src/main/java/jadx/dex/instructions/InsnDecoder.java\n--- a/src/main/java/jadx/dex/instructions/InsnDecoder.java\n+++ b/src/main/java/jadx/dex/instructions/InsnDecoder.java\n@@ -151,13 +151,8 @@ private InsnNode decode(DecodedInstruction insn, int offset) throws DecodeExcept\n \t\t\tcase Opcodes.SUB_INT_2ADDR:\n \t\t\t\treturn arith(insn, ArithOp.SUB, ArgType.INT);\n \n-\t\t\tcase Opcodes.RSUB_INT:\n-\t\t\t\treturn new ArithNode(ArithOp.SUB,\n-\t\t\t\t\t\tInsnArg.reg(insn, 0, ArgType.INT),\n-\t\t\t\t\t\tInsnArg.reg(insn, 2, ArgType.INT),\n-\t\t\t\t\t\tInsnArg.reg(insn, 1, ArgType.INT));\n-\n \t\t\tcase Opcodes.RSUB_INT_LIT8:\n+\t\t\tcase Opcodes.RSUB_INT: // LIT16\n \t\t\t\treturn new ArithNode(ArithOp.SUB,\n \t\t\t\t\t\tInsnArg.reg(insn, 0, ArgType.INT),\n \t\t\t\t\t\tInsnArg.lit(insn, ArgType.INT),",
    "output": "Fix 'rsub-int' instruction decoding"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/trycatch/ExceptionHandler.java b/src/main/java/jadx/dex/trycatch/ExceptionHandler.java\n--- a/src/main/java/jadx/dex/trycatch/ExceptionHandler.java\n+++ b/src/main/java/jadx/dex/trycatch/ExceptionHandler.java\n@@ -2,7 +2,7 @@\n \n import jadx.Consts;\n import jadx.dex.info.ClassInfo;\n-import jadx.dex.instructions.args.InsnArg;\n+import jadx.dex.instructions.args.RegisterArg;\n import jadx.dex.nodes.BlockNode;\n import jadx.dex.nodes.IContainer;\n import jadx.utils.InsnUtils;\n@@ -18,7 +18,9 @@ public class ExceptionHandler {\n \tprivate BlockNode handleBlock;\n \tprivate final List<BlockNode> blocks = new ArrayList<BlockNode>();\n \tprivate IContainer handlerRegion;\n-\tprivate InsnArg arg;\n+\tprivate RegisterArg arg;\n+\n+\tprivate TryCatchBlock tryBlock;\n \n \tpublic ExceptionHandler(int addr, ClassInfo type) {\n \t\tthis.handleOffset = addr;\n@@ -61,14 +63,22 @@ public void setHandlerRegion(IContainer handlerRegion) {\n \t\tthis.handlerRegion = handlerRegion;\n \t}\n \n-\tpublic InsnArg getArg() {\n+\tpublic RegisterArg getArg() {\n \t\treturn arg;\n \t}\n \n-\tpublic void setArg(InsnArg arg) {\n+\tpublic void setArg(RegisterArg arg) {\n \t\tthis.arg = arg;\n \t}\n \n+\tpublic void setTryBlock(TryCatchBlock tryBlock) {\n+\t\tthis.tryBlock = tryBlock;\n+\t}\n+\n+\tpublic TryCatchBlock getTryBlock() {\n+\t\treturn tryBlock;\n+\t}\n+\n \t@Override\n \tpublic int hashCode() {\n \t\treturn (catchType == null ? 0 : 31 * catchType.hashCode()) + handleOffset;\n\ndiff --git a/src/main/java/jadx/dex/trycatch/TryCatchBlock.java b/src/main/java/jadx/dex/trycatch/TryCatchBlock.java\n--- a/src/main/java/jadx/dex/trycatch/TryCatchBlock.java\n+++ b/src/main/java/jadx/dex/trycatch/TryCatchBlock.java\n@@ -1,11 +1,15 @@\n package jadx.dex.trycatch;\n \n import jadx.dex.attributes.AttributeType;\n+import jadx.dex.attributes.IAttribute;\n import jadx.dex.info.ClassInfo;\n import jadx.dex.nodes.BlockNode;\n+import jadx.dex.nodes.IBlock;\n import jadx.dex.nodes.IContainer;\n+import jadx.dex.nodes.InsnContainer;\n import jadx.dex.nodes.InsnNode;\n import jadx.dex.nodes.MethodNode;\n+import jadx.dex.visitors.InstructionRemover;\n import jadx.utils.Utils;\n \n import java.util.ArrayList;\n@@ -36,6 +40,7 @@ public ExceptionHandler addHandler(MethodNode mth, int addr, ClassInfo type) {\n \t\tExceptionHandler handler = new ExceptionHandler(addr, type);\n \t\thandler = mth.addExceptionHandler(handler);\n \t\thandlers.add(handler);\n+\t\thandler.setTryBlock(this);\n \t\treturn handler;\n \t}\n \n@@ -52,14 +57,29 @@ public void removeHandler(MethodNode mth, ExceptionHandler handler) {\n \t}\n \n \tprivate void removeWholeBlock(MethodNode mth) {\n+\t\tif (finalBlock != null) {\n+\t\t\t// search catch attr\n+\t\t\tfor (BlockNode block : mth.getBasicBlocks()) {\n+\t\t\t\tCatchAttr cb = (CatchAttr) block.getAttributes().get(AttributeType.CATCH_BLOCK);\n+\t\t\t\tif (cb == attr) {\n+\t\t\t\t\tfor (ExceptionHandler eh : mth.getExceptionHandlers()) {\n+\t\t\t\t\t\tif (eh.getBlocks().contains(block)) {\n+\t\t\t\t\t\t\tTryCatchBlock tb = eh.getTryBlock();\n+\t\t\t\t\t\t\ttb.setFinalBlockFromInsns(mth, ((IBlock) finalBlock).getInstructions());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\n \t\t// self destruction\n \t\tfor (InsnNode insn : insns)\n-\t\t\tinsn.getAttributes().remove(AttributeType.CATCH_BLOCK);\n+\t\t\tinsn.getAttributes().remove(attr);\n \n \t\tinsns.clear();\n-\t\tfor (BlockNode block : mth.getBasicBlocks()) {\n-\t\t\tblock.getAttributes().remove(AttributeType.CATCH_BLOCK);\n-\t\t}\n+\t\tfor (BlockNode block : mth.getBasicBlocks())\n+\t\t\tblock.getAttributes().remove(attr);\n \t}\n \n \tpublic void addInsn(InsnNode insn) {\n@@ -92,11 +112,34 @@ public void setFinalBlock(IContainer finalBlock) {\n \t\tthis.finalBlock = finalBlock;\n \t}\n \n+\tpublic void setFinalBlockFromInsns(MethodNode mth, List<InsnNode> insns) {\n+\t\tInsnContainer cont = new InsnContainer();\n+\t\tList<InsnNode> finalBlockInsns = new ArrayList<InsnNode>(insns);\n+\t\tcont.setInstructions(finalBlockInsns);\n+\t\tsetFinalBlock(cont);\n+\n+\t\tInstructionRemover.unbindInsnList(finalBlockInsns);\n+\n+\t\t// remove these instructions from other handlers\n+\t\tfor (ExceptionHandler h : getHandlers()) {\n+\t\t\tfor (BlockNode ehb : h.getBlocks())\n+\t\t\t\tehb.getInstructions().removeAll(finalBlockInsns);\n+\t\t}\n+\t\t// remove from blocks with this catch\n+\t\tfor (BlockNode b : mth.getBasicBlocks()) {\n+\t\t\tIAttribute ca = b.getAttributes().get(AttributeType.CATCH_BLOCK);\n+\t\t\tif (attr == ca)\n+\t\t\t\tb.getInstructions().removeAll(finalBlockInsns);\n+\t\t}\n+\t}\n+\n \tpublic void merge(MethodNode mth, TryCatchBlock tryBlock) {\n \t\tfor (InsnNode insn : tryBlock.getInsns())\n \t\t\tthis.addInsn(insn);\n \n \t\tthis.handlers.addAll(tryBlock.getHandlers());\n+\t\tfor (ExceptionHandler eh : handlers)\n+\t\t\teh.setTryBlock(this);\n \n \t\t// clear\n \t\ttryBlock.handlers.clear();\n\ndiff --git a/src/main/java/jadx/dex/visitors/ModVisitor.java b/src/main/java/jadx/dex/visitors/ModVisitor.java\n--- a/src/main/java/jadx/dex/visitors/ModVisitor.java\n+++ b/src/main/java/jadx/dex/visitors/ModVisitor.java\n@@ -2,7 +2,6 @@\n \n import jadx.Consts;\n import jadx.dex.attributes.AttributeType;\n-import jadx.dex.attributes.IAttribute;\n import jadx.dex.info.MethodInfo;\n import jadx.dex.instructions.IndexInsnNode;\n import jadx.dex.instructions.InsnType;\n@@ -12,7 +11,6 @@\n import jadx.dex.instructions.mods.ConstructorInsn;\n import jadx.dex.nodes.BlockNode;\n import jadx.dex.nodes.FieldNode;\n-import jadx.dex.nodes.InsnContainer;\n import jadx.dex.nodes.InsnNode;\n import jadx.dex.nodes.MethodNode;\n import jadx.dex.trycatch.ExcHandlerAttr;\n@@ -21,7 +19,6 @@\n import jadx.utils.BlockUtils;\n import jadx.utils.exceptions.JadxRuntimeException;\n \n-import java.util.ArrayList;\n import java.util.List;\n \n import org.slf4j.Logger;\n@@ -195,24 +192,8 @@ private void processExceptionHander(MethodNode mth, BlockNode block) {\n \n \t\t\t\t// move not removed instructions to 'finally' block\n \t\t\t\tif (size != 0) {\n-\t\t\t\t\tInsnContainer cont = new InsnContainer();\n-\t\t\t\t\tList<InsnNode> finalBlockInsns = new ArrayList<InsnNode>(insns);\n-\t\t\t\t\tcont.setInstructions(finalBlockInsns);\n-\t\t\t\t\ttryBlock.setFinalBlock(cont);\n-\n-\t\t\t\t\tInstructionRemover.unbindInsnList(finalBlockInsns);\n-\n-\t\t\t\t\t// remove these instructions from other handlers\n-\t\t\t\t\tfor (ExceptionHandler h : tryBlock.getHandlers()) {\n-\t\t\t\t\t\tfor (BlockNode ehb : h.getBlocks())\n-\t\t\t\t\t\t\tehb.getInstructions().removeAll(finalBlockInsns);\n-\t\t\t\t\t}\n-\t\t\t\t\t// remove from blocks with this catch\n-\t\t\t\t\tfor (BlockNode b : mth.getBasicBlocks()) {\n-\t\t\t\t\t\tIAttribute ca = b.getAttributes().get(AttributeType.CATCH_BLOCK);\n-\t\t\t\t\t\tif (tryBlock.getCatchAttr() == ca)\n-\t\t\t\t\t\t\tb.getInstructions().removeAll(finalBlockInsns);\n-\t\t\t\t\t}\n+\t\t\t\t\t// TODO: support instructions from several blocks\n+\t\t\t\t\ttryBlock.setFinalBlockFromInsns(mth, insns);\n \t\t\t\t\tsize = insns.size();\n \t\t\t\t}\n \t\t\t}\n\ndiff --git a/src/samples/java/jadx/samples/TestTryCatch.java b/src/samples/java/jadx/samples/TestTryCatch.java\n--- a/src/samples/java/jadx/samples/TestTryCatch.java\n+++ b/src/samples/java/jadx/samples/TestTryCatch.java\n@@ -118,6 +118,31 @@ private static boolean test7() {\n \t\t}\n \t}\n \n+\tprivate boolean test8(Object obj) {\n+\t\tthis.mDiscovering = false;\n+\t\ttry {\n+\t\t\texc(obj);\n+\t\t} catch (Exception e) {\n+\t\t\te.toString();\n+\t\t} finally {\n+\t\t\tmDiscovering = true;\n+\t\t}\n+\t\treturn mDiscovering;\n+\t}\n+\n+\tprivate boolean test8a(Object obj) {\n+\t\tthis.mDiscovering = false;\n+\t\ttry {\n+\t\t\texc(obj);\n+\t\t} catch (Exception e) {\n+\t\t\te.toString();\n+\t\t} finally {\n+\t\t\tif (!mDiscovering)\n+\t\t\t\tmDiscovering = true;\n+\t\t}\n+\t\treturn mDiscovering;\n+\t}\n+\n \tprivate static boolean testSynchronize(Object obj) throws InterruptedException {\n \t\tsynchronized (obj) {\n \t\t\tif (obj instanceof String)\n@@ -127,6 +152,7 @@ private static boolean testSynchronize(Object obj) throws InterruptedException {\n \t\treturn true;\n \t}\n \n+\t// TODO: remove 'synchronized(TestTryCatch.class)' block in decompiled version\n \tprivate synchronized static boolean testSynchronize2(Object obj) throws InterruptedException {\n \t\treturn obj.toString() != null;\n \t}\n@@ -159,6 +185,12 @@ public boolean testRun() throws Exception {\n \n \t\tassertTrue(testSynchronize2(\"str\"));\n \t\tassertTrue(testSynchronize3());\n+\n+\t\tassertTrue(test8(\"a\"));\n+\t\tassertTrue(test8(null));\n+\n+\t\tassertTrue(test8a(\"a\"));\n+\t\tassertTrue(test8a(null));\n \t\treturn true;\n \t}",
    "output": "Fix try/catch/finally block processing"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/attributes/AttributeType.java b/src/main/java/jadx/dex/attributes/AttributeType.java\n--- a/src/main/java/jadx/dex/attributes/AttributeType.java\n+++ b/src/main/java/jadx/dex/attributes/AttributeType.java\n@@ -8,12 +8,10 @@ public enum AttributeType {\n \n \t// blocks\n \tLOOP(false),\n-\n \tCATCH_BLOCK(false),\n-\tEXC_HANDLER(true),\n \n+\tEXC_HANDLER(true),\n \tSPLITTER_BLOCK(true),\n-\n \tFORCE_RETURN(true),\n \n \t// fields\n@@ -32,8 +30,25 @@ public enum AttributeType {\n \n \tDECLARE_VARIABLE(true);\n \n+\tprivate static final int notUniqCount;\n \tprivate final boolean uniq;\n \n+\tstatic {\n+\t\t// place all not unique attributes at first\n+\t\tint last = -1;\n+\t\tAttributeType[] vals = AttributeType.values();\n+\t\tfor (int i = 0; i < vals.length; i++) {\n+\t\t\tAttributeType type = vals[i];\n+\t\t\tif (type.notUniq())\n+\t\t\t\tlast = i;\n+\t\t}\n+\t\tnotUniqCount = last + 1;\n+\t}\n+\n+\tpublic static int getNotUniqCount() {\n+\t\treturn notUniqCount;\n+\t}\n+\n \tprivate AttributeType(boolean isUniq) {\n \t\tthis.uniq = isUniq;\n \t}\n\ndiff --git a/src/main/java/jadx/dex/attributes/AttributesList.java b/src/main/java/jadx/dex/attributes/AttributesList.java\n--- a/src/main/java/jadx/dex/attributes/AttributesList.java\n+++ b/src/main/java/jadx/dex/attributes/AttributesList.java\n@@ -14,6 +14,12 @@\n import java.util.Map;\n import java.util.Set;\n \n+/**\n+ * Storage for different attribute types:\n+ * 1. flags - boolean attribute (set or not)\n+ * 2. attribute - class instance associated for attribute type,\n+ * only one attached to node for unique attributes, multiple for others\n+ */\n public class AttributesList {\n \n \tprivate final Set<AttributeFlag> flags;\n@@ -24,16 +30,11 @@ public class AttributesList {\n \tpublic AttributesList() {\n \t\tflags = EnumSet.noneOf(AttributeFlag.class);\n \t\tuniqAttr = new EnumMap<AttributeType, IAttribute>(AttributeType.class);\n-\t\tattributes = new ArrayList<IAttribute>(1);\n-\t\tattrCount = new int[AttributeType.values().length];\n+\t\tattributes = new ArrayList<IAttribute>(0);\n+\t\tattrCount = new int[AttributeType.getNotUniqCount()];\n \t}\n \n-\tpublic void add(IAttribute attr) {\n-\t\tif (attr.getType().isUniq())\n-\t\t\tuniqAttr.put(attr.getType(), attr);\n-\t\telse\n-\t\t\taddMultiAttribute(attr);\n-\t}\n+\t// Flags\n \n \tpublic void add(AttributeFlag flag) {\n \t\tflags.add(flag);\n@@ -47,12 +48,21 @@ public void remove(AttributeFlag flag) {\n \t\tflags.remove(flag);\n \t}\n \n+\t// Attributes\n+\n+\tpublic void add(IAttribute attr) {\n+\t\tif (attr.getType().isUniq())\n+\t\t\tuniqAttr.put(attr.getType(), attr);\n+\t\telse\n+\t\t\taddMultiAttribute(attr);\n+\t}\n+\n \tprivate void addMultiAttribute(IAttribute attr) {\n \t\tattributes.add(attr);\n \t\tattrCount[attr.getType().ordinal()]++;\n \t}\n \n-\tprivate int getCountInternal(AttributeType type) {\n+\tprivate int getMultiCountInternal(AttributeType type) {\n \t\treturn attrCount[type.ordinal()];\n \t}\n \n@@ -67,15 +77,14 @@ public boolean contains(AttributeType type) {\n \t\tif (type.isUniq())\n \t\t\treturn uniqAttr.containsKey(type);\n \t\telse\n-\t\t\treturn getCountInternal(type) != 0;\n+\t\t\treturn getMultiCountInternal(type) != 0;\n \t}\n \n \tpublic IAttribute get(AttributeType type) {\n \t\tif (type.isUniq()) {\n \t\t\treturn uniqAttr.get(type);\n \t\t} else {\n-\t\t\tint count = getCountInternal(type);\n-\t\t\tif (count != 0) {\n+\t\t\tif (getMultiCountInternal(type) != 0) {\n \t\t\t\tfor (IAttribute attr : attributes)\n \t\t\t\t\tif (attr.getType() == type)\n \t\t\t\t\t\treturn attr;\n@@ -86,9 +95,9 @@ public IAttribute get(AttributeType type) {\n \n \tpublic int getCount(AttributeType type) {\n \t\tif (type.isUniq()) {\n-\t\t\treturn 0;\n+\t\t\treturn uniqAttr.containsKey(type) ? 1 : 0;\n \t\t} else {\n-\t\t\treturn getCountInternal(type);\n+\t\t\treturn getMultiCountInternal(type);\n \t\t}\n \t}\n \n@@ -103,7 +112,7 @@ public Annotation getAnnotation(String cls) {\n \tpublic List<IAttribute> getAll(AttributeType type) {\n \t\tassert type.notUniq();\n \n-\t\tint count = getCountInternal(type);\n+\t\tint count = getMultiCountInternal(type);\n \t\tif (count == 0) {\n \t\t\treturn Collections.emptyList();\n \t\t} else {\n@@ -129,6 +138,26 @@ public void remove(AttributeType type) {\n \t\t}\n \t}\n \n+\tpublic void remove(IAttribute attr) {\n+\t\tAttributeType type = attr.getType();\n+\t\tif (type.isUniq()) {\n+\t\t\tIAttribute a = uniqAttr.get(type);\n+\t\t\tif (a == attr)\n+\t\t\t\tuniqAttr.remove(type);\n+\t\t} else {\n+\t\t\tif (getMultiCountInternal(type) == 0)\n+\t\t\t\treturn;\n+\n+\t\t\tfor (Iterator<IAttribute> it = attributes.iterator(); it.hasNext();) {\n+\t\t\t\tIAttribute a = it.next();\n+\t\t\t\tif (a == attr) {\n+\t\t\t\t\tit.remove();\n+\t\t\t\t\tattrCount[type.ordinal()]--;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tpublic void clear() {\n \t\tflags.clear();\n \t\tuniqAttr.clear();",
    "output": "Fix errors in AttributesList, refactoring"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/visitors/regions/RegionMaker.java b/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n--- a/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n+++ b/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n@@ -124,17 +124,17 @@ private BlockNode processLoop(IRegion curRegion, LoopAttr loop, RegionStack stac\n \t\tIfNode ifnode = null;\n \t\tLoopRegion loopRegion = null;\n \t\tSet<BlockNode> exitBlocksSet = loop.getExitNodes();\n+\n \t\t// set exit blocks scan order by priority\n-\t\t// this can help if we have several exit from loop (after using 'break' or 'return' in loop)\n+\t\t// this can help if loop have several exits (after using 'break' or 'return' in loop)\n \t\tList<BlockNode> exitBlocks = new ArrayList<BlockNode>(exitBlocksSet.size());\n-\t\tif (exitBlocksSet.contains(loop.getEnd())) {\n+\t\tBlockNode nextStart = BlockUtils.getNextBlock(loopStart);\n+\t\tif (nextStart != null && exitBlocksSet.remove(nextStart))\n+\t\t\texitBlocks.add(nextStart);\n+\t\tif (exitBlocksSet.remove(loop.getEnd()))\n \t\t\texitBlocks.add(loop.getEnd());\n-\t\t\texitBlocksSet.remove(loop.getEnd());\n-\t\t}\n-\t\tif (exitBlocksSet.contains(loopStart)) {\n+\t\tif (exitBlocksSet.remove(loopStart))\n \t\t\texitBlocks.add(loopStart);\n-\t\t\texitBlocksSet.remove(loopStart);\n-\t\t}\n \t\texitBlocks.addAll(exitBlocksSet);\n \t\texitBlocksSet = null;\n \n@@ -189,7 +189,11 @@ private BlockNode processLoop(IRegion curRegion, LoopAttr loop, RegionStack stac\n \t\t\tstack.pop();\n \t\t\tloopStart.getAttributes().add(loop);\n \n-\t\t\treturn BlockUtils.getNextBlock(loop.getEnd());\n+\t\t\tBlockNode next = BlockUtils.getNextBlock(loop.getEnd());\n+\t\t\tif (!RegionUtils.isRegionContainsBlock(body, next))\n+\t\t\t\treturn next;\n+\t\t\telse\n+\t\t\t\treturn null;\n \t\t}\n \n \t\tstack.push(loopRegion);\n@@ -372,6 +376,10 @@ private BlockNode processIf(IRegion currentRegion, BlockNode block, IfNode ifnod\n \t\t\t}\n \t\t}\n \n+\t\tif (BlockUtils.isBackEdge(block, out)) {\n+\t\t\tout = null;\n+\t\t}\n+\n \t\tif (stack.containsExit(elseBlock))\n \t\t\telseBlock = null;\n \n\ndiff --git a/src/main/java/jadx/utils/BlockUtils.java b/src/main/java/jadx/utils/BlockUtils.java\n--- a/src/main/java/jadx/utils/BlockUtils.java\n+++ b/src/main/java/jadx/utils/BlockUtils.java\n@@ -48,6 +48,16 @@ public static List<BlockNode> cleanBlockList(List<BlockNode> list) {\n \t\treturn ret;\n \t}\n \n+\tpublic static boolean isBackEdge(BlockNode from, BlockNode to) {\n+\t\tif (from.getCleanSuccessors().contains(to))\n+\t\t\treturn false; // already checked\n+\n+\t\tif (!from.getSuccessors().contains(to))\n+\t\t\treturn false; // not even successor\n+\n+\t\treturn true;\n+\t}\n+\n \t/**\n \t * Remove exception handlers from block nodes bitset\n \t */\n\ndiff --git a/src/samples/java/jadx/samples/TestCF3.java b/src/samples/java/jadx/samples/TestCF3.java\n--- a/src/samples/java/jadx/samples/TestCF3.java\n+++ b/src/samples/java/jadx/samples/TestCF3.java\n@@ -18,6 +18,10 @@ private int next() {\n \t\treturn 1;\n \t}\n \n+\tprivate int exc() throws Exception {\n+\t\treturn 1;\n+\t}\n+\n \tpublic void testSwitchInLoop() throws Exception {\n \t\twhile (true) {\n \t\t\tint n = next();\n@@ -103,6 +107,31 @@ public static boolean testLabeledBreakContinue() {\n \t\treturn foundIt;\n \t}\n \n+\tpublic String testReturnInLoop(List<String> list) {\n+\t\tIterator<String> it = list.iterator();\n+\t\twhile (it.hasNext()) {\n+\t\t\tString ver = it.next();\n+\t\t\tif (ver != null)\n+\t\t\t\treturn ver;\n+\t\t}\n+\t\treturn \"error\";\n+\t}\n+\n+\tpublic String testReturnInLoop2(List<String> list) {\n+\t\ttry {\n+\t\t\tIterator<String> it = list.iterator();\n+\t\t\twhile (it.hasNext()) {\n+\t\t\t\tString ver = it.next();\n+\t\t\t\texc();\n+\t\t\t\tif (ver != null)\n+\t\t\t\t\treturn ver;\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tsetEnabled(false);\n+\t\t}\n+\t\treturn \"error\";\n+\t}\n+\n \t@Override\n \tpublic boolean testRun() throws Exception {\n \t\tsetEnabled(false);\n@@ -117,6 +146,17 @@ public boolean testRun() throws Exception {\n \t\t\t\tnew ArrayList<String>(Arrays.asList(\"a1\", \"a2\")),\n \t\t\t\tnew ArrayList<String>(Arrays.asList(\"a1\", \"b2\"))));\n \n+\t\tList<String> list1 = Arrays.asList(null, \"a\", \"b\");\n+\n+\t\t// TODO this line required to omit generic information because it create List<Object>\n+\t\t// List<String> list2 = Arrays.asList(null, null, null);\n+\n+\t\tassertEquals(testReturnInLoop(list1), \"a\");\n+\t\tassertEquals(testReturnInLoop2(list1), \"a\");\n+\n+\t\t// assertEquals(testReturnInLoop(list2), \"error\");\n+\t\t// assertEquals(testReturnInLoop2(list2), \"error\");\n+\n \t\t// assertTrue(testLabeledBreakContinue());\n \t\treturn true;\n \t}",
    "output": "Fix loops processing"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/visitors/typeresolver/finish/PostTypeResolver.java b/src/main/java/jadx/dex/visitors/typeresolver/finish/PostTypeResolver.java\n--- a/src/main/java/jadx/dex/visitors/typeresolver/finish/PostTypeResolver.java\n+++ b/src/main/java/jadx/dex/visitors/typeresolver/finish/PostTypeResolver.java\n@@ -40,16 +40,11 @@ public static boolean visit(InsnNode insn) {\n \t\t\t\treturn change;\n \t\t\t}\n \n-\t\t\tcase AGET: {\n-\t\t\t\tboolean change = false;\n-\t\t\t\tRegisterArg elem = insn.getResult();\n-\t\t\t\tInsnArg array = insn.getArg(0);\n-\t\t\t\tif (!elem.getType().isTypeKnown() && elem.merge(array.getType().getArrayElement()))\n-\t\t\t\t\tchange = true;\n-\t\t\t\tif (!array.getType().isTypeKnown() && array.merge(ArgType.array(elem.getType())))\n-\t\t\t\t\tchange = true;\n-\t\t\t\treturn change;\n-\t\t\t}\n+\t\t\tcase AGET:\n+\t\t\t\treturn fixArrayTypes(insn.getArg(0), insn.getResult());\n+\n+\t\t\tcase APUT:\n+\t\t\t\treturn fixArrayTypes(insn.getArg(0), insn.getArg(2));\n \n \t\t\tcase IF: {\n \t\t\t\tboolean change = false;\n@@ -69,4 +64,13 @@ public static boolean visit(InsnNode insn) {\n \t\treturn false;\n \n \t}\n+\n+\tprivate static boolean fixArrayTypes(InsnArg array, InsnArg elem) {\n+\t\tboolean change = false;\n+\t\tif (!elem.getType().isTypeKnown() && elem.merge(array.getType().getArrayElement()))\n+\t\t\tchange = true;\n+\t\tif (!array.getType().isTypeKnown() && array.merge(ArgType.array(elem.getType())))\n+\t\t\tchange = true;\n+\t\treturn change;\n+\t}\n }",
    "output": "Fix arguments types in array-put instruction"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/nodes/parser/DebugInfoParser.java b/src/main/java/jadx/dex/nodes/parser/DebugInfoParser.java\n--- a/src/main/java/jadx/dex/nodes/parser/DebugInfoParser.java\n+++ b/src/main/java/jadx/dex/nodes/parser/DebugInfoParser.java\n@@ -78,8 +78,7 @@ public void process(InsnNode[] insnByOffset) throws DecodeException {\n \t\t\t\t\tint nameId = section.readUleb128() - 1;\n \t\t\t\t\tint type = section.readUleb128() - 1;\n \t\t\t\t\tLocalVarInfo var = new LocalVarInfo(dex, regNum, nameId, type, DexNode.NO_INDEX);\n-\t\t\t\t\tvar.start(addr, line);\n-\t\t\t\t\tlocals[regNum] = var;\n+\t\t\t\t\tstartVar(var, locals, insnByOffset, addr, line);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tcase DBG_START_LOCAL_EXTENDED: {\n@@ -88,15 +87,17 @@ public void process(InsnNode[] insnByOffset) throws DecodeException {\n \t\t\t\t\tint type = section.readUleb128() - 1;\n \t\t\t\t\tint sign = section.readUleb128() - 1;\n \t\t\t\t\tLocalVarInfo var = new LocalVarInfo(dex, regNum, nameId, type, sign);\n-\t\t\t\t\tvar.start(addr, line);\n-\t\t\t\t\tlocals[regNum] = var;\n+\t\t\t\t\tstartVar(var, locals, insnByOffset, addr, line);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tcase DBG_RESTART_LOCAL: {\n \t\t\t\t\tint regNum = section.readUleb128();\n \t\t\t\t\tLocalVarInfo var = locals[regNum];\n-\t\t\t\t\tif (var != null)\n+\t\t\t\t\tif (var != null) {\n+\t\t\t\t\t\tvar.end(addr, line);\n+\t\t\t\t\t\tsetVar(var, insnByOffset);\n \t\t\t\t\t\tvar.start(addr, line);\n+\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tcase DBG_END_LOCAL: {\n@@ -141,6 +142,17 @@ public void process(InsnNode[] insnByOffset) throws DecodeException {\n \t\t}\n \t}\n \n+\tprivate void startVar(LocalVarInfo var, LocalVarInfo[] locals, InsnNode[] insnByOffset, int addr, int line) {\n+\t\tint regNum = var.getRegNum();\n+\t\tLocalVarInfo prev = locals[regNum];\n+\t\tif (prev != null && !prev.isEnd()) {\n+\t\t\tprev.end(addr, line);\n+\t\t\tsetVar(prev, insnByOffset);\n+\t\t}\n+\t\tvar.start(addr, line);\n+\t\tlocals[regNum] = var;\n+\t}\n+\n \tprivate void setVar(LocalVarInfo var, InsnNode[] insnByOffset) {\n \t\tint start = var.getStartAddr();\n \t\tint end = var.getEndAddr();",
    "output": "Fix setting variable name from debug info"
  },
  {
    "input": "diff --git a/src/main/java/jadx/codegen/RegionGen.java b/src/main/java/jadx/codegen/RegionGen.java\n--- a/src/main/java/jadx/codegen/RegionGen.java\n+++ b/src/main/java/jadx/codegen/RegionGen.java\n@@ -211,15 +211,12 @@ private CodeWriter makeSwitch(SwitchRegion sw, CodeWriter code) throws CodegenEx\n \n \tprivate void makeCaseBlock(IContainer c, CodeWriter code) throws CodegenException {\n \t\tif (RegionUtils.notEmpty(c)) {\n-\t\t\tboolean closeBlock = RegionUtils.hasExitEdge(c);\n-\t\t\tif (closeBlock) {\n-\t\t\t\tcode.add(\" {\");\n-\t\t\t}\n+\t\t\tcode.add(\" {\");\n \t\t\tmakeRegionIndent(code, c);\n-\t\t\tif (closeBlock) {\n+\t\t\tif (RegionUtils.hasExitEdge(c)) {\n \t\t\t\tcode.startLine(1, \"break;\");\n-\t\t\t\tcode.startLine('}');\n \t\t\t}\n+\t\t\tcode.startLine('}');\n \t\t} else {\n \t\t\tcode.startLine(1, \"break;\");\n \t\t}\n\ndiff --git a/src/main/java/jadx/dex/instructions/mods/ConstructorInsn.java b/src/main/java/jadx/dex/instructions/mods/ConstructorInsn.java\n--- a/src/main/java/jadx/dex/instructions/mods/ConstructorInsn.java\n+++ b/src/main/java/jadx/dex/instructions/mods/ConstructorInsn.java\n@@ -19,7 +19,7 @@ private static enum CallType {\n \t\tSELF // call itself\n \t}\n \n-\tprivate final CallType callType;\n+\tprivate CallType callType;\n \n \tpublic ConstructorInsn(MethodNode mth, InvokeNode invoke) {\n \t\tsuper(InsnType.CONSTRUCTOR, invoke.getArgsCount() - 1);\n@@ -28,16 +28,17 @@ public ConstructorInsn(MethodNode mth, InvokeNode invoke) {\n \n \t\tif (invoke.getArg(0).isThis()) {\n \t\t\tif (classType.equals(mth.getParentClass().getClassInfo())) {\n-\t\t\t\t// self constructor\n \t\t\t\tif (callMth.getShortId().equals(mth.getMethodInfo().getShortId())) {\n+\t\t\t\t\t// self constructor\n \t\t\t\t\tcallType = CallType.SELF;\n-\t\t\t\t} else {\n+\t\t\t\t} else if (mth.getMethodInfo().isConstructor()) {\n \t\t\t\t\tcallType = CallType.THIS;\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tcallType = CallType.SUPER;\n \t\t\t}\n-\t\t} else {\n+\t\t}\n+\t\tif (callType == null) {\n \t\t\tcallType = CallType.CONSTRUCTOR;\n \t\t\tsetResult((RegisterArg) invoke.getArg(0));\n \t\t}\n\ndiff --git a/src/main/java/jadx/dex/visitors/regions/RegionMaker.java b/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n--- a/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n+++ b/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n@@ -207,7 +207,10 @@ private BlockNode processLoop(IRegion curRegion, LoopAttr loop, RegionStack stac\n \t\t\t\t\t\t// found cross\n \t\t\t\t\t\tif (next.getCleanSuccessors().size() == 1) {\n \t\t\t\t\t\t\tBlockNode r = BlockUtils.getNextBlock(next);\n-\t\t\t\t\t\t\tif (r != null && r.getAttributes().contains(AttributeFlag.RETURN)) {\n+\t\t\t\t\t\t\tif (r != null\n+\t\t\t\t\t\t\t\t\t&& r.getAttributes().contains(AttributeFlag.RETURN)\n+\t\t\t\t\t\t\t\t\t&& r.getInstructions().size() > 0\n+\t\t\t\t\t\t\t\t\t&& r.getInstructions().get(0).getType() == InsnType.RETURN) {\n \t\t\t\t\t\t\t\tnext.getAttributes().add(new ForceReturnAttr(r.getInstructions().get(0)));\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tnext.getAttributes().add(AttributeFlag.BREAK);\n\ndiff --git a/src/samples/java/jadx/samples/TestInvoke.java b/src/samples/java/jadx/samples/TestInvoke.java\n--- a/src/samples/java/jadx/samples/TestInvoke.java\n+++ b/src/samples/java/jadx/samples/TestInvoke.java\n@@ -3,9 +3,16 @@\n import java.util.Arrays;\n \n public class TestInvoke extends AbstractTest {\n-\n \tprivate int f;\n \n+\tpublic TestInvoke() {\n+\t\tthis(-1);\n+\t}\n+\n+\tpublic TestInvoke(int f) {\n+\t\tthis.f = f;\n+\t}\n+\n \tprivate void parse(String[] args) {\n \t\tif (args.length > 0)\n \t\t\tf = Integer.parseInt(args[0]);\n@@ -30,6 +37,13 @@ private String testVarArgs2(char[]... args) {\n \t\treturn s;\n \t}\n \n+\tpublic TestInvoke testConstructor(int flag) {\n+\t\tif (getF() == flag)\n+\t\t\treturn new TestInvoke(flag);\n+\t\telse\n+\t\t\treturn this;\n+\t}\n+\n \t@Override\n \tpublic boolean testRun() throws Exception {\n \t\tTestInvoke inv = new TestInvoke();\n@@ -41,6 +55,8 @@ public boolean testRun() throws Exception {\n \n \t\tassertTrue(inv.testVarArgs(\"a\", \"2\", \"III\"));\n \t\tassertTrue(inv.testVarArgs2(\"a\".toCharArray(), new char[] { '1', '2' }).equals(\"a12\"));\n+\n+\t\tassertTrue(testConstructor(f) != this);\n \t\treturn true;\n \t}",
    "output": "Fix self constructor call"
  },
  {
    "input": "diff --git a/src/main/java/jadx/codegen/CodeWriter.java b/src/main/java/jadx/codegen/CodeWriter.java\n--- a/src/main/java/jadx/codegen/CodeWriter.java\n+++ b/src/main/java/jadx/codegen/CodeWriter.java\n@@ -36,6 +36,13 @@ public CodeWriter startLine(String str) {\n \t\treturn this;\n \t}\n \n+\tpublic CodeWriter startLine(char c) {\n+\t\tbuf.append(NL);\n+\t\tbuf.append(indentStr);\n+\t\tbuf.append(c);\n+\t\treturn this;\n+\t}\n+\n \tpublic CodeWriter startLine(int ind, String str) {\n \t\tbuf.append(NL);\n \t\tbuf.append(indentStr);\n\ndiff --git a/src/main/java/jadx/codegen/RegionGen.java b/src/main/java/jadx/codegen/RegionGen.java\n--- a/src/main/java/jadx/codegen/RegionGen.java\n+++ b/src/main/java/jadx/codegen/RegionGen.java\n@@ -107,7 +107,7 @@ private void makeIf(IfRegion region, CodeWriter code) throws CodegenException {\n \t\tIfNode insn = region.getIfInsn();\n \t\tcode.add(\"if \").add(makeCondition(insn)).add(\" {\");\n \t\tmakeRegionIndent(code, region.getThenRegion());\n-\t\tcode.startLine(\"}\");\n+\t\tcode.startLine('}');\n \n \t\tIContainer els = region.getElseRegion();\n \t\tif (els != null && RegionUtils.notEmpty(els)) {\n@@ -123,11 +123,11 @@ private void makeIf(IfRegion region, CodeWriter code) throws CodegenException {\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tcode.add(\"{\");\n+\t\t\tcode.add('{');\n \t\t\tcode.incIndent();\n \t\t\tmakeRegion(code, els);\n \t\t\tcode.decIndent();\n-\t\t\tcode.startLine(\"}\");\n+\t\t\tcode.startLine('}');\n \t\t}\n \t}\n \n@@ -136,27 +136,27 @@ private CodeWriter makeLoop(LoopRegion region, CodeWriter code) throws CodegenEx\n \t\t\t// infinite loop\n \t\t\tcode.startLine(\"while (true) {\");\n \t\t\tmakeRegionIndent(code, region.getBody());\n-\t\t\tcode.startLine(\"}\");\n+\t\t\tcode.startLine('}');\n \t\t\treturn code;\n \t\t}\n \n \t\tIfNode insn = region.getIfInsn();\n \t\tif (!region.isConditionAtEnd()) {\n \t\t\tcode.startLine(\"while \").add(makeCondition(insn)).add(\" {\");\n \t\t\tmakeRegionIndent(code, region.getBody());\n-\t\t\tcode.startLine(\"}\");\n+\t\t\tcode.startLine('}');\n \t\t} else {\n \t\t\tcode.startLine(\"do {\");\n \t\t\tmakeRegionIndent(code, region.getBody());\n-\t\t\tcode.startLine(\"} while \").add(makeCondition(insn)).add(\";\");\n+\t\t\tcode.startLine(\"} while \").add(makeCondition(insn)).add(';');\n \t\t}\n \t\treturn code;\n \t}\n \n \tprivate void makeSynchronizedRegion(SynchronizedRegion cont, CodeWriter code) throws CodegenException {\n \t\tcode.startLine(\"synchronized(\").add(arg(cont.getArg())).add(\") {\");\n \t\tmakeRegionIndent(code, cont.getRegion());\n-\t\tcode.startLine(\"}\");\n+\t\tcode.startLine('}');\n \t}\n \n \tprivate String makeCondition(IfNode insn) throws CodegenException {\n@@ -194,25 +194,37 @@ private CodeWriter makeSwitch(SwitchRegion sw, CodeWriter code) throws CodegenEx\n \t\t\tList<Integer> keys = sw.getKeys().get(i);\n \t\t\tIContainer c = sw.getCases().get(i);\n \t\t\tfor (Integer k : keys) {\n-\t\t\t\tcode.startLine(\"case \")\n-\t\t\t\t\t\t.add(TypeGen.literalToString(k, arg.getType()))\n-\t\t\t\t\t\t.add(\":\");\n+\t\t\t\tcode.startLine(\"case \");\n+\t\t\t\tcode.add(TypeGen.literalToString(k, arg.getType()));\n+\t\t\t\tcode.add(':');\n \t\t\t}\n-\t\t\tmakeRegionIndent(code, c);\n-\t\t\tif (RegionUtils.hasExitEdge(c))\n-\t\t\t\tcode.startLine(1, \"break;\");\n+\t\t\tmakeCaseBlock(c, code);\n \t\t}\n \t\tif (sw.getDefaultCase() != null) {\n \t\t\tcode.startLine(\"default:\");\n-\t\t\tmakeRegionIndent(code, sw.getDefaultCase());\n-\t\t\tif (RegionUtils.hasExitEdge(sw.getDefaultCase()))\n-\t\t\t\tcode.startLine(1, \"break;\");\n+\t\t\tmakeCaseBlock(sw.getDefaultCase(), code);\n \t\t}\n \t\tcode.decIndent();\n-\t\tcode.startLine(\"}\");\n+\t\tcode.startLine('}');\n \t\treturn code;\n \t}\n \n+\tprivate void makeCaseBlock(IContainer c, CodeWriter code) throws CodegenException {\n+\t\tif (RegionUtils.notEmpty(c)) {\n+\t\t\tboolean closeBlock = RegionUtils.hasExitEdge(c);\n+\t\t\tif (closeBlock) {\n+\t\t\t\tcode.add(\" {\");\n+\t\t\t}\n+\t\t\tmakeRegionIndent(code, c);\n+\t\t\tif (closeBlock) {\n+\t\t\t\tcode.startLine(1, \"break;\");\n+\t\t\t\tcode.startLine('}');\n+\t\t\t}\n+\t\t} else {\n+\t\t\tcode.startLine(1, \"break;\");\n+\t\t}\n+\t}\n+\n \tprivate void makeTryCatch(IContainer region, TryCatchBlock tryCatchBlock, CodeWriter code)\n \t\t\tthrows CodegenException {\n \t\tcode.startLine(\"try {\");\n@@ -235,7 +247,7 @@ private void makeTryCatch(IContainer region, TryCatchBlock tryCatchBlock, CodeWr\n \t\t\tcode.startLine(\"} finally {\");\n \t\t\tmakeRegionIndent(code, tryCatchBlock.getFinalBlock());\n \t\t}\n-\t\tcode.startLine(\"}\");\n+\t\tcode.startLine('}');\n \t}\n \n \tprivate void makeCatchBlock(CodeWriter code, ExceptionHandler handler)\n\ndiff --git a/src/main/java/jadx/dex/visitors/ModVisitor.java b/src/main/java/jadx/dex/visitors/ModVisitor.java\n--- a/src/main/java/jadx/dex/visitors/ModVisitor.java\n+++ b/src/main/java/jadx/dex/visitors/ModVisitor.java\n@@ -148,10 +148,13 @@ private void removeStep(MethodNode mth) {\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase RETURN:\n-\t\t\t\t\t\tif (insn.getArgsCount() == 0\n-\t\t\t\t\t\t\t\t&& mth.getBasicBlocks().size() == 1\n-\t\t\t\t\t\t\t\t&& i == size - 1)\n-\t\t\t\t\t\t\tremover.add(insn);\n+\t\t\t\t\t\tif (insn.getArgsCount() == 0) {\n+\t\t\t\t\t\t\tif (mth.getBasicBlocks().size() == 1 && i == size - 1) {\n+\t\t\t\t\t\t\t\tremover.add(insn);\n+\t\t\t\t\t\t\t} else if (mth.getMethodInfo().isClassInit()) {\n+\t\t\t\t\t\t\t\tremover.add(insn);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tdefault:\n\ndiff --git a/src/main/java/jadx/dex/visitors/regions/RegionMaker.java b/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n--- a/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n+++ b/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n@@ -404,7 +404,6 @@ private BlockNode processSwitch(IRegion currentRegion, BlockNode block, SwitchNo\n \t\t}\n \n \t\tMap<BlockNode, List<Integer>> blocksMap = new LinkedHashMap<BlockNode, List<Integer>>(len);\n-\n \t\tfor (Entry<Integer, List<Integer>> entry : casesMap.entrySet()) {\n \t\t\tBlockNode c = BlockUtils.getBlockByOffset(entry.getKey(), block.getSuccessors());\n \t\t\tassert c != null;\n@@ -413,7 +412,7 @@ private BlockNode processSwitch(IRegion currentRegion, BlockNode block, SwitchNo\n \n \t\tBitSet succ = BlockUtils.blocksToBitSet(mth, block.getSuccessors());\n \t\tBitSet domsOn = BlockUtils.blocksToBitSet(mth, block.getDominatesOn());\n-\t\tdomsOn.andNot(succ); // filter 'out' block\n+\t\tdomsOn.and(succ); // filter 'out' block\n \n \t\tBlockNode defCase = BlockUtils.getBlockByOffset(insn.getDefaultCaseOffset(), block.getSuccessors());\n \t\tif (defCase != null) {\n@@ -458,7 +457,12 @@ private BlockNode processSwitch(IRegion currentRegion, BlockNode block, SwitchNo\n \t\t}\n \t\tfor (Entry<BlockNode, List<Integer>> entry : blocksMap.entrySet()) {\n \t\t\tBlockNode c = entry.getKey();\n-\t\t\tsw.addCase(entry.getValue(), makeRegion(c, stack));\n+\t\t\tif (stack.containsExit(c)) {\n+\t\t\t\t// empty case block\n+\t\t\t\tsw.addCase(entry.getValue(), new Region(stack.peekRegion()));\n+\t\t\t} else {\n+\t\t\t\tsw.addCase(entry.getValue(), makeRegion(c, stack));\n+\t\t\t}\n \t\t}\n \n \t\tstack.pop();\n\ndiff --git a/src/samples/java/jadx/samples/AbstractTest.java b/src/samples/java/jadx/samples/AbstractTest.java\n--- a/src/samples/java/jadx/samples/AbstractTest.java\n+++ b/src/samples/java/jadx/samples/AbstractTest.java\n@@ -15,4 +15,13 @@ public static void assertEquals(int a1, int a2) {\n \t\t\tthrow new AssertionError(a1 + \" != \" + a2);\n \t\t}\n \t}\n+\n+\tpublic static void assertEquals(Object a1, Object a2) {\n+\t\tif (a1 == null) {\n+\t\t\tif (a2 != null)\n+\t\t\t\tthrow new AssertionError(a1 + \" != \" + a2);\n+\t\t} else if (!a1.equals(a2)) {\n+\t\t\tthrow new AssertionError(a1 + \" != \" + a2);\n+\t\t}\n+\t}\n }\n\ndiff --git a/src/samples/java/jadx/samples/TestSwitch.java b/src/samples/java/jadx/samples/TestSwitch.java\n--- a/src/samples/java/jadx/samples/TestSwitch.java\n+++ b/src/samples/java/jadx/samples/TestSwitch.java\n@@ -78,13 +78,43 @@ public static final int test5(int i, int b) {\n \t\treturn -1;\n \t}\n \n+\tpublic String escape(String str) {\n+\t\tint len = str.length();\n+\t\tStringBuilder sb = new StringBuilder(len);\n+\t\tfor (int i = 0; i < len; i++) {\n+\t\t\tchar c = str.charAt(i);\n+\t\t\tswitch (c) {\n+\t\t\t\tcase '.':\n+\t\t\t\tcase '/':\n+\t\t\t\t\tsb.append('_');\n+\t\t\t\t\tbreak;\n+\n+\t\t\t\tcase ']':\n+\t\t\t\t\tsb.append('A');\n+\t\t\t\t\tbreak;\n+\n+\t\t\t\tcase '?':\n+\t\t\t\t\tbreak;\n+\n+\t\t\t\tdefault:\n+\t\t\t\t\tsb.append(c);\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\treturn sb.toString();\n+\t}\n+\n \t@Override\n \tpublic boolean testRun() {\n \t\tassertTrue(test1(25) == 2);\n \t\tassertTrue(test2(5) == 3);\n \t\tassertTrue(test3(1, 0) == 0);\n \t\tassertTrue(test4(2) == 1);\n+\t\tassertEquals(escape(\"a.b/c]d?e\"), \"a_b_cAde\");\n \t\treturn true;\n \t}\n \n+\tpublic static void main(String[] args) {\n+\t\tnew TestSwitch().testRun();\n+\t}\n }",
    "output": "Fix 'switch' codegen for empty case block"
  },
  {
    "input": "diff --git a/src/main/java/jadx/codegen/MethodGen.java b/src/main/java/jadx/codegen/MethodGen.java\n--- a/src/main/java/jadx/codegen/MethodGen.java\n+++ b/src/main/java/jadx/codegen/MethodGen.java\n@@ -263,7 +263,7 @@ private void makeFullMethodDump(CodeWriter code, MethodNode mth) {\n \t}\n \n \tprivate void makeFallbackMethod(CodeWriter code, MethodNode mth) {\n-\t\tif (!mth.getAccessFlags().isStatic()) {\n+\t\tif (mth.getThisArg() != null) {\n \t\t\tcode.startLine(getFallbackMethodGen(mth).makeArgName(mth.getThisArg())).add(\" = this;\");\n \t\t}\n \t\tmakeFallbackInsns(code, mth, mth.getInstructions(), true);\n\ndiff --git a/src/main/java/jadx/dex/instructions/args/ArgType.java b/src/main/java/jadx/dex/instructions/args/ArgType.java\n--- a/src/main/java/jadx/dex/instructions/args/ArgType.java\n+++ b/src/main/java/jadx/dex/instructions/args/ArgType.java\n@@ -5,6 +5,7 @@\n \n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -421,6 +422,9 @@ public static List<ArgType> parseSignatureList(String str) {\n \t}\n \n \tprivate static List<ArgType> parseSignatureListInner(String str, boolean parsePrimitives) {\n+\t\tif (str.isEmpty()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n \t\tif (str.equals(\"*\")) {\n \t\t\treturn Arrays.asList(UNKNOWN);\n \t\t}\n\ndiff --git a/src/main/java/jadx/dex/nodes/MethodNode.java b/src/main/java/jadx/dex/nodes/MethodNode.java\n--- a/src/main/java/jadx/dex/nodes/MethodNode.java\n+++ b/src/main/java/jadx/dex/nodes/MethodNode.java\n@@ -154,29 +154,32 @@ private boolean parseSignature() {\n \t\t\tLOG.warn(\"Signature parse error: {}\", returnType);\n \t\t\treturn false;\n \t\t}\n-\t\tif (mthInfo.getArgumentsTypes().isEmpty()) {\n-\t\t\targsList = Collections.emptyList();\n-\t\t\treturn true;\n-\t\t}\n \n \t\tList<ArgType> argsTypes = ArgType.parseSignatureList(argsTypesStr);\n \t\tif (argsTypes == null)\n \t\t\treturn false;\n \n \t\tif (argsTypes.size() != mthInfo.getArgumentsTypes().size()) {\n+\t\t\tif (argsTypes.isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n \t\t\tif (!mthInfo.isConstructor()) {\n \t\t\t\tLOG.warn(\"Wrong signature parse result: \" + sign + \" -> \" + argsTypes\n \t\t\t\t\t\t+ \", not generic version: \" + mthInfo.getArgumentsTypes());\n \t\t\t\treturn false;\n \t\t\t} else if (getParentClass().getAccessFlags().isEnum()) {\n \t\t\t\t// TODO:\n-\t\t\t\targsTypes.add(0, mthInfo.getArgumentsTypes().get(1));\n+\t\t\t\targsTypes.add(0, mthInfo.getArgumentsTypes().get(0));\n \t\t\t\targsTypes.add(1, mthInfo.getArgumentsTypes().get(1));\n \t\t\t} else {\n \t\t\t\t// add synthetic arg for outer class\n \t\t\t\targsTypes.add(0, mthInfo.getArgumentsTypes().get(0));\n \t\t\t}\n+\t\t\tif (argsTypes.size() != mthInfo.getArgumentsTypes().size()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n \t\t}\n+\n \t\tinitArguments(argsTypes);\n \t\treturn true;\n \t}\n\ndiff --git a/src/main/java/jadx/utils/Utils.java b/src/main/java/jadx/utils/Utils.java\n--- a/src/main/java/jadx/utils/Utils.java\n+++ b/src/main/java/jadx/utils/Utils.java\n@@ -49,6 +49,8 @@ public static String escape(String str) {\n \t\t\t\tcase '>':\n \t\t\t\tcase ',':\n \t\t\t\tcase ' ':\n+\t\t\t\tcase '?':\n+\t\t\t\tcase '*':\n \t\t\t\t\tbreak;\n \n \t\t\t\tdefault:\n\ndiff --git a/src/samples/java/jadx/samples/TestGenerics.java b/src/samples/java/jadx/samples/TestGenerics.java\n--- a/src/samples/java/jadx/samples/TestGenerics.java\n+++ b/src/samples/java/jadx/samples/TestGenerics.java\n@@ -1,6 +1,7 @@\n package jadx.samples;\n \n import java.util.ArrayList;\n+import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n@@ -141,6 +142,28 @@ public T getData() {\n \t\t}\n \t}\n \n+\tprivate class TestConstructor implements Enumeration<String> {\n+\t\tprivate final TestGenerics a;\n+\n+\t\tTestConstructor(TestGenerics a) {\n+\t\t\tthis.a = a;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean hasMoreElements() {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String nextElement() {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tpublic Enumeration<String> testThis() {\n+\t\treturn new TestConstructor(this);\n+\t}\n+\n \tprivate List<String> test1(Map<String, String> map) {\n \t\tList<String> list = new ArrayList<String>();\n \t\tString str = map.get(\"key\");",
    "output": "Fix bug for args in methods with generics"
  },
  {
    "input": "diff --git a/src/main/java/jadx/codegen/ClassGen.java b/src/main/java/jadx/codegen/ClassGen.java\n--- a/src/main/java/jadx/codegen/ClassGen.java\n+++ b/src/main/java/jadx/codegen/ClassGen.java\n@@ -135,9 +135,9 @@ public void makeClassDeclaration(CodeWriter clsCode) {\n \t\t}\n \t}\n \n-\tpublic void makeGenericMap(CodeWriter code, Map<ArgType, List<ArgType>> gmap) {\n+\tpublic boolean makeGenericMap(CodeWriter code, Map<ArgType, List<ArgType>> gmap) {\n \t\tif (gmap == null || gmap.isEmpty())\n-\t\t\treturn;\n+\t\t\treturn false;\n \n \t\tcode.add('<');\n \t\tint i = 0;\n@@ -161,6 +161,7 @@ public void makeGenericMap(CodeWriter code, Map<ArgType, List<ArgType>> gmap) {\n \t\t\ti++;\n \t\t}\n \t\tcode.add('>');\n+\t\treturn true;\n \t}\n \n \tpublic void makeClassBody(CodeWriter clsCode) throws CodegenException {\n\ndiff --git a/src/main/java/jadx/codegen/MethodGen.java b/src/main/java/jadx/codegen/MethodGen.java\n--- a/src/main/java/jadx/codegen/MethodGen.java\n+++ b/src/main/java/jadx/codegen/MethodGen.java\n@@ -78,8 +78,8 @@ public void addDefinition(CodeWriter code) {\n \t\t\t}\n \t\t\tcode.startLine(ai.makeString());\n \n-\t\t\tclassGen.makeGenericMap(code, mth.getGenericMap());\n-\t\t\tcode.add(' ');\n+\t\t\tif (classGen.makeGenericMap(code, mth.getGenericMap()))\n+\t\t\t\tcode.add(' ');\n \n \t\t\tif (mth.getAccessFlags().isConstructor()) {\n \t\t\t\tcode.add(classGen.getClassNode().getShortName()); // constructor",
    "output": "Remove redundant space"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/nodes/MethodNode.java b/src/main/java/jadx/dex/nodes/MethodNode.java\n--- a/src/main/java/jadx/dex/nodes/MethodNode.java\n+++ b/src/main/java/jadx/dex/nodes/MethodNode.java\n@@ -70,31 +70,22 @@ public MethodNode(ClassNode classNode, Method mth) {\n \t\tthis.parentClass = classNode;\n \t\tthis.accFlags = new AccessInfo(mth.getAccessFlags(), AFType.METHOD);\n \t\tthis.methodData = mth;\n-\n-\t\tif (methodData.getCodeOffset() == 0) {\n-\t\t\tnoCode = true;\n-\t\t\tregsCount = 0;\n-\t\t\tretType = mthInfo.getReturnType();\n-\t\t\tinitArguments(mthInfo.getArgumentsTypes());\n-\t\t} else {\n-\t\t\tnoCode = false;\n-\t\t}\n+\t\tthis.noCode = (methodData.getCodeOffset() == 0);\n \t}\n \n \t@Override\n \tpublic void load() throws DecodeException {\n-\t\tif (noCode)\n-\t\t\treturn;\n-\n \t\ttry {\n+\t\t\tif (noCode) {\n+\t\t\t\tregsCount = 0;\n+\t\t\t\tinitMethodTypes();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n \t\t\tDexNode dex = parentClass.dex();\n \t\t\tCode mthCode = dex.readCode(methodData);\n \t\t\tregsCount = mthCode.getRegistersSize();\n-\n-\t\t\tif (!parseSignature()) {\n-\t\t\t\tretType = mthInfo.getReturnType();\n-\t\t\t\tinitArguments(mthInfo.getArgumentsTypes());\n-\t\t\t}\n+\t\t\tinitMethodTypes();\n \n \t\t\tInsnDecoder decoder = new InsnDecoder(this, mthCode);\n \t\t\tInsnNode[] insnByOffset = decoder.run();\n@@ -117,6 +108,13 @@ public void load() throws DecodeException {\n \t\t}\n \t}\n \n+\tprivate void initMethodTypes() {\n+\t\tif (!parseSignature()) {\n+\t\t\tretType = mthInfo.getReturnType();\n+\t\t\tinitArguments(mthInfo.getArgumentsTypes());\n+\t\t}\n+\t}\n+\n \t@Override\n \tpublic void unload() {\n \t\tif (noCode)\n@@ -185,12 +183,12 @@ private boolean parseSignature() {\n \n \tprivate void initArguments(List<ArgType> args) {\n \t\tint pos;\n-\t\tif (!noCode) {\n+\t\tif (noCode) {\n+\t\t\tpos = 1;\n+\t\t} else {\n \t\t\tpos = regsCount;\n \t\t\tfor (ArgType arg : args)\n \t\t\t\tpos -= arg.getRegCount();\n-\t\t} else {\n-\t\t\tpos = 2 * args.size() + 1;\n \t\t}\n \n \t\tif (accFlags.isStatic()) {\n\ndiff --git a/src/samples/java/jadx/samples/TestGenerics.java b/src/samples/java/jadx/samples/TestGenerics.java\n--- a/src/samples/java/jadx/samples/TestGenerics.java\n+++ b/src/samples/java/jadx/samples/TestGenerics.java\n@@ -11,7 +11,11 @@ public class TestGenerics extends AbstractTest {\n \n \tpublic Class<?>[] classes;\n \n-\tpublic static class GenericClass implements Comparable<String> {\n+\tpublic interface MyComparable<T> {\n+\t\tpublic int compareTo(T o);\n+\t}\n+\n+\tpublic static class GenericClass implements MyComparable<String> {\n \t\t@Override\n \t\tpublic int compareTo(String o) {\n \t\t\treturn 0;",
    "output": "Fix generic types for abstract methods"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/info/ClassInfo.java b/src/main/java/jadx/dex/info/ClassInfo.java\n--- a/src/main/java/jadx/dex/info/ClassInfo.java\n+++ b/src/main/java/jadx/dex/info/ClassInfo.java\n@@ -53,7 +53,7 @@ private ClassInfo(DexNode dex, ArgType type) {\n \t\tthis.type = type;\n \n \t\tString fullObjectName = type.getObject();\n-\t\tassert fullObjectName.indexOf('/') == -1;\n+\t\tassert fullObjectName.indexOf('/') == -1 : \"Raw type: \" + type;\n \n \t\tboolean notObfuscated = dex.root().getJadxArgs().isNotObfuscated();\n \t\tString name;\n\ndiff --git a/src/main/java/jadx/dex/instructions/args/ArgType.java b/src/main/java/jadx/dex/instructions/args/ArgType.java\n--- a/src/main/java/jadx/dex/instructions/args/ArgType.java\n+++ b/src/main/java/jadx/dex/instructions/args/ArgType.java\n@@ -399,13 +399,16 @@ public static ArgType parseSignature(String sign) {\n \t\tif (b == -1)\n \t\t\treturn parse(sign);\n \n-\t\tString obj = sign.substring(0, b);\n+\t\tif (sign.charAt(0) == '[')\n+\t\t\treturn array(parseSignature(sign.substring(1)));\n+\n+\t\tString obj = sign.substring(0, b) + \";\";\n \t\tString genericsStr = sign.substring(b + 1, sign.length() - 2);\n \t\tList<ArgType> generics = parseSignatureList(genericsStr);\n \t\tif (generics != null)\n-\t\t\treturn generic(obj + \";\", generics.toArray(new ArgType[generics.size()]));\n+\t\t\treturn generic(obj, generics.toArray(new ArgType[generics.size()]));\n \t\telse\n-\t\t\treturn object(obj + \";\");\n+\t\t\treturn object(obj);\n \t}\n \n \tpublic static List<ArgType> parseSignatureList(String str) {\n@@ -418,12 +421,11 @@ public static List<ArgType> parseSignatureList(String str) {\n \t}\n \n \tprivate static List<ArgType> parseSignatureListInner(String str, boolean parsePrimitives) {\n-\t\tList<ArgType> signs = new ArrayList<ArgType>(3);\n \t\tif (str.equals(\"*\")) {\n-\t\t\tsigns.add(UNKNOWN);\n-\t\t\treturn signs;\n+\t\t\treturn Arrays.asList(UNKNOWN);\n \t\t}\n \n+\t\tList<ArgType> signs = new ArrayList<ArgType>(3);\n \t\tint obj = 0;\n \t\tint objStart = 0;\n \t\tint gen = 0;\n\ndiff --git a/src/samples/java/jadx/samples/TestGenerics.java b/src/samples/java/jadx/samples/TestGenerics.java\n--- a/src/samples/java/jadx/samples/TestGenerics.java\n+++ b/src/samples/java/jadx/samples/TestGenerics.java\n@@ -9,6 +9,8 @@ public class TestGenerics extends AbstractTest {\n \n \tpublic List<String> strings;\n \n+\tpublic Class<?>[] classes;\n+\n \tpublic static class GenericClass implements Comparable<String> {\n \t\t@Override\n \t\tpublic int compareTo(String o) {",
    "output": "Fix arrays parsing in signature"
  },
  {
    "input": "diff --git a/src/main/java/jadx/codegen/InsnGen.java b/src/main/java/jadx/codegen/InsnGen.java\n--- a/src/main/java/jadx/codegen/InsnGen.java\n+++ b/src/main/java/jadx/codegen/InsnGen.java\n@@ -80,7 +80,6 @@ public String arg(InsnArg arg) throws CodegenException {\n \t}\n \n \tpublic String assignVar(InsnNode insn) {\n-\t\t// return mgen.assignArg(arg);\n \t\ttry {\n \t\t\tRegisterArg arg = insn.getResult();\n \t\t\tif (insn.getAttributes().contains(AttributeType.DECLARE_VARIABLE)) {\n@@ -95,7 +94,11 @@ public String assignVar(InsnNode insn) {\n \t}\n \n \tpublic String declareVar(RegisterArg arg) throws CodegenException {\n-\t\treturn TypeGen.translate(mgen.getClassGen(), arg.getType()) + \" \" + arg(arg);\n+\t\tString type = TypeGen.translate(mgen.getClassGen(), arg.getType());\n+\t\tString generic = arg.getType().getGeneric();\n+\t\tif (generic != null)\n+\t\t\ttype += \" /* \" + generic + \" */\";\n+\t\treturn type + \" \" + arg(arg);\n \t}\n \n \tprivate String lit(LiteralArg arg) {\n\ndiff --git a/src/main/java/jadx/dex/info/LocalVarInfo.java b/src/main/java/jadx/dex/info/LocalVarInfo.java\n--- a/src/main/java/jadx/dex/info/LocalVarInfo.java\n+++ b/src/main/java/jadx/dex/info/LocalVarInfo.java\n@@ -9,6 +9,9 @@ public class LocalVarInfo extends RegisterArg {\n \n \tprivate boolean isEnd;\n \n+\tprivate int startAddr;\n+\tprivate int endAddr;\n+\n \tpublic LocalVarInfo(DexNode dex, int rn, int nameId, int typeId, int signId) {\n \t\tsuper(rn);\n \t\tString name = (nameId == DexNode.NO_INDEX ? null : dex.getString(nameId));\n@@ -24,20 +27,38 @@ public LocalVarInfo(DexNode dex, int rn, String name, ArgType type, String sign)\n \t}\n \n \tprivate void init(String name, ArgType type, String sign) {\n+\t\tif (sign != null) {\n+\t\t\ttype.setGeneric(sign);\n+\t\t}\n \t\tTypedVar tv = new TypedVar(type);\n \t\ttv.setName(name);\n \t\tsetTypedVar(tv);\n \t}\n \n \tpublic void start(int addr, int line) {\n \t\tthis.isEnd = false;\n+\t\tthis.startAddr = addr;\n \t}\n \n \tpublic void end(int addr, int line) {\n \t\tthis.isEnd = true;\n+\t\tthis.endAddr = addr;\n \t}\n \n \tpublic boolean isEnd() {\n \t\treturn isEnd;\n \t}\n+\n+\tpublic int getStartAddr() {\n+\t\treturn startAddr;\n+\t}\n+\n+\tpublic int getEndAddr() {\n+\t\treturn endAddr;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn super.toString() + \" \" + (isEnd ? \"end\" : \"active\");\n+\t}\n }\n\ndiff --git a/src/main/java/jadx/dex/instructions/args/ArgType.java b/src/main/java/jadx/dex/instructions/args/ArgType.java\n--- a/src/main/java/jadx/dex/instructions/args/ArgType.java\n+++ b/src/main/java/jadx/dex/instructions/args/ArgType.java\n@@ -42,6 +42,8 @@ public final class ArgType {\n \n \tprivate final int hash;\n \n+\tprivate String generic; // TODO extract generic info from signature\n+\n \tprivate ArgType(PrimitiveType type, String object, ArgType arrayElement) {\n \t\tthis.type = type;\n \t\tthis.object = (object == null ? null : Utils.cleanObjectName(object));\n@@ -96,6 +98,14 @@ public boolean isObject() {\n \t\treturn type == PrimitiveType.OBJECT;\n \t}\n \n+\tpublic String getGeneric() {\n+\t\treturn generic;\n+\t}\n+\n+\tpublic void setGeneric(String generic) {\n+\t\tthis.generic = generic;\n+\t}\n+\n \tpublic ArgType getArrayElement() {\n \t\treturn arrayElement;\n \t}\n\ndiff --git a/src/main/java/jadx/dex/nodes/MethodNode.java b/src/main/java/jadx/dex/nodes/MethodNode.java\n--- a/src/main/java/jadx/dex/nodes/MethodNode.java\n+++ b/src/main/java/jadx/dex/nodes/MethodNode.java\n@@ -95,7 +95,7 @@ public void load() throws DecodeException {\n \t\t\tinitJumps(insnByOffset);\n \n \t\t\tif (mthCode.getDebugInfoOffset() > 0) {\n-\t\t\t\tDebugInfoParser debugInfo = new DebugInfoParser(this, dex.openSection(mthCode.getDebugInfoOffset()));\n+\t\t\t\tDebugInfoParser debugInfo = new DebugInfoParser(this, mthCode.getDebugInfoOffset());\n \t\t\t\tdebugInfo.process(insnByOffset);\n \t\t\t}\n \t\t} catch (Exception e) {\n\ndiff --git a/src/main/java/jadx/dex/nodes/parser/DebugInfoParser.java b/src/main/java/jadx/dex/nodes/parser/DebugInfoParser.java\n--- a/src/main/java/jadx/dex/nodes/parser/DebugInfoParser.java\n+++ b/src/main/java/jadx/dex/nodes/parser/DebugInfoParser.java\n@@ -33,10 +33,10 @@ public class DebugInfoParser {\n \tprivate final Section section;\n \tprivate final DexNode dex;\n \n-\tpublic DebugInfoParser(MethodNode mth, Section section) {\n+\tpublic DebugInfoParser(MethodNode mth, int debugOffset) {\n \t\tthis.mth = mth;\n-\t\tthis.section = section;\n \t\tthis.dex = mth.dex();\n+\t\tthis.section = dex.openSection(debugOffset);\n \t}\n \n \tpublic void process(InsnNode[] insnByOffset) throws DecodeException {\n@@ -77,29 +77,35 @@ public void process(InsnNode[] insnByOffset) throws DecodeException {\n \t\t\t\t\tint regNum = section.readUleb128();\n \t\t\t\t\tint nameId = section.readUleb128() - 1;\n \t\t\t\t\tint type = section.readUleb128() - 1;\n-\t\t\t\t\tlocals[regNum] = new LocalVarInfo(dex, regNum, nameId, type, DexNode.NO_INDEX);\n-\t\t\t\t\tlocals[regNum].start(addr, line);\n+\t\t\t\t\tLocalVarInfo var = new LocalVarInfo(dex, regNum, nameId, type, DexNode.NO_INDEX);\n+\t\t\t\t\tvar.start(addr, line);\n+\t\t\t\t\tlocals[regNum] = var;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tcase DBG_START_LOCAL_EXTENDED: {\n \t\t\t\t\tint regNum = section.readUleb128();\n \t\t\t\t\tint nameId = section.readUleb128() - 1;\n \t\t\t\t\tint type = section.readUleb128() - 1;\n \t\t\t\t\tint sign = section.readUleb128() - 1;\n-\t\t\t\t\tlocals[regNum] = new LocalVarInfo(dex, regNum, nameId, type, sign);\n-\t\t\t\t\tlocals[regNum].start(addr, line);\n+\t\t\t\t\tLocalVarInfo var = new LocalVarInfo(dex, regNum, nameId, type, sign);\n+\t\t\t\t\tvar.start(addr, line);\n+\t\t\t\t\tlocals[regNum] = var;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tcase DBG_RESTART_LOCAL: {\n \t\t\t\t\tint regNum = section.readUleb128();\n-\t\t\t\t\tif (locals[regNum] != null)\n-\t\t\t\t\t\tlocals[regNum].start(addr, line);\n+\t\t\t\t\tLocalVarInfo var = locals[regNum];\n+\t\t\t\t\tif (var != null)\n+\t\t\t\t\t\tvar.start(addr, line);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tcase DBG_END_LOCAL: {\n \t\t\t\t\tint regNum = section.readUleb128();\n-\t\t\t\t\tif (locals[regNum] != null)\n-\t\t\t\t\t\tlocals[regNum].end(addr, line);\n+\t\t\t\t\tLocalVarInfo var = locals[regNum];\n+\t\t\t\t\tif (var != null) {\n+\t\t\t\t\t\tvar.end(addr, line);\n+\t\t\t\t\t\tsetVar(var, insnByOffset);\n+\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \n@@ -115,12 +121,9 @@ public void process(InsnNode[] insnByOffset) throws DecodeException {\n \n \t\t\t\tdefault:\n \t\t\t\t\tif (c >= DBG_FIRST_SPECIAL) {\n-\n \t\t\t\t\t\tint adjusted_opcode = c - DBG_FIRST_SPECIAL;\n \t\t\t\t\t\tline += DBG_LINE_BASE + (adjusted_opcode % DBG_LINE_RANGE);\n \t\t\t\t\t\taddr += (adjusted_opcode / DBG_LINE_RANGE);\n-\n-\t\t\t\t\t\tfillLocals(insnByOffset[addr], locals);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tthrow new DecodeException(\"Unknown debug insn code: \" + c);\n \t\t\t\t\t}\n@@ -129,29 +132,41 @@ public void process(InsnNode[] insnByOffset) throws DecodeException {\n \n \t\t\tc = section.readByte() & 0xFF;\n \t\t}\n+\n+\t\tfor (LocalVarInfo var : locals) {\n+\t\t\tif (var != null && !var.isEnd()) {\n+\t\t\t\tvar.end(addr, line);\n+\t\t\t\tsetVar(var, insnByOffset);\n+\t\t\t}\n+\t\t}\n \t}\n \n-\tprivate void fillLocals(InsnNode insn, LocalVarInfo[] locals) {\n+\tprivate void setVar(LocalVarInfo var, InsnNode[] insnByOffset) {\n+\t\tint start = var.getStartAddr();\n+\t\tint end = var.getEndAddr();\n+\n+\t\tfor (int i = start; i <= end; i++) {\n+\t\t\tInsnNode insn = insnByOffset[i];\n+\t\t\tfillLocals(insn, var);\n+\t\t}\n+\t}\n+\n+\tprivate void fillLocals(InsnNode insn, LocalVarInfo var) {\n \t\tif (insn == null)\n \t\t\treturn;\n \n \t\tif (insn.getResult() != null)\n-\t\t\tmerge(insn.getResult(), locals);\n+\t\t\tmerge(insn.getResult(), var);\n \n \t\tfor (InsnArg arg : insn.getArguments())\n-\t\t\tmerge(arg, locals);\n+\t\t\tmerge(arg, var);\n \t}\n \n-\tprivate void merge(InsnArg arg, LocalVarInfo[] locals) {\n+\tprivate void merge(InsnArg arg, LocalVarInfo var) {\n \t\tif (arg.isRegister()) {\n \t\t\tint rn = ((RegisterArg) arg).getRegNum();\n-\n-\t\t\tfor (LocalVarInfo var : locals) {\n-\t\t\t\tif (var != null && !var.isEnd()) {\n-\t\t\t\t\tif (var.getRegNum() == rn)\n-\t\t\t\t\t\targ.replace(var);\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tif (var.getRegNum() == rn)\n+\t\t\t\targ.setTypedVar(var.getTypedVar());\n \t\t}\n \t}\n }",
    "output": "Fix debug info parsing, save generics types for variables"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/visitors/regions/ProcessVariables.java b/src/main/java/jadx/dex/visitors/regions/ProcessVariables.java\n--- a/src/main/java/jadx/dex/visitors/regions/ProcessVariables.java\n+++ b/src/main/java/jadx/dex/visitors/regions/ProcessVariables.java\n@@ -29,6 +29,7 @@ public class ProcessVariables extends AbstractVisitor {\n \n \tprivate static class Usage {\n \t\tprivate RegisterArg arg;\n+\t\tprivate IRegion argRegion;\n \t\tprivate final Set<IRegion> usage = new HashSet<IRegion>(2);\n \t\tprivate final Set<IRegion> assigns = new HashSet<IRegion>(2);\n \n@@ -40,6 +41,14 @@ public RegisterArg getArg() {\n \t\t\treturn arg;\n \t\t}\n \n+\t\tpublic void setArgRegion(IRegion argRegion) {\n+\t\t\tthis.argRegion = argRegion;\n+\t\t}\n+\n+\t\tpublic IRegion getArgRegion() {\n+\t\t\treturn argRegion;\n+\t\t}\n+\n \t\tpublic Set<IRegion> getAssigns() {\n \t\t\treturn assigns;\n \t\t}\n@@ -72,11 +81,12 @@ public void processBlockTraced(MethodNode mth, IBlock container, IRegion curRegi\n \t\t\t\t\t\tUsage u = usageMap.get(result);\n \t\t\t\t\t\tif (u == null) {\n \t\t\t\t\t\t\tu = new Usage();\n-\t\t\t\t\t\t\tu.setArg(result);\n \t\t\t\t\t\t\tusageMap.put(result, u);\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tif (u.getArg() == null)\n+\t\t\t\t\t\tif (u.getArg() == null) {\n \t\t\t\t\t\t\tu.setArg(result);\n+\t\t\t\t\t\t\tu.setArgRegion(curRegion);\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tu.getAssigns().add(curRegion);\n \t\t\t\t\t}\n \t\t\t\t\t// args\n@@ -95,28 +105,23 @@ public void processBlockTraced(MethodNode mth, IBlock container, IRegion curRegi\n \t\t};\n \t\tDepthRegionTraverser.traverseAll(mth, collect);\n \n-\t\tList<RegisterArg> mthArgs = mth.getArguments(true);\n \t\t// reduce assigns map\n+\t\tList<RegisterArg> mthArgs = mth.getArguments(true);\n \t\tfor (Iterator<Entry<RegisterArg, Usage>> it = usageMap.entrySet().iterator(); it.hasNext();) {\n \t\t\tEntry<RegisterArg, Usage> entry = it.next();\n \t\t\tUsage u = entry.getValue();\n \t\t\tRegisterArg r = u.getArg();\n \n-\t\t\tif (u.getAssigns().isEmpty()) {\n+\t\t\t// if no assigns or method argument => remove\n+\t\t\tif (u.getAssigns().isEmpty() || mthArgs.indexOf(r) != -1) {\n \t\t\t\tit.remove();\n \t\t\t\tcontinue;\n \t\t\t}\n \n-\t\t\tint i;\n-\t\t\tif ((i = mthArgs.indexOf(r)) != -1) {\n-\t\t\t\t// if (mthArgs.get(i).getTypedVar() == r.getTypedVar()) {\n-\t\t\t\tit.remove();\n-\t\t\t\tcontinue;\n-\t\t\t\t// }\n-\t\t\t}\n \t\t\t// check if we can declare variable at current assigns\n \t\t\tfor (IRegion assignRegion : u.getAssigns()) {\n-\t\t\t\tif (canDeclareInRegion(u, assignRegion)) {\n+\t\t\t\tif (u.getArgRegion() == assignRegion\n+\t\t\t\t\t\t&& canDeclareInRegion(u, assignRegion)) {\n \t\t\t\t\tr.getParentInsn().getAttributes().add(new DeclareVariableAttr());\n \t\t\t\t\tit.remove();\n \t\t\t\t\tbreak;\n@@ -130,8 +135,8 @@ public void processBlockTraced(MethodNode mth, IBlock container, IRegion curRegi\n \t\t\t// find common region which contains all usage regions\n \n \t\t\tSet<IRegion> set = u.getUseRegions();\n-\t\t\tfor (Iterator it = set.iterator(); it.hasNext();) {\n-\t\t\t\tIRegion r = (IRegion) it.next();\n+\t\t\tfor (Iterator<IRegion> it = set.iterator(); it.hasNext();) {\n+\t\t\t\tIRegion r = it.next();\n \t\t\t\tIRegion parent = r.getParent();\n \t\t\t\tif (parent != null && set.contains(parent))\n \t\t\t\t\tit.remove();\n@@ -159,8 +164,8 @@ public void processBlockTraced(MethodNode mth, IBlock container, IRegion curRegi\n \t}\n \n \tprivate void declareVar(IContainer region, RegisterArg arg) {\n-\t\tDeclareVariableAttr dv = (DeclareVariableAttr) region.getAttributes().get(\n-\t\t\t\tAttributeType.DECLARE_VARIABLE);\n+\t\tDeclareVariableAttr dv =\n+\t\t\t\t(DeclareVariableAttr) region.getAttributes().get(AttributeType.DECLARE_VARIABLE);\n \t\tif (dv == null) {\n \t\t\tdv = new DeclareVariableAttr(new ArrayList<RegisterArg>());\n \t\t\tregion.getAttributes().add(dv);\n\ndiff --git a/src/samples/java/jadx/samples/TestCF.java b/src/samples/java/jadx/samples/TestCF.java\n--- a/src/samples/java/jadx/samples/TestCF.java\n+++ b/src/samples/java/jadx/samples/TestCF.java\n@@ -149,6 +149,18 @@ else if (str.equals(\"$\"))\n \t\treturn Math.abs(r);\n \t}\n \n+\tpublic int testIfElse2(String str) {\n+\t\tString a;\n+\t\tif (str.length() == 5) {\n+\t\t\ta = new String(\"1\");\n+\t\t\ta.trim();\n+\t\t\ta.length();\n+\t\t}\n+\t\ta = new String(\"22\");\n+\t\ta.toLowerCase();\n+\t\treturn a.length();\n+\t}\n+\n \tpublic void testInfiniteLoop() {\n \t\twhile (true) {\n \t\t\tSystem.out.println(\"test\");\n@@ -194,6 +206,8 @@ public boolean testRun() throws Exception {\n \n \t\tassertEquals(c.testIfElse(\"b\"), 20);\n \t\tassertEquals(c.testIfElse(\"c\"), 10);\n+\n+\t\tassertEquals(c.testIfElse2(\"12345\"), 2);\n \t\treturn true;\n \t}",
    "output": "Fix variable declaration for multiple assigns"
  },
  {
    "input": "diff --git a/src/main/java/jadx/Main.java b/src/main/java/jadx/Main.java\n--- a/src/main/java/jadx/Main.java\n+++ b/src/main/java/jadx/Main.java\n@@ -98,8 +98,6 @@ private static List<IDexTreeVisitor> getPassesList(JadxArgs args) {\n \t\t\tif (args.isRawCFGOutput())\n \t\t\t\tpasses.add(new DotGraphVisitor(args.getOutDir(), false, true));\n \n-\t\t\tpasses.add(new ClassModifier());\n-\n \t\t\tpasses.add(new ModVisitor());\n \t\t\tpasses.add(new EnumVisitor());\n \n@@ -115,6 +113,7 @@ private static List<IDexTreeVisitor> getPassesList(JadxArgs args) {\n \t\t\tif (args.isCFGOutput())\n \t\t\t\tpasses.add(new DotGraphVisitor(args.getOutDir(), true));\n \n+\t\t\tpasses.add(new ClassModifier());\n \t\t\tpasses.add(new CleanRegions());\n \t\t}\n \t\tpasses.add(new CodeGen(args));\n\ndiff --git a/src/main/java/jadx/dex/info/AccessInfo.java b/src/main/java/jadx/dex/info/AccessInfo.java\n--- a/src/main/java/jadx/dex/info/AccessInfo.java\n+++ b/src/main/java/jadx/dex/info/AccessInfo.java\n@@ -37,6 +37,18 @@ public AccessInfo getVisibility() {\n \t\treturn new AccessInfo(f, type);\n \t}\n \n+\tpublic boolean isPublic() {\n+\t\treturn (accFlags & AccessFlags.ACC_PUBLIC) != 0;\n+\t}\n+\n+\tpublic boolean isProtected() {\n+\t\treturn (accFlags & AccessFlags.ACC_PROTECTED) != 0;\n+\t}\n+\n+\tpublic boolean isPrivate() {\n+\t\treturn (accFlags & AccessFlags.ACC_PRIVATE) != 0;\n+\t}\n+\n \tpublic boolean isAbstract() {\n \t\treturn (accFlags & AccessFlags.ACC_ABSTRACT) != 0;\n \t}\n@@ -87,13 +99,13 @@ public int getFlags() {\n \n \tpublic String makeString() {\n \t\tStringBuilder code = new StringBuilder();\n-\t\tif ((accFlags & AccessFlags.ACC_PUBLIC) != 0)\n+\t\tif (isPublic())\n \t\t\tcode.append(\"public \");\n \n-\t\tif ((accFlags & AccessFlags.ACC_PRIVATE) != 0)\n+\t\tif (isPrivate())\n \t\t\tcode.append(\"private \");\n \n-\t\tif ((accFlags & AccessFlags.ACC_PROTECTED) != 0)\n+\t\tif (isProtected())\n \t\t\tcode.append(\"protected \");\n \n \t\tif (isStatic())\n\ndiff --git a/src/main/java/jadx/dex/info/ClassInfo.java b/src/main/java/jadx/dex/info/ClassInfo.java\n--- a/src/main/java/jadx/dex/info/ClassInfo.java\n+++ b/src/main/java/jadx/dex/info/ClassInfo.java\n@@ -5,12 +5,12 @@\n import jadx.dex.nodes.DexNode;\n \n import java.io.File;\n-import java.util.HashMap;\n import java.util.Map;\n+import java.util.WeakHashMap;\n \n public final class ClassInfo {\n \n-\tprivate static final Map<ArgType, ClassInfo> CLASSINFO_CACHE = new HashMap<ArgType, ClassInfo>();\n+\tprivate static final Map<ArgType, ClassInfo> CLASSINFO_CACHE = new WeakHashMap<ArgType, ClassInfo>();\n \tprivate static final String DEFAULT_PACKAGE_NAME = \"defpackage\";\n \n \tprivate final String clsName;\n\ndiff --git a/src/main/java/jadx/dex/visitors/ClassModifier.java b/src/main/java/jadx/dex/visitors/ClassModifier.java\n--- a/src/main/java/jadx/dex/visitors/ClassModifier.java\n+++ b/src/main/java/jadx/dex/visitors/ClassModifier.java\n@@ -1,11 +1,13 @@\n package jadx.dex.visitors;\n \n import jadx.dex.info.AccessInfo;\n+import jadx.dex.nodes.BlockNode;\n import jadx.dex.nodes.ClassNode;\n import jadx.dex.nodes.MethodNode;\n import jadx.utils.exceptions.JadxException;\n \n import java.util.Iterator;\n+import java.util.List;\n \n public class ClassModifier extends AbstractVisitor {\n \n@@ -21,10 +23,32 @@ public boolean visit(ClassNode cls) throws JadxException {\n \n \t\t\t// remove bridge methods\n \t\t\tif (af.isBridge() && af.isSynthetic()) {\n-\t\t\t\t// TODO make some checks before deleting\n-\t\t\t\tit.remove();\n+\t\t\t\tif (!isMethodIdUniq(cls, mth)) {\n+\t\t\t\t\t// TODO add more checks before method deletion\n+\t\t\t\t\tit.remove();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// remove public empty constructors\n+\t\t\tif (af.isConstructor()\n+\t\t\t\t\t&& af.isPublic()\n+\t\t\t\t\t&& mth.getArguments(false).isEmpty()) {\n+\t\t\t\tList<BlockNode> bb = mth.getBasicBlocks();\n+\t\t\t\tif (bb.isEmpty() || (bb.size() == 1 && bb.get(0).getInstructions().isEmpty())) {\n+\t\t\t\t\tit.remove();\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn false;\n \t}\n+\n+\tprivate boolean isMethodIdUniq(ClassNode cls, MethodNode mth) {\n+\t\tString shortId = mth.getMethodInfo().getShortId();\n+\t\tfor (MethodNode otherMth : cls.getMethods()) {\n+\t\t\tif (otherMth.getMethodInfo().getShortId().equals(shortId)\n+\t\t\t\t\t&& otherMth != mth)\n+\t\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n }",
    "output": "Remove empty public constructors"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/visitors/regions/MarkTryCatchRegions.java b/src/main/java/jadx/dex/visitors/regions/MarkTryCatchRegions.java\n--- a/src/main/java/jadx/dex/visitors/regions/MarkTryCatchRegions.java\n+++ b/src/main/java/jadx/dex/visitors/regions/MarkTryCatchRegions.java\n@@ -92,6 +92,9 @@ public void leaveRegion(MethodNode mth, IRegion region) {\n \t\tif (tryBlocksMap.isEmpty())\n \t\t\treturn;\n \n+\t\tif (!(region instanceof Region))\n+\t\t\treturn;\n+\n \t\t// search dominator blocks in this region (don't need to go deeper)\n \t\tfor (BlockNode dominator : tryBlocksMap.keySet()) {\n \t\t\tif (region.getSubBlocks().contains(dominator)) {\n\ndiff --git a/src/main/java/jadx/dex/visitors/regions/RegionMaker.java b/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n--- a/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n+++ b/src/main/java/jadx/dex/visitors/regions/RegionMaker.java\n@@ -147,21 +147,31 @@ private BlockNode processLoop(IRegion curRegion, LoopAttr loop, RegionStack stac\n \n \t\t\tInsnNode insn = exit.getInstructions().get(0);\n \t\t\tif (insn.getType() == InsnType.IF) {\n+\t\t\t\tboolean found = true;\n \t\t\t\tifnode = (IfNode) insn;\n \t\t\t\tcondBlock = exit;\n \t\t\t\tloopRegion = new LoopRegion(curRegion, condBlock, condBlock == loop.getEnd());\n-\t\t\t\tif (!loopRegion.isConditionAtEnd() && condBlock != loop.getStart()\n-\t\t\t\t\t\t&& condBlock.getPredecessors().contains(loopStart)) {\n-\t\t\t\t\tloopRegion.setPreCondition(loopStart);\n-\t\t\t\t\t// if we can't merge pre-condition this is not correct header\n-\t\t\t\t\tif (!loopRegion.checkPreCondition()) {\n-\t\t\t\t\t\tifnode = null;\n-\t\t\t\t\t\tloopRegion = null;\n-\t\t\t\t\t\t// try another exit\n-\t\t\t\t\t\tcontinue;\n+\n+\t\t\t\tif (loopRegion.isConditionAtEnd()) {\n+\t\t\t\t\t// TODO: add some checks\n+\t\t\t\t} else {\n+\t\t\t\t\tif (condBlock != loop.getStart()) {\n+\t\t\t\t\t\tif (condBlock.getPredecessors().contains(loopStart)) {\n+\t\t\t\t\t\t\tloopRegion.setPreCondition(loopStart);\n+\t\t\t\t\t\t\t// if we can't merge pre-condition this is not correct header\n+\t\t\t\t\t\t\tfound = loopRegion.checkPreCondition();\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tfound = false;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tbreak;\n+\t\t\t\tif (!found) {\n+\t\t\t\t\tifnode = null;\n+\t\t\t\t\tloopRegion = null;\n+\t\t\t\t\tcondBlock = null;\n+\t\t\t\t\t// try another exit\n+\t\t\t\t} else\n+\t\t\t\t\tbreak;\n \t\t\t}\n \t\t}",
    "output": "Improve loops parsing"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/visitors/regions/ProcessVariables.java b/src/main/java/jadx/dex/visitors/regions/ProcessVariables.java\n--- a/src/main/java/jadx/dex/visitors/regions/ProcessVariables.java\n+++ b/src/main/java/jadx/dex/visitors/regions/ProcessVariables.java\n@@ -114,12 +114,6 @@ public void processBlockTraced(MethodNode mth, IBlock container, IRegion curRegi\n \t\t\t\tcontinue;\n \t\t\t\t// }\n \t\t\t}\n-\t\t\t// suppose variables always initialized\n-\t\t\tif (u.getAssigns().size() == 1 && u.getUseRegions().size() <= 1) {\n-\t\t\t\tr.getParentInsn().getAttributes().add(new DeclareVariableAttr());\n-\t\t\t\tit.remove();\n-\t\t\t\tcontinue;\n-\t\t\t}\n \t\t\t// check if we can declare variable at current assigns\n \t\t\tfor (IRegion assignRegion : u.getAssigns()) {\n \t\t\t\tif (canDeclareInRegion(u, assignRegion)) {\n\ndiff --git a/src/samples/java/jadx/samples/TestTryCatch.java b/src/samples/java/jadx/samples/TestTryCatch.java\n--- a/src/samples/java/jadx/samples/TestTryCatch.java\n+++ b/src/samples/java/jadx/samples/TestTryCatch.java\n@@ -131,6 +131,17 @@ private synchronized static boolean testSynchronize2(Object obj) throws Interrup\n \t\treturn obj.toString() != null;\n \t}\n \n+\tpublic Object mObject = new Object();\n+\tpublic boolean mDiscovering = true;\n+\n+\tprivate boolean testSynchronize3() {\n+\t\tboolean b = false;\n+\t\tsynchronized (mObject) {\n+\t\t\tb = this.mDiscovering;\n+\t\t}\n+\t\treturn b;\n+\t}\n+\n \t@Override\n \tpublic boolean testRun() throws Exception {\n \t\tObject obj = new Object();\n@@ -147,6 +158,7 @@ public boolean testRun() throws Exception {\n \t\tassertTrue(testSynchronize(\"str\") == false);\n \n \t\tassertTrue(testSynchronize2(\"str\"));\n+\t\tassertTrue(testSynchronize3());\n \t\treturn true;\n \t}",
    "output": "Fix incorrect variable declaration"
  },
  {
    "input": "diff --git a/src/main/java/jadx/utils/BlockUtils.java b/src/main/java/jadx/utils/BlockUtils.java\n--- a/src/main/java/jadx/utils/BlockUtils.java\n+++ b/src/main/java/jadx/utils/BlockUtils.java\n@@ -70,7 +70,7 @@ public static BlockNode canMergeNextBlock(MethodNode mth, BlockNode block) {\n \t}\n \n \t/**\n-\t * Check if insn contains in block (use == for comparison, not equals)\n+\t * Check if instruction contains in block (use == for comparison, not equals)\n \t */\n \tpublic static boolean blockContains(BlockNode block, InsnNode insn) {\n \t\tfor (InsnNode bi : block.getInstructions()) {\n@@ -81,7 +81,7 @@ public static boolean blockContains(BlockNode block, InsnNode insn) {\n \t}\n \n \t/**\n-\t * Return position of instruction in block (use == for comparison, not equals)\n+\t * Return instruction position in block (use == for comparison, not equals)\n \t */\n \tpublic static int insnIndex(BlockNode block, InsnNode insn) {\n \t\tint size = block.getInstructions().size();\n@@ -128,7 +128,7 @@ public static List<BlockNode> bitsetToBlocks(MethodNode mth, BitSet bs) {\n \t}\n \n \t/**\n-\t * Return first successor which not exception handler or followed by loop back edge\n+\t * Return first successor which not exception handler and not follow loop back edge\n \t */\n \tpublic static BlockNode getNextBlock(BlockNode block) {\n \t\tList<BlockNode> s = block.getCleanSuccessors();\n@@ -155,13 +155,20 @@ private static void addPredcessors(Set<BlockNode> set, BlockNode from, BlockNode\n \t\t}\n \t}\n \n-\tprivate static boolean addSuccessorsUntil(BlockNode from, BlockNode until) {\n-\t\tif (from == until)\n-\t\t\treturn true;\n-\n+\tprivate static boolean traverseSuccessorsUntil(BlockNode from, BlockNode until, Set<BlockNode> checked) {\n \t\tfor (BlockNode s : from.getCleanSuccessors()) {\n-\t\t\tif (addSuccessorsUntil(s, until))\n+\t\t\tif (s == until)\n \t\t\t\treturn true;\n+\n+\t\t\tif (!checked.contains(s)) {\n+\t\t\t\tchecked.add(s);\n+\n+\t\t\t\tif (until.isDominator(s))\n+\t\t\t\t\treturn true;\n+\n+\t\t\t\tif (traverseSuccessorsUntil(s, until, checked))\n+\t\t\t\t\treturn true;\n+\t\t\t}\n \t\t}\n \t\treturn false;\n \t}\n@@ -173,8 +180,7 @@ public static boolean isPathExists(BlockNode start, BlockNode end) {\n \t\tif (end.isDominator(start))\n \t\t\treturn true;\n \n-\t\treturn addSuccessorsUntil(start, end);\n-\t\t// return addPredcessorsUntil(new HashSet<BlockNode>(), end, start);\n+\t\treturn traverseSuccessorsUntil(start, end, new HashSet<BlockNode>());\n \t}\n \n \t/**",
    "output": "Fix endless loop in path existence check"
  },
  {
    "input": "diff --git a/src/main/java/jadx/dex/info/ClassInfo.java b/src/main/java/jadx/dex/info/ClassInfo.java\n--- a/src/main/java/jadx/dex/info/ClassInfo.java\n+++ b/src/main/java/jadx/dex/info/ClassInfo.java\n@@ -52,37 +52,30 @@ private ClassInfo(DexNode dex, ArgType type) {\n \t\tthis.type = type;\n \n \t\tString fullObjectName = type.getObject();\n+\t\tassert fullObjectName.indexOf('/') == -1;\n+\n+\t\tboolean notObfuscated = dex.root().getJadxArgs().isNotObfuscated();\n \t\tString name;\n \t\tString pkg;\n \n-\t\tassert fullObjectName.indexOf('/') == -1;\n-\n \t\tint dot = fullObjectName.lastIndexOf('.');\n \t\tif (dot == -1) {\n \t\t\t// rename default package if it used from class with package (often for obfuscated apps),\n-\t\t\t// TODO? if default package really needed\n-\t\t\tpkg = DEFAULT_PACKAGE_NAME;\n+\t\t\tpkg = (notObfuscated ? \"\" : DEFAULT_PACKAGE_NAME);\n \t\t\tname = fullObjectName;\n \t\t} else {\n \t\t\tpkg = fullObjectName.substring(0, dot);\n \t\t\tname = fullObjectName.substring(dot + 1);\n \t\t}\n \n \t\tint sep = name.lastIndexOf('$');\n-\t\tif (sep > 0) {\n+\t\tif (sep > 0 && sep != name.length() - 1) {\n \t\t\tString parClsName = pkg + '.' + name.substring(0, sep);\n-\t\t\tif (dex.root().getJadxArgs().isNotObfuscated()\n-\t\t\t\t\t|| dex.root().isClassExists(parClsName)) {\n+\t\t\tif (notObfuscated || dex.root().isClassExists(parClsName)) {\n \t\t\t\tparentClass = fromName(dex, parClsName);\n \t\t\t\tname = name.substring(sep + 1);\n \t\t\t} else {\n-\t\t\t\t// TODO for more accuracy we need full classpath class listing\n-\t\t\t\t// for now instead make more checks\n-\t\t\t\tif (sep != name.length() - 1) {\n-\t\t\t\t\tparentClass = fromName(dex, parClsName);\n-\t\t\t\t\tname = name.substring(sep + 1);\n-\t\t\t\t} else\n-\t\t\t\t\tparentClass = null;\n+\t\t\t\tparentClass = null;\n \t\t\t}\n \t\t} else {\n \t\t\tparentClass = null;\n@@ -91,15 +84,10 @@ private ClassInfo(DexNode dex, ArgType type) {\n \t\tif (Character.isDigit(name.charAt(0)))\n \t\t\tname = \"InnerClass_\" + name;\n \n-\t\t// TODO rename classes with reserved names\n \t\tif (NameMapper.isReserved(name))\n \t\t\tname += \"_\";\n \n-\t\tif (parentClass != null)\n-\t\t\tfullName = parentClass.getFullName() + '.' + name;\n-\t\telse\n-\t\t\tfullName = pkg + '.' + name;\n-\n+\t\tthis.fullName = (parentClass != null ? parentClass.getFullName() : pkg) + \".\" + name;\n \t\tthis.clsName = name;\n \t\tthis.clsPackage = pkg;\n \t}\n@@ -122,7 +110,7 @@ public String getPackage() {\n \t}\n \n \tpublic boolean isPackageDefault() {\n-\t\treturn clsPackage.equals(DEFAULT_PACKAGE_NAME);\n+\t\treturn clsPackage.isEmpty() || clsPackage.equals(DEFAULT_PACKAGE_NAME);\n \t}\n \n \tpublic String getNameWithoutPackage() {\n@@ -155,8 +143,8 @@ public int hashCode() {\n \tpublic boolean equals(Object obj) {\n \t\tif (this == obj) return true;\n \t\tif (obj instanceof ClassInfo) {\n-\t\t\tClassInfo cls = (ClassInfo) obj;\n-\t\t\treturn this.getFullName().equals(cls.getFullName());\n+\t\t\tClassInfo other = (ClassInfo) obj;\n+\t\t\treturn this.getFullName().equals(other.getFullName());\n \t\t}\n \t\treturn false;\n \t}",
    "output": "Improve class name parsing"
  }
]