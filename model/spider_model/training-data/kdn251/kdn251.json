[
  {
    "input": "diff --git a/company/google/PowerOfTwo.java b/company/google/PowerOfTwo.java\n--- a/company/google/PowerOfTwo.java\n+++ b/company/google/PowerOfTwo.java\n@@ -0,0 +1,25 @@\n+//Given an integer, write a function to determine if it is a power of two.\n+//\n+//Example 1:\n+//\n+//Input: 1\n+//Output: true\n+//Example 2:\n+//\n+//Input: 16\n+//Output: true\n+//Example 3:\n+//\n+//Input: 218\n+//Output: false\n+\n+class PowerOfTwo {\n+    public boolean isPowerOfTwo(int n) {\n+        long i = 1;\n+        while(i < n) {\n+            i <<= 1;\n+        }\n+        \n+        return i == n;\n+    }\n+}\n\ndiff --git a/leetcode/bit-manipulation/PowerOfTwo.java b/leetcode/bit-manipulation/PowerOfTwo.java\n--- a/leetcode/bit-manipulation/PowerOfTwo.java\n+++ b/leetcode/bit-manipulation/PowerOfTwo.java\n@@ -0,0 +1,25 @@\n+//Given an integer, write a function to determine if it is a power of two.\n+//\n+//Example 1:\n+//\n+//Input: 1\n+//Output: true\n+//Example 2:\n+//\n+//Input: 16\n+//Output: true\n+//Example 3:\n+//\n+//Input: 218\n+//Output: false\n+\n+class PowerOfTwo {\n+    public boolean isPowerOfTwo(int n) {\n+        long i = 1;\n+        while(i < n) {\n+            i <<= 1;\n+        }\n+        \n+        return i == n;\n+    }\n+}\n\ndiff --git a/leetcode/math/PowerOfTwo.java b/leetcode/math/PowerOfTwo.java\n--- a/leetcode/math/PowerOfTwo.java\n+++ b/leetcode/math/PowerOfTwo.java\n@@ -0,0 +1,25 @@\n+//Given an integer, write a function to determine if it is a power of two.\n+//\n+//Example 1:\n+//\n+//Input: 1\n+//Output: true\n+//Example 2:\n+//\n+//Input: 16\n+//Output: true\n+//Example 3:\n+//\n+//Input: 218\n+//Output: false\n+\n+class PowerOfTwo {\n+    public boolean isPowerOfTwo(int n) {\n+        long i = 1;\n+        while(i < n) {\n+            i <<= 1;\n+        }\n+        \n+        return i == n;\n+    }\n+}",
    "output": "Add PowerOfTwo.java"
  },
  {
    "input": "diff --git a/company/google/SpiralMatrix.java b/company/google/SpiralMatrix.java\n--- a/company/google/SpiralMatrix.java\n+++ b/company/google/SpiralMatrix.java\n@@ -0,0 +1,61 @@\n+//Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n+//\n+//Example 1:\n+//\n+//Input:\n+//[\n+ //[ 1, 2, 3 ],\n+ //[ 4, 5, 6 ],\n+ //[ 7, 8, 9 ]\n+//]\n+//Output: [1,2,3,6,9,8,7,4,5]\n+//Example 2:\n+//\n+//Input:\n+//[\n+  //[1, 2, 3, 4],\n+  //[5, 6, 7, 8],\n+  //[9,10,11,12]\n+//]\n+//Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n+\n+class SpiralMatrix {\n+    public List<Integer> spiralOrder(int[][] matrix) {\n+        List<Integer> result = new ArrayList<Integer>();\n+        if(matrix == null || matrix.length == 0) {\n+            return result;\n+        }\n+        \n+        int rowStart = 0;\n+        int rowEnd = matrix.length - 1;\n+        int colStart = 0;\n+        int colEnd = matrix[0].length - 1;\n+        while(rowStart <= rowEnd && colStart <= colEnd) {\n+            for(int i = colStart; i <= colEnd; i++) {\n+                result.add(matrix[rowStart][i]);\n+            }\n+            rowStart++;\n+            \n+            for(int i = rowStart; i <= rowEnd; i++) {\n+                result.add(matrix[i][colEnd]);\n+            }\n+            colEnd--;\n+            \n+            if(rowStart <= rowEnd) {\n+                for(int i = colEnd; i >= colStart; i--) {\n+                    result.add(matrix[rowEnd][i]);\n+                }\n+            }\n+            rowEnd--;\n+            \n+            if(colStart <= colEnd) {\n+                for(int i = rowEnd; i >= rowStart; i--) {\n+                    result.add(matrix[i][colStart]);\n+                }\n+            }   \n+            colStart++;\n+        }\n+        \n+        return result;\n+    }\n+}\n\ndiff --git a/company/microsoft/SpiralMatrix.java b/company/microsoft/SpiralMatrix.java\n--- a/company/microsoft/SpiralMatrix.java\n+++ b/company/microsoft/SpiralMatrix.java\n@@ -0,0 +1,61 @@\n+//Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n+//\n+//Example 1:\n+//\n+//Input:\n+//[\n+ //[ 1, 2, 3 ],\n+ //[ 4, 5, 6 ],\n+ //[ 7, 8, 9 ]\n+//]\n+//Output: [1,2,3,6,9,8,7,4,5]\n+//Example 2:\n+//\n+//Input:\n+//[\n+  //[1, 2, 3, 4],\n+  //[5, 6, 7, 8],\n+  //[9,10,11,12]\n+//]\n+//Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n+\n+class SpiralMatrix {\n+    public List<Integer> spiralOrder(int[][] matrix) {\n+        List<Integer> result = new ArrayList<Integer>();\n+        if(matrix == null || matrix.length == 0) {\n+            return result;\n+        }\n+        \n+        int rowStart = 0;\n+        int rowEnd = matrix.length - 1;\n+        int colStart = 0;\n+        int colEnd = matrix[0].length - 1;\n+        while(rowStart <= rowEnd && colStart <= colEnd) {\n+            for(int i = colStart; i <= colEnd; i++) {\n+                result.add(matrix[rowStart][i]);\n+            }\n+            rowStart++;\n+            \n+            for(int i = rowStart; i <= rowEnd; i++) {\n+                result.add(matrix[i][colEnd]);\n+            }\n+            colEnd--;\n+            \n+            if(rowStart <= rowEnd) {\n+                for(int i = colEnd; i >= colStart; i--) {\n+                    result.add(matrix[rowEnd][i]);\n+                }\n+            }\n+            rowEnd--;\n+            \n+            if(colStart <= colEnd) {\n+                for(int i = rowEnd; i >= rowStart; i--) {\n+                    result.add(matrix[i][colStart]);\n+                }\n+            }   \n+            colStart++;\n+        }\n+        \n+        return result;\n+    }\n+}\n\ndiff --git a/company/uber/SpiralMatrix.java b/company/uber/SpiralMatrix.java\n--- a/company/uber/SpiralMatrix.java\n+++ b/company/uber/SpiralMatrix.java\n@@ -0,0 +1,61 @@\n+//Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n+//\n+//Example 1:\n+//\n+//Input:\n+//[\n+ //[ 1, 2, 3 ],\n+ //[ 4, 5, 6 ],\n+ //[ 7, 8, 9 ]\n+//]\n+//Output: [1,2,3,6,9,8,7,4,5]\n+//Example 2:\n+//\n+//Input:\n+//[\n+  //[1, 2, 3, 4],\n+  //[5, 6, 7, 8],\n+  //[9,10,11,12]\n+//]\n+//Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n+\n+class SpiralMatrix {\n+    public List<Integer> spiralOrder(int[][] matrix) {\n+        List<Integer> result = new ArrayList<Integer>();\n+        if(matrix == null || matrix.length == 0) {\n+            return result;\n+        }\n+        \n+        int rowStart = 0;\n+        int rowEnd = matrix.length - 1;\n+        int colStart = 0;\n+        int colEnd = matrix[0].length - 1;\n+        while(rowStart <= rowEnd && colStart <= colEnd) {\n+            for(int i = colStart; i <= colEnd; i++) {\n+                result.add(matrix[rowStart][i]);\n+            }\n+            rowStart++;\n+            \n+            for(int i = rowStart; i <= rowEnd; i++) {\n+                result.add(matrix[i][colEnd]);\n+            }\n+            colEnd--;\n+            \n+            if(rowStart <= rowEnd) {\n+                for(int i = colEnd; i >= colStart; i--) {\n+                    result.add(matrix[rowEnd][i]);\n+                }\n+            }\n+            rowEnd--;\n+            \n+            if(colStart <= colEnd) {\n+                for(int i = rowEnd; i >= rowStart; i--) {\n+                    result.add(matrix[i][colStart]);\n+                }\n+            }   \n+            colStart++;\n+        }\n+        \n+        return result;\n+    }\n+}\n\ndiff --git a/leetcode/array/SpiralMatrix.java b/leetcode/array/SpiralMatrix.java\n--- a/leetcode/array/SpiralMatrix.java\n+++ b/leetcode/array/SpiralMatrix.java\n@@ -0,0 +1,61 @@\n+//Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n+//\n+//Example 1:\n+//\n+//Input:\n+//[\n+ //[ 1, 2, 3 ],\n+ //[ 4, 5, 6 ],\n+ //[ 7, 8, 9 ]\n+//]\n+//Output: [1,2,3,6,9,8,7,4,5]\n+//Example 2:\n+//\n+//Input:\n+//[\n+  //[1, 2, 3, 4],\n+  //[5, 6, 7, 8],\n+  //[9,10,11,12]\n+//]\n+//Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n+\n+class SpiralMatrix {\n+    public List<Integer> spiralOrder(int[][] matrix) {\n+        List<Integer> result = new ArrayList<Integer>();\n+        if(matrix == null || matrix.length == 0) {\n+            return result;\n+        }\n+        \n+        int rowStart = 0;\n+        int rowEnd = matrix.length - 1;\n+        int colStart = 0;\n+        int colEnd = matrix[0].length - 1;\n+        while(rowStart <= rowEnd && colStart <= colEnd) {\n+            for(int i = colStart; i <= colEnd; i++) {\n+                result.add(matrix[rowStart][i]);\n+            }\n+            rowStart++;\n+            \n+            for(int i = rowStart; i <= rowEnd; i++) {\n+                result.add(matrix[i][colEnd]);\n+            }\n+            colEnd--;\n+            \n+            if(rowStart <= rowEnd) {\n+                for(int i = colEnd; i >= colStart; i--) {\n+                    result.add(matrix[rowEnd][i]);\n+                }\n+            }\n+            rowEnd--;\n+            \n+            if(colStart <= colEnd) {\n+                for(int i = rowEnd; i >= rowStart; i--) {\n+                    result.add(matrix[i][colStart]);\n+                }\n+            }   \n+            colStart++;\n+        }\n+        \n+        return result;\n+    }\n+}",
    "output": "Add SpiralMatrix.java"
  },
  {
    "input": "diff --git a/company/google/DailyTemperatures.java b/company/google/DailyTemperatures.java\n--- a/company/google/DailyTemperatures.java\n+++ b/company/google/DailyTemperatures.java\n@@ -0,0 +1,21 @@\n+//Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.\n+//\n+//For example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].\n+//\n+//Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].\n+\n+class DailyTemperatures {\n+    public int[] dailyTemperatures(int[] temperatures) {\n+        int[] result = new int[temperatures.length];\n+        Stack<Integer> stack = new Stack<Integer>();\n+        for(int i = 0; i < temperatures.length; i++) {\n+            while(!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n+                int index = stack.pop();\n+                result[index] = i - index;\n+            }\n+            stack.push(i);\n+        }\n+        \n+        return result;\n+    }\n+}\n\ndiff --git a/leetcode/hash-table/DailyTemperatures.java b/leetcode/hash-table/DailyTemperatures.java\n--- a/leetcode/hash-table/DailyTemperatures.java\n+++ b/leetcode/hash-table/DailyTemperatures.java\n@@ -0,0 +1,21 @@\n+//Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.\n+//\n+//For example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].\n+//\n+//Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].\n+\n+class DailyTemperatures {\n+    public int[] dailyTemperatures(int[] temperatures) {\n+        int[] result = new int[temperatures.length];\n+        Stack<Integer> stack = new Stack<Integer>();\n+        for(int i = 0; i < temperatures.length; i++) {\n+            while(!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n+                int index = stack.pop();\n+                result[index] = i - index;\n+            }\n+            stack.push(i);\n+        }\n+        \n+        return result;\n+    }\n+}\n\ndiff --git a/leetcode/stack/DailyTemperatures.java b/leetcode/stack/DailyTemperatures.java\n--- a/leetcode/stack/DailyTemperatures.java\n+++ b/leetcode/stack/DailyTemperatures.java\n@@ -0,0 +1,21 @@\n+//Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.\n+//\n+//For example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].\n+//\n+//Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].\n+\n+class DailyTemperatures {\n+    public int[] dailyTemperatures(int[] temperatures) {\n+        int[] result = new int[temperatures.length];\n+        Stack<Integer> stack = new Stack<Integer>();\n+        for(int i = 0; i < temperatures.length; i++) {\n+            while(!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n+                int index = stack.pop();\n+                result[index] = i - index;\n+            }\n+            stack.push(i);\n+        }\n+        \n+        return result;\n+    }\n+}",
    "output": "Add DailyTemperatures.java"
  },
  {
    "input": "diff --git a/company/google/GuessNumberHigherOrLower.java b/company/google/GuessNumberHigherOrLower.java\n--- a/company/google/GuessNumberHigherOrLower.java\n+++ b/company/google/GuessNumberHigherOrLower.java\n@@ -21,30 +21,19 @@\n \n public class GuessNumberHigherOrLower extends GuessGame {\n     public int guessNumber(int n) {\n-        return binarySearch(1, n);\n-    }\n-    \n-    private int binarySearch(int start, int end) {\n-        if(start > end) {\n-            return -1;\n-        }\n-        \n-        if(guess(start) == 0) {\n-            return start;\n+        int left = 1;\n+        int right = n;\n+        while(left <= right) {\n+            int mid = left + (right - left) / 2;\n+            if(guess(mid) == 0) {\n+                return mid;\n+            } else if(guess(mid) > 0) {\n+                left = mid + 1;\n+            } else {\n+                right = mid;\n+            }\n         }\n         \n-        if(guess(end) == 0) {\n-            return end;\n-        }\n-        \n-        int mid = start + (end - start) / 2;\n-        \n-        if(guess(mid) == 0) {\n-            return mid;\n-        } else if(guess(mid) == 1) {\n-            return binarySearch(mid + 1, end);\n-        } else {\n-            return binarySearch(start, mid - 1);\n-        }\n+        return -1;\n     }\n }\n\ndiff --git a/leetcode/binary-search/GuessNumberHigherOrLower.java b/leetcode/binary-search/GuessNumberHigherOrLower.java\n--- a/leetcode/binary-search/GuessNumberHigherOrLower.java\n+++ b/leetcode/binary-search/GuessNumberHigherOrLower.java\n@@ -14,37 +14,21 @@\n \n // Return 6.\n \n-/* The guess API is defined in the parent class GuessGame.\n-   @param num, your guess\n-   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n-      int guess(int num); */\n-\n public class GuessNumberHigherOrLower extends GuessGame {\n     public int guessNumber(int n) {\n-        return binarySearch(1, n);\n-    }\n-    \n-    private int binarySearch(int start, int end) {\n-        if(start > end) {\n-            return -1;\n-        }\n-        \n-        if(guess(start) == 0) {\n-            return start;\n-        }\n-\n-        if(guess(end) == 0) {\n-            return end;\n+        int left = 1;\n+        int right = n;\n+        while(left <= right) {\n+            int mid = left + (right - left) / 2;\n+            if(guess(mid) == 0) {\n+                return mid;\n+            } else if(guess(mid) > 0) {\n+                left = mid + 1;\n+            } else {\n+                right = mid;\n+            }\n         }\n         \n-        int mid = start + (end - start) / 2;\n-        \n-        if(guess(mid) == 0) {\n-            return mid;\n-        } else if(guess(mid) == 1) {\n-            return binarySearch(mid + 1, end);\n-        } else {\n-            return binarySearch(start, mid - 1);\n-        }\n+        return -1;\n     }\n }",
    "output": "Add alternative solution to GuessNumberHigherOrLower.java"
  },
  {
    "input": "diff --git a/company/google/FindAllNumbersDisappearedInAnArray.java b/company/google/FindAllNumbersDisappearedInAnArray.java\n--- a/company/google/FindAllNumbersDisappearedInAnArray.java\n+++ b/company/google/FindAllNumbersDisappearedInAnArray.java\n@@ -0,0 +1,37 @@\n+//Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.\n+//\n+//Find all the elements of [1, n] inclusive that do not appear in this array.\n+//\n+//Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\n+//\n+//Example:\n+//\n+//Input:\n+//[4,3,2,7,8,2,3,1]\n+//\n+//Output:\n+//[5,6]\n+\n+class FindAllNumbersDisappearedInAnArray {\n+    public List<Integer> findDisappearedNumbers(int[] nums) {\n+        List<Integer> result = new ArrayList<Integer>();\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i = 1; i <= nums.length; i++) {\n+            map.put(i, 1);\n+        }\n+        \n+        for(int i = 0; i < nums.length; i++) {\n+            if(map.containsKey(nums[i])) {\n+                map.put(nums[i], -1);\n+            }\n+        }\n+        \n+        for(int i: map.keySet()) {\n+            if(map.get(i) != -1) {\n+                result.add(i);\n+            }\n+        }\n+        \n+        return result;\n+    }\n+}\n\ndiff --git a/leetcode/array/FindAllNumbersDisappearedInAnArray.java b/leetcode/array/FindAllNumbersDisappearedInAnArray.java\n--- a/leetcode/array/FindAllNumbersDisappearedInAnArray.java\n+++ b/leetcode/array/FindAllNumbersDisappearedInAnArray.java\n@@ -0,0 +1,37 @@\n+//Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.\n+//\n+//Find all the elements of [1, n] inclusive that do not appear in this array.\n+//\n+//Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\n+//\n+//Example:\n+//\n+//Input:\n+//[4,3,2,7,8,2,3,1]\n+//\n+//Output:\n+//[5,6]\n+\n+class FindAllNumbersDisappearedInAnArray {\n+    public List<Integer> findDisappearedNumbers(int[] nums) {\n+        List<Integer> result = new ArrayList<Integer>();\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i = 1; i <= nums.length; i++) {\n+            map.put(i, 1);\n+        }\n+        \n+        for(int i = 0; i < nums.length; i++) {\n+            if(map.containsKey(nums[i])) {\n+                map.put(nums[i], -1);\n+            }\n+        }\n+        \n+        for(int i: map.keySet()) {\n+            if(map.get(i) != -1) {\n+                result.add(i);\n+            }\n+        }\n+        \n+        return result;\n+    }\n+}",
    "output": "Add FindAllNumbersDisappearedInAnArray.java"
  },
  {
    "input": "diff --git a/company/amazon/FirstUniqueCharacterInAString.java b/company/amazon/FirstUniqueCharacterInAString.java\n--- a/company/amazon/FirstUniqueCharacterInAString.java\n+++ b/company/amazon/FirstUniqueCharacterInAString.java\n@@ -0,0 +1,34 @@\n+//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n+//\n+//Examples:\n+//\n+//s = \"leetcode\"\n+//return 0.\n+//\n+//s = \"loveleetcode\",\n+//return 2.\n+//Note: You may assume the string contain only lowercase letters.\n+\n+class FirstUniqueCharacterInAString {\n+    public int firstUniqChar(String s) {\n+        HashMap<Character, Integer> characters = new HashMap<Character, Integer>();\n+        for(int i = 0; i < s.length(); i++) {\n+            char current = s.charAt(i);\n+            if(characters.containsKey(current)) {\n+                characters.put(current, -1);\n+            } else {\n+                characters.put(current, i);\n+            }\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(char c: characters.keySet()) {\n+            if(characters.get(c) > -1 && characters.get(c) < min) {\n+                min = characters.get(c);\n+            }\n+        }\n+        \n+        return min == Integer.MAX_VALUE ? -1 : min;\n+        \n+    }\n+}\n\ndiff --git a/company/bloomberg/FirstUniqueCharacterInAString.java b/company/bloomberg/FirstUniqueCharacterInAString.java\n--- a/company/bloomberg/FirstUniqueCharacterInAString.java\n+++ b/company/bloomberg/FirstUniqueCharacterInAString.java\n@@ -0,0 +1,34 @@\n+//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n+//\n+//Examples:\n+//\n+//s = \"leetcode\"\n+//return 0.\n+//\n+//s = \"loveleetcode\",\n+//return 2.\n+//Note: You may assume the string contain only lowercase letters.\n+\n+class FirstUniqueCharacterInAString {\n+    public int firstUniqChar(String s) {\n+        HashMap<Character, Integer> characters = new HashMap<Character, Integer>();\n+        for(int i = 0; i < s.length(); i++) {\n+            char current = s.charAt(i);\n+            if(characters.containsKey(current)) {\n+                characters.put(current, -1);\n+            } else {\n+                characters.put(current, i);\n+            }\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(char c: characters.keySet()) {\n+            if(characters.get(c) > -1 && characters.get(c) < min) {\n+                min = characters.get(c);\n+            }\n+        }\n+        \n+        return min == Integer.MAX_VALUE ? -1 : min;\n+        \n+    }\n+}\n\ndiff --git a/company/google/FirstUniqueCharacterInAString.java b/company/google/FirstUniqueCharacterInAString.java\n--- a/company/google/FirstUniqueCharacterInAString.java\n+++ b/company/google/FirstUniqueCharacterInAString.java\n@@ -0,0 +1,34 @@\n+//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n+//\n+//Examples:\n+//\n+//s = \"leetcode\"\n+//return 0.\n+//\n+//s = \"loveleetcode\",\n+//return 2.\n+//Note: You may assume the string contain only lowercase letters.\n+\n+class FirstUniqueCharacterInAString {\n+    public int firstUniqChar(String s) {\n+        HashMap<Character, Integer> characters = new HashMap<Character, Integer>();\n+        for(int i = 0; i < s.length(); i++) {\n+            char current = s.charAt(i);\n+            if(characters.containsKey(current)) {\n+                characters.put(current, -1);\n+            } else {\n+                characters.put(current, i);\n+            }\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(char c: characters.keySet()) {\n+            if(characters.get(c) > -1 && characters.get(c) < min) {\n+                min = characters.get(c);\n+            }\n+        }\n+        \n+        return min == Integer.MAX_VALUE ? -1 : min;\n+        \n+    }\n+}\n\ndiff --git a/company/microsoft/FirstUniqueCharacterInAString.java b/company/microsoft/FirstUniqueCharacterInAString.java\n--- a/company/microsoft/FirstUniqueCharacterInAString.java\n+++ b/company/microsoft/FirstUniqueCharacterInAString.java\n@@ -0,0 +1,34 @@\n+//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n+//\n+//Examples:\n+//\n+//s = \"leetcode\"\n+//return 0.\n+//\n+//s = \"loveleetcode\",\n+//return 2.\n+//Note: You may assume the string contain only lowercase letters.\n+\n+class FirstUniqueCharacterInAString {\n+    public int firstUniqChar(String s) {\n+        HashMap<Character, Integer> characters = new HashMap<Character, Integer>();\n+        for(int i = 0; i < s.length(); i++) {\n+            char current = s.charAt(i);\n+            if(characters.containsKey(current)) {\n+                characters.put(current, -1);\n+            } else {\n+                characters.put(current, i);\n+            }\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(char c: characters.keySet()) {\n+            if(characters.get(c) > -1 && characters.get(c) < min) {\n+                min = characters.get(c);\n+            }\n+        }\n+        \n+        return min == Integer.MAX_VALUE ? -1 : min;\n+        \n+    }\n+}\n\ndiff --git a/leetcode/hash-table/FirstUniqueCharacterInAString.java b/leetcode/hash-table/FirstUniqueCharacterInAString.java\n--- a/leetcode/hash-table/FirstUniqueCharacterInAString.java\n+++ b/leetcode/hash-table/FirstUniqueCharacterInAString.java\n@@ -0,0 +1,34 @@\n+//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n+//\n+//Examples:\n+//\n+//s = \"leetcode\"\n+//return 0.\n+//\n+//s = \"loveleetcode\",\n+//return 2.\n+//Note: You may assume the string contain only lowercase letters.\n+\n+class FirstUniqueCharacterInAString {\n+    public int firstUniqChar(String s) {\n+        HashMap<Character, Integer> characters = new HashMap<Character, Integer>();\n+        for(int i = 0; i < s.length(); i++) {\n+            char current = s.charAt(i);\n+            if(characters.containsKey(current)) {\n+                characters.put(current, -1);\n+            } else {\n+                characters.put(current, i);\n+            }\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(char c: characters.keySet()) {\n+            if(characters.get(c) > -1 && characters.get(c) < min) {\n+                min = characters.get(c);\n+            }\n+        }\n+        \n+        return min == Integer.MAX_VALUE ? -1 : min;\n+        \n+    }\n+}\n\ndiff --git a/leetcode/string/FirstUniqueCharacterInAString.java b/leetcode/string/FirstUniqueCharacterInAString.java\n--- a/leetcode/string/FirstUniqueCharacterInAString.java\n+++ b/leetcode/string/FirstUniqueCharacterInAString.java\n@@ -0,0 +1,34 @@\n+//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n+//\n+//Examples:\n+//\n+//s = \"leetcode\"\n+//return 0.\n+//\n+//s = \"loveleetcode\",\n+//return 2.\n+//Note: You may assume the string contain only lowercase letters.\n+\n+class FirstUniqueCharacterInAString {\n+    public int firstUniqChar(String s) {\n+        HashMap<Character, Integer> characters = new HashMap<Character, Integer>();\n+        for(int i = 0; i < s.length(); i++) {\n+            char current = s.charAt(i);\n+            if(characters.containsKey(current)) {\n+                characters.put(current, -1);\n+            } else {\n+                characters.put(current, i);\n+            }\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(char c: characters.keySet()) {\n+            if(characters.get(c) > -1 && characters.get(c) < min) {\n+                min = characters.get(c);\n+            }\n+        }\n+        \n+        return min == Integer.MAX_VALUE ? -1 : min;\n+        \n+    }\n+}",
    "output": "Add FirstUniqueCharacterInAString.java"
  },
  {
    "input": "diff --git a/company/facebook/LongestConsecutiveSequence.java b/company/facebook/LongestConsecutiveSequence.java\n--- a/company/facebook/LongestConsecutiveSequence.java\n+++ b/company/facebook/LongestConsecutiveSequence.java\n@@ -6,27 +6,32 @@\n \n // Your algorithm should run in O(n) complexity.\n \n-public class LongestConsecutiveSequence {\n+class LongestConsecutiveSequence {\n     public int longestConsecutive(int[] nums) {\n-        int res = 0;\n-        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        if(nums == null || nums.length == 0) {\n+            return 0;\n+        }\n+        \n+        Set<Integer> set = new HashSet<Integer>();\n+        for(int n: nums) {\n+            set.add(n);\n+        }\n         \n-        for(int n : nums) {\n-            if(!map.containsKey(n)) {\n-                int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;\n-                int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;\n+        int maxLength = 0;\n+        for(int n: set) {\n+            if(!set.contains(n - 1)) {\n+                int current = n;\n+                int currentMax = 1;\n                 \n-                int sum = left + right + 1;\n-                map.put(n, sum);\n-                res = Math.max(res, sum);\n+                while(set.contains(n + 1)) {\n+                    currentMax++;\n+                    n++;\n+                }\n                 \n-                map.put(n - left, sum);\n-                map.put(n + right, sum);\n-            } else {\n-                continue;\n+                maxLength = Math.max(maxLength, currentMax);\n             }\n         }\n         \n-        return res;\n+        return maxLength;\n     }\n }\n\ndiff --git a/company/google/LongestConsecutiveSequence.java b/company/google/LongestConsecutiveSequence.java\n--- a/company/google/LongestConsecutiveSequence.java\n+++ b/company/google/LongestConsecutiveSequence.java\n@@ -6,27 +6,32 @@\n \n // Your algorithm should run in O(n) complexity.\n \n-public class LongestConsecutiveSequence {\n+class LongestConsecutiveSequence {\n     public int longestConsecutive(int[] nums) {\n-        int res = 0;\n-        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        if(nums == null || nums.length == 0) {\n+            return 0;\n+        }\n+        \n+        Set<Integer> set = new HashSet<Integer>();\n+        for(int n: nums) {\n+            set.add(n);\n+        }\n         \n-        for(int n : nums) {\n-            if(!map.containsKey(n)) {\n-                int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;\n-                int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;\n+        int maxLength = 0;\n+        for(int n: set) {\n+            if(!set.contains(n - 1)) {\n+                int current = n;\n+                int currentMax = 1;\n                 \n-                int sum = left + right + 1;\n-                map.put(n, sum);\n-                res = Math.max(res, sum);\n+                while(set.contains(n + 1)) {\n+                    currentMax++;\n+                    n++;\n+                }\n                 \n-                map.put(n - left, sum);\n-                map.put(n + right, sum);\n-            } else {\n-                continue;\n+                maxLength = Math.max(maxLength, currentMax);\n             }\n         }\n         \n-        return res;\n+        return maxLength;\n     }\n }\n\ndiff --git a/leetcode/array/LongestConsecutiveSequence.java b/leetcode/array/LongestConsecutiveSequence.java\n--- a/leetcode/array/LongestConsecutiveSequence.java\n+++ b/leetcode/array/LongestConsecutiveSequence.java\n@@ -6,27 +6,32 @@\n \n // Your algorithm should run in O(n) complexity.\n \n-public class LongestConsecutiveSequence {\n+class LongestConsecutiveSequence {\n     public int longestConsecutive(int[] nums) {\n-        int res = 0;\n-        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        if(nums == null || nums.length == 0) {\n+            return 0;\n+        }\n+        \n+        Set<Integer> set = new HashSet<Integer>();\n+        for(int n: nums) {\n+            set.add(n);\n+        }\n         \n-        for(int n : nums) {\n-            if(!map.containsKey(n)) {\n-                int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;\n-                int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;\n+        int maxLength = 0;\n+        for(int n: set) {\n+            if(!set.contains(n - 1)) {\n+                int current = n;\n+                int currentMax = 1;\n                 \n-                int sum = left + right + 1;\n-                map.put(n, sum);\n-                res = Math.max(res, sum);\n+                while(set.contains(n + 1)) {\n+                    currentMax++;\n+                    n++;\n+                }\n                 \n-                map.put(n - left, sum);\n-                map.put(n + right, sum);\n-            } else {\n-                continue;\n+                maxLength = Math.max(maxLength, currentMax);\n             }\n         }\n         \n-        return res;\n+        return maxLength;\n     }\n }",
    "output": "Add modified solution for LongestConsecutiveSequence.java"
  },
  {
    "input": "diff --git a/company/google/JudgeRouteCircle.java b/company/google/JudgeRouteCircle.java\n--- a/company/google/JudgeRouteCircle.java\n+++ b/company/google/JudgeRouteCircle.java\n@@ -0,0 +1,30 @@\n+//Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.\n+//\n+//The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.\n+//\n+//Example 1:\n+//Input: \"UD\"\n+//Output: true\n+//Example 2:\n+//Input: \"LL\"\n+//Output: false\n+\n+class JudgeRouteCircle {\n+    public boolean judgeCircle(String moves) {\n+        int UD = 0;\n+        int LR = 0;\n+        for(int i = 0; i < moves.length(); i++) {\n+            if(moves.charAt(i) == 'U') {\n+                UD++;\n+            } else if(moves.charAt(i) == 'D') {\n+                UD--;\n+            } else if(moves.charAt(i) == 'L') {\n+                LR++;\n+            } else if(moves.charAt(i) == 'R') {\n+                LR--;\n+            }\n+        }\n+        \n+        return UD == 0 && LR == 0;\n+    }\n+}\n\ndiff --git a/leetcode/string/JudgeRouteCircle.java b/leetcode/string/JudgeRouteCircle.java\n--- a/leetcode/string/JudgeRouteCircle.java\n+++ b/leetcode/string/JudgeRouteCircle.java\n@@ -0,0 +1,30 @@\n+//Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.\n+//\n+//The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.\n+//\n+//Example 1:\n+//Input: \"UD\"\n+//Output: true\n+//Example 2:\n+//Input: \"LL\"\n+//Output: false\n+\n+class JudgeRouteCircle {\n+    public boolean judgeCircle(String moves) {\n+        int UD = 0;\n+        int LR = 0;\n+        for(int i = 0; i < moves.length(); i++) {\n+            if(moves.charAt(i) == 'U') {\n+                UD++;\n+            } else if(moves.charAt(i) == 'D') {\n+                UD--;\n+            } else if(moves.charAt(i) == 'L') {\n+                LR++;\n+            } else if(moves.charAt(i) == 'R') {\n+                LR--;\n+            }\n+        }\n+        \n+        return UD == 0 && LR == 0;\n+    }\n+}",
    "output": "Add JudgeRouteCircle.java"
  },
  {
    "input": "diff --git a/company/google/BullsAndCows.java b/company/google/BullsAndCows.java\n--- a/company/google/BullsAndCows.java\n+++ b/company/google/BullsAndCows.java\n@@ -0,0 +1,43 @@\n+//You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called \"bulls\") and how many digits match the secret number but locate in the wrong position (called \"cows\"). Your friend will use successive guesses and hints to eventually derive the secret number.\n+//\n+//Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. \n+//\n+//Please note that both secret number and friend's guess may contain duplicate digits.\n+//\n+//Example 1:\n+//\n+//Input: secret = \"1807\", guess = \"7810\"\n+//\n+//Output: \"1A3B\"\n+//\n+//Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.\n+//Example 2:\n+//\n+//Input: secret = \"1123\", guess = \"0111\"\n+//\n+//Output: \"1A1B\"\n+//\n+//Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.\n+//Note: You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.\n+\n+class BullsAndCows {\n+    public String getHint(String secret, String guess) {\n+        int bulls = 0;\n+        int cows = 0;\n+        int[] counts = new int[10];\n+        for(int i = 0; i < secret.length(); i++) {\n+            if(secret.charAt(i) == guess.charAt(i)) {\n+                bulls++;\n+            }  else {\n+                if(counts[secret.charAt(i) - '0']++ < 0) {\n+                    cows++;\n+                }\n+                if(counts[guess.charAt(i) - '0']-- > 0) {\n+                    cows++;\n+                }\n+            }\n+        }\n+        \n+        return bulls + \"A\" + cows + \"B\";\n+    }\n+}\n\ndiff --git a/leetcode/hash-table/BullsAndCows.java b/leetcode/hash-table/BullsAndCows.java\n--- a/leetcode/hash-table/BullsAndCows.java\n+++ b/leetcode/hash-table/BullsAndCows.java\n@@ -0,0 +1,43 @@\n+//You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called \"bulls\") and how many digits match the secret number but locate in the wrong position (called \"cows\"). Your friend will use successive guesses and hints to eventually derive the secret number.\n+//\n+//Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. \n+//\n+//Please note that both secret number and friend's guess may contain duplicate digits.\n+//\n+//Example 1:\n+//\n+//Input: secret = \"1807\", guess = \"7810\"\n+//\n+//Output: \"1A3B\"\n+//\n+//Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.\n+//Example 2:\n+//\n+//Input: secret = \"1123\", guess = \"0111\"\n+//\n+//Output: \"1A1B\"\n+//\n+//Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.\n+//Note: You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.\n+\n+class BullsAndCows {\n+    public String getHint(String secret, String guess) {\n+        int bulls = 0;\n+        int cows = 0;\n+        int[] counts = new int[10];\n+        for(int i = 0; i < secret.length(); i++) {\n+            if(secret.charAt(i) == guess.charAt(i)) {\n+                bulls++;\n+            }  else {\n+                if(counts[secret.charAt(i) - '0']++ < 0) {\n+                    cows++;\n+                }\n+                if(counts[guess.charAt(i) - '0']-- > 0) {\n+                    cows++;\n+                }\n+            }\n+        }\n+        \n+        return bulls + \"A\" + cows + \"B\";\n+    }\n+}",
    "output": "Add BullsAndCows.java"
  },
  {
    "input": "diff --git a/company/amazon/MinStack.java b/company/amazon/MinStack.java\n--- a/company/amazon/MinStack.java\n+++ b/company/amazon/MinStack.java\n@@ -0,0 +1,55 @@\n+//Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n+//push(x) -- Push element x onto stack.\n+//pop() -- Removes the element on top of the stack.\n+//top() -- Get the top element.\n+//getMin() -- Retrieve the minimum element in the stack.\n+\n+/**\n+ * Your MinStack object will be instantiated and called as such:\n+ * MinStack obj = new MinStack();\n+ * obj.push(x);\n+ * obj.pop();\n+ * int param_3 = obj.top();\n+ * int param_4 = obj.getMin();\n+ */\n+class MinStack {\n+    class Node {\n+        int data;\n+        int min;\n+        Node next;\n+        \n+        public Node(int data, int min) {\n+            this.data = data;\n+            this.min = min;\n+            this.next = null;\n+        }\n+    }\n+    Node head;\n+    \n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        \n+    }\n+    \n+    public void push(int x) {\n+        if(head == null) {\n+            head = new Node(x, x);\n+        } else {\n+            Node newNode = new Node(x, Math.min(x, head.min));\n+            newNode.next = head;\n+            head = newNode;\n+        }\n+    }\n+    \n+    public void pop() {\n+        head = head.next;\n+    }\n+    \n+    public int top() {\n+        return head.data;\n+    }\n+    \n+    public int getMin() {\n+        return head.min;\n+    }\n+}\n\ndiff --git a/company/bloomberg/MinStack.java b/company/bloomberg/MinStack.java\n--- a/company/bloomberg/MinStack.java\n+++ b/company/bloomberg/MinStack.java\n@@ -0,0 +1,55 @@\n+//Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n+//push(x) -- Push element x onto stack.\n+//pop() -- Removes the element on top of the stack.\n+//top() -- Get the top element.\n+//getMin() -- Retrieve the minimum element in the stack.\n+\n+/**\n+ * Your MinStack object will be instantiated and called as such:\n+ * MinStack obj = new MinStack();\n+ * obj.push(x);\n+ * obj.pop();\n+ * int param_3 = obj.top();\n+ * int param_4 = obj.getMin();\n+ */\n+class MinStack {\n+    class Node {\n+        int data;\n+        int min;\n+        Node next;\n+        \n+        public Node(int data, int min) {\n+            this.data = data;\n+            this.min = min;\n+            this.next = null;\n+        }\n+    }\n+    Node head;\n+    \n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        \n+    }\n+    \n+    public void push(int x) {\n+        if(head == null) {\n+            head = new Node(x, x);\n+        } else {\n+            Node newNode = new Node(x, Math.min(x, head.min));\n+            newNode.next = head;\n+            head = newNode;\n+        }\n+    }\n+    \n+    public void pop() {\n+        head = head.next;\n+    }\n+    \n+    public int top() {\n+        return head.data;\n+    }\n+    \n+    public int getMin() {\n+        return head.min;\n+    }\n+}\n\ndiff --git a/company/google/MinStack.java b/company/google/MinStack.java\n--- a/company/google/MinStack.java\n+++ b/company/google/MinStack.java\n@@ -0,0 +1,55 @@\n+//Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n+//push(x) -- Push element x onto stack.\n+//pop() -- Removes the element on top of the stack.\n+//top() -- Get the top element.\n+//getMin() -- Retrieve the minimum element in the stack.\n+\n+/**\n+ * Your MinStack object will be instantiated and called as such:\n+ * MinStack obj = new MinStack();\n+ * obj.push(x);\n+ * obj.pop();\n+ * int param_3 = obj.top();\n+ * int param_4 = obj.getMin();\n+ */\n+class MinStack {\n+    class Node {\n+        int data;\n+        int min;\n+        Node next;\n+        \n+        public Node(int data, int min) {\n+            this.data = data;\n+            this.min = min;\n+            this.next = null;\n+        }\n+    }\n+    Node head;\n+    \n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        \n+    }\n+    \n+    public void push(int x) {\n+        if(head == null) {\n+            head = new Node(x, x);\n+        } else {\n+            Node newNode = new Node(x, Math.min(x, head.min));\n+            newNode.next = head;\n+            head = newNode;\n+        }\n+    }\n+    \n+    public void pop() {\n+        head = head.next;\n+    }\n+    \n+    public int top() {\n+        return head.data;\n+    }\n+    \n+    public int getMin() {\n+        return head.min;\n+    }\n+}\n\ndiff --git a/company/snapchat/MinStack.java b/company/snapchat/MinStack.java\n--- a/company/snapchat/MinStack.java\n+++ b/company/snapchat/MinStack.java\n@@ -0,0 +1,55 @@\n+//Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n+//push(x) -- Push element x onto stack.\n+//pop() -- Removes the element on top of the stack.\n+//top() -- Get the top element.\n+//getMin() -- Retrieve the minimum element in the stack.\n+\n+/**\n+ * Your MinStack object will be instantiated and called as such:\n+ * MinStack obj = new MinStack();\n+ * obj.push(x);\n+ * obj.pop();\n+ * int param_3 = obj.top();\n+ * int param_4 = obj.getMin();\n+ */\n+class MinStack {\n+    class Node {\n+        int data;\n+        int min;\n+        Node next;\n+        \n+        public Node(int data, int min) {\n+            this.data = data;\n+            this.min = min;\n+            this.next = null;\n+        }\n+    }\n+    Node head;\n+    \n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        \n+    }\n+    \n+    public void push(int x) {\n+        if(head == null) {\n+            head = new Node(x, x);\n+        } else {\n+            Node newNode = new Node(x, Math.min(x, head.min));\n+            newNode.next = head;\n+            head = newNode;\n+        }\n+    }\n+    \n+    public void pop() {\n+        head = head.next;\n+    }\n+    \n+    public int top() {\n+        return head.data;\n+    }\n+    \n+    public int getMin() {\n+        return head.min;\n+    }\n+}\n\ndiff --git a/company/uber/MinStack.java b/company/uber/MinStack.java\n--- a/company/uber/MinStack.java\n+++ b/company/uber/MinStack.java\n@@ -0,0 +1,55 @@\n+//Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n+//push(x) -- Push element x onto stack.\n+//pop() -- Removes the element on top of the stack.\n+//top() -- Get the top element.\n+//getMin() -- Retrieve the minimum element in the stack.\n+\n+/**\n+ * Your MinStack object will be instantiated and called as such:\n+ * MinStack obj = new MinStack();\n+ * obj.push(x);\n+ * obj.pop();\n+ * int param_3 = obj.top();\n+ * int param_4 = obj.getMin();\n+ */\n+class MinStack {\n+    class Node {\n+        int data;\n+        int min;\n+        Node next;\n+        \n+        public Node(int data, int min) {\n+            this.data = data;\n+            this.min = min;\n+            this.next = null;\n+        }\n+    }\n+    Node head;\n+    \n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        \n+    }\n+    \n+    public void push(int x) {\n+        if(head == null) {\n+            head = new Node(x, x);\n+        } else {\n+            Node newNode = new Node(x, Math.min(x, head.min));\n+            newNode.next = head;\n+            head = newNode;\n+        }\n+    }\n+    \n+    public void pop() {\n+        head = head.next;\n+    }\n+    \n+    public int top() {\n+        return head.data;\n+    }\n+    \n+    public int getMin() {\n+        return head.min;\n+    }\n+}\n\ndiff --git a/leetcode/design/MinStack.java b/leetcode/design/MinStack.java\n--- a/leetcode/design/MinStack.java\n+++ b/leetcode/design/MinStack.java\n@@ -0,0 +1,55 @@\n+//Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n+//push(x) -- Push element x onto stack.\n+//pop() -- Removes the element on top of the stack.\n+//top() -- Get the top element.\n+//getMin() -- Retrieve the minimum element in the stack.\n+\n+/**\n+ * Your MinStack object will be instantiated and called as such:\n+ * MinStack obj = new MinStack();\n+ * obj.push(x);\n+ * obj.pop();\n+ * int param_3 = obj.top();\n+ * int param_4 = obj.getMin();\n+ */\n+class MinStack {\n+    class Node {\n+        int data;\n+        int min;\n+        Node next;\n+        \n+        public Node(int data, int min) {\n+            this.data = data;\n+            this.min = min;\n+            this.next = null;\n+        }\n+    }\n+    Node head;\n+    \n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        \n+    }\n+    \n+    public void push(int x) {\n+        if(head == null) {\n+            head = new Node(x, x);\n+        } else {\n+            Node newNode = new Node(x, Math.min(x, head.min));\n+            newNode.next = head;\n+            head = newNode;\n+        }\n+    }\n+    \n+    public void pop() {\n+        head = head.next;\n+    }\n+    \n+    public int top() {\n+        return head.data;\n+    }\n+    \n+    public int getMin() {\n+        return head.min;\n+    }\n+}",
    "output": "Add MinStack.java"
  },
  {
    "input": "diff --git a/company/google/GenerateParentheses.java b/company/google/GenerateParentheses.java\n--- a/company/google/GenerateParentheses.java\n+++ b/company/google/GenerateParentheses.java\n@@ -0,0 +1,23 @@\n+class GenerateParentheses {\n+    public List<String> generateParenthesis(int n) {\n+        List<String> result = new ArrayList<String>();\n+        generateParenthesisRecursive(result, \"\", 0, 0, n);\n+        \n+        return result;\n+    }\n+    \n+    public void generateParenthesisRecursive(List<String> result, String current, int open, int close, int n) {\n+        if(current.length() == n * 2) {\n+            result.add(current);\n+            return;\n+        }\n+        \n+        if(open < n) {\n+            generateParenthesisRecursive(result, current + \"(\", open + 1, close, n);\n+        }\n+        \n+        if(close < open) {\n+            generateParenthesisRecursive(result, current + \")\", open, close + 1, n);\n+        }\n+    }\n+}\n\ndiff --git a/company/uber/GenerateParentheses.java b/company/uber/GenerateParentheses.java\n--- a/company/uber/GenerateParentheses.java\n+++ b/company/uber/GenerateParentheses.java\n@@ -0,0 +1,23 @@\n+class GenerateParentheses {\n+    public List<String> generateParenthesis(int n) {\n+        List<String> result = new ArrayList<String>();\n+        generateParenthesisRecursive(result, \"\", 0, 0, n);\n+        \n+        return result;\n+    }\n+    \n+    public void generateParenthesisRecursive(List<String> result, String current, int open, int close, int n) {\n+        if(current.length() == n * 2) {\n+            result.add(current);\n+            return;\n+        }\n+        \n+        if(open < n) {\n+            generateParenthesisRecursive(result, current + \"(\", open + 1, close, n);\n+        }\n+        \n+        if(close < open) {\n+            generateParenthesisRecursive(result, current + \")\", open, close + 1, n);\n+        }\n+    }\n+}\n\ndiff --git a/leetcode/backtracking/GenerateParentheses.java b/leetcode/backtracking/GenerateParentheses.java\n--- a/leetcode/backtracking/GenerateParentheses.java\n+++ b/leetcode/backtracking/GenerateParentheses.java\n@@ -0,0 +1,23 @@\n+class GenerateParentheses {\n+    public List<String> generateParenthesis(int n) {\n+        List<String> result = new ArrayList<String>();\n+        generateParenthesisRecursive(result, \"\", 0, 0, n);\n+        \n+        return result;\n+    }\n+    \n+    public void generateParenthesisRecursive(List<String> result, String current, int open, int close, int n) {\n+        if(current.length() == n * 2) {\n+            result.add(current);\n+            return;\n+        }\n+        \n+        if(open < n) {\n+            generateParenthesisRecursive(result, current + \"(\", open + 1, close, n);\n+        }\n+        \n+        if(close < open) {\n+            generateParenthesisRecursive(result, current + \")\", open, close + 1, n);\n+        }\n+    }\n+}\n\ndiff --git a/leetcode/string/GenerateParentheses.java b/leetcode/string/GenerateParentheses.java\n--- a/leetcode/string/GenerateParentheses.java\n+++ b/leetcode/string/GenerateParentheses.java\n@@ -0,0 +1,23 @@\n+class GenerateParentheses {\n+    public List<String> generateParenthesis(int n) {\n+        List<String> result = new ArrayList<String>();\n+        generateParenthesisRecursive(result, \"\", 0, 0, n);\n+        \n+        return result;\n+    }\n+    \n+    public void generateParenthesisRecursive(List<String> result, String current, int open, int close, int n) {\n+        if(current.length() == n * 2) {\n+            result.add(current);\n+            return;\n+        }\n+        \n+        if(open < n) {\n+            generateParenthesisRecursive(result, current + \"(\", open + 1, close, n);\n+        }\n+        \n+        if(close < open) {\n+            generateParenthesisRecursive(result, current + \")\", open, close + 1, n);\n+        }\n+    }\n+}",
    "output": "Add GenerateParentheses.java"
  },
  {
    "input": "diff --git a/company/microsoft/HouseRobberII.java b/company/microsoft/HouseRobberII.java\n--- a/company/microsoft/HouseRobberII.java\n+++ b/company/microsoft/HouseRobberII.java\n@@ -0,0 +1,34 @@\n+//Note: This is an extension of House Robber. (security system is tripped if two ajacent houses are robbed)\n+//After robbing those houses on that street, the thief has found himself a new place for his thievery so that \n+//he will not get too much attention. This time, all houses at this place are arranged in a circle. That means \n+//the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the \n+//same as for those in the previous street.\n+//Given a list of non-negative integers representing the amount of money of each house, determine the maximum \n+//amount of money you can rob tonight without alerting the police.\n+\n+class HouseRobberII {\n+    public int rob(int[] nums) {\n+        if (nums.length == 0) {\n+            return 0;\n+        }\n+        if (nums.length < 2) {\n+            return nums[0];\n+        }\n+        \n+        int[] first = new int[nums.length + 1];\n+        int[] second = new int[nums.length + 1];\n+        \n+        first[0]  = 0;\n+        first[1]  = nums[0];\n+        second[0] = 0;\n+        second[1] = 0;\n+        \n+        for (int i = 2; i <= nums.length; i++) {\n+            first[i] = Math.max(first[i - 1], first[i - 2] + nums[i - 1]);\n+            second[i] = Math.max(second[i - 1], second[i - 2] + nums[i - 1]);\n+        }\n+        \n+        return Math.max(first[nums.length - 1], second[nums.length]);\n+    }\n+}\n+\n\ndiff --git a/leetcode/dynamic-programming/HouseRobberII.java b/leetcode/dynamic-programming/HouseRobberII.java\n--- a/leetcode/dynamic-programming/HouseRobberII.java\n+++ b/leetcode/dynamic-programming/HouseRobberII.java\n@@ -0,0 +1,33 @@\n+//Note: This is an extension of House Robber. (security system is tripped if two ajacent houses are robbed)\n+//After robbing those houses on that street, the thief has found himself a new place for his thievery so that \n+//he will not get too much attention. This time, all houses at this place are arranged in a circle. That means \n+//the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the \n+//same as for those in the previous street.\n+//Given a list of non-negative integers representing the amount of money of each house, determine the maximum \n+//amount of money you can rob tonight without alerting the police.\n+\n+class HouseRobberII {\n+    public int rob(int[] nums) {\n+        if (nums.length == 0) {\n+            return 0;\n+        }\n+        if (nums.length < 2) {\n+            return nums[0];\n+        }\n+        \n+        int[] first = new int[nums.length + 1];\n+        int[] second = new int[nums.length + 1];\n+        \n+        first[0]  = 0;\n+        first[1]  = nums[0];\n+        second[0] = 0;\n+        second[1] = 0;\n+        \n+        for (int i = 2; i <= nums.length; i++) {\n+            first[i] = Math.max(first[i - 1], first[i - 2] + nums[i - 1]);\n+            second[i] = Math.max(second[i - 1], second[i - 2] + nums[i - 1]);\n+        }\n+        \n+        return Math.max(first[nums.length - 1], second[nums.length]);\n+    }\n+}",
    "output": "Add HouseRobberII"
  },
  {
    "input": "diff --git a/company/microsoft/LongestIncreasingSubsequence.java b/company/microsoft/LongestIncreasingSubsequence.java\n--- a/company/microsoft/LongestIncreasingSubsequence.java\n+++ b/company/microsoft/LongestIncreasingSubsequence.java\n@@ -0,0 +1,34 @@\n+//Given an unsorted array of integers, find the length of longest increasing subsequence.\n+\n+//For example,\n+//Given [10, 9, 2, 5, 3, 7, 101, 18],\n+//The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.\n+\n+//Your algorithm should run in O(n2) complexity.\n+\n+//Follow up: Could you improve it to O(n log n) time complexity?\n+\n+class LongestIncreasingSubsequence {\n+    public int lengthOfLIS(int[] nums) {\n+        if(nums == null || nums.length < 1) {\n+            return 0;\n+        }\n+\n+        int[] dp = new int[nums.length];\n+        dp[0] = 1;\n+        \n+        int max = 1;\n+        for(int i = 1; i < dp.length; i++) {\n+            int currentMax = 0;\n+            for(int j = 0; j < i; j++) {\n+                if(nums[i] > nums[j]) {\n+                    currentMax = Math.max(currentMax, dp[j]);\n+                }\n+            }\n+            dp[i] = 1 + currentMax;\n+            max = Math.max(max, dp[i]);\n+        }\n+\n+        return max;\n+    }\n+}\n\ndiff --git a/leetcode/dynamic-programming/LongestIncreasingSubsequence.java b/leetcode/dynamic-programming/LongestIncreasingSubsequence.java\n--- a/leetcode/dynamic-programming/LongestIncreasingSubsequence.java\n+++ b/leetcode/dynamic-programming/LongestIncreasingSubsequence.java\n@@ -0,0 +1,34 @@\n+//Given an unsorted array of integers, find the length of longest increasing subsequence.\n+\n+//For example,\n+//Given [10, 9, 2, 5, 3, 7, 101, 18],\n+//The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.\n+\n+//Your algorithm should run in O(n2) complexity.\n+\n+//Follow up: Could you improve it to O(n log n) time complexity?\n+\n+class LongestIncreasingSubsequence {\n+    public int lengthOfLIS(int[] nums) {\n+        if(nums == null || nums.length < 1) {\n+            return 0;\n+        }\n+\n+        int[] dp = new int[nums.length];\n+        dp[0] = 1;\n+        \n+        int max = 1;\n+        for(int i = 1; i < dp.length; i++) {\n+            int currentMax = 0;\n+            for(int j = 0; j < i; j++) {\n+                if(nums[i] > nums[j]) {\n+                    currentMax = Math.max(currentMax, dp[j]);\n+                }\n+            }\n+            dp[i] = 1 + currentMax;\n+            max = Math.max(max, dp[i]);\n+        }\n+\n+        return max;\n+    }\n+}",
    "output": "Add LongestIncreasingSubsequence"
  },
  {
    "input": "diff --git a/leetcode/dynamic-programming/CoinChange.java b/leetcode/dynamic-programming/CoinChange.java\n--- a/leetcode/dynamic-programming/CoinChange.java\n+++ b/leetcode/dynamic-programming/CoinChange.java\n@@ -0,0 +1,45 @@\n+//You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n+\n+//Example 1:\n+//coins = [1, 2, 5], amount = 11\n+//return 3 (11 = 5 + 5 + 1)\n+\n+//Example 2:\n+//coins = [2], amount = 3\n+//return -1.\n+\n+//Note:\n+//You may assume that you have an infinite number of each kind of coin.\n+\n+class CoinChange {\n+    public int coinChange(int[] coins, int amount) {\n+        if(amount < 1) {\n+            return 0;\n+        }\n+        \n+        return coinChangeRecursive(coins, amount, new int[amount]);\n+    }\n+    \n+    public int coinChangeRecursive(int[] coins, int amount, int[] dp) {\n+        if(amount < 0) {\n+            return -1;\n+        }\n+        if(amount == 0) {\n+            return 0;\n+        }\n+        if(dp[amount - 1] != 0) {\n+            return dp[amount - 1];\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(int coin: coins) {\n+            int result = coinChangeRecursive(coins, amount - coin, dp);\n+            if(result >= 0 && result < min) {\n+                min = 1 + result;\n+            }\n+        }\n+        \n+        dp[amount - 1] = min == Integer.MAX_VALUE ? -1 : min;\n+        return dp[amount - 1];\n+    }\n+}",
    "output": "Add CoinChange"
  },
  {
    "input": "diff --git a/leetcode/array/MinimumPathSum.java b/leetcode/array/MinimumPathSum.java\n--- a/leetcode/array/MinimumPathSum.java\n+++ b/leetcode/array/MinimumPathSum.java\n@@ -0,0 +1,27 @@\n+//Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right \n+//which minimizes the sum of all numbers along its path.\n+//Note: You can only move either down or right at any point in time.\n+//Example 1:\n+//[[1,3,1],\n+ //[1,5,1],\n+ //[4,2,1]]\n+//Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.\n+\n+class MinimumPathSum {\n+    public int minPathSum(int[][] grid) {\n+        for(int i = 1; i < grid.length; i++) {\n+            grid[i][0] += grid[i - 1][0];\n+        }\n+        for(int i = 1; i < grid[0].length; i++) {\n+            grid[0][i] += grid[0][i - 1];\n+        }\n+        \n+        for(int i = 1; i < grid.length; i++) {\n+            for(int j = 1; j < grid[0].length; j++) {\n+                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n+            }\n+        }\n+        \n+        return grid[grid.length - 1][grid[0].length - 1];\n+    }\n+}\n\ndiff --git a/leetcode/dynamic-programming/MinimumPathSum.java b/leetcode/dynamic-programming/MinimumPathSum.java\n--- a/leetcode/dynamic-programming/MinimumPathSum.java\n+++ b/leetcode/dynamic-programming/MinimumPathSum.java\n@@ -0,0 +1,28 @@\n+//Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right \n+//which minimizes the sum of all numbers along its path.\n+//Note: You can only move either down or right at any point in time.\n+//Example 1:\n+//[[1,3,1],\n+ //[1,5,1],\n+ //[4,2,1]]\n+//Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.\n+\n+class MinimumPathSum {\n+    public int minPathSum(int[][] grid) {\n+        for(int i = 1; i < grid.length; i++) {\n+            grid[i][0] += grid[i - 1][0];\n+        }\n+        for(int i = 1; i < grid[0].length; i++) {\n+            grid[0][i] += grid[0][i - 1];\n+        }\n+        \n+        for(int i = 1; i < grid.length; i++) {\n+            for(int j = 1; j < grid[0].length; j++) {\n+                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n+            }\n+        }\n+        \n+        return grid[grid.length - 1][grid[0].length - 1];\n+    }\n+}\n+",
    "output": "Add MinimumPathSum"
  },
  {
    "input": "diff --git a/company/facebook/PalindromicSubstrings.java b/company/facebook/PalindromicSubstrings.java\n--- a/company/facebook/PalindromicSubstrings.java\n+++ b/company/facebook/PalindromicSubstrings.java\n@@ -0,0 +1,39 @@\n+//Given a string, your task is to count how many palindromic substrings in this string.\n+//The substrings with different start indexes or end indexes are counted as different substrings \n+//even they consist of same characters.\n+\n+//Example 1:\n+//Input: \"abc\"\n+//Output: 3\n+//Explanation: Three palindromic strings: \"a\", \"b\", \"c\".\n+//Example 2:\n+//Input: \"aaa\"\n+//Output: 6\n+//Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n+//Note:\n+//The input string length won't exceed 1000.\n+\n+class PalindromicSubstrings {\n+    int result = 0;\n+    public int countSubstrings(String s) {\n+        if(s == null || s.length() == 0) {\n+            return 0;\n+        }\n+        \n+        for(int i = 0; i < s.length(); i++) {\n+            extendPalindrome(s, i, i);\n+            extendPalindrome(s, i, i + 1);\n+        }\n+        \n+        return result;\n+    }\n+    \n+    public void extendPalindrome(String s, int left, int right) {\n+        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n+            result++;\n+            left--;\n+            right++;\n+        }\n+    }\n+}\n+\n\ndiff --git a/company/linkedin/PaintHouse.java b/company/linkedin/PaintHouse.java\n--- a/company/linkedin/PaintHouse.java\n+++ b/company/linkedin/PaintHouse.java\n@@ -0,0 +1,26 @@\n+//There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. \n+//The cost of painting each house with a certain color is different. You have to paint all the houses such \n+//that no two adjacent houses have the same color.\n+\n+//The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, \n+//costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 \n+//with color green, and so on... Find the minimum cost to paint all houses.\n+\n+//Note:\n+//All costs are positive integers.\n+\n+class PaintHouse {\n+    public int minCost(int[][] costs) {\n+        if(costs == null || costs.length == 0) {\n+            return 0;\n+        }\n+        \n+        for(int i = 1; i < costs.length; i++) {\n+            costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n+            costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n+            costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n+        }\n+        \n+        return Math.min(Math.min(costs[costs.length - 1][0], costs[costs.length - 1][1]), costs[costs.length - 1][2]);\n+    }\n+}\n\ndiff --git a/company/linkedin/PalindromicSubstrings.java b/company/linkedin/PalindromicSubstrings.java\n--- a/company/linkedin/PalindromicSubstrings.java\n+++ b/company/linkedin/PalindromicSubstrings.java\n@@ -0,0 +1,39 @@\n+//Given a string, your task is to count how many palindromic substrings in this string.\n+//The substrings with different start indexes or end indexes are counted as different substrings \n+//even they consist of same characters.\n+\n+//Example 1:\n+//Input: \"abc\"\n+//Output: 3\n+//Explanation: Three palindromic strings: \"a\", \"b\", \"c\".\n+//Example 2:\n+//Input: \"aaa\"\n+//Output: 6\n+//Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n+//Note:\n+//The input string length won't exceed 1000.\n+\n+class PalindromicSubstrings {\n+    int result = 0;\n+    public int countSubstrings(String s) {\n+        if(s == null || s.length() == 0) {\n+            return 0;\n+        }\n+        \n+        for(int i = 0; i < s.length(); i++) {\n+            extendPalindrome(s, i, i);\n+            extendPalindrome(s, i, i + 1);\n+        }\n+        \n+        return result;\n+    }\n+    \n+    public void extendPalindrome(String s, int left, int right) {\n+        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n+            result++;\n+            left--;\n+            right++;\n+        }\n+    }\n+}\n+\n\ndiff --git a/leetcode/dynamic-programming/PaintHouse.java b/leetcode/dynamic-programming/PaintHouse.java\n--- a/leetcode/dynamic-programming/PaintHouse.java\n+++ b/leetcode/dynamic-programming/PaintHouse.java\n@@ -0,0 +1,27 @@\n+//There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. \n+//The cost of painting each house with a certain color is different. You have to paint all the houses such \n+//that no two adjacent houses have the same color.\n+\n+//The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, \n+//costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 \n+//with color green, and so on... Find the minimum cost to paint all houses.\n+\n+//Note:\n+//All costs are positive integers.\n+\n+class PaintHouse {\n+    public int minCost(int[][] costs) {\n+        if(costs == null || costs.length == 0) {\n+            return 0;\n+        }\n+        \n+        for(int i = 1; i < costs.length; i++) {\n+            costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n+            costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n+            costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n+        }\n+        \n+        return Math.min(Math.min(costs[costs.length - 1][0], costs[costs.length - 1][1]), costs[costs.length - 1][2]);\n+    }\n+}\n+\n\ndiff --git a/leetcode/dynamic-programming/PalindromicSubstrings.java b/leetcode/dynamic-programming/PalindromicSubstrings.java\n--- a/leetcode/dynamic-programming/PalindromicSubstrings.java\n+++ b/leetcode/dynamic-programming/PalindromicSubstrings.java\n@@ -0,0 +1,39 @@\n+//Given a string, your task is to count how many palindromic substrings in this string.\n+//The substrings with different start indexes or end indexes are counted as different substrings \n+//even they consist of same characters.\n+\n+//Example 1:\n+//Input: \"abc\"\n+//Output: 3\n+//Explanation: Three palindromic strings: \"a\", \"b\", \"c\".\n+//Example 2:\n+//Input: \"aaa\"\n+//Output: 6\n+//Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n+//Note:\n+//The input string length won't exceed 1000.\n+\n+class PalindromicSubstrings {\n+    int result = 0;\n+    public int countSubstrings(String s) {\n+        if(s == null || s.length() == 0) {\n+            return 0;\n+        }\n+        \n+        for(int i = 0; i < s.length(); i++) {\n+            extendPalindrome(s, i, i);\n+            extendPalindrome(s, i, i + 1);\n+        }\n+        \n+        return result;\n+    }\n+    \n+    public void extendPalindrome(String s, int left, int right) {\n+        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n+            result++;\n+            left--;\n+            right++;\n+        }\n+    }\n+}\n+\n\ndiff --git a/leetcode/string/PalindromicSubstrings.java b/leetcode/string/PalindromicSubstrings.java\n--- a/leetcode/string/PalindromicSubstrings.java\n+++ b/leetcode/string/PalindromicSubstrings.java\n@@ -0,0 +1,38 @@\n+//Given a string, your task is to count how many palindromic substrings in this string.\n+//The substrings with different start indexes or end indexes are counted as different substrings \n+//even they consist of same characters.\n+\n+//Example 1:\n+//Input: \"abc\"\n+//Output: 3\n+//Explanation: Three palindromic strings: \"a\", \"b\", \"c\".\n+//Example 2:\n+//Input: \"aaa\"\n+//Output: 6\n+//Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n+//Note:\n+//The input string length won't exceed 1000.\n+\n+class PalindromicSubstrings {\n+    int result = 0;\n+    public int countSubstrings(String s) {\n+        if(s == null || s.length() == 0) {\n+            return 0;\n+        }\n+        \n+        for(int i = 0; i < s.length(); i++) {\n+            extendPalindrome(s, i, i);\n+            extendPalindrome(s, i, i + 1);\n+        }\n+        \n+        return result;\n+    }\n+    \n+    public void extendPalindrome(String s, int left, int right) {\n+        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n+            result++;\n+            left--;\n+            right++;\n+        }\n+    }\n+}",
    "output": "Add PalindromicSubstrings and PaintHouse"
  },
  {
    "input": "diff --git a/company/amazon/MinCostClimbingStairs.java b/company/amazon/MinCostClimbingStairs.java\n--- a/company/amazon/MinCostClimbingStairs.java\n+++ b/company/amazon/MinCostClimbingStairs.java\n@@ -0,0 +1,38 @@\n+//On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).\n+//\n+//Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\n+//\n+//Example 1:\n+//Input: cost = [10, 15, 20]\n+//Output: 15\n+//Explanation: Cheapest is start on cost[1], pay that cost and go to the top.\n+//Example 2:\n+//Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n+//Output: 6\n+//Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].\n+//Note:\n+//cost will have a length in the range [2, 1000].\n+//Every cost[i] will be an integer in the range [0, 999].\n+\n+class MinCostClimbingStairs {\n+    public int minCostClimbingStairs(int[] cost) {\n+        if(cost == null || cost.length == 0) {\n+            return 0;\n+        }\n+        if(cost.length == 1) {\n+            return cost[0];\n+        }\n+        if(cost.length == 2) {\n+            return Math.min(cost[0], cost[1]);\n+        }\n+        \n+        int[] dp = new int[cost.length];\n+        dp[0] = cost[0];\n+        dp[1] = cost[1];\n+        for(int i = 2; i < cost.length; i++) {\n+            dp[i] = Math.min(dp[i - 1] + cost[i], dp[i - 2] + cost[i]);\n+        }\n+        \n+        return Math.min(dp[cost.length - 1], dp[cost.length -2]);\n+    }\n+}\n\ndiff --git a/leetcode/array/MinCostClimbingStairs.java b/leetcode/array/MinCostClimbingStairs.java\n--- a/leetcode/array/MinCostClimbingStairs.java\n+++ b/leetcode/array/MinCostClimbingStairs.java\n@@ -0,0 +1,39 @@\n+//On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).\n+//\n+//Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\n+//\n+//Example 1:\n+//Input: cost = [10, 15, 20]\n+//Output: 15\n+//Explanation: Cheapest is start on cost[1], pay that cost and go to the top.\n+//Example 2:\n+//Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n+//Output: 6\n+//Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].\n+//Note:\n+//cost will have a length in the range [2, 1000].\n+//Every cost[i] will be an integer in the range [0, 999].\n+\n+class MinCostClimbingStairs {\n+    public int minCostClimbingStairs(int[] cost) {\n+        if(cost == null || cost.length == 0) {\n+            return 0;\n+        }\n+        if(cost.length == 1) {\n+            return cost[0];\n+        }\n+        if(cost.length == 2) {\n+            return Math.min(cost[0], cost[1]);\n+        }\n+        \n+        int[] dp = new int[cost.length];\n+        dp[0] = cost[0];\n+        dp[1] = cost[1];\n+        for(int i = 2; i < cost.length; i++) {\n+            dp[i] = Math.min(dp[i - 1] + cost[i], dp[i - 2] + cost[i]);\n+        }\n+        \n+        return Math.min(dp[cost.length - 1], dp[cost.length -2]);\n+    }\n+}\n+\n\ndiff --git a/leetcode/dynamic-programming/MinCostClimbingStairs.java b/leetcode/dynamic-programming/MinCostClimbingStairs.java\n--- a/leetcode/dynamic-programming/MinCostClimbingStairs.java\n+++ b/leetcode/dynamic-programming/MinCostClimbingStairs.java\n@@ -0,0 +1,39 @@\n+//On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).\n+//\n+//Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\n+//\n+//Example 1:\n+//Input: cost = [10, 15, 20]\n+//Output: 15\n+//Explanation: Cheapest is start on cost[1], pay that cost and go to the top.\n+//Example 2:\n+//Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n+//Output: 6\n+//Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].\n+//Note:\n+//cost will have a length in the range [2, 1000].\n+//Every cost[i] will be an integer in the range [0, 999].\n+\n+class MinCostClimbingStairs {\n+    public int minCostClimbingStairs(int[] cost) {\n+        if(cost == null || cost.length == 0) {\n+            return 0;\n+        }\n+        if(cost.length == 1) {\n+            return cost[0];\n+        }\n+        if(cost.length == 2) {\n+            return Math.min(cost[0], cost[1]);\n+        }\n+        \n+        int[] dp = new int[cost.length];\n+        dp[0] = cost[0];\n+        dp[1] = cost[1];\n+        for(int i = 2; i < cost.length; i++) {\n+            dp[i] = Math.min(dp[i - 1] + cost[i], dp[i - 2] + cost[i]);\n+        }\n+        \n+        return Math.min(dp[cost.length - 1], dp[cost.length -2]);\n+    }\n+}\n+",
    "output": "Add MinCostClimbingStairs"
  },
  {
    "input": "diff --git a/company/apple/ValidSudoku.java b/company/apple/ValidSudoku.java\n--- a/company/apple/ValidSudoku.java\n+++ b/company/apple/ValidSudoku.java\n@@ -0,0 +1,31 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n+\n\ndiff --git a/company/snapchat/ValidSudoku.java b/company/snapchat/ValidSudoku.java\n--- a/company/snapchat/ValidSudoku.java\n+++ b/company/snapchat/ValidSudoku.java\n@@ -0,0 +1,31 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n+\n\ndiff --git a/company/uber/ValidSudoku.java b/company/uber/ValidSudoku.java\n--- a/company/uber/ValidSudoku.java\n+++ b/company/uber/ValidSudoku.java\n@@ -0,0 +1,30 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n\ndiff --git a/leetcode/hash-table/ValidSudoku.java b/leetcode/hash-table/ValidSudoku.java\n--- a/leetcode/hash-table/ValidSudoku.java\n+++ b/leetcode/hash-table/ValidSudoku.java\n@@ -0,0 +1,31 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n+",
    "output": "Add valid sudoku"
  },
  {
    "input": "diff --git a/company/bloomberg/UniquePaths.java b/company/bloomberg/UniquePaths.java\n--- a/company/bloomberg/UniquePaths.java\n+++ b/company/bloomberg/UniquePaths.java\n@@ -0,0 +1,33 @@\n+//A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n+//\n+//The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n+//\n+//How many possible unique paths are there?\n+\n+class UniquePaths {\n+    public int uniquePaths(int m, int n) {\n+        Integer[][] map = new Integer[m][n];\n+        \n+        //only 1 way to get to ith row, 0th column (move down)\n+        for(int i = 0; i < m; i++){\n+            map[i][0] = 1;\n+        }\n+        \n+        //only 1 way to get to ith column, 0th row (move right)\n+        for(int j= 0; j < n; j++){\n+            map[0][j]=1;\n+        }\n+        \n+        //x ways to get to ith row, jth column (# of ways to get to\n+        //ith - 1 row, jth column + # of ways to get to jth - 1 column\n+        //ith column\n+        for(int i = 1;i < m; i++){\n+            for(int j = 1; j < n; j++){\n+                map[i][j] = map[i - 1][j] + map[i][j - 1];\n+            }\n+        }\n+\n+        return map[m - 1][n - 1];\n+    }\n+}\n+\n\ndiff --git a/company/linkedin/Permutations.java b/company/linkedin/Permutations.java\n--- a/company/linkedin/Permutations.java\n+++ b/company/linkedin/Permutations.java\n@@ -0,0 +1,34 @@\n+//Given a collection of distinct numbers, return all possible permutations.\n+//\n+//For example,\n+//[1,2,3] have the following permutations:\n+//[\n+  //[1,2,3],\n+  //[1,3,2],\n+  //[2,1,3],\n+  //[2,3,1],\n+  //[3,1,2],\n+  //[3,2,1]\n+//]\n+\n+class Permutations {\n+    public List<List<Integer>> permute(int[] nums) {\n+        LinkedList<List<Integer>> result = new LinkedList<List<Integer>>();\n+        result.add(new ArrayList<Integer>());\n+        for (int n: nums) {\n+            int size = result.size();\n+            while(size > 0) {\n+                List<Integer> current = result.pollFirst();\n+                for (int i = 0; i <= current.size(); i++) {\n+                    List<Integer> temp = new ArrayList<Integer>(current);\n+                    temp.add(i, n);\n+                    result.add(temp);\n+                }\n+                size--;\n+            }\n+        }\n+\n+        return result;\n+    }\n+}\n+\n\ndiff --git a/company/microsoft/Permutations.java b/company/microsoft/Permutations.java\n--- a/company/microsoft/Permutations.java\n+++ b/company/microsoft/Permutations.java\n@@ -0,0 +1,34 @@\n+//Given a collection of distinct numbers, return all possible permutations.\n+//\n+//For example,\n+//[1,2,3] have the following permutations:\n+//[\n+  //[1,2,3],\n+  //[1,3,2],\n+  //[2,1,3],\n+  //[2,3,1],\n+  //[3,1,2],\n+  //[3,2,1]\n+//]\n+\n+class Permutations {\n+    public List<List<Integer>> permute(int[] nums) {\n+        LinkedList<List<Integer>> result = new LinkedList<List<Integer>>();\n+        result.add(new ArrayList<Integer>());\n+        for (int n: nums) {\n+            int size = result.size();\n+            while(size > 0) {\n+                List<Integer> current = result.pollFirst();\n+                for (int i = 0; i <= current.size(); i++) {\n+                    List<Integer> temp = new ArrayList<Integer>(current);\n+                    temp.add(i, n);\n+                    result.add(temp);\n+                }\n+                size--;\n+            }\n+        }\n+\n+        return result;\n+    }\n+}\n+\n\ndiff --git a/leetcode/array/UniquePaths.java b/leetcode/array/UniquePaths.java\n--- a/leetcode/array/UniquePaths.java\n+++ b/leetcode/array/UniquePaths.java\n@@ -0,0 +1,32 @@\n+//A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n+//\n+//The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n+//\n+//How many possible unique paths are there?\n+\n+class UniquePaths {\n+    public int uniquePaths(int m, int n) {\n+        Integer[][] map = new Integer[m][n];\n+        \n+        //only 1 way to get to ith row, 0th column (move down)\n+        for(int i = 0; i < m; i++){\n+            map[i][0] = 1;\n+        }\n+        \n+        //only 1 way to get to ith column, 0th row (move right)\n+        for(int j= 0; j < n; j++){\n+            map[0][j]=1;\n+        }\n+        \n+        //x ways to get to ith row, jth column (# of ways to get to\n+        //ith - 1 row, jth column + # of ways to get to jth - 1 column\n+        //ith column\n+        for(int i = 1;i < m; i++){\n+            for(int j = 1; j < n; j++){\n+                map[i][j] = map[i - 1][j] + map[i][j - 1];\n+            }\n+        }\n+\n+        return map[m - 1][n - 1];\n+    }\n+}\n\ndiff --git a/leetcode/backtracking/Permutations.java b/leetcode/backtracking/Permutations.java\n--- a/leetcode/backtracking/Permutations.java\n+++ b/leetcode/backtracking/Permutations.java\n@@ -0,0 +1,33 @@\n+//Given a collection of distinct numbers, return all possible permutations.\n+//\n+//For example,\n+//[1,2,3] have the following permutations:\n+//[\n+  //[1,2,3],\n+  //[1,3,2],\n+  //[2,1,3],\n+  //[2,3,1],\n+  //[3,1,2],\n+  //[3,2,1]\n+//]\n+\n+class Permutations {\n+    public List<List<Integer>> permute(int[] nums) {\n+        LinkedList<List<Integer>> result = new LinkedList<List<Integer>>();\n+        result.add(new ArrayList<Integer>());\n+        for (int n: nums) {\n+            int size = result.size();\n+            while(size > 0) {\n+                List<Integer> current = result.pollFirst();\n+                for (int i = 0; i <= current.size(); i++) {\n+                    List<Integer> temp = new ArrayList<Integer>(current);\n+                    temp.add(i, n);\n+                    result.add(temp);\n+                }\n+                size--;\n+            }\n+        }\n+\n+        return result;\n+    }\n+}\n\ndiff --git a/leetcode/dynamic-programming/UniquePaths.java b/leetcode/dynamic-programming/UniquePaths.java\n--- a/leetcode/dynamic-programming/UniquePaths.java\n+++ b/leetcode/dynamic-programming/UniquePaths.java\n@@ -0,0 +1,33 @@\n+//A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n+//\n+//The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n+//\n+//How many possible unique paths are there?\n+\n+class UniquePaths {\n+    public int uniquePaths(int m, int n) {\n+        Integer[][] map = new Integer[m][n];\n+        \n+        //only 1 way to get to ith row, 0th column (move down)\n+        for(int i = 0; i < m; i++){\n+            map[i][0] = 1;\n+        }\n+        \n+        //only 1 way to get to ith column, 0th row (move right)\n+        for(int j= 0; j < n; j++){\n+            map[0][j]=1;\n+        }\n+        \n+        //x ways to get to ith row, jth column (# of ways to get to\n+        //ith - 1 row, jth column + # of ways to get to jth - 1 column\n+        //ith column\n+        for(int i = 1;i < m; i++){\n+            for(int j = 1; j < n; j++){\n+                map[i][j] = map[i - 1][j] + map[i][j - 1];\n+            }\n+        }\n+\n+        return map[m - 1][n - 1];\n+    }\n+}\n+",
    "output": "Add additional problems"
  },
  {
    "input": "diff --git a/leetcode/brainteaser/BulbSwitcher.java b/leetcode/brainteaser/BulbSwitcher.java\n--- a/leetcode/brainteaser/BulbSwitcher.java\n+++ b/leetcode/brainteaser/BulbSwitcher.java\n@@ -0,0 +1,17 @@\n+//There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\n+//Example:\n+//Given n = 3. \n+\n+//At first, the three bulbs are [off, off, off].\n+//After first round, the three bulbs are [on, on, on].\n+//After second round, the three bulbs are [on, off, on].\n+//After third round, the three bulbs are [on, off, off]. \n+\n+//So you should return 1, because there is only one bulb is on.\n+\n+class BulbSwitcher {\n+    public int bulbSwitch(int n) {\n+        return (int)Math.sqrt(n);\n+    }\n+}\n+\n\ndiff --git a/leetcode/math/BulbSwitcher.java b/leetcode/math/BulbSwitcher.java\n--- a/leetcode/math/BulbSwitcher.java\n+++ b/leetcode/math/BulbSwitcher.java\n@@ -0,0 +1,16 @@\n+//There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\n+//Example:\n+//Given n = 3. \n+\n+//At first, the three bulbs are [off, off, off].\n+//After first round, the three bulbs are [on, on, on].\n+//After second round, the three bulbs are [on, off, on].\n+//After third round, the three bulbs are [on, off, off]. \n+\n+//So you should return 1, because there is only one bulb is on.\n+\n+class BulbSwitcher {\n+    public int bulbSwitch(int n) {\n+        return (int)Math.sqrt(n);\n+    }\n+}",
    "output": "Add brainteaser directory"
  },
  {
    "input": "diff --git a/company/airbnb/ContainsDuplicate.java b/company/airbnb/ContainsDuplicate.java\n--- a/company/airbnb/ContainsDuplicate.java\n+++ b/company/airbnb/ContainsDuplicate.java\n@@ -0,0 +1,18 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}\n+\n\ndiff --git a/company/palantir/ContainsDuplicate.java b/company/palantir/ContainsDuplicate.java\n--- a/company/palantir/ContainsDuplicate.java\n+++ b/company/palantir/ContainsDuplicate.java\n@@ -0,0 +1,18 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}\n+\n\ndiff --git a/company/yahoo/ContainsDuplicate.java b/company/yahoo/ContainsDuplicate.java\n--- a/company/yahoo/ContainsDuplicate.java\n+++ b/company/yahoo/ContainsDuplicate.java\n@@ -0,0 +1,18 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}\n+\n\ndiff --git a/leetcode/hash-table/ContainsDuplicate.java b/leetcode/hash-table/ContainsDuplicate.java\n--- a/leetcode/hash-table/ContainsDuplicate.java\n+++ b/leetcode/hash-table/ContainsDuplicate.java\n@@ -0,0 +1,17 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}",
    "output": "Add yahoo and palantir directories"
  },
  {
    "input": "diff --git a/company/apple/ReverseWordsInAString.java b/company/apple/ReverseWordsInAString.java\n--- a/company/apple/ReverseWordsInAString.java\n+++ b/company/apple/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/bloomberg/ReverseWordsInAString.java b/company/bloomberg/ReverseWordsInAString.java\n--- a/company/bloomberg/ReverseWordsInAString.java\n+++ b/company/bloomberg/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/microsoft/ReverseWordsInAString.java b/company/microsoft/ReverseWordsInAString.java\n--- a/company/microsoft/ReverseWordsInAString.java\n+++ b/company/microsoft/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/snapchat/ReverseWordsInAString.java b/company/snapchat/ReverseWordsInAString.java\n--- a/company/snapchat/ReverseWordsInAString.java\n+++ b/company/snapchat/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/yelp/ReverseWordsInAString.java b/company/yelp/ReverseWordsInAString.java\n--- a/company/yelp/ReverseWordsInAString.java\n+++ b/company/yelp/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/leetcode/string/ReverseWordsInAString.java b/leetcode/string/ReverseWordsInAString.java\n--- a/leetcode/string/ReverseWordsInAString.java\n+++ b/leetcode/string/ReverseWordsInAString.java\n@@ -0,0 +1,16 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}",
    "output": "Add directories for snapchat, yelp, and apple"
  },
  {
    "input": "diff --git a/company/adobe/MajorityElement.java b/company/adobe/MajorityElement.java\n--- a/company/adobe/MajorityElement.java\n+++ b/company/adobe/MajorityElement.java\n@@ -0,0 +1,24 @@\n+//Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n+//You may assume that the array is non-empty and the majority element always exist in the array.\n+\n+class MajorityElement {\n+    public int majorityElement(int[] nums) {\n+        if(nums.length == 1) {\n+            return nums[0];\n+        }\n+        \n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int current: nums) {\n+            if(map.containsKey(current) && map.get(current) + 1 > nums.length / 2) {\n+                return current;\n+            } else if(map.containsKey(current)) {\n+                map.put(current, map.get(current) + 1);\n+            } else {\n+                map.put(current, 1);\n+            }\n+        }\n+        \n+        //no majority element exists\n+        return -1;\n+    }\n+}\n\ndiff --git a/leetcode/array/MajorityElement.java b/leetcode/array/MajorityElement.java\n--- a/leetcode/array/MajorityElement.java\n+++ b/leetcode/array/MajorityElement.java\n@@ -0,0 +1,24 @@\n+//Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n+//You may assume that the array is non-empty and the majority element always exist in the array.\n+\n+class MajorityElement {\n+    public int majorityElement(int[] nums) {\n+        if(nums.length == 1) {\n+            return nums[0];\n+        }\n+        \n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int current: nums) {\n+            if(map.containsKey(current) && map.get(current) + 1 > nums.length / 2) {\n+                return current;\n+            } else if(map.containsKey(current)) {\n+                map.put(current, map.get(current) + 1);\n+            } else {\n+                map.put(current, 1);\n+            }\n+        }\n+        \n+        //no majority element exists\n+        return -1;\n+    }\n+}",
    "output": "Add adobe directory"
  },
  {
    "input": "diff --git a/company/apple/ValidSudoku.java b/company/apple/ValidSudoku.java\n--- a/company/apple/ValidSudoku.java\n+++ b/company/apple/ValidSudoku.java\n@@ -0,0 +1,31 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n+\n\ndiff --git a/company/snapchat/ValidSudoku.java b/company/snapchat/ValidSudoku.java\n--- a/company/snapchat/ValidSudoku.java\n+++ b/company/snapchat/ValidSudoku.java\n@@ -0,0 +1,31 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n+\n\ndiff --git a/company/uber/ValidSudoku.java b/company/uber/ValidSudoku.java\n--- a/company/uber/ValidSudoku.java\n+++ b/company/uber/ValidSudoku.java\n@@ -0,0 +1,30 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n\ndiff --git a/leetcode/hash-table/ValidSudoku.java b/leetcode/hash-table/ValidSudoku.java\n--- a/leetcode/hash-table/ValidSudoku.java\n+++ b/leetcode/hash-table/ValidSudoku.java\n@@ -0,0 +1,31 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n+",
    "output": "Add valid sudoku"
  },
  {
    "input": "diff --git a/company/bloomberg/UniquePaths.java b/company/bloomberg/UniquePaths.java\n--- a/company/bloomberg/UniquePaths.java\n+++ b/company/bloomberg/UniquePaths.java\n@@ -0,0 +1,33 @@\n+//A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n+//\n+//The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n+//\n+//How many possible unique paths are there?\n+\n+class UniquePaths {\n+    public int uniquePaths(int m, int n) {\n+        Integer[][] map = new Integer[m][n];\n+        \n+        //only 1 way to get to ith row, 0th column (move down)\n+        for(int i = 0; i < m; i++){\n+            map[i][0] = 1;\n+        }\n+        \n+        //only 1 way to get to ith column, 0th row (move right)\n+        for(int j= 0; j < n; j++){\n+            map[0][j]=1;\n+        }\n+        \n+        //x ways to get to ith row, jth column (# of ways to get to\n+        //ith - 1 row, jth column + # of ways to get to jth - 1 column\n+        //ith column\n+        for(int i = 1;i < m; i++){\n+            for(int j = 1; j < n; j++){\n+                map[i][j] = map[i - 1][j] + map[i][j - 1];\n+            }\n+        }\n+\n+        return map[m - 1][n - 1];\n+    }\n+}\n+\n\ndiff --git a/company/linkedin/Permutations.java b/company/linkedin/Permutations.java\n--- a/company/linkedin/Permutations.java\n+++ b/company/linkedin/Permutations.java\n@@ -0,0 +1,34 @@\n+//Given a collection of distinct numbers, return all possible permutations.\n+//\n+//For example,\n+//[1,2,3] have the following permutations:\n+//[\n+  //[1,2,3],\n+  //[1,3,2],\n+  //[2,1,3],\n+  //[2,3,1],\n+  //[3,1,2],\n+  //[3,2,1]\n+//]\n+\n+class Permutations {\n+    public List<List<Integer>> permute(int[] nums) {\n+        LinkedList<List<Integer>> result = new LinkedList<List<Integer>>();\n+        result.add(new ArrayList<Integer>());\n+        for (int n: nums) {\n+            int size = result.size();\n+            while(size > 0) {\n+                List<Integer> current = result.pollFirst();\n+                for (int i = 0; i <= current.size(); i++) {\n+                    List<Integer> temp = new ArrayList<Integer>(current);\n+                    temp.add(i, n);\n+                    result.add(temp);\n+                }\n+                size--;\n+            }\n+        }\n+\n+        return result;\n+    }\n+}\n+\n\ndiff --git a/company/microsoft/Permutations.java b/company/microsoft/Permutations.java\n--- a/company/microsoft/Permutations.java\n+++ b/company/microsoft/Permutations.java\n@@ -0,0 +1,34 @@\n+//Given a collection of distinct numbers, return all possible permutations.\n+//\n+//For example,\n+//[1,2,3] have the following permutations:\n+//[\n+  //[1,2,3],\n+  //[1,3,2],\n+  //[2,1,3],\n+  //[2,3,1],\n+  //[3,1,2],\n+  //[3,2,1]\n+//]\n+\n+class Permutations {\n+    public List<List<Integer>> permute(int[] nums) {\n+        LinkedList<List<Integer>> result = new LinkedList<List<Integer>>();\n+        result.add(new ArrayList<Integer>());\n+        for (int n: nums) {\n+            int size = result.size();\n+            while(size > 0) {\n+                List<Integer> current = result.pollFirst();\n+                for (int i = 0; i <= current.size(); i++) {\n+                    List<Integer> temp = new ArrayList<Integer>(current);\n+                    temp.add(i, n);\n+                    result.add(temp);\n+                }\n+                size--;\n+            }\n+        }\n+\n+        return result;\n+    }\n+}\n+\n\ndiff --git a/leetcode/array/UniquePaths.java b/leetcode/array/UniquePaths.java\n--- a/leetcode/array/UniquePaths.java\n+++ b/leetcode/array/UniquePaths.java\n@@ -0,0 +1,32 @@\n+//A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n+//\n+//The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n+//\n+//How many possible unique paths are there?\n+\n+class UniquePaths {\n+    public int uniquePaths(int m, int n) {\n+        Integer[][] map = new Integer[m][n];\n+        \n+        //only 1 way to get to ith row, 0th column (move down)\n+        for(int i = 0; i < m; i++){\n+            map[i][0] = 1;\n+        }\n+        \n+        //only 1 way to get to ith column, 0th row (move right)\n+        for(int j= 0; j < n; j++){\n+            map[0][j]=1;\n+        }\n+        \n+        //x ways to get to ith row, jth column (# of ways to get to\n+        //ith - 1 row, jth column + # of ways to get to jth - 1 column\n+        //ith column\n+        for(int i = 1;i < m; i++){\n+            for(int j = 1; j < n; j++){\n+                map[i][j] = map[i - 1][j] + map[i][j - 1];\n+            }\n+        }\n+\n+        return map[m - 1][n - 1];\n+    }\n+}\n\ndiff --git a/leetcode/backtracking/Permutations.java b/leetcode/backtracking/Permutations.java\n--- a/leetcode/backtracking/Permutations.java\n+++ b/leetcode/backtracking/Permutations.java\n@@ -0,0 +1,33 @@\n+//Given a collection of distinct numbers, return all possible permutations.\n+//\n+//For example,\n+//[1,2,3] have the following permutations:\n+//[\n+  //[1,2,3],\n+  //[1,3,2],\n+  //[2,1,3],\n+  //[2,3,1],\n+  //[3,1,2],\n+  //[3,2,1]\n+//]\n+\n+class Permutations {\n+    public List<List<Integer>> permute(int[] nums) {\n+        LinkedList<List<Integer>> result = new LinkedList<List<Integer>>();\n+        result.add(new ArrayList<Integer>());\n+        for (int n: nums) {\n+            int size = result.size();\n+            while(size > 0) {\n+                List<Integer> current = result.pollFirst();\n+                for (int i = 0; i <= current.size(); i++) {\n+                    List<Integer> temp = new ArrayList<Integer>(current);\n+                    temp.add(i, n);\n+                    result.add(temp);\n+                }\n+                size--;\n+            }\n+        }\n+\n+        return result;\n+    }\n+}\n\ndiff --git a/leetcode/dynamic-programming/UniquePaths.java b/leetcode/dynamic-programming/UniquePaths.java\n--- a/leetcode/dynamic-programming/UniquePaths.java\n+++ b/leetcode/dynamic-programming/UniquePaths.java\n@@ -0,0 +1,33 @@\n+//A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n+//\n+//The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n+//\n+//How many possible unique paths are there?\n+\n+class UniquePaths {\n+    public int uniquePaths(int m, int n) {\n+        Integer[][] map = new Integer[m][n];\n+        \n+        //only 1 way to get to ith row, 0th column (move down)\n+        for(int i = 0; i < m; i++){\n+            map[i][0] = 1;\n+        }\n+        \n+        //only 1 way to get to ith column, 0th row (move right)\n+        for(int j= 0; j < n; j++){\n+            map[0][j]=1;\n+        }\n+        \n+        //x ways to get to ith row, jth column (# of ways to get to\n+        //ith - 1 row, jth column + # of ways to get to jth - 1 column\n+        //ith column\n+        for(int i = 1;i < m; i++){\n+            for(int j = 1; j < n; j++){\n+                map[i][j] = map[i - 1][j] + map[i][j - 1];\n+            }\n+        }\n+\n+        return map[m - 1][n - 1];\n+    }\n+}\n+",
    "output": "Add additional problems"
  },
  {
    "input": "diff --git a/leetcode/brainteaser/BulbSwitcher.java b/leetcode/brainteaser/BulbSwitcher.java\n--- a/leetcode/brainteaser/BulbSwitcher.java\n+++ b/leetcode/brainteaser/BulbSwitcher.java\n@@ -0,0 +1,17 @@\n+//There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\n+//Example:\n+//Given n = 3. \n+\n+//At first, the three bulbs are [off, off, off].\n+//After first round, the three bulbs are [on, on, on].\n+//After second round, the three bulbs are [on, off, on].\n+//After third round, the three bulbs are [on, off, off]. \n+\n+//So you should return 1, because there is only one bulb is on.\n+\n+class BulbSwitcher {\n+    public int bulbSwitch(int n) {\n+        return (int)Math.sqrt(n);\n+    }\n+}\n+\n\ndiff --git a/leetcode/math/BulbSwitcher.java b/leetcode/math/BulbSwitcher.java\n--- a/leetcode/math/BulbSwitcher.java\n+++ b/leetcode/math/BulbSwitcher.java\n@@ -0,0 +1,16 @@\n+//There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\n+//Example:\n+//Given n = 3. \n+\n+//At first, the three bulbs are [off, off, off].\n+//After first round, the three bulbs are [on, on, on].\n+//After second round, the three bulbs are [on, off, on].\n+//After third round, the three bulbs are [on, off, off]. \n+\n+//So you should return 1, because there is only one bulb is on.\n+\n+class BulbSwitcher {\n+    public int bulbSwitch(int n) {\n+        return (int)Math.sqrt(n);\n+    }\n+}",
    "output": "Add brainteaser directory"
  },
  {
    "input": "diff --git a/company/airbnb/ContainsDuplicate.java b/company/airbnb/ContainsDuplicate.java\n--- a/company/airbnb/ContainsDuplicate.java\n+++ b/company/airbnb/ContainsDuplicate.java\n@@ -0,0 +1,18 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}\n+\n\ndiff --git a/company/palantir/ContainsDuplicate.java b/company/palantir/ContainsDuplicate.java\n--- a/company/palantir/ContainsDuplicate.java\n+++ b/company/palantir/ContainsDuplicate.java\n@@ -0,0 +1,18 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}\n+\n\ndiff --git a/company/yahoo/ContainsDuplicate.java b/company/yahoo/ContainsDuplicate.java\n--- a/company/yahoo/ContainsDuplicate.java\n+++ b/company/yahoo/ContainsDuplicate.java\n@@ -0,0 +1,18 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}\n+\n\ndiff --git a/leetcode/hash-table/ContainsDuplicate.java b/leetcode/hash-table/ContainsDuplicate.java\n--- a/leetcode/hash-table/ContainsDuplicate.java\n+++ b/leetcode/hash-table/ContainsDuplicate.java\n@@ -0,0 +1,17 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}",
    "output": "Add yahoo and palantir directories"
  },
  {
    "input": "diff --git a/company/apple/ReverseWordsInAString.java b/company/apple/ReverseWordsInAString.java\n--- a/company/apple/ReverseWordsInAString.java\n+++ b/company/apple/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/bloomberg/ReverseWordsInAString.java b/company/bloomberg/ReverseWordsInAString.java\n--- a/company/bloomberg/ReverseWordsInAString.java\n+++ b/company/bloomberg/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/microsoft/ReverseWordsInAString.java b/company/microsoft/ReverseWordsInAString.java\n--- a/company/microsoft/ReverseWordsInAString.java\n+++ b/company/microsoft/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/snapchat/ReverseWordsInAString.java b/company/snapchat/ReverseWordsInAString.java\n--- a/company/snapchat/ReverseWordsInAString.java\n+++ b/company/snapchat/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/yelp/ReverseWordsInAString.java b/company/yelp/ReverseWordsInAString.java\n--- a/company/yelp/ReverseWordsInAString.java\n+++ b/company/yelp/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/leetcode/string/ReverseWordsInAString.java b/leetcode/string/ReverseWordsInAString.java\n--- a/leetcode/string/ReverseWordsInAString.java\n+++ b/leetcode/string/ReverseWordsInAString.java\n@@ -0,0 +1,16 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}",
    "output": "Add directories for snapchat, yelp, and apple"
  },
  {
    "input": "diff --git a/company/adobe/MajorityElement.java b/company/adobe/MajorityElement.java\n--- a/company/adobe/MajorityElement.java\n+++ b/company/adobe/MajorityElement.java\n@@ -0,0 +1,24 @@\n+//Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n+//You may assume that the array is non-empty and the majority element always exist in the array.\n+\n+class MajorityElement {\n+    public int majorityElement(int[] nums) {\n+        if(nums.length == 1) {\n+            return nums[0];\n+        }\n+        \n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int current: nums) {\n+            if(map.containsKey(current) && map.get(current) + 1 > nums.length / 2) {\n+                return current;\n+            } else if(map.containsKey(current)) {\n+                map.put(current, map.get(current) + 1);\n+            } else {\n+                map.put(current, 1);\n+            }\n+        }\n+        \n+        //no majority element exists\n+        return -1;\n+    }\n+}\n\ndiff --git a/leetcode/array/MajorityElement.java b/leetcode/array/MajorityElement.java\n--- a/leetcode/array/MajorityElement.java\n+++ b/leetcode/array/MajorityElement.java\n@@ -0,0 +1,24 @@\n+//Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n+//You may assume that the array is non-empty and the majority element always exist in the array.\n+\n+class MajorityElement {\n+    public int majorityElement(int[] nums) {\n+        if(nums.length == 1) {\n+            return nums[0];\n+        }\n+        \n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int current: nums) {\n+            if(map.containsKey(current) && map.get(current) + 1 > nums.length / 2) {\n+                return current;\n+            } else if(map.containsKey(current)) {\n+                map.put(current, map.get(current) + 1);\n+            } else {\n+                map.put(current, 1);\n+            }\n+        }\n+        \n+        //no majority element exists\n+        return -1;\n+    }\n+}",
    "output": "Add adobe directory"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/IsUniqueChars.java b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/IsUniqueChars.java\n--- a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/IsUniqueChars.java\n+++ b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/IsUniqueChars.java\n@@ -1,15 +1,15 @@\n //Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?\n \n-public class isUniqueChars {\n+public class IsUniqueChars {\n     public boolean isUniqueChars(String str) {\n         int checker = 0;\n         for(int i = 0; i < str.length(); i++) {\n             int val = str.charAt(i) - 'a';\n             if((checker & (1 << val)) > 0) {\n                 return false;\n             }\n-            checker |= (1 << val));\n+            checker |= (1 << val);\n         }\n         return true;\n     }\n-}\n\\ No newline at end of file\n+}\n\ndiff --git a/CrackingTheCodingInterview/Chapter3StacksAndQueues/SortStack.java b/CrackingTheCodingInterview/Chapter3StacksAndQueues/SortStack.java\n--- a/CrackingTheCodingInterview/Chapter3StacksAndQueues/SortStack.java\n+++ b/CrackingTheCodingInterview/Chapter3StacksAndQueues/SortStack.java\n@@ -11,8 +11,8 @@ public static Stack<Integer> sort(Stack<Integer> s) {\n \t\t\twhile(!r.isEmpty() && r.peek() > tmp) { //step 2\n \t\t\t\ts.push(r.pop());\n \t\t\t}\n-\t\t\tr.push(tmp) //step 3\n+\t\t\tr.push(tmp); //step 3\n \t\t}\n \t\treturn r;\n \t}\n-}\n\\ No newline at end of file\n+}\n\ndiff --git a/CrackingTheCodingInterview/Chapter3StacksAndQueues/TowersOfHanoi.java b/CrackingTheCodingInterview/Chapter3StacksAndQueues/TowersOfHanoi.java\n--- a/CrackingTheCodingInterview/Chapter3StacksAndQueues/TowersOfHanoi.java\n+++ b/CrackingTheCodingInterview/Chapter3StacksAndQueues/TowersOfHanoi.java\n@@ -39,7 +39,7 @@ public void add(int d) {\n \t\t\tSystem.out.println(\"Error placing disk \" + d);\n \t\t}\n \t\telse {\n-\t\t\tdisks.push(d):\n+\t\t\tdisks.push(d);\n \t\t}\n \t}\n \n@@ -56,4 +56,4 @@ public void moveDisks(int n, Tower destination, Tower buffer) {\n \t\t\tbuffer.moveDisks(n - 1, destination, this);\n \t\t}\n \t}\n-}\n\\ No newline at end of file\n+}",
    "output": "Fix syntax errors"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/ReplaceSpaces.java b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/ReplaceSpaces.java\n--- a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/ReplaceSpaces.java\n+++ b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/ReplaceSpaces.java\n@@ -1,11 +1,11 @@\n-// Write a method to replace all spaces in a string with '%20.' You may assum ethat the string\n-// has sufficient space at th eend of the string to hold the additional characters, and that you\n+// Write a method to replace all spaces in a string with '%20.' You may assume that the string\n+// has sufficient space at the end of the string to hold the additional characters, and that you\n // are given the \"true\" length of the string. (Note: if implementing in Java, please use a characters\n // array so that you can perform this operation in place)\n \n public class ReplaceSpaces {\n \tpublic void replaceSpaces(char[] str, int length) {\n-\t\tint spaceCount = 0, newLength; i;\n+\t\tint spaceCount = 0, newLength;\n \t\tfor(int i = 0; i < length; i++) {\n \t\t\tif(str[i] == ' ') {\n \t\t\t\tspaceCount++;",
    "output": "Fix compile error and some typo"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n--- a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n+++ b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n@@ -1,4 +1,4 @@\n-// Given two strings, write a metho dto decide if one is a permutation of the other\n+// Given two strings, write a method to decide if one is a permutation of the other\n \n public class Permutation {\n \tpublic boolean permutation(String s, String t) {\n@@ -22,4 +22,4 @@ public boolean permutation(String s, String t) {\n \n \t\treturn true;\n \t}\n-}\n\\ No newline at end of file\n+}",
    "output": "Add articles"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n--- a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n+++ b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n@@ -1,4 +1,4 @@\n-// Given two strings, write a metho dto decide if one is a permutation of the other\n+// Given two strings, write a method to decide if one is a permutation of the other\n \n public class Permutation {\n \tpublic boolean permutation(String s, String t) {\n@@ -22,4 +22,4 @@ public boolean permutation(String s, String t) {\n \n \t\treturn true;\n \t}\n-}\n\\ No newline at end of file\n+}",
    "output": "Upgrade Permutation.java"
  },
  {
    "input": "diff --git a/UVa/Modex.java b/UVa/Modex.java\n--- a/UVa/Modex.java\n+++ b/UVa/Modex.java\n@@ -28,7 +28,6 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3671\r\n \r\n-\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r\n\ndiff --git a/UVa/WhoSaidCrisis.java b/UVa/WhoSaidCrisis.java\n--- a/UVa/WhoSaidCrisis.java\n+++ b/UVa/WhoSaidCrisis.java\n@@ -28,7 +28,6 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=2443\r\n \r\n-\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Remove spaces"
  },
  {
    "input": "diff --git a/UVa/ArchaeologistsDilemma.java b/UVa/ArchaeologistsDilemma.java\n--- a/UVa/ArchaeologistsDilemma.java\n+++ b/UVa/ArchaeologistsDilemma.java\n@@ -1,5 +1,3 @@\n-package uva;\r\n-\r\n /**\r\n  * An archeologist seeking proof of the presence of extraterrestrials in the Earth’s past, stumbles upon a\r\n  * partially destroyed wall containing strange chains of numbers. The left-hand part of these lines of digits\r\n\ndiff --git a/UVa/CoconutsRevisited.java b/UVa/CoconutsRevisited.java\n--- a/UVa/CoconutsRevisited.java\n+++ b/UVa/CoconutsRevisited.java\n@@ -39,7 +39,7 @@\n \r\n public class CoconutsRevisited {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\tint i, rez, j;\r\n \t\tboolean isValid;\r",
    "output": "Remove package declaration at ArchaeologistsDilemma"
  },
  {
    "input": "diff --git a/UVa/WhoSaidCrisis.java b/UVa/WhoSaidCrisis.java\n--- a/UVa/WhoSaidCrisis.java\n+++ b/UVa/WhoSaidCrisis.java\n@@ -43,6 +43,5 @@ public static void main(String[] args) {\n \t\t\tSystem.out.println(first.subtract(second));\r\n \t\t\tnumberOfTestCases--;\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at WhoSaidCrisis"
  },
  {
    "input": "diff --git a/UVa/MultipleOfSeventeen.java b/UVa/MultipleOfSeventeen.java\n--- a/UVa/MultipleOfSeventeen.java\n+++ b/UVa/MultipleOfSeventeen.java\n@@ -49,6 +49,5 @@ public static void main(String[] args) {\n \t\t\t\tSystem.out.println(\"0\");\r\n \t\t\t}\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at MultipleOfSeventeen"
  },
  {
    "input": "diff --git a/UVa/MultipleOfSeventeen.java b/UVa/MultipleOfSeventeen.java\n--- a/UVa/MultipleOfSeventeen.java\n+++ b/UVa/MultipleOfSeventeen.java\n@@ -24,18 +24,8 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=3001\r\n \r\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class MultipleOfSeventeen {\r\n \tprivate static final BigInteger BIGINTEGER_FIVE = new BigInteger(\"5\");\r",
    "output": "Remove unused imports at MultipleOfSeventeen"
  },
  {
    "input": "diff --git a/UVa/Modex.java b/UVa/Modex.java\n--- a/UVa/Modex.java\n+++ b/UVa/Modex.java\n@@ -45,7 +45,6 @@ public static void main(String[] args) {\n \t\t\tSystem.out.println(result);\r\n \t\t\tnumberOfTestCases--;\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r\n \r",
    "output": "Remove scanner close at Modex"
  },
  {
    "input": "diff --git a/UVa/IntegerInquiry.java b/UVa/IntegerInquiry.java\n--- a/UVa/IntegerInquiry.java\n+++ b/UVa/IntegerInquiry.java\n@@ -39,6 +39,5 @@ public static void main(String[] args) {\n \t\t\tsum = sum.add(number);\r\n \t\t}\r\n \t\tSystem.out.println(sum);\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at IntegerInquiry"
  },
  {
    "input": "diff --git a/UVa/HighPrecisionNumber.java b/UVa/HighPrecisionNumber.java\n--- a/UVa/HighPrecisionNumber.java\n+++ b/UVa/HighPrecisionNumber.java\n@@ -59,6 +59,5 @@ public static void main(String[] args) {\n \t\t\t\t\t\"\\\\.0*$|(\\\\.\\\\d*?)0+$\", \"$1\"));\r\n \t\t\tnumberOfGroups--;\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at HighPrecisionNumber"
  },
  {
    "input": "diff --git a/UVa/BigMod.java b/UVa/BigMod.java\n--- a/UVa/BigMod.java\n+++ b/UVa/BigMod.java\n@@ -42,6 +42,5 @@ public static void main(String[] args) {\n \t\t\tBigInteger m = input.nextBigInteger();\r\n \t\t\tSystem.out.println(b.modPow(p, m));\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at BigMod"
  },
  {
    "input": "diff --git a/UVa/BigMod.java b/UVa/BigMod.java\n--- a/UVa/BigMod.java\n+++ b/UVa/BigMod.java\n@@ -29,17 +29,8 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=727&page=show_problem&problem=310\r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class BigMod {\r\n \r",
    "output": "Remove unused imports"
  },
  {
    "input": "diff --git a/UVa/WhoSaidCrisis.java b/UVa/WhoSaidCrisis.java\n--- a/UVa/WhoSaidCrisis.java\n+++ b/UVa/WhoSaidCrisis.java\n@@ -1,4 +1,6 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=2443\r\n+\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL at WhoSaidCrisis"
  },
  {
    "input": "diff --git a/UVa/FiveHundredFactorial.java b/UVa/FiveHundredFactorial.java\n--- a/UVa/FiveHundredFactorial.java\n+++ b/UVa/FiveHundredFactorial.java\n@@ -35,6 +35,7 @@\n  * 93326215443944152681699238856266700490715968264381621468592963895217599993229915\r\n  * 608941463976156518286253697920827223758251185210916864000000000000000000000000\r\n  */\r\n+\r\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=564\r\n \r\n import java.math.BigInteger;\r\n\ndiff --git a/UVa/GoldbachConjecture.java b/UVa/GoldbachConjecture.java\n--- a/UVa/GoldbachConjecture.java\n+++ b/UVa/GoldbachConjecture.java\n@@ -63,7 +63,7 @@ public static void main(String[] args) {\n \t\t}\r\n \t}\r\n \r\n-\tstatic boolean[] sieveOfEratosthenes(int number) {\r\n+\tprivate static boolean[] sieveOfEratosthenes(int number) {\r\n \t\tboolean[] isPrime = new boolean[number + 1];\r\n \t\tfor (int i = 2; i < number + 1; i++) {\r\n \t\t\tisPrime[i] = true;\r",
    "output": "Make sieveOfEratosthenes as a private method"
  },
  {
    "input": "diff --git a/UVa/FiveHundredFactorial.java b/UVa/FiveHundredFactorial.java\n--- a/UVa/FiveHundredFactorial.java\n+++ b/UVa/FiveHundredFactorial.java\n@@ -52,6 +52,5 @@ public static void main(String[] args) {\n \t\t\t}\r\n \t\t\tSystem.out.println(number + \"!\\n\" + product);\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at FiveHundredFactorial"
  },
  {
    "input": "diff --git a/UVa/BasicallySpeaking.java b/UVa/BasicallySpeaking.java\n--- a/UVa/BasicallySpeaking.java\n+++ b/UVa/BasicallySpeaking.java\n@@ -40,17 +40,8 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=325\r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class BasicallySpeaking {\r\n \r",
    "output": "Remove unused imports at BasicallySpeaking"
  },
  {
    "input": "diff --git a/UVa/AddingReversedNumbers.java b/UVa/AddingReversedNumbers.java\n--- a/UVa/AddingReversedNumbers.java\n+++ b/UVa/AddingReversedNumbers.java\n@@ -56,6 +56,5 @@ static void solve() throws Exception {\n \t\t\tSystem.out.println(resultReversed.replaceFirst(\"^0*\", \"\"));\r\n \t\t\tnumberOfTestCases--;\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at AddingReversedNumbers"
  },
  {
    "input": "diff --git a/UVa/WhatBaseIsThis.java b/UVa/WhatBaseIsThis.java\n--- a/UVa/WhatBaseIsThis.java\n+++ b/UVa/WhatBaseIsThis.java\n@@ -1,4 +1,6 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=279\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL at WhatBaseIsThis"
  },
  {
    "input": "diff --git a/UVa/WhatBaseIsThis.java b/UVa/WhatBaseIsThis.java\n--- a/UVa/WhatBaseIsThis.java\n+++ b/UVa/WhatBaseIsThis.java\n@@ -1,4 +1,3 @@\n-package mathematics.bigInteger;\r\n \r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r",
    "output": "Remove package declaration at WhatBaseIsThis"
  },
  {
    "input": "diff --git a/UVa/SimplyEmirp.java b/UVa/SimplyEmirp.java\n--- a/UVa/SimplyEmirp.java\n+++ b/UVa/SimplyEmirp.java\n@@ -1,4 +1,7 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1176\r\n+\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for SimplyEmirp"
  },
  {
    "input": "diff --git a/UVa/SimplifyingFractions.java b/UVa/SimplifyingFractions.java\n--- a/UVa/SimplifyingFractions.java\n+++ b/UVa/SimplifyingFractions.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1755\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for SimplifyingFractions"
  },
  {
    "input": "diff --git a/UVa/MultipleOfSeventeen.java b/UVa/MultipleOfSeventeen.java\n--- a/UVa/MultipleOfSeventeen.java\n+++ b/UVa/MultipleOfSeventeen.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=3001\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for MultipleOfSeventee"
  },
  {
    "input": "diff --git a/UVa/IntegerInquiry.java b/UVa/IntegerInquiry.java\n--- a/UVa/IntegerInquiry.java\n+++ b/UVa/IntegerInquiry.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=365\r\n+\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL for IntegerInquiry"
  },
  {
    "input": "diff --git a/UVa/HighPrecisionNumber.java b/UVa/HighPrecisionNumber.java\n--- a/UVa/HighPrecisionNumber.java\n+++ b/UVa/HighPrecisionNumber.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2921\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for HighPrecisionNumber"
  },
  {
    "input": "diff --git a/UVa/BasicallySpeaking.java b/UVa/BasicallySpeaking.java\n--- a/UVa/BasicallySpeaking.java\n+++ b/UVa/BasicallySpeaking.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=325\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for BasicallySpeaking"
  },
  {
    "input": "diff --git a/UVa/AddingReversedNumbers.java b/UVa/AddingReversedNumbers.java\n--- a/UVa/AddingReversedNumbers.java\n+++ b/UVa/AddingReversedNumbers.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=654\r\n+\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL for AddingReversedNumbers"
  },
  {
    "input": "diff --git a/UVa/NumberingRoads.java b/UVa/NumberingRoads.java\n--- a/UVa/NumberingRoads.java\n+++ b/UVa/NumberingRoads.java\n@@ -36,6 +36,9 @@\n  * Case 2: impossible\r\n  */\r\n \r\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2823\r\n+\r\n import java.util.Scanner;\r\n \r\n public class NumberingRoads {\r",
    "output": "Add problem source URL for NumberingRoads"
  },
  {
    "input": "diff --git a/UVa/HighSchoolPhysics.java b/UVa/HighSchoolPhysics.java\n--- a/UVa/HighSchoolPhysics.java\n+++ b/UVa/HighSchoolPhysics.java\n@@ -1,16 +1,18 @@\n-import java.util.Scanner;\r\n-\r\n-public class HighSchoolPhysics {\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\tScanner input = new Scanner(System.in);\r\n-\t\tString line = input.nextLine();\r\n-\t\twhile (!\"\".equals(line)) {\r\n-\t\t\tString[] numbers = line.split(\" \");\r\n-\t\t\tint v = Integer.valueOf(numbers[0]);\r\n-\t\t\tint t = Integer.valueOf(numbers[1]) * 2;\r\n-\t\t\tSystem.out.println(v * t);\r\n-\t\t\tline = input.nextLine();\r\n-\t\t}\r\n-\t}\r\n-}\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1012\n+\n+import java.util.Scanner;\n+\n+public class HighSchoolPhysics {\n+\n+\tpublic static void main(String[] args) {\n+\t\tScanner input = new Scanner(System.in);\n+\t\tString line = input.nextLine();\n+\t\twhile (!\"\".equals(line)) {\n+\t\t\tString[] numbers = line.split(\" \");\n+\t\t\tint v = Integer.valueOf(numbers[0]);\n+\t\t\tint t = Integer.valueOf(numbers[1]) * 2;\n+\t\t\tSystem.out.println(v * t);\n+\t\t\tline = input.nextLine();\n+\t\t}\n+\t}\n+}",
    "output": "Add problem source URL for HighSchoolPhysics"
  },
  {
    "input": "diff --git a/UVa/HashmatWarriors.java b/UVa/HashmatWarriors.java\n--- a/UVa/HashmatWarriors.java\n+++ b/UVa/HashmatWarriors.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=996\r\n+\r\n import java.util.Scanner;\r\n \r\n public class HashmatWarriors {\r",
    "output": "Add problem source URL for HashmatWarriors"
  },
  {
    "input": "diff --git a/UVa/BrickGame.java b/UVa/BrickGame.java\n--- a/UVa/BrickGame.java\n+++ b/UVa/BrickGame.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2986\r\n+\r\n import static java.lang.Integer.parseInt;\r\n \r\n import java.util.ArrayList;\r",
    "output": "Add problem source URL for BrickGame"
  },
  {
    "input": "diff --git a/UVa/BackToIntermediateMath.java b/UVa/BackToIntermediateMath.java\n--- a/UVa/BackToIntermediateMath.java\n+++ b/UVa/BackToIntermediateMath.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=1714\r\n+\r\n import java.text.DecimalFormat;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL for BackToIntermediateMath"
  },
  {
    "input": "diff --git a/UVa/BackToIntermediateMath.java b/UVa/BackToIntermediateMath.java\n--- a/UVa/BackToIntermediateMath.java\n+++ b/UVa/BackToIntermediateMath.java\n@@ -1,24 +1,16 @@\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.text.DecimalFormat;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class BackToIntermediateMath {\r\n \r\n-\tstatic void solve() throws Exception {\r\n-\t\tint numberOfTestCases = nextInt();\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tint numberOfTestCases = input.nextInt();\r\n \t\tDecimalFormat formatter = new DecimalFormat(\"#0.000\");\r\n \t\tfor (int i = 0; i < numberOfTestCases; i++) {\r\n-\t\t\tdouble distance = nextDouble();\r\n-\t\t\tdouble riverSpeed = nextDouble();\r\n-\t\t\tdouble boatSpeed = nextDouble();\r\n+\t\t\tdouble distance = input.nextDouble();\r\n+\t\t\tdouble riverSpeed = input.nextDouble();\r\n+\t\t\tdouble boatSpeed = input.nextDouble();\r\n \t\t\tif (riverSpeed == 0 || boatSpeed == 0 || boatSpeed <= riverSpeed) {\r\n \t\t\t\tSystem.out.println(\"Case \" + (i + 1) + \": can't determine\");\r\n \t\t\t} else {\r\n@@ -31,36 +23,4 @@ static void solve() throws Exception {\n \t\t\t}\r\n \t\t}\r\n \t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic int nextDouble() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Add problem source URL for BackToIntermediateMath"
  },
  {
    "input": "diff --git a/UVa/AverageSpeed.java b/UVa/AverageSpeed.java\n--- a/UVa/AverageSpeed.java\n+++ b/UVa/AverageSpeed.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1222\r\n+\r\n import java.text.DecimalFormat;\r\n import java.util.Scanner;\r\n \r\n@@ -31,7 +34,7 @@ static void solve() throws Exception {\n \r\n \t}\r\n \r\n-\tpublic static double calcHours(String s) {\r\n+\tprivate static double calcHours(String s) {\r\n \t\tString[] arr = s.split(\":\");\r\n \t\treturn (Integer.parseInt(arr[0]) * 3600 + Integer.parseInt(arr[1]) * 60 + Integer\r\n \t\t\t\t.parseInt(arr[2])) * 1.0 / 3600;\r",
    "output": "Add problem source URL for AverageSpeed"
  },
  {
    "input": "diff --git a/UVa/CoconutsRevisited.java b/UVa/CoconutsRevisited.java\n--- a/UVa/CoconutsRevisited.java\n+++ b/UVa/CoconutsRevisited.java\n@@ -32,6 +32,7 @@\n  * 30 coconuts, no solution\r\n  * 3121 coconuts, 5 people and 1 monkey\r\n  */\r\n+\r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=557\r\n \r\n import java.util.Scanner;\r",
    "output": "Add problem description for CoconutRevisited"
  },
  {
    "input": "diff --git a/UVa/DigitCounting.java b/UVa/DigitCounting.java\n--- a/UVa/DigitCounting.java\n+++ b/UVa/DigitCounting.java\n@@ -1,4 +1,6 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3666\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for DigitCounting"
  },
  {
    "input": "diff --git a/UVa/SkewBinary.java b/UVa/SkewBinary.java\n--- a/UVa/SkewBinary.java\n+++ b/UVa/SkewBinary.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=516\r\n+\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL at SkewBinary"
  },
  {
    "input": "diff --git a/UVa/SkewBinary.java b/UVa/SkewBinary.java\n--- a/UVa/SkewBinary.java\n+++ b/UVa/SkewBinary.java\n@@ -1,20 +1,9 @@\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.Long.parseLong;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class SkewBinary {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\twhile (true) {\r\n \t\t\tBigInteger number = input.nextBigInteger();\r\n@@ -33,38 +22,5 @@ static void solve() throws Exception {\n \t\t\tSystem.out.println(sum);\r\n \t\t}\r\n \t\tinput.close();\r\n-\r\n-\t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic long nextLong() throws IOException {\r\n-\t\treturn parseLong(next());\r\n \t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Add SkewBinary"
  },
  {
    "input": "diff --git a/UVa/Parity.java b/UVa/Parity.java\n--- a/UVa/Parity.java\n+++ b/UVa/Parity.java\n@@ -22,19 +22,9 @@\n  * The parity of 10101 is 3 (mod 2).\r\n  */\r\n \r\n-\r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1872\r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class Parity {\r\n \r",
    "output": "Remove unused import"
  },
  {
    "input": "diff --git a/UVa/Parity.java b/UVa/Parity.java\n--- a/UVa/Parity.java\n+++ b/UVa/Parity.java\n@@ -22,6 +22,9 @@\n  * The parity of 10101 is 3 (mod 2).\r\n  */\r\n \r\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1872\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for Parity"
  },
  {
    "input": "diff --git a/UVa/LargestPrimeDivisor.java b/UVa/LargestPrimeDivisor.java\n--- a/UVa/LargestPrimeDivisor.java\n+++ b/UVa/LargestPrimeDivisor.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2461\r\n+\r\n import java.util.Scanner;\r\n \r\n public class LargestPrimeDivisor {\r",
    "output": "Add problem source URL for LargestPrimeDivisor"
  },
  {
    "input": "diff --git a/UVa/GoldbachConjecture.java b/UVa/GoldbachConjecture.java\n--- a/UVa/GoldbachConjecture.java\n+++ b/UVa/GoldbachConjecture.java\n@@ -1,4 +1,6 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=484\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n import java.io.BufferedReader;\r",
    "output": "Add problem source URL for GoldbachConjecture"
  },
  {
    "input": "diff --git a/UVa/MischievousChildren.java b/UVa/MischievousChildren.java\n--- a/UVa/MischievousChildren.java\n+++ b/UVa/MischievousChildren.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=1279\r\n+\r\n import java.util.HashMap;\r\n import java.util.Map;\r\n import java.util.Scanner;\r",
    "output": "Add problem source URL for MischeviousChildren"
  },
  {
    "input": "diff --git a/UVa/FiveHundredFactorial.java b/UVa/FiveHundredFactorial.java\n--- a/UVa/FiveHundredFactorial.java\n+++ b/UVa/FiveHundredFactorial.java\n@@ -1,4 +1,7 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=564\r\n+\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL at FiveHundredFactorial"
  },
  {
    "input": "diff --git a/UVa/TheHugeOne.java b/UVa/TheHugeOne.java\n--- a/UVa/TheHugeOne.java\n+++ b/UVa/TheHugeOne.java\n@@ -1,4 +1,6 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2319\r\n+\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL at TheHugeOne"
  },
  {
    "input": "diff --git a/UVa/FactorialFrequenices.java b/UVa/FactorialFrequenices.java\n--- a/UVa/FactorialFrequenices.java\n+++ b/UVa/FactorialFrequenices.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=260\r\n+\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL for FactorialFrequencies"
  },
  {
    "input": "diff --git a/UVa/NumberTheoryForNewbies.java b/UVa/NumberTheoryForNewbies.java\n--- a/UVa/NumberTheoryForNewbies.java\n+++ b/UVa/NumberTheoryForNewbies.java\n@@ -1,3 +1,7 @@\n+\r\n+\r\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=2366\r\n+\r\n import java.util.Arrays;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL for NumberTheoryForNewbies"
  },
  {
    "input": "diff --git a/UVa/LastNonZeroDigit.java b/UVa/LastNonZeroDigit.java\n--- a/UVa/LastNonZeroDigit.java\n+++ b/UVa/LastNonZeroDigit.java\n@@ -26,8 +26,6 @@\n \n //https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1153\n \n-import static java.lang.System.exit;\n-\n import java.util.Scanner;\n \n public class LastNonZeroDigit {",
    "output": "Remove unused import"
  },
  {
    "input": "diff --git a/UVa/JollyJumpers.java b/UVa/JollyJumpers.java\n--- a/UVa/JollyJumpers.java\n+++ b/UVa/JollyJumpers.java\n@@ -20,6 +20,11 @@\n \n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=979\n \n+import java.util.HashSet;\n+import java.util.Scanner;\n+import java.util.Set;\n+\n+\n public class JollyJumpers {\n \n \tpublic static void main(String[] args) {",
    "output": "Add missing imports at JollyJumpers"
  },
  {
    "input": "diff --git a/UVa/BasicRemains.java b/UVa/BasicRemains.java\n--- a/UVa/BasicRemains.java\n+++ b/UVa/BasicRemains.java\n@@ -21,6 +21,9 @@\n *10\n *789\n  */\n+\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1492\n+\n import java.math.BigInteger;\n import java.util.Scanner;\n \n\ndiff --git a/UVa/JollyJumper.java b/UVa/JollyJumper.java\n--- a/UVa/JollyJumper.java\n+++ b/UVa/JollyJumper.java\n@@ -16,6 +16,7 @@\n *Jolly\n *Not jolly\n */\n+\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=979\n \n public class JollyJumper {\n\ndiff --git a/UVa/LastNonZeroDigit.java b/UVa/LastNonZeroDigit.java\n--- a/UVa/LastNonZeroDigit.java\n+++ b/UVa/LastNonZeroDigit.java\n@@ -23,7 +23,9 @@\n *4\n *2\n */\n+\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1153\n+\n import static java.lang.System.exit;\n \n import java.util.Scanner;\n\ndiff --git a/UVa/Newspaper.java b/UVa/Newspaper.java\n--- a/UVa/Newspaper.java\n+++ b/UVa/Newspaper.java\n@@ -34,6 +34,7 @@\n *Sample Output\n *3.74$\n */\n+\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2315\n \n import java.text.DecimalFormat;",
    "output": "Add problem URL at BasicRemains"
  },
  {
    "input": "diff --git a/UVa/PrimeFactors.java b/UVa/PrimeFactors.java\n--- a/UVa/PrimeFactors.java\n+++ b/UVa/PrimeFactors.java\n@@ -49,7 +49,6 @@ greater than unity (with fi ≤ fj for i < j), the format of the output line sho\n 200 = 2 x 2 x 2 x 5 x 5*/\n \n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=524\n-package UVa;\n \n import java.util.ArrayList;\n import java.util.Collections;",
    "output": "Remove package declaration at PrimeFactors"
  },
  {
    "input": "diff --git a/Company/Airbnb/validParentheses.java b/Company/Airbnb/validParentheses.java\n--- a/Company/Airbnb/validParentheses.java\n+++ b/Company/Airbnb/validParentheses.java\n@@ -22,19 +22,19 @@ public boolean isValid(String s) {\n                 \n             }\n             \n-            else if(s.charAt(i) == ')' && !stack.isEmpty() && stack.peek() == ')') {\n+            else if(s.charAt(i) == ')' && !stack.isEmpty() && stack.peek() == '(') {\n                 \n                 stack.pop();\n                 \n             }\n             \n-            else if(s.charAt(i) == ']' && !stack.isEmpty() && stack.peek() == ']') {\n+            else if(s.charAt(i) == ']' && !stack.isEmpty() && stack.peek() == '[') {\n                 \n                 stack.pop();\n                 \n             }\n             \n-            else if(s.charAt(i) == '}' && !stack.isEmpty() && stack.peek() == '}') {\n+            else if(s.charAt(i) == '}' && !stack.isEmpty() && stack.peek() == '{') {\n                 \n                 stack.pop();\n                 \n@@ -52,4 +52,4 @@ else if(s.charAt(i) == '}' && !stack.isEmpty() && stack.peek() == '}') {\n         \n     }\n \n-}\n\\ No newline at end of file\n+}",
    "output": "Upgrade validParentheses.java fix code logic error leading to incorrect solution: top of stack should be an opening parenthesis if current character is a closing parenthesis for string to be valid"
  },
  {
    "input": "diff --git a/UVa/JollyJumper.java b/UVa/JollyJumper.java\n--- a/UVa/JollyJumper.java\n+++ b/UVa/JollyJumper.java\n@@ -42,14 +42,4 @@ public static void main(String[] args) {\n \t\t}\n \t}\n \n-\tpublic static int findMaximalElement(int[] numbers) {\n-\t\tint max = numbers[0];\n-\t\tfor (int i = 1; i < numbers.length; i++) {\n-\t\t\tif (max < numbers[i]) {\n-\t\t\t\tmax = numbers[i];\n-\t\t\t}\n-\t\t}\n-\t\treturn max;\n-\t}\n-\n }\n\\ No newline at end of file",
    "output": "Remove unused method at JollyJumper"
  },
  {
    "input": "diff --git a/UVa/Newspaper.java b/UVa/Newspaper.java\n--- a/UVa/Newspaper.java\n+++ b/UVa/Newspaper.java\n@@ -33,7 +33,6 @@ ACM International Collegiate Programming Contest (abbreviated\n Sample Output\n 3.74$*/\n \n-package UVa;\n \n import java.text.DecimalFormat;\n import java.util.HashMap;",
    "output": "Remove package declaration"
  },
  {
    "input": "diff --git a/UVa/JollyJumper.java b/UVa/JollyJumper.java\n--- a/UVa/JollyJumper.java\n+++ b/UVa/JollyJumper.java\n@@ -17,19 +17,6 @@\n Not jolly*/\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=979\n \n-import static java.lang.Integer.parseInt;\n-import static java.lang.System.exit;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n-import java.io.PrintWriter;\n-import java.util.HashSet;\n-import java.util.Scanner;\n-import java.util.Set;\n-import java.util.StringTokenizer;\n-\n public class JollyJumper {\n \n \tpublic static void main(String[] args) {",
    "output": "Remove unused libraries at JollyJumper"
  },
  {
    "input": "diff --git a/UVa/BasicRemains.java b/UVa/BasicRemains.java\n--- a/UVa/BasicRemains.java\n+++ b/UVa/BasicRemains.java\n@@ -21,15 +21,8 @@\n 10\n 789\n  */\n-import static java.lang.Integer.parseInt;\n-import static java.lang.System.exit;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n import java.math.BigInteger;\n import java.util.Scanner;\n-import java.util.StringTokenizer;\n \n public class BasicRemains {\n \n@@ -44,8 +37,5 @@ public static void main(String[] args) {\n \t\t\tBigInteger m = new BigInteger(input.next(), baseNumber);\n \t\t\tSystem.out.println((p.mod(m)).toString(baseNumber));\n \t\t}\n-\t\t\n-\t\tinput.close();\n-\t\t}\n \t}\n }\n\\ No newline at end of file",
    "output": "Remove unused libraries at BasicRemains"
  },
  {
    "input": "diff --git a/UVa/JollyJumper.java b/UVa/JollyJumper.java\n--- a/UVa/JollyJumper.java\n+++ b/UVa/JollyJumper.java\n@@ -1,3 +1,4 @@\n+\n /*A sequence of n > 0 integers is called a jolly jumper if the absolute values of the difference between\n successive elements take on all the values 1 through n − 1. For instance,\n 1 4 2 3\n@@ -16,7 +17,6 @@\n Not jolly*/\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=979\n \n-\n import static java.lang.Integer.parseInt;\n import static java.lang.System.exit;\n \n@@ -32,7 +32,7 @@\n \n public class JollyJumper {\n \n-\tstatic void solve() throws Exception {\n+\tpublic static void main(String[] args) {\n \t\tScanner input = new Scanner(System.in);\n \t\twhile (input.hasNext()) {\n \t\t\tSet<Integer> numbersAlreadyAdded = new HashSet<Integer>();\n@@ -53,10 +53,9 @@ static void solve() throws Exception {\n \t\t\t\tSystem.out.println(\"Not jolly\");\n \t\t\t}\n \t\t}\n-\t\tinput.close();\n \t}\n \n-\tstatic int findMaximalElement(int[] numbers) {\n+\tpublic static int findMaximalElement(int[] numbers) {\n \t\tint max = numbers[0];\n \t\tfor (int i = 1; i < numbers.length; i++) {\n \t\t\tif (max < numbers[i]) {\n@@ -66,31 +65,4 @@ static int findMaximalElement(int[] numbers) {\n \t\treturn max;\n \t}\n \n-\tstatic int nextInt() throws IOException {\n-\t\treturn parseInt(next());\n-\t}\n-\n-\tstatic String next() throws IOException {\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\n-\t\t\ttok = new StringTokenizer(in.readLine());\n-\t\t}\n-\t\treturn tok.nextToken();\n-\t}\n-\n-\tpublic static void main(String[] args) {\n-\t\ttry {\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n-\t\t\tsolve();\n-\t\t\tin.close();\n-\t\t\tout.close();\n-\t\t} catch (Throwable e) {\n-\t\t\te.printStackTrace();\n-\t\t\texit(0);\n-\t\t}\n-\t}\n-\n-\tstatic BufferedReader in;\n-\tstatic PrintWriter out;\n-\tstatic StringTokenizer tok;\n }\n\\ No newline at end of file",
    "output": "Remove unused methods from JollyJumper"
  },
  {
    "input": "diff --git a/UVa/BasicRemains.java b/UVa/BasicRemains.java\n--- a/UVa/BasicRemains.java\n+++ b/UVa/BasicRemains.java\n@@ -26,18 +26,15 @@\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.math.BigInteger;\n import java.util.Scanner;\n import java.util.StringTokenizer;\n \n public class BasicRemains {\n \n-\tstatic void solve() throws Exception {\n+\tpublic static void main(String[] args) {\n \t\tScanner input = new Scanner(System.in);\n-\n \t\twhile (input.hasNext()) {\n \t\t\tint baseNumber = input.nextInt();\n \t\t\tif (baseNumber == 0) {\n@@ -47,30 +44,8 @@ static void solve() throws Exception {\n \t\t\tBigInteger m = new BigInteger(input.next(), baseNumber);\n \t\t\tSystem.out.println((p.mod(m)).toString(baseNumber));\n \t\t}\n+\t\t\n \t\tinput.close();\n-\t}\n-\n-\tstatic int nextInt() throws IOException {\n-\t\treturn parseInt(next());\n-\t}\n-\n-\tstatic String next() throws IOException {\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\n-\t\t\ttok = new StringTokenizer(in.readLine());\n \t\t}\n-\t\treturn tok.nextToken();\n \t}\n-\n-\tpublic static void main(String[] args) {\n-\t\ttry {\n-\t\t\tsolve();\n-\t\t} catch (Throwable e) {\n-\t\t\te.printStackTrace();\n-\t\t\texit(0);\n-\t\t}\n-\t}\n-\n-\tstatic BufferedReader in;\n-\tstatic PrintWriter out;\n-\tstatic StringTokenizer tok;\n }\n\\ No newline at end of file",
    "output": "Remove unused methods from BasicRemains.java"
  },
  {
    "input": "diff --git a/UVa/PrimeFactors.java b/UVa/PrimeFactors.java\n--- a/UVa/PrimeFactors.java\n+++ b/UVa/PrimeFactors.java\n@@ -1,4 +1,58 @@\n-\n+/*Webster defines prime as:\n+prime (pr¯im) n. [ME, fr. MF, fem. of prin first, L primus; akin to L prior] 1: first in\n+time: original 2 a: having no factor except itself and one ⟨3 is a ∼ number⟩ b : having\n+no common factor except one ⟨12 and 25 are relatively ∼⟩ 3 a: first in rank, authority or\n+significance: principal b: having the highest quality or value ⟨∼ television time ⟩ [from\n+Webster’s New Collegiate Dictionary]\n+The most relevant definition for this problem is 2a: An integer g > 1 is said to be prime if and only\n+if its only positive divisors are itself and one (otherwise it is said to be composite). For example, the\n+number 21 is composite; the number 23 is prime. Note that the decompositon of a positive number g\n+into its prime factors, i.e.,\n+g = f1 × f2 × · · · × fn\n+is unique if we assert that fi > 1 for all i and fi ≤ fj for i < j.\n+One interesting class of prime numbers are the so-called Mersenne primes which are of the form\n+2\n+p − 1. Euler proved that 2\n+31 − 1 is prime in 1772 — all without the aid of a computer.\n+Input\n+The input will consist of a sequence of numbers. Each line of input will contain one number g in the\n+range −2\n+31 < g < 2\n+31, but different of -1 and 1. The end of input will be indicated by an input line\n+having a value of zero.\n+Output\n+For each line of input, your program should print a line of output consisting of the input number and\n+its prime factors. For an input number g > 0, g = f1 × f2 × · · · × fn, where each fi\n+is a prime number\n+greater than unity (with fi ≤ fj for i < j), the format of the output line should be\n+g = f1 x f2 x . . . x fn\n+When g < 0, if | g |= f1 × f2 × · · · × fn, the format of the output line should be\n+g = -1 x f1 x f2 x . . . x fn\n+Sample Input\n+-190\n+-191\n+-192\n+-193\n+-194\n+195\n+196\n+197\n+198\n+199\n+200\n+0\n+Sample Output\n+-190 = -1 x 2 x 5 x 19\n+-191 = -1 x 191\n+-192 = -1 x 2 x 2 x 2 x 2 x 2 x 2 x 3\n+-193 = -1 x 193\n+-194 = -1 x 2 x 97\n+195 = 3 x 5 x 13\n+196 = 2 x 2 x 7 x 7\n+197 = 197\n+198 = 2 x 3 x 3 x 11\n+199 = 199\n+200 = 2 x 2 x 2 x 5 x 5*/\n import static java.lang.Integer.parseInt;\n import static java.lang.System.exit;\n \n@@ -13,7 +67,6 @@\n import java.util.StringTokenizer;\n \n \n-//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=524\n public class PrimeFactors {\n \n     static void solve() throws Exception {",
    "output": "Add PrimeFactors probilem description"
  },
  {
    "input": "diff --git a/UVa/Newspaper.java b/UVa/Newspaper.java\n--- a/UVa/Newspaper.java\n+++ b/UVa/Newspaper.java\n@@ -32,21 +32,13 @@ ACM International Collegiate Programming Contest (abbreviated\n From Wikipedia.\n Sample Output\n 3.74$*/\n-//https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2315\n \n-import static java.lang.Integer.parseInt;\n-import static java.lang.System.exit;\n+package UVa;\n \n import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.text.DecimalFormat;\n-import java.util.HashMap;\n-import java.util.Map;\n import java.util.Scanner;\n-import java.util.StringTokenizer;\n \n public class Newspaper {\n ",
    "output": "Add problem description"
  },
  {
    "input": "diff --git a/UVa/Newspaper.java b/UVa/Newspaper.java\n--- a/UVa/Newspaper.java\n+++ b/UVa/Newspaper.java\n@@ -1,3 +1,38 @@\n+/*News agency pays money for articles according to some rules. Each character has its own value (some\n+characters may have value equals to zero). Author gets his payment as a sum of all character’s values\n+in the article. You have to determine the amount of money that news agency must pay to an author.\n+Input\n+The first line contains integer N (0 < N ≤ 5), it is a number of tests. Each test describes an integer\n+K (0 < K ≤ 100), the number of paid characters. On next K lines there are table of paid characters\n+and its values (character values are written in cents). If character can not be found in the table, then\n+its value is equal to zero. Next, there is integer M (0 < M ≤ 150000). Next M lines contain an article\n+itself. Each line can be up to 10000 characters length. Be aware of a large input size, the whole input\n+file is about 7MB.\n+Output\n+For each test print how much money publisher must pay for an article in format ‘x.yy$’. Where x is\n+a number of dollars without leading zeros, and yy number of cents with one leading zero if necessary.\n+Examples: ‘3.32$’, ‘13.07$’, ‘71.30$’, ‘0.09$’.\n+Sample Input\n+1\n+7\n+a 3\n+W 10\n+A 100\n+, 10\n+k 7\n+. 3\n+I 13\n+7\n+ACM International Collegiate Programming Contest (abbreviated\n+as ACM-ICPC or just ICPC) is an annual multi-tiered competition\n+among the universities of the world. The ICPC challenges students\n+to set ever higher standards of excellence for themselves\n+through competition that rewards team work, problem analysis,\n+and rapid software development.\n+From Wikipedia.\n+Sample Output\n+3.74$*/\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2315\n \n import static java.lang.Integer.parseInt;\n import static java.lang.System.exit;\n@@ -13,7 +48,6 @@\n import java.util.Scanner;\n import java.util.StringTokenizer;\n \n-//https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2315\n public class Newspaper {\n \n \tstatic void solve() throws Exception {",
    "output": "Add Newspaper problem description as a comment"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter3StacksAndQueues/ThreeStacks.java b/CrackingTheCodingInterview/Chapter3StacksAndQueues/ThreeStacks.java\n--- a/CrackingTheCodingInterview/Chapter3StacksAndQueues/ThreeStacks.java\n+++ b/CrackingTheCodingInterview/Chapter3StacksAndQueues/ThreeStacks.java\n@@ -34,11 +34,11 @@ int peek(int stackNum) {\n \t}\n \n \tboolean isEmpty(int stackNum) {\n-\t\treturn stackPointer[sstackNum] == -1;\n+\t\treturn stackPointer[stackNum] == -1;\n \t}\n \n \t/* returns index of top of stack \"stackNum\", in absolute terms */\n \tint absTopOfStack(int stasckNum) {\n \t\treturn stackNum * stackSize + stackPointer[stackNum];\n \t}\n-}\n\\ No newline at end of file\n+}",
    "output": "Upgrade ThreeStacks - isEmpty function variable is not equal to the parameter you are passing"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/DeleteDups.java b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/DeleteDups.java\n--- a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/DeleteDups.java\n+++ b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/DeleteDups.java\n@@ -0,0 +1,18 @@\n+//Write code to remove duplicates from an unsorted linked list\n+\n+public class RemoveDups {\n+\tvoid deleteDups(LinkedListNode n) {\n+\t\tHashSet<Integer> set = new HashSet<Integer>();\n+\t\tLinkedListNode previous = null;\n+\t\twhile(n != null) {\n+\t\t\tif(set.contains(n.data)) {\n+\t\t\t\tprevious.next = n.next;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tset.add(n.data);\n+\t\t\t\tprevious = n;\n+\t\t\t}\n+\t\t\tn = n.next;\n+\t\t}\n+\t}\n+}\n\\ No newline at end of file",
    "output": "Add Refdash, fixed toggle bit and switch values"
  },
  {
    "input": "diff --git a/DivideAndConquer/expressionAddOperators.java b/DivideAndConquer/expressionAddOperators.java\n--- a/DivideAndConquer/expressionAddOperators.java\n+++ b/DivideAndConquer/expressionAddOperators.java\n@@ -0,0 +1,58 @@\n+// Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.\n+\n+// Examples: \n+// \"123\", 6 -> [\"1+2+3\", \"1*2*3\"] \n+// \"232\", 8 -> [\"2*3+2\", \"2+3*2\"]\n+// \"105\", 5 -> [\"1*0+5\",\"10-5\"]\n+// \"00\", 0 -> [\"0+0\", \"0-0\", \"0*0\"]\n+// \"3456237490\", 9191 -> []\n+\n+public class Solution {\n+\n+    public List<String> addOperators(String num, int target) {\n+        \n+        List<String> result = new ArrayList<String>();\n+        if(num == null || num.length() == 0) return result;\n+        helper(result, \"\", num, target, 0, 0, 0);\n+        return result;\n+        \n+    }\n+    \n+    public void helper(List<String> result, String path, String num, int target, int pos, long eval, long multed) {\n+        \n+        if(pos == num.length()) {\n+            \n+            if(eval == target) {\n+                \n+                result.add(path);\n+                \n+            }\n+            \n+            return;\n+            \n+        }\n+        \n+        for(int i = pos; i < num.length(); i++) {\n+            \n+            if(i != pos && num.charAt(pos) == '0') break;\n+            long cur = Long.parseLong(num.substring(pos, i + 1));\n+            if(pos == 0) {\n+                \n+                helper(result, path + cur, num, target, i + 1, cur, cur);\n+                \n+            }\n+            \n+            else {\n+                \n+                helper(result, path + \"+\" + cur, num, target, i + 1, eval + cur, cur);\n+                helper(result, path + \"-\" + cur, num, target, i + 1, eval - cur, -cur);\n+                helper(result, path + \"*\" + cur, num, target, i + 1, eval - multed + multed * cur, multed * cur);\n+                \n+                \n+            }\n+            \n+        }\n+        \n+    }\n+    \n+}\n\\ No newline at end of file\n\ndiff --git a/DivideAndConquer/kthLargestElementInAnArray.java b/DivideAndConquer/kthLargestElementInAnArray.java\n--- a/DivideAndConquer/kthLargestElementInAnArray.java\n+++ b/DivideAndConquer/kthLargestElementInAnArray.java\n@@ -0,0 +1,19 @@\n+// Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n+\n+// For example,\n+// Given [3,2,1,5,6,4] and k = 2, return 5.\n+\n+// Note: \n+// You may assume k is always valid, 1 ≤ k ≤ array's length.\n+\n+public class Solution {\n+\n+    public int findKthLargest(int[] nums, int k) {\n+\n+        int length = nums.length;\n+        Arrays.sort(nums);\n+        return nums[length - k];\n+        \n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Add DivideAndConquer"
  },
  {
    "input": "diff --git a/Backtracking/androidUnlockPatterns.java b/Backtracking/androidUnlockPatterns.java\n--- a/Backtracking/androidUnlockPatterns.java\n+++ b/Backtracking/androidUnlockPatterns.java\n@@ -0,0 +1,93 @@\n+// Given an Android 3x3 key lock screen and two integers m and n, where 1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.\n+\n+// Rules for a valid pattern:\n+    // Each pattern must connect at least m keys and at most n keys.\n+    // All the keys must be distinct.\n+    // If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed.\n+    // The order of keys used matters.\n+\n+// Explanation:\n+// | 1 | 2 | 3 |\n+// | 4 | 5 | 6 |\n+// | 7 | 8 | 9 |\n+// Invalid move: 4 - 1 - 3 - 6 \n+// Line 1 - 3 passes through key 2 which had not been selected in the pattern.\n+\n+// Invalid move: 4 - 1 - 9 - 2\n+// Line 1 - 9 passes through key 5 which had not been selected in the pattern.\n+\n+// Valid move: 2 - 4 - 1 - 3 - 6\n+// Line 1 - 3 is valid because it passes through key 2, which had been selected in the pattern\n+\n+// Valid move: 6 - 5 - 4 - 1 - 9 - 2\n+// Line 1 - 9 is valid because it passes through key 5, which had been selected in the pattern.\n+\n+// Example:\n+// Given m = 1, n = 1, return 9.\n+\n+public class Solution {\n+\n+    public int numberOfPatterns(int m, int n) {\n+        \n+        //initialize a 10x10 matrix\n+        int skip[][] = new int[10][10];\n+        \n+        //initialize indices of skip matrix (all other indices in matrix are 0 by default)\n+        skip[1][3] = skip[3][1] = 2;\n+        skip[1][7] = skip[7][1] = 4;\n+        skip[3][9] = skip[9][3] = 6;\n+        skip[7][9] = skip[9][7] = 8;\n+        skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip [7][3] = skip[6][4] = skip[4][6] = 5;\n+        \n+        //initialize visited array\n+        boolean visited[] = new boolean[10];\n+        \n+        //initialize total number to 0\n+        int totalNumber = 0;\n+        \n+        //run DFS for each length from m to n\n+        for(int i = m; i <= n; ++i) {\n+            \n+            totalNumber += DFS(visited, skip, 1, i - 1) * 4; //1, 3, 7, and 9 are symmetric so multiply this result by 4\n+            totalNumber += DFS(visited, skip, 2, i - 1) * 4; //2, 4, 6, and 8 are symmetric so multiply this result by 4\n+            totalNumber += DFS(visited, skip, 5, i - 1); //do not multiply by 4 because 5 is unique         \n+            \n+        }\n+        \n+        return totalNumber;\n+  \n+    }\n+    \n+    int DFS(boolean visited[], int[][] skip, int current, int remaining) {\n+        \n+        //base cases\n+        if(remaining < 0) return 0;\n+        if(remaining == 0) return 1;\n+        \n+        //mark the current node as visited\n+        visited[current] = true;\n+        \n+        //initialize total number to 0\n+        int totalNumber = 0;\n+        \n+        \n+        for(int i = 1; i <= 9; ++i) {\n+            \n+            //if the current node has not been visited and (two numbers are adjacent or skip number has already been visited)\n+            if(!visited[i] && (skip[current][i] == 0 || visited[skip[current][i]])) {\n+                \n+                totalNumber += DFS(visited, skip, i, remaining - 1);\n+                \n+            }\n+            \n+        }\n+        \n+        //mark the current node as not visited\n+        visited[current] = false;\n+        \n+        //return total number\n+        return totalNumber;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/Backtracking/generalizedAbbreviation.java b/Backtracking/generalizedAbbreviation.java\n--- a/Backtracking/generalizedAbbreviation.java\n+++ b/Backtracking/generalizedAbbreviation.java\n@@ -0,0 +1,42 @@\n+// Write a function to generate the generalized abbreviations of a word.\n+\n+// Example:\n+// Given word = \"word\", return the following list (order does not matter):\n+// [\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\n+\n+public class Solution {\n+\n+    public List<String> generateAbbreviations(String word) {\n+        \n+        List<String> result = new ArrayList<String>();\n+        \n+        backtrack(result, word, 0, \"\", 0);\n+        \n+        return result;\n+        \n+    }\n+    \n+    void backtrack(List result, String word, int position, String current, int count) {\n+        \n+        if(position == word.length()) {\n+            \n+            if(count > 0) {\n+                \n+                current += count;   \n+                \n+            }\n+            \n+            result.add(current);\n+            \n+        }\n+        \n+        else {\n+            \n+            backtrack(result, word, position + 1, current, count + 1);\n+            backtrack(result, word, position + 1, current + (count > 0 ? count : \"\") + word.charAt(position), 0);\n+            \n+        }\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/Backtracking/letterCombinationsOfAPhoneNumber.java b/Backtracking/letterCombinationsOfAPhoneNumber.java\n--- a/Backtracking/letterCombinationsOfAPhoneNumber.java\n+++ b/Backtracking/letterCombinationsOfAPhoneNumber.java\n@@ -0,0 +1,54 @@\n+// Given a digit string, return all possible letter combinations that the number could represent.\n+\n+// A mapping of digit to letters (just like on the telephone buttons) is given below.\n+\n+// 2 - abc\n+// 3 - def\n+// 4 - ghi\n+// 5 - jkl\n+// 6 - mno\n+// 7 - pqrs\n+// 8 - tuv\n+// 9 - wxyz\n+\n+// Input:Digit string \"23\"\n+// Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n+\n+public class Solution {\n+\n+    public List<String> letterCombinations(String digits) {\n+        \n+        LinkedList<String> result = new LinkedList<>();\n+        String[] mapping = new String[] { \"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\n+        \n+        if(digits == null || digits.length() == 0) {\n+            \n+            return result;\n+            \n+        }\n+        \n+        result.add(\"\");\n+        \n+        for(int i = 0; i < digits.length(); i++) {\n+            \n+            int current = Character.getNumericValue(digits.charAt(i));\n+            \n+            while(result.peek().length() == i) {\n+                \n+                String s = result.remove();\n+                \n+                for(char c : mapping[current].toCharArray()) {\n+                    \n+                    result.add(s + c);\n+                    \n+                }\n+                \n+            }\n+            \n+        }\n+        \n+        return result;\n+        \n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Add Backtracking"
  },
  {
    "input": "diff --git a/Sort/meetingRooms.java b/Sort/meetingRooms.java\n--- a/Sort/meetingRooms.java\n+++ b/Sort/meetingRooms.java\n@@ -0,0 +1,47 @@\n+// Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings.\n+\n+// For example,\n+// Given [[0, 30],[5, 10],[15, 20]],\n+// return false.\n+\n+/**\n+ * Definition for an interval.\n+ * public class Interval {\n+ *     int start;\n+ *     int end;\n+ *     Interval() { start = 0; end = 0; }\n+ *     Interval(int s, int e) { start = s; end = e; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public boolean canAttendMeetings(Interval[] intervals) {\n+        \n+            if(intervals == null) {\n+                \n+                return false;\n+                \n+            }\n+        \n+    // Sort the intervals by start time\n+    Arrays.sort(intervals, new Comparator<Interval>() {\n+\n+        public int compare(Interval a, Interval b) { return a.start - b.start; }\n+\n+    });\n+\n+            for(int i = 1; i < intervals.length; i++) {\n+                \n+                if(intervals[i].start < intervals[i - 1].end) {\n+                    \n+                    return false;\n+                    \n+                }\n+                \n+            }\n+            \n+            return true;\n+\n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/Sort/meetingRoomsII.java b/Sort/meetingRoomsII.java\n--- a/Sort/meetingRoomsII.java\n+++ b/Sort/meetingRoomsII.java\n@@ -0,0 +1,48 @@\n+// Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.\n+\n+// For example,\n+// Given [[0, 30],[5, 10],[15, 20]],\n+// return 2.\n+\n+/**\n+ * Definition for an interval.\n+ * public class Interval {\n+ *     int start;\n+ *     int end;\n+ *     Interval() { start = 0; end = 0; }\n+ *     Interval(int s, int e) { start = s; end = e; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public int minMeetingRooms(Interval[] intervals) {\n+\n+        int[] starts = new int[intervals.length];\n+        int[] ends = new int[intervals.length];\n+\n+        for(int i=0; i<intervals.length; i++) {\n+\n+            starts[i] = intervals[i].start;\n+            ends[i] = intervals[i].end;\n+\n+        }\n+\n+        Arrays.sort(starts);\n+        Arrays.sort(ends);\n+        int rooms = 0;\n+        int endsItr = 0;\n+\n+        for(int i=0; i<starts.length; i++) {\n+\n+            if(starts[i]<ends[endsItr])\n+                rooms++;\n+            else\n+                endsItr++;\n+\n+        }\n+\n+        return rooms;\n+\n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Add Sort"
  },
  {
    "input": "diff --git a/Array/insertInterval.java b/Array/insertInterval.java\n--- a/Array/insertInterval.java\n+++ b/Array/insertInterval.java\n@@ -0,0 +1,41 @@\n+// Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\n+\n+// You may assume that the intervals were initially sorted according to their start times.\n+\n+// Example 1:\n+// Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].\n+\n+// Example 2:\n+// Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].\n+\n+// This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].\n+\n+/**\n+ * Definition for an interval.\n+ * public class Interval {\n+ *     int start;\n+ *     int end;\n+ *     Interval() { start = 0; end = 0; }\n+ *     Interval(int s, int e) { start = s; end = e; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n+        \n+        int i = 0;\n+\n+        while(i < intervals.size() && intervals.get(i).end < newInterval.start) i++;\n+        while(i < intervals.size() && intervals.get(i).start <= newInterval.end) {\n+            \n+            newInterval = new Interval(Math.min(intervals.get(i).start, newInterval.start), Math.max(intervals.get(i).end, newInterval.end));\n+            intervals.remove(i);\n+            \n+        }\n+        \n+        intervals.add(i, newInterval);\n+        return intervals;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/Array/missingRanges.java b/Array/missingRanges.java\n--- a/Array/missingRanges.java\n+++ b/Array/missingRanges.java\n@@ -0,0 +1,46 @@\n+// Given a sorted integer array where the range of elements are in the inclusive range [lower, upper], return its missing ranges.\n+\n+// For example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, return [\"2\", \"4->49\", \"51->74\", \"76->99\"].\n+\n+public class Solution {\n+\n+    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\n+        \n+        ArrayList<String> result = new ArrayList<String>();\n+        \n+        for(int i = 0; i <= nums.length; i++) {\n+            \n+            long start = i == 0 ? lower : (long)nums[i - 1] + 1;\n+            long end = i == nums.length ? upper : (long)nums[i] - 1;\n+            addMissing(result, start, end);\n+            \n+            \n+        }\n+        \n+        return result;\n+        \n+    }\n+    \n+    void addMissing(ArrayList<String> result, long start, long end) {\n+        \n+        if(start > end) {\n+            \n+            return;\n+            \n+        }\n+        \n+        else if(start == end) {\n+            \n+            result.add(start + \"\");\n+            \n+        }\n+        \n+        else {\n+            \n+            result.add(start + \"->\" + end);\n+            \n+        }\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/Array/subsetsII.java b/Array/subsetsII.java\n--- a/Array/subsetsII.java\n+++ b/Array/subsetsII.java\n@@ -0,0 +1,50 @@\n+// Given a collection of integers that might contain duplicates, nums, return all possible subsets.\n+\n+// Note: The solution set must not contain duplicate subsets.\n+\n+// For example,\n+// If nums = [1,2,2], a solution is:\n+\n+// [\n+//   [2],\n+//   [1],\n+//   [1,2,2],\n+//   [2,2],\n+//   [1,2],\n+//   []\n+// ]\n+\n+public class Solution {\n+\n+    public List<List<Integer>> subsetsWithDup(int[] nums) {\n+        \n+        Arrays.sort(nums);\n+        \n+        List<List<Integer>> result = new ArrayList<List<Integer>>();\n+        \n+        if(nums.length == 0 || nums == null) return result;\n+        \n+        helper(nums, new ArrayList<Integer>(), 0, result);\n+        \n+        return result;\n+        \n+    }\n+    \n+    \n+    public void helper(int[] nums, ArrayList<Integer> current, int index, List<List<Integer>> result) {\n+        \n+        result.add(current);\n+        \n+        for(int i = index; i < nums.length; i++) {\n+            \n+            if(i > index && nums[i] == nums[i - 1]) continue;\n+            \n+            ArrayList<Integer> newCurrent = new ArrayList<Integer>(current);\n+            newCurrent.add(nums[i]);\n+            helper(nums, newCurrent, i + 1, result);\n+            \n+        }\n+        \n+    }\n+    \n+}\n\\ No newline at end of file",
    "output": "Add to Array"
  },
  {
    "input": "diff --git a/Trie/addAndSearchWordDataStructureDesign.java b/Trie/addAndSearchWordDataStructureDesign.java\n--- a/Trie/addAndSearchWordDataStructureDesign.java\n+++ b/Trie/addAndSearchWordDataStructureDesign.java\n@@ -0,0 +1,85 @@\n+// Design a data structure that supports the following two operations:\n+\n+// void addWord(word)\n+// bool search(word)\n+// search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.\n+\n+// For example:\n+\n+// addWord(\"bad\")\n+// addWord(\"dad\")\n+// addWord(\"mad\")\n+// search(\"pad\") -> false\n+// search(\"bad\") -> true\n+// search(\".ad\") -> true\n+// search(\"b..\") -> true\n+\n+// Note:\n+    // You may assume that all words are consist of lowercase letters a-z.\n+\n+public class WordDictionary {\n+\n+    public class TrieNode {\n+\n+        public TrieNode[] children = new TrieNode[26];\n+        public String item = \"\";\n+\n+    }\n+    \n+    private TrieNode root = new TrieNode();\n+\n+    public void addWord(String word) {\n+\n+        TrieNode node = root;\n+\n+        for (char c : word.toCharArray()) {\n+\n+            if (node.children[c - 'a'] == null) {\n+\n+                node.children[c - 'a'] = new TrieNode();\n+            }\n+\n+            node = node.children[c - 'a'];\n+        }\n+\n+        node.item = word;\n+    }\n+\n+    public boolean search(String word) {\n+\n+        return match(word.toCharArray(), 0, root);\n+\n+    }\n+    \n+    private boolean match(char[] chs, int k, TrieNode node) {\n+\n+        if (k == chs.length) return !node.item.equals(\"\"); \n+\n+        if (chs[k] != '.') {\n+\n+            return node.children[chs[k] - 'a'] != null && match(chs, k + 1, node.children[chs[k] - 'a']);\n+\n+        } \n+\n+        else {\n+\n+            for (int i = 0; i < node.children.length; i++) {\n+\n+                if (node.children[i] != null) {\n+\n+                    if (match(chs, k + 1, node.children[i])) {\n+\n+                        return true;\n+\n+                    }\n+\n+                }\n+\n+            }\n+\n+        }\n+\n+        return false;\n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/Trie/implementTrie.java b/Trie/implementTrie.java\n--- a/Trie/implementTrie.java\n+++ b/Trie/implementTrie.java\n@@ -0,0 +1,96 @@\n+// Implement a trie with insert, search, and startsWith methods.\n+\n+// Note:\n+// You may assume that all inputs are consist of lowercase letters a-z.\n+\n+// Your Trie object will be instantiated and called as such:\n+// Trie trie = new Trie();\n+// trie.insert(\"somestring\");\n+// trie.search(\"key\");\n+\n+class TrieNode {\n+\n+    HashMap<Character, TrieNode> map;\n+    char character;\n+    boolean last;\n+    \n+    // Initialize your data structure here.\n+    public TrieNode(char character) {\n+        \n+        this.map = new HashMap<Character, TrieNode>();\n+        this.character = character;\n+        this.last = false;\n+        \n+    }\n+\n+}\n+\n+public class Trie {\n+\n+    private TrieNode root;\n+\n+    public Trie() {\n+\n+        root = new TrieNode(' ');\n+\n+    }\n+\n+    // Inserts a word into the trie.\n+    public void insert(String word) {\n+\n+        TrieNode current = root;\n+            \n+        for(char c : word.toCharArray()) {\n+            \n+            if(!current.map.containsKey(c)) {\n+                \n+                current.map.put(c, new TrieNode(c));\n+                \n+            }\n+            \n+            current = current.map.get(c);\n+\n+        }\n+        \n+        current.last = true;\n+        \n+    }\n+\n+    // Returns if the word is in the trie.\n+    public boolean search(String word) {\n+        \n+        TrieNode current = root;\n+        \n+        for(char c : word.toCharArray()) {\n+            \n+            if(!current.map.containsKey(c)) return false;\n+            \n+            current = current.map.get(c);\n+            \n+        }\n+        \n+        if(current.last == true) return true;\n+        else return false;\n+        \n+    }\n+\n+    // Returns if there is any word in the trie\n+    // that starts with the given prefix.\n+    public boolean startsWith(String prefix) {\n+        \n+        TrieNode current = root;\n+        \n+        for(char c : prefix.toCharArray()) {\n+            \n+            if(!current.map.containsKey(c)) return false;\n+            \n+            current = current.map.get(c);\n+            \n+        }\n+        \n+        return true;\n+        \n+    }\n+\n+}\n+\n\ndiff --git a/Trie/wordSquares.java b/Trie/wordSquares.java\n--- a/Trie/wordSquares.java\n+++ b/Trie/wordSquares.java\n@@ -0,0 +1,73 @@\n+// Given a set of words (without duplicates), find all word squares you can build from them.\n+\n+// A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k < max(numRows, numColumns).\n+\n+// For example, the word sequence [\"ball\",\"area\",\"lead\",\"lady\"] forms a word square because each word reads the same both horizontally and vertically.\n+\n+// b a l l\n+// a r e a\n+// l e a d\n+// l a d y\n+\n+// Note:\n+    // There are at least 1 and at most 1000 words.\n+    // All words will have the exact same length.\n+    // Word length is at least 1 and at most 5.\n+    // Each word contains only lowercase English alphabet a-z.\n+\n+public class Solution {\n+\n+    public List<List<String>> wordSquares(String[] words) {\n+\n+        List<List<String>> ret = new ArrayList<List<String>>();\n+\n+        if(words.length==0 || words[0].length()==0) return ret;\n+\n+        Map<String, Set<String>> map = new HashMap<>();\n+\n+        int squareLen = words[0].length();\n+\n+        // create all prefix\n+        for(int i=0;i<words.length;i++){\n+\n+            for(int j=-1;j<words[0].length();j++){\n+\n+                if(!map.containsKey(words[i].substring(0, j+1))) map.put(words[i].substring(0, j+1), new HashSet<String>());\n+\n+                map.get(words[i].substring(0, j+1)).add(words[i]);\n+\n+            }\n+\n+        }\n+\n+        helper(ret, new ArrayList<String>(), 0, squareLen, map);\n+\n+        return ret;\n+\n+    }\n+\n+    public void helper(List<List<String>> ret, List<String> cur, int matched, int total, Map<String, Set<String>> map){\n+\n+        if(matched == total) {ret.add(new ArrayList<String>(cur));return;}\n+\n+        // build search string\n+        StringBuilder sb = new StringBuilder();\n+\n+        for(int i=0;i<=matched-1;i++) sb.append(cur.get(i).charAt(matched));\n+\n+        // bachtracking\n+        Set<String> cand = map.get(sb.toString());\n+\n+        if(cand==null) return;\n+\n+        for(String str:cand){\n+\n+            cur.add(str);\n+            helper(ret, cur, matched+1, total, map);\n+            cur.remove(cur.size()-1);\n+\n+        }\n+\n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Add Trie"
  },
  {
    "input": "diff --git a/HashTable/loggerRateLimiter.java b/HashTable/loggerRateLimiter.java\n--- a/HashTable/loggerRateLimiter.java\n+++ b/HashTable/loggerRateLimiter.java\n@@ -67,7 +67,7 @@ public boolean shouldPrintMessage(int timestamp, String message) {\n         }\n     \n     }\n-    \n+\n }\n \n /**\n\ndiff --git a/Stack/binarySearchTreeIterator.java b/Stack/binarySearchTreeIterator.java\n--- a/Stack/binarySearchTreeIterator.java\n+++ b/Stack/binarySearchTreeIterator.java\n@@ -0,0 +1,65 @@\n+// Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.\n+\n+// Calling next() will return the next smallest number in the BST.\n+\n+// Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.\n+\n+/**\n+ * Definition for binary tree\n+ * public class TreeNode {\n+ *     int val;\n+ *     TreeNode left;\n+ *     TreeNode right;\n+ *     TreeNode(int x) { val = x; }\n+ * }\n+ */\n+\n+public class BSTIterator {\n+    \n+    Stack<TreeNode> stack;\n+\n+    public BSTIterator(TreeNode root) {\n+        \n+        stack = new Stack<TreeNode>();\n+        \n+        while(root != null) {\n+            \n+            stack.push(root);\n+            root = root.left;\n+            \n+        }\n+        \n+    }\n+\n+    /** @return whether we have a next smallest number */\n+    public boolean hasNext() {\n+        \n+        return stack.isEmpty() ? false : true;\n+        \n+    }\n+\n+    /** @return the next smallest number */\n+    public int next() {\n+        \n+        TreeNode nextSmallest = stack.pop();\n+        \n+        TreeNode addToStack = nextSmallest.right;\n+        \n+        while(addToStack != null) {\n+            \n+            stack.add(addToStack);\n+            addToStack = addToStack.left;\n+            \n+        }\n+        \n+        return nextSmallest.val;\n+        \n+    }\n+\n+}\n+\n+/**\n+ * Your BSTIterator will be called like this:\n+ * BSTIterator i = new BSTIterator(root);\n+ * while (i.hasNext()) v[f()] = i.next();\n+ */\n\\ No newline at end of file\n\ndiff --git a/Stack/decodeString.java b/Stack/decodeString.java\n--- a/Stack/decodeString.java\n+++ b/Stack/decodeString.java\n@@ -0,0 +1,94 @@\n+// Given an encoded string, return it's decoded string.\n+\n+// The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n+\n+// You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\n+\n+// Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\n+\n+public class Solution {\n+\n+    public String decodeString(String s) {\n+        \n+        //declare empty string\n+        String decoded = \"\";\n+        \n+        //initialize stack to hold counts\n+        Stack<Integer> countStack = new Stack<Integer>();\n+        \n+        //initalize stack to hold decoded string\n+        Stack<String> decodedStack = new Stack<String>();\n+        \n+        //initialize index to zero\n+        int index = 0;\n+        \n+        //iterate through entire string\n+        while(index < s.length()) {\n+            \n+            //if the current character is numeric...\n+            if(Character.isDigit(s.charAt(index))) {\n+                \n+                int count = 0;\n+                \n+                //determine the number\n+                while(Character.isDigit(s.charAt(index))) {\n+                    \n+                    count = 10 * count + (s.charAt(index) - '0');\n+                    \n+                    index++;\n+                    \n+                }\n+                \n+                //push the number onto the count stack\n+                countStack.push(count);\n+                \n+            }\n+            \n+            //if the current character is an opening bracket\n+            else if(s.charAt(index) == '[') {\n+                \n+                decodedStack.push(decoded);\n+                \n+                decoded = \"\";\n+                \n+                index++;\n+                \n+            }\n+            \n+            //if the current character is a closing bracket\n+            else if(s.charAt(index) == ']') {\n+                \n+                StringBuilder temp = new StringBuilder(decodedStack.pop());\n+                \n+                int repeatTimes = countStack.pop();\n+                \n+                for(int i = 0; i < repeatTimes; i++) {\n+                    \n+                    temp.append(decoded);\n+                    \n+                }\n+                \n+                decoded = temp.toString();\n+                \n+                index++;\n+                \n+            }\n+            \n+            //otherwise, append the current character to the decoded string\n+            else {\n+                \n+                decoded += s.charAt(index);\n+                \n+                index++;\n+                \n+            }\n+            \n+            \n+        }\n+        \n+        //return the decoded string\n+        return decoded;\n+        \n+    }\n+        \n+}\n\\ No newline at end of file\n\ndiff --git a/Stack/flattenNestedListIterator.java b/Stack/flattenNestedListIterator.java\n--- a/Stack/flattenNestedListIterator.java\n+++ b/Stack/flattenNestedListIterator.java\n@@ -0,0 +1,79 @@\n+// Given a nested list of integers, implement an iterator to flatten it.\n+\n+// Each element is either an integer, or a list -- whose elements may also be integers or other lists.\n+\n+// Example 1:\n+// Given the list [[1,1],2,[1,1]],\n+\n+// By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\n+\n+// Example 2:\n+// Given the list [1,[4,[6]]],\n+\n+// By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\n+\n+/**\n+ * // This is the interface that allows for creating nested lists.\n+ * // You should not implement it, or speculate about its implementation\n+ * public interface NestedInteger {\n+ *\n+ *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n+ *     public boolean isInteger();\n+ *\n+ *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n+ *     // Return null if this NestedInteger holds a nested list\n+ *     public Integer getInteger();\n+ *\n+ *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n+ *     // Return null if this NestedInteger holds a single integer\n+ *     public List<NestedInteger> getList();\n+ * }\n+ */\n+public class NestedIterator implements Iterator<Integer> {\n+    \n+    Stack<NestedInteger> stack = new Stack<NestedInteger>();\n+\n+    public NestedIterator(List<NestedInteger> nestedList) {\n+        \n+        for(int i = nestedList.size() - 1; i >= 0; i--) {\n+            \n+            stack.push(nestedList.get(i));\n+            \n+        }\n+        \n+    }\n+\n+    @Override\n+    public Integer next() {\n+        \n+        return stack.pop().getInteger();\n+        \n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+        \n+        while(!stack.isEmpty()) {\n+            \n+            NestedInteger current = stack.peek();\n+            if(current.isInteger()) return true;\n+            stack.pop();\n+            for(int i = current.getList().size() - 1;  i >= 0; i--) {\n+                \n+                stack.push(current.getList().get(i));\n+                \n+            }\n+            \n+        }\n+        \n+        return false;\n+        \n+    }\n+\n+}\n+\n+/**\n+ * Your NestedIterator object will be instantiated and called as such:\n+ * NestedIterator i = new NestedIterator(nestedList);\n+ * while (i.hasNext()) v[f()] = i.next();\n+ */\n\\ No newline at end of file\n\ndiff --git a/Stack/trappingRainWater.java b/Stack/trappingRainWater.java\n--- a/Stack/trappingRainWater.java\n+++ b/Stack/trappingRainWater.java\n@@ -0,0 +1,44 @@\n+// Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n+\n+// For example, \n+// Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.\n+\n+public class Solution {\n+\n+    public int trap(int[] height) {\n+        \n+        int water = 0;\n+        \n+        int leftIndex = 0;\n+        int rightIndex = height.length - 1;\n+        \n+        int leftMax = 0;\n+        int rightMax = 0;\n+        \n+        while(leftIndex <= rightIndex) {\n+            \n+            leftMax = Math.max(leftMax, height[leftIndex]);\n+            rightMax = Math.max(rightMax, height[rightIndex]);\n+            \n+            if(leftMax < rightMax) {\n+                \n+                water += leftMax - height[leftIndex];\n+                leftIndex++;\n+                \n+            }\n+            \n+            else {\n+                \n+                water += rightMax - height[rightIndex];\n+                rightIndex--;\n+                \n+            }\n+            \n+        }\n+        \n+        return water;\n+        \n+    }\n+    \n+}\n+",
    "output": "Add Stack"
  },
  {
    "input": "diff --git a/DepthFirstSearch/balancedBinaryTree.java b/DepthFirstSearch/balancedBinaryTree.java\n--- a/DepthFirstSearch/balancedBinaryTree.java\n+++ b/DepthFirstSearch/balancedBinaryTree.java\n@@ -0,0 +1,42 @@\n+// Given a binary tree, determine if it is height-balanced.\n+\n+// For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n+\n+/**\n+ * Definition for a binary tree node.\n+ * public class TreeNode {\n+ *     int val;\n+ *     TreeNode left;\n+ *     TreeNode right;\n+ *     TreeNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+    \n+    boolean balanced = true;\n+    \n+    public boolean isBalanced(TreeNode root) {\n+        \n+        height(root);\n+        return balanced;\n+        \n+    }\n+    \n+    private int height(TreeNode root) {\n+        \n+        if(root == null) return 0;\n+        \n+        int leftHeight = height(root.left);\n+        int rightHeight = height(root.right);\n+        \n+        if(Math.abs(leftHeight - rightHeight) > 1) {\n+            \n+            balanced = false;\n+            \n+        }\n+        \n+        return 1 + Math.max(leftHeight, rightHeight);\n+        \n+    }\n+    \n+}\n\\ No newline at end of file\n\ndiff --git a/DepthFirstSearch/convertSortedArrayToBinarySearchTree.java b/DepthFirstSearch/convertSortedArrayToBinarySearchTree.java\n--- a/DepthFirstSearch/convertSortedArrayToBinarySearchTree.java\n+++ b/DepthFirstSearch/convertSortedArrayToBinarySearchTree.java\n@@ -0,0 +1,43 @@\n+// Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\n+\n+/**\n+ * Definition for a binary tree node.\n+ * public class TreeNode {\n+ *     int val;\n+ *     TreeNode left;\n+ *     TreeNode right;\n+ *     TreeNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public TreeNode sortedArrayToBST(int[] nums) {\n+        \n+        if(nums.length == 0) return null;\n+        \n+        TreeNode root = helper(nums, 0, nums.length - 1);\n+        \n+        return root;\n+        \n+    }\n+    \n+    private TreeNode helper(int[] nums, int start, int end) {\n+        \n+        if(start <= end) {\n+            \n+            int mid = (start + end) / 2;\n+            \n+            TreeNode current = new TreeNode(nums[mid]);\n+            \n+            current.left = helper(nums, start, mid - 1);\n+            current.right = helper(nums, mid + 1, end);\n+            \n+            return current;\n+            \n+        }\n+        \n+        return null;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/DepthFirstSearch/maximumDepthOfABinaryTree.java b/DepthFirstSearch/maximumDepthOfABinaryTree.java\n--- a/DepthFirstSearch/maximumDepthOfABinaryTree.java\n+++ b/DepthFirstSearch/maximumDepthOfABinaryTree.java\n@@ -0,0 +1,24 @@\n+// Given a binary tree, find its maximum depth.\n+\n+// The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n+\n+/**\n+ * Definition for a binary tree node.\n+ * public class TreeNode {\n+ *     int val;\n+ *     TreeNode left;\n+ *     TreeNode right;\n+ *     TreeNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public int maxDepth(TreeNode root) {\n+        \n+        if(root == null) return 0;\n+        \n+        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/DepthFirstSearch/numberOfIslands.java b/DepthFirstSearch/numberOfIslands.java\n--- a/DepthFirstSearch/numberOfIslands.java\n+++ b/DepthFirstSearch/numberOfIslands.java\n@@ -0,0 +1,71 @@\n+// Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n+\n+// Example 1:\n+\n+// 11110\n+// 11010\n+// 11000\n+// 00000\n+// Answer: 1\n+\n+// Example 2:\n+\n+// 11000\n+// 11000\n+// 00100\n+// 00011\n+// Answer: 3\n+\n+public class Solution {\n+    \n+    char[][] gridCopy;\n+    \n+    public int numIslands(char[][] grid) {\n+        \n+        //set grid copy to the current grid\n+        gridCopy = grid;\n+        \n+        //initialize number of islands to zero\n+        int numberOfIslands = 0;\n+        \n+        //iterate through every index of the grid\n+        for(int i = 0; i < grid.length; i++) {\n+            \n+            for(int j = 0; j < grid[0].length; j++) {\n+                \n+                //attempt to \"sink\" the current index of the grid\n+                numberOfIslands += sink(gridCopy, i, j);\n+                \n+            }\n+            \n+        }\n+        \n+        //return the total number of islands\n+        return numberOfIslands;\n+        \n+    }\n+    \n+    int sink(char[][] grid, int i, int j) {\n+        \n+        //check the bounds of i and j and if the current index is an island or not (1 or 0)\n+        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') {\n+            \n+            return 0;\n+            \n+        }\n+        \n+        //set current index to 0\n+        grid[i][j] = '0';\n+        \n+        // sink all neighbors of current index\n+        sink(grid, i + 1, j);\n+        sink(grid, i - 1, j);\n+        sink(grid, i, j + 1);\n+        sink(grid, i, j - 1);\n+        \n+        //increment number of islands\n+        return 1;\n+        \n+    }\n+    \n+}\n\\ No newline at end of file\n\ndiff --git a/DepthFirstSearch/populatingNextRightPointersInEachNode.java b/DepthFirstSearch/populatingNextRightPointersInEachNode.java\n--- a/DepthFirstSearch/populatingNextRightPointersInEachNode.java\n+++ b/DepthFirstSearch/populatingNextRightPointersInEachNode.java\n@@ -0,0 +1,81 @@\n+// Given a binary tree\n+\n+//     struct TreeLinkNode {\n+//       TreeLinkNode *left;\n+//       TreeLinkNode *right;\n+//       TreeLinkNode *next;\n+//     }\n+// Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n+\n+// Initially, all next pointers are set to NULL.\n+\n+// Note:\n+\n+// You may only use constant extra space.\n+// You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).\n+// For example,\n+// Given the following perfect binary tree,\n+//          1\n+//        /  \\\n+//       2    3\n+//      / \\  / \\\n+//     4  5  6  7\n+// After calling your function, the tree should look like:\n+//          1 -> NULL\n+//        /  \\\n+//       2 -> 3 -> NULL\n+//      / \\  / \\\n+//     4->5->6->7 -> NULL\n+\n+/**\n+ * Definition for binary tree with next pointer.\n+ * public class TreeLinkNode {\n+ *     int val;\n+ *     TreeLinkNode left, right, next;\n+ *     TreeLinkNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public void connect(TreeLinkNode root) {\n+        \n+        if(root == null) return;\n+        \n+        Queue<TreeLinkNode> queue = new LinkedList<TreeLinkNode>();\n+        \n+        queue.add(root);\n+        \n+        while(!queue.isEmpty()) {\n+            \n+            Queue<TreeLinkNode> currentLevel = new LinkedList<TreeLinkNode>();\n+            \n+            TreeLinkNode temp = null;\n+            \n+            while(!queue.isEmpty()) {\n+                \n+                TreeLinkNode current = queue.remove();\n+                current.next = temp;\n+                temp = current;\n+                \n+                \n+                if(current.right != null) {\n+                    \n+                    currentLevel.add(current.right);\n+                    \n+                }\n+                \n+                if(current.left!= null) {\n+                    \n+                    currentLevel.add(current.left);\n+                }\n+                \n+                \n+            }\n+            \n+            queue = currentLevel;\n+            \n+        }\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/DepthFirstSearch/sameTree.java b/DepthFirstSearch/sameTree.java\n--- a/DepthFirstSearch/sameTree.java\n+++ b/DepthFirstSearch/sameTree.java\n@@ -0,0 +1,30 @@\n+// Given two binary trees, write a function to check if they are equal or not.\n+\n+// Two binary trees are considered equal if they are structurally identical and the nodes have the same value.\n+\n+/**\n+ * Definition for a binary tree node.\n+ * public class TreeNode {\n+ *     int val;\n+ *     TreeNode left;\n+ *     TreeNode right;\n+ *     TreeNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public boolean isSameTree(TreeNode p, TreeNode q) {\n+        \n+        if(p == null && q == null) return true;\n+        \n+        if(p == null && q != null || q == null && p != null) return false;\n+        \n+        if(p.val != q.val) return false;\n+        \n+        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n+        \n+        \n+    \n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Add to DepthFirstSearch"
  },
  {
    "input": "diff --git a/BitManipulation/binaryWatch.java b/BitManipulation/binaryWatch.java\n--- a/BitManipulation/binaryWatch.java\n+++ b/BitManipulation/binaryWatch.java\n@@ -0,0 +1,45 @@\n+// A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).\n+\n+// Each LED represents a zero or one, with the least significant bit on the right.\n+\n+// For example, the above binary watch reads \"3:25\".\n+\n+// Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.\n+\n+// Example:\n+\n+// Input: n = 1\n+// Return: [\"1:00\", \"2:00\", \"4:00\", \"8:00\", \"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\"]\n+// Note:\n+// The order of output does not matter.\n+// The hour must not contain a leading zero, for example \"01:00\" is not valid, it should be \"1:00\".\n+// The minute must be consist of two digits and may contain a leading zero, for example \"10:2\" is not valid, it should be \"10:02\".\n+\n+public class Solution {\n+\n+    public List<String> readBinaryWatch(int num) {\n+        \n+        ArrayList<String> allTimes = new ArrayList<String>();\n+        \n+        //iterate through all possible time combinations\n+        for(int i = 0; i < 12; i++) {\n+            \n+            for(int j = 0; j < 60; j++) {\n+                \n+                //if the current number and n have the same number of bits the time is possible\n+                if(Integer.bitCount(i * 64 + j) == num) {\n+                    \n+                    //add the current time to all times arraylist\n+                    allTimes.add(String.format(\"%d:%02d\", i, j));\n+                    \n+                }\n+                \n+            }\n+            \n+        }\n+        \n+        return allTimes;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/BitManipulation/countingBits.java b/BitManipulation/countingBits.java\n--- a/BitManipulation/countingBits.java\n+++ b/BitManipulation/countingBits.java\n@@ -0,0 +1,23 @@\n+// Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.\n+\n+// Example:\n+// For num = 5 you should return [0,1,1,2,1,2].\n+\n+public class Solution {\n+    public int[] countBits(int num) {\n+        \n+        int[] bits = new int[num + 1];\n+        \n+        bits[0] = 0;\n+        \n+        for(int i = 1; i <= num; i++) {\n+            \n+            bits[i] = bits[i >> 1] + (i & 1);\n+            \n+        }\n+        \n+        return bits;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/BitManipulation/hammingDistance.java b/BitManipulation/hammingDistance.java\n--- a/BitManipulation/hammingDistance.java\n+++ b/BitManipulation/hammingDistance.java\n@@ -0,0 +1,29 @@\n+// The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n+\n+// Given two integers x and y, calculate the Hamming distance.\n+\n+// Note:\n+// 0 ≤ x, y < 2^31.\n+\n+// Example:\n+\n+// Input: x = 1, y = 4\n+\n+// Output: 2\n+\n+// Explanation:\n+// 1   (0 0 0 1)\n+// 4   (0 1 0 0)\n+//        ↑   ↑\n+\n+// The above arrows point to positions where the corresponding bits are different.\n+\n+public class Solution {\n+\n+    public int hammingDistance(int x, int y) {\n+        \n+        return Integer.bitCount(x ^ y);\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/BitManipulation/maximumProductOfWordLengths.java b/BitManipulation/maximumProductOfWordLengths.java\n--- a/BitManipulation/maximumProductOfWordLengths.java\n+++ b/BitManipulation/maximumProductOfWordLengths.java\n@@ -0,0 +1,61 @@\n+// Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.\n+\n+// Example 1:\n+// Given [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"]\n+// Return 16\n+// The two words can be \"abcw\", \"xtfn\".\n+\n+// Example 2:\n+// Given [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"]\n+// Return 4\n+// The two words can be \"ab\", \"cd\".\n+\n+// Example 3:\n+// Given [\"a\", \"aa\", \"aaa\", \"aaaa\"]\n+// Return 0\n+// No such pair of words.\n+\n+public class Solution {\n+\n+    public int maxProduct(String[] words) {\n+        \n+        if(words.length == 0 || words == null) return 0;\n+        \n+        int length = words.length;\n+        int[] value = new int[length];\n+        int max = 0;\n+        \n+        for(int i = 0; i < length; i++) {\n+            \n+            String temp = words[i];\n+            \n+            value[i] = 0;\n+            \n+            for(int j = 0; j < temp.length(); j++) {\n+                \n+                value[i] |= 1 << (temp.charAt(j) - 'a');\n+                \n+            }\n+            \n+        }\n+        \n+        \n+        for(int i = 0; i < length; i++) {\n+            \n+            for(int j = 1; j < length; j++) {\n+                \n+                if((value[i] & value[j]) == 0 && (words[i].length() * words[j].length()) > max) {\n+                    \n+                    max = words[i].length() * words[j].length();\n+                    \n+                }\n+                \n+            }\n+            \n+        }\n+        \n+        return max;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/BitManipulation/numberOf1Bits.java b/BitManipulation/numberOf1Bits.java\n--- a/BitManipulation/numberOf1Bits.java\n+++ b/BitManipulation/numberOf1Bits.java\n@@ -0,0 +1,25 @@\n+// Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).\n+\n+// For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.\n+\n+public class Solution {\n+\n+    // you need to treat n as an unsigned value\n+    public int hammingWeight(int n) {\n+        \n+        if(n == 0) return 0;\n+        \n+        int count = 0;\n+        \n+        while(n != 0) {\n+            \n+            count += (n) & 1;\n+            n >>>= 1;\n+            \n+        }\n+        \n+        return count;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/BitManipulation/sumOfTwoIntegers.java b/BitManipulation/sumOfTwoIntegers.java\n--- a/BitManipulation/sumOfTwoIntegers.java\n+++ b/BitManipulation/sumOfTwoIntegers.java\n@@ -0,0 +1,25 @@\n+// Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.\n+\n+// Example:\n+// Given a = 1 and b = 2, return 3.\n+\n+public class Solution {\n+\n+    public int getSum(int a, int b) {\n+        \n+        if(a == 0) return b;\n+        if(b == 0) return a;\n+        \n+        while(b != 0) {\n+            \n+            int carry = a & b;\n+            a = a ^ b;\n+            b = carry << 1;\n+            \n+        }\n+        \n+        return a;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/BitManipulation/utf-8Validation.java b/BitManipulation/utf-8Validation.java\n--- a/BitManipulation/utf-8Validation.java\n+++ b/BitManipulation/utf-8Validation.java\n@@ -0,0 +1,63 @@\n+// A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\n+\n+// For 1-byte character, the first bit is a 0, followed by its unicode code.\n+// For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.\n+// This is how the UTF-8 encoding would work:\n+\n+//    Char. number range  |        UTF-8 octet sequence\n+//       (hexadecimal)    |              (binary)\n+//    --------------------+---------------------------------------------\n+//    0000 0000-0000 007F | 0xxxxxxx\n+//    0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n+//    0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n+//    0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+// Given an array of integers representing the data, return whether it is a valid utf-8 encoding.\n+\n+// Note:\n+// The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\n+\n+// Example 1:\n+\n+// data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.\n+\n+// Return true.\n+// It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n+// Example 2:\n+\n+// data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.\n+\n+// Return false.\n+// The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\n+// The next byte is a continuation byte which starts with 10 and that's correct.\n+// But the second continuation byte does not start with 10, so it is invalid.\n+\n+public class Solution {\n+\n+    public boolean validUtf8(int[] data) {\n+        \n+        int count = 0;\n+        for(int i : data) {\n+            \n+            if(count == 0) {\n+                \n+                if((i >> 5) == 0b110) count = 1;\n+                else if((i >> 4) == 0b1110) count = 2;\n+                else if((i >> 3) == 0b11110) count = 3;\n+                else if((i >> 7) == 0b1) return false;\n+                \n+            }\n+            \n+            else {\n+                \n+                if((i >> 6) != 0b10) return false;\n+                count--;\n+                \n+            }\n+            \n+        }\n+        \n+        return count == 0;\n+        \n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Add BitManipulation"
  },
  {
    "input": "diff --git a/LinkedList/addTwoNumbers.java b/LinkedList/addTwoNumbers.java\n--- a/LinkedList/addTwoNumbers.java\n+++ b/LinkedList/addTwoNumbers.java\n@@ -0,0 +1,62 @@\n+// You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n+\n+// You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n+\n+// Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)\n+// Output: 7 -> 0 -> 8\n+\n+/**\n+ * Definition for singly-linked list.\n+ * public class ListNode {\n+ *     int val;\n+ *     ListNode next;\n+ *     ListNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n+        \n+        ListNode current1 = l1;\n+        ListNode current2 = l2;\n+        \n+        ListNode head = new ListNode(0);\n+        ListNode currentHead = head;\n+        \n+        int sum = 0;\n+        \n+        while(current1 != null || current2 != null) {\n+            \n+            sum /= 10;\n+            \n+            if(current1 != null) {\n+                \n+                sum += current1.val;\n+                current1 = current1.next;\n+                \n+            }\n+            \n+            if(current2 != null) {\n+                \n+                sum += current2.val;\n+                current2 = current2.next;\n+                \n+            }\n+            \n+            currentHead.next = new ListNode(sum % 10);\n+            currentHead = currentHead.next;\n+            \n+        }\n+        \n+        \n+        if(sum / 10 == 1) {\n+            \n+            currentHead.next = new ListNode(1);\n+            \n+        }\n+        \n+        return head.next;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/LinkedList/deleteNodeInALinkedList.java b/LinkedList/deleteNodeInALinkedList.java\n--- a/LinkedList/deleteNodeInALinkedList.java\n+++ b/LinkedList/deleteNodeInALinkedList.java\n@@ -0,0 +1,22 @@\n+// Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.\n+\n+// Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.\n+\n+/**\n+ * Definition for singly-linked list.\n+ * public class ListNode {\n+ *     int val;\n+ *     ListNode next;\n+ *     ListNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public void deleteNode(ListNode node) {\n+        \n+        node.val = node.next.val;\n+        node.next = node.next.next;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/LinkedList/mergeKSortedLists.java b/LinkedList/mergeKSortedLists.java\n--- a/LinkedList/mergeKSortedLists.java\n+++ b/LinkedList/mergeKSortedLists.java\n@@ -0,0 +1,46 @@\n+// Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n+\n+/**\n+ * Definition for singly-linked list.\n+ * public class ListNode {\n+ *     int val;\n+ *     ListNode next;\n+ *     ListNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public ListNode mergeKLists(ListNode[] lists) {\n+\n+        if (lists==null||lists.length==0) return null;\n+        \n+        PriorityQueue<ListNode> queue= new PriorityQueue<ListNode>(lists.length,new Comparator<ListNode>(){\n+            @Override\n+            public int compare(ListNode o1,ListNode o2){\n+                if (o1.val<o2.val)\n+                    return -1;\n+                else if (o1.val==o2.val)\n+                    return 0;\n+                else \n+                    return 1;\n+            }\n+        });\n+        \n+        ListNode dummy = new ListNode(0);\n+        ListNode tail=dummy;\n+        \n+        for (ListNode node:lists)\n+            if (node!=null)\n+                queue.add(node);\n+            \n+        while (!queue.isEmpty()){\n+            tail.next=queue.poll();\n+            tail=tail.next;\n+            \n+            if (tail.next!=null)\n+                queue.add(tail.next);\n+        }\n+        return dummy.next;\n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/LinkedList/plusOneLinkedList.java b/LinkedList/plusOneLinkedList.java\n--- a/LinkedList/plusOneLinkedList.java\n+++ b/LinkedList/plusOneLinkedList.java\n@@ -0,0 +1,59 @@\n+// Given a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer.\n+\n+// You may assume the integer do not contain any leading zero, except the number 0 itself.\n+\n+// The digits are stored such that the most significant digit is at the head of the list.\n+\n+// Example:\n+// Input:\n+// 1->2->3\n+\n+// Output:\n+// 1->2->4\n+\n+/**\n+ * Definition for singly-linked list.\n+ * public class ListNode {\n+ *     int val;\n+ *     ListNode next;\n+ *     ListNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public ListNode plusOne(ListNode head) {\n+        \n+        if(plusOneRecursive(head) == 0) {\n+            \n+            return head;\n+            \n+        }\n+        \n+        else {\n+            \n+            ListNode newHead = new ListNode(1);\n+            \n+            newHead.next = head;\n+            \n+            return newHead;\n+            \n+        }\n+        \n+    }\n+    \n+    private int plusOneRecursive(ListNode head) {\n+        \n+        if(head == null) return 1;\n+        \n+        int carry = plusOneRecursive(head.next);\n+        \n+        if(carry == 0) return 0;\n+        \n+        int value = head.val + 1;\n+        head.val = value % 10;\n+        return value/10;\n+        \n+        \n+    }\n+    \n+}\n\\ No newline at end of file\n\ndiff --git a/LinkedList/reverseLinkedList.java b/LinkedList/reverseLinkedList.java\n--- a/LinkedList/reverseLinkedList.java\n+++ b/LinkedList/reverseLinkedList.java\n@@ -0,0 +1,32 @@\n+// Reverse a singly linked list.\n+\n+/**\n+ * Definition for singly-linked list.\n+ * public class ListNode {\n+ *     int val;\n+ *     ListNode next;\n+ *     ListNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public ListNode reverseList(ListNode head) {\n+        \n+        if(head == null) return head;\n+    \n+        ListNode newHead = null;\n+        \n+        while(head != null) {\n+            \n+            ListNode next = head.next;\n+            head.next = newHead;\n+            newHead = head;\n+            head = next;\n+            \n+        }\n+        \n+        return newHead;\n+        \n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Add to Linked List"
  },
  {
    "input": "diff --git a/String/reverseVowelsOfAString.java b/String/reverseVowelsOfAString.java\n--- a/String/reverseVowelsOfAString.java\n+++ b/String/reverseVowelsOfAString.java\n@@ -0,0 +1,53 @@\n+// Write a function that takes a string as input and reverse only the vowels of a string.\n+\n+// Example 1:\n+// Given s = \"hello\", return \"holle\".\n+\n+// Example 2:\n+// Given s = \"leetcode\", return \"leotcede\".\n+\n+// Note:\n+// The vowels does not include the letter \"y\".\n+\n+public class Solution {\n+\n+    public String reverseVowels(String s) {\n+        \n+        if(s == null || s.length() == 0) return s;\n+        \n+        String vowels = \"aeiouAEIOU\";\n+        \n+        char[] chars = s.toCharArray();\n+        \n+        int start = 0;\n+        int end = s.length() - 1;\n+        \n+        while(start < end) {\n+            \n+            while(start < end && !vowels.contains(chars[start] + \"\")) {\n+                \n+                start++;\n+                \n+            }\n+            \n+            while(start < end && !vowels.contains(chars[end] + \"\")) {\n+                \n+                end--;\n+                \n+            }\n+            \n+            \n+            char temp = chars[start];\n+            chars[start] = chars[end];\n+            chars[end] = temp;\n+            \n+            start++;\n+            end--;\n+            \n+        }\n+        \n+        return new String(chars);\n+        \n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Add reverseVowelsOfAString"
  },
  {
    "input": "diff --git a/palindromePermutation.java b/palindromePermutation.java\n--- a/palindromePermutation.java\n+++ b/palindromePermutation.java\n@@ -0,0 +1,35 @@\n+public class Solution {\n+\n+    public boolean canPermutePalindrome(String s) {\n+        \n+        char[] characters = new char[256];\n+        \n+        for(int i = 0; i < s.length(); i++) {\n+            \n+            characters[s.charAt(i)]++;\n+            \n+        }\n+        \n+        int oddCount = 0;\n+        \n+        for(int i = 0; i < characters.length; i++) {\n+            \n+            if(!(characters[i] % 2 == 0)) {\n+                \n+                oddCount++;\n+                \n+                if(oddCount > 1) {\n+                    \n+                    return false;\n+                    \n+                }\n+                \n+            }\n+            \n+        }\n+        \n+        return true;\n+        \n+    }\n+    \n+}\n\\ No newline at end of file",
    "output": "Add palindromePermutation"
  },
  {
    "input": "diff --git a/palindromeLinkedList.java b/palindromeLinkedList.java\n--- a/palindromeLinkedList.java\n+++ b/palindromeLinkedList.java\n@@ -0,0 +1,45 @@\n+/**\n+ * Definition for singly-linked list.\n+ * public class ListNode {\n+ *     int val;\n+ *     ListNode next;\n+ *     ListNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public boolean isPalindrome(ListNode head) {\n+        \n+        if(head == null || head.next == null) return true;\n+        \n+        Stack<Integer> stack = new Stack<Integer>();\n+        \n+        ListNode fast = head;\n+        ListNode slow = head;\n+\n+        while(fast != null && fast.next != null) {\n+            \n+            stack.push(slow.val);\n+            fast = fast.next.next;\n+            slow = slow.next;\n+            \n+        }\n+        \n+        if(fast != null) {\n+            \n+            slow = slow.next;\n+            \n+        }\n+        \n+        while(slow != null) {\n+            \n+            if(stack.pop() != slow.val) return false;\n+            slow = slow.next;\n+            \n+        }\n+        \n+        return true;\n+        \n+    }\n+    \n+}\n\\ No newline at end of file",
    "output": "Add palindromeLinkedList"
  },
  {
    "input": "diff --git a/longestPalindrome.java b/longestPalindrome.java\n--- a/longestPalindrome.java\n+++ b/longestPalindrome.java\n@@ -0,0 +1,30 @@\n+public class Solution {\n+\n+    public int longestPalindrome(String s) {\n+        \n+        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\n+        \n+        int count = 0;\n+        \n+        for(int i = 0; i < s.length(); i++) {\n+            \n+            if(!map.containsKey(s.charAt(i))) {\n+                \n+                map.put(s.charAt(i), (int)(s.charAt(i)));\n+                \n+            }\n+            \n+            else {\n+                \n+                map.remove(s.charAt(i));\n+                count++;\n+                \n+            }\n+            \n+        }\n+        \n+        return map.isEmpty() ? count * 2 : count * 2 + 1;\n+        \n+    }\n+    \n+}\n\\ No newline at end of file",
    "output": "Add longestPalindrome"
  }
]