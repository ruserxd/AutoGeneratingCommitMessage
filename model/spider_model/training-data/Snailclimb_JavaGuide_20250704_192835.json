[
  {
    "input": "diff --git a/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java b/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n--- a/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n@@ -1,49 +0,0 @@\n-package callable;\n-\n-import java.util.ArrayList;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.concurrent.ArrayBlockingQueue;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n-\n-import static common.ThreadPoolConstants.CORE_POOL_SIZE;\n-import static common.ThreadPoolConstants.KEEP_ALIVE_TIME;\n-import static common.ThreadPoolConstants.MAX_POOL_SIZE;\n-import static common.ThreadPoolConstants.QUEUE_CAPACITY;\n-\n-public class CallableDemo {\n-    public static void main(String[] args) {\n-        //使用阿里巴巴推荐的创建线程池的方式\n-        //通过ThreadPoolExecutor构造函数自定义参数创建\n-        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n-                CORE_POOL_SIZE,\n-                MAX_POOL_SIZE,\n-                KEEP_ALIVE_TIME,\n-                TimeUnit.SECONDS,\n-                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n-                new ThreadPoolExecutor.CallerRunsPolicy());\n-\n-        List<Future<String>> futureList = new ArrayList<>();\n-        Callable<String> callable = new MyCallable();\n-        for (int i = 0; i < 10; i++) {\n-            //提交任务到线程池\n-            Future<String> future = executor.submit(callable);\n-            //将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值\n-            futureList.add(future);\n-        }\n-        for (Future<String> fut : futureList) {\n-            try {\n-                System.out.println(new Date() + \"::\" + fut.get());\n-            } catch (InterruptedException | ExecutionException e) {\n-                e.printStackTrace();\n-            }\n-        }\n-        //关闭线程池\n-        executor.shutdown();\n-    }\n-}\n-\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java b/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n--- a/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n@@ -1,13 +0,0 @@\n-package callable;\n-\n-import java.util.concurrent.Callable;\n-\n-public class MyCallable implements Callable<String> {\n-\n-    @Override\n-    public String call() throws Exception {\n-        Thread.sleep(1000);\n-        //返回执行当前 Callable 的线程名字\n-        return Thread.currentThread().getName();\n-    }\n-}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java b/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n--- a/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n@@ -1,11 +0,0 @@\n-package common;\n-\n-public class ThreadPoolConstants {\n-    public static final int CORE_POOL_SIZE = 5;\n-    public static final int MAX_POOL_SIZE = 10;\n-    public static final int QUEUE_CAPACITY = 100;\n-    public static final Long KEEP_ALIVE_TIME = 1L;\n-    private ThreadPoolConstants(){\n-\n-    }\n-}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n--- a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n@@ -1,36 +0,0 @@\n-package threadPoolExecutor;\n-\n-import java.util.Date;\n-\n-/**\n- * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。\n- * @author shuang.kou\n- */\n-public class MyRunnable implements Runnable {\n-\n-    private String command;\n-\n-    public MyRunnable(String s) {\n-        this.command = s;\n-    }\n-\n-    @Override\n-    public void run() {\n-        System.out.println(Thread.currentThread().getName() + \" Start. Time = \" + new Date());\n-        processCommand();\n-        System.out.println(Thread.currentThread().getName() + \" End. Time = \" + new Date());\n-    }\n-\n-    private void processCommand() {\n-        try {\n-            Thread.sleep(5000);\n-        } catch (InterruptedException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return this.command;\n-    }\n-}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n--- a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n@@ -1,39 +0,0 @@\n-package threadPoolExecutor;\n-\n-import java.util.concurrent.ArrayBlockingQueue;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n-\n-import static common.ThreadPoolConstants.CORE_POOL_SIZE;\n-import static common.ThreadPoolConstants.KEEP_ALIVE_TIME;\n-import static common.ThreadPoolConstants.MAX_POOL_SIZE;\n-import static common.ThreadPoolConstants.QUEUE_CAPACITY;\n-\n-\n-public class ThreadPoolExecutorDemo {\n-\n-    public static void main(String[] args) {\n-\n-        //使用阿里巴巴推荐的创建线程池的方式\n-        //通过ThreadPoolExecutor构造函数自定义参数创建\n-        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n-                CORE_POOL_SIZE,\n-                MAX_POOL_SIZE,\n-                KEEP_ALIVE_TIME,\n-                TimeUnit.SECONDS,\n-                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n-                new ThreadPoolExecutor.CallerRunsPolicy());\n-\n-        for (int i = 0; i < 10; i++) {\n-            //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）\n-            Runnable worker = new MyRunnable(\"\" + i);\n-            //执行Runnable\n-            executor.execute(worker);\n-        }\n-        //终止线程池\n-        executor.shutdown();\n-        while (!executor.isTerminated()) {\n-        }\n-        System.out.println(\"Finished all threads\");\n-    }\n-}",
    "output": "Merge branch 'master' of https://github.com/shahainloong/JavaGuide"
  },
  {
    "input": "diff --git a/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java b/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n--- a/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n@@ -1,49 +0,0 @@\n-package callable;\n-\n-import java.util.ArrayList;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.concurrent.ArrayBlockingQueue;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n-\n-import static common.ThreadPoolConstants.CORE_POOL_SIZE;\n-import static common.ThreadPoolConstants.KEEP_ALIVE_TIME;\n-import static common.ThreadPoolConstants.MAX_POOL_SIZE;\n-import static common.ThreadPoolConstants.QUEUE_CAPACITY;\n-\n-public class CallableDemo {\n-    public static void main(String[] args) {\n-        //使用阿里巴巴推荐的创建线程池的方式\n-        //通过ThreadPoolExecutor构造函数自定义参数创建\n-        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n-                CORE_POOL_SIZE,\n-                MAX_POOL_SIZE,\n-                KEEP_ALIVE_TIME,\n-                TimeUnit.SECONDS,\n-                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n-                new ThreadPoolExecutor.CallerRunsPolicy());\n-\n-        List<Future<String>> futureList = new ArrayList<>();\n-        Callable<String> callable = new MyCallable();\n-        for (int i = 0; i < 10; i++) {\n-            //提交任务到线程池\n-            Future<String> future = executor.submit(callable);\n-            //将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值\n-            futureList.add(future);\n-        }\n-        for (Future<String> fut : futureList) {\n-            try {\n-                System.out.println(new Date() + \"::\" + fut.get());\n-            } catch (InterruptedException | ExecutionException e) {\n-                e.printStackTrace();\n-            }\n-        }\n-        //关闭线程池\n-        executor.shutdown();\n-    }\n-}\n-\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java b/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n--- a/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n@@ -1,13 +0,0 @@\n-package callable;\n-\n-import java.util.concurrent.Callable;\n-\n-public class MyCallable implements Callable<String> {\n-\n-    @Override\n-    public String call() throws Exception {\n-        Thread.sleep(1000);\n-        //返回执行当前 Callable 的线程名字\n-        return Thread.currentThread().getName();\n-    }\n-}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java b/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n--- a/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n@@ -1,11 +0,0 @@\n-package common;\n-\n-public class ThreadPoolConstants {\n-    public static final int CORE_POOL_SIZE = 5;\n-    public static final int MAX_POOL_SIZE = 10;\n-    public static final int QUEUE_CAPACITY = 100;\n-    public static final Long KEEP_ALIVE_TIME = 1L;\n-    private ThreadPoolConstants(){\n-\n-    }\n-}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n--- a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n@@ -1,36 +0,0 @@\n-package threadPoolExecutor;\n-\n-import java.util.Date;\n-\n-/**\n- * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。\n- * @author shuang.kou\n- */\n-public class MyRunnable implements Runnable {\n-\n-    private String command;\n-\n-    public MyRunnable(String s) {\n-        this.command = s;\n-    }\n-\n-    @Override\n-    public void run() {\n-        System.out.println(Thread.currentThread().getName() + \" Start. Time = \" + new Date());\n-        processCommand();\n-        System.out.println(Thread.currentThread().getName() + \" End. Time = \" + new Date());\n-    }\n-\n-    private void processCommand() {\n-        try {\n-            Thread.sleep(5000);\n-        } catch (InterruptedException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return this.command;\n-    }\n-}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n--- a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n@@ -1,39 +0,0 @@\n-package threadPoolExecutor;\n-\n-import java.util.concurrent.ArrayBlockingQueue;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n-\n-import static common.ThreadPoolConstants.CORE_POOL_SIZE;\n-import static common.ThreadPoolConstants.KEEP_ALIVE_TIME;\n-import static common.ThreadPoolConstants.MAX_POOL_SIZE;\n-import static common.ThreadPoolConstants.QUEUE_CAPACITY;\n-\n-\n-public class ThreadPoolExecutorDemo {\n-\n-    public static void main(String[] args) {\n-\n-        //使用阿里巴巴推荐的创建线程池的方式\n-        //通过ThreadPoolExecutor构造函数自定义参数创建\n-        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n-                CORE_POOL_SIZE,\n-                MAX_POOL_SIZE,\n-                KEEP_ALIVE_TIME,\n-                TimeUnit.SECONDS,\n-                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n-                new ThreadPoolExecutor.CallerRunsPolicy());\n-\n-        for (int i = 0; i < 10; i++) {\n-            //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）\n-            Runnable worker = new MyRunnable(\"\" + i);\n-            //执行Runnable\n-            executor.execute(worker);\n-        }\n-        //终止线程池\n-        executor.shutdown();\n-        while (!executor.isTerminated()) {\n-        }\n-        System.out.println(\"Finished all threads\");\n-    }\n-}",
    "output": "Merge pull request #11 from Snailclimb/master\n\nDaily update"
  },
  {
    "input": "diff --git a/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java b/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n--- a/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n@@ -1,49 +0,0 @@\n-package callable;\n-\n-import java.util.ArrayList;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.concurrent.ArrayBlockingQueue;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n-\n-import static common.ThreadPoolConstants.CORE_POOL_SIZE;\n-import static common.ThreadPoolConstants.KEEP_ALIVE_TIME;\n-import static common.ThreadPoolConstants.MAX_POOL_SIZE;\n-import static common.ThreadPoolConstants.QUEUE_CAPACITY;\n-\n-public class CallableDemo {\n-    public static void main(String[] args) {\n-        //使用阿里巴巴推荐的创建线程池的方式\n-        //通过ThreadPoolExecutor构造函数自定义参数创建\n-        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n-                CORE_POOL_SIZE,\n-                MAX_POOL_SIZE,\n-                KEEP_ALIVE_TIME,\n-                TimeUnit.SECONDS,\n-                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n-                new ThreadPoolExecutor.CallerRunsPolicy());\n-\n-        List<Future<String>> futureList = new ArrayList<>();\n-        Callable<String> callable = new MyCallable();\n-        for (int i = 0; i < 10; i++) {\n-            //提交任务到线程池\n-            Future<String> future = executor.submit(callable);\n-            //将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值\n-            futureList.add(future);\n-        }\n-        for (Future<String> fut : futureList) {\n-            try {\n-                System.out.println(new Date() + \"::\" + fut.get());\n-            } catch (InterruptedException | ExecutionException e) {\n-                e.printStackTrace();\n-            }\n-        }\n-        //关闭线程池\n-        executor.shutdown();\n-    }\n-}\n-\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java b/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n--- a/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n@@ -1,13 +0,0 @@\n-package callable;\n-\n-import java.util.concurrent.Callable;\n-\n-public class MyCallable implements Callable<String> {\n-\n-    @Override\n-    public String call() throws Exception {\n-        Thread.sleep(1000);\n-        //返回执行当前 Callable 的线程名字\n-        return Thread.currentThread().getName();\n-    }\n-}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java b/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n--- a/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n@@ -1,11 +0,0 @@\n-package common;\n-\n-public class ThreadPoolConstants {\n-    public static final int CORE_POOL_SIZE = 5;\n-    public static final int MAX_POOL_SIZE = 10;\n-    public static final int QUEUE_CAPACITY = 100;\n-    public static final Long KEEP_ALIVE_TIME = 1L;\n-    private ThreadPoolConstants(){\n-\n-    }\n-}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n--- a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n@@ -1,36 +0,0 @@\n-package threadPoolExecutor;\n-\n-import java.util.Date;\n-\n-/**\n- * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。\n- * @author shuang.kou\n- */\n-public class MyRunnable implements Runnable {\n-\n-    private String command;\n-\n-    public MyRunnable(String s) {\n-        this.command = s;\n-    }\n-\n-    @Override\n-    public void run() {\n-        System.out.println(Thread.currentThread().getName() + \" Start. Time = \" + new Date());\n-        processCommand();\n-        System.out.println(Thread.currentThread().getName() + \" End. Time = \" + new Date());\n-    }\n-\n-    private void processCommand() {\n-        try {\n-            Thread.sleep(5000);\n-        } catch (InterruptedException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return this.command;\n-    }\n-}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n--- a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n@@ -1,39 +0,0 @@\n-package threadPoolExecutor;\n-\n-import java.util.concurrent.ArrayBlockingQueue;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n-\n-import static common.ThreadPoolConstants.CORE_POOL_SIZE;\n-import static common.ThreadPoolConstants.KEEP_ALIVE_TIME;\n-import static common.ThreadPoolConstants.MAX_POOL_SIZE;\n-import static common.ThreadPoolConstants.QUEUE_CAPACITY;\n-\n-\n-public class ThreadPoolExecutorDemo {\n-\n-    public static void main(String[] args) {\n-\n-        //使用阿里巴巴推荐的创建线程池的方式\n-        //通过ThreadPoolExecutor构造函数自定义参数创建\n-        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n-                CORE_POOL_SIZE,\n-                MAX_POOL_SIZE,\n-                KEEP_ALIVE_TIME,\n-                TimeUnit.SECONDS,\n-                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n-                new ThreadPoolExecutor.CallerRunsPolicy());\n-\n-        for (int i = 0; i < 10; i++) {\n-            //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）\n-            Runnable worker = new MyRunnable(\"\" + i);\n-            //执行Runnable\n-            executor.execute(worker);\n-        }\n-        //终止线程池\n-        executor.shutdown();\n-        while (!executor.isTerminated()) {\n-        }\n-        System.out.println(\"Finished all threads\");\n-    }\n-}",
    "output": "Merge pull request #4 from Snailclimb/master\n\nmerge"
  },
  {
    "input": "diff --git a/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java b/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n--- a/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n@@ -0,0 +1,49 @@\n+package callable;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import static common.ThreadPoolConstants.CORE_POOL_SIZE;\n+import static common.ThreadPoolConstants.KEEP_ALIVE_TIME;\n+import static common.ThreadPoolConstants.MAX_POOL_SIZE;\n+import static common.ThreadPoolConstants.QUEUE_CAPACITY;\n+\n+public class CallableDemo {\n+    public static void main(String[] args) {\n+        //使用阿里巴巴推荐的创建线程池的方式\n+        //通过ThreadPoolExecutor构造函数自定义参数创建\n+        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n+                CORE_POOL_SIZE,\n+                MAX_POOL_SIZE,\n+                KEEP_ALIVE_TIME,\n+                TimeUnit.SECONDS,\n+                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n+                new ThreadPoolExecutor.CallerRunsPolicy());\n+\n+        List<Future<String>> futureList = new ArrayList<>();\n+        Callable<String> callable = new MyCallable();\n+        for (int i = 0; i < 10; i++) {\n+            //提交任务到线程池\n+            Future<String> future = executor.submit(callable);\n+            //将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值\n+            futureList.add(future);\n+        }\n+        for (Future<String> fut : futureList) {\n+            try {\n+                System.out.println(new Date() + \"::\" + fut.get());\n+            } catch (InterruptedException | ExecutionException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+        //关闭线程池\n+        executor.shutdown();\n+    }\n+}\n+\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java b/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n--- a/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n@@ -0,0 +1,13 @@\n+package callable;\n+\n+import java.util.concurrent.Callable;\n+\n+public class MyCallable implements Callable<String> {\n+\n+    @Override\n+    public String call() throws Exception {\n+        Thread.sleep(1000);\n+        //返回执行当前 Callable 的线程名字\n+        return Thread.currentThread().getName();\n+    }\n+}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java b/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n--- a/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n@@ -0,0 +1,11 @@\n+package common;\n+\n+public class ThreadPoolConstants {\n+    public static final int CORE_POOL_SIZE = 5;\n+    public static final int MAX_POOL_SIZE = 10;\n+    public static final int QUEUE_CAPACITY = 100;\n+    public static final Long KEEP_ALIVE_TIME = 1L;\n+    private ThreadPoolConstants(){\n+\n+    }\n+}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n--- a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n@@ -0,0 +1,36 @@\n+package threadPoolExecutor;\n+\n+import java.util.Date;\n+\n+/**\n+ * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。\n+ * @author shuang.kou\n+ */\n+public class MyRunnable implements Runnable {\n+\n+    private String command;\n+\n+    public MyRunnable(String s) {\n+        this.command = s;\n+    }\n+\n+    @Override\n+    public void run() {\n+        System.out.println(Thread.currentThread().getName() + \" Start. Time = \" + new Date());\n+        processCommand();\n+        System.out.println(Thread.currentThread().getName() + \" End. Time = \" + new Date());\n+    }\n+\n+    private void processCommand() {\n+        try {\n+            Thread.sleep(5000);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return this.command;\n+    }\n+}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n--- a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n@@ -0,0 +1,39 @@\n+package threadPoolExecutor;\n+\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import static common.ThreadPoolConstants.CORE_POOL_SIZE;\n+import static common.ThreadPoolConstants.KEEP_ALIVE_TIME;\n+import static common.ThreadPoolConstants.MAX_POOL_SIZE;\n+import static common.ThreadPoolConstants.QUEUE_CAPACITY;\n+\n+\n+public class ThreadPoolExecutorDemo {\n+\n+    public static void main(String[] args) {\n+\n+        //使用阿里巴巴推荐的创建线程池的方式\n+        //通过ThreadPoolExecutor构造函数自定义参数创建\n+        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n+                CORE_POOL_SIZE,\n+                MAX_POOL_SIZE,\n+                KEEP_ALIVE_TIME,\n+                TimeUnit.SECONDS,\n+                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n+                new ThreadPoolExecutor.CallerRunsPolicy());\n+\n+        for (int i = 0; i < 10; i++) {\n+            //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）\n+            Runnable worker = new MyRunnable(\"\" + i);\n+            //执行Runnable\n+            executor.execute(worker);\n+        }\n+        //终止线程池\n+        executor.shutdown();\n+        while (!executor.isTerminated()) {\n+        }\n+        System.out.println(\"Finished all threads\");\n+    }\n+}",
    "output": "Merge pull request #1 from Snailclimb/master\n\nupdate fork"
  },
  {
    "input": "diff --git a/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java b/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n--- a/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/callable/CallableDemo.java\n@@ -0,0 +1,49 @@\n+package callable;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import static common.ThreadPoolConstants.CORE_POOL_SIZE;\n+import static common.ThreadPoolConstants.KEEP_ALIVE_TIME;\n+import static common.ThreadPoolConstants.MAX_POOL_SIZE;\n+import static common.ThreadPoolConstants.QUEUE_CAPACITY;\n+\n+public class CallableDemo {\n+    public static void main(String[] args) {\n+        //使用阿里巴巴推荐的创建线程池的方式\n+        //通过ThreadPoolExecutor构造函数自定义参数创建\n+        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n+                CORE_POOL_SIZE,\n+                MAX_POOL_SIZE,\n+                KEEP_ALIVE_TIME,\n+                TimeUnit.SECONDS,\n+                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n+                new ThreadPoolExecutor.CallerRunsPolicy());\n+\n+        List<Future<String>> futureList = new ArrayList<>();\n+        Callable<String> callable = new MyCallable();\n+        for (int i = 0; i < 10; i++) {\n+            //提交任务到线程池\n+            Future<String> future = executor.submit(callable);\n+            //将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值\n+            futureList.add(future);\n+        }\n+        for (Future<String> fut : futureList) {\n+            try {\n+                System.out.println(new Date() + \"::\" + fut.get());\n+            } catch (InterruptedException | ExecutionException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+        //关闭线程池\n+        executor.shutdown();\n+    }\n+}\n+\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java b/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n--- a/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/callable/MyCallable.java\n@@ -0,0 +1,13 @@\n+package callable;\n+\n+import java.util.concurrent.Callable;\n+\n+public class MyCallable implements Callable<String> {\n+\n+    @Override\n+    public String call() throws Exception {\n+        Thread.sleep(1000);\n+        //返回执行当前 Callable 的线程名字\n+        return Thread.currentThread().getName();\n+    }\n+}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java b/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n--- a/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/common/ThreadPoolConstants.java\n@@ -0,0 +1,11 @@\n+package common;\n+\n+public class ThreadPoolConstants {\n+    public static final int CORE_POOL_SIZE = 5;\n+    public static final int MAX_POOL_SIZE = 10;\n+    public static final int QUEUE_CAPACITY = 100;\n+    public static final Long KEEP_ALIVE_TIME = 1L;\n+    private ThreadPoolConstants(){\n+\n+    }\n+}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n--- a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/MyRunnable.java\n@@ -0,0 +1,36 @@\n+package threadPoolExecutor;\n+\n+import java.util.Date;\n+\n+/**\n+ * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。\n+ * @author shuang.kou\n+ */\n+public class MyRunnable implements Runnable {\n+\n+    private String command;\n+\n+    public MyRunnable(String s) {\n+        this.command = s;\n+    }\n+\n+    @Override\n+    public void run() {\n+        System.out.println(Thread.currentThread().getName() + \" Start. Time = \" + new Date());\n+        processCommand();\n+        System.out.println(Thread.currentThread().getName() + \" End. Time = \" + new Date());\n+    }\n+\n+    private void processCommand() {\n+        try {\n+            Thread.sleep(5000);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return this.command;\n+    }\n+}\n\ndiff --git a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n--- a/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n+++ b/code/java/ThreadPoolExecutorDemo/src/threadPoolExecutor/ThreadPoolExecutorDemo.java\n@@ -0,0 +1,39 @@\n+package threadPoolExecutor;\n+\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import static common.ThreadPoolConstants.CORE_POOL_SIZE;\n+import static common.ThreadPoolConstants.KEEP_ALIVE_TIME;\n+import static common.ThreadPoolConstants.MAX_POOL_SIZE;\n+import static common.ThreadPoolConstants.QUEUE_CAPACITY;\n+\n+\n+public class ThreadPoolExecutorDemo {\n+\n+    public static void main(String[] args) {\n+\n+        //使用阿里巴巴推荐的创建线程池的方式\n+        //通过ThreadPoolExecutor构造函数自定义参数创建\n+        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n+                CORE_POOL_SIZE,\n+                MAX_POOL_SIZE,\n+                KEEP_ALIVE_TIME,\n+                TimeUnit.SECONDS,\n+                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n+                new ThreadPoolExecutor.CallerRunsPolicy());\n+\n+        for (int i = 0; i < 10; i++) {\n+            //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）\n+            Runnable worker = new MyRunnable(\"\" + i);\n+            //执行Runnable\n+            executor.execute(worker);\n+        }\n+        //终止线程池\n+        executor.shutdown();\n+        while (!executor.isTerminated()) {\n+        }\n+        System.out.println(\"Finished all threads\");\n+    }\n+}",
    "output": "Merge remote-tracking branch 'remotes/origin/dev'\n\n# Conflicts:\n#\t.gitignore"
  }
]