[
  {
    "input": "diff --git a/company/google/PowerOfTwo.java b/company/google/PowerOfTwo.java\n--- a/company/google/PowerOfTwo.java\n+++ b/company/google/PowerOfTwo.java\n@@ -0,0 +1,25 @@\n+//Given an integer, write a function to determine if it is a power of two.\n+//\n+//Example 1:\n+//\n+//Input: 1\n+//Output: true\n+//Example 2:\n+//\n+//Input: 16\n+//Output: true\n+//Example 3:\n+//\n+//Input: 218\n+//Output: false\n+\n+class PowerOfTwo {\n+    public boolean isPowerOfTwo(int n) {\n+        long i = 1;\n+        while(i < n) {\n+            i <<= 1;\n+        }\n+        \n+        return i == n;\n+    }\n+}\n\ndiff --git a/leetcode/bit-manipulation/PowerOfTwo.java b/leetcode/bit-manipulation/PowerOfTwo.java\n--- a/leetcode/bit-manipulation/PowerOfTwo.java\n+++ b/leetcode/bit-manipulation/PowerOfTwo.java\n@@ -0,0 +1,25 @@\n+//Given an integer, write a function to determine if it is a power of two.\n+//\n+//Example 1:\n+//\n+//Input: 1\n+//Output: true\n+//Example 2:\n+//\n+//Input: 16\n+//Output: true\n+//Example 3:\n+//\n+//Input: 218\n+//Output: false\n+\n+class PowerOfTwo {\n+    public boolean isPowerOfTwo(int n) {\n+        long i = 1;\n+        while(i < n) {\n+            i <<= 1;\n+        }\n+        \n+        return i == n;\n+    }\n+}\n\ndiff --git a/leetcode/math/PowerOfTwo.java b/leetcode/math/PowerOfTwo.java\n--- a/leetcode/math/PowerOfTwo.java\n+++ b/leetcode/math/PowerOfTwo.java\n@@ -0,0 +1,25 @@\n+//Given an integer, write a function to determine if it is a power of two.\n+//\n+//Example 1:\n+//\n+//Input: 1\n+//Output: true\n+//Example 2:\n+//\n+//Input: 16\n+//Output: true\n+//Example 3:\n+//\n+//Input: 218\n+//Output: false\n+\n+class PowerOfTwo {\n+    public boolean isPowerOfTwo(int n) {\n+        long i = 1;\n+        while(i < n) {\n+            i <<= 1;\n+        }\n+        \n+        return i == n;\n+    }\n+}",
    "output": "added PowerOfTwo.java"
  },
  {
    "input": "diff --git a/company/google/SpiralMatrix.java b/company/google/SpiralMatrix.java\n--- a/company/google/SpiralMatrix.java\n+++ b/company/google/SpiralMatrix.java\n@@ -0,0 +1,61 @@\n+//Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n+//\n+//Example 1:\n+//\n+//Input:\n+//[\n+ //[ 1, 2, 3 ],\n+ //[ 4, 5, 6 ],\n+ //[ 7, 8, 9 ]\n+//]\n+//Output: [1,2,3,6,9,8,7,4,5]\n+//Example 2:\n+//\n+//Input:\n+//[\n+  //[1, 2, 3, 4],\n+  //[5, 6, 7, 8],\n+  //[9,10,11,12]\n+//]\n+//Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n+\n+class SpiralMatrix {\n+    public List<Integer> spiralOrder(int[][] matrix) {\n+        List<Integer> result = new ArrayList<Integer>();\n+        if(matrix == null || matrix.length == 0) {\n+            return result;\n+        }\n+        \n+        int rowStart = 0;\n+        int rowEnd = matrix.length - 1;\n+        int colStart = 0;\n+        int colEnd = matrix[0].length - 1;\n+        while(rowStart <= rowEnd && colStart <= colEnd) {\n+            for(int i = colStart; i <= colEnd; i++) {\n+                result.add(matrix[rowStart][i]);\n+            }\n+            rowStart++;\n+            \n+            for(int i = rowStart; i <= rowEnd; i++) {\n+                result.add(matrix[i][colEnd]);\n+            }\n+            colEnd--;\n+            \n+            if(rowStart <= rowEnd) {\n+                for(int i = colEnd; i >= colStart; i--) {\n+                    result.add(matrix[rowEnd][i]);\n+                }\n+            }\n+            rowEnd--;\n+            \n+            if(colStart <= colEnd) {\n+                for(int i = rowEnd; i >= rowStart; i--) {\n+                    result.add(matrix[i][colStart]);\n+                }\n+            }   \n+            colStart++;\n+        }\n+        \n+        return result;\n+    }\n+}\n\ndiff --git a/company/microsoft/SpiralMatrix.java b/company/microsoft/SpiralMatrix.java\n--- a/company/microsoft/SpiralMatrix.java\n+++ b/company/microsoft/SpiralMatrix.java\n@@ -0,0 +1,61 @@\n+//Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n+//\n+//Example 1:\n+//\n+//Input:\n+//[\n+ //[ 1, 2, 3 ],\n+ //[ 4, 5, 6 ],\n+ //[ 7, 8, 9 ]\n+//]\n+//Output: [1,2,3,6,9,8,7,4,5]\n+//Example 2:\n+//\n+//Input:\n+//[\n+  //[1, 2, 3, 4],\n+  //[5, 6, 7, 8],\n+  //[9,10,11,12]\n+//]\n+//Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n+\n+class SpiralMatrix {\n+    public List<Integer> spiralOrder(int[][] matrix) {\n+        List<Integer> result = new ArrayList<Integer>();\n+        if(matrix == null || matrix.length == 0) {\n+            return result;\n+        }\n+        \n+        int rowStart = 0;\n+        int rowEnd = matrix.length - 1;\n+        int colStart = 0;\n+        int colEnd = matrix[0].length - 1;\n+        while(rowStart <= rowEnd && colStart <= colEnd) {\n+            for(int i = colStart; i <= colEnd; i++) {\n+                result.add(matrix[rowStart][i]);\n+            }\n+            rowStart++;\n+            \n+            for(int i = rowStart; i <= rowEnd; i++) {\n+                result.add(matrix[i][colEnd]);\n+            }\n+            colEnd--;\n+            \n+            if(rowStart <= rowEnd) {\n+                for(int i = colEnd; i >= colStart; i--) {\n+                    result.add(matrix[rowEnd][i]);\n+                }\n+            }\n+            rowEnd--;\n+            \n+            if(colStart <= colEnd) {\n+                for(int i = rowEnd; i >= rowStart; i--) {\n+                    result.add(matrix[i][colStart]);\n+                }\n+            }   \n+            colStart++;\n+        }\n+        \n+        return result;\n+    }\n+}\n\ndiff --git a/company/uber/SpiralMatrix.java b/company/uber/SpiralMatrix.java\n--- a/company/uber/SpiralMatrix.java\n+++ b/company/uber/SpiralMatrix.java\n@@ -0,0 +1,61 @@\n+//Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n+//\n+//Example 1:\n+//\n+//Input:\n+//[\n+ //[ 1, 2, 3 ],\n+ //[ 4, 5, 6 ],\n+ //[ 7, 8, 9 ]\n+//]\n+//Output: [1,2,3,6,9,8,7,4,5]\n+//Example 2:\n+//\n+//Input:\n+//[\n+  //[1, 2, 3, 4],\n+  //[5, 6, 7, 8],\n+  //[9,10,11,12]\n+//]\n+//Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n+\n+class SpiralMatrix {\n+    public List<Integer> spiralOrder(int[][] matrix) {\n+        List<Integer> result = new ArrayList<Integer>();\n+        if(matrix == null || matrix.length == 0) {\n+            return result;\n+        }\n+        \n+        int rowStart = 0;\n+        int rowEnd = matrix.length - 1;\n+        int colStart = 0;\n+        int colEnd = matrix[0].length - 1;\n+        while(rowStart <= rowEnd && colStart <= colEnd) {\n+            for(int i = colStart; i <= colEnd; i++) {\n+                result.add(matrix[rowStart][i]);\n+            }\n+            rowStart++;\n+            \n+            for(int i = rowStart; i <= rowEnd; i++) {\n+                result.add(matrix[i][colEnd]);\n+            }\n+            colEnd--;\n+            \n+            if(rowStart <= rowEnd) {\n+                for(int i = colEnd; i >= colStart; i--) {\n+                    result.add(matrix[rowEnd][i]);\n+                }\n+            }\n+            rowEnd--;\n+            \n+            if(colStart <= colEnd) {\n+                for(int i = rowEnd; i >= rowStart; i--) {\n+                    result.add(matrix[i][colStart]);\n+                }\n+            }   \n+            colStart++;\n+        }\n+        \n+        return result;\n+    }\n+}\n\ndiff --git a/leetcode/array/SpiralMatrix.java b/leetcode/array/SpiralMatrix.java\n--- a/leetcode/array/SpiralMatrix.java\n+++ b/leetcode/array/SpiralMatrix.java\n@@ -0,0 +1,61 @@\n+//Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n+//\n+//Example 1:\n+//\n+//Input:\n+//[\n+ //[ 1, 2, 3 ],\n+ //[ 4, 5, 6 ],\n+ //[ 7, 8, 9 ]\n+//]\n+//Output: [1,2,3,6,9,8,7,4,5]\n+//Example 2:\n+//\n+//Input:\n+//[\n+  //[1, 2, 3, 4],\n+  //[5, 6, 7, 8],\n+  //[9,10,11,12]\n+//]\n+//Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n+\n+class SpiralMatrix {\n+    public List<Integer> spiralOrder(int[][] matrix) {\n+        List<Integer> result = new ArrayList<Integer>();\n+        if(matrix == null || matrix.length == 0) {\n+            return result;\n+        }\n+        \n+        int rowStart = 0;\n+        int rowEnd = matrix.length - 1;\n+        int colStart = 0;\n+        int colEnd = matrix[0].length - 1;\n+        while(rowStart <= rowEnd && colStart <= colEnd) {\n+            for(int i = colStart; i <= colEnd; i++) {\n+                result.add(matrix[rowStart][i]);\n+            }\n+            rowStart++;\n+            \n+            for(int i = rowStart; i <= rowEnd; i++) {\n+                result.add(matrix[i][colEnd]);\n+            }\n+            colEnd--;\n+            \n+            if(rowStart <= rowEnd) {\n+                for(int i = colEnd; i >= colStart; i--) {\n+                    result.add(matrix[rowEnd][i]);\n+                }\n+            }\n+            rowEnd--;\n+            \n+            if(colStart <= colEnd) {\n+                for(int i = rowEnd; i >= rowStart; i--) {\n+                    result.add(matrix[i][colStart]);\n+                }\n+            }   \n+            colStart++;\n+        }\n+        \n+        return result;\n+    }\n+}",
    "output": "added SpiralMatrix.java"
  },
  {
    "input": "diff --git a/company/google/DailyTemperatures.java b/company/google/DailyTemperatures.java\n--- a/company/google/DailyTemperatures.java\n+++ b/company/google/DailyTemperatures.java\n@@ -0,0 +1,21 @@\n+//Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.\n+//\n+//For example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].\n+//\n+//Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].\n+\n+class DailyTemperatures {\n+    public int[] dailyTemperatures(int[] temperatures) {\n+        int[] result = new int[temperatures.length];\n+        Stack<Integer> stack = new Stack<Integer>();\n+        for(int i = 0; i < temperatures.length; i++) {\n+            while(!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n+                int index = stack.pop();\n+                result[index] = i - index;\n+            }\n+            stack.push(i);\n+        }\n+        \n+        return result;\n+    }\n+}\n\ndiff --git a/leetcode/hash-table/DailyTemperatures.java b/leetcode/hash-table/DailyTemperatures.java\n--- a/leetcode/hash-table/DailyTemperatures.java\n+++ b/leetcode/hash-table/DailyTemperatures.java\n@@ -0,0 +1,21 @@\n+//Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.\n+//\n+//For example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].\n+//\n+//Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].\n+\n+class DailyTemperatures {\n+    public int[] dailyTemperatures(int[] temperatures) {\n+        int[] result = new int[temperatures.length];\n+        Stack<Integer> stack = new Stack<Integer>();\n+        for(int i = 0; i < temperatures.length; i++) {\n+            while(!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n+                int index = stack.pop();\n+                result[index] = i - index;\n+            }\n+            stack.push(i);\n+        }\n+        \n+        return result;\n+    }\n+}\n\ndiff --git a/leetcode/stack/DailyTemperatures.java b/leetcode/stack/DailyTemperatures.java\n--- a/leetcode/stack/DailyTemperatures.java\n+++ b/leetcode/stack/DailyTemperatures.java\n@@ -0,0 +1,21 @@\n+//Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.\n+//\n+//For example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].\n+//\n+//Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].\n+\n+class DailyTemperatures {\n+    public int[] dailyTemperatures(int[] temperatures) {\n+        int[] result = new int[temperatures.length];\n+        Stack<Integer> stack = new Stack<Integer>();\n+        for(int i = 0; i < temperatures.length; i++) {\n+            while(!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n+                int index = stack.pop();\n+                result[index] = i - index;\n+            }\n+            stack.push(i);\n+        }\n+        \n+        return result;\n+    }\n+}",
    "output": "added DailyTemperatures.java"
  },
  {
    "input": "diff --git a/company/google/GuessNumberHigherOrLower.java b/company/google/GuessNumberHigherOrLower.java\n--- a/company/google/GuessNumberHigherOrLower.java\n+++ b/company/google/GuessNumberHigherOrLower.java\n@@ -21,30 +21,19 @@\n \n public class GuessNumberHigherOrLower extends GuessGame {\n     public int guessNumber(int n) {\n-        return binarySearch(1, n);\n-    }\n-    \n-    private int binarySearch(int start, int end) {\n-        if(start > end) {\n-            return -1;\n-        }\n-        \n-        if(guess(start) == 0) {\n-            return start;\n+        int left = 1;\n+        int right = n;\n+        while(left <= right) {\n+            int mid = left + (right - left) / 2;\n+            if(guess(mid) == 0) {\n+                return mid;\n+            } else if(guess(mid) > 0) {\n+                left = mid + 1;\n+            } else {\n+                right = mid;\n+            }\n         }\n         \n-        if(guess(end) == 0) {\n-            return end;\n-        }\n-        \n-        int mid = start + (end - start) / 2;\n-        \n-        if(guess(mid) == 0) {\n-            return mid;\n-        } else if(guess(mid) == 1) {\n-            return binarySearch(mid + 1, end);\n-        } else {\n-            return binarySearch(start, mid - 1);\n-        }\n+        return -1;\n     }\n }\n\ndiff --git a/leetcode/binary-search/GuessNumberHigherOrLower.java b/leetcode/binary-search/GuessNumberHigherOrLower.java\n--- a/leetcode/binary-search/GuessNumberHigherOrLower.java\n+++ b/leetcode/binary-search/GuessNumberHigherOrLower.java\n@@ -14,37 +14,21 @@\n \n // Return 6.\n \n-/* The guess API is defined in the parent class GuessGame.\n-   @param num, your guess\n-   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n-      int guess(int num); */\n-\n public class GuessNumberHigherOrLower extends GuessGame {\n     public int guessNumber(int n) {\n-        return binarySearch(1, n);\n-    }\n-    \n-    private int binarySearch(int start, int end) {\n-        if(start > end) {\n-            return -1;\n-        }\n-        \n-        if(guess(start) == 0) {\n-            return start;\n-        }\n-\n-        if(guess(end) == 0) {\n-            return end;\n+        int left = 1;\n+        int right = n;\n+        while(left <= right) {\n+            int mid = left + (right - left) / 2;\n+            if(guess(mid) == 0) {\n+                return mid;\n+            } else if(guess(mid) > 0) {\n+                left = mid + 1;\n+            } else {\n+                right = mid;\n+            }\n         }\n         \n-        int mid = start + (end - start) / 2;\n-        \n-        if(guess(mid) == 0) {\n-            return mid;\n-        } else if(guess(mid) == 1) {\n-            return binarySearch(mid + 1, end);\n-        } else {\n-            return binarySearch(start, mid - 1);\n-        }\n+        return -1;\n     }\n }",
    "output": "added alternative solution to GuessNumberHigherOrLower.java"
  },
  {
    "input": "diff --git a/company/google/FindAllNumbersDisappearedInAnArray.java b/company/google/FindAllNumbersDisappearedInAnArray.java\n--- a/company/google/FindAllNumbersDisappearedInAnArray.java\n+++ b/company/google/FindAllNumbersDisappearedInAnArray.java\n@@ -0,0 +1,37 @@\n+//Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.\n+//\n+//Find all the elements of [1, n] inclusive that do not appear in this array.\n+//\n+//Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\n+//\n+//Example:\n+//\n+//Input:\n+//[4,3,2,7,8,2,3,1]\n+//\n+//Output:\n+//[5,6]\n+\n+class FindAllNumbersDisappearedInAnArray {\n+    public List<Integer> findDisappearedNumbers(int[] nums) {\n+        List<Integer> result = new ArrayList<Integer>();\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i = 1; i <= nums.length; i++) {\n+            map.put(i, 1);\n+        }\n+        \n+        for(int i = 0; i < nums.length; i++) {\n+            if(map.containsKey(nums[i])) {\n+                map.put(nums[i], -1);\n+            }\n+        }\n+        \n+        for(int i: map.keySet()) {\n+            if(map.get(i) != -1) {\n+                result.add(i);\n+            }\n+        }\n+        \n+        return result;\n+    }\n+}\n\ndiff --git a/leetcode/array/FindAllNumbersDisappearedInAnArray.java b/leetcode/array/FindAllNumbersDisappearedInAnArray.java\n--- a/leetcode/array/FindAllNumbersDisappearedInAnArray.java\n+++ b/leetcode/array/FindAllNumbersDisappearedInAnArray.java\n@@ -0,0 +1,37 @@\n+//Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.\n+//\n+//Find all the elements of [1, n] inclusive that do not appear in this array.\n+//\n+//Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\n+//\n+//Example:\n+//\n+//Input:\n+//[4,3,2,7,8,2,3,1]\n+//\n+//Output:\n+//[5,6]\n+\n+class FindAllNumbersDisappearedInAnArray {\n+    public List<Integer> findDisappearedNumbers(int[] nums) {\n+        List<Integer> result = new ArrayList<Integer>();\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i = 1; i <= nums.length; i++) {\n+            map.put(i, 1);\n+        }\n+        \n+        for(int i = 0; i < nums.length; i++) {\n+            if(map.containsKey(nums[i])) {\n+                map.put(nums[i], -1);\n+            }\n+        }\n+        \n+        for(int i: map.keySet()) {\n+            if(map.get(i) != -1) {\n+                result.add(i);\n+            }\n+        }\n+        \n+        return result;\n+    }\n+}",
    "output": "added FindAllNumbersDisappearedInAnArray.java"
  },
  {
    "input": "diff --git a/company/amazon/FirstUniqueCharacterInAString.java b/company/amazon/FirstUniqueCharacterInAString.java\n--- a/company/amazon/FirstUniqueCharacterInAString.java\n+++ b/company/amazon/FirstUniqueCharacterInAString.java\n@@ -0,0 +1,34 @@\n+//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n+//\n+//Examples:\n+//\n+//s = \"leetcode\"\n+//return 0.\n+//\n+//s = \"loveleetcode\",\n+//return 2.\n+//Note: You may assume the string contain only lowercase letters.\n+\n+class FirstUniqueCharacterInAString {\n+    public int firstUniqChar(String s) {\n+        HashMap<Character, Integer> characters = new HashMap<Character, Integer>();\n+        for(int i = 0; i < s.length(); i++) {\n+            char current = s.charAt(i);\n+            if(characters.containsKey(current)) {\n+                characters.put(current, -1);\n+            } else {\n+                characters.put(current, i);\n+            }\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(char c: characters.keySet()) {\n+            if(characters.get(c) > -1 && characters.get(c) < min) {\n+                min = characters.get(c);\n+            }\n+        }\n+        \n+        return min == Integer.MAX_VALUE ? -1 : min;\n+        \n+    }\n+}\n\ndiff --git a/company/bloomberg/FirstUniqueCharacterInAString.java b/company/bloomberg/FirstUniqueCharacterInAString.java\n--- a/company/bloomberg/FirstUniqueCharacterInAString.java\n+++ b/company/bloomberg/FirstUniqueCharacterInAString.java\n@@ -0,0 +1,34 @@\n+//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n+//\n+//Examples:\n+//\n+//s = \"leetcode\"\n+//return 0.\n+//\n+//s = \"loveleetcode\",\n+//return 2.\n+//Note: You may assume the string contain only lowercase letters.\n+\n+class FirstUniqueCharacterInAString {\n+    public int firstUniqChar(String s) {\n+        HashMap<Character, Integer> characters = new HashMap<Character, Integer>();\n+        for(int i = 0; i < s.length(); i++) {\n+            char current = s.charAt(i);\n+            if(characters.containsKey(current)) {\n+                characters.put(current, -1);\n+            } else {\n+                characters.put(current, i);\n+            }\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(char c: characters.keySet()) {\n+            if(characters.get(c) > -1 && characters.get(c) < min) {\n+                min = characters.get(c);\n+            }\n+        }\n+        \n+        return min == Integer.MAX_VALUE ? -1 : min;\n+        \n+    }\n+}\n\ndiff --git a/company/google/FirstUniqueCharacterInAString.java b/company/google/FirstUniqueCharacterInAString.java\n--- a/company/google/FirstUniqueCharacterInAString.java\n+++ b/company/google/FirstUniqueCharacterInAString.java\n@@ -0,0 +1,34 @@\n+//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n+//\n+//Examples:\n+//\n+//s = \"leetcode\"\n+//return 0.\n+//\n+//s = \"loveleetcode\",\n+//return 2.\n+//Note: You may assume the string contain only lowercase letters.\n+\n+class FirstUniqueCharacterInAString {\n+    public int firstUniqChar(String s) {\n+        HashMap<Character, Integer> characters = new HashMap<Character, Integer>();\n+        for(int i = 0; i < s.length(); i++) {\n+            char current = s.charAt(i);\n+            if(characters.containsKey(current)) {\n+                characters.put(current, -1);\n+            } else {\n+                characters.put(current, i);\n+            }\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(char c: characters.keySet()) {\n+            if(characters.get(c) > -1 && characters.get(c) < min) {\n+                min = characters.get(c);\n+            }\n+        }\n+        \n+        return min == Integer.MAX_VALUE ? -1 : min;\n+        \n+    }\n+}\n\ndiff --git a/company/microsoft/FirstUniqueCharacterInAString.java b/company/microsoft/FirstUniqueCharacterInAString.java\n--- a/company/microsoft/FirstUniqueCharacterInAString.java\n+++ b/company/microsoft/FirstUniqueCharacterInAString.java\n@@ -0,0 +1,34 @@\n+//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n+//\n+//Examples:\n+//\n+//s = \"leetcode\"\n+//return 0.\n+//\n+//s = \"loveleetcode\",\n+//return 2.\n+//Note: You may assume the string contain only lowercase letters.\n+\n+class FirstUniqueCharacterInAString {\n+    public int firstUniqChar(String s) {\n+        HashMap<Character, Integer> characters = new HashMap<Character, Integer>();\n+        for(int i = 0; i < s.length(); i++) {\n+            char current = s.charAt(i);\n+            if(characters.containsKey(current)) {\n+                characters.put(current, -1);\n+            } else {\n+                characters.put(current, i);\n+            }\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(char c: characters.keySet()) {\n+            if(characters.get(c) > -1 && characters.get(c) < min) {\n+                min = characters.get(c);\n+            }\n+        }\n+        \n+        return min == Integer.MAX_VALUE ? -1 : min;\n+        \n+    }\n+}\n\ndiff --git a/leetcode/hash-table/FirstUniqueCharacterInAString.java b/leetcode/hash-table/FirstUniqueCharacterInAString.java\n--- a/leetcode/hash-table/FirstUniqueCharacterInAString.java\n+++ b/leetcode/hash-table/FirstUniqueCharacterInAString.java\n@@ -0,0 +1,34 @@\n+//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n+//\n+//Examples:\n+//\n+//s = \"leetcode\"\n+//return 0.\n+//\n+//s = \"loveleetcode\",\n+//return 2.\n+//Note: You may assume the string contain only lowercase letters.\n+\n+class FirstUniqueCharacterInAString {\n+    public int firstUniqChar(String s) {\n+        HashMap<Character, Integer> characters = new HashMap<Character, Integer>();\n+        for(int i = 0; i < s.length(); i++) {\n+            char current = s.charAt(i);\n+            if(characters.containsKey(current)) {\n+                characters.put(current, -1);\n+            } else {\n+                characters.put(current, i);\n+            }\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(char c: characters.keySet()) {\n+            if(characters.get(c) > -1 && characters.get(c) < min) {\n+                min = characters.get(c);\n+            }\n+        }\n+        \n+        return min == Integer.MAX_VALUE ? -1 : min;\n+        \n+    }\n+}\n\ndiff --git a/leetcode/string/FirstUniqueCharacterInAString.java b/leetcode/string/FirstUniqueCharacterInAString.java\n--- a/leetcode/string/FirstUniqueCharacterInAString.java\n+++ b/leetcode/string/FirstUniqueCharacterInAString.java\n@@ -0,0 +1,34 @@\n+//Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n+//\n+//Examples:\n+//\n+//s = \"leetcode\"\n+//return 0.\n+//\n+//s = \"loveleetcode\",\n+//return 2.\n+//Note: You may assume the string contain only lowercase letters.\n+\n+class FirstUniqueCharacterInAString {\n+    public int firstUniqChar(String s) {\n+        HashMap<Character, Integer> characters = new HashMap<Character, Integer>();\n+        for(int i = 0; i < s.length(); i++) {\n+            char current = s.charAt(i);\n+            if(characters.containsKey(current)) {\n+                characters.put(current, -1);\n+            } else {\n+                characters.put(current, i);\n+            }\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(char c: characters.keySet()) {\n+            if(characters.get(c) > -1 && characters.get(c) < min) {\n+                min = characters.get(c);\n+            }\n+        }\n+        \n+        return min == Integer.MAX_VALUE ? -1 : min;\n+        \n+    }\n+}",
    "output": "added FirstUniqueCharacterInAString.java"
  },
  {
    "input": "diff --git a/company/facebook/LongestConsecutiveSequence.java b/company/facebook/LongestConsecutiveSequence.java\n--- a/company/facebook/LongestConsecutiveSequence.java\n+++ b/company/facebook/LongestConsecutiveSequence.java\n@@ -6,27 +6,32 @@\n \n // Your algorithm should run in O(n) complexity.\n \n-public class LongestConsecutiveSequence {\n+class LongestConsecutiveSequence {\n     public int longestConsecutive(int[] nums) {\n-        int res = 0;\n-        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        if(nums == null || nums.length == 0) {\n+            return 0;\n+        }\n+        \n+        Set<Integer> set = new HashSet<Integer>();\n+        for(int n: nums) {\n+            set.add(n);\n+        }\n         \n-        for(int n : nums) {\n-            if(!map.containsKey(n)) {\n-                int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;\n-                int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;\n+        int maxLength = 0;\n+        for(int n: set) {\n+            if(!set.contains(n - 1)) {\n+                int current = n;\n+                int currentMax = 1;\n                 \n-                int sum = left + right + 1;\n-                map.put(n, sum);\n-                res = Math.max(res, sum);\n+                while(set.contains(n + 1)) {\n+                    currentMax++;\n+                    n++;\n+                }\n                 \n-                map.put(n - left, sum);\n-                map.put(n + right, sum);\n-            } else {\n-                continue;\n+                maxLength = Math.max(maxLength, currentMax);\n             }\n         }\n         \n-        return res;\n+        return maxLength;\n     }\n }\n\ndiff --git a/company/google/LongestConsecutiveSequence.java b/company/google/LongestConsecutiveSequence.java\n--- a/company/google/LongestConsecutiveSequence.java\n+++ b/company/google/LongestConsecutiveSequence.java\n@@ -6,27 +6,32 @@\n \n // Your algorithm should run in O(n) complexity.\n \n-public class LongestConsecutiveSequence {\n+class LongestConsecutiveSequence {\n     public int longestConsecutive(int[] nums) {\n-        int res = 0;\n-        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        if(nums == null || nums.length == 0) {\n+            return 0;\n+        }\n+        \n+        Set<Integer> set = new HashSet<Integer>();\n+        for(int n: nums) {\n+            set.add(n);\n+        }\n         \n-        for(int n : nums) {\n-            if(!map.containsKey(n)) {\n-                int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;\n-                int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;\n+        int maxLength = 0;\n+        for(int n: set) {\n+            if(!set.contains(n - 1)) {\n+                int current = n;\n+                int currentMax = 1;\n                 \n-                int sum = left + right + 1;\n-                map.put(n, sum);\n-                res = Math.max(res, sum);\n+                while(set.contains(n + 1)) {\n+                    currentMax++;\n+                    n++;\n+                }\n                 \n-                map.put(n - left, sum);\n-                map.put(n + right, sum);\n-            } else {\n-                continue;\n+                maxLength = Math.max(maxLength, currentMax);\n             }\n         }\n         \n-        return res;\n+        return maxLength;\n     }\n }\n\ndiff --git a/leetcode/array/LongestConsecutiveSequence.java b/leetcode/array/LongestConsecutiveSequence.java\n--- a/leetcode/array/LongestConsecutiveSequence.java\n+++ b/leetcode/array/LongestConsecutiveSequence.java\n@@ -6,27 +6,32 @@\n \n // Your algorithm should run in O(n) complexity.\n \n-public class LongestConsecutiveSequence {\n+class LongestConsecutiveSequence {\n     public int longestConsecutive(int[] nums) {\n-        int res = 0;\n-        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        if(nums == null || nums.length == 0) {\n+            return 0;\n+        }\n+        \n+        Set<Integer> set = new HashSet<Integer>();\n+        for(int n: nums) {\n+            set.add(n);\n+        }\n         \n-        for(int n : nums) {\n-            if(!map.containsKey(n)) {\n-                int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;\n-                int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;\n+        int maxLength = 0;\n+        for(int n: set) {\n+            if(!set.contains(n - 1)) {\n+                int current = n;\n+                int currentMax = 1;\n                 \n-                int sum = left + right + 1;\n-                map.put(n, sum);\n-                res = Math.max(res, sum);\n+                while(set.contains(n + 1)) {\n+                    currentMax++;\n+                    n++;\n+                }\n                 \n-                map.put(n - left, sum);\n-                map.put(n + right, sum);\n-            } else {\n-                continue;\n+                maxLength = Math.max(maxLength, currentMax);\n             }\n         }\n         \n-        return res;\n+        return maxLength;\n     }\n }",
    "output": "added modified solution for LongestConsecutiveSequence.java"
  },
  {
    "input": "diff --git a/company/google/JudgeRouteCircle.java b/company/google/JudgeRouteCircle.java\n--- a/company/google/JudgeRouteCircle.java\n+++ b/company/google/JudgeRouteCircle.java\n@@ -0,0 +1,30 @@\n+//Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.\n+//\n+//The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.\n+//\n+//Example 1:\n+//Input: \"UD\"\n+//Output: true\n+//Example 2:\n+//Input: \"LL\"\n+//Output: false\n+\n+class JudgeRouteCircle {\n+    public boolean judgeCircle(String moves) {\n+        int UD = 0;\n+        int LR = 0;\n+        for(int i = 0; i < moves.length(); i++) {\n+            if(moves.charAt(i) == 'U') {\n+                UD++;\n+            } else if(moves.charAt(i) == 'D') {\n+                UD--;\n+            } else if(moves.charAt(i) == 'L') {\n+                LR++;\n+            } else if(moves.charAt(i) == 'R') {\n+                LR--;\n+            }\n+        }\n+        \n+        return UD == 0 && LR == 0;\n+    }\n+}\n\ndiff --git a/leetcode/string/JudgeRouteCircle.java b/leetcode/string/JudgeRouteCircle.java\n--- a/leetcode/string/JudgeRouteCircle.java\n+++ b/leetcode/string/JudgeRouteCircle.java\n@@ -0,0 +1,30 @@\n+//Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.\n+//\n+//The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.\n+//\n+//Example 1:\n+//Input: \"UD\"\n+//Output: true\n+//Example 2:\n+//Input: \"LL\"\n+//Output: false\n+\n+class JudgeRouteCircle {\n+    public boolean judgeCircle(String moves) {\n+        int UD = 0;\n+        int LR = 0;\n+        for(int i = 0; i < moves.length(); i++) {\n+            if(moves.charAt(i) == 'U') {\n+                UD++;\n+            } else if(moves.charAt(i) == 'D') {\n+                UD--;\n+            } else if(moves.charAt(i) == 'L') {\n+                LR++;\n+            } else if(moves.charAt(i) == 'R') {\n+                LR--;\n+            }\n+        }\n+        \n+        return UD == 0 && LR == 0;\n+    }\n+}",
    "output": "adding JudgeRouteCircle.java"
  },
  {
    "input": "diff --git a/company/google/BullsAndCows.java b/company/google/BullsAndCows.java\n--- a/company/google/BullsAndCows.java\n+++ b/company/google/BullsAndCows.java\n@@ -0,0 +1,43 @@\n+//You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called \"bulls\") and how many digits match the secret number but locate in the wrong position (called \"cows\"). Your friend will use successive guesses and hints to eventually derive the secret number.\n+//\n+//Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. \n+//\n+//Please note that both secret number and friend's guess may contain duplicate digits.\n+//\n+//Example 1:\n+//\n+//Input: secret = \"1807\", guess = \"7810\"\n+//\n+//Output: \"1A3B\"\n+//\n+//Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.\n+//Example 2:\n+//\n+//Input: secret = \"1123\", guess = \"0111\"\n+//\n+//Output: \"1A1B\"\n+//\n+//Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.\n+//Note: You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.\n+\n+class BullsAndCows {\n+    public String getHint(String secret, String guess) {\n+        int bulls = 0;\n+        int cows = 0;\n+        int[] counts = new int[10];\n+        for(int i = 0; i < secret.length(); i++) {\n+            if(secret.charAt(i) == guess.charAt(i)) {\n+                bulls++;\n+            }  else {\n+                if(counts[secret.charAt(i) - '0']++ < 0) {\n+                    cows++;\n+                }\n+                if(counts[guess.charAt(i) - '0']-- > 0) {\n+                    cows++;\n+                }\n+            }\n+        }\n+        \n+        return bulls + \"A\" + cows + \"B\";\n+    }\n+}\n\ndiff --git a/leetcode/hash-table/BullsAndCows.java b/leetcode/hash-table/BullsAndCows.java\n--- a/leetcode/hash-table/BullsAndCows.java\n+++ b/leetcode/hash-table/BullsAndCows.java\n@@ -0,0 +1,43 @@\n+//You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called \"bulls\") and how many digits match the secret number but locate in the wrong position (called \"cows\"). Your friend will use successive guesses and hints to eventually derive the secret number.\n+//\n+//Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. \n+//\n+//Please note that both secret number and friend's guess may contain duplicate digits.\n+//\n+//Example 1:\n+//\n+//Input: secret = \"1807\", guess = \"7810\"\n+//\n+//Output: \"1A3B\"\n+//\n+//Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.\n+//Example 2:\n+//\n+//Input: secret = \"1123\", guess = \"0111\"\n+//\n+//Output: \"1A1B\"\n+//\n+//Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.\n+//Note: You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.\n+\n+class BullsAndCows {\n+    public String getHint(String secret, String guess) {\n+        int bulls = 0;\n+        int cows = 0;\n+        int[] counts = new int[10];\n+        for(int i = 0; i < secret.length(); i++) {\n+            if(secret.charAt(i) == guess.charAt(i)) {\n+                bulls++;\n+            }  else {\n+                if(counts[secret.charAt(i) - '0']++ < 0) {\n+                    cows++;\n+                }\n+                if(counts[guess.charAt(i) - '0']-- > 0) {\n+                    cows++;\n+                }\n+            }\n+        }\n+        \n+        return bulls + \"A\" + cows + \"B\";\n+    }\n+}",
    "output": "adding BullsAndCows.java"
  },
  {
    "input": "diff --git a/company/google/IslandPerimeter.java b/company/google/IslandPerimeter.java\n--- a/company/google/IslandPerimeter.java\n+++ b/company/google/IslandPerimeter.java\n@@ -9,27 +9,38 @@\n \n // Answer: 16\n \n-public class IslandPerimeter {\n+class IslandPerimeter {\n     public int islandPerimeter(int[][] grid) {\n-        int islands = 0;\n-        int neighbors = 0;\n-        \n+        int perimeter = 0;\n+        if(grid == null || grid.length == 0) {\n+            return perimeter;\n+        }\n+\n         for(int i = 0; i < grid.length; i++) {\n-            for(int j = 0; j < grid[0].length; j++) {\n+            for(int j = 0; j < grid[i].length; j++) {\n                 if(grid[i][j] == 1) {\n-                    islands++;\n-                    \n-                    if(i < grid.length - 1 && grid[i + 1][j] == 1) {\n-                        neighbors++;\n-                    }\n-                    \n-                    if(j < grid[0].length - 1 && grid[i][j + 1] == 1) {\n-                        neighbors++;\n-                    }\n+                    perimeter += numNeighbors(grid, i, j);\n+                    return perimeter;\n                 }\n             }\n         }\n-        \n-        return islands * 4 - neighbors * 2;\n+\n+        return perimeter;\n+    }\n+\n+    public int numNeighbors(int[][] grid, int x, int y) {\n+        if(x < 0 || x >= grid.length || y < 0 || y >= grid[x].length || grid[x][y] == 0) {\n+            return 1;\n+        }\n+\n+        if(grid[x][y] == -1) {\n+            return 0;\n+        }\n+\n+        grid[x][y] = -1;\n+        return numNeighbors(grid, x + 1, y) + \n+            numNeighbors(grid, x - 1, y) + \n+            numNeighbors(grid, x, y + 1) + \n+            numNeighbors(grid, x, y - 1);\n     }\n }\n\ndiff --git a/leetcode/hash-table/IslandPerimeter.java b/leetcode/hash-table/IslandPerimeter.java\n--- a/leetcode/hash-table/IslandPerimeter.java\n+++ b/leetcode/hash-table/IslandPerimeter.java\n@@ -9,27 +9,38 @@\n \n // Answer: 16\n \n-public class IslandPerimeter {\n+class IslandPerimeter {\n     public int islandPerimeter(int[][] grid) {\n-        int islands = 0;\n-        int neighbors = 0;\n-        \n+        int perimeter = 0;\n+        if(grid == null || grid.length == 0) {\n+            return perimeter;\n+        }\n+\n         for(int i = 0; i < grid.length; i++) {\n-            for(int j = 0; j < grid[0].length; j++) {\n+            for(int j = 0; j < grid[i].length; j++) {\n                 if(grid[i][j] == 1) {\n-                    islands++;\n-                    \n-                    if(i < grid.length - 1 && grid[i + 1][j] == 1) {\n-                        neighbors++;\n-                    }\n-                    \n-                    if(j < grid[0].length - 1 && grid[i][j + 1] == 1) {\n-                        neighbors++;\n-                    }\n+                    perimeter += numNeighbors(grid, i, j);\n+                    return perimeter;\n                 }\n             }\n         }\n-        \n-        return islands * 4 - neighbors * 2;\n+\n+        return perimeter;\n+    }\n+\n+    public int numNeighbors(int[][] grid, int x, int y) {\n+        if(x < 0 || x >= grid.length || y < 0 || y >= grid[x].length || grid[x][y] == 0) {\n+            return 1;\n+        }\n+\n+        if(grid[x][y] == -1) {\n+            return 0;\n+        }\n+\n+        grid[x][y] = -1;\n+        return numNeighbors(grid, x + 1, y) + \n+            numNeighbors(grid, x - 1, y) + \n+            numNeighbors(grid, x, y + 1) + \n+            numNeighbors(grid, x, y - 1);\n     }\n }",
    "output": "alternative solution for IslandPerimeter"
  },
  {
    "input": "diff --git a/company/amazon/MinStack.java b/company/amazon/MinStack.java\n--- a/company/amazon/MinStack.java\n+++ b/company/amazon/MinStack.java\n@@ -0,0 +1,55 @@\n+//Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n+//push(x) -- Push element x onto stack.\n+//pop() -- Removes the element on top of the stack.\n+//top() -- Get the top element.\n+//getMin() -- Retrieve the minimum element in the stack.\n+\n+/**\n+ * Your MinStack object will be instantiated and called as such:\n+ * MinStack obj = new MinStack();\n+ * obj.push(x);\n+ * obj.pop();\n+ * int param_3 = obj.top();\n+ * int param_4 = obj.getMin();\n+ */\n+class MinStack {\n+    class Node {\n+        int data;\n+        int min;\n+        Node next;\n+        \n+        public Node(int data, int min) {\n+            this.data = data;\n+            this.min = min;\n+            this.next = null;\n+        }\n+    }\n+    Node head;\n+    \n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        \n+    }\n+    \n+    public void push(int x) {\n+        if(head == null) {\n+            head = new Node(x, x);\n+        } else {\n+            Node newNode = new Node(x, Math.min(x, head.min));\n+            newNode.next = head;\n+            head = newNode;\n+        }\n+    }\n+    \n+    public void pop() {\n+        head = head.next;\n+    }\n+    \n+    public int top() {\n+        return head.data;\n+    }\n+    \n+    public int getMin() {\n+        return head.min;\n+    }\n+}\n\ndiff --git a/company/bloomberg/MinStack.java b/company/bloomberg/MinStack.java\n--- a/company/bloomberg/MinStack.java\n+++ b/company/bloomberg/MinStack.java\n@@ -0,0 +1,55 @@\n+//Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n+//push(x) -- Push element x onto stack.\n+//pop() -- Removes the element on top of the stack.\n+//top() -- Get the top element.\n+//getMin() -- Retrieve the minimum element in the stack.\n+\n+/**\n+ * Your MinStack object will be instantiated and called as such:\n+ * MinStack obj = new MinStack();\n+ * obj.push(x);\n+ * obj.pop();\n+ * int param_3 = obj.top();\n+ * int param_4 = obj.getMin();\n+ */\n+class MinStack {\n+    class Node {\n+        int data;\n+        int min;\n+        Node next;\n+        \n+        public Node(int data, int min) {\n+            this.data = data;\n+            this.min = min;\n+            this.next = null;\n+        }\n+    }\n+    Node head;\n+    \n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        \n+    }\n+    \n+    public void push(int x) {\n+        if(head == null) {\n+            head = new Node(x, x);\n+        } else {\n+            Node newNode = new Node(x, Math.min(x, head.min));\n+            newNode.next = head;\n+            head = newNode;\n+        }\n+    }\n+    \n+    public void pop() {\n+        head = head.next;\n+    }\n+    \n+    public int top() {\n+        return head.data;\n+    }\n+    \n+    public int getMin() {\n+        return head.min;\n+    }\n+}\n\ndiff --git a/company/google/MinStack.java b/company/google/MinStack.java\n--- a/company/google/MinStack.java\n+++ b/company/google/MinStack.java\n@@ -0,0 +1,55 @@\n+//Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n+//push(x) -- Push element x onto stack.\n+//pop() -- Removes the element on top of the stack.\n+//top() -- Get the top element.\n+//getMin() -- Retrieve the minimum element in the stack.\n+\n+/**\n+ * Your MinStack object will be instantiated and called as such:\n+ * MinStack obj = new MinStack();\n+ * obj.push(x);\n+ * obj.pop();\n+ * int param_3 = obj.top();\n+ * int param_4 = obj.getMin();\n+ */\n+class MinStack {\n+    class Node {\n+        int data;\n+        int min;\n+        Node next;\n+        \n+        public Node(int data, int min) {\n+            this.data = data;\n+            this.min = min;\n+            this.next = null;\n+        }\n+    }\n+    Node head;\n+    \n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        \n+    }\n+    \n+    public void push(int x) {\n+        if(head == null) {\n+            head = new Node(x, x);\n+        } else {\n+            Node newNode = new Node(x, Math.min(x, head.min));\n+            newNode.next = head;\n+            head = newNode;\n+        }\n+    }\n+    \n+    public void pop() {\n+        head = head.next;\n+    }\n+    \n+    public int top() {\n+        return head.data;\n+    }\n+    \n+    public int getMin() {\n+        return head.min;\n+    }\n+}\n\ndiff --git a/company/snapchat/MinStack.java b/company/snapchat/MinStack.java\n--- a/company/snapchat/MinStack.java\n+++ b/company/snapchat/MinStack.java\n@@ -0,0 +1,55 @@\n+//Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n+//push(x) -- Push element x onto stack.\n+//pop() -- Removes the element on top of the stack.\n+//top() -- Get the top element.\n+//getMin() -- Retrieve the minimum element in the stack.\n+\n+/**\n+ * Your MinStack object will be instantiated and called as such:\n+ * MinStack obj = new MinStack();\n+ * obj.push(x);\n+ * obj.pop();\n+ * int param_3 = obj.top();\n+ * int param_4 = obj.getMin();\n+ */\n+class MinStack {\n+    class Node {\n+        int data;\n+        int min;\n+        Node next;\n+        \n+        public Node(int data, int min) {\n+            this.data = data;\n+            this.min = min;\n+            this.next = null;\n+        }\n+    }\n+    Node head;\n+    \n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        \n+    }\n+    \n+    public void push(int x) {\n+        if(head == null) {\n+            head = new Node(x, x);\n+        } else {\n+            Node newNode = new Node(x, Math.min(x, head.min));\n+            newNode.next = head;\n+            head = newNode;\n+        }\n+    }\n+    \n+    public void pop() {\n+        head = head.next;\n+    }\n+    \n+    public int top() {\n+        return head.data;\n+    }\n+    \n+    public int getMin() {\n+        return head.min;\n+    }\n+}\n\ndiff --git a/company/uber/MinStack.java b/company/uber/MinStack.java\n--- a/company/uber/MinStack.java\n+++ b/company/uber/MinStack.java\n@@ -0,0 +1,55 @@\n+//Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n+//push(x) -- Push element x onto stack.\n+//pop() -- Removes the element on top of the stack.\n+//top() -- Get the top element.\n+//getMin() -- Retrieve the minimum element in the stack.\n+\n+/**\n+ * Your MinStack object will be instantiated and called as such:\n+ * MinStack obj = new MinStack();\n+ * obj.push(x);\n+ * obj.pop();\n+ * int param_3 = obj.top();\n+ * int param_4 = obj.getMin();\n+ */\n+class MinStack {\n+    class Node {\n+        int data;\n+        int min;\n+        Node next;\n+        \n+        public Node(int data, int min) {\n+            this.data = data;\n+            this.min = min;\n+            this.next = null;\n+        }\n+    }\n+    Node head;\n+    \n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        \n+    }\n+    \n+    public void push(int x) {\n+        if(head == null) {\n+            head = new Node(x, x);\n+        } else {\n+            Node newNode = new Node(x, Math.min(x, head.min));\n+            newNode.next = head;\n+            head = newNode;\n+        }\n+    }\n+    \n+    public void pop() {\n+        head = head.next;\n+    }\n+    \n+    public int top() {\n+        return head.data;\n+    }\n+    \n+    public int getMin() {\n+        return head.min;\n+    }\n+}\n\ndiff --git a/leetcode/design/MinStack.java b/leetcode/design/MinStack.java\n--- a/leetcode/design/MinStack.java\n+++ b/leetcode/design/MinStack.java\n@@ -0,0 +1,55 @@\n+//Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n+//push(x) -- Push element x onto stack.\n+//pop() -- Removes the element on top of the stack.\n+//top() -- Get the top element.\n+//getMin() -- Retrieve the minimum element in the stack.\n+\n+/**\n+ * Your MinStack object will be instantiated and called as such:\n+ * MinStack obj = new MinStack();\n+ * obj.push(x);\n+ * obj.pop();\n+ * int param_3 = obj.top();\n+ * int param_4 = obj.getMin();\n+ */\n+class MinStack {\n+    class Node {\n+        int data;\n+        int min;\n+        Node next;\n+        \n+        public Node(int data, int min) {\n+            this.data = data;\n+            this.min = min;\n+            this.next = null;\n+        }\n+    }\n+    Node head;\n+    \n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        \n+    }\n+    \n+    public void push(int x) {\n+        if(head == null) {\n+            head = new Node(x, x);\n+        } else {\n+            Node newNode = new Node(x, Math.min(x, head.min));\n+            newNode.next = head;\n+            head = newNode;\n+        }\n+    }\n+    \n+    public void pop() {\n+        head = head.next;\n+    }\n+    \n+    public int top() {\n+        return head.data;\n+    }\n+    \n+    public int getMin() {\n+        return head.min;\n+    }\n+}",
    "output": "added MinStack.java"
  },
  {
    "input": "diff --git a/company/google/GenerateParentheses.java b/company/google/GenerateParentheses.java\n--- a/company/google/GenerateParentheses.java\n+++ b/company/google/GenerateParentheses.java\n@@ -0,0 +1,23 @@\n+class GenerateParentheses {\n+    public List<String> generateParenthesis(int n) {\n+        List<String> result = new ArrayList<String>();\n+        generateParenthesisRecursive(result, \"\", 0, 0, n);\n+        \n+        return result;\n+    }\n+    \n+    public void generateParenthesisRecursive(List<String> result, String current, int open, int close, int n) {\n+        if(current.length() == n * 2) {\n+            result.add(current);\n+            return;\n+        }\n+        \n+        if(open < n) {\n+            generateParenthesisRecursive(result, current + \"(\", open + 1, close, n);\n+        }\n+        \n+        if(close < open) {\n+            generateParenthesisRecursive(result, current + \")\", open, close + 1, n);\n+        }\n+    }\n+}\n\ndiff --git a/company/uber/GenerateParentheses.java b/company/uber/GenerateParentheses.java\n--- a/company/uber/GenerateParentheses.java\n+++ b/company/uber/GenerateParentheses.java\n@@ -0,0 +1,23 @@\n+class GenerateParentheses {\n+    public List<String> generateParenthesis(int n) {\n+        List<String> result = new ArrayList<String>();\n+        generateParenthesisRecursive(result, \"\", 0, 0, n);\n+        \n+        return result;\n+    }\n+    \n+    public void generateParenthesisRecursive(List<String> result, String current, int open, int close, int n) {\n+        if(current.length() == n * 2) {\n+            result.add(current);\n+            return;\n+        }\n+        \n+        if(open < n) {\n+            generateParenthesisRecursive(result, current + \"(\", open + 1, close, n);\n+        }\n+        \n+        if(close < open) {\n+            generateParenthesisRecursive(result, current + \")\", open, close + 1, n);\n+        }\n+    }\n+}\n\ndiff --git a/leetcode/backtracking/GenerateParentheses.java b/leetcode/backtracking/GenerateParentheses.java\n--- a/leetcode/backtracking/GenerateParentheses.java\n+++ b/leetcode/backtracking/GenerateParentheses.java\n@@ -0,0 +1,23 @@\n+class GenerateParentheses {\n+    public List<String> generateParenthesis(int n) {\n+        List<String> result = new ArrayList<String>();\n+        generateParenthesisRecursive(result, \"\", 0, 0, n);\n+        \n+        return result;\n+    }\n+    \n+    public void generateParenthesisRecursive(List<String> result, String current, int open, int close, int n) {\n+        if(current.length() == n * 2) {\n+            result.add(current);\n+            return;\n+        }\n+        \n+        if(open < n) {\n+            generateParenthesisRecursive(result, current + \"(\", open + 1, close, n);\n+        }\n+        \n+        if(close < open) {\n+            generateParenthesisRecursive(result, current + \")\", open, close + 1, n);\n+        }\n+    }\n+}\n\ndiff --git a/leetcode/string/GenerateParentheses.java b/leetcode/string/GenerateParentheses.java\n--- a/leetcode/string/GenerateParentheses.java\n+++ b/leetcode/string/GenerateParentheses.java\n@@ -0,0 +1,23 @@\n+class GenerateParentheses {\n+    public List<String> generateParenthesis(int n) {\n+        List<String> result = new ArrayList<String>();\n+        generateParenthesisRecursive(result, \"\", 0, 0, n);\n+        \n+        return result;\n+    }\n+    \n+    public void generateParenthesisRecursive(List<String> result, String current, int open, int close, int n) {\n+        if(current.length() == n * 2) {\n+            result.add(current);\n+            return;\n+        }\n+        \n+        if(open < n) {\n+            generateParenthesisRecursive(result, current + \"(\", open + 1, close, n);\n+        }\n+        \n+        if(close < open) {\n+            generateParenthesisRecursive(result, current + \")\", open, close + 1, n);\n+        }\n+    }\n+}",
    "output": "added GenerateParentheses.java"
  },
  {
    "input": "diff --git a/company/microsoft/HouseRobberII.java b/company/microsoft/HouseRobberII.java\n--- a/company/microsoft/HouseRobberII.java\n+++ b/company/microsoft/HouseRobberII.java\n@@ -0,0 +1,34 @@\n+//Note: This is an extension of House Robber. (security system is tripped if two ajacent houses are robbed)\n+//After robbing those houses on that street, the thief has found himself a new place for his thievery so that \n+//he will not get too much attention. This time, all houses at this place are arranged in a circle. That means \n+//the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the \n+//same as for those in the previous street.\n+//Given a list of non-negative integers representing the amount of money of each house, determine the maximum \n+//amount of money you can rob tonight without alerting the police.\n+\n+class HouseRobberII {\n+    public int rob(int[] nums) {\n+        if (nums.length == 0) {\n+            return 0;\n+        }\n+        if (nums.length < 2) {\n+            return nums[0];\n+        }\n+        \n+        int[] first = new int[nums.length + 1];\n+        int[] second = new int[nums.length + 1];\n+        \n+        first[0]  = 0;\n+        first[1]  = nums[0];\n+        second[0] = 0;\n+        second[1] = 0;\n+        \n+        for (int i = 2; i <= nums.length; i++) {\n+            first[i] = Math.max(first[i - 1], first[i - 2] + nums[i - 1]);\n+            second[i] = Math.max(second[i - 1], second[i - 2] + nums[i - 1]);\n+        }\n+        \n+        return Math.max(first[nums.length - 1], second[nums.length]);\n+    }\n+}\n+\n\ndiff --git a/leetcode/dynamic-programming/HouseRobberII.java b/leetcode/dynamic-programming/HouseRobberII.java\n--- a/leetcode/dynamic-programming/HouseRobberII.java\n+++ b/leetcode/dynamic-programming/HouseRobberII.java\n@@ -0,0 +1,33 @@\n+//Note: This is an extension of House Robber. (security system is tripped if two ajacent houses are robbed)\n+//After robbing those houses on that street, the thief has found himself a new place for his thievery so that \n+//he will not get too much attention. This time, all houses at this place are arranged in a circle. That means \n+//the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the \n+//same as for those in the previous street.\n+//Given a list of non-negative integers representing the amount of money of each house, determine the maximum \n+//amount of money you can rob tonight without alerting the police.\n+\n+class HouseRobberII {\n+    public int rob(int[] nums) {\n+        if (nums.length == 0) {\n+            return 0;\n+        }\n+        if (nums.length < 2) {\n+            return nums[0];\n+        }\n+        \n+        int[] first = new int[nums.length + 1];\n+        int[] second = new int[nums.length + 1];\n+        \n+        first[0]  = 0;\n+        first[1]  = nums[0];\n+        second[0] = 0;\n+        second[1] = 0;\n+        \n+        for (int i = 2; i <= nums.length; i++) {\n+            first[i] = Math.max(first[i - 1], first[i - 2] + nums[i - 1]);\n+            second[i] = Math.max(second[i - 1], second[i - 2] + nums[i - 1]);\n+        }\n+        \n+        return Math.max(first[nums.length - 1], second[nums.length]);\n+    }\n+}",
    "output": "adding HouseRobberII"
  },
  {
    "input": "diff --git a/company/microsoft/LongestIncreasingSubsequence.java b/company/microsoft/LongestIncreasingSubsequence.java\n--- a/company/microsoft/LongestIncreasingSubsequence.java\n+++ b/company/microsoft/LongestIncreasingSubsequence.java\n@@ -0,0 +1,34 @@\n+//Given an unsorted array of integers, find the length of longest increasing subsequence.\n+\n+//For example,\n+//Given [10, 9, 2, 5, 3, 7, 101, 18],\n+//The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.\n+\n+//Your algorithm should run in O(n2) complexity.\n+\n+//Follow up: Could you improve it to O(n log n) time complexity?\n+\n+class LongestIncreasingSubsequence {\n+    public int lengthOfLIS(int[] nums) {\n+        if(nums == null || nums.length < 1) {\n+            return 0;\n+        }\n+\n+        int[] dp = new int[nums.length];\n+        dp[0] = 1;\n+        \n+        int max = 1;\n+        for(int i = 1; i < dp.length; i++) {\n+            int currentMax = 0;\n+            for(int j = 0; j < i; j++) {\n+                if(nums[i] > nums[j]) {\n+                    currentMax = Math.max(currentMax, dp[j]);\n+                }\n+            }\n+            dp[i] = 1 + currentMax;\n+            max = Math.max(max, dp[i]);\n+        }\n+\n+        return max;\n+    }\n+}\n\ndiff --git a/leetcode/dynamic-programming/LongestIncreasingSubsequence.java b/leetcode/dynamic-programming/LongestIncreasingSubsequence.java\n--- a/leetcode/dynamic-programming/LongestIncreasingSubsequence.java\n+++ b/leetcode/dynamic-programming/LongestIncreasingSubsequence.java\n@@ -0,0 +1,34 @@\n+//Given an unsorted array of integers, find the length of longest increasing subsequence.\n+\n+//For example,\n+//Given [10, 9, 2, 5, 3, 7, 101, 18],\n+//The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.\n+\n+//Your algorithm should run in O(n2) complexity.\n+\n+//Follow up: Could you improve it to O(n log n) time complexity?\n+\n+class LongestIncreasingSubsequence {\n+    public int lengthOfLIS(int[] nums) {\n+        if(nums == null || nums.length < 1) {\n+            return 0;\n+        }\n+\n+        int[] dp = new int[nums.length];\n+        dp[0] = 1;\n+        \n+        int max = 1;\n+        for(int i = 1; i < dp.length; i++) {\n+            int currentMax = 0;\n+            for(int j = 0; j < i; j++) {\n+                if(nums[i] > nums[j]) {\n+                    currentMax = Math.max(currentMax, dp[j]);\n+                }\n+            }\n+            dp[i] = 1 + currentMax;\n+            max = Math.max(max, dp[i]);\n+        }\n+\n+        return max;\n+    }\n+}",
    "output": "add LongestIncreasingSubsequence"
  },
  {
    "input": "diff --git a/leetcode/dynamic-programming/CoinChange.java b/leetcode/dynamic-programming/CoinChange.java\n--- a/leetcode/dynamic-programming/CoinChange.java\n+++ b/leetcode/dynamic-programming/CoinChange.java\n@@ -0,0 +1,45 @@\n+//You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n+\n+//Example 1:\n+//coins = [1, 2, 5], amount = 11\n+//return 3 (11 = 5 + 5 + 1)\n+\n+//Example 2:\n+//coins = [2], amount = 3\n+//return -1.\n+\n+//Note:\n+//You may assume that you have an infinite number of each kind of coin.\n+\n+class CoinChange {\n+    public int coinChange(int[] coins, int amount) {\n+        if(amount < 1) {\n+            return 0;\n+        }\n+        \n+        return coinChangeRecursive(coins, amount, new int[amount]);\n+    }\n+    \n+    public int coinChangeRecursive(int[] coins, int amount, int[] dp) {\n+        if(amount < 0) {\n+            return -1;\n+        }\n+        if(amount == 0) {\n+            return 0;\n+        }\n+        if(dp[amount - 1] != 0) {\n+            return dp[amount - 1];\n+        }\n+        \n+        int min = Integer.MAX_VALUE;\n+        for(int coin: coins) {\n+            int result = coinChangeRecursive(coins, amount - coin, dp);\n+            if(result >= 0 && result < min) {\n+                min = 1 + result;\n+            }\n+        }\n+        \n+        dp[amount - 1] = min == Integer.MAX_VALUE ? -1 : min;\n+        return dp[amount - 1];\n+    }\n+}",
    "output": "adding CoinChange"
  },
  {
    "input": "diff --git a/leetcode/array/MinimumPathSum.java b/leetcode/array/MinimumPathSum.java\n--- a/leetcode/array/MinimumPathSum.java\n+++ b/leetcode/array/MinimumPathSum.java\n@@ -0,0 +1,27 @@\n+//Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right \n+//which minimizes the sum of all numbers along its path.\n+//Note: You can only move either down or right at any point in time.\n+//Example 1:\n+//[[1,3,1],\n+ //[1,5,1],\n+ //[4,2,1]]\n+//Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.\n+\n+class MinimumPathSum {\n+    public int minPathSum(int[][] grid) {\n+        for(int i = 1; i < grid.length; i++) {\n+            grid[i][0] += grid[i - 1][0];\n+        }\n+        for(int i = 1; i < grid[0].length; i++) {\n+            grid[0][i] += grid[0][i - 1];\n+        }\n+        \n+        for(int i = 1; i < grid.length; i++) {\n+            for(int j = 1; j < grid[0].length; j++) {\n+                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n+            }\n+        }\n+        \n+        return grid[grid.length - 1][grid[0].length - 1];\n+    }\n+}\n\ndiff --git a/leetcode/dynamic-programming/MinimumPathSum.java b/leetcode/dynamic-programming/MinimumPathSum.java\n--- a/leetcode/dynamic-programming/MinimumPathSum.java\n+++ b/leetcode/dynamic-programming/MinimumPathSum.java\n@@ -0,0 +1,28 @@\n+//Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right \n+//which minimizes the sum of all numbers along its path.\n+//Note: You can only move either down or right at any point in time.\n+//Example 1:\n+//[[1,3,1],\n+ //[1,5,1],\n+ //[4,2,1]]\n+//Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.\n+\n+class MinimumPathSum {\n+    public int minPathSum(int[][] grid) {\n+        for(int i = 1; i < grid.length; i++) {\n+            grid[i][0] += grid[i - 1][0];\n+        }\n+        for(int i = 1; i < grid[0].length; i++) {\n+            grid[0][i] += grid[0][i - 1];\n+        }\n+        \n+        for(int i = 1; i < grid.length; i++) {\n+            for(int j = 1; j < grid[0].length; j++) {\n+                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n+            }\n+        }\n+        \n+        return grid[grid.length - 1][grid[0].length - 1];\n+    }\n+}\n+",
    "output": "add MinimumPathSum"
  },
  {
    "input": "diff --git a/company/facebook/PalindromicSubstrings.java b/company/facebook/PalindromicSubstrings.java\n--- a/company/facebook/PalindromicSubstrings.java\n+++ b/company/facebook/PalindromicSubstrings.java\n@@ -0,0 +1,39 @@\n+//Given a string, your task is to count how many palindromic substrings in this string.\n+//The substrings with different start indexes or end indexes are counted as different substrings \n+//even they consist of same characters.\n+\n+//Example 1:\n+//Input: \"abc\"\n+//Output: 3\n+//Explanation: Three palindromic strings: \"a\", \"b\", \"c\".\n+//Example 2:\n+//Input: \"aaa\"\n+//Output: 6\n+//Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n+//Note:\n+//The input string length won't exceed 1000.\n+\n+class PalindromicSubstrings {\n+    int result = 0;\n+    public int countSubstrings(String s) {\n+        if(s == null || s.length() == 0) {\n+            return 0;\n+        }\n+        \n+        for(int i = 0; i < s.length(); i++) {\n+            extendPalindrome(s, i, i);\n+            extendPalindrome(s, i, i + 1);\n+        }\n+        \n+        return result;\n+    }\n+    \n+    public void extendPalindrome(String s, int left, int right) {\n+        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n+            result++;\n+            left--;\n+            right++;\n+        }\n+    }\n+}\n+\n\ndiff --git a/company/linkedin/PaintHouse.java b/company/linkedin/PaintHouse.java\n--- a/company/linkedin/PaintHouse.java\n+++ b/company/linkedin/PaintHouse.java\n@@ -0,0 +1,26 @@\n+//There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. \n+//The cost of painting each house with a certain color is different. You have to paint all the houses such \n+//that no two adjacent houses have the same color.\n+\n+//The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, \n+//costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 \n+//with color green, and so on... Find the minimum cost to paint all houses.\n+\n+//Note:\n+//All costs are positive integers.\n+\n+class PaintHouse {\n+    public int minCost(int[][] costs) {\n+        if(costs == null || costs.length == 0) {\n+            return 0;\n+        }\n+        \n+        for(int i = 1; i < costs.length; i++) {\n+            costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n+            costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n+            costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n+        }\n+        \n+        return Math.min(Math.min(costs[costs.length - 1][0], costs[costs.length - 1][1]), costs[costs.length - 1][2]);\n+    }\n+}\n\ndiff --git a/company/linkedin/PalindromicSubstrings.java b/company/linkedin/PalindromicSubstrings.java\n--- a/company/linkedin/PalindromicSubstrings.java\n+++ b/company/linkedin/PalindromicSubstrings.java\n@@ -0,0 +1,39 @@\n+//Given a string, your task is to count how many palindromic substrings in this string.\n+//The substrings with different start indexes or end indexes are counted as different substrings \n+//even they consist of same characters.\n+\n+//Example 1:\n+//Input: \"abc\"\n+//Output: 3\n+//Explanation: Three palindromic strings: \"a\", \"b\", \"c\".\n+//Example 2:\n+//Input: \"aaa\"\n+//Output: 6\n+//Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n+//Note:\n+//The input string length won't exceed 1000.\n+\n+class PalindromicSubstrings {\n+    int result = 0;\n+    public int countSubstrings(String s) {\n+        if(s == null || s.length() == 0) {\n+            return 0;\n+        }\n+        \n+        for(int i = 0; i < s.length(); i++) {\n+            extendPalindrome(s, i, i);\n+            extendPalindrome(s, i, i + 1);\n+        }\n+        \n+        return result;\n+    }\n+    \n+    public void extendPalindrome(String s, int left, int right) {\n+        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n+            result++;\n+            left--;\n+            right++;\n+        }\n+    }\n+}\n+\n\ndiff --git a/leetcode/dynamic-programming/PaintHouse.java b/leetcode/dynamic-programming/PaintHouse.java\n--- a/leetcode/dynamic-programming/PaintHouse.java\n+++ b/leetcode/dynamic-programming/PaintHouse.java\n@@ -0,0 +1,27 @@\n+//There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. \n+//The cost of painting each house with a certain color is different. You have to paint all the houses such \n+//that no two adjacent houses have the same color.\n+\n+//The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, \n+//costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 \n+//with color green, and so on... Find the minimum cost to paint all houses.\n+\n+//Note:\n+//All costs are positive integers.\n+\n+class PaintHouse {\n+    public int minCost(int[][] costs) {\n+        if(costs == null || costs.length == 0) {\n+            return 0;\n+        }\n+        \n+        for(int i = 1; i < costs.length; i++) {\n+            costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n+            costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n+            costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n+        }\n+        \n+        return Math.min(Math.min(costs[costs.length - 1][0], costs[costs.length - 1][1]), costs[costs.length - 1][2]);\n+    }\n+}\n+\n\ndiff --git a/leetcode/dynamic-programming/PalindromicSubstrings.java b/leetcode/dynamic-programming/PalindromicSubstrings.java\n--- a/leetcode/dynamic-programming/PalindromicSubstrings.java\n+++ b/leetcode/dynamic-programming/PalindromicSubstrings.java\n@@ -0,0 +1,39 @@\n+//Given a string, your task is to count how many palindromic substrings in this string.\n+//The substrings with different start indexes or end indexes are counted as different substrings \n+//even they consist of same characters.\n+\n+//Example 1:\n+//Input: \"abc\"\n+//Output: 3\n+//Explanation: Three palindromic strings: \"a\", \"b\", \"c\".\n+//Example 2:\n+//Input: \"aaa\"\n+//Output: 6\n+//Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n+//Note:\n+//The input string length won't exceed 1000.\n+\n+class PalindromicSubstrings {\n+    int result = 0;\n+    public int countSubstrings(String s) {\n+        if(s == null || s.length() == 0) {\n+            return 0;\n+        }\n+        \n+        for(int i = 0; i < s.length(); i++) {\n+            extendPalindrome(s, i, i);\n+            extendPalindrome(s, i, i + 1);\n+        }\n+        \n+        return result;\n+    }\n+    \n+    public void extendPalindrome(String s, int left, int right) {\n+        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n+            result++;\n+            left--;\n+            right++;\n+        }\n+    }\n+}\n+\n\ndiff --git a/leetcode/string/PalindromicSubstrings.java b/leetcode/string/PalindromicSubstrings.java\n--- a/leetcode/string/PalindromicSubstrings.java\n+++ b/leetcode/string/PalindromicSubstrings.java\n@@ -0,0 +1,38 @@\n+//Given a string, your task is to count how many palindromic substrings in this string.\n+//The substrings with different start indexes or end indexes are counted as different substrings \n+//even they consist of same characters.\n+\n+//Example 1:\n+//Input: \"abc\"\n+//Output: 3\n+//Explanation: Three palindromic strings: \"a\", \"b\", \"c\".\n+//Example 2:\n+//Input: \"aaa\"\n+//Output: 6\n+//Explanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n+//Note:\n+//The input string length won't exceed 1000.\n+\n+class PalindromicSubstrings {\n+    int result = 0;\n+    public int countSubstrings(String s) {\n+        if(s == null || s.length() == 0) {\n+            return 0;\n+        }\n+        \n+        for(int i = 0; i < s.length(); i++) {\n+            extendPalindrome(s, i, i);\n+            extendPalindrome(s, i, i + 1);\n+        }\n+        \n+        return result;\n+    }\n+    \n+    public void extendPalindrome(String s, int left, int right) {\n+        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n+            result++;\n+            left--;\n+            right++;\n+        }\n+    }\n+}",
    "output": "add PalindromicSubstrings and PaintHouse"
  },
  {
    "input": "diff --git a/company/amazon/MinCostClimbingStairs.java b/company/amazon/MinCostClimbingStairs.java\n--- a/company/amazon/MinCostClimbingStairs.java\n+++ b/company/amazon/MinCostClimbingStairs.java\n@@ -0,0 +1,38 @@\n+//On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).\n+//\n+//Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\n+//\n+//Example 1:\n+//Input: cost = [10, 15, 20]\n+//Output: 15\n+//Explanation: Cheapest is start on cost[1], pay that cost and go to the top.\n+//Example 2:\n+//Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n+//Output: 6\n+//Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].\n+//Note:\n+//cost will have a length in the range [2, 1000].\n+//Every cost[i] will be an integer in the range [0, 999].\n+\n+class MinCostClimbingStairs {\n+    public int minCostClimbingStairs(int[] cost) {\n+        if(cost == null || cost.length == 0) {\n+            return 0;\n+        }\n+        if(cost.length == 1) {\n+            return cost[0];\n+        }\n+        if(cost.length == 2) {\n+            return Math.min(cost[0], cost[1]);\n+        }\n+        \n+        int[] dp = new int[cost.length];\n+        dp[0] = cost[0];\n+        dp[1] = cost[1];\n+        for(int i = 2; i < cost.length; i++) {\n+            dp[i] = Math.min(dp[i - 1] + cost[i], dp[i - 2] + cost[i]);\n+        }\n+        \n+        return Math.min(dp[cost.length - 1], dp[cost.length -2]);\n+    }\n+}\n\ndiff --git a/leetcode/array/MinCostClimbingStairs.java b/leetcode/array/MinCostClimbingStairs.java\n--- a/leetcode/array/MinCostClimbingStairs.java\n+++ b/leetcode/array/MinCostClimbingStairs.java\n@@ -0,0 +1,39 @@\n+//On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).\n+//\n+//Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\n+//\n+//Example 1:\n+//Input: cost = [10, 15, 20]\n+//Output: 15\n+//Explanation: Cheapest is start on cost[1], pay that cost and go to the top.\n+//Example 2:\n+//Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n+//Output: 6\n+//Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].\n+//Note:\n+//cost will have a length in the range [2, 1000].\n+//Every cost[i] will be an integer in the range [0, 999].\n+\n+class MinCostClimbingStairs {\n+    public int minCostClimbingStairs(int[] cost) {\n+        if(cost == null || cost.length == 0) {\n+            return 0;\n+        }\n+        if(cost.length == 1) {\n+            return cost[0];\n+        }\n+        if(cost.length == 2) {\n+            return Math.min(cost[0], cost[1]);\n+        }\n+        \n+        int[] dp = new int[cost.length];\n+        dp[0] = cost[0];\n+        dp[1] = cost[1];\n+        for(int i = 2; i < cost.length; i++) {\n+            dp[i] = Math.min(dp[i - 1] + cost[i], dp[i - 2] + cost[i]);\n+        }\n+        \n+        return Math.min(dp[cost.length - 1], dp[cost.length -2]);\n+    }\n+}\n+\n\ndiff --git a/leetcode/dynamic-programming/MinCostClimbingStairs.java b/leetcode/dynamic-programming/MinCostClimbingStairs.java\n--- a/leetcode/dynamic-programming/MinCostClimbingStairs.java\n+++ b/leetcode/dynamic-programming/MinCostClimbingStairs.java\n@@ -0,0 +1,39 @@\n+//On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).\n+//\n+//Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\n+//\n+//Example 1:\n+//Input: cost = [10, 15, 20]\n+//Output: 15\n+//Explanation: Cheapest is start on cost[1], pay that cost and go to the top.\n+//Example 2:\n+//Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n+//Output: 6\n+//Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].\n+//Note:\n+//cost will have a length in the range [2, 1000].\n+//Every cost[i] will be an integer in the range [0, 999].\n+\n+class MinCostClimbingStairs {\n+    public int minCostClimbingStairs(int[] cost) {\n+        if(cost == null || cost.length == 0) {\n+            return 0;\n+        }\n+        if(cost.length == 1) {\n+            return cost[0];\n+        }\n+        if(cost.length == 2) {\n+            return Math.min(cost[0], cost[1]);\n+        }\n+        \n+        int[] dp = new int[cost.length];\n+        dp[0] = cost[0];\n+        dp[1] = cost[1];\n+        for(int i = 2; i < cost.length; i++) {\n+            dp[i] = Math.min(dp[i - 1] + cost[i], dp[i - 2] + cost[i]);\n+        }\n+        \n+        return Math.min(dp[cost.length - 1], dp[cost.length -2]);\n+    }\n+}\n+",
    "output": "add MinCostClimbingStairs"
  },
  {
    "input": "diff --git a/company/airbnb/HouseRobber.java b/company/airbnb/HouseRobber.java\n--- a/company/airbnb/HouseRobber.java\n+++ b/company/airbnb/HouseRobber.java\n@@ -20,10 +20,6 @@ public int rob(int[] nums) {\n         for(int i = 2; i < nums.length; i++) {\n             dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n         }\n-\n-        for(int i = 0; i < dp.length; i++) {\n-            System.out.print(dp[i] + \" \");\n-        }\n         \n         return dp[dp.length - 1];\n     }\n\ndiff --git a/company/linkedin/HouseRobber.java b/company/linkedin/HouseRobber.java\n--- a/company/linkedin/HouseRobber.java\n+++ b/company/linkedin/HouseRobber.java\n@@ -6,7 +6,6 @@ public class HouseRobber {\n     public int rob(int[] nums) {\n         if(nums.length == 0) {\n             return 0;\n-\n         }\n \n         if(nums.length == 1) {\n@@ -22,10 +21,6 @@ public int rob(int[] nums) {\n             dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n         }\n \n-        for(int i = 0; i < dp.length; i++) {\n-            System.out.print(dp[i] + \" \");\n-        }\n-\n         return dp[dp.length - 1];\n     }\n }\n\ndiff --git a/leetcode/dynamic-programming/HouseRobber.java b/leetcode/dynamic-programming/HouseRobber.java\n--- a/leetcode/dynamic-programming/HouseRobber.java\n+++ b/leetcode/dynamic-programming/HouseRobber.java\n@@ -21,10 +21,6 @@ public int rob(int[] nums) {\n             dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n         }\n         \n-        for(int i = 0; i < dp.length; i++) {\n-            System.out.print(dp[i] + \" \");\n-        }\n-        \n         return dp[dp.length - 1];\n     }\n }",
    "output": "edit house robber, update README"
  },
  {
    "input": "diff --git a/company/apple/ValidSudoku.java b/company/apple/ValidSudoku.java\n--- a/company/apple/ValidSudoku.java\n+++ b/company/apple/ValidSudoku.java\n@@ -0,0 +1,31 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n+\n\ndiff --git a/company/snapchat/ValidSudoku.java b/company/snapchat/ValidSudoku.java\n--- a/company/snapchat/ValidSudoku.java\n+++ b/company/snapchat/ValidSudoku.java\n@@ -0,0 +1,31 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n+\n\ndiff --git a/company/uber/ValidSudoku.java b/company/uber/ValidSudoku.java\n--- a/company/uber/ValidSudoku.java\n+++ b/company/uber/ValidSudoku.java\n@@ -0,0 +1,30 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n\ndiff --git a/leetcode/hash-table/ValidSudoku.java b/leetcode/hash-table/ValidSudoku.java\n--- a/leetcode/hash-table/ValidSudoku.java\n+++ b/leetcode/hash-table/ValidSudoku.java\n@@ -0,0 +1,31 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n+",
    "output": "add valid sudoku"
  },
  {
    "input": "diff --git a/company/facebook/ExclusiveTimeOfFunctions.java b/company/facebook/ExclusiveTimeOfFunctions.java\n--- a/company/facebook/ExclusiveTimeOfFunctions.java\n+++ b/company/facebook/ExclusiveTimeOfFunctions.java\n@@ -0,0 +1,55 @@\n+//Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.\n+\n+//Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.\n+\n+//A log is a string has this format : function_id:start_or_end:timestamp. For example, \"0:start:0\" means function 0 starts from the very beginning of time 0. \"0:end:0\" means function 0 ends to the very end of time 0.\n+\n+//Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id.\n+\n+//Example 1:\n+//Input:\n+//n = 2\n+//logs = \n+//[\"0:start:0\",\n+ //\"1:start:2\",\n+ //\"1:end:5\",\n+ //\"0:end:6\"]\n+//Output:[3, 4]\n+//Explanation:\n+//Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. \n+//Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.\n+//Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. \n+//So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.\n+//Note:\n+//Input logs will be sorted by timestamp, NOT log id.\n+//Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.\n+//Two functions won't start or end at the same time.\n+//Functions could be called recursively, and will always end.\n+//1 <= n <= 100\n+\n+class ExclusiveTimeOfFunctions {\n+    public int[] exclusiveTime(int n, List<String> logs) {\n+        Stack<Integer> stack = new Stack <Integer>();\n+        int[] result = new int[n];\n+        String[] current = logs.get(0).split(\":\");\n+        stack.push(Integer.parseInt(current[0]));\n+        int i = 1;\n+        int previous = Integer.parseInt(current[2]);\n+        while (i < logs.size()) {\n+            current = logs.get(i).split(\":\");\n+            if (current[1].equals(\"start\")) {\n+                if (!stack.isEmpty()) {\n+                    result[stack.peek()] += Integer.parseInt(current[2]) - previous;\n+                }\n+                stack.push(Integer.parseInt(current[0]));\n+                previous = Integer.parseInt(current[2]);\n+            } else {\n+                result[stack.peek()] += Integer.parseInt(current[2]) - previous + 1;\n+                stack.pop();\n+                previous = Integer.parseInt(current[2]) + 1;\n+            }\n+            i++;\n+        }\n+        return result;\n+    }\n+}\n\ndiff --git a/company/uber/ExclusiveTimeOfFunctions.java b/company/uber/ExclusiveTimeOfFunctions.java\n--- a/company/uber/ExclusiveTimeOfFunctions.java\n+++ b/company/uber/ExclusiveTimeOfFunctions.java\n@@ -0,0 +1,56 @@\n+//Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.\n+\n+//Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.\n+\n+//A log is a string has this format : function_id:start_or_end:timestamp. For example, \"0:start:0\" means function 0 starts from the very beginning of time 0. \"0:end:0\" means function 0 ends to the very end of time 0.\n+\n+//Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id.\n+\n+//Example 1:\n+//Input:\n+//n = 2\n+//logs = \n+//[\"0:start:0\",\n+ //\"1:start:2\",\n+ //\"1:end:5\",\n+ //\"0:end:6\"]\n+//Output:[3, 4]\n+//Explanation:\n+//Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. \n+//Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.\n+//Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. \n+//So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.\n+//Note:\n+//Input logs will be sorted by timestamp, NOT log id.\n+//Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.\n+//Two functions won't start or end at the same time.\n+//Functions could be called recursively, and will always end.\n+//1 <= n <= 100\n+\n+class ExclusiveTimeOfFunctions {\n+    public int[] exclusiveTime(int n, List<String> logs) {\n+        Stack<Integer> stack = new Stack <Integer>();\n+        int[] result = new int[n];\n+        String[] current = logs.get(0).split(\":\");\n+        stack.push(Integer.parseInt(current[0]));\n+        int i = 1;\n+        int previous = Integer.parseInt(current[2]);\n+        while (i < logs.size()) {\n+            current = logs.get(i).split(\":\");\n+            if (current[1].equals(\"start\")) {\n+                if (!stack.isEmpty()) {\n+                    result[stack.peek()] += Integer.parseInt(current[2]) - previous;\n+                }\n+                stack.push(Integer.parseInt(current[0]));\n+                previous = Integer.parseInt(current[2]);\n+            } else {\n+                result[stack.peek()] += Integer.parseInt(current[2]) - previous + 1;\n+                stack.pop();\n+                previous = Integer.parseInt(current[2]) + 1;\n+            }\n+            i++;\n+        }\n+        return result;\n+    }\n+}\n+\n\ndiff --git a/leetcode/stack/ExclusiveTimeOfFunctions.java b/leetcode/stack/ExclusiveTimeOfFunctions.java\n--- a/leetcode/stack/ExclusiveTimeOfFunctions.java\n+++ b/leetcode/stack/ExclusiveTimeOfFunctions.java\n@@ -0,0 +1,56 @@\n+//Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.\n+\n+//Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.\n+\n+//A log is a string has this format : function_id:start_or_end:timestamp. For example, \"0:start:0\" means function 0 starts from the very beginning of time 0. \"0:end:0\" means function 0 ends to the very end of time 0.\n+\n+//Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id.\n+\n+//Example 1:\n+//Input:\n+//n = 2\n+//logs = \n+//[\"0:start:0\",\n+ //\"1:start:2\",\n+ //\"1:end:5\",\n+ //\"0:end:6\"]\n+//Output:[3, 4]\n+//Explanation:\n+//Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. \n+//Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.\n+//Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. \n+//So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.\n+//Note:\n+//Input logs will be sorted by timestamp, NOT log id.\n+//Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.\n+//Two functions won't start or end at the same time.\n+//Functions could be called recursively, and will always end.\n+//1 <= n <= 100\n+\n+class ExclusiveTimeOfFunctions {\n+    public int[] exclusiveTime(int n, List<String> logs) {\n+        Stack<Integer> stack = new Stack <Integer>();\n+        int[] result = new int[n];\n+        String[] current = logs.get(0).split(\":\");\n+        stack.push(Integer.parseInt(current[0]));\n+        int i = 1;\n+        int previous = Integer.parseInt(current[2]);\n+        while (i < logs.size()) {\n+            current = logs.get(i).split(\":\");\n+            if (current[1].equals(\"start\")) {\n+                if (!stack.isEmpty()) {\n+                    result[stack.peek()] += Integer.parseInt(current[2]) - previous;\n+                }\n+                stack.push(Integer.parseInt(current[0]));\n+                previous = Integer.parseInt(current[2]);\n+            } else {\n+                result[stack.peek()] += Integer.parseInt(current[2]) - previous + 1;\n+                stack.pop();\n+                previous = Integer.parseInt(current[2]) + 1;\n+            }\n+            i++;\n+        }\n+        return result;\n+    }\n+}\n+",
    "output": "ExclusiveTimeOfFunctions.java"
  },
  {
    "input": "diff --git a/company/bloomberg/UniquePaths.java b/company/bloomberg/UniquePaths.java\n--- a/company/bloomberg/UniquePaths.java\n+++ b/company/bloomberg/UniquePaths.java\n@@ -0,0 +1,33 @@\n+//A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n+//\n+//The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n+//\n+//How many possible unique paths are there?\n+\n+class UniquePaths {\n+    public int uniquePaths(int m, int n) {\n+        Integer[][] map = new Integer[m][n];\n+        \n+        //only 1 way to get to ith row, 0th column (move down)\n+        for(int i = 0; i < m; i++){\n+            map[i][0] = 1;\n+        }\n+        \n+        //only 1 way to get to ith column, 0th row (move right)\n+        for(int j= 0; j < n; j++){\n+            map[0][j]=1;\n+        }\n+        \n+        //x ways to get to ith row, jth column (# of ways to get to\n+        //ith - 1 row, jth column + # of ways to get to jth - 1 column\n+        //ith column\n+        for(int i = 1;i < m; i++){\n+            for(int j = 1; j < n; j++){\n+                map[i][j] = map[i - 1][j] + map[i][j - 1];\n+            }\n+        }\n+\n+        return map[m - 1][n - 1];\n+    }\n+}\n+\n\ndiff --git a/company/linkedin/Permutations.java b/company/linkedin/Permutations.java\n--- a/company/linkedin/Permutations.java\n+++ b/company/linkedin/Permutations.java\n@@ -0,0 +1,34 @@\n+//Given a collection of distinct numbers, return all possible permutations.\n+//\n+//For example,\n+//[1,2,3] have the following permutations:\n+//[\n+  //[1,2,3],\n+  //[1,3,2],\n+  //[2,1,3],\n+  //[2,3,1],\n+  //[3,1,2],\n+  //[3,2,1]\n+//]\n+\n+class Permutations {\n+    public List<List<Integer>> permute(int[] nums) {\n+        LinkedList<List<Integer>> result = new LinkedList<List<Integer>>();\n+        result.add(new ArrayList<Integer>());\n+        for (int n: nums) {\n+            int size = result.size();\n+            while(size > 0) {\n+                List<Integer> current = result.pollFirst();\n+                for (int i = 0; i <= current.size(); i++) {\n+                    List<Integer> temp = new ArrayList<Integer>(current);\n+                    temp.add(i, n);\n+                    result.add(temp);\n+                }\n+                size--;\n+            }\n+        }\n+\n+        return result;\n+    }\n+}\n+\n\ndiff --git a/company/microsoft/Permutations.java b/company/microsoft/Permutations.java\n--- a/company/microsoft/Permutations.java\n+++ b/company/microsoft/Permutations.java\n@@ -0,0 +1,34 @@\n+//Given a collection of distinct numbers, return all possible permutations.\n+//\n+//For example,\n+//[1,2,3] have the following permutations:\n+//[\n+  //[1,2,3],\n+  //[1,3,2],\n+  //[2,1,3],\n+  //[2,3,1],\n+  //[3,1,2],\n+  //[3,2,1]\n+//]\n+\n+class Permutations {\n+    public List<List<Integer>> permute(int[] nums) {\n+        LinkedList<List<Integer>> result = new LinkedList<List<Integer>>();\n+        result.add(new ArrayList<Integer>());\n+        for (int n: nums) {\n+            int size = result.size();\n+            while(size > 0) {\n+                List<Integer> current = result.pollFirst();\n+                for (int i = 0; i <= current.size(); i++) {\n+                    List<Integer> temp = new ArrayList<Integer>(current);\n+                    temp.add(i, n);\n+                    result.add(temp);\n+                }\n+                size--;\n+            }\n+        }\n+\n+        return result;\n+    }\n+}\n+\n\ndiff --git a/leetcode/array/UniquePaths.java b/leetcode/array/UniquePaths.java\n--- a/leetcode/array/UniquePaths.java\n+++ b/leetcode/array/UniquePaths.java\n@@ -0,0 +1,32 @@\n+//A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n+//\n+//The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n+//\n+//How many possible unique paths are there?\n+\n+class UniquePaths {\n+    public int uniquePaths(int m, int n) {\n+        Integer[][] map = new Integer[m][n];\n+        \n+        //only 1 way to get to ith row, 0th column (move down)\n+        for(int i = 0; i < m; i++){\n+            map[i][0] = 1;\n+        }\n+        \n+        //only 1 way to get to ith column, 0th row (move right)\n+        for(int j= 0; j < n; j++){\n+            map[0][j]=1;\n+        }\n+        \n+        //x ways to get to ith row, jth column (# of ways to get to\n+        //ith - 1 row, jth column + # of ways to get to jth - 1 column\n+        //ith column\n+        for(int i = 1;i < m; i++){\n+            for(int j = 1; j < n; j++){\n+                map[i][j] = map[i - 1][j] + map[i][j - 1];\n+            }\n+        }\n+\n+        return map[m - 1][n - 1];\n+    }\n+}\n\ndiff --git a/leetcode/backtracking/Permutations.java b/leetcode/backtracking/Permutations.java\n--- a/leetcode/backtracking/Permutations.java\n+++ b/leetcode/backtracking/Permutations.java\n@@ -0,0 +1,33 @@\n+//Given a collection of distinct numbers, return all possible permutations.\n+//\n+//For example,\n+//[1,2,3] have the following permutations:\n+//[\n+  //[1,2,3],\n+  //[1,3,2],\n+  //[2,1,3],\n+  //[2,3,1],\n+  //[3,1,2],\n+  //[3,2,1]\n+//]\n+\n+class Permutations {\n+    public List<List<Integer>> permute(int[] nums) {\n+        LinkedList<List<Integer>> result = new LinkedList<List<Integer>>();\n+        result.add(new ArrayList<Integer>());\n+        for (int n: nums) {\n+            int size = result.size();\n+            while(size > 0) {\n+                List<Integer> current = result.pollFirst();\n+                for (int i = 0; i <= current.size(); i++) {\n+                    List<Integer> temp = new ArrayList<Integer>(current);\n+                    temp.add(i, n);\n+                    result.add(temp);\n+                }\n+                size--;\n+            }\n+        }\n+\n+        return result;\n+    }\n+}\n\ndiff --git a/leetcode/dynamic-programming/UniquePaths.java b/leetcode/dynamic-programming/UniquePaths.java\n--- a/leetcode/dynamic-programming/UniquePaths.java\n+++ b/leetcode/dynamic-programming/UniquePaths.java\n@@ -0,0 +1,33 @@\n+//A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n+//\n+//The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n+//\n+//How many possible unique paths are there?\n+\n+class UniquePaths {\n+    public int uniquePaths(int m, int n) {\n+        Integer[][] map = new Integer[m][n];\n+        \n+        //only 1 way to get to ith row, 0th column (move down)\n+        for(int i = 0; i < m; i++){\n+            map[i][0] = 1;\n+        }\n+        \n+        //only 1 way to get to ith column, 0th row (move right)\n+        for(int j= 0; j < n; j++){\n+            map[0][j]=1;\n+        }\n+        \n+        //x ways to get to ith row, jth column (# of ways to get to\n+        //ith - 1 row, jth column + # of ways to get to jth - 1 column\n+        //ith column\n+        for(int i = 1;i < m; i++){\n+            for(int j = 1; j < n; j++){\n+                map[i][j] = map[i - 1][j] + map[i][j - 1];\n+            }\n+        }\n+\n+        return map[m - 1][n - 1];\n+    }\n+}\n+",
    "output": "adding additional problems"
  },
  {
    "input": "diff --git a/leetcode/brainteaser/BulbSwitcher.java b/leetcode/brainteaser/BulbSwitcher.java\n--- a/leetcode/brainteaser/BulbSwitcher.java\n+++ b/leetcode/brainteaser/BulbSwitcher.java\n@@ -0,0 +1,17 @@\n+//There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\n+//Example:\n+//Given n = 3. \n+\n+//At first, the three bulbs are [off, off, off].\n+//After first round, the three bulbs are [on, on, on].\n+//After second round, the three bulbs are [on, off, on].\n+//After third round, the three bulbs are [on, off, off]. \n+\n+//So you should return 1, because there is only one bulb is on.\n+\n+class BulbSwitcher {\n+    public int bulbSwitch(int n) {\n+        return (int)Math.sqrt(n);\n+    }\n+}\n+\n\ndiff --git a/leetcode/math/BulbSwitcher.java b/leetcode/math/BulbSwitcher.java\n--- a/leetcode/math/BulbSwitcher.java\n+++ b/leetcode/math/BulbSwitcher.java\n@@ -0,0 +1,16 @@\n+//There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\n+//Example:\n+//Given n = 3. \n+\n+//At first, the three bulbs are [off, off, off].\n+//After first round, the three bulbs are [on, on, on].\n+//After second round, the three bulbs are [on, off, on].\n+//After third round, the three bulbs are [on, off, off]. \n+\n+//So you should return 1, because there is only one bulb is on.\n+\n+class BulbSwitcher {\n+    public int bulbSwitch(int n) {\n+        return (int)Math.sqrt(n);\n+    }\n+}",
    "output": "added brainteaser directory"
  },
  {
    "input": "diff --git a/company/airbnb/ContainsDuplicate.java b/company/airbnb/ContainsDuplicate.java\n--- a/company/airbnb/ContainsDuplicate.java\n+++ b/company/airbnb/ContainsDuplicate.java\n@@ -0,0 +1,18 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}\n+\n\ndiff --git a/company/palantir/ContainsDuplicate.java b/company/palantir/ContainsDuplicate.java\n--- a/company/palantir/ContainsDuplicate.java\n+++ b/company/palantir/ContainsDuplicate.java\n@@ -0,0 +1,18 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}\n+\n\ndiff --git a/company/yahoo/ContainsDuplicate.java b/company/yahoo/ContainsDuplicate.java\n--- a/company/yahoo/ContainsDuplicate.java\n+++ b/company/yahoo/ContainsDuplicate.java\n@@ -0,0 +1,18 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}\n+\n\ndiff --git a/leetcode/hash-table/ContainsDuplicate.java b/leetcode/hash-table/ContainsDuplicate.java\n--- a/leetcode/hash-table/ContainsDuplicate.java\n+++ b/leetcode/hash-table/ContainsDuplicate.java\n@@ -0,0 +1,17 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}",
    "output": "added yahoo and palantir directories"
  },
  {
    "input": "diff --git a/company/apple/ReverseWordsInAString.java b/company/apple/ReverseWordsInAString.java\n--- a/company/apple/ReverseWordsInAString.java\n+++ b/company/apple/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/bloomberg/ReverseWordsInAString.java b/company/bloomberg/ReverseWordsInAString.java\n--- a/company/bloomberg/ReverseWordsInAString.java\n+++ b/company/bloomberg/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/microsoft/ReverseWordsInAString.java b/company/microsoft/ReverseWordsInAString.java\n--- a/company/microsoft/ReverseWordsInAString.java\n+++ b/company/microsoft/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/snapchat/ReverseWordsInAString.java b/company/snapchat/ReverseWordsInAString.java\n--- a/company/snapchat/ReverseWordsInAString.java\n+++ b/company/snapchat/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/yelp/ReverseWordsInAString.java b/company/yelp/ReverseWordsInAString.java\n--- a/company/yelp/ReverseWordsInAString.java\n+++ b/company/yelp/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/leetcode/string/ReverseWordsInAString.java b/leetcode/string/ReverseWordsInAString.java\n--- a/leetcode/string/ReverseWordsInAString.java\n+++ b/leetcode/string/ReverseWordsInAString.java\n@@ -0,0 +1,16 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}",
    "output": "added directories for snapchat, yelp, and apple"
  },
  {
    "input": "diff --git a/company/adobe/MajorityElement.java b/company/adobe/MajorityElement.java\n--- a/company/adobe/MajorityElement.java\n+++ b/company/adobe/MajorityElement.java\n@@ -0,0 +1,24 @@\n+//Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n+//You may assume that the array is non-empty and the majority element always exist in the array.\n+\n+class MajorityElement {\n+    public int majorityElement(int[] nums) {\n+        if(nums.length == 1) {\n+            return nums[0];\n+        }\n+        \n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int current: nums) {\n+            if(map.containsKey(current) && map.get(current) + 1 > nums.length / 2) {\n+                return current;\n+            } else if(map.containsKey(current)) {\n+                map.put(current, map.get(current) + 1);\n+            } else {\n+                map.put(current, 1);\n+            }\n+        }\n+        \n+        //no majority element exists\n+        return -1;\n+    }\n+}\n\ndiff --git a/leetcode/array/MajorityElement.java b/leetcode/array/MajorityElement.java\n--- a/leetcode/array/MajorityElement.java\n+++ b/leetcode/array/MajorityElement.java\n@@ -0,0 +1,24 @@\n+//Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n+//You may assume that the array is non-empty and the majority element always exist in the array.\n+\n+class MajorityElement {\n+    public int majorityElement(int[] nums) {\n+        if(nums.length == 1) {\n+            return nums[0];\n+        }\n+        \n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int current: nums) {\n+            if(map.containsKey(current) && map.get(current) + 1 > nums.length / 2) {\n+                return current;\n+            } else if(map.containsKey(current)) {\n+                map.put(current, map.get(current) + 1);\n+            } else {\n+                map.put(current, 1);\n+            }\n+        }\n+        \n+        //no majority element exists\n+        return -1;\n+    }\n+}",
    "output": "add adobe directory"
  },
  {
    "input": "diff --git a/company/airbnb/HouseRobber.java b/company/airbnb/HouseRobber.java\n--- a/company/airbnb/HouseRobber.java\n+++ b/company/airbnb/HouseRobber.java\n@@ -20,10 +20,6 @@ public int rob(int[] nums) {\n         for(int i = 2; i < nums.length; i++) {\n             dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n         }\n-\n-        for(int i = 0; i < dp.length; i++) {\n-            System.out.print(dp[i] + \" \");\n-        }\n         \n         return dp[dp.length - 1];\n     }\n\ndiff --git a/company/linkedin/HouseRobber.java b/company/linkedin/HouseRobber.java\n--- a/company/linkedin/HouseRobber.java\n+++ b/company/linkedin/HouseRobber.java\n@@ -6,7 +6,6 @@ public class HouseRobber {\n     public int rob(int[] nums) {\n         if(nums.length == 0) {\n             return 0;\n-\n         }\n \n         if(nums.length == 1) {\n@@ -22,10 +21,6 @@ public int rob(int[] nums) {\n             dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n         }\n \n-        for(int i = 0; i < dp.length; i++) {\n-            System.out.print(dp[i] + \" \");\n-        }\n-\n         return dp[dp.length - 1];\n     }\n }\n\ndiff --git a/leetcode/dynamic-programming/HouseRobber.java b/leetcode/dynamic-programming/HouseRobber.java\n--- a/leetcode/dynamic-programming/HouseRobber.java\n+++ b/leetcode/dynamic-programming/HouseRobber.java\n@@ -21,10 +21,6 @@ public int rob(int[] nums) {\n             dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n         }\n         \n-        for(int i = 0; i < dp.length; i++) {\n-            System.out.print(dp[i] + \" \");\n-        }\n-        \n         return dp[dp.length - 1];\n     }\n }",
    "output": "edit house robber, update README"
  },
  {
    "input": "diff --git a/company/apple/ValidSudoku.java b/company/apple/ValidSudoku.java\n--- a/company/apple/ValidSudoku.java\n+++ b/company/apple/ValidSudoku.java\n@@ -0,0 +1,31 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n+\n\ndiff --git a/company/snapchat/ValidSudoku.java b/company/snapchat/ValidSudoku.java\n--- a/company/snapchat/ValidSudoku.java\n+++ b/company/snapchat/ValidSudoku.java\n@@ -0,0 +1,31 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n+\n\ndiff --git a/company/uber/ValidSudoku.java b/company/uber/ValidSudoku.java\n--- a/company/uber/ValidSudoku.java\n+++ b/company/uber/ValidSudoku.java\n@@ -0,0 +1,30 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n\ndiff --git a/leetcode/hash-table/ValidSudoku.java b/leetcode/hash-table/ValidSudoku.java\n--- a/leetcode/hash-table/ValidSudoku.java\n+++ b/leetcode/hash-table/ValidSudoku.java\n@@ -0,0 +1,31 @@\n+//Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. (http://sudoku.com.au/TheRules.aspx)\n+//The Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n+//A partially filled sudoku which is valid.\n+\n+//Note:\n+//A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n+\n+class ValidSudoku {\n+    public boolean isValidSudoku(char[][] board) {\n+        for(int i = 0; i < board.length; i++){\n+            HashSet<Character> rows = new HashSet<Character>();\n+            HashSet<Character> columns = new HashSet<Character>();\n+            HashSet<Character> box = new HashSet<Character>();\n+            for (int j = 0; j < board[0].length; j++){\n+                if(board[i][j] != '.' && !rows.add(board[i][j])) {\n+                    return false;\n+                }\n+                if(board[j][i]!='.' && !columns.add(board[j][i])) {\n+                    return false;\n+                }\n+                int rowIndex = (i / 3) * 3;\n+                int columnIndex = (i % 3) * 3;\n+                if(board[rowIndex + j / 3][columnIndex + j % 3] != '.' && !box.add(board[rowIndex + j / 3][columnIndex + j % 3])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n+",
    "output": "add valid sudoku"
  },
  {
    "input": "diff --git a/company/facebook/ExclusiveTimeOfFunctions.java b/company/facebook/ExclusiveTimeOfFunctions.java\n--- a/company/facebook/ExclusiveTimeOfFunctions.java\n+++ b/company/facebook/ExclusiveTimeOfFunctions.java\n@@ -0,0 +1,55 @@\n+//Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.\n+\n+//Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.\n+\n+//A log is a string has this format : function_id:start_or_end:timestamp. For example, \"0:start:0\" means function 0 starts from the very beginning of time 0. \"0:end:0\" means function 0 ends to the very end of time 0.\n+\n+//Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id.\n+\n+//Example 1:\n+//Input:\n+//n = 2\n+//logs = \n+//[\"0:start:0\",\n+ //\"1:start:2\",\n+ //\"1:end:5\",\n+ //\"0:end:6\"]\n+//Output:[3, 4]\n+//Explanation:\n+//Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. \n+//Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.\n+//Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. \n+//So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.\n+//Note:\n+//Input logs will be sorted by timestamp, NOT log id.\n+//Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.\n+//Two functions won't start or end at the same time.\n+//Functions could be called recursively, and will always end.\n+//1 <= n <= 100\n+\n+class ExclusiveTimeOfFunctions {\n+    public int[] exclusiveTime(int n, List<String> logs) {\n+        Stack<Integer> stack = new Stack <Integer>();\n+        int[] result = new int[n];\n+        String[] current = logs.get(0).split(\":\");\n+        stack.push(Integer.parseInt(current[0]));\n+        int i = 1;\n+        int previous = Integer.parseInt(current[2]);\n+        while (i < logs.size()) {\n+            current = logs.get(i).split(\":\");\n+            if (current[1].equals(\"start\")) {\n+                if (!stack.isEmpty()) {\n+                    result[stack.peek()] += Integer.parseInt(current[2]) - previous;\n+                }\n+                stack.push(Integer.parseInt(current[0]));\n+                previous = Integer.parseInt(current[2]);\n+            } else {\n+                result[stack.peek()] += Integer.parseInt(current[2]) - previous + 1;\n+                stack.pop();\n+                previous = Integer.parseInt(current[2]) + 1;\n+            }\n+            i++;\n+        }\n+        return result;\n+    }\n+}\n\ndiff --git a/company/uber/ExclusiveTimeOfFunctions.java b/company/uber/ExclusiveTimeOfFunctions.java\n--- a/company/uber/ExclusiveTimeOfFunctions.java\n+++ b/company/uber/ExclusiveTimeOfFunctions.java\n@@ -0,0 +1,56 @@\n+//Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.\n+\n+//Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.\n+\n+//A log is a string has this format : function_id:start_or_end:timestamp. For example, \"0:start:0\" means function 0 starts from the very beginning of time 0. \"0:end:0\" means function 0 ends to the very end of time 0.\n+\n+//Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id.\n+\n+//Example 1:\n+//Input:\n+//n = 2\n+//logs = \n+//[\"0:start:0\",\n+ //\"1:start:2\",\n+ //\"1:end:5\",\n+ //\"0:end:6\"]\n+//Output:[3, 4]\n+//Explanation:\n+//Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. \n+//Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.\n+//Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. \n+//So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.\n+//Note:\n+//Input logs will be sorted by timestamp, NOT log id.\n+//Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.\n+//Two functions won't start or end at the same time.\n+//Functions could be called recursively, and will always end.\n+//1 <= n <= 100\n+\n+class ExclusiveTimeOfFunctions {\n+    public int[] exclusiveTime(int n, List<String> logs) {\n+        Stack<Integer> stack = new Stack <Integer>();\n+        int[] result = new int[n];\n+        String[] current = logs.get(0).split(\":\");\n+        stack.push(Integer.parseInt(current[0]));\n+        int i = 1;\n+        int previous = Integer.parseInt(current[2]);\n+        while (i < logs.size()) {\n+            current = logs.get(i).split(\":\");\n+            if (current[1].equals(\"start\")) {\n+                if (!stack.isEmpty()) {\n+                    result[stack.peek()] += Integer.parseInt(current[2]) - previous;\n+                }\n+                stack.push(Integer.parseInt(current[0]));\n+                previous = Integer.parseInt(current[2]);\n+            } else {\n+                result[stack.peek()] += Integer.parseInt(current[2]) - previous + 1;\n+                stack.pop();\n+                previous = Integer.parseInt(current[2]) + 1;\n+            }\n+            i++;\n+        }\n+        return result;\n+    }\n+}\n+\n\ndiff --git a/leetcode/stack/ExclusiveTimeOfFunctions.java b/leetcode/stack/ExclusiveTimeOfFunctions.java\n--- a/leetcode/stack/ExclusiveTimeOfFunctions.java\n+++ b/leetcode/stack/ExclusiveTimeOfFunctions.java\n@@ -0,0 +1,56 @@\n+//Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.\n+\n+//Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.\n+\n+//A log is a string has this format : function_id:start_or_end:timestamp. For example, \"0:start:0\" means function 0 starts from the very beginning of time 0. \"0:end:0\" means function 0 ends to the very end of time 0.\n+\n+//Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id.\n+\n+//Example 1:\n+//Input:\n+//n = 2\n+//logs = \n+//[\"0:start:0\",\n+ //\"1:start:2\",\n+ //\"1:end:5\",\n+ //\"0:end:6\"]\n+//Output:[3, 4]\n+//Explanation:\n+//Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. \n+//Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.\n+//Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. \n+//So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.\n+//Note:\n+//Input logs will be sorted by timestamp, NOT log id.\n+//Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.\n+//Two functions won't start or end at the same time.\n+//Functions could be called recursively, and will always end.\n+//1 <= n <= 100\n+\n+class ExclusiveTimeOfFunctions {\n+    public int[] exclusiveTime(int n, List<String> logs) {\n+        Stack<Integer> stack = new Stack <Integer>();\n+        int[] result = new int[n];\n+        String[] current = logs.get(0).split(\":\");\n+        stack.push(Integer.parseInt(current[0]));\n+        int i = 1;\n+        int previous = Integer.parseInt(current[2]);\n+        while (i < logs.size()) {\n+            current = logs.get(i).split(\":\");\n+            if (current[1].equals(\"start\")) {\n+                if (!stack.isEmpty()) {\n+                    result[stack.peek()] += Integer.parseInt(current[2]) - previous;\n+                }\n+                stack.push(Integer.parseInt(current[0]));\n+                previous = Integer.parseInt(current[2]);\n+            } else {\n+                result[stack.peek()] += Integer.parseInt(current[2]) - previous + 1;\n+                stack.pop();\n+                previous = Integer.parseInt(current[2]) + 1;\n+            }\n+            i++;\n+        }\n+        return result;\n+    }\n+}\n+",
    "output": "ExclusiveTimeOfFunctions.java"
  },
  {
    "input": "diff --git a/company/bloomberg/UniquePaths.java b/company/bloomberg/UniquePaths.java\n--- a/company/bloomberg/UniquePaths.java\n+++ b/company/bloomberg/UniquePaths.java\n@@ -0,0 +1,33 @@\n+//A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n+//\n+//The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n+//\n+//How many possible unique paths are there?\n+\n+class UniquePaths {\n+    public int uniquePaths(int m, int n) {\n+        Integer[][] map = new Integer[m][n];\n+        \n+        //only 1 way to get to ith row, 0th column (move down)\n+        for(int i = 0; i < m; i++){\n+            map[i][0] = 1;\n+        }\n+        \n+        //only 1 way to get to ith column, 0th row (move right)\n+        for(int j= 0; j < n; j++){\n+            map[0][j]=1;\n+        }\n+        \n+        //x ways to get to ith row, jth column (# of ways to get to\n+        //ith - 1 row, jth column + # of ways to get to jth - 1 column\n+        //ith column\n+        for(int i = 1;i < m; i++){\n+            for(int j = 1; j < n; j++){\n+                map[i][j] = map[i - 1][j] + map[i][j - 1];\n+            }\n+        }\n+\n+        return map[m - 1][n - 1];\n+    }\n+}\n+\n\ndiff --git a/company/linkedin/Permutations.java b/company/linkedin/Permutations.java\n--- a/company/linkedin/Permutations.java\n+++ b/company/linkedin/Permutations.java\n@@ -0,0 +1,34 @@\n+//Given a collection of distinct numbers, return all possible permutations.\n+//\n+//For example,\n+//[1,2,3] have the following permutations:\n+//[\n+  //[1,2,3],\n+  //[1,3,2],\n+  //[2,1,3],\n+  //[2,3,1],\n+  //[3,1,2],\n+  //[3,2,1]\n+//]\n+\n+class Permutations {\n+    public List<List<Integer>> permute(int[] nums) {\n+        LinkedList<List<Integer>> result = new LinkedList<List<Integer>>();\n+        result.add(new ArrayList<Integer>());\n+        for (int n: nums) {\n+            int size = result.size();\n+            while(size > 0) {\n+                List<Integer> current = result.pollFirst();\n+                for (int i = 0; i <= current.size(); i++) {\n+                    List<Integer> temp = new ArrayList<Integer>(current);\n+                    temp.add(i, n);\n+                    result.add(temp);\n+                }\n+                size--;\n+            }\n+        }\n+\n+        return result;\n+    }\n+}\n+\n\ndiff --git a/company/microsoft/Permutations.java b/company/microsoft/Permutations.java\n--- a/company/microsoft/Permutations.java\n+++ b/company/microsoft/Permutations.java\n@@ -0,0 +1,34 @@\n+//Given a collection of distinct numbers, return all possible permutations.\n+//\n+//For example,\n+//[1,2,3] have the following permutations:\n+//[\n+  //[1,2,3],\n+  //[1,3,2],\n+  //[2,1,3],\n+  //[2,3,1],\n+  //[3,1,2],\n+  //[3,2,1]\n+//]\n+\n+class Permutations {\n+    public List<List<Integer>> permute(int[] nums) {\n+        LinkedList<List<Integer>> result = new LinkedList<List<Integer>>();\n+        result.add(new ArrayList<Integer>());\n+        for (int n: nums) {\n+            int size = result.size();\n+            while(size > 0) {\n+                List<Integer> current = result.pollFirst();\n+                for (int i = 0; i <= current.size(); i++) {\n+                    List<Integer> temp = new ArrayList<Integer>(current);\n+                    temp.add(i, n);\n+                    result.add(temp);\n+                }\n+                size--;\n+            }\n+        }\n+\n+        return result;\n+    }\n+}\n+\n\ndiff --git a/leetcode/array/UniquePaths.java b/leetcode/array/UniquePaths.java\n--- a/leetcode/array/UniquePaths.java\n+++ b/leetcode/array/UniquePaths.java\n@@ -0,0 +1,32 @@\n+//A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n+//\n+//The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n+//\n+//How many possible unique paths are there?\n+\n+class UniquePaths {\n+    public int uniquePaths(int m, int n) {\n+        Integer[][] map = new Integer[m][n];\n+        \n+        //only 1 way to get to ith row, 0th column (move down)\n+        for(int i = 0; i < m; i++){\n+            map[i][0] = 1;\n+        }\n+        \n+        //only 1 way to get to ith column, 0th row (move right)\n+        for(int j= 0; j < n; j++){\n+            map[0][j]=1;\n+        }\n+        \n+        //x ways to get to ith row, jth column (# of ways to get to\n+        //ith - 1 row, jth column + # of ways to get to jth - 1 column\n+        //ith column\n+        for(int i = 1;i < m; i++){\n+            for(int j = 1; j < n; j++){\n+                map[i][j] = map[i - 1][j] + map[i][j - 1];\n+            }\n+        }\n+\n+        return map[m - 1][n - 1];\n+    }\n+}\n\ndiff --git a/leetcode/backtracking/Permutations.java b/leetcode/backtracking/Permutations.java\n--- a/leetcode/backtracking/Permutations.java\n+++ b/leetcode/backtracking/Permutations.java\n@@ -0,0 +1,33 @@\n+//Given a collection of distinct numbers, return all possible permutations.\n+//\n+//For example,\n+//[1,2,3] have the following permutations:\n+//[\n+  //[1,2,3],\n+  //[1,3,2],\n+  //[2,1,3],\n+  //[2,3,1],\n+  //[3,1,2],\n+  //[3,2,1]\n+//]\n+\n+class Permutations {\n+    public List<List<Integer>> permute(int[] nums) {\n+        LinkedList<List<Integer>> result = new LinkedList<List<Integer>>();\n+        result.add(new ArrayList<Integer>());\n+        for (int n: nums) {\n+            int size = result.size();\n+            while(size > 0) {\n+                List<Integer> current = result.pollFirst();\n+                for (int i = 0; i <= current.size(); i++) {\n+                    List<Integer> temp = new ArrayList<Integer>(current);\n+                    temp.add(i, n);\n+                    result.add(temp);\n+                }\n+                size--;\n+            }\n+        }\n+\n+        return result;\n+    }\n+}\n\ndiff --git a/leetcode/dynamic-programming/UniquePaths.java b/leetcode/dynamic-programming/UniquePaths.java\n--- a/leetcode/dynamic-programming/UniquePaths.java\n+++ b/leetcode/dynamic-programming/UniquePaths.java\n@@ -0,0 +1,33 @@\n+//A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n+//\n+//The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n+//\n+//How many possible unique paths are there?\n+\n+class UniquePaths {\n+    public int uniquePaths(int m, int n) {\n+        Integer[][] map = new Integer[m][n];\n+        \n+        //only 1 way to get to ith row, 0th column (move down)\n+        for(int i = 0; i < m; i++){\n+            map[i][0] = 1;\n+        }\n+        \n+        //only 1 way to get to ith column, 0th row (move right)\n+        for(int j= 0; j < n; j++){\n+            map[0][j]=1;\n+        }\n+        \n+        //x ways to get to ith row, jth column (# of ways to get to\n+        //ith - 1 row, jth column + # of ways to get to jth - 1 column\n+        //ith column\n+        for(int i = 1;i < m; i++){\n+            for(int j = 1; j < n; j++){\n+                map[i][j] = map[i - 1][j] + map[i][j - 1];\n+            }\n+        }\n+\n+        return map[m - 1][n - 1];\n+    }\n+}\n+",
    "output": "adding additional problems"
  },
  {
    "input": "diff --git a/leetcode/brainteaser/BulbSwitcher.java b/leetcode/brainteaser/BulbSwitcher.java\n--- a/leetcode/brainteaser/BulbSwitcher.java\n+++ b/leetcode/brainteaser/BulbSwitcher.java\n@@ -0,0 +1,17 @@\n+//There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\n+//Example:\n+//Given n = 3. \n+\n+//At first, the three bulbs are [off, off, off].\n+//After first round, the three bulbs are [on, on, on].\n+//After second round, the three bulbs are [on, off, on].\n+//After third round, the three bulbs are [on, off, off]. \n+\n+//So you should return 1, because there is only one bulb is on.\n+\n+class BulbSwitcher {\n+    public int bulbSwitch(int n) {\n+        return (int)Math.sqrt(n);\n+    }\n+}\n+\n\ndiff --git a/leetcode/math/BulbSwitcher.java b/leetcode/math/BulbSwitcher.java\n--- a/leetcode/math/BulbSwitcher.java\n+++ b/leetcode/math/BulbSwitcher.java\n@@ -0,0 +1,16 @@\n+//There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\n+//Example:\n+//Given n = 3. \n+\n+//At first, the three bulbs are [off, off, off].\n+//After first round, the three bulbs are [on, on, on].\n+//After second round, the three bulbs are [on, off, on].\n+//After third round, the three bulbs are [on, off, off]. \n+\n+//So you should return 1, because there is only one bulb is on.\n+\n+class BulbSwitcher {\n+    public int bulbSwitch(int n) {\n+        return (int)Math.sqrt(n);\n+    }\n+}",
    "output": "added brainteaser directory"
  },
  {
    "input": "diff --git a/company/airbnb/ContainsDuplicate.java b/company/airbnb/ContainsDuplicate.java\n--- a/company/airbnb/ContainsDuplicate.java\n+++ b/company/airbnb/ContainsDuplicate.java\n@@ -0,0 +1,18 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}\n+\n\ndiff --git a/company/palantir/ContainsDuplicate.java b/company/palantir/ContainsDuplicate.java\n--- a/company/palantir/ContainsDuplicate.java\n+++ b/company/palantir/ContainsDuplicate.java\n@@ -0,0 +1,18 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}\n+\n\ndiff --git a/company/yahoo/ContainsDuplicate.java b/company/yahoo/ContainsDuplicate.java\n--- a/company/yahoo/ContainsDuplicate.java\n+++ b/company/yahoo/ContainsDuplicate.java\n@@ -0,0 +1,18 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}\n+\n\ndiff --git a/leetcode/hash-table/ContainsDuplicate.java b/leetcode/hash-table/ContainsDuplicate.java\n--- a/leetcode/hash-table/ContainsDuplicate.java\n+++ b/leetcode/hash-table/ContainsDuplicate.java\n@@ -0,0 +1,17 @@\n+//Given an array of integers, find if the array contains any duplicates. Your function should return \n+//true if any value appears at least twice in the array, and it should return false if every element is distinct.\n+\n+class ContainsDuplicate {\n+    public boolean containsDuplicate(int[] nums) {\n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int i: nums) {\n+            if(map.containsKey(i)) {\n+                return true;\n+            } else {\n+                map.put(i, 1);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}",
    "output": "added yahoo and palantir directories"
  },
  {
    "input": "diff --git a/company/apple/ReverseWordsInAString.java b/company/apple/ReverseWordsInAString.java\n--- a/company/apple/ReverseWordsInAString.java\n+++ b/company/apple/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/bloomberg/ReverseWordsInAString.java b/company/bloomberg/ReverseWordsInAString.java\n--- a/company/bloomberg/ReverseWordsInAString.java\n+++ b/company/bloomberg/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/microsoft/ReverseWordsInAString.java b/company/microsoft/ReverseWordsInAString.java\n--- a/company/microsoft/ReverseWordsInAString.java\n+++ b/company/microsoft/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/snapchat/ReverseWordsInAString.java b/company/snapchat/ReverseWordsInAString.java\n--- a/company/snapchat/ReverseWordsInAString.java\n+++ b/company/snapchat/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/company/yelp/ReverseWordsInAString.java b/company/yelp/ReverseWordsInAString.java\n--- a/company/yelp/ReverseWordsInAString.java\n+++ b/company/yelp/ReverseWordsInAString.java\n@@ -0,0 +1,17 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}\n+\n\ndiff --git a/leetcode/string/ReverseWordsInAString.java b/leetcode/string/ReverseWordsInAString.java\n--- a/leetcode/string/ReverseWordsInAString.java\n+++ b/leetcode/string/ReverseWordsInAString.java\n@@ -0,0 +1,16 @@\n+//Given an input string, reverse the string word by word.\n+//For example,\n+//Given s = \"the sky is blue\",\n+//return \"blue is sky the\".\n+\n+public class ReverseWordsInAString {\n+    public String reverseWords(String s) {\n+        String[] words = s.trim().split(\"\\\\s+\");\n+        String result = \"\";\n+        for(int i = words.length - 1; i > 0; i--) {\n+            result += words[i] + \" \";\n+        }\n+        \n+        return result + words[0];\n+    }\n+}",
    "output": "added directories for snapchat, yelp, and apple"
  },
  {
    "input": "diff --git a/company/adobe/MajorityElement.java b/company/adobe/MajorityElement.java\n--- a/company/adobe/MajorityElement.java\n+++ b/company/adobe/MajorityElement.java\n@@ -0,0 +1,24 @@\n+//Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n+//You may assume that the array is non-empty and the majority element always exist in the array.\n+\n+class MajorityElement {\n+    public int majorityElement(int[] nums) {\n+        if(nums.length == 1) {\n+            return nums[0];\n+        }\n+        \n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int current: nums) {\n+            if(map.containsKey(current) && map.get(current) + 1 > nums.length / 2) {\n+                return current;\n+            } else if(map.containsKey(current)) {\n+                map.put(current, map.get(current) + 1);\n+            } else {\n+                map.put(current, 1);\n+            }\n+        }\n+        \n+        //no majority element exists\n+        return -1;\n+    }\n+}\n\ndiff --git a/leetcode/array/MajorityElement.java b/leetcode/array/MajorityElement.java\n--- a/leetcode/array/MajorityElement.java\n+++ b/leetcode/array/MajorityElement.java\n@@ -0,0 +1,24 @@\n+//Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n+//You may assume that the array is non-empty and the majority element always exist in the array.\n+\n+class MajorityElement {\n+    public int majorityElement(int[] nums) {\n+        if(nums.length == 1) {\n+            return nums[0];\n+        }\n+        \n+        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n+        for(int current: nums) {\n+            if(map.containsKey(current) && map.get(current) + 1 > nums.length / 2) {\n+                return current;\n+            } else if(map.containsKey(current)) {\n+                map.put(current, map.get(current) + 1);\n+            } else {\n+                map.put(current, 1);\n+            }\n+        }\n+        \n+        //no majority element exists\n+        return -1;\n+    }\n+}",
    "output": "add adobe directory"
  },
  {
    "input": "diff --git a/leetcode/bit-manipulation/NumberOfOneBits.java b/leetcode/bit-manipulation/NumberOfOneBits.java\n--- a/leetcode/bit-manipulation/NumberOfOneBits.java\n+++ b/leetcode/bit-manipulation/NumberOfOneBits.java\n@@ -2,7 +2,7 @@\n \n // For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.\n \n-public class NumberOf1Bits {\n+public class NumberOfOneBits {\n     // you need to treat n as an unsigned value\n     public int hammingWeight(int n) {\n         if(n == 0) {",
    "output": "Merge pull request #70 from kdn251/rename\n\nfinish renaming files and directories"
  },
  {
    "input": "diff --git a/leetcode/bit-manipulation/NumberOfOneBits.java b/leetcode/bit-manipulation/NumberOfOneBits.java\n--- a/leetcode/bit-manipulation/NumberOfOneBits.java\n+++ b/leetcode/bit-manipulation/NumberOfOneBits.java\n@@ -2,7 +2,7 @@\n \n // For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.\n \n-public class NumberOf1Bits {\n+public class NumberOfOneBits {\n     // you need to treat n as an unsigned value\n     public int hammingWeight(int n) {\n         if(n == 0) {",
    "output": "finish renaming files and directories"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/ReplaceSpaces.java b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/ReplaceSpaces.java\n--- a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/ReplaceSpaces.java\n+++ b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/ReplaceSpaces.java\n@@ -1,11 +1,11 @@\n-// Write a method to replace all spaces in a string with '%20.' You may assum ethat the string\n-// has sufficient space at th eend of the string to hold the additional characters, and that you\n+// Write a method to replace all spaces in a string with '%20.' You may assume that the string\n+// has sufficient space at the end of the string to hold the additional characters, and that you\n // are given the \"true\" length of the string. (Note: if implementing in Java, please use a characters\n // array so that you can perform this operation in place)\n \n public class ReplaceSpaces {\n \tpublic void replaceSpaces(char[] str, int length) {\n-\t\tint spaceCount = 0, newLength; i;\n+\t\tint spaceCount = 0, newLength;\n \t\tfor(int i = 0; i < length; i++) {\n \t\t\tif(str[i] == ' ') {\n \t\t\t\tspaceCount++;",
    "output": "Merge pull request #58 from emrecosar/master\n\nFixed compile error and some typo"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/IsUniqueChars.java b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/IsUniqueChars.java\n--- a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/IsUniqueChars.java\n+++ b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/IsUniqueChars.java\n@@ -1,15 +1,15 @@\n //Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?\n \n-public class isUniqueChars {\n+public class IsUniqueChars {\n     public boolean isUniqueChars(String str) {\n         int checker = 0;\n         for(int i = 0; i < str.length(); i++) {\n             int val = str.charAt(i) - 'a';\n             if((checker & (1 << val)) > 0) {\n                 return false;\n             }\n-            checker |= (1 << val));\n+            checker |= (1 << val);\n         }\n         return true;\n     }\n-}\n\\ No newline at end of file\n+}\n\ndiff --git a/CrackingTheCodingInterview/Chapter3StacksAndQueues/SortStack.java b/CrackingTheCodingInterview/Chapter3StacksAndQueues/SortStack.java\n--- a/CrackingTheCodingInterview/Chapter3StacksAndQueues/SortStack.java\n+++ b/CrackingTheCodingInterview/Chapter3StacksAndQueues/SortStack.java\n@@ -11,8 +11,8 @@ public static Stack<Integer> sort(Stack<Integer> s) {\n \t\t\twhile(!r.isEmpty() && r.peek() > tmp) { //step 2\n \t\t\t\ts.push(r.pop());\n \t\t\t}\n-\t\t\tr.push(tmp) //step 3\n+\t\t\tr.push(tmp); //step 3\n \t\t}\n \t\treturn r;\n \t}\n-}\n\\ No newline at end of file\n+}\n\ndiff --git a/CrackingTheCodingInterview/Chapter3StacksAndQueues/TowersOfHanoi.java b/CrackingTheCodingInterview/Chapter3StacksAndQueues/TowersOfHanoi.java\n--- a/CrackingTheCodingInterview/Chapter3StacksAndQueues/TowersOfHanoi.java\n+++ b/CrackingTheCodingInterview/Chapter3StacksAndQueues/TowersOfHanoi.java\n@@ -39,7 +39,7 @@ public void add(int d) {\n \t\t\tSystem.out.println(\"Error placing disk \" + d);\n \t\t}\n \t\telse {\n-\t\t\tdisks.push(d):\n+\t\t\tdisks.push(d);\n \t\t}\n \t}\n \n@@ -56,4 +56,4 @@ public void moveDisks(int n, Tower destination, Tower buffer) {\n \t\t\tbuffer.moveDisks(n - 1, destination, this);\n \t\t}\n \t}\n-}\n\\ No newline at end of file\n+}",
    "output": "Merge pull request #62 from doompadee/syntax-errors\n\nFix syntax errors"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/IsUniqueChars.java b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/IsUniqueChars.java\n--- a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/IsUniqueChars.java\n+++ b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/IsUniqueChars.java\n@@ -1,15 +1,15 @@\n //Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?\n \n-public class isUniqueChars {\n+public class IsUniqueChars {\n     public boolean isUniqueChars(String str) {\n         int checker = 0;\n         for(int i = 0; i < str.length(); i++) {\n             int val = str.charAt(i) - 'a';\n             if((checker & (1 << val)) > 0) {\n                 return false;\n             }\n-            checker |= (1 << val));\n+            checker |= (1 << val);\n         }\n         return true;\n     }\n-}\n\\ No newline at end of file\n+}\n\ndiff --git a/CrackingTheCodingInterview/Chapter3StacksAndQueues/SortStack.java b/CrackingTheCodingInterview/Chapter3StacksAndQueues/SortStack.java\n--- a/CrackingTheCodingInterview/Chapter3StacksAndQueues/SortStack.java\n+++ b/CrackingTheCodingInterview/Chapter3StacksAndQueues/SortStack.java\n@@ -11,8 +11,8 @@ public static Stack<Integer> sort(Stack<Integer> s) {\n \t\t\twhile(!r.isEmpty() && r.peek() > tmp) { //step 2\n \t\t\t\ts.push(r.pop());\n \t\t\t}\n-\t\t\tr.push(tmp) //step 3\n+\t\t\tr.push(tmp); //step 3\n \t\t}\n \t\treturn r;\n \t}\n-}\n\\ No newline at end of file\n+}\n\ndiff --git a/CrackingTheCodingInterview/Chapter3StacksAndQueues/TowersOfHanoi.java b/CrackingTheCodingInterview/Chapter3StacksAndQueues/TowersOfHanoi.java\n--- a/CrackingTheCodingInterview/Chapter3StacksAndQueues/TowersOfHanoi.java\n+++ b/CrackingTheCodingInterview/Chapter3StacksAndQueues/TowersOfHanoi.java\n@@ -39,7 +39,7 @@ public void add(int d) {\n \t\t\tSystem.out.println(\"Error placing disk \" + d);\n \t\t}\n \t\telse {\n-\t\t\tdisks.push(d):\n+\t\t\tdisks.push(d);\n \t\t}\n \t}\n \n@@ -56,4 +56,4 @@ public void moveDisks(int n, Tower destination, Tower buffer) {\n \t\t\tbuffer.moveDisks(n - 1, destination, this);\n \t\t}\n \t}\n-}\n\\ No newline at end of file\n+}",
    "output": "Fix syntax errors"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/ReplaceSpaces.java b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/ReplaceSpaces.java\n--- a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/ReplaceSpaces.java\n+++ b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/ReplaceSpaces.java\n@@ -1,11 +1,11 @@\n-// Write a method to replace all spaces in a string with '%20.' You may assum ethat the string\n-// has sufficient space at th eend of the string to hold the additional characters, and that you\n+// Write a method to replace all spaces in a string with '%20.' You may assume that the string\n+// has sufficient space at the end of the string to hold the additional characters, and that you\n // are given the \"true\" length of the string. (Note: if implementing in Java, please use a characters\n // array so that you can perform this operation in place)\n \n public class ReplaceSpaces {\n \tpublic void replaceSpaces(char[] str, int length) {\n-\t\tint spaceCount = 0, newLength; i;\n+\t\tint spaceCount = 0, newLength;\n \t\tfor(int i = 0; i < length; i++) {\n \t\t\tif(str[i] == ' ') {\n \t\t\t\tspaceCount++;",
    "output": "Fixed compile error and some typo"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n--- a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n+++ b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n@@ -1,4 +1,4 @@\n-// Given two strings, write a metho dto decide if one is a permutation of the other\n+// Given two strings, write a method to decide if one is a permutation of the other\n \n public class Permutation {\n \tpublic boolean permutation(String s, String t) {\n@@ -22,4 +22,4 @@ public boolean permutation(String s, String t) {\n \n \t\treturn true;\n \t}\n-}\n\\ No newline at end of file\n+}",
    "output": "added articles"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n--- a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n+++ b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n@@ -1,4 +1,4 @@\n-// Given two strings, write a metho dto decide if one is a permutation of the other\n+// Given two strings, write a method to decide if one is a permutation of the other\n \n public class Permutation {\n \tpublic boolean permutation(String s, String t) {\n@@ -22,4 +22,4 @@ public boolean permutation(String s, String t) {\n \n \t\treturn true;\n \t}\n-}\n\\ No newline at end of file\n+}",
    "output": "Merge pull request #41 from dong-jy/patch-1\n\nUpdate Permutation.java"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n--- a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n+++ b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/Permutation.java\n@@ -1,4 +1,4 @@\n-// Given two strings, write a metho dto decide if one is a permutation of the other\n+// Given two strings, write a method to decide if one is a permutation of the other\n \n public class Permutation {\n \tpublic boolean permutation(String s, String t) {\n@@ -22,4 +22,4 @@ public boolean permutation(String s, String t) {\n \n \t\treturn true;\n \t}\n-}\n\\ No newline at end of file\n+}",
    "output": "Update Permutation.java"
  },
  {
    "input": "diff --git a/UVa/Modex.java b/UVa/Modex.java\n--- a/UVa/Modex.java\n+++ b/UVa/Modex.java\n@@ -28,7 +28,6 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3671\r\n \r\n-\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r\n\ndiff --git a/UVa/WhoSaidCrisis.java b/UVa/WhoSaidCrisis.java\n--- a/UVa/WhoSaidCrisis.java\n+++ b/UVa/WhoSaidCrisis.java\n@@ -28,7 +28,6 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=2443\r\n \r\n-\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Remove spaces"
  },
  {
    "input": "diff --git a/UVa/SimplyEmirp.java b/UVa/SimplyEmirp.java\n--- a/UVa/SimplyEmirp.java\n+++ b/UVa/SimplyEmirp.java\n@@ -38,7 +38,7 @@\n \r\n public class SimplyEmirp {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\twhile (input.hasNext()) {\r\n \t\t\tString inputGiven = input.next();\r",
    "output": "Replace static void solve() throws Exception with public static void main(String[] args) at SimplyEmirp"
  },
  {
    "input": "diff --git a/UVa/NumberingRoads.java b/UVa/NumberingRoads.java\n--- a/UVa/NumberingRoads.java\n+++ b/UVa/NumberingRoads.java\n@@ -36,14 +36,13 @@\n  * Case 2: impossible\r\n  */\r\n \r\n-\r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2823\r\n \r\n import java.util.Scanner;\r\n \r\n public class NumberingRoads {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\tint caseNumber = 1;\r\n \t\twhile (true) {\r",
    "output": "Replace static void solve() throws Exception with public static void main(String[] args) at NumberingRoads"
  },
  {
    "input": "diff --git a/UVa/ArchaeologistsDilemma.java b/UVa/ArchaeologistsDilemma.java\n--- a/UVa/ArchaeologistsDilemma.java\n+++ b/UVa/ArchaeologistsDilemma.java\n@@ -1,5 +1,3 @@\n-package uva;\r\n-\r\n /**\r\n  * An archeologist seeking proof of the presence of extraterrestrials in the Earth’s past, stumbles upon a\r\n  * partially destroyed wall containing strange chains of numbers. The left-hand part of these lines of digits\r\n\ndiff --git a/UVa/CoconutsRevisited.java b/UVa/CoconutsRevisited.java\n--- a/UVa/CoconutsRevisited.java\n+++ b/UVa/CoconutsRevisited.java\n@@ -39,7 +39,7 @@\n \r\n public class CoconutsRevisited {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\tint i, rez, j;\r\n \t\tboolean isValid;\r",
    "output": "Remove package declaration at ArchaeologistsDilemma"
  },
  {
    "input": "diff --git a/UVa/AverageSpeed.java b/UVa/AverageSpeed.java\n--- a/UVa/AverageSpeed.java\n+++ b/UVa/AverageSpeed.java\n@@ -33,7 +33,7 @@\n \r\n public class AverageSpeed {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tint speed = 0;\r\n \t\tboolean reachedTheEnd = false;\r\n \t\tScanner input = new Scanner(System.in);\r",
    "output": "Replace static void solve() throws Exception with public static void main(String[] args) at AverageSpeed"
  },
  {
    "input": "diff --git a/UVa/ArchaeologistsDilemma.java b/UVa/ArchaeologistsDilemma.java\n--- a/UVa/ArchaeologistsDilemma.java\n+++ b/UVa/ArchaeologistsDilemma.java\n@@ -1,3 +1,5 @@\n+package uva;\r\n+\r\n /**\r\n  * An archeologist seeking proof of the presence of extraterrestrials in the Earth’s past, stumbles upon a\r\n  * partially destroyed wall containing strange chains of numbers. The left-hand part of these lines of digits\r\n@@ -39,7 +41,7 @@ public class ArchaeologistsDilemma {\n \tfinal static double LOG2 = Math.log(2.0);\r\n \tfinal static double LOG2_10 = Math.log(10) / LOG2;\r\n \r\n-\tpublic static void solve() throws IOException {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\twhile (true) {\r\n \t\t\tlong N = input.nextLong();\r",
    "output": "Replace static void solve() throws Exception with public static void main(String[] args) at ArchaeologistsDilemma"
  },
  {
    "input": "diff --git a/UVa/AddingReversedNumbers.java b/UVa/AddingReversedNumbers.java\n--- a/UVa/AddingReversedNumbers.java\n+++ b/UVa/AddingReversedNumbers.java\n@@ -38,7 +38,7 @@\n \r\n public class AddingReversedNumbers {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\tint numberOfTestCases = input.nextInt();\r\n \t\twhile (numberOfTestCases != 0) {\r",
    "output": "Replace static void solve() throws Exception with public static void main(String[] args) at AddingReversedNumbers"
  },
  {
    "input": "diff --git a/UVa/WhoSaidCrisis.java b/UVa/WhoSaidCrisis.java\n--- a/UVa/WhoSaidCrisis.java\n+++ b/UVa/WhoSaidCrisis.java\n@@ -43,6 +43,5 @@ public static void main(String[] args) {\n \t\t\tSystem.out.println(first.subtract(second));\r\n \t\t\tnumberOfTestCases--;\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at WhoSaidCrisis"
  },
  {
    "input": "diff --git a/UVa/VeryEasy.java b/UVa/VeryEasy.java\n--- a/UVa/VeryEasy.java\n+++ b/UVa/VeryEasy.java\n@@ -45,6 +45,5 @@ public static void main(String[] args) {\n \t\t\t}\r\n \t\t\tSystem.out.println(sum);\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Delete scanner close at VeryEasy"
  },
  {
    "input": "diff --git a/UVa/SolveEquation.java b/UVa/SolveEquation.java\n--- a/UVa/SolveEquation.java\n+++ b/UVa/SolveEquation.java\n@@ -1,99 +1,54 @@\n /**\r\n- * Let us look at a boring mathematics problem. :-)\r\n- * We have three different integers, x, y and z, which satisfy the following three relations:\r\n- * • x + y + z = A\r\n- * • xyz = B\r\n- * • x\r\n- * 2 + y\r\n- * 2 + z\r\n- * 2 = C\r\n- * You are asked to write a program that solves for x, y and z for given values of A, B and C.\r\n- * Input\r\n- * The first line of the input file gives the number of test cases N (N < 20). Each of the following N lines\r\n- * gives the values of A, B and C (1 ≤ A, B, C ≤ 10000).\r\n- * Output\r\n- * For each test case, output the corresponding values of x, y and z. If there are many possible answers,\r\n- * choose the one with the least value of x. If there is a tie, output the one with the least value of y.\r\n- * If there is no solution, output the line ‘No solution.’ instead.\r\n- * Sample Input\r\n- * 2\r\n- * 1 2 3\r\n- * 6 6 14\r\n- * Sample Output\r\n- * No solution.\r\n- * 1 2 3\r\n+ * Let us look at a boring mathematics problem. :-) We have three different\r\n+ * integers, x, y and z, which satisfy the following three relations: • x + y +\r\n+ * z = A • xyz = B • x 2 + y 2 + z 2 = C You are asked to write a program that\r\n+ * solves for x, y and z for given values of A, B and C. Input The first line of\r\n+ * the input file gives the number of test cases N (N < 20). Each of the\r\n+ * following N lines gives the values of A, B and C (1 ≤ A, B, C ≤ 10000).\r\n+ * Output For each test case, output the corresponding values of x, y and z. If\r\n+ * there are many possible answers, choose the one with the least value of x. If\r\n+ * there is a tie, output the one with the least value of y. If there is no\r\n+ * solution, output the line ‘No solution.’ instead. Sample Input 2 1 2 3 6 6 14\r\n+ * Sample Output No solution. 1 2 3\r\n  */\r\n-//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2612\r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n+// https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2612\r\n \r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class SolveEquation {\r\n \r\n-    static void solve() throws Exception {\r\n-\r\n-\tint numberOfTestCases = nextInt();\r\n-\twhile (numberOfTestCases != 0) {\r\n-\r\n-\t    int A = nextInt();\r\n-\t    int B = nextInt();\r\n-\t    int C = nextInt();\r\n-\t    boolean hasSolution = false;\r\n-\r\n-\t    for (int x = -22; x <= 22 && !hasSolution; x++) {\r\n-\t\tif (x * x <= C) {\r\n-\t\t    for (int y = -100; y <= 100 && !hasSolution; y++) {\r\n-\t\t\tif (x!= y && y * y <= C && (x * x + y * y <= C)) {\r\n-\t\t\t    int z = A - x - y;\r\n-\t\t\t    if ((z != y && z != x && x * x + y * y + z * z == C) && x * y * z == B) {\r\n-\t\t\t\thasSolution = true;\r\n-\t\t\t\tSystem.out.println(x + \" \" + y + \" \" + z);\r\n-\t\t\t    }\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\r\n+\t\tint numberOfTestCases = input.nextInt();\r\n+\t\twhile (numberOfTestCases != 0) {\r\n+\r\n+\t\t\tint A = input.nextInt();\r\n+\t\t\tint B = input.nextInt();\r\n+\t\t\tint C = input.nextInt();\r\n+\t\t\tboolean hasSolution = false;\r\n+\r\n+\t\t\tfor (int x = -22; x <= 22 && !hasSolution; x++) {\r\n+\t\t\t\tif (x * x <= C) {\r\n+\t\t\t\t\tfor (int y = -100; y <= 100 && !hasSolution; y++) {\r\n+\t\t\t\t\t\tif (x != y && y * y <= C && (x * x + y * y <= C)) {\r\n+\t\t\t\t\t\t\tint z = A - x - y;\r\n+\t\t\t\t\t\t\tif ((z != y && z != x && x * x + y * y + z * z == C)\r\n+\t\t\t\t\t\t\t\t\t&& x * y * z == B) {\r\n+\t\t\t\t\t\t\t\thasSolution = true;\r\n+\t\t\t\t\t\t\t\tSystem.out.println(x + \" \" + y + \" \" + z);\r\n+\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tif (!hasSolution) {\r\n+\t\t\t\tSystem.out.println(\"No solution.\");\r\n \t\t\t}\r\n-\t\t    }\r\n-\t\t}\r\n-\t    }\r\n-\t    if (!hasSolution) {\r\n-\t\tSystem.out.println(\"No solution.\");\r\n-\t    }\r\n-\r\n-\t    numberOfTestCases--;\r\n-\t}\r\n-\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n \r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n-\t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n+\t\t\tnumberOfTestCases--;\r\n+\t\t}\r\n \r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t    solve();\r\n-\t    in.close();\r\n-\t    out.close();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n \t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r",
    "output": "Refactor SolveEquation"
  },
  {
    "input": "diff --git a/UVa/SkewBinary.java b/UVa/SkewBinary.java\n--- a/UVa/SkewBinary.java\n+++ b/UVa/SkewBinary.java\n@@ -67,6 +67,5 @@ public static void main(String[] args) {\n \t\t\t}\r\n \t\t\tSystem.out.println(sum);\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Delete scanner close at SkewBinary"
  },
  {
    "input": "diff --git a/UVa/SimplyEmirp.java b/UVa/SimplyEmirp.java\n--- a/UVa/SimplyEmirp.java\n+++ b/UVa/SimplyEmirp.java\n@@ -58,6 +58,5 @@ static void solve() throws Exception {\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Delete scanner close at SimplyEmirp"
  },
  {
    "input": "diff --git a/UVa/SimplifyingFractions.java b/UVa/SimplifyingFractions.java\n--- a/UVa/SimplifyingFractions.java\n+++ b/UVa/SimplifyingFractions.java\n@@ -42,6 +42,5 @@ public static void main(String[] args) {\n \t\t\tSystem.out.println(p + \" / \" + q);\r\n \t\t\tnumberOfTestCases--;\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Delete scanner close at SimplifyingFractions"
  },
  {
    "input": "diff --git a/UVa/MultipleOfSeventeen.java b/UVa/MultipleOfSeventeen.java\n--- a/UVa/MultipleOfSeventeen.java\n+++ b/UVa/MultipleOfSeventeen.java\n@@ -49,6 +49,5 @@ public static void main(String[] args) {\n \t\t\t\tSystem.out.println(\"0\");\r\n \t\t\t}\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at MultipleOfSeventeen"
  },
  {
    "input": "diff --git a/UVa/MultipleOfSeventeen.java b/UVa/MultipleOfSeventeen.java\n--- a/UVa/MultipleOfSeventeen.java\n+++ b/UVa/MultipleOfSeventeen.java\n@@ -24,18 +24,8 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=3001\r\n \r\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class MultipleOfSeventeen {\r\n \tprivate static final BigInteger BIGINTEGER_FIVE = new BigInteger(\"5\");\r",
    "output": "Remove unused imports at MultipleOfSeventeen"
  },
  {
    "input": "diff --git a/UVa/MultipleOfSeventeen.java b/UVa/MultipleOfSeventeen.java\n--- a/UVa/MultipleOfSeventeen.java\n+++ b/UVa/MultipleOfSeventeen.java\n@@ -24,6 +24,7 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=3001\r\n \r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r\n@@ -41,7 +42,7 @@ public class MultipleOfSeventeen {\n \tprivate static final BigInteger BIGINTEGER_SEVENTEEN = new BigInteger(\"17\");\r\n \tprivate static final BigInteger BIGINTEGER_ZERO = new BigInteger(\"0\");\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\twhile (input.hasNext()) {\r\n \t\t\tBigInteger number = input.nextBigInteger();\r\n@@ -60,32 +61,4 @@ static void solve() throws Exception {\n \t\t}\r\n \t\tinput.close();\r\n \t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor MultipleOfSeventeen"
  },
  {
    "input": "diff --git a/UVa/Modex.java b/UVa/Modex.java\n--- a/UVa/Modex.java\n+++ b/UVa/Modex.java\n@@ -45,7 +45,6 @@ public static void main(String[] args) {\n \t\t\tSystem.out.println(result);\r\n \t\t\tnumberOfTestCases--;\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r\n \r",
    "output": "Remove scanner close at Modex"
  },
  {
    "input": "diff --git a/UVa/IntegerInquiry.java b/UVa/IntegerInquiry.java\n--- a/UVa/IntegerInquiry.java\n+++ b/UVa/IntegerInquiry.java\n@@ -39,6 +39,5 @@ public static void main(String[] args) {\n \t\t\tsum = sum.add(number);\r\n \t\t}\r\n \t\tSystem.out.println(sum);\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at IntegerInquiry"
  },
  {
    "input": "diff --git a/UVa/HighPrecisionNumber.java b/UVa/HighPrecisionNumber.java\n--- a/UVa/HighPrecisionNumber.java\n+++ b/UVa/HighPrecisionNumber.java\n@@ -59,6 +59,5 @@ public static void main(String[] args) {\n \t\t\t\t\t\"\\\\.0*$|(\\\\.\\\\d*?)0+$\", \"$1\"));\r\n \t\t\tnumberOfGroups--;\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at HighPrecisionNumber"
  },
  {
    "input": "diff --git a/UVa/BigMod.java b/UVa/BigMod.java\n--- a/UVa/BigMod.java\n+++ b/UVa/BigMod.java\n@@ -42,6 +42,5 @@ public static void main(String[] args) {\n \t\t\tBigInteger m = input.nextBigInteger();\r\n \t\t\tSystem.out.println(b.modPow(p, m));\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at BigMod"
  },
  {
    "input": "diff --git a/UVa/BigMod.java b/UVa/BigMod.java\n--- a/UVa/BigMod.java\n+++ b/UVa/BigMod.java\n@@ -29,17 +29,8 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=727&page=show_problem&problem=310\r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class BigMod {\r\n \r",
    "output": "Remove unused imports"
  },
  {
    "input": "diff --git a/UVa/BigMod.java b/UVa/BigMod.java\n--- a/UVa/BigMod.java\n+++ b/UVa/BigMod.java\n@@ -41,45 +41,16 @@\n import java.util.Scanner;\r\n import java.util.StringTokenizer;\r\n \r\n-\r\n public class BigMod {\r\n \r\n-    static void solve() throws Exception {\r\n-\tScanner input = new Scanner(System.in);\r\n-\twhile(input.hasNext()){\r\n-\t    BigInteger b = input.nextBigInteger();\r\n-\t    BigInteger p = input.nextBigInteger();\r\n-\t    BigInteger m = input.nextBigInteger();\r\n-\t    System.out.println(b.modPow(p, m));\r\n-\t}\r\n-\tinput.close();\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n-\r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\twhile (input.hasNext()) {\r\n+\t\t\tBigInteger b = input.nextBigInteger();\r\n+\t\t\tBigInteger p = input.nextBigInteger();\r\n+\t\t\tBigInteger m = input.nextBigInteger();\r\n+\t\t\tSystem.out.println(b.modPow(p, m));\r\n+\t\t}\r\n+\t\tinput.close();\r\n \t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t    solve();\r\n-\t    in.close();\r\n-\t    out.close();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n-\t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r",
    "output": "Refactor BigMod"
  },
  {
    "input": "diff --git a/UVa/BigMod.java b/UVa/BigMod.java\n--- a/UVa/BigMod.java\n+++ b/UVa/BigMod.java\n@@ -0,0 +1,55 @@\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=727&page=show_problem&problem=310\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+\r\n+public class BigMod {\r\n+\r\n+    static void solve() throws Exception {\r\n+\tScanner input = new Scanner(System.in);\r\n+\twhile(input.hasNext()){\r\n+\t    BigInteger b = input.nextBigInteger();\r\n+\t    BigInteger p = input.nextBigInteger();\r\n+\t    BigInteger m = input.nextBigInteger();\r\n+\t    System.out.println(b.modPow(p, m));\r\n+\t}\r\n+\tinput.close();\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t    solve();\r\n+\t    in.close();\r\n+\t    out.close();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve BigMod"
  },
  {
    "input": "diff --git a/UVa/WhoSaidCrisis.java b/UVa/WhoSaidCrisis.java\n--- a/UVa/WhoSaidCrisis.java\n+++ b/UVa/WhoSaidCrisis.java\n@@ -1,4 +1,6 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=2443\r\n+\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL at WhoSaidCrisis"
  },
  {
    "input": "diff --git a/UVa/WhoSaidCrisis.java b/UVa/WhoSaidCrisis.java\n--- a/UVa/WhoSaidCrisis.java\n+++ b/UVa/WhoSaidCrisis.java\n@@ -1,55 +1,18 @@\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class WhoSaidCrisis {\r\n \r\n-    static void solve() throws Exception {\r\n-\tScanner input = new Scanner(System.in);\r\n-\tint numberOfTestCases = input.nextInt();\r\n-\twhile (numberOfTestCases != 0) {\r\n-\t    BigInteger first = input.nextBigInteger();\r\n-\t    BigInteger second = input.nextBigInteger();\r\n-\t    System.out.println(first.subtract(second));\r\n-\t    numberOfTestCases--;\r\n-\t}\r\n-\tinput.close();\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n-\r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tint numberOfTestCases = input.nextInt();\r\n+\t\twhile (numberOfTestCases != 0) {\r\n+\t\t\tBigInteger first = input.nextBigInteger();\r\n+\t\t\tBigInteger second = input.nextBigInteger();\r\n+\t\t\tSystem.out.println(first.subtract(second));\r\n+\t\t\tnumberOfTestCases--;\r\n+\t\t}\r\n+\t\tinput.close();\r\n \t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t    solve();\r\n-\t    in.close();\r\n-\t    out.close();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n-\t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r",
    "output": "Refactor WhoSaidCrisis"
  },
  {
    "input": "diff --git a/UVa/WhoSaidCrisis.java b/UVa/WhoSaidCrisis.java\n--- a/UVa/WhoSaidCrisis.java\n+++ b/UVa/WhoSaidCrisis.java\n@@ -0,0 +1,55 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class WhoSaidCrisis {\r\n+\r\n+    static void solve() throws Exception {\r\n+\tScanner input = new Scanner(System.in);\r\n+\tint numberOfTestCases = input.nextInt();\r\n+\twhile (numberOfTestCases != 0) {\r\n+\t    BigInteger first = input.nextBigInteger();\r\n+\t    BigInteger second = input.nextBigInteger();\r\n+\t    System.out.println(first.subtract(second));\r\n+\t    numberOfTestCases--;\r\n+\t}\r\n+\tinput.close();\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t    solve();\r\n+\t    in.close();\r\n+\t    out.close();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve WhoSaidCrisis"
  },
  {
    "input": "diff --git a/UVa/HighPrecisionNumber.java b/UVa/HighPrecisionNumber.java\n--- a/UVa/HighPrecisionNumber.java\n+++ b/UVa/HighPrecisionNumber.java\n@@ -1,60 +1,25 @@\n-//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2921\r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2921\r\n \r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigDecimal;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class HighPrecisionNumber {\r\n \r\n-    static void solve() throws Exception {\r\n-\tScanner input = new Scanner(System.in);\r\n-\tint numberOfGroups = input.nextInt();\r\n-\twhile (numberOfGroups != 0) {\r\n-\t    BigDecimal sum = BigDecimal.ZERO;\r\n-\t    BigDecimal number = input.nextBigDecimal();\r\n-\t    while(!number.equals(BigDecimal.ZERO)){\r\n-\t\tsum = sum.add(number);\r\n-\t\tnumber = input.nextBigDecimal();\r\n-\t    }\r\n-\t    System.out.println(sum.toPlainString().replaceFirst(\"\\\\.0*$|(\\\\.\\\\d*?)0+$\", \"$1\"));\r\n-\t    numberOfGroups--;\r\n-\t}\r\n-\tinput.close();\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n-\r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n-\t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t    solve();\r\n-\t    in.close();\r\n-\t    out.close();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tint numberOfGroups = input.nextInt();\r\n+\t\twhile (numberOfGroups != 0) {\r\n+\t\t\tBigDecimal sum = BigDecimal.ZERO;\r\n+\t\t\tBigDecimal number = input.nextBigDecimal();\r\n+\t\t\twhile (!number.equals(BigDecimal.ZERO)) {\r\n+\t\t\t\tsum = sum.add(number);\r\n+\t\t\t\tnumber = input.nextBigDecimal();\r\n+\t\t\t}\r\n+\t\t\tSystem.out.println(sum.toPlainString().replaceFirst(\r\n+\t\t\t\t\t\"\\\\.0*$|(\\\\.\\\\d*?)0+$\", \"$1\"));\r\n+\t\t\tnumberOfGroups--;\r\n+\t\t}\r\n+\t\tinput.close();\r\n \t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r",
    "output": "Refactor HighPrecisionNumber"
  },
  {
    "input": "diff --git a/UVa/FiveHundredFactorial.java b/UVa/FiveHundredFactorial.java\n--- a/UVa/FiveHundredFactorial.java\n+++ b/UVa/FiveHundredFactorial.java\n@@ -35,6 +35,7 @@\n  * 93326215443944152681699238856266700490715968264381621468592963895217599993229915\r\n  * 608941463976156518286253697920827223758251185210916864000000000000000000000000\r\n  */\r\n+\r\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=564\r\n \r\n import java.math.BigInteger;\r\n\ndiff --git a/UVa/GoldbachConjecture.java b/UVa/GoldbachConjecture.java\n--- a/UVa/GoldbachConjecture.java\n+++ b/UVa/GoldbachConjecture.java\n@@ -63,7 +63,7 @@ public static void main(String[] args) {\n \t\t}\r\n \t}\r\n \r\n-\tstatic boolean[] sieveOfEratosthenes(int number) {\r\n+\tprivate static boolean[] sieveOfEratosthenes(int number) {\r\n \t\tboolean[] isPrime = new boolean[number + 1];\r\n \t\tfor (int i = 2; i < number + 1; i++) {\r\n \t\t\tisPrime[i] = true;\r",
    "output": "Make sieveOfEratosthenes as a private method"
  },
  {
    "input": "diff --git a/UVa/FiveHundredFactorial.java b/UVa/FiveHundredFactorial.java\n--- a/UVa/FiveHundredFactorial.java\n+++ b/UVa/FiveHundredFactorial.java\n@@ -52,6 +52,5 @@ public static void main(String[] args) {\n \t\t\t}\r\n \t\t\tSystem.out.println(number + \"!\\n\" + product);\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at FiveHundredFactorial"
  },
  {
    "input": "diff --git a/UVa/DigitCounting.java b/UVa/DigitCounting.java\n--- a/UVa/DigitCounting.java\n+++ b/UVa/DigitCounting.java\n@@ -20,25 +20,27 @@\n  * 0 1 1 1 0 0 0 0 0 0\r\n  * 1 6 2 2 1 1 1 1 1 1\r\n  */\r\n+\r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3666\r\n \r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n-\r\n import java.io.BufferedReader;\r\n import java.io.IOException;\r\n import java.io.InputStreamReader;\r\n import java.io.OutputStreamWriter;\r\n import java.io.PrintWriter;\r\n+import java.util.Scanner;\r\n import java.util.StringTokenizer;\r\n \r\n public class DigitCounting {\r\n \r\n-\tstatic void solve() throws Exception {\r\n-\t\tint numberOfTestCases = nextInt();\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tint numberOfTestCases = input.nextInt();\r\n \t\twhile (numberOfTestCases != 0) {\r\n \t\t\tint[] numbers = new int[10];\r\n-\t\t\tint number = nextInt();\r\n+\t\t\tint number = input.nextInt();\r\n \t\t\tfor (int i = number; i > 0; i--) {\r\n \t\t\t\tint j = i;\r\n \t\t\t\twhile (j != 0) {\r\n@@ -56,32 +58,4 @@ static void solve() throws Exception {\n \t\t\tnumberOfTestCases--;\r\n \t\t}\r\n \t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor DigitCounting"
  },
  {
    "input": "diff --git a/UVa/BasicallySpeaking.java b/UVa/BasicallySpeaking.java\n--- a/UVa/BasicallySpeaking.java\n+++ b/UVa/BasicallySpeaking.java\n@@ -40,17 +40,8 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=325\r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class BasicallySpeaking {\r\n \r",
    "output": "Remove unused imports at BasicallySpeaking"
  },
  {
    "input": "diff --git a/UVa/BasicallySpeaking.java b/UVa/BasicallySpeaking.java\n--- a/UVa/BasicallySpeaking.java\n+++ b/UVa/BasicallySpeaking.java\n@@ -54,7 +54,7 @@\n \r\n public class BasicallySpeaking {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\twhile (input.hasNext()) {\r\n \t\t\tString numberAsString = input.next();\r\n@@ -68,34 +68,5 @@ static void solve() throws Exception {\n \t\t\t}\r\n \t\t\tSystem.out.printf(\"%7s\\n\", answer);\r\n \t\t}\r\n-\t\tinput.close();\r\n-\t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n \t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor BasicallySpeaking"
  },
  {
    "input": "diff --git a/UVa/AddingReversedNumbers.java b/UVa/AddingReversedNumbers.java\n--- a/UVa/AddingReversedNumbers.java\n+++ b/UVa/AddingReversedNumbers.java\n@@ -56,6 +56,5 @@ static void solve() throws Exception {\n \t\t\tSystem.out.println(resultReversed.replaceFirst(\"^0*\", \"\"));\r\n \t\t\tnumberOfTestCases--;\r\n \t\t}\r\n-\t\tinput.close();\r\n \t}\r\n }\r",
    "output": "Remove scanner close at AddingReversedNumbers"
  },
  {
    "input": "diff --git a/UVa/WhatBaseIsThis.java b/UVa/WhatBaseIsThis.java\n--- a/UVa/WhatBaseIsThis.java\n+++ b/UVa/WhatBaseIsThis.java\n@@ -46,82 +46,45 @@\n  * 10 (base 2) = 2 (base 3)\r\n  */\r\n \r\n-\r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=279\r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class WhatBaseIsThis {\r\n \r\n-    static void solve() throws Exception {\r\n-\tScanner input = new Scanner(System.in);\r\n-\twhile (input.hasNext()) {\r\n-\t    String x = input.next();\r\n-\t    String y = input.next();\r\n-\t    boolean found = false;\r\n-\t    for (int i = 2; i < 37 && !found; i++) {\r\n-\t\tBigInteger xConvertedToBase;\r\n-\t\ttry {\r\n-\t\t    xConvertedToBase = new BigInteger(x, i);\r\n-\t\t} catch (Exception e) {\r\n-\t\t    continue;\r\n-\t\t}\r\n-\t\tfor (int j = 2; j < 37; j++) {\r\n-\t\t    BigInteger yConvertedToBase;\r\n-\t\t    try {\r\n-\t\t\tyConvertedToBase = new BigInteger(y, j);\r\n-\t\t    } catch (Exception e) {\r\n-\t\t\tcontinue;\r\n-\t\t    }\r\n-\t\t    if (xConvertedToBase.equals(yConvertedToBase)) {\r\n-\t\t\tSystem.out.println(x + \" (base \" + i  + \") = \" + y + \" (base \" + j + \")\");\r\n-\t\t\tfound = true;\r\n-\t\t\tbreak;\r\n-\t\t    }\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\twhile (input.hasNext()) {\r\n+\t\t\tString x = input.next();\r\n+\t\t\tString y = input.next();\r\n+\t\t\tboolean found = false;\r\n+\t\t\tfor (int i = 2; i < 37 && !found; i++) {\r\n+\t\t\t\tBigInteger xConvertedToBase;\r\n+\t\t\t\ttry {\r\n+\t\t\t\t\txConvertedToBase = new BigInteger(x, i);\r\n+\t\t\t\t} catch (Exception e) {\r\n+\t\t\t\t\tcontinue;\r\n+\t\t\t\t}\r\n+\t\t\t\tfor (int j = 2; j < 37; j++) {\r\n+\t\t\t\t\tBigInteger yConvertedToBase;\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\tyConvertedToBase = new BigInteger(y, j);\r\n+\t\t\t\t\t} catch (Exception e) {\r\n+\t\t\t\t\t\tcontinue;\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tif (xConvertedToBase.equals(yConvertedToBase)) {\r\n+\t\t\t\t\t\tSystem.out.println(x + \" (base \" + i + \") = \" + y\r\n+\t\t\t\t\t\t\t\t+ \" (base \" + j + \")\");\r\n+\t\t\t\t\t\tfound = true;\r\n+\t\t\t\t\t\tbreak;\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tif (!found) {\r\n+\t\t\t\tSystem.out.println(x + \" is not equal to \" + y\r\n+\t\t\t\t\t\t+ \" in any base 2..36\");\r\n+\t\t\t}\r\n \t\t}\r\n-\t    }\r\n-\t    if (!found) {\r\n-\t\tSystem.out.println(x + \" is not equal to \" + y + \" in any base 2..36\");\r\n-\t    }\r\n \t}\r\n-\tinput.close();\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n-\r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n-\t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t    solve();\r\n-\t    in.close();\r\n-\t    out.close();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n-\t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r",
    "output": "Refactor WhatBaseIsThis"
  },
  {
    "input": "diff --git a/UVa/WhatBaseIsThis.java b/UVa/WhatBaseIsThis.java\n--- a/UVa/WhatBaseIsThis.java\n+++ b/UVa/WhatBaseIsThis.java\n@@ -1,4 +1,6 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=279\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL at WhatBaseIsThis"
  },
  {
    "input": "diff --git a/UVa/WhatBaseIsThis.java b/UVa/WhatBaseIsThis.java\n--- a/UVa/WhatBaseIsThis.java\n+++ b/UVa/WhatBaseIsThis.java\n@@ -1,4 +1,3 @@\n-package mathematics.bigInteger;\r\n \r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r",
    "output": "Remove package declaration at WhatBaseIsThis"
  },
  {
    "input": "diff --git a/UVa/WhatBaseIsThis.java b/UVa/WhatBaseIsThis.java\n--- a/UVa/WhatBaseIsThis.java\n+++ b/UVa/WhatBaseIsThis.java\n@@ -0,0 +1,78 @@\n+package mathematics.bigInteger;\r\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class WhatBaseIsThis {\r\n+\r\n+    static void solve() throws Exception {\r\n+\tScanner input = new Scanner(System.in);\r\n+\twhile (input.hasNext()) {\r\n+\t    String x = input.next();\r\n+\t    String y = input.next();\r\n+\t    boolean found = false;\r\n+\t    for (int i = 2; i < 37 && !found; i++) {\r\n+\t\tBigInteger xConvertedToBase;\r\n+\t\ttry {\r\n+\t\t    xConvertedToBase = new BigInteger(x, i);\r\n+\t\t} catch (Exception e) {\r\n+\t\t    continue;\r\n+\t\t}\r\n+\t\tfor (int j = 2; j < 37; j++) {\r\n+\t\t    BigInteger yConvertedToBase;\r\n+\t\t    try {\r\n+\t\t\tyConvertedToBase = new BigInteger(y, j);\r\n+\t\t    } catch (Exception e) {\r\n+\t\t\tcontinue;\r\n+\t\t    }\r\n+\t\t    if (xConvertedToBase.equals(yConvertedToBase)) {\r\n+\t\t\tSystem.out.println(x + \" (base \" + i  + \") = \" + y + \" (base \" + j + \")\");\r\n+\t\t\tfound = true;\r\n+\t\t\tbreak;\r\n+\t\t    }\r\n+\t\t}\r\n+\t    }\r\n+\t    if (!found) {\r\n+\t\tSystem.out.println(x + \" is not equal to \" + y + \" in any base 2..36\");\r\n+\t    }\r\n+\t}\r\n+\tinput.close();\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t    solve();\r\n+\t    in.close();\r\n+\t    out.close();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve WhatBaseIsThis"
  },
  {
    "input": "diff --git a/UVa/VeryEasy.java b/UVa/VeryEasy.java\n--- a/UVa/VeryEasy.java\n+++ b/UVa/VeryEasy.java\n@@ -25,21 +25,13 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=1464\r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n \r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class VeryEasy {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\twhile (input.hasNext()) {\r\n \t\t\tBigInteger sum = BigInteger.ZERO;\r\n@@ -55,32 +47,4 @@ static void solve() throws Exception {\n \t\t}\r\n \t\tinput.close();\r\n \t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor VeryEasy"
  },
  {
    "input": "diff --git a/UVa/VeryEasy.java b/UVa/VeryEasy.java\n--- a/UVa/VeryEasy.java\n+++ b/UVa/VeryEasy.java\n@@ -0,0 +1,59 @@\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class VeryEasy {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\twhile (input.hasNext()) {\r\n+\t\t\tBigInteger sum = BigInteger.ZERO;\r\n+\t\t\tint N = input.nextInt();\r\n+\t\t\tint A = input.nextInt();\r\n+\t\t\tBigInteger aAsBigInteger = BigInteger.valueOf(A);\r\n+\t\t\tBigInteger product = BigInteger.ONE;\r\n+\t\t\tfor (int i = 1; i < N + 1; i++) {\r\n+\t\t\t\tproduct = BigInteger.valueOf(i).multiply(aAsBigInteger.pow(i));\r\n+\t\t\t\tsum = sum.add(product);\r\n+\t\t\t}\r\n+\t\t\tSystem.out.println(sum);\r\n+\t\t}\r\n+\t\tinput.close();\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve VeryEasy"
  },
  {
    "input": "diff --git a/UVa/SimplyEmirp.java b/UVa/SimplyEmirp.java\n--- a/UVa/SimplyEmirp.java\n+++ b/UVa/SimplyEmirp.java\n@@ -30,69 +30,34 @@\n  * 199 is emirp.\r\n  */\r\n \r\n-\r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1176\r\n \r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class SimplyEmirp {\r\n \r\n-    static void solve() throws Exception {\r\n-\tScanner input = new Scanner(System.in);\r\n-\twhile (input.hasNext()) {\r\n-\t    String inputGiven = input.next();\r\n-\t    BigInteger number = new BigInteger(inputGiven);\r\n-\t    if (!number.isProbablePrime(10)) {\r\n-\t\tSystem.out.println(number + \" is not prime.\");\r\n-\t    } else {\r\n-\t\tString numberReversedAsString = new StringBuilder(number.toString()).reverse().toString();\r\n-\t\tBigInteger numberReversed = new BigInteger(numberReversedAsString);\r\n-\t\tif(numberReversed.isProbablePrime(10) && numberReversed.compareTo(number) != 0){\r\n-\t\t    System.out.println(number +\" is emirp.\");\r\n-\t\t} else {\r\n-\t\t    System.out.println(number +\" is prime.\");\r\n+\tstatic void solve() throws Exception {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\twhile (input.hasNext()) {\r\n+\t\t\tString inputGiven = input.next();\r\n+\t\t\tBigInteger number = new BigInteger(inputGiven);\r\n+\t\t\tif (!number.isProbablePrime(10)) {\r\n+\t\t\t\tSystem.out.println(number + \" is not prime.\");\r\n+\t\t\t} else {\r\n+\t\t\t\tString numberReversedAsString = new StringBuilder(\r\n+\t\t\t\t\t\tnumber.toString()).reverse().toString();\r\n+\t\t\t\tBigInteger numberReversed = new BigInteger(\r\n+\t\t\t\t\t\tnumberReversedAsString);\r\n+\t\t\t\tif (numberReversed.isProbablePrime(10)\r\n+\t\t\t\t\t\t&& numberReversed.compareTo(number) != 0) {\r\n+\t\t\t\t\tSystem.out.println(number + \" is emirp.\");\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tSystem.out.println(number + \" is prime.\");\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n \t\t}\r\n-\t    }\r\n-\t}\r\n-\tinput.close();\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n-\r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n-\t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t    solve();\r\n-\t    in.close();\r\n-\t    out.close();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n+\t\tinput.close();\r\n \t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r",
    "output": "Refactor SimplyEmirp:"
  },
  {
    "input": "diff --git a/UVa/SimplyEmirp.java b/UVa/SimplyEmirp.java\n--- a/UVa/SimplyEmirp.java\n+++ b/UVa/SimplyEmirp.java\n@@ -1,4 +1,7 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1176\r\n+\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for SimplyEmirp"
  },
  {
    "input": "diff --git a/UVa/SimplyEmirp.java b/UVa/SimplyEmirp.java\n--- a/UVa/SimplyEmirp.java\n+++ b/UVa/SimplyEmirp.java\n@@ -0,0 +1,63 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class SimplyEmirp {\r\n+\r\n+    static void solve() throws Exception {\r\n+\tScanner input = new Scanner(System.in);\r\n+\twhile (input.hasNext()) {\r\n+\t    String inputGiven = input.next();\r\n+\t    BigInteger number = new BigInteger(inputGiven);\r\n+\t    if (!number.isProbablePrime(10)) {\r\n+\t\tSystem.out.println(number + \" is not prime.\");\r\n+\t    } else {\r\n+\t\tString numberReversedAsString = new StringBuilder(number.toString()).reverse().toString();\r\n+\t\tBigInteger numberReversed = new BigInteger(numberReversedAsString);\r\n+\t\tif(numberReversed.isProbablePrime(10) && numberReversed.compareTo(number) != 0){\r\n+\t\t    System.out.println(number +\" is emirp.\");\r\n+\t\t} else {\r\n+\t\t    System.out.println(number +\" is prime.\");\r\n+\t\t}\r\n+\t    }\r\n+\t}\r\n+\tinput.close();\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t    solve();\r\n+\t    in.close();\r\n+\t    out.close();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve SimplyEmirp"
  },
  {
    "input": "diff --git a/UVa/SimplifyingFractions.java b/UVa/SimplifyingFractions.java\n--- a/UVa/SimplifyingFractions.java\n+++ b/UVa/SimplifyingFractions.java\n@@ -20,19 +20,12 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1755\r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class SimplifyingFractions {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\tint numberOfTestCases = input.nextInt();\r\n \t\twhile (numberOfTestCases != 0) {\r\n@@ -51,28 +44,4 @@ static void solve() throws Exception {\n \t\t}\r\n \t\tinput.close();\r\n \t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tsolve();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor SimplifyingFractions"
  },
  {
    "input": "diff --git a/UVa/SimplifyingFractions.java b/UVa/SimplifyingFractions.java\n--- a/UVa/SimplifyingFractions.java\n+++ b/UVa/SimplifyingFractions.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1755\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for SimplifyingFractions"
  },
  {
    "input": "diff --git a/UVa/SimplifyingFractions.java b/UVa/SimplifyingFractions.java\n--- a/UVa/SimplifyingFractions.java\n+++ b/UVa/SimplifyingFractions.java\n@@ -0,0 +1,56 @@\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class SimplifyingFractions {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tint numberOfTestCases = input.nextInt();\r\n+\t\twhile (numberOfTestCases != 0) {\r\n+\t\t\tString pAsString = input.next();\r\n+\t\t\tinput.next();\r\n+\t\t\tString qAsString = input.next();\r\n+\t\t\tBigInteger p = new BigInteger(pAsString);\r\n+\t\t\tBigInteger q = new BigInteger(qAsString);\r\n+\t\t\tBigInteger greatestCommonDivisor = p.gcd(q);\r\n+\t\t\tif (!greatestCommonDivisor.equals(BigInteger.ONE)) {\r\n+\t\t\t\tp = p.divide(greatestCommonDivisor);\r\n+\t\t\t\tq = q.divide(greatestCommonDivisor);\r\n+\t\t\t}\r\n+\t\t\tSystem.out.println(p + \" / \" + q);\r\n+\t\t\tnumberOfTestCases--;\r\n+\t\t}\r\n+\t\tinput.close();\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tsolve();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "SimplifyingFractions"
  },
  {
    "input": "diff --git a/UVa/PseudoPrimeNumbers.java b/UVa/PseudoPrimeNumbers.java\n--- a/UVa/PseudoPrimeNumbers.java\n+++ b/UVa/PseudoPrimeNumbers.java\n@@ -1,67 +1,32 @@\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n-import java.util.StringTokenizer;\r\n-\r\n+import java.util.Scanner;\r\n \r\n public class PseudoPrimeNumbers {\r\n \r\n-    static void solve() throws Exception {\r\n-\twhile(true){\r\n-\t    int p = nextInt();\r\n-\t    int a = nextInt();\r\n-\t    if(a== 0 && p == 0){\r\n-\t\tbreak;\r\n-\t    }\r\n-\t    BigInteger pAsBigInteger = new BigInteger(p+\"\");\r\n-\t    BigInteger aAsBigInteger = new BigInteger(a+\"\");\r\n-\t    String answer = \"\";\r\n-\t    if(!pAsBigInteger.isProbablePrime(10)){\r\n-\t\tBigInteger result = aAsBigInteger.modPow(pAsBigInteger, pAsBigInteger);\r\n-\t\tif(result.equals(aAsBigInteger)){\r\n-\t\t    answer = \"yes\";\r\n-\t\t} else {\r\n-\t\t    answer = \"no\";\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\twhile (true) {\r\n+\t\t\tint p = input.nextInt();\r\n+\t\t\tint a = input.nextInt();\r\n+\t\t\tif (a == 0 && p == 0) {\r\n+\t\t\t\tbreak;\r\n+\t\t\t}\r\n+\t\t\tBigInteger pAsBigInteger = new BigInteger(p + \"\");\r\n+\t\t\tBigInteger aAsBigInteger = new BigInteger(a + \"\");\r\n+\t\t\tString answer = \"\";\r\n+\t\t\tif (!pAsBigInteger.isProbablePrime(10)) {\r\n+\t\t\t\tBigInteger result = aAsBigInteger.modPow(pAsBigInteger,\r\n+\t\t\t\t\t\tpAsBigInteger);\r\n+\t\t\t\tif (result.equals(aAsBigInteger)) {\r\n+\t\t\t\t\tanswer = \"yes\";\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tanswer = \"no\";\r\n+\t\t\t\t}\r\n+\t\t\t} else {\r\n+\t\t\t\tanswer = \"no\";\r\n+\t\t\t}\r\n+\t\t\tSystem.out.println(answer);\r\n \t\t}\r\n-\t    } else {\r\n-\t\tanswer = \"no\";\r\n-\t    }\r\n-\t    System.out.println(answer);\r\n-\t}\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n-\r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n-\t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t    solve();\r\n-\t    in.close();\r\n-\t    out.close();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n \t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r",
    "output": "Refactor PseudoPrimeNumbers"
  },
  {
    "input": "diff --git a/UVa/PseudoPrimeNumbers.java b/UVa/PseudoPrimeNumbers.java\n--- a/UVa/PseudoPrimeNumbers.java\n+++ b/UVa/PseudoPrimeNumbers.java\n@@ -0,0 +1,67 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.StringTokenizer;\r\n+\r\n+\r\n+public class PseudoPrimeNumbers {\r\n+\r\n+    static void solve() throws Exception {\r\n+\twhile(true){\r\n+\t    int p = nextInt();\r\n+\t    int a = nextInt();\r\n+\t    if(a== 0 && p == 0){\r\n+\t\tbreak;\r\n+\t    }\r\n+\t    BigInteger pAsBigInteger = new BigInteger(p+\"\");\r\n+\t    BigInteger aAsBigInteger = new BigInteger(a+\"\");\r\n+\t    String answer = \"\";\r\n+\t    if(!pAsBigInteger.isProbablePrime(10)){\r\n+\t\tBigInteger result = aAsBigInteger.modPow(pAsBigInteger, pAsBigInteger);\r\n+\t\tif(result.equals(aAsBigInteger)){\r\n+\t\t    answer = \"yes\";\r\n+\t\t} else {\r\n+\t\t    answer = \"no\";\r\n+\t\t}\r\n+\t    } else {\r\n+\t\tanswer = \"no\";\r\n+\t    }\r\n+\t    System.out.println(answer);\r\n+\t}\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t    solve();\r\n+\t    in.close();\r\n+\t    out.close();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve PseudoPrimeNumbers"
  },
  {
    "input": "diff --git a/UVa/MultipleOfSeventeen.java b/UVa/MultipleOfSeventeen.java\n--- a/UVa/MultipleOfSeventeen.java\n+++ b/UVa/MultipleOfSeventeen.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=3001\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for MultipleOfSeventee"
  },
  {
    "input": "diff --git a/UVa/MultipleOfSeventeen.java b/UVa/MultipleOfSeventeen.java\n--- a/UVa/MultipleOfSeventeen.java\n+++ b/UVa/MultipleOfSeventeen.java\n@@ -0,0 +1,65 @@\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class MultipleOfSeventeen {\r\n+\tprivate static final BigInteger BIGINTEGER_FIVE = new BigInteger(\"5\");\r\n+\tprivate static final BigInteger BIGINTEGER_SEVENTEEN = new BigInteger(\"17\");\r\n+\tprivate static final BigInteger BIGINTEGER_ZERO = new BigInteger(\"0\");\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\twhile (input.hasNext()) {\r\n+\t\t\tBigInteger number = input.nextBigInteger();\r\n+\t\t\tif (number.equals(BIGINTEGER_ZERO)) {\r\n+\t\t\t\tbreak;\r\n+\t\t\t}\r\n+\t\t\tBigInteger lastDigit = number.mod(BigInteger.TEN);\r\n+\t\t\tnumber = number.divide(BigInteger.TEN);\r\n+\t\t\tBigInteger product5D = lastDigit.multiply(BIGINTEGER_FIVE);\r\n+\t\t\tBigInteger difference = number.subtract(product5D);\r\n+\t\t\tif (difference.mod(BIGINTEGER_SEVENTEEN).equals(BIGINTEGER_ZERO)) {\r\n+\t\t\t\tSystem.out.println(\"1\");\r\n+\t\t\t} else {\r\n+\t\t\t\tSystem.out.println(\"0\");\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\tinput.close();\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve MultipleOfSeventeen"
  },
  {
    "input": "diff --git a/UVa/Modex.java b/UVa/Modex.java\n--- a/UVa/Modex.java\n+++ b/UVa/Modex.java\n@@ -28,59 +28,24 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3671\r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n \r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class Modex {\r\n \r\n-    static void solve() throws Exception {\r\n-\tScanner input = new Scanner(System.in);\r\n-\tint numberOfTestCases = input.nextInt();\r\n-\twhile (numberOfTestCases != 0) {\r\n-\t    BigInteger x = input.nextBigInteger();\r\n-\t    BigInteger y = input.nextBigInteger();\r\n-\t    BigInteger n = input.nextBigInteger();\r\n-\t    BigInteger result = x.modPow(y, n);\r\n-\t    System.out.println(result);\r\n-\t    numberOfTestCases--;\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tint numberOfTestCases = input.nextInt();\r\n+\t\twhile (numberOfTestCases != 0) {\r\n+\t\t\tBigInteger x = input.nextBigInteger();\r\n+\t\t\tBigInteger y = input.nextBigInteger();\r\n+\t\t\tBigInteger n = input.nextBigInteger();\r\n+\t\t\tBigInteger result = x.modPow(y, n);\r\n+\t\t\tSystem.out.println(result);\r\n+\t\t\tnumberOfTestCases--;\r\n+\t\t}\r\n+\t\tinput.close();\r\n \t}\r\n-\tinput.close();\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n-\r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n-\t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t    solve();\r\n-\t    in.close();\r\n-\t    out.close();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n-\t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r\n+\r",
    "output": "Refactor Modex"
  },
  {
    "input": "diff --git a/UVa/Modex.java b/UVa/Modex.java\n--- a/UVa/Modex.java\n+++ b/UVa/Modex.java\n@@ -0,0 +1,58 @@\n+package mathematics.bigInteger;\r\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class Modex {\r\n+\r\n+    static void solve() throws Exception {\r\n+\tScanner input = new Scanner(System.in);\r\n+\tint numberOfTestCases = input.nextInt();\r\n+\twhile (numberOfTestCases != 0) {\r\n+\t    BigInteger x = input.nextBigInteger();\r\n+\t    BigInteger y = input.nextBigInteger();\r\n+\t    BigInteger n = input.nextBigInteger();\r\n+\t    BigInteger result = x.modPow(y, n);\r\n+\t    System.out.println(result);\r\n+\t    numberOfTestCases--;\r\n+\t}\r\n+\tinput.close();\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t    solve();\r\n+\t    in.close();\r\n+\t    out.close();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve Modex"
  },
  {
    "input": "diff --git a/UVa/IntegerInquiry.java b/UVa/IntegerInquiry.java\n--- a/UVa/IntegerInquiry.java\n+++ b/UVa/IntegerInquiry.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=365\r\n+\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL for IntegerInquiry"
  },
  {
    "input": "diff --git a/UVa/IntegerInquiry.java b/UVa/IntegerInquiry.java\n--- a/UVa/IntegerInquiry.java\n+++ b/UVa/IntegerInquiry.java\n@@ -1,18 +1,9 @@\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class IntegerInquiry {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\tBigInteger sum = BigInteger.ZERO;\r\n \t\twhile (true) {\r\n@@ -25,32 +16,4 @@ static void solve() throws Exception {\n \t\tSystem.out.println(sum);\r\n \t\tinput.close();\r\n \t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor IntegerInquiry"
  },
  {
    "input": "diff --git a/UVa/IntegerInquiry.java b/UVa/IntegerInquiry.java\n--- a/UVa/IntegerInquiry.java\n+++ b/UVa/IntegerInquiry.java\n@@ -0,0 +1,56 @@\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class IntegerInquiry {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tBigInteger sum = BigInteger.ZERO;\r\n+\t\twhile (true) {\r\n+\t\t\tBigInteger number = input.nextBigInteger();\r\n+\t\t\tif (number.equals(BigInteger.ZERO)) {\r\n+\t\t\t\tbreak;\r\n+\t\t\t}\r\n+\t\t\tsum = sum.add(number);\r\n+\t\t}\r\n+\t\tSystem.out.println(sum);\r\n+\t\tinput.close();\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve IntegerInquiry"
  },
  {
    "input": "diff --git a/UVa/HighPrecisionNumber.java b/UVa/HighPrecisionNumber.java\n--- a/UVa/HighPrecisionNumber.java\n+++ b/UVa/HighPrecisionNumber.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2921\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for HighPrecisionNumber"
  },
  {
    "input": "diff --git a/UVa/HighPrecisionNumber.java b/UVa/HighPrecisionNumber.java\n--- a/UVa/HighPrecisionNumber.java\n+++ b/UVa/HighPrecisionNumber.java\n@@ -0,0 +1,58 @@\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigDecimal;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class HighPrecisionNumber {\r\n+\r\n+    static void solve() throws Exception {\r\n+\tScanner input = new Scanner(System.in);\r\n+\tint numberOfGroups = input.nextInt();\r\n+\twhile (numberOfGroups != 0) {\r\n+\t    BigDecimal sum = BigDecimal.ZERO;\r\n+\t    BigDecimal number = input.nextBigDecimal();\r\n+\t    while(!number.equals(BigDecimal.ZERO)){\r\n+\t\tsum = sum.add(number);\r\n+\t\tnumber = input.nextBigDecimal();\r\n+\t    }\r\n+\t    System.out.println(sum.toPlainString().replaceFirst(\"\\\\.0*$|(\\\\.\\\\d*?)0+$\", \"$1\"));\r\n+\t    numberOfGroups--;\r\n+\t}\r\n+\tinput.close();\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t    solve();\r\n+\t    in.close();\r\n+\t    out.close();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve HighPrecisionNumber"
  },
  {
    "input": "diff --git a/UVa/BasicallySpeaking.java b/UVa/BasicallySpeaking.java\n--- a/UVa/BasicallySpeaking.java\n+++ b/UVa/BasicallySpeaking.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=325\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for BasicallySpeaking"
  },
  {
    "input": "diff --git a/UVa/BasicallySpeaking.java b/UVa/BasicallySpeaking.java\n--- a/UVa/BasicallySpeaking.java\n+++ b/UVa/BasicallySpeaking.java\n@@ -0,0 +1,59 @@\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class BasicallySpeaking {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\twhile (input.hasNext()) {\r\n+\t\t\tString numberAsString = input.next();\r\n+\t\t\tint fromBase = input.nextInt();\r\n+\t\t\tint toBase = input.nextInt();\r\n+\t\t\tBigInteger number = new BigInteger(numberAsString, fromBase);\r\n+\t\t\tString numberThatIsPrinted = number.toString(toBase);\r\n+\t\t\tString answer = numberThatIsPrinted.toUpperCase();\r\n+\t\t\tif (numberThatIsPrinted.length() > 7) {\r\n+\t\t\t\tanswer = \"ERROR\";\r\n+\t\t\t}\r\n+\t\t\tSystem.out.printf(\"%7s\\n\", answer);\r\n+\t\t}\r\n+\t\tinput.close();\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve BasicallySpeaking"
  },
  {
    "input": "diff --git a/UVa/AddingReversedNumbers.java b/UVa/AddingReversedNumbers.java\n--- a/UVa/AddingReversedNumbers.java\n+++ b/UVa/AddingReversedNumbers.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=654\r\n+\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL for AddingReversedNumbers"
  },
  {
    "input": "diff --git a/UVa/AddingReversedNumbers.java b/UVa/AddingReversedNumbers.java\n--- a/UVa/AddingReversedNumbers.java\n+++ b/UVa/AddingReversedNumbers.java\n@@ -1,13 +1,5 @@\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class AddingReversedNumbers {\r\n \r\n@@ -31,28 +23,4 @@ static void solve() throws Exception {\n \t\t}\r\n \t\tinput.close();\r\n \t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tsolve();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor AddingReversedNumbers:"
  },
  {
    "input": "diff --git a/UVa/AddingReversedNumbers.java b/UVa/AddingReversedNumbers.java\n--- a/UVa/AddingReversedNumbers.java\n+++ b/UVa/AddingReversedNumbers.java\n@@ -0,0 +1,58 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class AddingReversedNumbers {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tint numberOfTestCases = input.nextInt();\r\n+\t\twhile (numberOfTestCases != 0) {\r\n+\t\t\tBigInteger first = input.nextBigInteger();\r\n+\t\t\tBigInteger second = input.nextBigInteger();\r\n+\t\t\tStringBuilder firstString = new StringBuilder(first + \"\");\r\n+\t\t\tStringBuilder secondString = new StringBuilder(second + \"\");\r\n+\t\t\tBigInteger firstReversed = new BigInteger(firstString.reverse()\r\n+\t\t\t\t\t.toString());\r\n+\t\t\tBigInteger secondReversed = new BigInteger(secondString.reverse()\r\n+\t\t\t\t\t.toString());\r\n+\t\t\tBigInteger result = firstReversed.add(secondReversed);\r\n+\t\t\tString resultReversed = new StringBuilder(result + \"\").reverse()\r\n+\t\t\t\t\t.toString();\r\n+\t\t\tSystem.out.println(resultReversed.replaceFirst(\"^0*\", \"\"));\r\n+\t\t\tnumberOfTestCases--;\r\n+\t\t}\r\n+\t\tinput.close();\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tsolve();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve AddingReversedNumbers"
  },
  {
    "input": "diff --git a/UVa/NumberingRoads.java b/UVa/NumberingRoads.java\n--- a/UVa/NumberingRoads.java\n+++ b/UVa/NumberingRoads.java\n@@ -36,6 +36,9 @@\n  * Case 2: impossible\r\n  */\r\n \r\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2823\r\n+\r\n import java.util.Scanner;\r\n \r\n public class NumberingRoads {\r",
    "output": "Add problem source URL for NumberingRoads"
  },
  {
    "input": "diff --git a/UVa/NumberingRoads.java b/UVa/NumberingRoads.java\n--- a/UVa/NumberingRoads.java\n+++ b/UVa/NumberingRoads.java\n@@ -1,64 +1,28 @@\n-package mathematics.adHoc.simpler;\r\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class NumberingRoads {\r\n \r\n-    static void solve() throws Exception {\r\n-\tint caseNumber = 1;\r\n-\twhile (true) {\r\n-\t    int first = nextInt();\r\n-\t    int second = nextInt();\r\n-\t    if (first == 0 && second == 0) {\r\n-\t\tbreak;\r\n-\t    }\r\n-\t    boolean found = false;\r\n-\t    for (int i = 0; i < 27 && !found; i++) {\r\n-\t\tint sum = second + second * i;\r\n-\t\tif (sum >= first) {\r\n-\t\t    System.out.print(\"Case \" + caseNumber + \": \" + i + \"\\n\");\r\n-\t\t    found = true;\r\n+\tstatic void solve() throws Exception {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tint caseNumber = 1;\r\n+\t\twhile (true) {\r\n+\t\t\tint first = input.nextInt();\r\n+\t\t\tint second = input.nextInt();\r\n+\t\t\tif (first == 0 && second == 0) {\r\n+\t\t\t\tbreak;\r\n+\t\t\t}\r\n+\t\t\tboolean found = false;\r\n+\t\t\tfor (int i = 0; i < 27 && !found; i++) {\r\n+\t\t\t\tint sum = second + second * i;\r\n+\t\t\t\tif (sum >= first) {\r\n+\t\t\t\t\tSystem.out.print(\"Case \" + caseNumber + \": \" + i + \"\\n\");\r\n+\t\t\t\t\tfound = true;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tif (!found) {\r\n+\t\t\t\tSystem.out.print(\"Case \" + caseNumber + \": impossible\\n\");\r\n+\t\t\t}\r\n+\t\t\tcaseNumber = caseNumber + 1;\r\n \t\t}\r\n-\t    }\r\n-\t    if (!found) {\r\n-\t\tSystem.out.print(\"Case \" + caseNumber + \": impossible\\n\");\r\n-\t    }\r\n-\t    caseNumber = caseNumber + 1;\r\n-\t}\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n-\r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n \t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t    solve();\r\n-\t    in.close();\r\n-\t    out.close();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n-\t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r",
    "output": "Refactor NumberingRoads"
  },
  {
    "input": "diff --git a/UVa/NumberingRoads.java b/UVa/NumberingRoads.java\n--- a/UVa/NumberingRoads.java\n+++ b/UVa/NumberingRoads.java\n@@ -0,0 +1,64 @@\n+package mathematics.adHoc.simpler;\r\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class NumberingRoads {\r\n+\r\n+    static void solve() throws Exception {\r\n+\tint caseNumber = 1;\r\n+\twhile (true) {\r\n+\t    int first = nextInt();\r\n+\t    int second = nextInt();\r\n+\t    if (first == 0 && second == 0) {\r\n+\t\tbreak;\r\n+\t    }\r\n+\t    boolean found = false;\r\n+\t    for (int i = 0; i < 27 && !found; i++) {\r\n+\t\tint sum = second + second * i;\r\n+\t\tif (sum >= first) {\r\n+\t\t    System.out.print(\"Case \" + caseNumber + \": \" + i + \"\\n\");\r\n+\t\t    found = true;\r\n+\t\t}\r\n+\t    }\r\n+\t    if (!found) {\r\n+\t\tSystem.out.print(\"Case \" + caseNumber + \": impossible\\n\");\r\n+\t    }\r\n+\t    caseNumber = caseNumber + 1;\r\n+\t}\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t    solve();\r\n+\t    in.close();\r\n+\t    out.close();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve NumberingRoads"
  },
  {
    "input": "diff --git a/UVa/HighSchoolPhysics.java b/UVa/HighSchoolPhysics.java\n--- a/UVa/HighSchoolPhysics.java\n+++ b/UVa/HighSchoolPhysics.java\n@@ -1,16 +1,18 @@\n-import java.util.Scanner;\r\n-\r\n-public class HighSchoolPhysics {\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\tScanner input = new Scanner(System.in);\r\n-\t\tString line = input.nextLine();\r\n-\t\twhile (!\"\".equals(line)) {\r\n-\t\t\tString[] numbers = line.split(\" \");\r\n-\t\t\tint v = Integer.valueOf(numbers[0]);\r\n-\t\t\tint t = Integer.valueOf(numbers[1]) * 2;\r\n-\t\t\tSystem.out.println(v * t);\r\n-\t\t\tline = input.nextLine();\r\n-\t\t}\r\n-\t}\r\n-}\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1012\n+\n+import java.util.Scanner;\n+\n+public class HighSchoolPhysics {\n+\n+\tpublic static void main(String[] args) {\n+\t\tScanner input = new Scanner(System.in);\n+\t\tString line = input.nextLine();\n+\t\twhile (!\"\".equals(line)) {\n+\t\t\tString[] numbers = line.split(\" \");\n+\t\t\tint v = Integer.valueOf(numbers[0]);\n+\t\t\tint t = Integer.valueOf(numbers[1]) * 2;\n+\t\t\tSystem.out.println(v * t);\n+\t\t\tline = input.nextLine();\n+\t\t}\n+\t}\n+}",
    "output": "Add problem source URL for HighSchoolPhysics"
  },
  {
    "input": "diff --git a/UVa/HighSchoolPhysics.java b/UVa/HighSchoolPhysics.java\n--- a/UVa/HighSchoolPhysics.java\n+++ b/UVa/HighSchoolPhysics.java\n@@ -1,55 +1,16 @@\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class HighSchoolPhysics {\r\n \r\n-\tstatic void solve() throws Exception {\r\n-\t\tString line = nextLine();\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tString line = input.nextLine();\r\n \t\twhile (!\"\".equals(line)) {\r\n \t\t\tString[] numbers = line.split(\" \");\r\n \t\t\tint v = Integer.valueOf(numbers[0]);\r\n \t\t\tint t = Integer.valueOf(numbers[1]) * 2;\r\n \t\t\tSystem.out.println(v * t);\r\n-\t\t\tline = nextLine();\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String nextLine() throws IOException {\r\n-\t\treturn in.readLine();\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t\tline = input.nextLine();\r\n \t\t}\r\n-\t\treturn tok.nextToken();\r\n \t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor HighSchoolPhysics"
  },
  {
    "input": "diff --git a/UVa/HighSchoolPhysics.java b/UVa/HighSchoolPhysics.java\n--- a/UVa/HighSchoolPhysics.java\n+++ b/UVa/HighSchoolPhysics.java\n@@ -0,0 +1,55 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class HighSchoolPhysics {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tString line = nextLine();\r\n+\t\twhile (!\"\".equals(line)) {\r\n+\t\t\tString[] numbers = line.split(\" \");\r\n+\t\t\tint v = Integer.valueOf(numbers[0]);\r\n+\t\t\tint t = Integer.valueOf(numbers[1]) * 2;\r\n+\t\t\tSystem.out.println(v * t);\r\n+\t\t\tline = nextLine();\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String nextLine() throws IOException {\r\n+\t\treturn in.readLine();\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve HighSchoolPhysics"
  },
  {
    "input": "diff --git a/UVa/HashmatWarriors.java b/UVa/HashmatWarriors.java\n--- a/UVa/HashmatWarriors.java\n+++ b/UVa/HashmatWarriors.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=996\r\n+\r\n import java.util.Scanner;\r\n \r\n public class HashmatWarriors {\r",
    "output": "Add problem source URL for HashmatWarriors"
  },
  {
    "input": "diff --git a/UVa/HashmatWarriors.java b/UVa/HashmatWarriors.java\n--- a/UVa/HashmatWarriors.java\n+++ b/UVa/HashmatWarriors.java\n@@ -1,56 +1,16 @@\n-\r\n-import static java.lang.Long.parseLong;\r\n-import static java.lang.System.exit;\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class HashmatWarriors {\r\n \r\n-\tstatic void solve() throws Exception {\r\n-\r\n-\t\tString nextLine = nextLine();\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tString nextLine = input.nextLine();\r\n \t\twhile (!\"\".equals(nextLine)) {\r\n \t\t\tString[] nums = nextLine.split(\" \");\r\n \t\t\tlong firstNum = Long.valueOf(nums[0]);\r\n \t\t\tlong secondNum = Long.valueOf(nums[1]);\r\n \t\t\tSystem.out.println(Math.abs(secondNum - firstNum));\r\n-\t\t\tnextLine = nextLine();\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic long nextLong() throws IOException {\r\n-\t\treturn parseLong(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t\tnextLine = input.nextLine();\r\n \t\t}\r\n-\t\treturn tok.nextToken();\r\n \t}\r\n-\r\n-\tstatic String nextLine() throws IOException {\r\n-\t\treturn in.readLine();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor HashmatWarriors"
  },
  {
    "input": "diff --git a/UVa/HashmatWarriors.java b/UVa/HashmatWarriors.java\n--- a/UVa/HashmatWarriors.java\n+++ b/UVa/HashmatWarriors.java\n@@ -0,0 +1,56 @@\n+\r\n+import static java.lang.Long.parseLong;\r\n+import static java.lang.System.exit;\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class HashmatWarriors {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\r\n+\t\tString nextLine = nextLine();\r\n+\t\twhile (!\"\".equals(nextLine)) {\r\n+\t\t\tString[] nums = nextLine.split(\" \");\r\n+\t\t\tlong firstNum = Long.valueOf(nums[0]);\r\n+\t\t\tlong secondNum = Long.valueOf(nums[1]);\r\n+\t\t\tSystem.out.println(Math.abs(secondNum - firstNum));\r\n+\t\t\tnextLine = nextLine();\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic long nextLong() throws IOException {\r\n+\t\treturn parseLong(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tstatic String nextLine() throws IOException {\r\n+\t\treturn in.readLine();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Refactor HashmatWarriors"
  },
  {
    "input": "diff --git a/UVa/BrickGame.java b/UVa/BrickGame.java\n--- a/UVa/BrickGame.java\n+++ b/UVa/BrickGame.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2986\r\n+\r\n import static java.lang.Integer.parseInt;\r\n \r\n import java.util.ArrayList;\r",
    "output": "Add problem source URL for BrickGame"
  },
  {
    "input": "diff --git a/UVa/BrickGame.java b/UVa/BrickGame.java\n--- a/UVa/BrickGame.java\n+++ b/UVa/BrickGame.java\n@@ -1,67 +1,31 @@\n-package mathematics.adHoc.simpler;\r\n-\r\n import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n \r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.util.ArrayList;\r\n import java.util.Collections;\r\n import java.util.List;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class BrickGame {\r\n \r\n-    static void solve() throws Exception {\r\n-\tint numberOfTestCases = nextInt();\r\n-\tint caseNum = 1;\r\n-\twhile (numberOfTestCases != 0) {\r\n-\t    String[] numbersString = nextLine().split(\" \");\r\n-\t    int numberOfMembers = parseInt(numbersString[0]);\r\n-\t    List<Integer> numbers = new ArrayList<Integer>();\r\n-\t    for (int i = 0; i < numberOfMembers + 1; i++) {\r\n-\t\tnumbers.add(parseInt(numbersString[i]));\r\n-\t    }\r\n-\t    Collections.sort(numbers);\r\n-\t    System.out.print(\r\n-\t\t    \"Case \" + caseNum + \": \" + numbers.subList(1, numbers.size()).get(numberOfMembers / 2) + \"\\n\");\r\n-\t    numberOfTestCases--;\r\n-\t    caseNum++;\r\n-\t}\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n-\r\n-    static String nextLine() throws IOException {\r\n-\treturn in.readLine();\r\n-    }\r\n-\r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n-\t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t    solve();\r\n-\t    in.close();\r\n-\t    out.close();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tint numberOfTestCases = input.nextInt();\r\n+\t\tint caseNum = 1;\r\n+\t\twhile (numberOfTestCases != 0) {\r\n+\t\t\tString[] numbersString = input.nextLine().split(\" \");\r\n+\t\t\tint numberOfMembers = parseInt(numbersString[0]);\r\n+\t\t\tList<Integer> numbers = new ArrayList<Integer>();\r\n+\t\t\tfor (int i = 0; i < numberOfMembers + 1; i++) {\r\n+\t\t\t\tnumbers.add(parseInt(numbersString[i]));\r\n+\t\t\t}\r\n+\t\t\tCollections.sort(numbers);\r\n+\t\t\tSystem.out.print(\"Case \"\r\n+\t\t\t\t\t+ caseNum\r\n+\t\t\t\t\t+ \": \"\r\n+\t\t\t\t\t+ numbers.subList(1, numbers.size()).get(\r\n+\t\t\t\t\t\t\tnumberOfMembers / 2) + \"\\n\");\r\n+\t\t\tnumberOfTestCases--;\r\n+\t\t\tcaseNum++;\r\n+\t\t}\r\n \t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r",
    "output": "Refactor BrickGame"
  },
  {
    "input": "diff --git a/UVa/BackToIntermediateMath.java b/UVa/BackToIntermediateMath.java\n--- a/UVa/BackToIntermediateMath.java\n+++ b/UVa/BackToIntermediateMath.java\n@@ -28,6 +28,7 @@\n  * Case 2: 0.114\r\n  * Case 3: 0.135\r\n  */\r\n+\r\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=1714\r\n \r\n import java.text.DecimalFormat;\r\n\ndiff --git a/UVa/BrickGame.java b/UVa/BrickGame.java\n--- a/UVa/BrickGame.java\n+++ b/UVa/BrickGame.java\n@@ -0,0 +1,67 @@\n+package mathematics.adHoc.simpler;\r\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.util.ArrayList;\r\n+import java.util.Collections;\r\n+import java.util.List;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class BrickGame {\r\n+\r\n+    static void solve() throws Exception {\r\n+\tint numberOfTestCases = nextInt();\r\n+\tint caseNum = 1;\r\n+\twhile (numberOfTestCases != 0) {\r\n+\t    String[] numbersString = nextLine().split(\" \");\r\n+\t    int numberOfMembers = parseInt(numbersString[0]);\r\n+\t    List<Integer> numbers = new ArrayList<Integer>();\r\n+\t    for (int i = 0; i < numberOfMembers + 1; i++) {\r\n+\t\tnumbers.add(parseInt(numbersString[i]));\r\n+\t    }\r\n+\t    Collections.sort(numbers);\r\n+\t    System.out.print(\r\n+\t\t    \"Case \" + caseNum + \": \" + numbers.subList(1, numbers.size()).get(numberOfMembers / 2) + \"\\n\");\r\n+\t    numberOfTestCases--;\r\n+\t    caseNum++;\r\n+\t}\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static String nextLine() throws IOException {\r\n+\treturn in.readLine();\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t    solve();\r\n+\t    in.close();\r\n+\t    out.close();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve BrickGame"
  },
  {
    "input": "diff --git a/UVa/BackToIntermediateMath.java b/UVa/BackToIntermediateMath.java\n--- a/UVa/BackToIntermediateMath.java\n+++ b/UVa/BackToIntermediateMath.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=1714\r\n+\r\n import java.text.DecimalFormat;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL for BackToIntermediateMath"
  },
  {
    "input": "diff --git a/UVa/BackToIntermediateMath.java b/UVa/BackToIntermediateMath.java\n--- a/UVa/BackToIntermediateMath.java\n+++ b/UVa/BackToIntermediateMath.java\n@@ -1,24 +1,16 @@\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.text.DecimalFormat;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class BackToIntermediateMath {\r\n \r\n-\tstatic void solve() throws Exception {\r\n-\t\tint numberOfTestCases = nextInt();\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tint numberOfTestCases = input.nextInt();\r\n \t\tDecimalFormat formatter = new DecimalFormat(\"#0.000\");\r\n \t\tfor (int i = 0; i < numberOfTestCases; i++) {\r\n-\t\t\tdouble distance = nextDouble();\r\n-\t\t\tdouble riverSpeed = nextDouble();\r\n-\t\t\tdouble boatSpeed = nextDouble();\r\n+\t\t\tdouble distance = input.nextDouble();\r\n+\t\t\tdouble riverSpeed = input.nextDouble();\r\n+\t\t\tdouble boatSpeed = input.nextDouble();\r\n \t\t\tif (riverSpeed == 0 || boatSpeed == 0 || boatSpeed <= riverSpeed) {\r\n \t\t\t\tSystem.out.println(\"Case \" + (i + 1) + \": can't determine\");\r\n \t\t\t} else {\r\n@@ -31,36 +23,4 @@ static void solve() throws Exception {\n \t\t\t}\r\n \t\t}\r\n \t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic int nextDouble() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Add problem source URL for BackToIntermediateMath"
  },
  {
    "input": "diff --git a/UVa/BackToIntermediateMath.java b/UVa/BackToIntermediateMath.java\n--- a/UVa/BackToIntermediateMath.java\n+++ b/UVa/BackToIntermediateMath.java\n@@ -0,0 +1,66 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.text.DecimalFormat;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class BackToIntermediateMath {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tint numberOfTestCases = nextInt();\r\n+\t\tDecimalFormat formatter = new DecimalFormat(\"#0.000\");\r\n+\t\tfor (int i = 0; i < numberOfTestCases; i++) {\r\n+\t\t\tdouble distance = nextDouble();\r\n+\t\t\tdouble riverSpeed = nextDouble();\r\n+\t\t\tdouble boatSpeed = nextDouble();\r\n+\t\t\tif (riverSpeed == 0 || boatSpeed == 0 || boatSpeed <= riverSpeed) {\r\n+\t\t\t\tSystem.out.println(\"Case \" + (i + 1) + \": can't determine\");\r\n+\t\t\t} else {\r\n+\t\t\t\tdouble P1 = distance / boatSpeed;\r\n+\t\t\t\tdouble P2 = distance\r\n+\t\t\t\t\t\t/ Math.sqrt(boatSpeed * boatSpeed - riverSpeed\r\n+\t\t\t\t\t\t\t\t* riverSpeed);\r\n+\t\t\t\tSystem.out.print(\"Case \" + (i + 1) + \": \"\r\n+\t\t\t\t\t\t+ formatter.format(Math.abs(P1 - P2)) + \"\\n\");\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic int nextDouble() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve BackToIntermediateMath"
  },
  {
    "input": "diff --git a/UVa/AverageSpeed.java b/UVa/AverageSpeed.java\n--- a/UVa/AverageSpeed.java\n+++ b/UVa/AverageSpeed.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1222\r\n+\r\n import java.text.DecimalFormat;\r\n import java.util.Scanner;\r\n \r\n@@ -31,7 +34,7 @@ static void solve() throws Exception {\n \r\n \t}\r\n \r\n-\tpublic static double calcHours(String s) {\r\n+\tprivate static double calcHours(String s) {\r\n \t\tString[] arr = s.split(\":\");\r\n \t\treturn (Integer.parseInt(arr[0]) * 3600 + Integer.parseInt(arr[1]) * 60 + Integer\r\n \t\t\t\t.parseInt(arr[2])) * 1.0 / 3600;\r",
    "output": "Add problem source URL for AverageSpeed"
  },
  {
    "input": "diff --git a/UVa/AverageSpeed.java b/UVa/AverageSpeed.java\n--- a/UVa/AverageSpeed.java\n+++ b/UVa/AverageSpeed.java\n@@ -1,78 +1,39 @@\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.text.DecimalFormat;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class AverageSpeed {\r\n \r\n-    static void solve() throws Exception {\r\n-\tint speed = 0;\r\n-\tboolean reachedTheEnd = false;\r\n-\tString nextLine = nextLine();\r\n-\tdouble hour = 0;\r\n-\tdouble baseHour = 0;\r\n-\tdouble kilometersPassed = 0;\r\n-\twhile (!reachedTheEnd) {\r\n-\t    String[] time1 = nextLine.split(\" \");\r\n-\t    String[] time = nextLine.split(\":\");\r\n-\t    String[] extendedTime = new String[2];\r\n-\t    DecimalFormat formatter = new DecimalFormat(\"#0.00\");\r\n-\t    hour = calcHours(time1[0]);\r\n-\t    kilometersPassed += (hour - baseHour) * speed;\r\n-\t    if (time[2].contains(\" \")) {\r\n-\t\textendedTime = time[2].split(\" \");\r\n-\t\tspeed = Integer.valueOf(extendedTime[1]);\r\n-\t    } else {\r\n-\t\tSystem.out.print(nextLine + \" \" + formatter.format(kilometersPassed) + \" km\\n\");\r\n-\t    }\r\n-\t    baseHour = hour;\r\n-\t    nextLine = nextLine();\r\n-\t}\r\n-\r\n-    }\r\n+\tstatic void solve() throws Exception {\r\n+\t\tint speed = 0;\r\n+\t\tboolean reachedTheEnd = false;\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tString nextLine = input.nextLine();\r\n+\t\tdouble hour = 0;\r\n+\t\tdouble baseHour = 0;\r\n+\t\tdouble kilometersPassed = 0;\r\n+\t\twhile (!reachedTheEnd) {\r\n+\t\t\tString[] time1 = nextLine.split(\" \");\r\n+\t\t\tString[] time = nextLine.split(\":\");\r\n+\t\t\tString[] extendedTime = new String[2];\r\n+\t\t\tDecimalFormat formatter = new DecimalFormat(\"#0.00\");\r\n+\t\t\thour = calcHours(time1[0]);\r\n+\t\t\tkilometersPassed += (hour - baseHour) * speed;\r\n+\t\t\tif (time[2].contains(\" \")) {\r\n+\t\t\t\textendedTime = time[2].split(\" \");\r\n+\t\t\t\tspeed = Integer.valueOf(extendedTime[1]);\r\n+\t\t\t} else {\r\n+\t\t\t\tSystem.out.print(nextLine + \" \"\r\n+\t\t\t\t\t\t+ formatter.format(kilometersPassed) + \" km\\n\");\r\n+\t\t\t}\r\n+\t\t\tbaseHour = hour;\r\n+\t\t\tnextLine = input.nextLine();\r\n+\t\t}\r\n \r\n-    public static double calcHours(String s) {\r\n-\tString[] arr = s.split(\":\");\r\n-\treturn (Integer.parseInt(arr[0]) * 3600 + Integer.parseInt(arr[1]) * 60 + Integer.parseInt(arr[2])) * 1.0\r\n-\t\t/ 3600;\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n-\r\n-    static String nextLine() throws IOException {\r\n-\treturn in.readLine();\r\n-    }\r\n-\r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n \t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n \r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t    solve();\r\n-\t    in.close();\r\n-\t    out.close();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n+\tpublic static double calcHours(String s) {\r\n+\t\tString[] arr = s.split(\":\");\r\n+\t\treturn (Integer.parseInt(arr[0]) * 3600 + Integer.parseInt(arr[1]) * 60 + Integer\r\n+\t\t\t\t.parseInt(arr[2])) * 1.0 / 3600;\r\n \t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r",
    "output": "Refactor AverageSpeed"
  },
  {
    "input": "diff --git a/UVa/AverageSpeed.java b/UVa/AverageSpeed.java\n--- a/UVa/AverageSpeed.java\n+++ b/UVa/AverageSpeed.java\n@@ -0,0 +1,78 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.text.DecimalFormat;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class AverageSpeed {\r\n+\r\n+    static void solve() throws Exception {\r\n+\tint speed = 0;\r\n+\tboolean reachedTheEnd = false;\r\n+\tString nextLine = nextLine();\r\n+\tdouble hour = 0;\r\n+\tdouble baseHour = 0;\r\n+\tdouble kilometersPassed = 0;\r\n+\twhile (!reachedTheEnd) {\r\n+\t    String[] time1 = nextLine.split(\" \");\r\n+\t    String[] time = nextLine.split(\":\");\r\n+\t    String[] extendedTime = new String[2];\r\n+\t    DecimalFormat formatter = new DecimalFormat(\"#0.00\");\r\n+\t    hour = calcHours(time1[0]);\r\n+\t    kilometersPassed += (hour - baseHour) * speed;\r\n+\t    if (time[2].contains(\" \")) {\r\n+\t\textendedTime = time[2].split(\" \");\r\n+\t\tspeed = Integer.valueOf(extendedTime[1]);\r\n+\t    } else {\r\n+\t\tSystem.out.print(nextLine + \" \" + formatter.format(kilometersPassed) + \" km\\n\");\r\n+\t    }\r\n+\t    baseHour = hour;\r\n+\t    nextLine = nextLine();\r\n+\t}\r\n+\r\n+    }\r\n+\r\n+    public static double calcHours(String s) {\r\n+\tString[] arr = s.split(\":\");\r\n+\treturn (Integer.parseInt(arr[0]) * 3600 + Integer.parseInt(arr[1]) * 60 + Integer.parseInt(arr[2])) * 1.0\r\n+\t\t/ 3600;\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static String nextLine() throws IOException {\r\n+\treturn in.readLine();\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t    solve();\r\n+\t    in.close();\r\n+\t    out.close();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve AverageSpeed"
  },
  {
    "input": "diff --git a/UVa/ArchaeologistsDilemma.java b/UVa/ArchaeologistsDilemma.java\n--- a/UVa/ArchaeologistsDilemma.java\n+++ b/UVa/ArchaeologistsDilemma.java\n@@ -1,3 +1,5 @@\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=642\r\n+\r\n import java.io.IOException;\r\n import java.util.Scanner;\r\n \r",
    "output": "asf"
  },
  {
    "input": "diff --git a/UVa/ArchaeologistsDilemma.java b/UVa/ArchaeologistsDilemma.java\n--- a/UVa/ArchaeologistsDilemma.java\n+++ b/UVa/ArchaeologistsDilemma.java\n@@ -1,70 +1,30 @@\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.Long.parseLong;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class ArchaeologistsDilemma {\r\n \r\n-    public static final boolean DEBUG = true;\r\n-    public static final boolean DEBUG_INPUT = true;\r\n+\tpublic static final boolean DEBUG = true;\r\n+\tpublic static final boolean DEBUG_INPUT = true;\r\n \r\n-    final static double LOG2 = Math.log(2.0);\r\n-    final static double LOG2_10 = Math.log(10) / LOG2;\r\n+\tfinal static double LOG2 = Math.log(2.0);\r\n+\tfinal static double LOG2_10 = Math.log(10) / LOG2;\r\n \r\n-    public static void solve() throws IOException {\r\n-\twhile (true) {\r\n-\t    long N = nextLong();\r\n-\t    int k = (N + \"\").length() + 1;\r\n+\tpublic static void solve() throws IOException {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\twhile (true) {\r\n+\t\t\tlong N = input.nextLong();\r\n+\t\t\tint k = (N + \"\").length() + 1;\r\n \r\n-\t    long lowerBound = (long) ((Math.log(N) / LOG2) + k * LOG2_10);\r\n-\t    long upperBound = (long) ((Math.log(N + 1) / LOG2) + k * LOG2_10);\r\n+\t\t\tlong lowerBound = (long) ((Math.log(N) / LOG2) + k * LOG2_10);\r\n+\t\t\tlong upperBound = (long) ((Math.log(N + 1) / LOG2) + k * LOG2_10);\r\n \r\n-\t    while (lowerBound == upperBound) {\r\n-\t\tk++;\r\n-\t\tlowerBound = (long) ((Math.log(N) / LOG2) + k * LOG2_10);\r\n-\t\tupperBound = (long) ((Math.log(N + 1) / LOG2) + k * LOG2_10);\r\n-\t    }\r\n+\t\t\twhile (lowerBound == upperBound) {\r\n+\t\t\t\tk++;\r\n+\t\t\t\tlowerBound = (long) ((Math.log(N) / LOG2) + k * LOG2_10);\r\n+\t\t\t\tupperBound = (long) ((Math.log(N + 1) / LOG2) + k * LOG2_10);\r\n+\t\t\t}\r\n \r\n-\t    System.out.println(upperBound);\r\n+\t\t\tSystem.out.println(upperBound);\r\n+\t\t}\r\n \t}\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n-\r\n-    static long nextLong() throws IOException {\r\n-\treturn parseLong(next());\r\n-    }\r\n-\r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n-\t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t    solve();\r\n-\t    in.close();\r\n-\t    out.close();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n-\t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r",
    "output": "Refactor ArchaeologistsDilemma"
  },
  {
    "input": "diff --git a/UVa/ArchaeologistsDilemma.java b/UVa/ArchaeologistsDilemma.java\n--- a/UVa/ArchaeologistsDilemma.java\n+++ b/UVa/ArchaeologistsDilemma.java\n@@ -0,0 +1,70 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.Long.parseLong;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class ArchaeologistsDilemma {\r\n+\r\n+    public static final boolean DEBUG = true;\r\n+    public static final boolean DEBUG_INPUT = true;\r\n+\r\n+    final static double LOG2 = Math.log(2.0);\r\n+    final static double LOG2_10 = Math.log(10) / LOG2;\r\n+\r\n+    public static void solve() throws IOException {\r\n+\twhile (true) {\r\n+\t    long N = nextLong();\r\n+\t    int k = (N + \"\").length() + 1;\r\n+\r\n+\t    long lowerBound = (long) ((Math.log(N) / LOG2) + k * LOG2_10);\r\n+\t    long upperBound = (long) ((Math.log(N + 1) / LOG2) + k * LOG2_10);\r\n+\r\n+\t    while (lowerBound == upperBound) {\r\n+\t\tk++;\r\n+\t\tlowerBound = (long) ((Math.log(N) / LOG2) + k * LOG2_10);\r\n+\t\tupperBound = (long) ((Math.log(N + 1) / LOG2) + k * LOG2_10);\r\n+\t    }\r\n+\r\n+\t    System.out.println(upperBound);\r\n+\t}\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static long nextLong() throws IOException {\r\n+\treturn parseLong(next());\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t    solve();\r\n+\t    in.close();\r\n+\t    out.close();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve ArchaeologistsDilemma"
  },
  {
    "input": "diff --git a/UVa/CoconutsRevisited.java b/UVa/CoconutsRevisited.java\n--- a/UVa/CoconutsRevisited.java\n+++ b/UVa/CoconutsRevisited.java\n@@ -32,6 +32,7 @@\n  * 30 coconuts, no solution\r\n  * 3121 coconuts, 5 people and 1 monkey\r\n  */\r\n+\r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=557\r\n \r\n import java.util.Scanner;\r",
    "output": "Add problem description for CoconutRevisited"
  },
  {
    "input": "diff --git a/UVa/CoconutsRevisited.java b/UVa/CoconutsRevisited.java\n--- a/UVa/CoconutsRevisited.java\n+++ b/UVa/CoconutsRevisited.java\n@@ -1,21 +1,14 @@\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class CoconutsRevisited {\r\n \r\n \tstatic void solve() throws Exception {\r\n+\t\tScanner input = new Scanner(System.in);\r\n \t\tint i, rez, j;\r\n \t\tboolean isValid;\r\n \t\twhile (true) {\r\n \t\t\tisValid = false;\r\n-\t\t\tint num = nextInt();\r\n+\t\t\tint num = input.nextInt();\r\n \t\t\tif (num == -1) {\r\n \t\t\t\tbreak;\r\n \t\t\t}\r\n@@ -38,32 +31,4 @@ static void solve() throws Exception {\n \t\t}\r\n \r\n \t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor CoconutRevisited"
  },
  {
    "input": "diff --git a/UVa/CoconutsRevisited.java b/UVa/CoconutsRevisited.java\n--- a/UVa/CoconutsRevisited.java\n+++ b/UVa/CoconutsRevisited.java\n@@ -0,0 +1,69 @@\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class CoconutsRevisited {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tint i, rez, j;\r\n+\t\tboolean isValid;\r\n+\t\twhile (true) {\r\n+\t\t\tisValid = false;\r\n+\t\t\tint num = nextInt();\r\n+\t\t\tif (num == -1) {\r\n+\t\t\t\tbreak;\r\n+\t\t\t}\r\n+\t\t\tfor (i = (int) (Math.sqrt(num) + 1); i > 1; i--) {\r\n+\t\t\t\trez = num;\r\n+\t\t\t\tfor (j = 0; j < i && rez % i == 1; j++) {\r\n+\t\t\t\t\trez = rez - rez / i - 1;\r\n+\t\t\t\t}\r\n+\t\t\t\tif (rez % i == 0 && i == j) {\r\n+\t\t\t\t\tisValid = true;\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tif (isValid) {\r\n+\t\t\t\tSystem.out.println(num + \" coconuts, \" + i\r\n+\t\t\t\t\t\t+ \" people and 1 monkey\");\r\n+\t\t\t} else {\r\n+\t\t\t\tSystem.out.println(num + \" coconuts, no solution\");\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve CoconutesRevisited"
  },
  {
    "input": "diff --git a/UVa/DigitCounting.java b/UVa/DigitCounting.java\n--- a/UVa/DigitCounting.java\n+++ b/UVa/DigitCounting.java\n@@ -1,4 +1,6 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3666\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for DigitCounting"
  },
  {
    "input": "diff --git a/UVa/DigitCounting.java b/UVa/DigitCounting.java\n--- a/UVa/DigitCounting.java\n+++ b/UVa/DigitCounting.java\n@@ -0,0 +1,64 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class DigitCounting {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tint numberOfTestCases = nextInt();\r\n+\t\twhile (numberOfTestCases != 0) {\r\n+\t\t\tint[] numbers = new int[10];\r\n+\t\t\tint number = nextInt();\r\n+\t\t\tfor (int i = number; i > 0; i--) {\r\n+\t\t\t\tint j = i;\r\n+\t\t\t\twhile (j != 0) {\r\n+\t\t\t\t\tnumbers[j % 10]++;\r\n+\t\t\t\t\tj = j / 10;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tfor (int i = 0; i < 10; i++) {\r\n+\t\t\t\tif (i != 0) {\r\n+\t\t\t\t\tSystem.out.print(\" \");\r\n+\t\t\t\t}\r\n+\t\t\t\tSystem.out.print(numbers[i]);\r\n+\t\t\t}\r\n+\t\t\tSystem.out.println();\r\n+\t\t\tnumberOfTestCases--;\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve DigitCounting"
  },
  {
    "input": "diff --git a/UVa/SkewBinary.java b/UVa/SkewBinary.java\n--- a/UVa/SkewBinary.java\n+++ b/UVa/SkewBinary.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=516\r\n+\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL at SkewBinary"
  },
  {
    "input": "diff --git a/UVa/SkewBinary.java b/UVa/SkewBinary.java\n--- a/UVa/SkewBinary.java\n+++ b/UVa/SkewBinary.java\n@@ -1,20 +1,9 @@\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.Long.parseLong;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class SkewBinary {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\twhile (true) {\r\n \t\t\tBigInteger number = input.nextBigInteger();\r\n@@ -33,38 +22,5 @@ static void solve() throws Exception {\n \t\t\tSystem.out.println(sum);\r\n \t\t}\r\n \t\tinput.close();\r\n-\r\n-\t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic long nextLong() throws IOException {\r\n-\t\treturn parseLong(next());\r\n \t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Add SkewBinary"
  },
  {
    "input": "diff --git a/UVa/SkewBinary.java b/UVa/SkewBinary.java\n--- a/UVa/SkewBinary.java\n+++ b/UVa/SkewBinary.java\n@@ -0,0 +1,70 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.Long.parseLong;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class SkewBinary {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\twhile (true) {\r\n+\t\t\tBigInteger number = input.nextBigInteger();\r\n+\t\t\tif (number.equals(BigInteger.ZERO)) {\r\n+\t\t\t\tbreak;\r\n+\t\t\t}\r\n+\t\t\tint length = (number + \"\").length();\r\n+\t\t\tBigInteger sum = BigInteger.ZERO;\r\n+\t\t\tfor (int i = 0; i < length; i++) {\r\n+\t\t\t\tBigInteger mod10 = number.mod(BigInteger.TEN);\r\n+\t\t\t\tBigInteger insideBrackets = BigInteger.valueOf((long) (Math\r\n+\t\t\t\t\t\t.pow(2, i + 1) - 1));\r\n+\t\t\t\tsum = sum.add((mod10).multiply(insideBrackets));\r\n+\t\t\t\tnumber = number.divide(BigInteger.TEN);\r\n+\t\t\t}\r\n+\t\t\tSystem.out.println(sum);\r\n+\t\t}\r\n+\t\tinput.close();\r\n+\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic long nextLong() throws IOException {\r\n+\t\treturn parseLong(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve SkewBinary"
  },
  {
    "input": "diff --git a/UVa/Parity.java b/UVa/Parity.java\n--- a/UVa/Parity.java\n+++ b/UVa/Parity.java\n@@ -22,19 +22,9 @@\n  * The parity of 10101 is 3 (mod 2).\r\n  */\r\n \r\n-\r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1872\r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class Parity {\r\n \r",
    "output": "Remove unused import"
  },
  {
    "input": "diff --git a/UVa/Parity.java b/UVa/Parity.java\n--- a/UVa/Parity.java\n+++ b/UVa/Parity.java\n@@ -22,6 +22,9 @@\n  * The parity of 10101 is 3 (mod 2).\r\n  */\r\n \r\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1872\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL for Parity"
  },
  {
    "input": "diff --git a/UVa/Parity.java b/UVa/Parity.java\n--- a/UVa/Parity.java\n+++ b/UVa/Parity.java\n@@ -6,13 +6,15 @@\n import java.io.InputStreamReader;\r\n import java.io.OutputStreamWriter;\r\n import java.io.PrintWriter;\r\n+import java.util.Scanner;\r\n import java.util.StringTokenizer;\r\n \r\n public class Parity {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\twhile (true) {\r\n-\t\t\tint number = nextInt();\r\n+\t\t\tScanner input = new Scanner(System.in);\r\n+\t\t\tint number = input.nextInt();\r\n \t\t\tif (number == 0) {\r\n \t\t\t\tbreak;\r\n \t\t\t}\r\n@@ -29,40 +31,12 @@ static void solve() throws Exception {\n \t\t}\r\n \t}\r\n \r\n-\tstatic String convertToBinary(int number) {\r\n+\tprivate static String convertToBinary(int number) {\r\n \t\tStringBuilder s = new StringBuilder(\"\");\r\n \t\twhile (number != 0) {\r\n \t\t\ts = s.append(number % 2);\r\n \t\t\tnumber = number / 2;\r\n \t\t}\r\n \t\treturn s.reverse().toString();\r\n \t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor Parity"
  },
  {
    "input": "diff --git a/UVa/Parity.java b/UVa/Parity.java\n--- a/UVa/Parity.java\n+++ b/UVa/Parity.java\n@@ -0,0 +1,68 @@\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class Parity {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\twhile (true) {\r\n+\t\t\tint number = nextInt();\r\n+\t\t\tif (number == 0) {\r\n+\t\t\t\tbreak;\r\n+\t\t\t}\r\n+\t\t\tString binaryInString = convertToBinary(number);\r\n+\t\t\tint count = 0;\r\n+\t\t\tfor (int i = 0; i < binaryInString.length(); i++) {\r\n+\t\t\t\tif (\"1\".equals(binaryInString.charAt(i) + \"\")) {\r\n+\t\t\t\t\tcount++;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tSystem.out.println(\"The parity of \" + binaryInString + \" is \"\r\n+\t\t\t\t\t+ count + \" (mod 2).\");\r\n+\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic String convertToBinary(int number) {\r\n+\t\tStringBuilder s = new StringBuilder(\"\");\r\n+\t\twhile (number != 0) {\r\n+\t\t\ts = s.append(number % 2);\r\n+\t\t\tnumber = number / 2;\r\n+\t\t}\r\n+\t\treturn s.reverse().toString();\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve Parity"
  },
  {
    "input": "diff --git a/UVa/SolveEquation.java b/UVa/SolveEquation.java\n--- a/UVa/SolveEquation.java\n+++ b/UVa/SolveEquation.java\n@@ -0,0 +1,74 @@\n+\r\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class SolveEquation {\r\n+\r\n+    static void solve() throws Exception {\r\n+\r\n+\tint numberOfTestCases = nextInt();\r\n+\twhile (numberOfTestCases != 0) {\r\n+\r\n+\t    int A = nextInt();\r\n+\t    int B = nextInt();\r\n+\t    int C = nextInt();\r\n+\t    boolean hasSolution = false;\r\n+\r\n+\t    for (int x = -22; x <= 22 && !hasSolution; x++) {\r\n+\t\tif (x * x <= C) {\r\n+\t\t    for (int y = -100; y <= 100 && !hasSolution; y++) {\r\n+\t\t\tif (x!= y && y * y <= C && (x * x + y * y <= C)) {\r\n+\t\t\t    int z = A - x - y;\r\n+\t\t\t    if ((z != y && z != x && x * x + y * y + z * z == C) && x * y * z == B) {\r\n+\t\t\t\thasSolution = true;\r\n+\t\t\t\tSystem.out.println(x + \" \" + y + \" \" + z);\r\n+\t\t\t    }\r\n+\t\t\t}\r\n+\t\t    }\r\n+\t\t}\r\n+\t    }\r\n+\t    if (!hasSolution) {\r\n+\t\tSystem.out.println(\"No solution.\");\r\n+\t    }\r\n+\r\n+\t    numberOfTestCases--;\r\n+\t}\r\n+\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t    solve();\r\n+\t    in.close();\r\n+\t    out.close();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve SolveEquation"
  },
  {
    "input": "diff --git a/UVa/LargestPrimeDivisor.java b/UVa/LargestPrimeDivisor.java\n--- a/UVa/LargestPrimeDivisor.java\n+++ b/UVa/LargestPrimeDivisor.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2461\r\n+\r\n import java.util.Scanner;\r\n \r\n public class LargestPrimeDivisor {\r",
    "output": "Add problem source URL for LargestPrimeDivisor"
  },
  {
    "input": "diff --git a/UVa/LargestPrimeDivisor.java b/UVa/LargestPrimeDivisor.java\n--- a/UVa/LargestPrimeDivisor.java\n+++ b/UVa/LargestPrimeDivisor.java\n@@ -1,19 +1,10 @@\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.Long.parseLong;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class LargestPrimeDivisor {\r\n \r\n-\tstatic void solve() throws Exception {\r\n-\t\tlong number = nextLong();\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tlong number = input.nextLong();\r\n \t\twhile (number != 0) {\r\n \t\t\tnumber = (long) (Math.abs(number));\r\n \t\t\tlong largestPrimeDivisor = -1;\r\n@@ -35,39 +26,7 @@ static void solve() throws Exception {\n \t\t\t} else {\r\n \t\t\t\tSystem.out.println(largestPrimeDivisor);\r\n \t\t\t}\r\n-\t\t\tnumber = nextLong();\r\n+\t\t\tnumber = input.nextLong();\r\n \t\t}\r\n \t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic long nextLong() throws IOException {\r\n-\t\treturn parseLong(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor LargestPrimeDivisor"
  },
  {
    "input": "diff --git a/UVa/LargestPrimeDivisor.java b/UVa/LargestPrimeDivisor.java\n--- a/UVa/LargestPrimeDivisor.java\n+++ b/UVa/LargestPrimeDivisor.java\n@@ -0,0 +1,73 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.Long.parseLong;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class LargestPrimeDivisor {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tlong number = nextLong();\r\n+\t\twhile (number != 0) {\r\n+\t\t\tnumber = (long) (Math.abs(number));\r\n+\t\t\tlong largestPrimeDivisor = -1;\r\n+\t\t\tint numberOfPrimeDivisors = 0;\r\n+\t\t\tint sqrtOfNumber = (int) (Math.sqrt(number));\r\n+\t\t\tfor (int i = 2; i <= sqrtOfNumber; i++) {\r\n+\t\t\t\tif (number % i == 0) {\r\n+\t\t\t\t\tnumberOfPrimeDivisors++;\r\n+\t\t\t\t\tlargestPrimeDivisor = i;\r\n+\t\t\t\t\twhile (number % i == 0) {\r\n+\t\t\t\t\t\tnumber = number / i;\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tif (largestPrimeDivisor != -1 && number != 1) {\r\n+\t\t\t\tSystem.out.println(number);\r\n+\t\t\t} else if (numberOfPrimeDivisors <= 1) {\r\n+\t\t\t\tSystem.out.println(-1);\r\n+\t\t\t} else {\r\n+\t\t\t\tSystem.out.println(largestPrimeDivisor);\r\n+\t\t\t}\r\n+\t\t\tnumber = nextLong();\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic long nextLong() throws IOException {\r\n+\t\treturn parseLong(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve LargestPrimeDivisor"
  },
  {
    "input": "diff --git a/UVa/GoldbachConjecture.java b/UVa/GoldbachConjecture.java\n--- a/UVa/GoldbachConjecture.java\n+++ b/UVa/GoldbachConjecture.java\n@@ -7,7 +7,7 @@ public class GoldbachConjecture {\n \r\n \tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n-\t\tboolean[] isPrime = generatePrimeNumbers(1000000);\r\n+\t\tboolean[] isPrime = sieveOfEratosthenes(1000000);\r\n \t\tint number = input.nextInt();\r\n \t\twhile (number != 0) {\r\n \t\t\tboolean found = false;\r\n@@ -29,7 +29,7 @@ public static void main(String[] args) {\n \t\t}\r\n \t}\r\n \r\n-\tstatic boolean[] generatePrimeNumbers(int number) {\r\n+\tstatic boolean[] sieveOfEratosthenes(int number) {\r\n \t\tboolean[] isPrime = new boolean[number + 1];\r\n \t\tfor (int i = 2; i < number + 1; i++) {\r\n \t\t\tisPrime[i] = true;\r",
    "output": "Rename method for generating prime numbers to sieveOfEratosthenes"
  },
  {
    "input": "diff --git a/UVa/GoldbachConjecture.java b/UVa/GoldbachConjecture.java\n--- a/UVa/GoldbachConjecture.java\n+++ b/UVa/GoldbachConjecture.java\n@@ -1,20 +1,14 @@\n \r\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=484\r\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class GoldbachConjecture {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n \t\tboolean[] isPrime = generatePrimeNumbers(1000000);\r\n-\t\tint number = nextInt();\r\n+\t\tint number = input.nextInt();\r\n \t\twhile (number != 0) {\r\n \t\t\tboolean found = false;\r\n \t\t\tfor (int i = 3; i < number && !found; i++) {\r\n@@ -31,7 +25,7 @@ static void solve() throws Exception {\n \t\t\tif (!found) {\r\n \t\t\t\tSystem.out.println(\"Goldbach's conjecture is wrong.\");\r\n \t\t\t}\r\n-\t\t\tnumber = nextInt();\r\n+\t\t\tnumber = input.nextInt();\r\n \t\t}\r\n \t}\r\n \r\n@@ -50,32 +44,4 @@ static boolean[] generatePrimeNumbers(int number) {\n \t\t}\r\n \t\treturn isPrime;\r\n \t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor GoldbachConjecture"
  },
  {
    "input": "diff --git a/UVa/GoldbachConjecture.java b/UVa/GoldbachConjecture.java\n--- a/UVa/GoldbachConjecture.java\n+++ b/UVa/GoldbachConjecture.java\n@@ -1,4 +1,6 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=484\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n import java.io.BufferedReader;\r",
    "output": "Add problem source URL for GoldbachConjecture"
  },
  {
    "input": "diff --git a/UVa/GoldbachConjecture.java b/UVa/GoldbachConjecture.java\n--- a/UVa/GoldbachConjecture.java\n+++ b/UVa/GoldbachConjecture.java\n@@ -0,0 +1,79 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class GoldbachConjecture {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tboolean[] isPrime = generatePrimeNumbers(1000000);\r\n+\t\tint number = nextInt();\r\n+\t\twhile (number != 0) {\r\n+\t\t\tboolean found = false;\r\n+\t\t\tfor (int i = 3; i < number && !found; i++) {\r\n+\t\t\t\tif (isPrime[i]) {\r\n+\t\t\t\t\tint currentPrime = i;\r\n+\t\t\t\t\tint j = number - currentPrime;\r\n+\t\t\t\t\tif (isPrime[j]) {\r\n+\t\t\t\t\t\tSystem.out.println(number + \" = \" + currentPrime\r\n+\t\t\t\t\t\t\t\t+ \" + \" + j);\r\n+\t\t\t\t\t\tfound = true;\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tif (!found) {\r\n+\t\t\t\tSystem.out.println(\"Goldbach's conjecture is wrong.\");\r\n+\t\t\t}\r\n+\t\t\tnumber = nextInt();\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic boolean[] generatePrimeNumbers(int number) {\r\n+\t\tboolean[] isPrime = new boolean[number + 1];\r\n+\t\tfor (int i = 2; i < number + 1; i++) {\r\n+\t\t\tisPrime[i] = true;\r\n+\t\t}\r\n+\r\n+\t\tfor (int factor = 2; factor * factor <= number; factor++) {\r\n+\t\t\tif (isPrime[factor]) {\r\n+\t\t\t\tfor (int j = factor; factor * j <= number; j++) {\r\n+\t\t\t\t\tisPrime[factor * j] = false;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn isPrime;\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve GoldbachConjecture"
  },
  {
    "input": "diff --git a/UVa/MischievousChildren.java b/UVa/MischievousChildren.java\n--- a/UVa/MischievousChildren.java\n+++ b/UVa/MischievousChildren.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=1279\r\n+\r\n import java.util.HashMap;\r\n import java.util.Map;\r\n import java.util.Scanner;\r",
    "output": "Add problem source URL for MischeviousChildren"
  },
  {
    "input": "diff --git a/UVa/MischievousChildren.java b/UVa/MischievousChildren.java\n--- a/UVa/MischievousChildren.java\n+++ b/UVa/MischievousChildren.java\n@@ -1,23 +1,15 @@\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.util.HashMap;\r\n import java.util.Map;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class MischievousChildren {\r\n \r\n-\tstatic void solve() throws Exception {\r\n-\t\tint numberOfCases = nextInt();\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tint numberOfCases = input.nextInt();\r\n \t\tint currentCase = 1;\r\n \t\twhile (numberOfCases != 0) {\r\n-\t\t\tString line = next();\r\n+\t\t\tString line = input.next();\r\n \t\t\tint numberOfLetters = line.length();\r\n \t\t\tMap<Character, Integer> letterCounter = new HashMap<Character, Integer>();\r\n \r\n@@ -52,39 +44,12 @@ static void solve() throws Exception {\n \t\t}\r\n \t}\r\n \r\n-\tstatic long computeFactorial(int number) {\r\n+\tprivate static long computeFactorial(int number) {\r\n \t\tlong product = 1;\r\n \t\tfor (int i = 2; i < number + 1; i++) {\r\n \t\t\tproduct = product * i;\r\n \t\t}\r\n \t\treturn product;\r\n \t}\r\n \r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor MischievousChildren"
  },
  {
    "input": "diff --git a/UVa/MischievousChildren.java b/UVa/MischievousChildren.java\n--- a/UVa/MischievousChildren.java\n+++ b/UVa/MischievousChildren.java\n@@ -0,0 +1,90 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class MischievousChildren {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tint numberOfCases = nextInt();\r\n+\t\tint currentCase = 1;\r\n+\t\twhile (numberOfCases != 0) {\r\n+\t\t\tString line = next();\r\n+\t\t\tint numberOfLetters = line.length();\r\n+\t\t\tMap<Character, Integer> letterCounter = new HashMap<Character, Integer>();\r\n+\r\n+\t\t\tfor (int i = 0; i < numberOfLetters; i++) {\r\n+\t\t\t\tchar c = line.charAt(i);\r\n+\t\t\t\tif (letterCounter.containsKey(c)) {\r\n+\t\t\t\t\tint previousOccurrences = letterCounter.get(c);\r\n+\t\t\t\t\tletterCounter.replace(c, previousOccurrences + 1);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tletterCounter.put(c, 1);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tString lineWithoutDuplicates = \"\";\r\n+\t\t\tfor (int i = 0; i < numberOfLetters; i++) {\r\n+\t\t\t\tchar c = line.charAt(i);\r\n+\t\t\t\tif (!lineWithoutDuplicates.contains(c + \"\")) {\r\n+\t\t\t\t\tlineWithoutDuplicates = lineWithoutDuplicates + c;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tlong nFactorial = computeFactorial(numberOfLetters);\r\n+\t\t\tfor (int i = 0; i < letterCounter.size(); i++) {\r\n+\t\t\t\tchar c = lineWithoutDuplicates.charAt(i);\r\n+\t\t\t\tint numberOfOccurrences = letterCounter.get(c);\r\n+\t\t\t\tif (numberOfOccurrences != 1) {\r\n+\t\t\t\t\tlong currentProduct = computeFactorial(numberOfOccurrences);\r\n+\t\t\t\t\tnFactorial = nFactorial / currentProduct;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tSystem.out.println(\"Data set \" + currentCase + \": \" + nFactorial);\r\n+\t\t\tcurrentCase++;\r\n+\t\t\tnumberOfCases--;\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic long computeFactorial(int number) {\r\n+\t\tlong product = 1;\r\n+\t\tfor (int i = 2; i < number + 1; i++) {\r\n+\t\t\tproduct = product * i;\r\n+\t\t}\r\n+\t\treturn product;\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve MischievousChildren"
  },
  {
    "input": "diff --git a/UVa/FiveHundredFactorial.java b/UVa/FiveHundredFactorial.java\n--- a/UVa/FiveHundredFactorial.java\n+++ b/UVa/FiveHundredFactorial.java\n@@ -1,4 +1,3 @@\n-\r\n /**\r\n  * In these days you can more and more often happen to see programs which perform some useful calculations\r\n  * being executed rather then trivial screen savers. Some of them check the system message queue\r\n@@ -38,16 +37,8 @@\n  */\r\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=564\r\n \r\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class FiveHundredFactorial {\r\n \r\n@@ -63,28 +54,4 @@ public static void main(String[] args) {\n \t\t}\r\n \t\tinput.close();\r\n \t}\r\n-\r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tsolve();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor FiveHundredFactorial"
  },
  {
    "input": "diff --git a/UVa/FiveHundredFactorial.java b/UVa/FiveHundredFactorial.java\n--- a/UVa/FiveHundredFactorial.java\n+++ b/UVa/FiveHundredFactorial.java\n@@ -1,4 +1,7 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=564\r\n+\r\n+\r\n import static java.lang.Integer.parseInt;\r\n import static java.lang.System.exit;\r\n \r",
    "output": "Add problem source URL at FiveHundredFactorial"
  },
  {
    "input": "diff --git a/UVa/FiveHundredFactorial.java b/UVa/FiveHundredFactorial.java\n--- a/UVa/FiveHundredFactorial.java\n+++ b/UVa/FiveHundredFactorial.java\n@@ -11,7 +11,7 @@\n \r\n public class FiveHundredFactorial {\r\n \r\n-\tstatic void solve() throws Exception {\r\n+\tpublic static void main(String[] args) {\r\n \t\tScanner input = new Scanner(System.in);\r\n \t\twhile (input.hasNext()) {\r\n \t\t\tint number = input.nextInt();\r",
    "output": "Refactor FiveHundredFactorial"
  },
  {
    "input": "diff --git a/UVa/FiveHundredFactorial.java b/UVa/FiveHundredFactorial.java\n--- a/UVa/FiveHundredFactorial.java\n+++ b/UVa/FiveHundredFactorial.java\n@@ -0,0 +1,50 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class FiveHundredFactorial {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\twhile (input.hasNext()) {\r\n+\t\t\tint number = input.nextInt();\r\n+\t\t\tBigInteger product = BigInteger.ONE;\r\n+\t\t\tfor (int i = 2; i < number + 1; i++) {\r\n+\t\t\t\tproduct = product.multiply(BigInteger.valueOf(i));\r\n+\t\t\t}\r\n+\t\t\tSystem.out.println(number + \"!\\n\" + product);\r\n+\t\t}\r\n+\t\tinput.close();\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tsolve();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve FiveHundredFactorial"
  },
  {
    "input": "diff --git a/UVa/TheHugeOne.java b/UVa/TheHugeOne.java\n--- a/UVa/TheHugeOne.java\n+++ b/UVa/TheHugeOne.java\n@@ -1,4 +1,6 @@\n \r\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2319\r\n+\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL at TheHugeOne"
  },
  {
    "input": "diff --git a/UVa/FactorialFrequenices.java b/UVa/FactorialFrequenices.java\n--- a/UVa/FactorialFrequenices.java\n+++ b/UVa/FactorialFrequenices.java\n@@ -1,3 +1,6 @@\n+\r\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=260\r\n+\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL for FactorialFrequencies"
  },
  {
    "input": "diff --git a/UVa/FactorialFrequenices.java b/UVa/FactorialFrequenices.java\n--- a/UVa/FactorialFrequenices.java\n+++ b/UVa/FactorialFrequenices.java\n@@ -1,18 +1,11 @@\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n-import java.util.StringTokenizer;\r\n+import java.util.Scanner;\r\n \r\n public class FactorialFrequenices {\r\n \r\n-\tstatic void solve() throws Exception {\r\n-\t\tint number = nextInt();\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tint number = input.nextInt();\r\n \t\twhile (number != 0) {\r\n \t\t\tBigInteger product = BigInteger.ONE;\r\n \t\t\tfor (int i = 2; i < number + 1; i++) {\r\n@@ -27,11 +20,11 @@ static void solve() throws Exception {\n \t\t\t\tproductValue = productValue.divide(BigInteger.TEN);\r\n \t\t\t}\r\n \t\t\tformatOutput(number, digitCounter);\r\n-\t\t\tnumber = nextInt();\r\n+\t\t\tnumber = input.nextInt();\r\n \t\t}\r\n \t}\r\n \r\n-\tstatic void formatOutput(int number, int[] digits) {\r\n+\tprivate static void formatOutput(int number, int[] digits) {\r\n \t\tSystem.out.println(number + \"! --\");\r\n \t\tfor (int i = 0; i < 10; i++) {\r\n \t\t\tif (i != 0 || i != 9 || i != 4)\r\n@@ -42,31 +35,4 @@ static void formatOutput(int number, int[] digits) {\n \t\t}\r\n \t}\r\n \r\n-\tstatic int nextInt() throws IOException {\r\n-\t\treturn parseInt(next());\r\n-\t}\r\n-\r\n-\tstatic String next() throws IOException {\r\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t\t\ttok = new StringTokenizer(in.readLine());\r\n-\t\t}\r\n-\t\treturn tok.nextToken();\r\n-\t}\r\n-\r\n-\tpublic static void main(String[] args) {\r\n-\t\ttry {\r\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t\t\tsolve();\r\n-\t\t\tin.close();\r\n-\t\t\tout.close();\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\texit(0);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic BufferedReader in;\r\n-\tstatic PrintWriter out;\r\n-\tstatic StringTokenizer tok;\r\n }\r",
    "output": "Refactor FactorialFrequencies"
  },
  {
    "input": "diff --git a/UVa/FactorialFrequenices.java b/UVa/FactorialFrequenices.java\n--- a/UVa/FactorialFrequenices.java\n+++ b/UVa/FactorialFrequenices.java\n@@ -0,0 +1,72 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class FactorialFrequenices {\r\n+\r\n+\tstatic void solve() throws Exception {\r\n+\t\tint number = nextInt();\r\n+\t\twhile (number != 0) {\r\n+\t\t\tBigInteger product = BigInteger.ONE;\r\n+\t\t\tfor (int i = 2; i < number + 1; i++) {\r\n+\t\t\t\tproduct = product.multiply(BigInteger.valueOf(i));\r\n+\t\t\t}\r\n+\t\t\tint[] digitCounter = new int[10];\r\n+\t\t\tBigInteger productValue = product;\r\n+\t\t\twhile (!productValue.equals(BigInteger.ZERO)) {\r\n+\r\n+\t\t\t\tdigitCounter[Integer.valueOf(productValue.mod(BigInteger.TEN)\r\n+\t\t\t\t\t\t.toString())]++;\r\n+\t\t\t\tproductValue = productValue.divide(BigInteger.TEN);\r\n+\t\t\t}\r\n+\t\t\tformatOutput(number, digitCounter);\r\n+\t\t\tnumber = nextInt();\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic void formatOutput(int number, int[] digits) {\r\n+\t\tSystem.out.println(number + \"! --\");\r\n+\t\tfor (int i = 0; i < 10; i++) {\r\n+\t\t\tif (i != 0 || i != 9 || i != 4)\r\n+\t\t\t\tSystem.out.printf(\"   \");\r\n+\t\t\tSystem.out.printf(\"(%d)%5d\", i, digits[i]);\r\n+\t\t\tif (i == 4 || i == 9)\r\n+\t\t\t\tSystem.out.printf(\"\\n\");\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic int nextInt() throws IOException {\r\n+\t\treturn parseInt(next());\r\n+\t}\r\n+\r\n+\tstatic String next() throws IOException {\r\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t\t\ttok = new StringTokenizer(in.readLine());\r\n+\t\t}\r\n+\t\treturn tok.nextToken();\r\n+\t}\r\n+\r\n+\tpublic static void main(String[] args) {\r\n+\t\ttry {\r\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\r\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t\t\tsolve();\r\n+\t\t\tin.close();\r\n+\t\t\tout.close();\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t\texit(0);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic BufferedReader in;\r\n+\tstatic PrintWriter out;\r\n+\tstatic StringTokenizer tok;\r\n+}\r",
    "output": "Solve FactorialFrequencies"
  },
  {
    "input": "diff --git a/UVa/TheHugeOne.java b/UVa/TheHugeOne.java\n--- a/UVa/TheHugeOne.java\n+++ b/UVa/TheHugeOne.java\n@@ -1,61 +1,29 @@\n \r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.PrintWriter;\r\n import java.math.BigInteger;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class TheHugeOne {\r\n \r\n-    static void solve() throws Exception {\r\n-\tScanner input = new Scanner(System.in);\r\n-\tint numberOfTestCases = input.nextInt();\r\n-\twhile (numberOfTestCases != 0) {\r\n-\t    BigInteger M = input.nextBigInteger();\r\n-\t    input.nextLine();\r\n-\t    String[] elementsLine = input.nextLine().split(\" \");\r\n-\t    boolean found = false;\r\n-\t    for (int i = 1; i < elementsLine.length; i++) {\r\n-\t\tBigInteger number = new BigInteger(elementsLine[i]);\r\n-\t\tif (!M.mod(number).equals(BigInteger.ZERO)) {\r\n-\t\t    System.out.println(M + \" - Simple.\");\r\n-\t\t    found = true;\r\n-\t\t    break;\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\tint numberOfTestCases = input.nextInt();\r\n+\t\twhile (numberOfTestCases != 0) {\r\n+\t\t\tBigInteger M = input.nextBigInteger();\r\n+\t\t\tinput.nextLine();\r\n+\t\t\tString[] elementsLine = input.nextLine().split(\" \");\r\n+\t\t\tboolean found = false;\r\n+\t\t\tfor (int i = 1; i < elementsLine.length; i++) {\r\n+\t\t\t\tBigInteger number = new BigInteger(elementsLine[i]);\r\n+\t\t\t\tif (!M.mod(number).equals(BigInteger.ZERO)) {\r\n+\t\t\t\t\tSystem.out.println(M + \" - Simple.\");\r\n+\t\t\t\t\tfound = true;\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tif (!found) {\r\n+\t\t\t\tSystem.out.println(M + \" - Wonderful.\");\r\n+\t\t\t}\r\n+\t\t\tnumberOfTestCases--;\r\n \t\t}\r\n-\t    }\r\n-\t    if (!found) {\r\n-\t\tSystem.out.println(M + \" - Wonderful.\");\r\n-\t    }\r\n-\t    numberOfTestCases--;\r\n-\t}\r\n-\tinput.close();\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n-\r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n \t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    solve();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n-\t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r",
    "output": "Refactor TheHugeOne"
  },
  {
    "input": "diff --git a/UVa/TheHugeOne.java b/UVa/TheHugeOne.java\n--- a/UVa/TheHugeOne.java\n+++ b/UVa/TheHugeOne.java\n@@ -0,0 +1,61 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.PrintWriter;\r\n+import java.math.BigInteger;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class TheHugeOne {\r\n+\r\n+    static void solve() throws Exception {\r\n+\tScanner input = new Scanner(System.in);\r\n+\tint numberOfTestCases = input.nextInt();\r\n+\twhile (numberOfTestCases != 0) {\r\n+\t    BigInteger M = input.nextBigInteger();\r\n+\t    input.nextLine();\r\n+\t    String[] elementsLine = input.nextLine().split(\" \");\r\n+\t    boolean found = false;\r\n+\t    for (int i = 1; i < elementsLine.length; i++) {\r\n+\t\tBigInteger number = new BigInteger(elementsLine[i]);\r\n+\t\tif (!M.mod(number).equals(BigInteger.ZERO)) {\r\n+\t\t    System.out.println(M + \" - Simple.\");\r\n+\t\t    found = true;\r\n+\t\t    break;\r\n+\t\t}\r\n+\t    }\r\n+\t    if (!found) {\r\n+\t\tSystem.out.println(M + \" - Wonderful.\");\r\n+\t    }\r\n+\t    numberOfTestCases--;\r\n+\t}\r\n+\tinput.close();\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    solve();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve TheHugeOne"
  },
  {
    "input": "diff --git a/UVa/NumberTheoryForNewbies.java b/UVa/NumberTheoryForNewbies.java\n--- a/UVa/NumberTheoryForNewbies.java\n+++ b/UVa/NumberTheoryForNewbies.java\n@@ -1,3 +1,7 @@\n+\r\n+\r\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=&problem=2366\r\n+\r\n import java.util.Arrays;\r\n import java.util.Scanner;\r\n \r",
    "output": "Add problem source URL for NumberTheoryForNewbies"
  },
  {
    "input": "diff --git a/UVa/NumberTheoryForNewbies.java b/UVa/NumberTheoryForNewbies.java\n--- a/UVa/NumberTheoryForNewbies.java\n+++ b/UVa/NumberTheoryForNewbies.java\n@@ -1,82 +1,39 @@\n-\r\n-import static java.lang.Integer.parseInt;\r\n-import static java.lang.Long.parseLong;\r\n-import static java.lang.System.exit;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.IOException;\r\n-import java.io.InputStreamReader;\r\n-import java.io.OutputStreamWriter;\r\n-import java.io.PrintWriter;\r\n import java.util.Arrays;\r\n import java.util.Scanner;\r\n-import java.util.StringTokenizer;\r\n \r\n public class NumberTheoryForNewbies {\r\n \r\n-    static void solve() throws Exception {\r\n-\tScanner input = new Scanner(System.in);\r\n-\twhile (input.hasNextLong()) {\r\n-\t    String inputValue = input.nextLine();\r\n-\t    StringBuilder minimal = new StringBuilder();\r\n-\t    StringBuilder maximal = new StringBuilder();\r\n-\t    char[] characters = inputValue.toCharArray();\r\n-\t    int length = characters.length;\r\n-\t    Arrays.sort(characters);\r\n-\t    int index;\r\n-\t    for (index = 0; index < length; index++) {\r\n-\t\tif (characters[index] != '0') {\r\n-\t\t    break;\r\n+\tpublic static void main(String[] args) {\r\n+\t\tScanner input = new Scanner(System.in);\r\n+\t\twhile (input.hasNextLong()) {\r\n+\t\t\tString inputValue = input.nextLine();\r\n+\t\t\tStringBuilder minimal = new StringBuilder();\r\n+\t\t\tStringBuilder maximal = new StringBuilder();\r\n+\t\t\tchar[] characters = inputValue.toCharArray();\r\n+\t\t\tint length = characters.length;\r\n+\t\t\tArrays.sort(characters);\r\n+\t\t\tint index;\r\n+\t\t\tfor (index = 0; index < length; index++) {\r\n+\t\t\t\tif (characters[index] != '0') {\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\tif (index != 0) {\r\n+\t\t\t\tcharacters[0] = characters[index];\r\n+\t\t\t\tcharacters[index] = '0';\r\n+\t\t\t}\r\n+\t\t\tfor (int i = 0; i < length; i++) {\r\n+\t\t\t\tminimal.append(characters[i]);\r\n+\t\t\t}\r\n+\t\t\tArrays.sort(characters);\r\n+\t\t\tfor (int i = length - 1; i > -1; i--) {\r\n+\t\t\t\tmaximal.append(characters[i]);\r\n+\t\t\t}\r\n+\t\t\tlong maximalNumber = Long.valueOf(maximal.toString());\r\n+\t\t\tlong minimalNumber = Long.valueOf(minimal.toString());\r\n+\t\t\tlong difference = maximalNumber - minimalNumber;\r\n+\t\t\tSystem.out.println(maximal + \" - \" + minimal + \" = \" + difference\r\n+\t\t\t\t\t+ \" = 9 * \" + (difference / 9));\r\n \t\t}\r\n-\t    }\r\n-\t    if (index != 0) {\r\n-\t\tcharacters[0] = characters[index];\r\n-\t\tcharacters[index] = '0';\r\n-\t    }\r\n-\t    for (int i = 0; i < length; i++) {\r\n-\t\tminimal.append(characters[i]);\r\n-\t    }\r\n-\t    Arrays.sort(characters);\r\n-\t    for (int i = length - 1; i > -1; i--) {\r\n-\t\tmaximal.append(characters[i]);\r\n-\t    }\r\n-\t    long maximalNumber = Long.valueOf(maximal.toString());\r\n-\t    long minimalNumber = Long.valueOf(minimal.toString());\r\n-\t    long difference = maximalNumber - minimalNumber;\r\n-\t    System.out.println(maximal + \" - \" + minimal + \" = \" + difference + \" = 9 * \" + (difference / 9));\r\n \t}\r\n-\tinput.close();\r\n-    }\r\n-\r\n-    static int nextInt() throws IOException {\r\n-\treturn parseInt(next());\r\n-    }\r\n-\r\n-    static long nextLong() throws IOException {\r\n-\treturn parseLong(next());\r\n-    }\r\n-\r\n-    static String next() throws IOException {\r\n-\twhile (tok == null || !tok.hasMoreTokens()) {\r\n-\t    tok = new StringTokenizer(in.readLine());\r\n-\t}\r\n-\treturn tok.nextToken();\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-\ttry {\r\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n-\t    solve();\r\n-\t    in.close();\r\n-\t    out.close();\r\n-\t} catch (Throwable e) {\r\n-\t    e.printStackTrace();\r\n-\t    exit(0);\r\n-\t}\r\n-    }\r\n-\r\n-    static BufferedReader in;\r\n-    static PrintWriter out;\r\n-    static StringTokenizer tok;\r\n }\r",
    "output": "Refactor NumberTheoryForNewbies"
  },
  {
    "input": "diff --git a/UVa/NumberTheoryForNewbies.java b/UVa/NumberTheoryForNewbies.java\n--- a/UVa/NumberTheoryForNewbies.java\n+++ b/UVa/NumberTheoryForNewbies.java\n@@ -0,0 +1,82 @@\n+\r\n+import static java.lang.Integer.parseInt;\r\n+import static java.lang.Long.parseLong;\r\n+import static java.lang.System.exit;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.io.OutputStreamWriter;\r\n+import java.io.PrintWriter;\r\n+import java.util.Arrays;\r\n+import java.util.Scanner;\r\n+import java.util.StringTokenizer;\r\n+\r\n+public class NumberTheoryForNewbies {\r\n+\r\n+    static void solve() throws Exception {\r\n+\tScanner input = new Scanner(System.in);\r\n+\twhile (input.hasNextLong()) {\r\n+\t    String inputValue = input.nextLine();\r\n+\t    StringBuilder minimal = new StringBuilder();\r\n+\t    StringBuilder maximal = new StringBuilder();\r\n+\t    char[] characters = inputValue.toCharArray();\r\n+\t    int length = characters.length;\r\n+\t    Arrays.sort(characters);\r\n+\t    int index;\r\n+\t    for (index = 0; index < length; index++) {\r\n+\t\tif (characters[index] != '0') {\r\n+\t\t    break;\r\n+\t\t}\r\n+\t    }\r\n+\t    if (index != 0) {\r\n+\t\tcharacters[0] = characters[index];\r\n+\t\tcharacters[index] = '0';\r\n+\t    }\r\n+\t    for (int i = 0; i < length; i++) {\r\n+\t\tminimal.append(characters[i]);\r\n+\t    }\r\n+\t    Arrays.sort(characters);\r\n+\t    for (int i = length - 1; i > -1; i--) {\r\n+\t\tmaximal.append(characters[i]);\r\n+\t    }\r\n+\t    long maximalNumber = Long.valueOf(maximal.toString());\r\n+\t    long minimalNumber = Long.valueOf(minimal.toString());\r\n+\t    long difference = maximalNumber - minimalNumber;\r\n+\t    System.out.println(maximal + \" - \" + minimal + \" = \" + difference + \" = 9 * \" + (difference / 9));\r\n+\t}\r\n+\tinput.close();\r\n+    }\r\n+\r\n+    static int nextInt() throws IOException {\r\n+\treturn parseInt(next());\r\n+    }\r\n+\r\n+    static long nextLong() throws IOException {\r\n+\treturn parseLong(next());\r\n+    }\r\n+\r\n+    static String next() throws IOException {\r\n+\twhile (tok == null || !tok.hasMoreTokens()) {\r\n+\t    tok = new StringTokenizer(in.readLine());\r\n+\t}\r\n+\treturn tok.nextToken();\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+\ttry {\r\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\r\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\r\n+\t    solve();\r\n+\t    in.close();\r\n+\t    out.close();\r\n+\t} catch (Throwable e) {\r\n+\t    e.printStackTrace();\r\n+\t    exit(0);\r\n+\t}\r\n+    }\r\n+\r\n+    static BufferedReader in;\r\n+    static PrintWriter out;\r\n+    static StringTokenizer tok;\r\n+}\r",
    "output": "Solve NumberTheoryForNewbies"
  },
  {
    "input": "diff --git a/UVa/LightMoreLight.java b/UVa/LightMoreLight.java\n--- a/UVa/LightMoreLight.java\n+++ b/UVa/LightMoreLight.java\n@@ -1,62 +1,23 @@\n-import static java.lang.Integer.parseInt;\n-import static java.lang.Long.parseLong;\n-import static java.lang.System.exit;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n-import java.io.PrintWriter;\n-import java.util.StringTokenizer;\n+import java.util.Scanner;\n \n public class LightMoreLight {\n \n-\tstatic void solve() throws Exception {\n-\t\tlong number = nextLong();\n+\tpublic static void main(String[] args) {\n+\t\tScanner input = new Scanner(System.in);\n+\t\tlong number = input.nextLong();\n \t\twhile (number != 0) {\n \t\t\tif (isAPerfectSquare(number)) {\n \t\t\t\tSystem.out.println(\"yes\");\n \t\t\t} else {\n \t\t\t\tSystem.out.println(\"no\");\n \t\t\t}\n-\t\t\tnumber = nextLong();\n+\t\t\tnumber = input.nextLong();\n \t\t}\n \t}\n \n-\tstatic boolean isAPerfectSquare(long number) {\n+\tprivate static boolean isAPerfectSquare(long number) {\n \t\tlong squareRoot = (long) Math.sqrt(number);\n \t\treturn squareRoot * squareRoot == number;\n \t}\n \n-\tstatic int nextInt() throws IOException {\n-\t\treturn parseInt(next());\n-\t}\n-\n-\tstatic long nextLong() throws IOException {\n-\t\treturn parseLong(next());\n-\t}\n-\n-\tstatic String next() throws IOException {\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\n-\t\t\ttok = new StringTokenizer(in.readLine());\n-\t\t}\n-\t\treturn tok.nextToken();\n-\t}\n-\n-\tpublic static void main(String[] args) {\n-\t\ttry {\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n-\t\t\tsolve();\n-\t\t\tin.close();\n-\t\t\tout.close();\n-\t\t} catch (Throwable e) {\n-\t\t\te.printStackTrace();\n-\t\t\texit(0);\n-\t\t}\n-\t}\n-\n-\tstatic BufferedReader in;\n-\tstatic PrintWriter out;\n-\tstatic StringTokenizer tok;\n }",
    "output": "Refactor LightMoreLight"
  },
  {
    "input": "diff --git a/UVa/LightMoreLight.java b/UVa/LightMoreLight.java\n--- a/UVa/LightMoreLight.java\n+++ b/UVa/LightMoreLight.java\n@@ -0,0 +1,62 @@\n+import static java.lang.Integer.parseInt;\n+import static java.lang.Long.parseLong;\n+import static java.lang.System.exit;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.util.StringTokenizer;\n+\n+public class LightMoreLight {\n+\n+\tstatic void solve() throws Exception {\n+\t\tlong number = nextLong();\n+\t\twhile (number != 0) {\n+\t\t\tif (isAPerfectSquare(number)) {\n+\t\t\t\tSystem.out.println(\"yes\");\n+\t\t\t} else {\n+\t\t\t\tSystem.out.println(\"no\");\n+\t\t\t}\n+\t\t\tnumber = nextLong();\n+\t\t}\n+\t}\n+\n+\tstatic boolean isAPerfectSquare(long number) {\n+\t\tlong squareRoot = (long) Math.sqrt(number);\n+\t\treturn squareRoot * squareRoot == number;\n+\t}\n+\n+\tstatic int nextInt() throws IOException {\n+\t\treturn parseInt(next());\n+\t}\n+\n+\tstatic long nextLong() throws IOException {\n+\t\treturn parseLong(next());\n+\t}\n+\n+\tstatic String next() throws IOException {\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\n+\t\t\ttok = new StringTokenizer(in.readLine());\n+\t\t}\n+\t\treturn tok.nextToken();\n+\t}\n+\n+\tpublic static void main(String[] args) {\n+\t\ttry {\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n+\t\t\tsolve();\n+\t\t\tin.close();\n+\t\t\tout.close();\n+\t\t} catch (Throwable e) {\n+\t\t\te.printStackTrace();\n+\t\t\texit(0);\n+\t\t}\n+\t}\n+\n+\tstatic BufferedReader in;\n+\tstatic PrintWriter out;\n+\tstatic StringTokenizer tok;\n+}",
    "output": "Solve LightMoreLight"
  },
  {
    "input": "diff --git a/UVa/TheLastNonZeroDigit.java b/UVa/TheLastNonZeroDigit.java\n--- a/UVa/TheLastNonZeroDigit.java\n+++ b/UVa/TheLastNonZeroDigit.java\n@@ -28,7 +28,7 @@\n \n import java.util.Scanner;\n \n-public class LastNonZeroDigit {\n+public class TheLastNonZeroDigit {\n \n \tpublic static void main(String[] args) {\n \t\tScanner input = new Scanner(System.in);",
    "output": "Rename LastNonZeroDigit to TheLastNonZeroDigit"
  },
  {
    "input": "diff --git a/UVa/PrimeFactors.java b/UVa/PrimeFactors.java\n--- a/UVa/PrimeFactors.java\n+++ b/UVa/PrimeFactors.java\n@@ -62,20 +62,20 @@ public class PrimeFactors {\n \tpublic static void main(String[] args) {\n \t\tScanner input = new Scanner(System.in);\n \t\tint number = input.nextInt();\n+\t\tboolean[] isPrime = generatePrimeNumbers();\n \t\twhile (number != 0) {\n \t\t\tboolean isNegative = false;\n \t\t\tif (number < 0) {\n \t\t\t\tisNegative = true;\n \t\t\t\tnumber = Math.abs(number);\n \t\t\t}\n \t\t\tint originalNumber = number;\n-\t\t\tformatOutput(originalNumber, sieveOfEratosthenes(originalNumber), isNegative);\n+\t\t\tformatOutput(originalNumber, sieveOfEratosthenes(isPrime, originalNumber), isNegative);\n \t\t\tnumber = input.nextInt();\n \t\t}\n \t}\n \n-\tpublic static List<Integer> sieveOfEratosthenes(int number) {\n-\t\tboolean[] isPrime = generatePrimeNumbers();\n+\tpublic static List<Integer> sieveOfEratosthenes(boolean[] isPrime, int number) {\n \t\tList<Integer> primeFactors = new ArrayList<Integer>();\n \t\tint squareRootOfOriginalNumber = (int) Math.sqrt(number);\n \t\tfor (int i = 2; i <= squareRootOfOriginalNumber; i++) {",
    "output": "Optimize PrimeFactors"
  },
  {
    "input": "diff --git a/UVa/PrimeFactors.java b/UVa/PrimeFactors.java\n--- a/UVa/PrimeFactors.java\n+++ b/UVa/PrimeFactors.java\n@@ -69,7 +69,7 @@ public static void main(String[] args) {\n \t\t\t\tnumber = Math.abs(number);\n \t\t\t}\n \t\t\tint originalNumber = number;\n-\t\t\tformatOutput(originalNumber, getPrimeFactors(originalNumber), isNegative);\n+\t\t\tformatOutput(originalNumber, sieveOfEratosthenes(originalNumber), isNegative);\n \t\t\tnumber = input.nextInt();\n \t\t}\n \t}",
    "output": "Rename method from generatePrimeFactors to sieveOfEratosthenes"
  },
  {
    "input": "diff --git a/UVa/PrimeFactors.java b/UVa/PrimeFactors.java\n--- a/UVa/PrimeFactors.java\n+++ b/UVa/PrimeFactors.java\n@@ -74,7 +74,7 @@ public static void main(String[] args) {\n \t\t}\n \t}\n \n-\tpublic static List<Integer> getPrimeFactors(int number) {\n+\tpublic static List<Integer> sieveOfEratosthenes(int number) {\n \t\tboolean[] isPrime = generatePrimeNumbers();\n \t\tList<Integer> primeFactors = new ArrayList<Integer>();\n \t\tint squareRootOfOriginalNumber = (int) Math.sqrt(number);",
    "output": "Rename method from generatePrimeFactors to sieveOfEratosthenes"
  },
  {
    "input": "diff --git a/UVa/LastNonZeroDigit.java b/UVa/LastNonZeroDigit.java\n--- a/UVa/LastNonZeroDigit.java\n+++ b/UVa/LastNonZeroDigit.java\n@@ -26,8 +26,6 @@\n \n //https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1153\n \n-import static java.lang.System.exit;\n-\n import java.util.Scanner;\n \n public class LastNonZeroDigit {",
    "output": "Remove unused import"
  },
  {
    "input": "diff --git a/UVa/JollyJumpers.java b/UVa/JollyJumpers.java\n--- a/UVa/JollyJumpers.java\n+++ b/UVa/JollyJumpers.java\n@@ -20,6 +20,11 @@\n \n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=979\n \n+import java.util.HashSet;\n+import java.util.Scanner;\n+import java.util.Set;\n+\n+\n public class JollyJumpers {\n \n \tpublic static void main(String[] args) {",
    "output": "Add missing imports at JollyJumpers"
  },
  {
    "input": "diff --git a/UVa/JollyJumper.java b/UVa/JollyJumper.java\n--- a/UVa/JollyJumper.java\n+++ b/UVa/JollyJumper.java\n@@ -20,7 +20,7 @@\n \n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=979\n \n-public class JollyJumper {\n+public class JollyJumpers {\n \n \tpublic static void main(String[] args) {\n \t\tScanner input = new Scanner(System.in);",
    "output": "Rename JollyJumper to JollyJumpers"
  },
  {
    "input": "diff --git a/UVa/BasicRemains.java b/UVa/BasicRemains.java\n--- a/UVa/BasicRemains.java\n+++ b/UVa/BasicRemains.java\n@@ -21,6 +21,9 @@\n *10\n *789\n  */\n+\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1492\n+\n import java.math.BigInteger;\n import java.util.Scanner;\n \n\ndiff --git a/UVa/JollyJumper.java b/UVa/JollyJumper.java\n--- a/UVa/JollyJumper.java\n+++ b/UVa/JollyJumper.java\n@@ -16,6 +16,7 @@\n *Jolly\n *Not jolly\n */\n+\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=979\n \n public class JollyJumper {\n\ndiff --git a/UVa/LastNonZeroDigit.java b/UVa/LastNonZeroDigit.java\n--- a/UVa/LastNonZeroDigit.java\n+++ b/UVa/LastNonZeroDigit.java\n@@ -23,7 +23,9 @@\n *4\n *2\n */\n+\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1153\n+\n import static java.lang.System.exit;\n \n import java.util.Scanner;\n\ndiff --git a/UVa/Newspaper.java b/UVa/Newspaper.java\n--- a/UVa/Newspaper.java\n+++ b/UVa/Newspaper.java\n@@ -34,6 +34,7 @@\n *Sample Output\n *3.74$\n */\n+\n //https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2315\n \n import java.text.DecimalFormat;",
    "output": "Add problem URL at BasicRemains"
  },
  {
    "input": "diff --git a/UVa/PrimeFactors.java b/UVa/PrimeFactors.java\n--- a/UVa/PrimeFactors.java\n+++ b/UVa/PrimeFactors.java\n@@ -49,7 +49,6 @@ greater than unity (with fi ≤ fj for i < j), the format of the output line sho\n 200 = 2 x 2 x 2 x 5 x 5*/\n \n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=524\n-package UVa;\n \n import java.util.ArrayList;\n import java.util.Collections;",
    "output": "Remove package declaration at PrimeFactors"
  },
  {
    "input": "diff --git a/Company/Airbnb/validParentheses.java b/Company/Airbnb/validParentheses.java\n--- a/Company/Airbnb/validParentheses.java\n+++ b/Company/Airbnb/validParentheses.java\n@@ -22,19 +22,19 @@ public boolean isValid(String s) {\n                 \n             }\n             \n-            else if(s.charAt(i) == ')' && !stack.isEmpty() && stack.peek() == ')') {\n+            else if(s.charAt(i) == ')' && !stack.isEmpty() && stack.peek() == '(') {\n                 \n                 stack.pop();\n                 \n             }\n             \n-            else if(s.charAt(i) == ']' && !stack.isEmpty() && stack.peek() == ']') {\n+            else if(s.charAt(i) == ']' && !stack.isEmpty() && stack.peek() == '[') {\n                 \n                 stack.pop();\n                 \n             }\n             \n-            else if(s.charAt(i) == '}' && !stack.isEmpty() && stack.peek() == '}') {\n+            else if(s.charAt(i) == '}' && !stack.isEmpty() && stack.peek() == '{') {\n                 \n                 stack.pop();\n                 \n@@ -52,4 +52,4 @@ else if(s.charAt(i) == '}' && !stack.isEmpty() && stack.peek() == '}') {\n         \n     }\n \n-}\n\\ No newline at end of file\n+}",
    "output": "Merge pull request #31 from doshprompt/valid-parentheses\n\nUpdate validParentheses.java"
  },
  {
    "input": "diff --git a/Company/Airbnb/validParentheses.java b/Company/Airbnb/validParentheses.java\n--- a/Company/Airbnb/validParentheses.java\n+++ b/Company/Airbnb/validParentheses.java\n@@ -22,19 +22,19 @@ public boolean isValid(String s) {\n                 \n             }\n             \n-            else if(s.charAt(i) == ')' && !stack.isEmpty() && stack.peek() == ')') {\n+            else if(s.charAt(i) == ')' && !stack.isEmpty() && stack.peek() == '(') {\n                 \n                 stack.pop();\n                 \n             }\n             \n-            else if(s.charAt(i) == ']' && !stack.isEmpty() && stack.peek() == ']') {\n+            else if(s.charAt(i) == ']' && !stack.isEmpty() && stack.peek() == '[') {\n                 \n                 stack.pop();\n                 \n             }\n             \n-            else if(s.charAt(i) == '}' && !stack.isEmpty() && stack.peek() == '}') {\n+            else if(s.charAt(i) == '}' && !stack.isEmpty() && stack.peek() == '{') {\n                 \n                 stack.pop();\n                 \n@@ -52,4 +52,4 @@ else if(s.charAt(i) == '}' && !stack.isEmpty() && stack.peek() == '}') {\n         \n     }\n \n-}\n\\ No newline at end of file\n+}",
    "output": "Update validParentheses.java\n\nfix code logic error leading to incorrect solution:\r\n\r\ntop of stack should be an opening parenthesis if current character is a closing parenthesis for string to be valid"
  },
  {
    "input": "diff --git a/UVa/PrimeFactors.java b/UVa/PrimeFactors.java\n--- a/UVa/PrimeFactors.java\n+++ b/UVa/PrimeFactors.java\n@@ -93,7 +93,7 @@ public static List<Integer> getPrimeFactors(int number) {\n \n \tstatic void formatOutput(int number, List<Integer> primeFactors, boolean isNegative) {\n \t\tif (isNegative) {\n-\t\t\tnumber = number * (-1);\n+\t\t\tnumber *= -1;\n \t\t}\n \t\tStringBuilder output = new StringBuilder(number + \" = \");\n \t\tint numberOfPrimeFactors = primeFactors.size();",
    "output": "Turn number = number * (-1) into short form"
  },
  {
    "input": "diff --git a/UVa/PrimeFactors.java b/UVa/PrimeFactors.java\n--- a/UVa/PrimeFactors.java\n+++ b/UVa/PrimeFactors.java\n@@ -65,7 +65,7 @@ public static void main(String[] args) {\n \t\t\tboolean isNegative = false;\n \t\t\tif (number < 0) {\n \t\t\t\tisNegative = true;\n-\t\t\t\tnumber = (int) Math.abs(number);\n+\t\t\t\tnumber = Math.abs(number);\n \t\t\t}\n \t\t\tint originalNumber = number;\n \t\t\tformatOutput(originalNumber, getPrimeFactors(originalNumber), isNegative);",
    "output": "Do not cast Math.abs into int"
  },
  {
    "input": "diff --git a/UVa/JollyJumper.java b/UVa/JollyJumper.java\n--- a/UVa/JollyJumper.java\n+++ b/UVa/JollyJumper.java\n@@ -42,14 +42,4 @@ public static void main(String[] args) {\n \t\t}\n \t}\n \n-\tpublic static int findMaximalElement(int[] numbers) {\n-\t\tint max = numbers[0];\n-\t\tfor (int i = 1; i < numbers.length; i++) {\n-\t\t\tif (max < numbers[i]) {\n-\t\t\t\tmax = numbers[i];\n-\t\t\t}\n-\t\t}\n-\t\treturn max;\n-\t}\n-\n }\n\\ No newline at end of file",
    "output": "remove unused method at JollyJumper"
  },
  {
    "input": "diff --git a/UVa/Newspaper.java b/UVa/Newspaper.java\n--- a/UVa/Newspaper.java\n+++ b/UVa/Newspaper.java\n@@ -33,7 +33,6 @@ ACM International Collegiate Programming Contest (abbreviated\n Sample Output\n 3.74$*/\n \n-package UVa;\n \n import java.text.DecimalFormat;\n import java.util.HashMap;",
    "output": "Remove package declaration"
  },
  {
    "input": "diff --git a/UVa/JollyJumper.java b/UVa/JollyJumper.java\n--- a/UVa/JollyJumper.java\n+++ b/UVa/JollyJumper.java\n@@ -17,19 +17,6 @@\n Not jolly*/\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=979\n \n-import static java.lang.Integer.parseInt;\n-import static java.lang.System.exit;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n-import java.io.PrintWriter;\n-import java.util.HashSet;\n-import java.util.Scanner;\n-import java.util.Set;\n-import java.util.StringTokenizer;\n-\n public class JollyJumper {\n \n \tpublic static void main(String[] args) {",
    "output": "Remove unused libraries at JollyJumper"
  },
  {
    "input": "diff --git a/UVa/BasicRemains.java b/UVa/BasicRemains.java\n--- a/UVa/BasicRemains.java\n+++ b/UVa/BasicRemains.java\n@@ -21,15 +21,8 @@\n 10\n 789\n  */\n-import static java.lang.Integer.parseInt;\n-import static java.lang.System.exit;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n import java.math.BigInteger;\n import java.util.Scanner;\n-import java.util.StringTokenizer;\n \n public class BasicRemains {\n \n@@ -44,8 +37,5 @@ public static void main(String[] args) {\n \t\t\tBigInteger m = new BigInteger(input.next(), baseNumber);\n \t\t\tSystem.out.println((p.mod(m)).toString(baseNumber));\n \t\t}\n-\t\t\n-\t\tinput.close();\n-\t\t}\n \t}\n }\n\\ No newline at end of file",
    "output": "Remove unused libraries at BasicRemains"
  },
  {
    "input": "diff --git a/UVa/PrimeFactors.java b/UVa/PrimeFactors.java\n--- a/UVa/PrimeFactors.java\n+++ b/UVa/PrimeFactors.java\n@@ -1,10 +1,4 @@\n-/*Webster defines prime as:\n-prime (pr¯im) n. [ME, fr. MF, fem. of prin first, L primus; akin to L prior] 1: first in\n-time: original 2 a: having no factor except itself and one ⟨3 is a ∼ number⟩ b : having\n-no common factor except one ⟨12 and 25 are relatively ∼⟩ 3 a: first in rank, authority or\n-significance: principal b: having the highest quality or value ⟨∼ television time ⟩ [from\n-Webster’s New Collegiate Dictionary]\n-The most relevant definition for this problem is 2a: An integer g > 1 is said to be prime if and only\n+/*The most relevant definition for this problem is 2a: An integer g > 1 is said to be prime if and only\n if its only positive divisors are itself and one (otherwise it is said to be composite). For example, the\n number 21 is composite; the number 23 is prime. Note that the decompositon of a positive number g\n into its prime factors, i.e.,\n@@ -53,118 +47,89 @@ greater than unity (with fi ≤ fj for i < j), the format of the output line sho\n 198 = 2 x 3 x 3 x 11\n 199 = 199\n 200 = 2 x 2 x 2 x 5 x 5*/\n-import static java.lang.Integer.parseInt;\n-import static java.lang.System.exit;\n \n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n-import java.io.PrintWriter;\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=524\n+package UVa;\n+\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n-import java.util.StringTokenizer;\n-\n+import java.util.Scanner;\n \n public class PrimeFactors {\n \n-    static void solve() throws Exception {\n-\tint number = nextInt();\n-\tboolean[] isPrime = generatePrimeNumbers();\n-\twhile (number != 0) {\n-\t    boolean isNegative = false;\n-\t    if (number < 0) {\n-\t\tisNegative = true;\n-\t\tnumber = (int) Math.abs(number);\n-\t    }\n-\t    int originalNumber = number;\n-\t    List<Integer> primeFactors = new ArrayList<Integer>();\n-\t    int squareRootOfOriginalNumber = (int) Math.sqrt(originalNumber);\n-\t    for (int i = 2; i <= squareRootOfOriginalNumber; i++) {\n-\t\tif (isPrime[i]) {\n-\t\t    while (number % i == 0) {\n-\t\t\tprimeFactors.add(i);\n-\t\t\tnumber = number / i;\n-\t\t    }\n+\tpublic static void main(String[] args) {\n+\t\tScanner input = new Scanner(System.in);\n+\t\tint number = input.nextInt();\n+\t\twhile (number != 0) {\n+\t\t\tboolean isNegative = false;\n+\t\t\tif (number < 0) {\n+\t\t\t\tisNegative = true;\n+\t\t\t\tnumber = (int) Math.abs(number);\n+\t\t\t}\n+\t\t\tint originalNumber = number;\n+\t\t\tformatOutput(originalNumber, getPrimeFactors(originalNumber), isNegative);\n+\t\t\tnumber = input.nextInt();\n \t\t}\n-\t    }\n-\t    if (number != 1) {\n-\t\tprimeFactors.add(number);\n-\t    }\n-\t    formatOutput(originalNumber, primeFactors, isNegative);\n-\t    number = nextInt();\n-\n-\t}\n-\n-    }\n-\n-    static void formatOutput(int number, List<Integer> primeFactors, boolean isNegative) {\n-\tif (isNegative) {\n-\t    number = number * (-1);\n-\t}\n-\tStringBuilder output = new StringBuilder(number + \" = \");\n-\tint numberOfPrimeFactors = primeFactors.size();\n-\tif (numberOfPrimeFactors == 1) {\n-\t    if (isNegative) {\n-\t\toutput.append(\"-1 x \" + (number * (-1)));\n-\t    } else {\n-\t\toutput.append(number);\n-\t    }\n-\t} else {\n-\t    Collections.sort(primeFactors);\n-\t    if (isNegative) {\n-\t\toutput.append(\"-1 x \");\n-\t    }\n-\t    for (int i = 0; i < numberOfPrimeFactors - 1; i++) {\n-\t\toutput.append(primeFactors.get(i) + \" x \");\n-\t    }\n-\t    output.append(primeFactors.get(numberOfPrimeFactors - 1));\n \t}\n-\tSystem.out.println(output);\n-    }\n \n-    static boolean[] generatePrimeNumbers() {\n-\tint number = (int) Math.sqrt(Integer.MAX_VALUE);\n-\tboolean[] isPrime = new boolean[number + 1];\n-\tfor (int i = 2; i < number + 1; i++) {\n-\t    isPrime[i] = true;\n-\t}\n-\tfor (int factor = 2; factor * factor < number + 1; factor++) {\n-\t    if (isPrime[factor]) {\n-\t\tfor (int j = factor; j * factor < number + 1; j++) {\n-\t\t    isPrime[j * factor] = false;\n+\tpublic static List<Integer> getPrimeFactors(int number) {\n+\t\tboolean[] isPrime = generatePrimeNumbers();\n+\t\tList<Integer> primeFactors = new ArrayList<Integer>();\n+\t\tint squareRootOfOriginalNumber = (int) Math.sqrt(number);\n+\t\tfor (int i = 2; i <= squareRootOfOriginalNumber; i++) {\n+\t\t\tif (isPrime[i]) {\n+\t\t\t\twhile (number % i == 0) {\n+\t\t\t\t\tprimeFactors.add(i);\n+\t\t\t\t\tnumber = number / i;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (number != 1) {\n+\t\t\tprimeFactors.add(number);\n \t\t}\n-\t    }\n+\t\treturn primeFactors;\n \t}\n-\treturn isPrime;\n-    }\n \n-    static int nextInt() throws IOException {\n-\treturn parseInt(next());\n-    }\n-\n-    static String next() throws IOException {\n-\twhile (tok == null || !tok.hasMoreTokens()) {\n-\t    tok = new StringTokenizer(in.readLine());\n+\tstatic void formatOutput(int number, List<Integer> primeFactors, boolean isNegative) {\n+\t\tif (isNegative) {\n+\t\t\tnumber = number * (-1);\n+\t\t}\n+\t\tStringBuilder output = new StringBuilder(number + \" = \");\n+\t\tint numberOfPrimeFactors = primeFactors.size();\n+\t\tif (numberOfPrimeFactors == 1) {\n+\t\t\tif (isNegative) {\n+\t\t\t\toutput.append(\"-1 x \" + (number * (-1)));\n+\t\t\t} else {\n+\t\t\t\toutput.append(number);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tCollections.sort(primeFactors);\n+\t\t\tif (isNegative) {\n+\t\t\t\toutput.append(\"-1 x \");\n+\t\t\t}\n+\t\t\tfor (int i = 0; i < numberOfPrimeFactors - 1; i++) {\n+\t\t\t\toutput.append(primeFactors.get(i) + \" x \");\n+\t\t\t}\n+\t\t\toutput.append(primeFactors.get(numberOfPrimeFactors - 1));\n+\t\t}\n+\t\tSystem.out.println(output);\n \t}\n-\treturn tok.nextToken();\n-    }\n \n-    public static void main(String[] args) {\n-\ttry {\n-\t    in = new BufferedReader(new InputStreamReader(System.in));\n-\t    out = new PrintWriter(new OutputStreamWriter(System.out));\n-\t    solve();\n-\t    in.close();\n-\t    out.close();\n-\t} catch (Throwable e) {\n-\t    e.printStackTrace();\n-\t    exit(0);\n+\tstatic boolean[] generatePrimeNumbers() {\n+\t\tint number = (int) Math.sqrt(Integer.MAX_VALUE);\n+\t\tboolean[] isPrime = new boolean[number + 1];\n+\t\tfor (int i = 2; i < number + 1; i++) {\n+\t\t\tisPrime[i] = true;\n+\t\t}\n+\t\tfor (int factor = 2; factor * factor < number + 1; factor++) {\n+\t\t\tif (isPrime[factor]) {\n+\t\t\t\tfor (int j = factor; j * factor < number + 1; j++) {\n+\t\t\t\t\tisPrime[j * factor] = false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn isPrime;\n \t}\n-    }\n \n-    static BufferedReader in;\n-    static PrintWriter out;\n-    static StringTokenizer tok;\n }\n\\ No newline at end of file",
    "output": "Refactor PrimeFactors"
  },
  {
    "input": "diff --git a/UVa/Newspaper.java b/UVa/Newspaper.java\n--- a/UVa/Newspaper.java\n+++ b/UVa/Newspaper.java\n@@ -35,14 +35,14 @@ ACM International Collegiate Programming Contest (abbreviated\n \n package UVa;\n \n-import java.io.BufferedReader;\n-import java.io.PrintWriter;\n import java.text.DecimalFormat;\n+import java.util.HashMap;\n+import java.util.Map;\n import java.util.Scanner;\n \n public class Newspaper {\n \n-\tstatic void solve() throws Exception {\n+\tpublic static void main(String[] args) {\n \t\tScanner input = new Scanner(System.in);\n \t\tint numberOfTestCases = input.nextInt();\n \t\twhile (numberOfTestCases != 0) {\n@@ -71,34 +71,6 @@ static void solve() throws Exception {\n \t\t\tSystem.out.println(sumFormatted + \"$\");\n \t\t\tnumberOfTestCases--;\n \t\t}\n-\t\tinput.close();\n-\t}\n-\n-\tstatic int nextInt() throws IOException {\n-\t\treturn parseInt(next());\n-\t}\n-\n-\tstatic String next() throws IOException {\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\n-\t\t\ttok = new StringTokenizer(in.readLine());\n-\t\t}\n-\t\treturn tok.nextToken();\n-\t}\n-\n-\tpublic static void main(String[] args) {\n-\t\ttry {\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n-\t\t\tsolve();\n-\t\t\tin.close();\n-\t\t\tout.close();\n-\t\t} catch (Throwable e) {\n-\t\t\te.printStackTrace();\n-\t\t\texit(0);\n-\t\t}\n \t}\n \n-\tstatic BufferedReader in;\n-\tstatic PrintWriter out;\n-\tstatic StringTokenizer tok;\n }\n\\ No newline at end of file",
    "output": "Refactor Newspaper"
  },
  {
    "input": "diff --git a/UVa/LastNonZeroDigit.java b/UVa/LastNonZeroDigit.java\n--- a/UVa/LastNonZeroDigit.java\n+++ b/UVa/LastNonZeroDigit.java\n@@ -1,3 +1,4 @@\n+\n /**\n  * In this problem you will be given two decimal integer number N, M. You will have to find the last\n non-zero digit of the P\n@@ -28,38 +29,28 @@\n \n public class LastNonZeroDigit {\n \n-    static void solve() throws Exception {\n-\tScanner input = new Scanner(System.in);\n-\twhile (input.hasNext()) {\n-\t    long n = input.nextInt();\n-\t    long m = input.nextInt();\n-\t    long product = 1;\n-\t    for (long i = (n - m + 1); i < n + 1; i++) {\n-\t\tproduct = product * i;\n-\t\twhile (product % 10 == 0) {\n-\t\t    product = product / 10;\n-\t\t}\n-\t\tproduct = product % (long) (Math.pow(10, 11));\n-\t    }\n-\t    String number = product + \"\";\n-\t    for (int i = number.length() - 1; i > -1; i--) {\n-\t\tchar c = number.charAt(i);\n-\t\tif (c != '0') {\n-\t\t    System.out.println(c);\n-\t\t    break;\n+\tpublic static void main(String[] args) {\n+\t\tScanner input = new Scanner(System.in);\n+\t\twhile (input.hasNext()) {\n+\t\t\tlong n = input.nextInt();\n+\t\t\tlong m = input.nextInt();\n+\t\t\tlong product = 1;\n+\t\t\tfor (long i = (n - m + 1); i < n + 1; i++) {\n+\t\t\t\tproduct = product * i;\n+\t\t\t\twhile (product % 10 == 0) {\n+\t\t\t\t\tproduct = product / 10;\n+\t\t\t\t}\n+\t\t\t\tproduct = product % (long) (Math.pow(10, 11));\n+\t\t\t}\n+\t\t\tString number = product + \"\";\n+\t\t\tfor (int i = number.length() - 1; i > -1; i--) {\n+\t\t\t\tchar c = number.charAt(i);\n+\t\t\t\tif (c != '0') {\n+\t\t\t\t\tSystem.out.println(c);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t    }\n-\t}\n-\tinput.close();\n-    }\n-\n-    public static void main(String[] args) {\n-\ttry {\n-\t    solve();\n-\t} catch (Throwable e) {\n-\t    e.printStackTrace();\n-\t    exit(0);\n \t}\n-    }\n \n }\n\\ No newline at end of file",
    "output": "Refactor LastNonZeroDigit"
  },
  {
    "input": "diff --git a/UVa/JollyJumper.java b/UVa/JollyJumper.java\n--- a/UVa/JollyJumper.java\n+++ b/UVa/JollyJumper.java\n@@ -1,3 +1,4 @@\n+\n /*A sequence of n > 0 integers is called a jolly jumper if the absolute values of the difference between\n successive elements take on all the values 1 through n − 1. For instance,\n 1 4 2 3\n@@ -16,7 +17,6 @@\n Not jolly*/\n //https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=979\n \n-\n import static java.lang.Integer.parseInt;\n import static java.lang.System.exit;\n \n@@ -32,7 +32,7 @@\n \n public class JollyJumper {\n \n-\tstatic void solve() throws Exception {\n+\tpublic static void main(String[] args) {\n \t\tScanner input = new Scanner(System.in);\n \t\twhile (input.hasNext()) {\n \t\t\tSet<Integer> numbersAlreadyAdded = new HashSet<Integer>();\n@@ -53,10 +53,9 @@ static void solve() throws Exception {\n \t\t\t\tSystem.out.println(\"Not jolly\");\n \t\t\t}\n \t\t}\n-\t\tinput.close();\n \t}\n \n-\tstatic int findMaximalElement(int[] numbers) {\n+\tpublic static int findMaximalElement(int[] numbers) {\n \t\tint max = numbers[0];\n \t\tfor (int i = 1; i < numbers.length; i++) {\n \t\t\tif (max < numbers[i]) {\n@@ -66,31 +65,4 @@ static int findMaximalElement(int[] numbers) {\n \t\treturn max;\n \t}\n \n-\tstatic int nextInt() throws IOException {\n-\t\treturn parseInt(next());\n-\t}\n-\n-\tstatic String next() throws IOException {\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\n-\t\t\ttok = new StringTokenizer(in.readLine());\n-\t\t}\n-\t\treturn tok.nextToken();\n-\t}\n-\n-\tpublic static void main(String[] args) {\n-\t\ttry {\n-\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n-\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n-\t\t\tsolve();\n-\t\t\tin.close();\n-\t\t\tout.close();\n-\t\t} catch (Throwable e) {\n-\t\t\te.printStackTrace();\n-\t\t\texit(0);\n-\t\t}\n-\t}\n-\n-\tstatic BufferedReader in;\n-\tstatic PrintWriter out;\n-\tstatic StringTokenizer tok;\n }\n\\ No newline at end of file",
    "output": "Remove unused methods from JollyJumper"
  },
  {
    "input": "diff --git a/UVa/BasicRemains.java b/UVa/BasicRemains.java\n--- a/UVa/BasicRemains.java\n+++ b/UVa/BasicRemains.java\n@@ -26,18 +26,15 @@\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.math.BigInteger;\n import java.util.Scanner;\n import java.util.StringTokenizer;\n \n public class BasicRemains {\n \n-\tstatic void solve() throws Exception {\n+\tpublic static void main(String[] args) {\n \t\tScanner input = new Scanner(System.in);\n-\n \t\twhile (input.hasNext()) {\n \t\t\tint baseNumber = input.nextInt();\n \t\t\tif (baseNumber == 0) {\n@@ -47,30 +44,8 @@ static void solve() throws Exception {\n \t\t\tBigInteger m = new BigInteger(input.next(), baseNumber);\n \t\t\tSystem.out.println((p.mod(m)).toString(baseNumber));\n \t\t}\n+\t\t\n \t\tinput.close();\n-\t}\n-\n-\tstatic int nextInt() throws IOException {\n-\t\treturn parseInt(next());\n-\t}\n-\n-\tstatic String next() throws IOException {\n-\t\twhile (tok == null || !tok.hasMoreTokens()) {\n-\t\t\ttok = new StringTokenizer(in.readLine());\n \t\t}\n-\t\treturn tok.nextToken();\n \t}\n-\n-\tpublic static void main(String[] args) {\n-\t\ttry {\n-\t\t\tsolve();\n-\t\t} catch (Throwable e) {\n-\t\t\te.printStackTrace();\n-\t\t\texit(0);\n-\t\t}\n-\t}\n-\n-\tstatic BufferedReader in;\n-\tstatic PrintWriter out;\n-\tstatic StringTokenizer tok;\n }\n\\ No newline at end of file",
    "output": "Remove unused methods from BasicRemains.java"
  },
  {
    "input": "diff --git a/UVa/LastNonZeroDigit.java b/UVa/LastNonZeroDigit.java\n--- a/UVa/LastNonZeroDigit.java\n+++ b/UVa/LastNonZeroDigit.java\n@@ -0,0 +1,65 @@\n+/**\n+ * In this problem you will be given two decimal integer number N, M. You will have to find the last\n+non-zero digit of the P\n+N\n+M . This means no of permutations of N things taking M at a time.\n+Input\n+The input file contains several lines of input. Each line of the input file contains two integers N\n+(0 ≤ N ≤ 20000000), M (0 ≤ M ≤ N). Input is terminated by end-of-file.\n+Output\n+For each line of the input file you should output a single digit, which is the last non-zero digit of P\n+N\n+M .\n+For example, if P\n+N\n+M is 720 then the last non-zero digit is 2. So in this case your output should be 2.\n+Sample Input\n+10 10\n+10 5\n+25 6\n+Sample Output\n+8\n+4\n+2\n+ */\n+import static java.lang.System.exit;\n+\n+import java.util.Scanner;\n+\n+public class LastNonZeroDigit {\n+\n+    static void solve() throws Exception {\n+\tScanner input = new Scanner(System.in);\n+\twhile (input.hasNext()) {\n+\t    long n = input.nextInt();\n+\t    long m = input.nextInt();\n+\t    long product = 1;\n+\t    for (long i = (n - m + 1); i < n + 1; i++) {\n+\t\tproduct = product * i;\n+\t\twhile (product % 10 == 0) {\n+\t\t    product = product / 10;\n+\t\t}\n+\t\tproduct = product % (long) (Math.pow(10, 11));\n+\t    }\n+\t    String number = product + \"\";\n+\t    for (int i = number.length() - 1; i > -1; i--) {\n+\t\tchar c = number.charAt(i);\n+\t\tif (c != '0') {\n+\t\t    System.out.println(c);\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t}\n+\tinput.close();\n+    }\n+\n+    public static void main(String[] args) {\n+\ttry {\n+\t    solve();\n+\t} catch (Throwable e) {\n+\t    e.printStackTrace();\n+\t    exit(0);\n+\t}\n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "Solve LastNonZeroDigit"
  },
  {
    "input": "diff --git a/UVa/BasicRemains.java b/UVa/BasicRemains.java\n--- a/UVa/BasicRemains.java\n+++ b/UVa/BasicRemains.java\n@@ -0,0 +1,76 @@\n+\n+/*\n+Given a base b and two non-negative base b integers\n+p and m, compute p mod m and print the\n+result as a base-b integer. p mod m is defined\n+as the smallest non-negative integer k such that\n+p = a ∗ m + k for some integer a.\n+Input\n+Input consists of a number of cases. Each case is\n+represented by a line containing three unsigned\n+integers. The first, b, is a decimal number between\n+2 and 10. The second, p, contains up to 1000 digits between 0 and b − 1. The third, m, contains\n+up to 9 digits between 0 and b − 1. The last case is followed by a line containing ‘0’.\n+Output\n+For each test case, print a line giving p mod m as a base-b integer.\n+Sample Input\n+2 1100 101\n+10 123456789123456789123456789 1000\n+0\n+Sample Output\n+10\n+789\n+ */\n+import static java.lang.Integer.parseInt;\n+import static java.lang.System.exit;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.math.BigInteger;\n+import java.util.Scanner;\n+import java.util.StringTokenizer;\n+\n+public class BasicRemains {\n+\n+\tstatic void solve() throws Exception {\n+\t\tScanner input = new Scanner(System.in);\n+\n+\t\twhile (input.hasNext()) {\n+\t\t\tint baseNumber = input.nextInt();\n+\t\t\tif (baseNumber == 0) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tBigInteger p = new BigInteger(input.next(), baseNumber);\n+\t\t\tBigInteger m = new BigInteger(input.next(), baseNumber);\n+\t\t\tSystem.out.println((p.mod(m)).toString(baseNumber));\n+\t\t}\n+\t\tinput.close();\n+\t}\n+\n+\tstatic int nextInt() throws IOException {\n+\t\treturn parseInt(next());\n+\t}\n+\n+\tstatic String next() throws IOException {\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\n+\t\t\ttok = new StringTokenizer(in.readLine());\n+\t\t}\n+\t\treturn tok.nextToken();\n+\t}\n+\n+\tpublic static void main(String[] args) {\n+\t\ttry {\n+\t\t\tsolve();\n+\t\t} catch (Throwable e) {\n+\t\t\te.printStackTrace();\n+\t\t\texit(0);\n+\t\t}\n+\t}\n+\n+\tstatic BufferedReader in;\n+\tstatic PrintWriter out;\n+\tstatic StringTokenizer tok;\n+}\n\\ No newline at end of file",
    "output": "Solve BasicRemains"
  },
  {
    "input": "diff --git a/UVa/PrimeFactors.java b/UVa/PrimeFactors.java\n--- a/UVa/PrimeFactors.java\n+++ b/UVa/PrimeFactors.java\n@@ -1,4 +1,58 @@\n-\n+/*Webster defines prime as:\n+prime (pr¯im) n. [ME, fr. MF, fem. of prin first, L primus; akin to L prior] 1: first in\n+time: original 2 a: having no factor except itself and one ⟨3 is a ∼ number⟩ b : having\n+no common factor except one ⟨12 and 25 are relatively ∼⟩ 3 a: first in rank, authority or\n+significance: principal b: having the highest quality or value ⟨∼ television time ⟩ [from\n+Webster’s New Collegiate Dictionary]\n+The most relevant definition for this problem is 2a: An integer g > 1 is said to be prime if and only\n+if its only positive divisors are itself and one (otherwise it is said to be composite). For example, the\n+number 21 is composite; the number 23 is prime. Note that the decompositon of a positive number g\n+into its prime factors, i.e.,\n+g = f1 × f2 × · · · × fn\n+is unique if we assert that fi > 1 for all i and fi ≤ fj for i < j.\n+One interesting class of prime numbers are the so-called Mersenne primes which are of the form\n+2\n+p − 1. Euler proved that 2\n+31 − 1 is prime in 1772 — all without the aid of a computer.\n+Input\n+The input will consist of a sequence of numbers. Each line of input will contain one number g in the\n+range −2\n+31 < g < 2\n+31, but different of -1 and 1. The end of input will be indicated by an input line\n+having a value of zero.\n+Output\n+For each line of input, your program should print a line of output consisting of the input number and\n+its prime factors. For an input number g > 0, g = f1 × f2 × · · · × fn, where each fi\n+is a prime number\n+greater than unity (with fi ≤ fj for i < j), the format of the output line should be\n+g = f1 x f2 x . . . x fn\n+When g < 0, if | g |= f1 × f2 × · · · × fn, the format of the output line should be\n+g = -1 x f1 x f2 x . . . x fn\n+Sample Input\n+-190\n+-191\n+-192\n+-193\n+-194\n+195\n+196\n+197\n+198\n+199\n+200\n+0\n+Sample Output\n+-190 = -1 x 2 x 5 x 19\n+-191 = -1 x 191\n+-192 = -1 x 2 x 2 x 2 x 2 x 2 x 2 x 3\n+-193 = -1 x 193\n+-194 = -1 x 2 x 97\n+195 = 3 x 5 x 13\n+196 = 2 x 2 x 7 x 7\n+197 = 197\n+198 = 2 x 3 x 3 x 11\n+199 = 199\n+200 = 2 x 2 x 2 x 5 x 5*/\n import static java.lang.Integer.parseInt;\n import static java.lang.System.exit;\n \n@@ -13,7 +67,6 @@\n import java.util.StringTokenizer;\n \n \n-//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=524\n public class PrimeFactors {\n \n     static void solve() throws Exception {",
    "output": "Add PrimeFactors probilem description"
  },
  {
    "input": "diff --git a/UVa/Newspaper.java b/UVa/Newspaper.java\n--- a/UVa/Newspaper.java\n+++ b/UVa/Newspaper.java\n@@ -32,21 +32,13 @@ ACM International Collegiate Programming Contest (abbreviated\n From Wikipedia.\n Sample Output\n 3.74$*/\n-//https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2315\n \n-import static java.lang.Integer.parseInt;\n-import static java.lang.System.exit;\n+package UVa;\n \n import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.OutputStreamWriter;\n import java.io.PrintWriter;\n import java.text.DecimalFormat;\n-import java.util.HashMap;\n-import java.util.Map;\n import java.util.Scanner;\n-import java.util.StringTokenizer;\n \n public class Newspaper {\n ",
    "output": "Add problem description"
  },
  {
    "input": "diff --git a/UVa/JollyJumper.java b/UVa/JollyJumper.java\n--- a/UVa/JollyJumper.java\n+++ b/UVa/JollyJumper.java\n@@ -1,3 +1,21 @@\n+/*A sequence of n > 0 integers is called a jolly jumper if the absolute values of the difference between\n+successive elements take on all the values 1 through n − 1. For instance,\n+1 4 2 3\n+is a jolly jumper, because the absolutes differences are 3, 2, and 1 respectively. The definition implies\n+that any sequence of a single integer is a jolly jumper. You are to write a program to determine whether\n+or not each of a number of sequences is a jolly jumper.\n+Input\n+Each line of input contains an integer n ≤ 3000 followed by n integers representing the sequence.\n+Output\n+For each line of input, generate a line of output saying ‘Jolly’ or ‘Not jolly’.\n+Sample Input\n+4 1 4 2 3\n+5 1 4 2 -1 6\n+Sample Output\n+Jolly\n+Not jolly*/\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=979\n+\n \n import static java.lang.Integer.parseInt;\n import static java.lang.System.exit;\n@@ -12,7 +30,6 @@\n import java.util.Set;\n import java.util.StringTokenizer;\n \n-//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=submit_problem&problemid=979&category=\n public class JollyJumper {\n \n \tstatic void solve() throws Exception {",
    "output": "JollyJumper"
  },
  {
    "input": "diff --git a/UVa/Newspaper.java b/UVa/Newspaper.java\n--- a/UVa/Newspaper.java\n+++ b/UVa/Newspaper.java\n@@ -1,3 +1,38 @@\n+/*News agency pays money for articles according to some rules. Each character has its own value (some\n+characters may have value equals to zero). Author gets his payment as a sum of all character’s values\n+in the article. You have to determine the amount of money that news agency must pay to an author.\n+Input\n+The first line contains integer N (0 < N ≤ 5), it is a number of tests. Each test describes an integer\n+K (0 < K ≤ 100), the number of paid characters. On next K lines there are table of paid characters\n+and its values (character values are written in cents). If character can not be found in the table, then\n+its value is equal to zero. Next, there is integer M (0 < M ≤ 150000). Next M lines contain an article\n+itself. Each line can be up to 10000 characters length. Be aware of a large input size, the whole input\n+file is about 7MB.\n+Output\n+For each test print how much money publisher must pay for an article in format ‘x.yy$’. Where x is\n+a number of dollars without leading zeros, and yy number of cents with one leading zero if necessary.\n+Examples: ‘3.32$’, ‘13.07$’, ‘71.30$’, ‘0.09$’.\n+Sample Input\n+1\n+7\n+a 3\n+W 10\n+A 100\n+, 10\n+k 7\n+. 3\n+I 13\n+7\n+ACM International Collegiate Programming Contest (abbreviated\n+as ACM-ICPC or just ICPC) is an annual multi-tiered competition\n+among the universities of the world. The ICPC challenges students\n+to set ever higher standards of excellence for themselves\n+through competition that rewards team work, problem analysis,\n+and rapid software development.\n+From Wikipedia.\n+Sample Output\n+3.74$*/\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2315\n \n import static java.lang.Integer.parseInt;\n import static java.lang.System.exit;\n@@ -13,7 +48,6 @@\n import java.util.Scanner;\n import java.util.StringTokenizer;\n \n-//https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2315\n public class Newspaper {\n \n \tstatic void solve() throws Exception {",
    "output": "Add Newspaper problem description as a comment"
  },
  {
    "input": "diff --git a/UVa/Newspaper.java b/UVa/Newspaper.java\n--- a/UVa/Newspaper.java\n+++ b/UVa/Newspaper.java\n@@ -0,0 +1,78 @@\n+\n+import static java.lang.Integer.parseInt;\n+import static java.lang.System.exit;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.text.DecimalFormat;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.StringTokenizer;\n+\n+//https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2315\n+public class Newspaper {\n+\n+\tstatic void solve() throws Exception {\n+\t\tScanner input = new Scanner(System.in);\n+\t\tint numberOfTestCases = input.nextInt();\n+\t\twhile (numberOfTestCases != 0) {\n+\t\t\tMap<String, Integer> values = new HashMap<String, Integer>();\n+\t\t\tint numberOfValuableCharacters = input.nextInt();\n+\t\t\twhile (numberOfValuableCharacters != 0) {\n+\t\t\t\tvalues.put(input.next(), input.nextInt());\n+\t\t\t\tnumberOfValuableCharacters--;\n+\t\t\t}\n+\t\t\tint numberOfLines = input.nextInt();\n+\t\t\tinput.nextLine();\n+\t\t\tdouble sum = 0;\n+\t\t\twhile (numberOfLines != 0) {\n+\t\t\t\tString textAsString = input.nextLine();\n+\t\t\t\tfor (int i = 0; i < textAsString.length(); i++) {\n+\t\t\t\t\tString c = textAsString.charAt(i) + \"\";\n+\t\t\t\t\tif (values.containsKey(c)) {\n+\t\t\t\t\t\tsum = sum + values.get(c);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tnumberOfLines--;\n+\t\t\t}\n+\t\t\tsum = sum / 100;\n+\t\t\tDecimalFormat formatter = new DecimalFormat(\"0.00\");\n+\t\t\tString sumFormatted = formatter.format(sum);\n+\t\t\tSystem.out.println(sumFormatted + \"$\");\n+\t\t\tnumberOfTestCases--;\n+\t\t}\n+\t\tinput.close();\n+\t}\n+\n+\tstatic int nextInt() throws IOException {\n+\t\treturn parseInt(next());\n+\t}\n+\n+\tstatic String next() throws IOException {\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\n+\t\t\ttok = new StringTokenizer(in.readLine());\n+\t\t}\n+\t\treturn tok.nextToken();\n+\t}\n+\n+\tpublic static void main(String[] args) {\n+\t\ttry {\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n+\t\t\tsolve();\n+\t\t\tin.close();\n+\t\t\tout.close();\n+\t\t} catch (Throwable e) {\n+\t\t\te.printStackTrace();\n+\t\t\texit(0);\n+\t\t}\n+\t}\n+\n+\tstatic BufferedReader in;\n+\tstatic PrintWriter out;\n+\tstatic StringTokenizer tok;\n+}\n\\ No newline at end of file",
    "output": "Solve Newspaper"
  },
  {
    "input": "diff --git a/UVa/JollyJumper.java b/UVa/JollyJumper.java\n--- a/UVa/JollyJumper.java\n+++ b/UVa/JollyJumper.java\n@@ -0,0 +1,79 @@\n+\n+import static java.lang.Integer.parseInt;\n+import static java.lang.System.exit;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.util.HashSet;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=submit_problem&problemid=979&category=\n+public class JollyJumper {\n+\n+\tstatic void solve() throws Exception {\n+\t\tScanner input = new Scanner(System.in);\n+\t\twhile (input.hasNext()) {\n+\t\t\tSet<Integer> numbersAlreadyAdded = new HashSet<Integer>();\n+\t\t\tint numberOfElements = input.nextInt();\n+\t\t\tint[] numbers = new int[numberOfElements];\n+\t\t\tfor (int i = 0; i < numberOfElements; i++) {\n+\t\t\t\tnumbers[i] = input.nextInt();\n+\t\t\t}\n+\t\t\tfor (int i = 0; i < numberOfElements - 1; i++) {\n+\t\t\t\tint difference = Math.abs(numbers[i] - numbers[i + 1]);\n+\t\t\t\tif (difference > 0 && difference < numberOfElements) {\n+\t\t\t\t\tnumbersAlreadyAdded.add(difference);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (numbersAlreadyAdded.size() == (numberOfElements - 1)) {\n+\t\t\t\tSystem.out.println(\"Jolly\");\n+\t\t\t} else {\n+\t\t\t\tSystem.out.println(\"Not jolly\");\n+\t\t\t}\n+\t\t}\n+\t\tinput.close();\n+\t}\n+\n+\tstatic int findMaximalElement(int[] numbers) {\n+\t\tint max = numbers[0];\n+\t\tfor (int i = 1; i < numbers.length; i++) {\n+\t\t\tif (max < numbers[i]) {\n+\t\t\t\tmax = numbers[i];\n+\t\t\t}\n+\t\t}\n+\t\treturn max;\n+\t}\n+\n+\tstatic int nextInt() throws IOException {\n+\t\treturn parseInt(next());\n+\t}\n+\n+\tstatic String next() throws IOException {\n+\t\twhile (tok == null || !tok.hasMoreTokens()) {\n+\t\t\ttok = new StringTokenizer(in.readLine());\n+\t\t}\n+\t\treturn tok.nextToken();\n+\t}\n+\n+\tpublic static void main(String[] args) {\n+\t\ttry {\n+\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n+\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n+\t\t\tsolve();\n+\t\t\tin.close();\n+\t\t\tout.close();\n+\t\t} catch (Throwable e) {\n+\t\t\te.printStackTrace();\n+\t\t\texit(0);\n+\t\t}\n+\t}\n+\n+\tstatic BufferedReader in;\n+\tstatic PrintWriter out;\n+\tstatic StringTokenizer tok;\n+}\n\\ No newline at end of file",
    "output": "Solve JollyJumper:"
  },
  {
    "input": "diff --git a/UVa/PrimeFactors.java b/UVa/PrimeFactors.java\n--- a/UVa/PrimeFactors.java\n+++ b/UVa/PrimeFactors.java\n@@ -0,0 +1,117 @@\n+\n+import static java.lang.Integer.parseInt;\n+import static java.lang.System.exit;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+\n+//https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=524\n+public class PrimeFactors {\n+\n+    static void solve() throws Exception {\n+\tint number = nextInt();\n+\tboolean[] isPrime = generatePrimeNumbers();\n+\twhile (number != 0) {\n+\t    boolean isNegative = false;\n+\t    if (number < 0) {\n+\t\tisNegative = true;\n+\t\tnumber = (int) Math.abs(number);\n+\t    }\n+\t    int originalNumber = number;\n+\t    List<Integer> primeFactors = new ArrayList<Integer>();\n+\t    int squareRootOfOriginalNumber = (int) Math.sqrt(originalNumber);\n+\t    for (int i = 2; i <= squareRootOfOriginalNumber; i++) {\n+\t\tif (isPrime[i]) {\n+\t\t    while (number % i == 0) {\n+\t\t\tprimeFactors.add(i);\n+\t\t\tnumber = number / i;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t    if (number != 1) {\n+\t\tprimeFactors.add(number);\n+\t    }\n+\t    formatOutput(originalNumber, primeFactors, isNegative);\n+\t    number = nextInt();\n+\n+\t}\n+\n+    }\n+\n+    static void formatOutput(int number, List<Integer> primeFactors, boolean isNegative) {\n+\tif (isNegative) {\n+\t    number = number * (-1);\n+\t}\n+\tStringBuilder output = new StringBuilder(number + \" = \");\n+\tint numberOfPrimeFactors = primeFactors.size();\n+\tif (numberOfPrimeFactors == 1) {\n+\t    if (isNegative) {\n+\t\toutput.append(\"-1 x \" + (number * (-1)));\n+\t    } else {\n+\t\toutput.append(number);\n+\t    }\n+\t} else {\n+\t    Collections.sort(primeFactors);\n+\t    if (isNegative) {\n+\t\toutput.append(\"-1 x \");\n+\t    }\n+\t    for (int i = 0; i < numberOfPrimeFactors - 1; i++) {\n+\t\toutput.append(primeFactors.get(i) + \" x \");\n+\t    }\n+\t    output.append(primeFactors.get(numberOfPrimeFactors - 1));\n+\t}\n+\tSystem.out.println(output);\n+    }\n+\n+    static boolean[] generatePrimeNumbers() {\n+\tint number = (int) Math.sqrt(Integer.MAX_VALUE);\n+\tboolean[] isPrime = new boolean[number + 1];\n+\tfor (int i = 2; i < number + 1; i++) {\n+\t    isPrime[i] = true;\n+\t}\n+\tfor (int factor = 2; factor * factor < number + 1; factor++) {\n+\t    if (isPrime[factor]) {\n+\t\tfor (int j = factor; j * factor < number + 1; j++) {\n+\t\t    isPrime[j * factor] = false;\n+\t\t}\n+\t    }\n+\t}\n+\treturn isPrime;\n+    }\n+\n+    static int nextInt() throws IOException {\n+\treturn parseInt(next());\n+    }\n+\n+    static String next() throws IOException {\n+\twhile (tok == null || !tok.hasMoreTokens()) {\n+\t    tok = new StringTokenizer(in.readLine());\n+\t}\n+\treturn tok.nextToken();\n+    }\n+\n+    public static void main(String[] args) {\n+\ttry {\n+\t    in = new BufferedReader(new InputStreamReader(System.in));\n+\t    out = new PrintWriter(new OutputStreamWriter(System.out));\n+\t    solve();\n+\t    in.close();\n+\t    out.close();\n+\t} catch (Throwable e) {\n+\t    e.printStackTrace();\n+\t    exit(0);\n+\t}\n+    }\n+\n+    static BufferedReader in;\n+    static PrintWriter out;\n+    static StringTokenizer tok;\n+}\n\\ No newline at end of file",
    "output": "Solve PrimeFactors"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter3StacksAndQueues/ThreeStacks.java b/CrackingTheCodingInterview/Chapter3StacksAndQueues/ThreeStacks.java\n--- a/CrackingTheCodingInterview/Chapter3StacksAndQueues/ThreeStacks.java\n+++ b/CrackingTheCodingInterview/Chapter3StacksAndQueues/ThreeStacks.java\n@@ -34,11 +34,11 @@ int peek(int stackNum) {\n \t}\n \n \tboolean isEmpty(int stackNum) {\n-\t\treturn stackPointer[sstackNum] == -1;\n+\t\treturn stackPointer[stackNum] == -1;\n \t}\n \n \t/* returns index of top of stack \"stackNum\", in absolute terms */\n \tint absTopOfStack(int stasckNum) {\n \t\treturn stackNum * stackSize + stackPointer[stackNum];\n \t}\n-}\n\\ No newline at end of file\n+}",
    "output": "Merge pull request #28 from rahulmaddineni/patch-1\n\nUpdate ThreeStacks - isEmpty function"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter3StacksAndQueues/ThreeStacks.java b/CrackingTheCodingInterview/Chapter3StacksAndQueues/ThreeStacks.java\n--- a/CrackingTheCodingInterview/Chapter3StacksAndQueues/ThreeStacks.java\n+++ b/CrackingTheCodingInterview/Chapter3StacksAndQueues/ThreeStacks.java\n@@ -34,11 +34,11 @@ int peek(int stackNum) {\n \t}\n \n \tboolean isEmpty(int stackNum) {\n-\t\treturn stackPointer[sstackNum] == -1;\n+\t\treturn stackPointer[stackNum] == -1;\n \t}\n \n \t/* returns index of top of stack \"stackNum\", in absolute terms */\n \tint absTopOfStack(int stasckNum) {\n \t\treturn stackNum * stackSize + stackPointer[stackNum];\n \t}\n-}\n\\ No newline at end of file\n+}",
    "output": "Update ThreeStacks - isEmpty function\n\nvariable is not equal to the parameter you are passing"
  },
  {
    "input": "diff --git a/Company/Google/3SumSmaller.java b/Company/Google/3SumSmaller.java\n--- a/Company/Google/3SumSmaller.java\n+++ b/Company/Google/3SumSmaller.java\n@@ -38,15 +38,15 @@ public int threeSumSmaller(int[] nums, int target) {\n                     //increment the count by the distance between left and right because the array is sorted\n                     count += right - left;\n                     \n-                    //decrement right pointer\n+                    //increment left pointer\n                     left++;\n                     \n                 }\n                 \n                 //if they sum to a value greater than target...\n                 else {\n                     \n-                    //increment left pointer\n+                    //decrement right pointer\n                     right--;\n                     \n                 }\n@@ -59,4 +59,4 @@ public int threeSumSmaller(int[] nums, int target) {\n             \n     }\n     \n-}\n\\ No newline at end of file\n+}",
    "output": "Merge pull request #16 from UWarbs/patch-2\n\nRearrange mixed up comments"
  },
  {
    "input": "diff --git a/Company/Google/3SumSmaller.java b/Company/Google/3SumSmaller.java\n--- a/Company/Google/3SumSmaller.java\n+++ b/Company/Google/3SumSmaller.java\n@@ -38,15 +38,15 @@ public int threeSumSmaller(int[] nums, int target) {\n                     //increment the count by the distance between left and right because the array is sorted\n                     count += right - left;\n                     \n-                    //decrement right pointer\n+                    //increment left pointer\n                     left++;\n                     \n                 }\n                 \n                 //if they sum to a value greater than target...\n                 else {\n                     \n-                    //increment left pointer\n+                    //decrement right pointer\n                     right--;\n                     \n                 }\n@@ -59,4 +59,4 @@ public int threeSumSmaller(int[] nums, int target) {\n             \n     }\n     \n-}\n\\ No newline at end of file\n+}",
    "output": "Rearrange mixed up comments"
  },
  {
    "input": "diff --git a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/DeleteDups.java b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/DeleteDups.java\n--- a/CrackingTheCodingInterview/Chapter1ArraysAndStrings/DeleteDups.java\n+++ b/CrackingTheCodingInterview/Chapter1ArraysAndStrings/DeleteDups.java\n@@ -0,0 +1,18 @@\n+//Write code to remove duplicates from an unsorted linked list\n+\n+public class RemoveDups {\n+\tvoid deleteDups(LinkedListNode n) {\n+\t\tHashSet<Integer> set = new HashSet<Integer>();\n+\t\tLinkedListNode previous = null;\n+\t\twhile(n != null) {\n+\t\t\tif(set.contains(n.data)) {\n+\t\t\t\tprevious.next = n.next;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tset.add(n.data);\n+\t\t\t\tprevious = n;\n+\t\t\t}\n+\t\t\tn = n.next;\n+\t\t}\n+\t}\n+}\n\\ No newline at end of file",
    "output": "added Refdash, fixed toggle bit and switch values"
  },
  {
    "input": "diff --git a/DivideAndConquer/expressionAddOperators.java b/DivideAndConquer/expressionAddOperators.java\n--- a/DivideAndConquer/expressionAddOperators.java\n+++ b/DivideAndConquer/expressionAddOperators.java\n@@ -0,0 +1,58 @@\n+// Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.\n+\n+// Examples: \n+// \"123\", 6 -> [\"1+2+3\", \"1*2*3\"] \n+// \"232\", 8 -> [\"2*3+2\", \"2+3*2\"]\n+// \"105\", 5 -> [\"1*0+5\",\"10-5\"]\n+// \"00\", 0 -> [\"0+0\", \"0-0\", \"0*0\"]\n+// \"3456237490\", 9191 -> []\n+\n+public class Solution {\n+\n+    public List<String> addOperators(String num, int target) {\n+        \n+        List<String> result = new ArrayList<String>();\n+        if(num == null || num.length() == 0) return result;\n+        helper(result, \"\", num, target, 0, 0, 0);\n+        return result;\n+        \n+    }\n+    \n+    public void helper(List<String> result, String path, String num, int target, int pos, long eval, long multed) {\n+        \n+        if(pos == num.length()) {\n+            \n+            if(eval == target) {\n+                \n+                result.add(path);\n+                \n+            }\n+            \n+            return;\n+            \n+        }\n+        \n+        for(int i = pos; i < num.length(); i++) {\n+            \n+            if(i != pos && num.charAt(pos) == '0') break;\n+            long cur = Long.parseLong(num.substring(pos, i + 1));\n+            if(pos == 0) {\n+                \n+                helper(result, path + cur, num, target, i + 1, cur, cur);\n+                \n+            }\n+            \n+            else {\n+                \n+                helper(result, path + \"+\" + cur, num, target, i + 1, eval + cur, cur);\n+                helper(result, path + \"-\" + cur, num, target, i + 1, eval - cur, -cur);\n+                helper(result, path + \"*\" + cur, num, target, i + 1, eval - multed + multed * cur, multed * cur);\n+                \n+                \n+            }\n+            \n+        }\n+        \n+    }\n+    \n+}\n\\ No newline at end of file\n\ndiff --git a/DivideAndConquer/kthLargestElementInAnArray.java b/DivideAndConquer/kthLargestElementInAnArray.java\n--- a/DivideAndConquer/kthLargestElementInAnArray.java\n+++ b/DivideAndConquer/kthLargestElementInAnArray.java\n@@ -0,0 +1,19 @@\n+// Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n+\n+// For example,\n+// Given [3,2,1,5,6,4] and k = 2, return 5.\n+\n+// Note: \n+// You may assume k is always valid, 1 ≤ k ≤ array's length.\n+\n+public class Solution {\n+\n+    public int findKthLargest(int[] nums, int k) {\n+\n+        int length = nums.length;\n+        Arrays.sort(nums);\n+        return nums[length - k];\n+        \n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "added DivideAndConquer"
  },
  {
    "input": "diff --git a/Backtracking/androidUnlockPatterns.java b/Backtracking/androidUnlockPatterns.java\n--- a/Backtracking/androidUnlockPatterns.java\n+++ b/Backtracking/androidUnlockPatterns.java\n@@ -0,0 +1,93 @@\n+// Given an Android 3x3 key lock screen and two integers m and n, where 1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.\n+\n+// Rules for a valid pattern:\n+    // Each pattern must connect at least m keys and at most n keys.\n+    // All the keys must be distinct.\n+    // If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed.\n+    // The order of keys used matters.\n+\n+// Explanation:\n+// | 1 | 2 | 3 |\n+// | 4 | 5 | 6 |\n+// | 7 | 8 | 9 |\n+// Invalid move: 4 - 1 - 3 - 6 \n+// Line 1 - 3 passes through key 2 which had not been selected in the pattern.\n+\n+// Invalid move: 4 - 1 - 9 - 2\n+// Line 1 - 9 passes through key 5 which had not been selected in the pattern.\n+\n+// Valid move: 2 - 4 - 1 - 3 - 6\n+// Line 1 - 3 is valid because it passes through key 2, which had been selected in the pattern\n+\n+// Valid move: 6 - 5 - 4 - 1 - 9 - 2\n+// Line 1 - 9 is valid because it passes through key 5, which had been selected in the pattern.\n+\n+// Example:\n+// Given m = 1, n = 1, return 9.\n+\n+public class Solution {\n+\n+    public int numberOfPatterns(int m, int n) {\n+        \n+        //initialize a 10x10 matrix\n+        int skip[][] = new int[10][10];\n+        \n+        //initialize indices of skip matrix (all other indices in matrix are 0 by default)\n+        skip[1][3] = skip[3][1] = 2;\n+        skip[1][7] = skip[7][1] = 4;\n+        skip[3][9] = skip[9][3] = 6;\n+        skip[7][9] = skip[9][7] = 8;\n+        skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip [7][3] = skip[6][4] = skip[4][6] = 5;\n+        \n+        //initialize visited array\n+        boolean visited[] = new boolean[10];\n+        \n+        //initialize total number to 0\n+        int totalNumber = 0;\n+        \n+        //run DFS for each length from m to n\n+        for(int i = m; i <= n; ++i) {\n+            \n+            totalNumber += DFS(visited, skip, 1, i - 1) * 4; //1, 3, 7, and 9 are symmetric so multiply this result by 4\n+            totalNumber += DFS(visited, skip, 2, i - 1) * 4; //2, 4, 6, and 8 are symmetric so multiply this result by 4\n+            totalNumber += DFS(visited, skip, 5, i - 1); //do not multiply by 4 because 5 is unique         \n+            \n+        }\n+        \n+        return totalNumber;\n+  \n+    }\n+    \n+    int DFS(boolean visited[], int[][] skip, int current, int remaining) {\n+        \n+        //base cases\n+        if(remaining < 0) return 0;\n+        if(remaining == 0) return 1;\n+        \n+        //mark the current node as visited\n+        visited[current] = true;\n+        \n+        //initialize total number to 0\n+        int totalNumber = 0;\n+        \n+        \n+        for(int i = 1; i <= 9; ++i) {\n+            \n+            //if the current node has not been visited and (two numbers are adjacent or skip number has already been visited)\n+            if(!visited[i] && (skip[current][i] == 0 || visited[skip[current][i]])) {\n+                \n+                totalNumber += DFS(visited, skip, i, remaining - 1);\n+                \n+            }\n+            \n+        }\n+        \n+        //mark the current node as not visited\n+        visited[current] = false;\n+        \n+        //return total number\n+        return totalNumber;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/Backtracking/generalizedAbbreviation.java b/Backtracking/generalizedAbbreviation.java\n--- a/Backtracking/generalizedAbbreviation.java\n+++ b/Backtracking/generalizedAbbreviation.java\n@@ -0,0 +1,42 @@\n+// Write a function to generate the generalized abbreviations of a word.\n+\n+// Example:\n+// Given word = \"word\", return the following list (order does not matter):\n+// [\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\n+\n+public class Solution {\n+\n+    public List<String> generateAbbreviations(String word) {\n+        \n+        List<String> result = new ArrayList<String>();\n+        \n+        backtrack(result, word, 0, \"\", 0);\n+        \n+        return result;\n+        \n+    }\n+    \n+    void backtrack(List result, String word, int position, String current, int count) {\n+        \n+        if(position == word.length()) {\n+            \n+            if(count > 0) {\n+                \n+                current += count;   \n+                \n+            }\n+            \n+            result.add(current);\n+            \n+        }\n+        \n+        else {\n+            \n+            backtrack(result, word, position + 1, current, count + 1);\n+            backtrack(result, word, position + 1, current + (count > 0 ? count : \"\") + word.charAt(position), 0);\n+            \n+        }\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/Backtracking/letterCombinationsOfAPhoneNumber.java b/Backtracking/letterCombinationsOfAPhoneNumber.java\n--- a/Backtracking/letterCombinationsOfAPhoneNumber.java\n+++ b/Backtracking/letterCombinationsOfAPhoneNumber.java\n@@ -0,0 +1,54 @@\n+// Given a digit string, return all possible letter combinations that the number could represent.\n+\n+// A mapping of digit to letters (just like on the telephone buttons) is given below.\n+\n+// 2 - abc\n+// 3 - def\n+// 4 - ghi\n+// 5 - jkl\n+// 6 - mno\n+// 7 - pqrs\n+// 8 - tuv\n+// 9 - wxyz\n+\n+// Input:Digit string \"23\"\n+// Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n+\n+public class Solution {\n+\n+    public List<String> letterCombinations(String digits) {\n+        \n+        LinkedList<String> result = new LinkedList<>();\n+        String[] mapping = new String[] { \"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" };\n+        \n+        if(digits == null || digits.length() == 0) {\n+            \n+            return result;\n+            \n+        }\n+        \n+        result.add(\"\");\n+        \n+        for(int i = 0; i < digits.length(); i++) {\n+            \n+            int current = Character.getNumericValue(digits.charAt(i));\n+            \n+            while(result.peek().length() == i) {\n+                \n+                String s = result.remove();\n+                \n+                for(char c : mapping[current].toCharArray()) {\n+                    \n+                    result.add(s + c);\n+                    \n+                }\n+                \n+            }\n+            \n+        }\n+        \n+        return result;\n+        \n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "added Backtracking"
  },
  {
    "input": "diff --git a/Sort/meetingRooms.java b/Sort/meetingRooms.java\n--- a/Sort/meetingRooms.java\n+++ b/Sort/meetingRooms.java\n@@ -0,0 +1,47 @@\n+// Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings.\n+\n+// For example,\n+// Given [[0, 30],[5, 10],[15, 20]],\n+// return false.\n+\n+/**\n+ * Definition for an interval.\n+ * public class Interval {\n+ *     int start;\n+ *     int end;\n+ *     Interval() { start = 0; end = 0; }\n+ *     Interval(int s, int e) { start = s; end = e; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public boolean canAttendMeetings(Interval[] intervals) {\n+        \n+            if(intervals == null) {\n+                \n+                return false;\n+                \n+            }\n+        \n+    // Sort the intervals by start time\n+    Arrays.sort(intervals, new Comparator<Interval>() {\n+\n+        public int compare(Interval a, Interval b) { return a.start - b.start; }\n+\n+    });\n+\n+            for(int i = 1; i < intervals.length; i++) {\n+                \n+                if(intervals[i].start < intervals[i - 1].end) {\n+                    \n+                    return false;\n+                    \n+                }\n+                \n+            }\n+            \n+            return true;\n+\n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/Sort/meetingRoomsII.java b/Sort/meetingRoomsII.java\n--- a/Sort/meetingRoomsII.java\n+++ b/Sort/meetingRoomsII.java\n@@ -0,0 +1,48 @@\n+// Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.\n+\n+// For example,\n+// Given [[0, 30],[5, 10],[15, 20]],\n+// return 2.\n+\n+/**\n+ * Definition for an interval.\n+ * public class Interval {\n+ *     int start;\n+ *     int end;\n+ *     Interval() { start = 0; end = 0; }\n+ *     Interval(int s, int e) { start = s; end = e; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public int minMeetingRooms(Interval[] intervals) {\n+\n+        int[] starts = new int[intervals.length];\n+        int[] ends = new int[intervals.length];\n+\n+        for(int i=0; i<intervals.length; i++) {\n+\n+            starts[i] = intervals[i].start;\n+            ends[i] = intervals[i].end;\n+\n+        }\n+\n+        Arrays.sort(starts);\n+        Arrays.sort(ends);\n+        int rooms = 0;\n+        int endsItr = 0;\n+\n+        for(int i=0; i<starts.length; i++) {\n+\n+            if(starts[i]<ends[endsItr])\n+                rooms++;\n+            else\n+                endsItr++;\n+\n+        }\n+\n+        return rooms;\n+\n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "added Sort"
  },
  {
    "input": "diff --git a/Array/insertInterval.java b/Array/insertInterval.java\n--- a/Array/insertInterval.java\n+++ b/Array/insertInterval.java\n@@ -0,0 +1,41 @@\n+// Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\n+\n+// You may assume that the intervals were initially sorted according to their start times.\n+\n+// Example 1:\n+// Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].\n+\n+// Example 2:\n+// Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].\n+\n+// This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].\n+\n+/**\n+ * Definition for an interval.\n+ * public class Interval {\n+ *     int start;\n+ *     int end;\n+ *     Interval() { start = 0; end = 0; }\n+ *     Interval(int s, int e) { start = s; end = e; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n+        \n+        int i = 0;\n+\n+        while(i < intervals.size() && intervals.get(i).end < newInterval.start) i++;\n+        while(i < intervals.size() && intervals.get(i).start <= newInterval.end) {\n+            \n+            newInterval = new Interval(Math.min(intervals.get(i).start, newInterval.start), Math.max(intervals.get(i).end, newInterval.end));\n+            intervals.remove(i);\n+            \n+        }\n+        \n+        intervals.add(i, newInterval);\n+        return intervals;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/Array/missingRanges.java b/Array/missingRanges.java\n--- a/Array/missingRanges.java\n+++ b/Array/missingRanges.java\n@@ -0,0 +1,46 @@\n+// Given a sorted integer array where the range of elements are in the inclusive range [lower, upper], return its missing ranges.\n+\n+// For example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, return [\"2\", \"4->49\", \"51->74\", \"76->99\"].\n+\n+public class Solution {\n+\n+    public List<String> findMissingRanges(int[] nums, int lower, int upper) {\n+        \n+        ArrayList<String> result = new ArrayList<String>();\n+        \n+        for(int i = 0; i <= nums.length; i++) {\n+            \n+            long start = i == 0 ? lower : (long)nums[i - 1] + 1;\n+            long end = i == nums.length ? upper : (long)nums[i] - 1;\n+            addMissing(result, start, end);\n+            \n+            \n+        }\n+        \n+        return result;\n+        \n+    }\n+    \n+    void addMissing(ArrayList<String> result, long start, long end) {\n+        \n+        if(start > end) {\n+            \n+            return;\n+            \n+        }\n+        \n+        else if(start == end) {\n+            \n+            result.add(start + \"\");\n+            \n+        }\n+        \n+        else {\n+            \n+            result.add(start + \"->\" + end);\n+            \n+        }\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/Array/subsetsII.java b/Array/subsetsII.java\n--- a/Array/subsetsII.java\n+++ b/Array/subsetsII.java\n@@ -0,0 +1,50 @@\n+// Given a collection of integers that might contain duplicates, nums, return all possible subsets.\n+\n+// Note: The solution set must not contain duplicate subsets.\n+\n+// For example,\n+// If nums = [1,2,2], a solution is:\n+\n+// [\n+//   [2],\n+//   [1],\n+//   [1,2,2],\n+//   [2,2],\n+//   [1,2],\n+//   []\n+// ]\n+\n+public class Solution {\n+\n+    public List<List<Integer>> subsetsWithDup(int[] nums) {\n+        \n+        Arrays.sort(nums);\n+        \n+        List<List<Integer>> result = new ArrayList<List<Integer>>();\n+        \n+        if(nums.length == 0 || nums == null) return result;\n+        \n+        helper(nums, new ArrayList<Integer>(), 0, result);\n+        \n+        return result;\n+        \n+    }\n+    \n+    \n+    public void helper(int[] nums, ArrayList<Integer> current, int index, List<List<Integer>> result) {\n+        \n+        result.add(current);\n+        \n+        for(int i = index; i < nums.length; i++) {\n+            \n+            if(i > index && nums[i] == nums[i - 1]) continue;\n+            \n+            ArrayList<Integer> newCurrent = new ArrayList<Integer>(current);\n+            newCurrent.add(nums[i]);\n+            helper(nums, newCurrent, i + 1, result);\n+            \n+        }\n+        \n+    }\n+    \n+}\n\\ No newline at end of file",
    "output": "added to Array"
  },
  {
    "input": "diff --git a/Trie/addAndSearchWordDataStructureDesign.java b/Trie/addAndSearchWordDataStructureDesign.java\n--- a/Trie/addAndSearchWordDataStructureDesign.java\n+++ b/Trie/addAndSearchWordDataStructureDesign.java\n@@ -0,0 +1,85 @@\n+// Design a data structure that supports the following two operations:\n+\n+// void addWord(word)\n+// bool search(word)\n+// search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.\n+\n+// For example:\n+\n+// addWord(\"bad\")\n+// addWord(\"dad\")\n+// addWord(\"mad\")\n+// search(\"pad\") -> false\n+// search(\"bad\") -> true\n+// search(\".ad\") -> true\n+// search(\"b..\") -> true\n+\n+// Note:\n+    // You may assume that all words are consist of lowercase letters a-z.\n+\n+public class WordDictionary {\n+\n+    public class TrieNode {\n+\n+        public TrieNode[] children = new TrieNode[26];\n+        public String item = \"\";\n+\n+    }\n+    \n+    private TrieNode root = new TrieNode();\n+\n+    public void addWord(String word) {\n+\n+        TrieNode node = root;\n+\n+        for (char c : word.toCharArray()) {\n+\n+            if (node.children[c - 'a'] == null) {\n+\n+                node.children[c - 'a'] = new TrieNode();\n+            }\n+\n+            node = node.children[c - 'a'];\n+        }\n+\n+        node.item = word;\n+    }\n+\n+    public boolean search(String word) {\n+\n+        return match(word.toCharArray(), 0, root);\n+\n+    }\n+    \n+    private boolean match(char[] chs, int k, TrieNode node) {\n+\n+        if (k == chs.length) return !node.item.equals(\"\"); \n+\n+        if (chs[k] != '.') {\n+\n+            return node.children[chs[k] - 'a'] != null && match(chs, k + 1, node.children[chs[k] - 'a']);\n+\n+        } \n+\n+        else {\n+\n+            for (int i = 0; i < node.children.length; i++) {\n+\n+                if (node.children[i] != null) {\n+\n+                    if (match(chs, k + 1, node.children[i])) {\n+\n+                        return true;\n+\n+                    }\n+\n+                }\n+\n+            }\n+\n+        }\n+\n+        return false;\n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/Trie/implementTrie.java b/Trie/implementTrie.java\n--- a/Trie/implementTrie.java\n+++ b/Trie/implementTrie.java\n@@ -0,0 +1,96 @@\n+// Implement a trie with insert, search, and startsWith methods.\n+\n+// Note:\n+// You may assume that all inputs are consist of lowercase letters a-z.\n+\n+// Your Trie object will be instantiated and called as such:\n+// Trie trie = new Trie();\n+// trie.insert(\"somestring\");\n+// trie.search(\"key\");\n+\n+class TrieNode {\n+\n+    HashMap<Character, TrieNode> map;\n+    char character;\n+    boolean last;\n+    \n+    // Initialize your data structure here.\n+    public TrieNode(char character) {\n+        \n+        this.map = new HashMap<Character, TrieNode>();\n+        this.character = character;\n+        this.last = false;\n+        \n+    }\n+\n+}\n+\n+public class Trie {\n+\n+    private TrieNode root;\n+\n+    public Trie() {\n+\n+        root = new TrieNode(' ');\n+\n+    }\n+\n+    // Inserts a word into the trie.\n+    public void insert(String word) {\n+\n+        TrieNode current = root;\n+            \n+        for(char c : word.toCharArray()) {\n+            \n+            if(!current.map.containsKey(c)) {\n+                \n+                current.map.put(c, new TrieNode(c));\n+                \n+            }\n+            \n+            current = current.map.get(c);\n+\n+        }\n+        \n+        current.last = true;\n+        \n+    }\n+\n+    // Returns if the word is in the trie.\n+    public boolean search(String word) {\n+        \n+        TrieNode current = root;\n+        \n+        for(char c : word.toCharArray()) {\n+            \n+            if(!current.map.containsKey(c)) return false;\n+            \n+            current = current.map.get(c);\n+            \n+        }\n+        \n+        if(current.last == true) return true;\n+        else return false;\n+        \n+    }\n+\n+    // Returns if there is any word in the trie\n+    // that starts with the given prefix.\n+    public boolean startsWith(String prefix) {\n+        \n+        TrieNode current = root;\n+        \n+        for(char c : prefix.toCharArray()) {\n+            \n+            if(!current.map.containsKey(c)) return false;\n+            \n+            current = current.map.get(c);\n+            \n+        }\n+        \n+        return true;\n+        \n+    }\n+\n+}\n+\n\ndiff --git a/Trie/wordSquares.java b/Trie/wordSquares.java\n--- a/Trie/wordSquares.java\n+++ b/Trie/wordSquares.java\n@@ -0,0 +1,73 @@\n+// Given a set of words (without duplicates), find all word squares you can build from them.\n+\n+// A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k < max(numRows, numColumns).\n+\n+// For example, the word sequence [\"ball\",\"area\",\"lead\",\"lady\"] forms a word square because each word reads the same both horizontally and vertically.\n+\n+// b a l l\n+// a r e a\n+// l e a d\n+// l a d y\n+\n+// Note:\n+    // There are at least 1 and at most 1000 words.\n+    // All words will have the exact same length.\n+    // Word length is at least 1 and at most 5.\n+    // Each word contains only lowercase English alphabet a-z.\n+\n+public class Solution {\n+\n+    public List<List<String>> wordSquares(String[] words) {\n+\n+        List<List<String>> ret = new ArrayList<List<String>>();\n+\n+        if(words.length==0 || words[0].length()==0) return ret;\n+\n+        Map<String, Set<String>> map = new HashMap<>();\n+\n+        int squareLen = words[0].length();\n+\n+        // create all prefix\n+        for(int i=0;i<words.length;i++){\n+\n+            for(int j=-1;j<words[0].length();j++){\n+\n+                if(!map.containsKey(words[i].substring(0, j+1))) map.put(words[i].substring(0, j+1), new HashSet<String>());\n+\n+                map.get(words[i].substring(0, j+1)).add(words[i]);\n+\n+            }\n+\n+        }\n+\n+        helper(ret, new ArrayList<String>(), 0, squareLen, map);\n+\n+        return ret;\n+\n+    }\n+\n+    public void helper(List<List<String>> ret, List<String> cur, int matched, int total, Map<String, Set<String>> map){\n+\n+        if(matched == total) {ret.add(new ArrayList<String>(cur));return;}\n+\n+        // build search string\n+        StringBuilder sb = new StringBuilder();\n+\n+        for(int i=0;i<=matched-1;i++) sb.append(cur.get(i).charAt(matched));\n+\n+        // bachtracking\n+        Set<String> cand = map.get(sb.toString());\n+\n+        if(cand==null) return;\n+\n+        for(String str:cand){\n+\n+            cur.add(str);\n+            helper(ret, cur, matched+1, total, map);\n+            cur.remove(cur.size()-1);\n+\n+        }\n+\n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "added Trie"
  },
  {
    "input": "diff --git a/HashTable/loggerRateLimiter.java b/HashTable/loggerRateLimiter.java\n--- a/HashTable/loggerRateLimiter.java\n+++ b/HashTable/loggerRateLimiter.java\n@@ -67,7 +67,7 @@ public boolean shouldPrintMessage(int timestamp, String message) {\n         }\n     \n     }\n-    \n+\n }\n \n /**\n\ndiff --git a/Stack/binarySearchTreeIterator.java b/Stack/binarySearchTreeIterator.java\n--- a/Stack/binarySearchTreeIterator.java\n+++ b/Stack/binarySearchTreeIterator.java\n@@ -0,0 +1,65 @@\n+// Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.\n+\n+// Calling next() will return the next smallest number in the BST.\n+\n+// Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.\n+\n+/**\n+ * Definition for binary tree\n+ * public class TreeNode {\n+ *     int val;\n+ *     TreeNode left;\n+ *     TreeNode right;\n+ *     TreeNode(int x) { val = x; }\n+ * }\n+ */\n+\n+public class BSTIterator {\n+    \n+    Stack<TreeNode> stack;\n+\n+    public BSTIterator(TreeNode root) {\n+        \n+        stack = new Stack<TreeNode>();\n+        \n+        while(root != null) {\n+            \n+            stack.push(root);\n+            root = root.left;\n+            \n+        }\n+        \n+    }\n+\n+    /** @return whether we have a next smallest number */\n+    public boolean hasNext() {\n+        \n+        return stack.isEmpty() ? false : true;\n+        \n+    }\n+\n+    /** @return the next smallest number */\n+    public int next() {\n+        \n+        TreeNode nextSmallest = stack.pop();\n+        \n+        TreeNode addToStack = nextSmallest.right;\n+        \n+        while(addToStack != null) {\n+            \n+            stack.add(addToStack);\n+            addToStack = addToStack.left;\n+            \n+        }\n+        \n+        return nextSmallest.val;\n+        \n+    }\n+\n+}\n+\n+/**\n+ * Your BSTIterator will be called like this:\n+ * BSTIterator i = new BSTIterator(root);\n+ * while (i.hasNext()) v[f()] = i.next();\n+ */\n\\ No newline at end of file\n\ndiff --git a/Stack/decodeString.java b/Stack/decodeString.java\n--- a/Stack/decodeString.java\n+++ b/Stack/decodeString.java\n@@ -0,0 +1,94 @@\n+// Given an encoded string, return it's decoded string.\n+\n+// The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n+\n+// You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\n+\n+// Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\n+\n+public class Solution {\n+\n+    public String decodeString(String s) {\n+        \n+        //declare empty string\n+        String decoded = \"\";\n+        \n+        //initialize stack to hold counts\n+        Stack<Integer> countStack = new Stack<Integer>();\n+        \n+        //initalize stack to hold decoded string\n+        Stack<String> decodedStack = new Stack<String>();\n+        \n+        //initialize index to zero\n+        int index = 0;\n+        \n+        //iterate through entire string\n+        while(index < s.length()) {\n+            \n+            //if the current character is numeric...\n+            if(Character.isDigit(s.charAt(index))) {\n+                \n+                int count = 0;\n+                \n+                //determine the number\n+                while(Character.isDigit(s.charAt(index))) {\n+                    \n+                    count = 10 * count + (s.charAt(index) - '0');\n+                    \n+                    index++;\n+                    \n+                }\n+                \n+                //push the number onto the count stack\n+                countStack.push(count);\n+                \n+            }\n+            \n+            //if the current character is an opening bracket\n+            else if(s.charAt(index) == '[') {\n+                \n+                decodedStack.push(decoded);\n+                \n+                decoded = \"\";\n+                \n+                index++;\n+                \n+            }\n+            \n+            //if the current character is a closing bracket\n+            else if(s.charAt(index) == ']') {\n+                \n+                StringBuilder temp = new StringBuilder(decodedStack.pop());\n+                \n+                int repeatTimes = countStack.pop();\n+                \n+                for(int i = 0; i < repeatTimes; i++) {\n+                    \n+                    temp.append(decoded);\n+                    \n+                }\n+                \n+                decoded = temp.toString();\n+                \n+                index++;\n+                \n+            }\n+            \n+            //otherwise, append the current character to the decoded string\n+            else {\n+                \n+                decoded += s.charAt(index);\n+                \n+                index++;\n+                \n+            }\n+            \n+            \n+        }\n+        \n+        //return the decoded string\n+        return decoded;\n+        \n+    }\n+        \n+}\n\\ No newline at end of file\n\ndiff --git a/Stack/flattenNestedListIterator.java b/Stack/flattenNestedListIterator.java\n--- a/Stack/flattenNestedListIterator.java\n+++ b/Stack/flattenNestedListIterator.java\n@@ -0,0 +1,79 @@\n+// Given a nested list of integers, implement an iterator to flatten it.\n+\n+// Each element is either an integer, or a list -- whose elements may also be integers or other lists.\n+\n+// Example 1:\n+// Given the list [[1,1],2,[1,1]],\n+\n+// By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\n+\n+// Example 2:\n+// Given the list [1,[4,[6]]],\n+\n+// By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\n+\n+/**\n+ * // This is the interface that allows for creating nested lists.\n+ * // You should not implement it, or speculate about its implementation\n+ * public interface NestedInteger {\n+ *\n+ *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n+ *     public boolean isInteger();\n+ *\n+ *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n+ *     // Return null if this NestedInteger holds a nested list\n+ *     public Integer getInteger();\n+ *\n+ *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n+ *     // Return null if this NestedInteger holds a single integer\n+ *     public List<NestedInteger> getList();\n+ * }\n+ */\n+public class NestedIterator implements Iterator<Integer> {\n+    \n+    Stack<NestedInteger> stack = new Stack<NestedInteger>();\n+\n+    public NestedIterator(List<NestedInteger> nestedList) {\n+        \n+        for(int i = nestedList.size() - 1; i >= 0; i--) {\n+            \n+            stack.push(nestedList.get(i));\n+            \n+        }\n+        \n+    }\n+\n+    @Override\n+    public Integer next() {\n+        \n+        return stack.pop().getInteger();\n+        \n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+        \n+        while(!stack.isEmpty()) {\n+            \n+            NestedInteger current = stack.peek();\n+            if(current.isInteger()) return true;\n+            stack.pop();\n+            for(int i = current.getList().size() - 1;  i >= 0; i--) {\n+                \n+                stack.push(current.getList().get(i));\n+                \n+            }\n+            \n+        }\n+        \n+        return false;\n+        \n+    }\n+\n+}\n+\n+/**\n+ * Your NestedIterator object will be instantiated and called as such:\n+ * NestedIterator i = new NestedIterator(nestedList);\n+ * while (i.hasNext()) v[f()] = i.next();\n+ */\n\\ No newline at end of file\n\ndiff --git a/Stack/trappingRainWater.java b/Stack/trappingRainWater.java\n--- a/Stack/trappingRainWater.java\n+++ b/Stack/trappingRainWater.java\n@@ -0,0 +1,44 @@\n+// Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n+\n+// For example, \n+// Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.\n+\n+public class Solution {\n+\n+    public int trap(int[] height) {\n+        \n+        int water = 0;\n+        \n+        int leftIndex = 0;\n+        int rightIndex = height.length - 1;\n+        \n+        int leftMax = 0;\n+        int rightMax = 0;\n+        \n+        while(leftIndex <= rightIndex) {\n+            \n+            leftMax = Math.max(leftMax, height[leftIndex]);\n+            rightMax = Math.max(rightMax, height[rightIndex]);\n+            \n+            if(leftMax < rightMax) {\n+                \n+                water += leftMax - height[leftIndex];\n+                leftIndex++;\n+                \n+            }\n+            \n+            else {\n+                \n+                water += rightMax - height[rightIndex];\n+                rightIndex--;\n+                \n+            }\n+            \n+        }\n+        \n+        return water;\n+        \n+    }\n+    \n+}\n+",
    "output": "added Stack"
  },
  {
    "input": "diff --git a/DepthFirstSearch/balancedBinaryTree.java b/DepthFirstSearch/balancedBinaryTree.java\n--- a/DepthFirstSearch/balancedBinaryTree.java\n+++ b/DepthFirstSearch/balancedBinaryTree.java\n@@ -0,0 +1,42 @@\n+// Given a binary tree, determine if it is height-balanced.\n+\n+// For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n+\n+/**\n+ * Definition for a binary tree node.\n+ * public class TreeNode {\n+ *     int val;\n+ *     TreeNode left;\n+ *     TreeNode right;\n+ *     TreeNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+    \n+    boolean balanced = true;\n+    \n+    public boolean isBalanced(TreeNode root) {\n+        \n+        height(root);\n+        return balanced;\n+        \n+    }\n+    \n+    private int height(TreeNode root) {\n+        \n+        if(root == null) return 0;\n+        \n+        int leftHeight = height(root.left);\n+        int rightHeight = height(root.right);\n+        \n+        if(Math.abs(leftHeight - rightHeight) > 1) {\n+            \n+            balanced = false;\n+            \n+        }\n+        \n+        return 1 + Math.max(leftHeight, rightHeight);\n+        \n+    }\n+    \n+}\n\\ No newline at end of file\n\ndiff --git a/DepthFirstSearch/convertSortedArrayToBinarySearchTree.java b/DepthFirstSearch/convertSortedArrayToBinarySearchTree.java\n--- a/DepthFirstSearch/convertSortedArrayToBinarySearchTree.java\n+++ b/DepthFirstSearch/convertSortedArrayToBinarySearchTree.java\n@@ -0,0 +1,43 @@\n+// Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\n+\n+/**\n+ * Definition for a binary tree node.\n+ * public class TreeNode {\n+ *     int val;\n+ *     TreeNode left;\n+ *     TreeNode right;\n+ *     TreeNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public TreeNode sortedArrayToBST(int[] nums) {\n+        \n+        if(nums.length == 0) return null;\n+        \n+        TreeNode root = helper(nums, 0, nums.length - 1);\n+        \n+        return root;\n+        \n+    }\n+    \n+    private TreeNode helper(int[] nums, int start, int end) {\n+        \n+        if(start <= end) {\n+            \n+            int mid = (start + end) / 2;\n+            \n+            TreeNode current = new TreeNode(nums[mid]);\n+            \n+            current.left = helper(nums, start, mid - 1);\n+            current.right = helper(nums, mid + 1, end);\n+            \n+            return current;\n+            \n+        }\n+        \n+        return null;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/DepthFirstSearch/maximumDepthOfABinaryTree.java b/DepthFirstSearch/maximumDepthOfABinaryTree.java\n--- a/DepthFirstSearch/maximumDepthOfABinaryTree.java\n+++ b/DepthFirstSearch/maximumDepthOfABinaryTree.java\n@@ -0,0 +1,24 @@\n+// Given a binary tree, find its maximum depth.\n+\n+// The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n+\n+/**\n+ * Definition for a binary tree node.\n+ * public class TreeNode {\n+ *     int val;\n+ *     TreeNode left;\n+ *     TreeNode right;\n+ *     TreeNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public int maxDepth(TreeNode root) {\n+        \n+        if(root == null) return 0;\n+        \n+        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/DepthFirstSearch/numberOfIslands.java b/DepthFirstSearch/numberOfIslands.java\n--- a/DepthFirstSearch/numberOfIslands.java\n+++ b/DepthFirstSearch/numberOfIslands.java\n@@ -0,0 +1,71 @@\n+// Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n+\n+// Example 1:\n+\n+// 11110\n+// 11010\n+// 11000\n+// 00000\n+// Answer: 1\n+\n+// Example 2:\n+\n+// 11000\n+// 11000\n+// 00100\n+// 00011\n+// Answer: 3\n+\n+public class Solution {\n+    \n+    char[][] gridCopy;\n+    \n+    public int numIslands(char[][] grid) {\n+        \n+        //set grid copy to the current grid\n+        gridCopy = grid;\n+        \n+        //initialize number of islands to zero\n+        int numberOfIslands = 0;\n+        \n+        //iterate through every index of the grid\n+        for(int i = 0; i < grid.length; i++) {\n+            \n+            for(int j = 0; j < grid[0].length; j++) {\n+                \n+                //attempt to \"sink\" the current index of the grid\n+                numberOfIslands += sink(gridCopy, i, j);\n+                \n+            }\n+            \n+        }\n+        \n+        //return the total number of islands\n+        return numberOfIslands;\n+        \n+    }\n+    \n+    int sink(char[][] grid, int i, int j) {\n+        \n+        //check the bounds of i and j and if the current index is an island or not (1 or 0)\n+        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') {\n+            \n+            return 0;\n+            \n+        }\n+        \n+        //set current index to 0\n+        grid[i][j] = '0';\n+        \n+        // sink all neighbors of current index\n+        sink(grid, i + 1, j);\n+        sink(grid, i - 1, j);\n+        sink(grid, i, j + 1);\n+        sink(grid, i, j - 1);\n+        \n+        //increment number of islands\n+        return 1;\n+        \n+    }\n+    \n+}\n\\ No newline at end of file\n\ndiff --git a/DepthFirstSearch/populatingNextRightPointersInEachNode.java b/DepthFirstSearch/populatingNextRightPointersInEachNode.java\n--- a/DepthFirstSearch/populatingNextRightPointersInEachNode.java\n+++ b/DepthFirstSearch/populatingNextRightPointersInEachNode.java\n@@ -0,0 +1,81 @@\n+// Given a binary tree\n+\n+//     struct TreeLinkNode {\n+//       TreeLinkNode *left;\n+//       TreeLinkNode *right;\n+//       TreeLinkNode *next;\n+//     }\n+// Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n+\n+// Initially, all next pointers are set to NULL.\n+\n+// Note:\n+\n+// You may only use constant extra space.\n+// You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).\n+// For example,\n+// Given the following perfect binary tree,\n+//          1\n+//        /  \\\n+//       2    3\n+//      / \\  / \\\n+//     4  5  6  7\n+// After calling your function, the tree should look like:\n+//          1 -> NULL\n+//        /  \\\n+//       2 -> 3 -> NULL\n+//      / \\  / \\\n+//     4->5->6->7 -> NULL\n+\n+/**\n+ * Definition for binary tree with next pointer.\n+ * public class TreeLinkNode {\n+ *     int val;\n+ *     TreeLinkNode left, right, next;\n+ *     TreeLinkNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public void connect(TreeLinkNode root) {\n+        \n+        if(root == null) return;\n+        \n+        Queue<TreeLinkNode> queue = new LinkedList<TreeLinkNode>();\n+        \n+        queue.add(root);\n+        \n+        while(!queue.isEmpty()) {\n+            \n+            Queue<TreeLinkNode> currentLevel = new LinkedList<TreeLinkNode>();\n+            \n+            TreeLinkNode temp = null;\n+            \n+            while(!queue.isEmpty()) {\n+                \n+                TreeLinkNode current = queue.remove();\n+                current.next = temp;\n+                temp = current;\n+                \n+                \n+                if(current.right != null) {\n+                    \n+                    currentLevel.add(current.right);\n+                    \n+                }\n+                \n+                if(current.left!= null) {\n+                    \n+                    currentLevel.add(current.left);\n+                }\n+                \n+                \n+            }\n+            \n+            queue = currentLevel;\n+            \n+        }\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/DepthFirstSearch/sameTree.java b/DepthFirstSearch/sameTree.java\n--- a/DepthFirstSearch/sameTree.java\n+++ b/DepthFirstSearch/sameTree.java\n@@ -0,0 +1,30 @@\n+// Given two binary trees, write a function to check if they are equal or not.\n+\n+// Two binary trees are considered equal if they are structurally identical and the nodes have the same value.\n+\n+/**\n+ * Definition for a binary tree node.\n+ * public class TreeNode {\n+ *     int val;\n+ *     TreeNode left;\n+ *     TreeNode right;\n+ *     TreeNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public boolean isSameTree(TreeNode p, TreeNode q) {\n+        \n+        if(p == null && q == null) return true;\n+        \n+        if(p == null && q != null || q == null && p != null) return false;\n+        \n+        if(p.val != q.val) return false;\n+        \n+        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n+        \n+        \n+    \n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "added to DepthFirstSearch"
  },
  {
    "input": "diff --git a/BitManipulation/binaryWatch.java b/BitManipulation/binaryWatch.java\n--- a/BitManipulation/binaryWatch.java\n+++ b/BitManipulation/binaryWatch.java\n@@ -0,0 +1,45 @@\n+// A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).\n+\n+// Each LED represents a zero or one, with the least significant bit on the right.\n+\n+// For example, the above binary watch reads \"3:25\".\n+\n+// Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.\n+\n+// Example:\n+\n+// Input: n = 1\n+// Return: [\"1:00\", \"2:00\", \"4:00\", \"8:00\", \"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\"]\n+// Note:\n+// The order of output does not matter.\n+// The hour must not contain a leading zero, for example \"01:00\" is not valid, it should be \"1:00\".\n+// The minute must be consist of two digits and may contain a leading zero, for example \"10:2\" is not valid, it should be \"10:02\".\n+\n+public class Solution {\n+\n+    public List<String> readBinaryWatch(int num) {\n+        \n+        ArrayList<String> allTimes = new ArrayList<String>();\n+        \n+        //iterate through all possible time combinations\n+        for(int i = 0; i < 12; i++) {\n+            \n+            for(int j = 0; j < 60; j++) {\n+                \n+                //if the current number and n have the same number of bits the time is possible\n+                if(Integer.bitCount(i * 64 + j) == num) {\n+                    \n+                    //add the current time to all times arraylist\n+                    allTimes.add(String.format(\"%d:%02d\", i, j));\n+                    \n+                }\n+                \n+            }\n+            \n+        }\n+        \n+        return allTimes;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/BitManipulation/countingBits.java b/BitManipulation/countingBits.java\n--- a/BitManipulation/countingBits.java\n+++ b/BitManipulation/countingBits.java\n@@ -0,0 +1,23 @@\n+// Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.\n+\n+// Example:\n+// For num = 5 you should return [0,1,1,2,1,2].\n+\n+public class Solution {\n+    public int[] countBits(int num) {\n+        \n+        int[] bits = new int[num + 1];\n+        \n+        bits[0] = 0;\n+        \n+        for(int i = 1; i <= num; i++) {\n+            \n+            bits[i] = bits[i >> 1] + (i & 1);\n+            \n+        }\n+        \n+        return bits;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/BitManipulation/hammingDistance.java b/BitManipulation/hammingDistance.java\n--- a/BitManipulation/hammingDistance.java\n+++ b/BitManipulation/hammingDistance.java\n@@ -0,0 +1,29 @@\n+// The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n+\n+// Given two integers x and y, calculate the Hamming distance.\n+\n+// Note:\n+// 0 ≤ x, y < 2^31.\n+\n+// Example:\n+\n+// Input: x = 1, y = 4\n+\n+// Output: 2\n+\n+// Explanation:\n+// 1   (0 0 0 1)\n+// 4   (0 1 0 0)\n+//        ↑   ↑\n+\n+// The above arrows point to positions where the corresponding bits are different.\n+\n+public class Solution {\n+\n+    public int hammingDistance(int x, int y) {\n+        \n+        return Integer.bitCount(x ^ y);\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/BitManipulation/maximumProductOfWordLengths.java b/BitManipulation/maximumProductOfWordLengths.java\n--- a/BitManipulation/maximumProductOfWordLengths.java\n+++ b/BitManipulation/maximumProductOfWordLengths.java\n@@ -0,0 +1,61 @@\n+// Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.\n+\n+// Example 1:\n+// Given [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"]\n+// Return 16\n+// The two words can be \"abcw\", \"xtfn\".\n+\n+// Example 2:\n+// Given [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"]\n+// Return 4\n+// The two words can be \"ab\", \"cd\".\n+\n+// Example 3:\n+// Given [\"a\", \"aa\", \"aaa\", \"aaaa\"]\n+// Return 0\n+// No such pair of words.\n+\n+public class Solution {\n+\n+    public int maxProduct(String[] words) {\n+        \n+        if(words.length == 0 || words == null) return 0;\n+        \n+        int length = words.length;\n+        int[] value = new int[length];\n+        int max = 0;\n+        \n+        for(int i = 0; i < length; i++) {\n+            \n+            String temp = words[i];\n+            \n+            value[i] = 0;\n+            \n+            for(int j = 0; j < temp.length(); j++) {\n+                \n+                value[i] |= 1 << (temp.charAt(j) - 'a');\n+                \n+            }\n+            \n+        }\n+        \n+        \n+        for(int i = 0; i < length; i++) {\n+            \n+            for(int j = 1; j < length; j++) {\n+                \n+                if((value[i] & value[j]) == 0 && (words[i].length() * words[j].length()) > max) {\n+                    \n+                    max = words[i].length() * words[j].length();\n+                    \n+                }\n+                \n+            }\n+            \n+        }\n+        \n+        return max;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/BitManipulation/numberOf1Bits.java b/BitManipulation/numberOf1Bits.java\n--- a/BitManipulation/numberOf1Bits.java\n+++ b/BitManipulation/numberOf1Bits.java\n@@ -0,0 +1,25 @@\n+// Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).\n+\n+// For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.\n+\n+public class Solution {\n+\n+    // you need to treat n as an unsigned value\n+    public int hammingWeight(int n) {\n+        \n+        if(n == 0) return 0;\n+        \n+        int count = 0;\n+        \n+        while(n != 0) {\n+            \n+            count += (n) & 1;\n+            n >>>= 1;\n+            \n+        }\n+        \n+        return count;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/BitManipulation/sumOfTwoIntegers.java b/BitManipulation/sumOfTwoIntegers.java\n--- a/BitManipulation/sumOfTwoIntegers.java\n+++ b/BitManipulation/sumOfTwoIntegers.java\n@@ -0,0 +1,25 @@\n+// Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.\n+\n+// Example:\n+// Given a = 1 and b = 2, return 3.\n+\n+public class Solution {\n+\n+    public int getSum(int a, int b) {\n+        \n+        if(a == 0) return b;\n+        if(b == 0) return a;\n+        \n+        while(b != 0) {\n+            \n+            int carry = a & b;\n+            a = a ^ b;\n+            b = carry << 1;\n+            \n+        }\n+        \n+        return a;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/BitManipulation/utf-8Validation.java b/BitManipulation/utf-8Validation.java\n--- a/BitManipulation/utf-8Validation.java\n+++ b/BitManipulation/utf-8Validation.java\n@@ -0,0 +1,63 @@\n+// A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\n+\n+// For 1-byte character, the first bit is a 0, followed by its unicode code.\n+// For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.\n+// This is how the UTF-8 encoding would work:\n+\n+//    Char. number range  |        UTF-8 octet sequence\n+//       (hexadecimal)    |              (binary)\n+//    --------------------+---------------------------------------------\n+//    0000 0000-0000 007F | 0xxxxxxx\n+//    0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n+//    0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n+//    0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+// Given an array of integers representing the data, return whether it is a valid utf-8 encoding.\n+\n+// Note:\n+// The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\n+\n+// Example 1:\n+\n+// data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.\n+\n+// Return true.\n+// It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n+// Example 2:\n+\n+// data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.\n+\n+// Return false.\n+// The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\n+// The next byte is a continuation byte which starts with 10 and that's correct.\n+// But the second continuation byte does not start with 10, so it is invalid.\n+\n+public class Solution {\n+\n+    public boolean validUtf8(int[] data) {\n+        \n+        int count = 0;\n+        for(int i : data) {\n+            \n+            if(count == 0) {\n+                \n+                if((i >> 5) == 0b110) count = 1;\n+                else if((i >> 4) == 0b1110) count = 2;\n+                else if((i >> 3) == 0b11110) count = 3;\n+                else if((i >> 7) == 0b1) return false;\n+                \n+            }\n+            \n+            else {\n+                \n+                if((i >> 6) != 0b10) return false;\n+                count--;\n+                \n+            }\n+            \n+        }\n+        \n+        return count == 0;\n+        \n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "added BitManipulation"
  },
  {
    "input": "diff --git a/longestPalindrome.java b/longestPalindrome.java\n--- a/longestPalindrome.java\n+++ b/longestPalindrome.java\n@@ -1,30 +0,0 @@\n-public class Solution {\n-\n-    public int longestPalindrome(String s) {\n-        \n-        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\n-        \n-        int count = 0;\n-        \n-        for(int i = 0; i < s.length(); i++) {\n-            \n-            if(!map.containsKey(s.charAt(i))) {\n-                \n-                map.put(s.charAt(i), (int)(s.charAt(i)));\n-                \n-            }\n-            \n-            else {\n-                \n-                map.remove(s.charAt(i));\n-                count++;\n-                \n-            }\n-            \n-        }\n-        \n-        return map.isEmpty() ? count * 2 : count * 2 + 1;\n-        \n-    }\n-    \n-}\n\\ No newline at end of file\n\ndiff --git a/palindromeLinkedList.java b/palindromeLinkedList.java\n--- a/palindromeLinkedList.java\n+++ b/palindromeLinkedList.java\n@@ -1,45 +0,0 @@\n-/**\n- * Definition for singly-linked list.\n- * public class ListNode {\n- *     int val;\n- *     ListNode next;\n- *     ListNode(int x) { val = x; }\n- * }\n- */\n-public class Solution {\n-\n-    public boolean isPalindrome(ListNode head) {\n-        \n-        if(head == null || head.next == null) return true;\n-        \n-        Stack<Integer> stack = new Stack<Integer>();\n-        \n-        ListNode fast = head;\n-        ListNode slow = head;\n-\n-        while(fast != null && fast.next != null) {\n-            \n-            stack.push(slow.val);\n-            fast = fast.next.next;\n-            slow = slow.next;\n-            \n-        }\n-        \n-        if(fast != null) {\n-            \n-            slow = slow.next;\n-            \n-        }\n-        \n-        while(slow != null) {\n-            \n-            if(stack.pop() != slow.val) return false;\n-            slow = slow.next;\n-            \n-        }\n-        \n-        return true;\n-        \n-    }\n-    \n-}\n\\ No newline at end of file\n\ndiff --git a/palindromePermutation.java b/palindromePermutation.java\n--- a/palindromePermutation.java\n+++ b/palindromePermutation.java\n@@ -1,35 +0,0 @@\n-public class Solution {\n-\n-    public boolean canPermutePalindrome(String s) {\n-        \n-        char[] characters = new char[256];\n-        \n-        for(int i = 0; i < s.length(); i++) {\n-            \n-            characters[s.charAt(i)]++;\n-            \n-        }\n-        \n-        int oddCount = 0;\n-        \n-        for(int i = 0; i < characters.length; i++) {\n-            \n-            if(!(characters[i] % 2 == 0)) {\n-                \n-                oddCount++;\n-                \n-                if(oddCount > 1) {\n-                    \n-                    return false;\n-                    \n-                }\n-                \n-            }\n-            \n-        }\n-        \n-        return true;\n-        \n-    }\n-    \n-}\n\\ No newline at end of file\n\ndiff --git a/validPalindrome.java b/validPalindrome.java\n--- a/validPalindrome.java\n+++ b/validPalindrome.java\n@@ -1,24 +0,0 @@\n-public class Solution {\n-\n-    public boolean isPalindrome(String s) {\n-        \n-        int left = 0;\n-        int right = s.length() - 1;\n-        \n-        while(left < right) {\n-            \n-            while(!Character.isLetterOrDigit(s.charAt(left)) && left < right) left++;\n-            while(!Character.isLetterOrDigit(s.charAt(right)) && right > left) right--;\n-            \n-            if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) return false;\n-            \n-            left++;\n-            right--;\n-            \n-        }\n-        \n-        return true;\n-        \n-    }\n-    \n-}\n\\ No newline at end of file",
    "output": "cleaned up repo"
  },
  {
    "input": "diff --git a/LinkedList/addTwoNumbers.java b/LinkedList/addTwoNumbers.java\n--- a/LinkedList/addTwoNumbers.java\n+++ b/LinkedList/addTwoNumbers.java\n@@ -0,0 +1,62 @@\n+// You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n+\n+// You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n+\n+// Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)\n+// Output: 7 -> 0 -> 8\n+\n+/**\n+ * Definition for singly-linked list.\n+ * public class ListNode {\n+ *     int val;\n+ *     ListNode next;\n+ *     ListNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n+        \n+        ListNode current1 = l1;\n+        ListNode current2 = l2;\n+        \n+        ListNode head = new ListNode(0);\n+        ListNode currentHead = head;\n+        \n+        int sum = 0;\n+        \n+        while(current1 != null || current2 != null) {\n+            \n+            sum /= 10;\n+            \n+            if(current1 != null) {\n+                \n+                sum += current1.val;\n+                current1 = current1.next;\n+                \n+            }\n+            \n+            if(current2 != null) {\n+                \n+                sum += current2.val;\n+                current2 = current2.next;\n+                \n+            }\n+            \n+            currentHead.next = new ListNode(sum % 10);\n+            currentHead = currentHead.next;\n+            \n+        }\n+        \n+        \n+        if(sum / 10 == 1) {\n+            \n+            currentHead.next = new ListNode(1);\n+            \n+        }\n+        \n+        return head.next;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/LinkedList/deleteNodeInALinkedList.java b/LinkedList/deleteNodeInALinkedList.java\n--- a/LinkedList/deleteNodeInALinkedList.java\n+++ b/LinkedList/deleteNodeInALinkedList.java\n@@ -0,0 +1,22 @@\n+// Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.\n+\n+// Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.\n+\n+/**\n+ * Definition for singly-linked list.\n+ * public class ListNode {\n+ *     int val;\n+ *     ListNode next;\n+ *     ListNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public void deleteNode(ListNode node) {\n+        \n+        node.val = node.next.val;\n+        node.next = node.next.next;\n+        \n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/LinkedList/mergeKSortedLists.java b/LinkedList/mergeKSortedLists.java\n--- a/LinkedList/mergeKSortedLists.java\n+++ b/LinkedList/mergeKSortedLists.java\n@@ -0,0 +1,46 @@\n+// Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n+\n+/**\n+ * Definition for singly-linked list.\n+ * public class ListNode {\n+ *     int val;\n+ *     ListNode next;\n+ *     ListNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public ListNode mergeKLists(ListNode[] lists) {\n+\n+        if (lists==null||lists.length==0) return null;\n+        \n+        PriorityQueue<ListNode> queue= new PriorityQueue<ListNode>(lists.length,new Comparator<ListNode>(){\n+            @Override\n+            public int compare(ListNode o1,ListNode o2){\n+                if (o1.val<o2.val)\n+                    return -1;\n+                else if (o1.val==o2.val)\n+                    return 0;\n+                else \n+                    return 1;\n+            }\n+        });\n+        \n+        ListNode dummy = new ListNode(0);\n+        ListNode tail=dummy;\n+        \n+        for (ListNode node:lists)\n+            if (node!=null)\n+                queue.add(node);\n+            \n+        while (!queue.isEmpty()){\n+            tail.next=queue.poll();\n+            tail=tail.next;\n+            \n+            if (tail.next!=null)\n+                queue.add(tail.next);\n+        }\n+        return dummy.next;\n+    }\n+\n+}\n\\ No newline at end of file\n\ndiff --git a/LinkedList/plusOneLinkedList.java b/LinkedList/plusOneLinkedList.java\n--- a/LinkedList/plusOneLinkedList.java\n+++ b/LinkedList/plusOneLinkedList.java\n@@ -0,0 +1,59 @@\n+// Given a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer.\n+\n+// You may assume the integer do not contain any leading zero, except the number 0 itself.\n+\n+// The digits are stored such that the most significant digit is at the head of the list.\n+\n+// Example:\n+// Input:\n+// 1->2->3\n+\n+// Output:\n+// 1->2->4\n+\n+/**\n+ * Definition for singly-linked list.\n+ * public class ListNode {\n+ *     int val;\n+ *     ListNode next;\n+ *     ListNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public ListNode plusOne(ListNode head) {\n+        \n+        if(plusOneRecursive(head) == 0) {\n+            \n+            return head;\n+            \n+        }\n+        \n+        else {\n+            \n+            ListNode newHead = new ListNode(1);\n+            \n+            newHead.next = head;\n+            \n+            return newHead;\n+            \n+        }\n+        \n+    }\n+    \n+    private int plusOneRecursive(ListNode head) {\n+        \n+        if(head == null) return 1;\n+        \n+        int carry = plusOneRecursive(head.next);\n+        \n+        if(carry == 0) return 0;\n+        \n+        int value = head.val + 1;\n+        head.val = value % 10;\n+        return value/10;\n+        \n+        \n+    }\n+    \n+}\n\\ No newline at end of file\n\ndiff --git a/LinkedList/reverseLinkedList.java b/LinkedList/reverseLinkedList.java\n--- a/LinkedList/reverseLinkedList.java\n+++ b/LinkedList/reverseLinkedList.java\n@@ -0,0 +1,32 @@\n+// Reverse a singly linked list.\n+\n+/**\n+ * Definition for singly-linked list.\n+ * public class ListNode {\n+ *     int val;\n+ *     ListNode next;\n+ *     ListNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public ListNode reverseList(ListNode head) {\n+        \n+        if(head == null) return head;\n+    \n+        ListNode newHead = null;\n+        \n+        while(head != null) {\n+            \n+            ListNode next = head.next;\n+            head.next = newHead;\n+            newHead = head;\n+            head = next;\n+            \n+        }\n+        \n+        return newHead;\n+        \n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "added to Linked List"
  },
  {
    "input": "diff --git a/String/reverseVowelsOfAString.java b/String/reverseVowelsOfAString.java\n--- a/String/reverseVowelsOfAString.java\n+++ b/String/reverseVowelsOfAString.java\n@@ -0,0 +1,53 @@\n+// Write a function that takes a string as input and reverse only the vowels of a string.\n+\n+// Example 1:\n+// Given s = \"hello\", return \"holle\".\n+\n+// Example 2:\n+// Given s = \"leetcode\", return \"leotcede\".\n+\n+// Note:\n+// The vowels does not include the letter \"y\".\n+\n+public class Solution {\n+\n+    public String reverseVowels(String s) {\n+        \n+        if(s == null || s.length() == 0) return s;\n+        \n+        String vowels = \"aeiouAEIOU\";\n+        \n+        char[] chars = s.toCharArray();\n+        \n+        int start = 0;\n+        int end = s.length() - 1;\n+        \n+        while(start < end) {\n+            \n+            while(start < end && !vowels.contains(chars[start] + \"\")) {\n+                \n+                start++;\n+                \n+            }\n+            \n+            while(start < end && !vowels.contains(chars[end] + \"\")) {\n+                \n+                end--;\n+                \n+            }\n+            \n+            \n+            char temp = chars[start];\n+            chars[start] = chars[end];\n+            chars[end] = temp;\n+            \n+            start++;\n+            end--;\n+            \n+        }\n+        \n+        return new String(chars);\n+        \n+    }\n+\n+}\n\\ No newline at end of file",
    "output": "added reverseVowelsOfAString"
  },
  {
    "input": "diff --git a/palindromePermutation.java b/palindromePermutation.java\n--- a/palindromePermutation.java\n+++ b/palindromePermutation.java\n@@ -0,0 +1,35 @@\n+public class Solution {\n+\n+    public boolean canPermutePalindrome(String s) {\n+        \n+        char[] characters = new char[256];\n+        \n+        for(int i = 0; i < s.length(); i++) {\n+            \n+            characters[s.charAt(i)]++;\n+            \n+        }\n+        \n+        int oddCount = 0;\n+        \n+        for(int i = 0; i < characters.length; i++) {\n+            \n+            if(!(characters[i] % 2 == 0)) {\n+                \n+                oddCount++;\n+                \n+                if(oddCount > 1) {\n+                    \n+                    return false;\n+                    \n+                }\n+                \n+            }\n+            \n+        }\n+        \n+        return true;\n+        \n+    }\n+    \n+}\n\\ No newline at end of file",
    "output": "added palindromePermutation"
  },
  {
    "input": "diff --git a/palindromeLinkedList.java b/palindromeLinkedList.java\n--- a/palindromeLinkedList.java\n+++ b/palindromeLinkedList.java\n@@ -0,0 +1,45 @@\n+/**\n+ * Definition for singly-linked list.\n+ * public class ListNode {\n+ *     int val;\n+ *     ListNode next;\n+ *     ListNode(int x) { val = x; }\n+ * }\n+ */\n+public class Solution {\n+\n+    public boolean isPalindrome(ListNode head) {\n+        \n+        if(head == null || head.next == null) return true;\n+        \n+        Stack<Integer> stack = new Stack<Integer>();\n+        \n+        ListNode fast = head;\n+        ListNode slow = head;\n+\n+        while(fast != null && fast.next != null) {\n+            \n+            stack.push(slow.val);\n+            fast = fast.next.next;\n+            slow = slow.next;\n+            \n+        }\n+        \n+        if(fast != null) {\n+            \n+            slow = slow.next;\n+            \n+        }\n+        \n+        while(slow != null) {\n+            \n+            if(stack.pop() != slow.val) return false;\n+            slow = slow.next;\n+            \n+        }\n+        \n+        return true;\n+        \n+    }\n+    \n+}\n\\ No newline at end of file",
    "output": "added palindromeLinkedList"
  },
  {
    "input": "diff --git a/longestPalindrome.java b/longestPalindrome.java\n--- a/longestPalindrome.java\n+++ b/longestPalindrome.java\n@@ -0,0 +1,30 @@\n+public class Solution {\n+\n+    public int longestPalindrome(String s) {\n+        \n+        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\n+        \n+        int count = 0;\n+        \n+        for(int i = 0; i < s.length(); i++) {\n+            \n+            if(!map.containsKey(s.charAt(i))) {\n+                \n+                map.put(s.charAt(i), (int)(s.charAt(i)));\n+                \n+            }\n+            \n+            else {\n+                \n+                map.remove(s.charAt(i));\n+                count++;\n+                \n+            }\n+            \n+        }\n+        \n+        return map.isEmpty() ? count * 2 : count * 2 + 1;\n+        \n+    }\n+    \n+}\n\\ No newline at end of file",
    "output": "added longestPalindrome"
  },
  {
    "input": "diff --git a/validPalindrome.java b/validPalindrome.java\n--- a/validPalindrome.java\n+++ b/validPalindrome.java\n@@ -0,0 +1,24 @@\n+public class Solution {\n+\n+    public boolean isPalindrome(String s) {\n+        \n+        int left = 0;\n+        int right = s.length() - 1;\n+        \n+        while(left < right) {\n+            \n+            while(!Character.isLetterOrDigit(s.charAt(left)) && left < right) left++;\n+            while(!Character.isLetterOrDigit(s.charAt(right)) && right > left) right--;\n+            \n+            if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) return false;\n+            \n+            left++;\n+            right--;\n+            \n+        }\n+        \n+        return true;\n+        \n+    }\n+    \n+}\n\\ No newline at end of file",
    "output": "validPalindrome added"
  }
]