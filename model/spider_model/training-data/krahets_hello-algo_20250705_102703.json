[
  {
    "input": "diff --git a/codes/java/chapter_sorting/merge_sort.java b/codes/java/chapter_sorting/merge_sort.java\n--- a/codes/java/chapter_sorting/merge_sort.java\n+++ b/codes/java/chapter_sorting/merge_sort.java\n@@ -42,7 +42,7 @@ static void mergeSort(int[] nums, int left, int right) {\n         if (left >= right)\n             return; // 当子数组长度为 1 时终止递归\n         // 划分阶段\n-        int mid = (left + right) / 2; // 计算中点\n+        int mid = left + (right - left) / 2; // 计算中点\n         mergeSort(nums, left, mid); // 递归左子数组\n         mergeSort(nums, mid + 1, right); // 递归右子数组\n         // 合并阶段\n\ndiff --git a/en/codes/java/chapter_divide_and_conquer/binary_search_recur.java b/en/codes/java/chapter_divide_and_conquer/binary_search_recur.java\n--- a/en/codes/java/chapter_divide_and_conquer/binary_search_recur.java\n+++ b/en/codes/java/chapter_divide_and_conquer/binary_search_recur.java\n@@ -14,7 +14,7 @@ static int dfs(int[] nums, int target, int i, int j) {\n             return -1;\n         }\n         // Calculate midpoint index m\n-        int m = (i + j) / 2;\n+        int m = i + (j - i) / 2;\n         if (nums[m] < target) {\n             // Recursive subproblem f(m+1, j)\n             return dfs(nums, target, m + 1, j);\n\ndiff --git a/en/codes/java/chapter_sorting/merge_sort.java b/en/codes/java/chapter_sorting/merge_sort.java\n--- a/en/codes/java/chapter_sorting/merge_sort.java\n+++ b/en/codes/java/chapter_sorting/merge_sort.java\n@@ -42,7 +42,7 @@ static void mergeSort(int[] nums, int left, int right) {\n         if (left >= right)\n             return; // Terminate recursion when subarray length is 1\n         // Partition stage\n-        int mid = (left + right) / 2; // Calculate midpoint\n+        int mid = left + (right - left) / 2; // Calculate midpoint\n         mergeSort(nums, left, mid); // Recursively process the left subarray\n         mergeSort(nums, mid + 1, right); // Recursively process the right subarray\n         // Merge stage\n\ndiff --git a/zh-hant/codes/java/chapter_sorting/merge_sort.java b/zh-hant/codes/java/chapter_sorting/merge_sort.java\n--- a/zh-hant/codes/java/chapter_sorting/merge_sort.java\n+++ b/zh-hant/codes/java/chapter_sorting/merge_sort.java\n@@ -42,7 +42,7 @@ static void mergeSort(int[] nums, int left, int right) {\n         if (left >= right)\n             return; // 當子陣列長度為 1 時終止遞迴\n         // 劃分階段\n-        int mid = (left + right) / 2; // 計算中點\n+        int mid = left + (right - left) / 2; // 計算中點\n         mergeSort(nums, left, mid); // 遞迴左子陣列\n         mergeSort(nums, mid + 1, right); // 遞迴右子陣列\n         // 合併階段",
    "output": "[Rust] Normalize mid calculation in case overflow (#1363)\n\n* Normalize mid calculate in case overflow\r\n\r\n* Change ALL language\r\n\r\n* Update merge_sort.py\r\n\r\n* Update merge_sort.zig\r\n\r\n* Update binary_search_tree.zig\r\n\r\n* Update binary_search_recur.py\r\n\r\n---------\r\n\r\nCo-authored-by: Yudong Jin <krahets@163.com>"
  },
  {
    "input": "diff --git a/zh-hant/codes/java/chapter_sorting/radix_sort.java b/zh-hant/codes/java/chapter_sorting/radix_sort.java\n--- a/zh-hant/codes/java/chapter_sorting/radix_sort.java\n+++ b/zh-hant/codes/java/chapter_sorting/radix_sort.java\n@@ -50,12 +50,13 @@ static void radixSort(int[] nums) {\n             if (num > m)\n                 m = num;\n         // 按照從低位到高位的順序走訪\n-        for (int exp = 1; exp <= m; exp *= 10)\n+        for (int exp = 1; exp <= m; exp *= 10) {\n             // 對陣列元素的第 k 位執行計數排序\n             // k = 1 -> exp = 1\n             // k = 2 -> exp = 10\n             // 即 exp = 10^(k-1)\n             countingSortDigit(nums, exp);\n+        }\n     }\n \n     public static void main(String[] args) {",
    "output": "Many bug fixes and improvements (#1270)\n\n* Add Ruby and Kotlin icons\r\nAdd the avatar of @curtishd\r\n\r\n* Update README\r\n\r\n* Synchronize zh-hant and zh versions.\r\n\r\n* Translate the pythontutor blocks to traditional Chinese\r\n\r\n* Fix en/mkdocs.yml\r\n\r\n* Update the landing page of the en version.\r\n\r\n* Fix the Dockerfile\r\n\r\n* Refine the en landingpage\r\n\r\n* Fix en landing page\r\n\r\n* Reset the README.md"
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/time_complexity.java b/codes/java/chapter_computational_complexity/time_complexity.java\n--- a/codes/java/chapter_computational_complexity/time_complexity.java\n+++ b/codes/java/chapter_computational_complexity/time_complexity.java\n@@ -87,7 +87,7 @@ static int expRecur(int n) {\n     }\n \n     /* 对数阶（循环实现） */\n-    static int logarithmic(float n) {\n+    static int logarithmic(int n) {\n         int count = 0;\n         while (n > 1) {\n             n = n / 2;\n@@ -97,14 +97,14 @@ static int logarithmic(float n) {\n     }\n \n     /* 对数阶（递归实现） */\n-    static int logRecur(float n) {\n+    static int logRecur(int n) {\n         if (n <= 1)\n             return 0;\n         return logRecur(n / 2) + 1;\n     }\n \n     /* 线性对数阶 */\n-    static int linearLogRecur(float n) {\n+    static int linearLogRecur(int n) {\n         if (n <= 1)\n             return 1;\n         int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n@@ -153,12 +153,12 @@ public static void main(String[] args) {\n         count = expRecur(n);\n         System.out.println(\"指数阶（递归实现）的操作数量 = \" + count);\n \n-        count = logarithmic((float) n);\n+        count = logarithmic(n);\n         System.out.println(\"对数阶（循环实现）的操作数量 = \" + count);\n-        count = logRecur((float) n);\n+        count = logRecur(n);\n         System.out.println(\"对数阶（递归实现）的操作数量 = \" + count);\n \n-        count = linearLogRecur((float) n);\n+        count = linearLogRecur(n);\n         System.out.println(\"线性对数阶（递归实现）的操作数量 = \" + count);\n \n         count = factorialRecur(n);",
    "output": "fix: Use int instead of float for the example code of log time complexity (#1164)\n\n* Use int instead of float for the example code of log time complexity\r\n\r\n* Bug fixes\r\n\r\n* Bug fixes"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/quick_sort.java b/codes/java/chapter_sorting/quick_sort.java\n--- a/codes/java/chapter_sorting/quick_sort.java\n+++ b/codes/java/chapter_sorting/quick_sort.java\n@@ -56,14 +56,12 @@ static void swap(int[] nums, int i, int j) {\n \n     /* 选取三个候选元素的中位数 */\n     static int medianThree(int[] nums, int left, int mid, int right) {\n-        // 此处使用异或运算来简化代码\n-        // 异或规则为 0 ^ 0 = 1 ^ 1 = 0, 0 ^ 1 = 1 ^ 0 = 1\n-        if ((nums[left] < nums[mid]) ^ (nums[left] < nums[right]))\n-            return left;\n-        else if ((nums[mid] < nums[left]) ^ (nums[mid] < nums[right]))\n-            return mid;\n-        else\n-            return right;\n+        int l = nums[left], m = nums[mid], r = nums[right];\n+        if ((l <= m && m <= r) || (r <= m && m <= l))\n+            return mid; // m 在 l 和 r 之间\n+        if ((m <= l && l <= r) || (r <= l && l <= m))\n+            return left; // l 在 m 和 r 之间\n+        return right;\n     }\n \n     /* 哨兵划分（三数取中值） */",
    "output": "Fix the median_three mehod for quick sort (#1134)\n\n* Add the section of terminologies.\r\n\r\n* fix format\r\n\r\n* Fix median_three function for quick sort\r\n\r\n* Delete docs/chapter_appendix/terminologies.md\r\n\r\n* Update quick_sort.ts\r\n\r\n* Update quick_sort.rs\r\n\r\n* Update quick_sort.js"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/array_binary_tree.java b/codes/java/chapter_tree/array_binary_tree.java\n--- a/codes/java/chapter_tree/array_binary_tree.java\n+++ b/codes/java/chapter_tree/array_binary_tree.java\n@@ -63,15 +63,15 @@ private void dfs(Integer i, String order, List<Integer> res) {\n         if (val(i) == null)\n             return;\n         // 前序遍历\n-        if (order == \"pre\")\n+        if (\"pre\".equals(order))\n             res.add(val(i));\n         dfs(left(i), order, res);\n         // 中序遍历\n-        if (order == \"in\")\n+        if (\"in\".equals(order))\n             res.add(val(i));\n         dfs(right(i), order, res);\n         // 后序遍历\n-        if (order == \"post\")\n+        if (\"post\".equals(order))\n             res.add(val(i));\n     }\n ",
    "output": "fix: Use .equals() to compare two strings in Java (#961)"
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/array.java b/codes/java/chapter_array_and_linkedlist/array.java\n--- a/codes/java/chapter_array_and_linkedlist/array.java\n+++ b/codes/java/chapter_array_and_linkedlist/array.java\n@@ -54,11 +54,11 @@ static void traverse(int[] nums) {\n         int count = 0;\n         // 通过索引遍历数组\n         for (int i = 0; i < nums.length; i++) {\n-            count++;\n+            count += nums[i];\n         }\n-        // 直接遍历数组\n+        // 直接遍历数组元素\n         for (int num : nums) {\n-            count++;\n+            count += num;\n         }\n     }\n \n\ndiff --git a/codes/java/chapter_array_and_linkedlist/list.java b/codes/java/chapter_array_and_linkedlist/list.java\n--- a/codes/java/chapter_array_and_linkedlist/list.java\n+++ b/codes/java/chapter_array_and_linkedlist/list.java\n@@ -17,8 +17,8 @@ public static void main(String[] args) {\n         System.out.println(\"列表 nums = \" + nums);\n \n         /* 访问元素 */\n-        int x = nums.get(1);\n-        System.out.println(\"访问索引 1 处的元素，得到 x = \" + x);\n+        int num = nums.get(1);\n+        System.out.println(\"访问索引 1 处的元素，得到 num = \" + num);\n \n         /* 更新元素 */\n         nums.set(1, 0);\n@@ -47,13 +47,11 @@ public static void main(String[] args) {\n         /* 通过索引遍历列表 */\n         int count = 0;\n         for (int i = 0; i < nums.size(); i++) {\n-            count++;\n+            count += nums.get(i);\n         }\n-\n         /* 直接遍历列表元素 */\n-        count = 0;\n-        for (int num : nums) {\n-            count++;\n+        for (int x : nums) {\n+            count += x;\n         }\n \n         /* 拼接两个列表 */\n\ndiff --git a/codes/java/chapter_dynamic_programming/climbing_stairs_backtrack.java b/codes/java/chapter_dynamic_programming/climbing_stairs_backtrack.java\n--- a/codes/java/chapter_dynamic_programming/climbing_stairs_backtrack.java\n+++ b/codes/java/chapter_dynamic_programming/climbing_stairs_backtrack.java\n@@ -18,7 +18,7 @@ public static void backtrack(List<Integer> choices, int state, int n, List<Integ\n         for (Integer choice : choices) {\n             // 剪枝：不允许越过第 n 阶\n             if (state + choice > n)\n-                break;\n+                continue;\n             // 尝试：做出选择，更新状态\n             backtrack(choices, state + choice, n, res);\n             // 回退",
    "output": "Several bug fixes and improvements (#945)\n\n* Update Dockerfile for code debugging.\r\n\r\n* Format Python code using Black.\r\n\r\n* Improve dark theme by defining html classes for the figures, animations and cover images.\r\n\r\n* Fix several glossary translation.\r\n\r\n* Update a code comment.\r\n\r\n* Fix climbing_stairs_backtrack: the pruning should not require the sorted choices list.\r\n\r\n* Update the code of array and list traversal.\r\n\r\n* Fix a rendering issue of README.md\r\n\r\n* Update code of list traversal.\r\n\r\n* Fix array_definition.png\r\n\r\n* Update README.md\r\n\r\n* Fix max_capacity_moving_short_board.png\r\n\r\n* Fix array.dart\r\n\r\n* Fix array.dart\r\n\r\n* Fix array.dart\r\n\r\n* Fix array.dart"
  },
  {
    "input": "diff --git a/codes/java/utils/PrintUtil.java b/codes/java/utils/PrintUtil.java\n--- a/codes/java/utils/PrintUtil.java\n+++ b/codes/java/utils/PrintUtil.java\n@@ -58,7 +58,7 @@ public static void printTree(TreeNode root) {\n     }\n \n     /* Print a binary tree */\n-    public static void printTree(TreeNode root, Trunk prev, boolean isLeft) {\n+    public static void printTree(TreeNode root, Trunk prev, boolean isRight) {\n         if (root == null) {\n             return;\n         }\n@@ -70,7 +70,7 @@ public static void printTree(TreeNode root, Trunk prev, boolean isLeft) {\n \n         if (prev == null) {\n             trunk.str = \"———\";\n-        } else if (isLeft) {\n+        } else if (isRight) {\n             trunk.str = \"/———\";\n             prev_str = \"   |\";\n         } else {",
    "output": "Bug fixes to C code."
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/merge_sort.java b/codes/java/chapter_sorting/merge_sort.java\n--- a/codes/java/chapter_sorting/merge_sort.java\n+++ b/codes/java/chapter_sorting/merge_sort.java\n@@ -10,39 +10,40 @@\n \n public class merge_sort {\n     /* 合并左子数组和右子数组 */\n-    // 左子数组区间 [left, mid]\n-    // 右子数组区间 [mid + 1, right]\n     static void merge(int[] nums, int left, int mid, int right) {\n-        // 初始化辅助数组\n-        int[] tmp = Arrays.copyOfRange(nums, left, right + 1);\n-        // 左子数组的起始索引和结束索引\n-        int leftStart = left - left, leftEnd = mid - left;\n-        // 右子数组的起始索引和结束索引\n-        int rightStart = mid + 1 - left, rightEnd = right - left;\n-        // i, j 分别指向左子数组、右子数组的首元素\n-        int i = leftStart, j = rightStart;\n-        // 通过覆盖原数组 nums 来合并左子数组和右子数组\n-        for (int k = left; k <= right; k++) {\n-            // 若“左子数组已全部合并完”，则选取右子数组元素，并且 j++\n-            if (i > leftEnd)\n-                nums[k] = tmp[j++];\n-            // 否则，若“右子数组已全部合并完”或“左子数组元素 <= 右子数组元素”，则选取左子数组元素，并且 i++\n-            else if (j > rightEnd || tmp[i] <= tmp[j])\n-                nums[k] = tmp[i++];\n-            // 否则，若“左右子数组都未全部合并完”且“左子数组元素 > 右子数组元素”，则选取右子数组元素，并且 j++\n+        // 左子数组区间 [left, mid], 右子数组区间 [mid+1, right]\n+        // 创建一个临时数组 tmp ，用于存放合并后的结果\n+        int[] tmp = new int[right - left + 1];\n+        // 初始化左子数组和右子数组的起始索引\n+        int i = left, j = mid + 1, k = 0;\n+        // 当左右子数组都还有元素时，比较并将较小的元素复制到临时数组中\n+        while (i <= mid && j <= right) {\n+            if (nums[i] <= nums[j])\n+                tmp[k++] = nums[i++];\n             else\n-                nums[k] = tmp[j++];\n+                tmp[k++] = nums[j++];\n+        }\n+        // 将左子数组和右子数组的剩余元素复制到临时数组中\n+        while (i <= mid) {\n+            tmp[k++] = nums[i++];\n+        }\n+        while (j <= right) {\n+            tmp[k++] = nums[j++];\n+        }\n+        // 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间\n+        for (k = 0; k < tmp.length; k++) {\n+            nums[left + k] = tmp[k];\n         }\n     }\n \n     /* 归并排序 */\n     static void mergeSort(int[] nums, int left, int right) {\n         // 终止条件\n         if (left >= right)\n-            return;                      // 当子数组长度为 1 时终止递归\n+            return; // 当子数组长度为 1 时终止递归\n         // 划分阶段\n-        int mid = (left + right) / 2;    // 计算中点\n-        mergeSort(nums, left, mid);      // 递归左子数组\n+        int mid = (left + right) / 2; // 计算中点\n+        mergeSort(nums, left, mid); // 递归左子数组\n         mergeSort(nums, mid + 1, right); // 递归右子数组\n         // 合并阶段\n         merge(nums, left, mid, right);",
    "output": "Re-implement merge sort function. (#888)"
  },
  {
    "input": "diff --git a/codes/java/chapter_dynamic_programming/min_path_sum.java b/codes/java/chapter_dynamic_programming/min_path_sum.java\n--- a/codes/java/chapter_dynamic_programming/min_path_sum.java\n+++ b/codes/java/chapter_dynamic_programming/min_path_sum.java\n@@ -20,8 +20,8 @@ static int minPathSumDFS(int[][] grid, int i, int j) {\n             return Integer.MAX_VALUE;\n         }\n         // 计算从左上角到 (i-1, j) 和 (i, j-1) 的最小路径代价\n-        int left = minPathSumDFS(grid, i - 1, j);\n-        int up = minPathSumDFS(grid, i, j - 1);\n+        int up = minPathSumDFS(grid, i - 1, j);\n+        int left = minPathSumDFS(grid, i, j - 1);\n         // 返回从左上角到 (i, j) 的最小路径代价\n         return Math.min(left, up) + grid[i][j];\n     }\n@@ -41,8 +41,8 @@ static int minPathSumDFSMem(int[][] grid, int[][] mem, int i, int j) {\n             return mem[i][j];\n         }\n         // 左边和上边单元格的最小路径代价\n-        int left = minPathSumDFSMem(grid, mem, i - 1, j);\n-        int up = minPathSumDFSMem(grid, mem, i, j - 1);\n+        int up = minPathSumDFSMem(grid, mem, i - 1, j);\n+        int left = minPathSumDFSMem(grid, mem, i, j - 1);\n         // 记录并返回左上角到 (i, j) 的最小路径代价\n         mem[i][j] = Math.min(left, up) + grid[i][j];\n         return mem[i][j];",
    "output": "Fix the code in min_path_sum"
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/time_complexity.java b/codes/java/chapter_computational_complexity/time_complexity.java\n--- a/codes/java/chapter_computational_complexity/time_complexity.java\n+++ b/codes/java/chapter_computational_complexity/time_complexity.java\n@@ -107,8 +107,7 @@ static int logRecur(float n) {\n     static int linearLogRecur(float n) {\n         if (n <= 1)\n             return 1;\n-        int count = linearLogRecur(n / 2) +\n-                linearLogRecur(n / 2);\n+        int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);\n         for (int i = 0; i < n; i++) {\n             count++;\n         }",
    "output": "fix: Polishing code format on linearLogRecur, convert String type to string (#841)"
  },
  {
    "input": "diff --git a/codes/java/chapter_hashing/hash_map_chaining.java b/codes/java/chapter_hashing/hash_map_chaining.java\n--- a/codes/java/chapter_hashing/hash_map_chaining.java\n+++ b/codes/java/chapter_hashing/hash_map_chaining.java\n@@ -21,7 +21,7 @@ class HashMapChaining {\n     public HashMapChaining() {\n         size = 0;\n         capacity = 4;\n-        loadThres = 2 / 3.0;\n+        loadThres = 2.0 / 3.0;\n         extendRatio = 2;\n         buckets = new ArrayList<>(capacity);\n         for (int i = 0; i < capacity; i++) {\n\ndiff --git a/codes/java/chapter_hashing/hash_map_open_addressing.java b/codes/java/chapter_hashing/hash_map_open_addressing.java\n--- a/codes/java/chapter_hashing/hash_map_open_addressing.java\n+++ b/codes/java/chapter_hashing/hash_map_open_addressing.java\n@@ -10,7 +10,7 @@\n class HashMapOpenAddressing {\n     private int size; // 键值对数量\n     private int capacity = 4; // 哈希表容量\n-    private final double loadThres = 2.0 / 3; // 触发扩容的负载因子阈值\n+    private final double loadThres = 2.0 / 3.0; // 触发扩容的负载因子阈值\n     private final int extendRatio = 2; // 扩容倍数\n     private Pair[] buckets; // 桶数组\n     private final Pair TOMBSTONE = new Pair(-1, \"-1\"); // 删除标记",
    "output": "Several bug fixes."
  },
  {
    "input": "diff --git a/codes/java/chapter_divide_and_conquer/build_tree.java b/codes/java/chapter_divide_and_conquer/build_tree.java\n--- a/codes/java/chapter_divide_and_conquer/build_tree.java\n+++ b/codes/java/chapter_divide_and_conquer/build_tree.java\n@@ -11,30 +11,30 @@\n \n public class build_tree {\n     /* 构建二叉树：分治 */\n-    static TreeNode dfs(int[] preorder, int[] inorder, Map<Integer, Integer> hmap, int i, int l, int r) {\n+    static TreeNode dfs(int[] preorder, Map<Integer, Integer> inorderMap, int i, int l, int r) {\n         // 子树区间为空时终止\n         if (r - l < 0)\n             return null;\n         // 初始化根节点\n         TreeNode root = new TreeNode(preorder[i]);\n         // 查询 m ，从而划分左右子树\n-        int m = hmap.get(preorder[i]);\n+        int m = inorderMap.get(preorder[i]);\n         // 子问题：构建左子树\n-        root.left = dfs(preorder, inorder, hmap, i + 1, l, m - 1);\n+        root.left = dfs(preorder, inorderMap, i + 1, l, m - 1);\n         // 子问题：构建右子树\n-        root.right = dfs(preorder, inorder, hmap, i + 1 + m - l, m + 1, r);\n+        root.right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r);\n         // 返回根节点\n         return root;\n     }\n \n     /* 构建二叉树 */\n     static TreeNode buildTree(int[] preorder, int[] inorder) {\n         // 初始化哈希表，存储 inorder 元素到索引的映射\n-        Map<Integer, Integer> hmap = new HashMap<>();\n+        Map<Integer, Integer> inorderMap = new HashMap<>();\n         for (int i = 0; i < inorder.length; i++) {\n-            hmap.put(inorder[i], i);\n+            inorderMap.put(inorder[i], i);\n         }\n-        TreeNode root = dfs(preorder, inorder, hmap, 0, 0, inorder.length - 1);\n+        TreeNode root = dfs(preorder, inorderMap, 0, 0, inorder.length - 1);\n         return root;\n     }\n ",
    "output": "fix build_tree, binary_search_tree.cs\nfix two figures"
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/linkedlist_deque.java b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n@@ -72,10 +72,9 @@ public void pushLast(int num) {\n     }\n \n     /* 出队操作 */\n-    private Integer pop(boolean isFront) {\n-        // 若队列为空，直接返回 null\n+    private int pop(boolean isFront) {\n         if (isEmpty())\n-            return null;\n+            throw new IndexOutOfBoundsException();\n         int val;\n         // 队首出队操作\n         if (isFront) {\n@@ -103,23 +102,27 @@ private Integer pop(boolean isFront) {\n     }\n \n     /* 队首出队 */\n-    public Integer popFirst() {\n+    public int popFirst() {\n         return pop(true);\n     }\n \n     /* 队尾出队 */\n-    public Integer popLast() {\n+    public int popLast() {\n         return pop(false);\n     }\n \n     /* 访问队首元素 */\n-    public Integer peekFirst() {\n-        return isEmpty() ? null : front.val;\n+    public int peekFirst() {\n+        if (isEmpty())\n+            throw new IndexOutOfBoundsException();\n+        return front.val;\n     }\n \n     /* 访问队尾元素 */\n-    public Integer peekLast() {\n-        return isEmpty() ? null : rear.val;\n+    public int peekLast() {\n+        if (isEmpty())\n+            throw new IndexOutOfBoundsException();\n+        return rear.val;\n     }\n \n     /* 返回数组用于打印 */\n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_queue.java b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n@@ -55,7 +55,7 @@ public int pop() {\n \n     /* 访问队首元素 */\n     public int peek() {\n-        if (size() == 0)\n+        if (isEmpty())\n             throw new IndexOutOfBoundsException();\n         return front.val;\n     }\n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_stack.java b/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n@@ -46,7 +46,7 @@ public int pop() {\n \n     /* 访问栈顶元素 */\n     public int peek() {\n-        if (size() == 0)\n+        if (isEmpty())\n             throw new IndexOutOfBoundsException();\n         return stackPeek.val;\n     }",
    "output": "Several enhancements and fixes"
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/iteration.java b/codes/java/chapter_computational_complexity/iteration.java\n--- a/codes/java/chapter_computational_complexity/iteration.java\n+++ b/codes/java/chapter_computational_complexity/iteration.java\n@@ -8,7 +8,7 @@\n \n public class iteration {\n     /* for 循环 */\n-    public static int forLoop(int n) {\n+    static int forLoop(int n) {\n         int res = 0;\n         // 循环求和 1, 2, ..., n-1, n\n         for (int i = 1; i <= n; i++) {\n@@ -18,7 +18,7 @@ public static int forLoop(int n) {\n     }\n \n     /* while 循环 */\n-    public static int whileLoop(int n) {\n+    static int whileLoop(int n) {\n         int res = 0;\n         int i = 1; // 初始化条件变量\n         // 循环求和 1, 2, ..., n-1, n\n@@ -30,7 +30,7 @@ public static int whileLoop(int n) {\n     }\n \n     /* while 循环（两次更新） */\n-    public static int whileLoopII(int n) {\n+    static int whileLoopII(int n) {\n         int res = 0;\n         int i = 1; // 初始化条件变量\n         // 循环求和 1, 4, ...\n@@ -44,7 +44,7 @@ public static int whileLoopII(int n) {\n     }\n \n     /* 双层 for 循环 */\n-    public static String nestedForLoop(int n) {\n+    static String nestedForLoop(int n) {\n         StringBuilder res = new StringBuilder();\n         // 循环 i = 1, 2, ..., n-1, n\n         for (int i = 1; i <= n; i++) {\n\ndiff --git a/codes/java/chapter_computational_complexity/recursion.java b/codes/java/chapter_computational_complexity/recursion.java\n--- a/codes/java/chapter_computational_complexity/recursion.java\n+++ b/codes/java/chapter_computational_complexity/recursion.java\n@@ -6,9 +6,11 @@\n \n package chapter_computational_complexity;\n \n+import java.util.Stack;\n+\n public class recursion {\n     /* 递归 */\n-    public static int recur(int n) {\n+    static int recur(int n) {\n         // 终止条件\n         if (n == 1)\n             return 1;\n@@ -18,8 +20,27 @@ public static int recur(int n) {\n         return n + res;\n     }\n \n+    /* 使用迭代模拟递归 */\n+    static int forLoopRecur(int n) {\n+        // 使用一个显式的栈来模拟系统调用栈\n+        Stack<Integer> stack = new Stack<>();\n+        int res = 0;\n+        // 递：递归调用\n+        for (int i = n; i > 0; i--) {\n+            // 通过“入栈操作”模拟“递”\n+            stack.push(i);\n+        }\n+        // 归：返回结果\n+        while (!stack.isEmpty()) {\n+            // 通过“出栈操作”模拟“归”\n+            res += stack.pop();\n+        }\n+        // res = 1+2+3+...+n\n+        return res;\n+    }\n+\n     /* 尾递归 */\n-    public static int tailRecur(int n, int res) {\n+    static int tailRecur(int n, int res) {\n         // 终止条件\n         if (n == 0)\n             return res;\n@@ -28,7 +49,7 @@ public static int tailRecur(int n, int res) {\n     }\n \n     /* 斐波那契数列：递归 */\n-    public static int fib(int n) {\n+    static int fib(int n) {\n         // 终止条件 f(1) = 0, f(2) = 1\n         if (n == 1 || n == 2)\n             return n - 1;\n@@ -46,6 +67,9 @@ public static void main(String[] args) {\n         res = recur(n);\n         System.out.println(\"\\n递归函数的求和结果 res = \" + res);\n \n+        res = forLoopRecur(n);\n+        System.out.println(\"\\n使用迭代模拟递归求和结果 res = \" + res);\n+\n         res = tailRecur(n, 0);\n         System.out.println(\"\\n尾递归函数的求和结果 res = \" + res);\n ",
    "output": "Add comparison between iteration and recursion.\nFix the figure of tail recursion.\nFix two links."
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n--- a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n+++ b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n@@ -24,8 +24,6 @@ static void preOrder(TreeNode root) {\n         if (root.val == 7) {\n             // 记录解\n             res.add(new ArrayList<>(path));\n-            path.remove(path.size() - 1);\n-            return;\n         }\n         preOrder(root.left);\n         preOrder(root.right);",
    "output": "fix preorder_traversal_iii_compact code"
  },
  {
    "input": "diff --git a/codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java b/codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java\n--- a/codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java\n+++ b/codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java\n@@ -10,7 +10,7 @@ public class climbing_stairs_constraint_dp {\n     /* 带约束爬楼梯：动态规划 */\n     static int climbingStairsConstraintDP(int n) {\n         if (n == 1 || n == 2) {\n-            return n;\n+            return 1;\n         }\n         // 初始化 dp 表，用于存储子问题的解\n         int[][] dp = new int[n + 1][3];",
    "output": "fix climbing_stairs_constraint_dp code"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -6,36 +6,23 @@\n \n package chapter_tree;\n \n-import java.util.*;\n import utils.*;\n \n /* 二叉搜索树 */\n class BinarySearchTree {\n     private TreeNode root;\n \n-    public BinarySearchTree(int[] nums) {\n-        Arrays.sort(nums); // 排序数组\n-        root = buildTree(nums, 0, nums.length - 1); // 构建二叉搜索树\n+    /* 构造方法 */\n+    public BinarySearchTree() {\n+        // 初始化空树\n+        root = null;\n     }\n \n     /* 获取二叉树根节点 */\n     public TreeNode getRoot() {\n         return root;\n     }\n \n-    /* 构建二叉搜索树 */\n-    public TreeNode buildTree(int[] nums, int i, int j) {\n-        if (i > j)\n-            return null;\n-        // 将数组中间节点作为根节点\n-        int mid = (i + j) / 2;\n-        TreeNode root = new TreeNode(nums[mid]);\n-        // 递归建立左子树和右子树\n-        root.left = buildTree(nums, i, mid - 1);\n-        root.right = buildTree(nums, mid + 1, j);\n-        return root;\n-    }\n-\n     /* 查找节点 */\n     public TreeNode search(int num) {\n         TreeNode cur = root;\n@@ -57,9 +44,11 @@ else if (cur.val > num)\n \n     /* 插入节点 */\n     public void insert(int num) {\n-        // 若树为空，直接提前返回\n-        if (root == null)\n+        // 若树为空，则初始化根节点\n+        if (root == null) {\n+            root = new TreeNode(num);\n             return;\n+        }\n         TreeNode cur = root, pre = null;\n         // 循环查找，越过叶节点后跳出\n         while (cur != null) {\n@@ -137,8 +126,12 @@ public void remove(int num) {\n public class binary_search_tree {\n     public static void main(String[] args) {\n         /* 初始化二叉搜索树 */\n-        int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n-        BinarySearchTree bst = new BinarySearchTree(nums);\n+        BinarySearchTree bst = new BinarySearchTree();\n+        // 请注意，不同的插入顺序会生成不同的二叉树，该序列可以生成一个完美二叉树\n+        int[] nums = { 8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15 };\n+        for (int num : nums) {\n+            bst.insert(num);\n+        }\n         System.out.println(\"\\n初始化的二叉树为\\n\");\n         PrintUtil.printTree(bst.getRoot());\n ",
    "output": "fix binary_search_tree code"
  },
  {
    "input": "diff --git a/codes/java/chapter_dynamic_programming/min_path_sum.java b/codes/java/chapter_dynamic_programming/min_path_sum.java\n--- a/codes/java/chapter_dynamic_programming/min_path_sum.java\n+++ b/codes/java/chapter_dynamic_programming/min_path_sum.java\n@@ -104,22 +104,22 @@ public static void main(String[] args) {\n \n         // 暴力搜索\n         int res = minPathSumDFS(grid, n - 1, m - 1);\n-        System.out.println(\"从左上角到右下角的做小路径和为 \" + res);\n+        System.out.println(\"从左上角到右下角的最小路径和为 \" + res);\n \n         // 记忆化搜索\n         int[][] mem = new int[n][m];\n         for (int[] row : mem) {\n             Arrays.fill(row, -1);\n         }\n         res = minPathSumDFSMem(grid, mem, n - 1, m - 1);\n-        System.out.println(\"从左上角到右下角的做小路径和为 \" + res);\n+        System.out.println(\"从左上角到右下角的最小路径和为 \" + res);\n \n         // 动态规划\n         res = minPathSumDP(grid);\n-        System.out.println(\"从左上角到右下角的做小路径和为 \" + res);\n+        System.out.println(\"从左上角到右下角的最小路径和为 \" + res);\n \n         // 空间优化后的动态规划\n         res = minPathSumDPComp(grid);\n-        System.out.println(\"从左上角到右下角的做小路径和为 \" + res);\n+        System.out.println(\"从左上角到右下角的最小路径和为 \" + res);\n     }\n }",
    "output": "feat: add dynamic programming code for JS and TS (#692)\n\n* fix: Correcting typos\r\n\r\n* Add JavaScript and TypeScript code of dynamic programming.\r\n\r\n* fix: Code Style\r\n\r\n* Change ==/!= to ===/!==\r\n* Create const by default, change to let if necessary.\r\n\r\n* style fix: Delete unnecessary defined type"
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/iteration.java b/codes/java/chapter_computational_complexity/iteration.java\n--- a/codes/java/chapter_computational_complexity/iteration.java\n+++ b/codes/java/chapter_computational_complexity/iteration.java\n@@ -24,7 +24,7 @@ public static int whileLoop(int n) {\n         // 循环求和 1, 2, ..., n-1, n\n         while (i <= n) {\n             res += i;\n-            i += 1; // 更新条件变量\n+            i++; // 更新条件变量\n         }\n         return res;\n     }\n@@ -33,12 +33,12 @@ public static int whileLoop(int n) {\n     public static int whileLoopII(int n) {\n         int res = 0;\n         int i = 1; // 初始化条件变量\n-        // 循环求和 1, 2, 4, 5...\n+        // 循环求和 1, 4, ...\n         while (i <= n) {\n             res += i;\n-            i += 1; // 更新条件变量\n-            res += i;\n-            i *= 2; // 更新条件变量\n+            // 更新条件变量\n+            i++;\n+            i *= 2;\n         }\n         return res;\n     }",
    "output": "Update iteration code."
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/iteration.java b/codes/java/chapter_computational_complexity/iteration.java\n--- a/codes/java/chapter_computational_complexity/iteration.java\n+++ b/codes/java/chapter_computational_complexity/iteration.java\n@@ -0,0 +1,76 @@\n+/**\n+ * File: iteration.java\n+ * Created Time: 2023-08-24\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_computational_complexity;\n+\n+public class iteration {\n+    /* for 循环 */\n+    public static int forLoop(int n) {\n+        int res = 0;\n+        // 循环求和 1, 2, ..., n-1, n\n+        for (int i = 1; i <= n; i++) {\n+            res += i;\n+        }\n+        return res;\n+    }\n+\n+    /* while 循环 */\n+    public static int whileLoop(int n) {\n+        int res = 0;\n+        int i = 1; // 初始化条件变量\n+        // 循环求和 1, 2, ..., n-1, n\n+        while (i <= n) {\n+            res += i;\n+            i += 1; // 更新条件变量\n+        }\n+        return res;\n+    }\n+\n+    /* while 循环（两次更新） */\n+    public static int whileLoopII(int n) {\n+        int res = 0;\n+        int i = 1; // 初始化条件变量\n+        // 循环求和 1, 2, 4, 5...\n+        while (i <= n) {\n+            res += i;\n+            i += 1; // 更新条件变量\n+            res += i;\n+            i *= 2; // 更新条件变量\n+        }\n+        return res;\n+    }\n+\n+    /* 双层 for 循环 */\n+    public static String nestedForLoop(int n) {\n+        StringBuilder res = new StringBuilder();\n+        // 循环 i = 1, 2, ..., n-1, n\n+        for (int i = 1; i <= n; i++) {\n+            // 循环 j = 1, 2, ..., n-1, n\n+            for (int j = 1; j <= n; j++) {\n+                res.append(\"(\" + i + \", \" + j + \"), \");\n+            }\n+        }\n+        return res.toString();\n+    }\n+\n+    /* Driver Code */\n+    public static void main(String[] args) {\n+        int n = 5;\n+        int res;\n+\n+        res = forLoop(n);\n+        System.out.println(\"\\nfor 循环的求和结果 res = \" + res);\n+\n+        res = whileLoop(n);\n+        System.out.println(\"\\nwhile 循环的求和结果 res = \" + res);\n+\n+        res = whileLoopII(n);\n+        System.out.println(\"\\nwhile 循环（两次更新）求和结果 res = \" + res);\n+\n+        String resStr = nestedForLoop(n);\n+        System.out.println(\"\\n双层 for 循环的遍历结果 \" + resStr);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_computational_complexity/recursion.java b/codes/java/chapter_computational_complexity/recursion.java\n--- a/codes/java/chapter_computational_complexity/recursion.java\n+++ b/codes/java/chapter_computational_complexity/recursion.java\n@@ -0,0 +1,55 @@\n+/**\n+ * File: recursion.java\n+ * Created Time: 2023-08-24\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_computational_complexity;\n+\n+public class recursion {\n+    /* 递归 */\n+    public static int recur(int n) {\n+        // 终止条件\n+        if (n == 1)\n+            return 1;\n+        // 递：递归调用\n+        int res = recur(n - 1);\n+        // 归：返回结果\n+        return n + res;\n+    }\n+\n+    /* 尾递归 */\n+    public static int tailRecur(int n, int res) {\n+        // 终止条件\n+        if (n == 0)\n+            return res;\n+        // 尾递归调用\n+        return tailRecur(n - 1, res + n);\n+    }\n+\n+    /* 斐波那契数列：递归 */\n+    public static int fib(int n) {\n+        // 终止条件 f(1) = 0, f(2) = 1\n+        if (n == 1 || n == 2)\n+            return n - 1;\n+        // 递归调用 f(n) = f(n-1) + f(n-2)\n+        int res = fib(n - 1) + fib(n - 2);\n+        // 返回结果 f(n)\n+        return res;\n+    }\n+\n+    /* Driver Code */\n+    public static void main(String[] args) {\n+        int n = 5;\n+        int res;\n+\n+        res = recur(n);\n+        System.out.println(\"\\n递归函数的求和结果 res = \" + res);\n+\n+        res = tailRecur(n, 0);\n+        System.out.println(\"\\n尾递归函数的求和结果 res = \" + res);\n+\n+        res = fib(n);\n+        System.out.println(\"\\n斐波那契数列的第 \" + n + \" 项为 \" + res);\n+    }\n+}",
    "output": "Add the section of iteration and recursion. (#693)"
  },
  {
    "input": "diff --git a/codes/java/chapter_greedy/coin_change_greedy.java b/codes/java/chapter_greedy/coin_change_greedy.java\n--- a/codes/java/chapter_greedy/coin_change_greedy.java\n+++ b/codes/java/chapter_greedy/coin_change_greedy.java\n@@ -17,7 +17,7 @@ static int coinChangeGreedy(int[] coins, int amt) {\n         // 循环进行贪心选择，直到无剩余金额\n         while (amt > 0) {\n             // 找到小于且最接近剩余金额的硬币\n-            while (coins[i] > amt) {\n+            while (i > 0 && coins[i] > amt) {\n                 i--;\n             }\n             // 选择 coins[i]\n\ndiff --git a/codes/java/chapter_heap/top_k.java b/codes/java/chapter_heap/top_k.java\n--- a/codes/java/chapter_heap/top_k.java\n+++ b/codes/java/chapter_heap/top_k.java\n@@ -15,14 +15,14 @@ static Queue<Integer> topKHeap(int[] nums, int k) {\n         Queue<Integer> heap = new PriorityQueue<Integer>();\n         // 将数组的前 k 个元素入堆\n         for (int i = 0; i < k; i++) {\n-            heap.add(nums[i]);\n+            heap.offer(nums[i]);\n         }\n         // 从第 k+1 个元素开始，保持堆的长度为 k\n         for (int i = k; i < nums.length; i++) {\n             // 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆\n             if (nums[i] > heap.peek()) {\n                 heap.poll();\n-                heap.add(nums[i]);\n+                heap.offer(nums[i]);\n             }\n         }\n         return heap;",
    "output": "Fix the content"
  },
  {
    "input": "diff --git a/codes/java/chapter_searching/binary_search_edge.java b/codes/java/chapter_searching/binary_search_edge.java\n--- a/codes/java/chapter_searching/binary_search_edge.java\n+++ b/codes/java/chapter_searching/binary_search_edge.java\n@@ -1,56 +1,49 @@\n /**\n  * File: binary_search_edge.java\n- * Created Time: 2023-05-21\n+ * Created Time: 2023-08-04\n  * Author: Krahets (krahets@163.com)\n  */\n \n package chapter_searching;\n \n public class binary_search_edge {\n-    /* 二分查找最左一个元素 */\n+    /* 二分查找最左一个 target */\n     static int binarySearchLeftEdge(int[] nums, int target) {\n-        int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1]\n-        while (i <= j) {\n-            int m = i + (j - i) / 2; // 计算中点索引 m\n-            if (nums[m] < target)\n-                i = m + 1; // target 在区间 [m+1, j] 中\n-            else if (nums[m] > target)\n-                j = m - 1; // target 在区间 [i, m-1] 中\n-            else\n-                j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中\n+        // 等价于查找 target 的插入点\n+        int i = binary_search_insertion.binarySearchInsertion(nums, target);\n+        // 未找到 target ，返回 -1\n+        if (i == nums.length || nums[i] != target) {\n+            return -1;\n         }\n-        if (i == nums.length || nums[i] != target)\n-            return -1; // 未找到目标元素，返回 -1\n+        // 找到 target ，返回索引 i\n         return i;\n     }\n \n-    /* 二分查找最右一个元素 */\n+    /* 二分查找最右一个 target */\n     static int binarySearchRightEdge(int[] nums, int target) {\n-        int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1]\n-        while (i <= j) {\n-            int m = i + (j - i) / 2; // 计算中点索引 m\n-            if (nums[m] < target)\n-                i = m + 1; // target 在区间 [m+1, j] 中\n-            else if (nums[m] > target)\n-                j = m - 1; // target 在区间 [i, m-1] 中\n-            else\n-                i = m + 1; // 首个大于 target 的元素在区间 [m+1, j] 中\n+        // 转化为查找最左一个 target + 1\n+        int i = binary_search_insertion.binarySearchInsertion(nums, target + 1);\n+        // j 指向最右一个 target ，i 指向首个大于 target 的元素\n+        int j = i - 1;\n+        // 未找到 target ，返回 -1\n+        if (j == -1 || nums[j] != target) {\n+            return -1;\n         }\n-        if (j < 0 || nums[j] != target)\n-            return -1; // 未找到目标元素，返回 -1\n+        // 找到 target ，返回索引 j\n         return j;\n     }\n \n     public static void main(String[] args) {\n-        int target = 6;\n+        // 包含重复元素的数组\n         int[] nums = { 1, 3, 6, 6, 6, 6, 6, 10, 12, 15 };\n+        System.out.println(\"\\n数组 nums = \" + java.util.Arrays.toString(nums));\n \n-        // 二分查找最左一个元素\n-        int indexLeft = binarySearchLeftEdge(nums, target);\n-        System.out.println(\"数组中最左一个元素 6 的索引 = \" + indexLeft);\n-\n-        // 二分查找最右一个元素\n-        int indexRight = binarySearchRightEdge(nums, target);\n-        System.out.println(\"数组中最右一个元素 6 的索引 = \" + indexRight);\n+        // 二分查找左边界和右边界\n+        for (int target : new int[] { 6, 7 }) {\n+            int index = binarySearchLeftEdge(nums, target);\n+            System.out.println(\"最左一个元素 \" + target + \" 的索引为 \" + index);\n+            index = binarySearchRightEdge(nums, target);\n+            System.out.println(\"最右一个元素 \" + target + \" 的索引为 \" + index);\n+        }\n     }\n }\n\ndiff --git a/codes/java/chapter_searching/binary_search_insertion.java b/codes/java/chapter_searching/binary_search_insertion.java\n--- a/codes/java/chapter_searching/binary_search_insertion.java\n+++ b/codes/java/chapter_searching/binary_search_insertion.java\n@@ -0,0 +1,63 @@\n+/**\n+ * File: binary_search_edge.java\n+ * Created Time: 2023-08-04\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_searching;\n+\n+class binary_search_insertion {\n+    /* 二分查找插入点（无重复元素） */\n+    static int binarySearchInsertionSimple(int[] nums, int target) {\n+        int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1]\n+        while (i <= j) {\n+            int m = i + (j - i) / 2; // 计算中点索引 m\n+            if (nums[m] < target) {\n+                i = m + 1; // target 在区间 [m+1, j] 中\n+            } else if (nums[m] > target) {\n+                j = m - 1; // target 在区间 [i, m-1] 中\n+            } else {\n+                return m; // 找到 target ，返回插入点 m\n+            }\n+        }\n+        // 未找到 target ，返回插入点 i\n+        return i;\n+    }\n+\n+    /* 二分查找插入点（存在重复元素） */\n+    static int binarySearchInsertion(int[] nums, int target) {\n+        int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1]\n+        while (i <= j) {\n+            int m = i + (j - i) / 2; // 计算中点索引 m\n+            if (nums[m] < target) {\n+                i = m + 1; // target 在区间 [m+1, j] 中\n+            } else if (nums[m] > target) {\n+                j = m - 1; // target 在区间 [i, m-1] 中\n+            } else {\n+                j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中\n+            }\n+        }\n+        // 返回插入点 i\n+        return i;\n+    }\n+\n+    public static void main(String[] args) {\n+        // 无重复元素的数组\n+        int[] nums = { 1, 3, 6, 8, 12, 15, 23, 26, 31, 35 };\n+        System.out.println(\"\\n数组 nums = \" + java.util.Arrays.toString(nums));\n+        // 二分查找插入点\n+        for (int target : new int[] { 6, 9 }) {\n+            int index = binarySearchInsertionSimple(nums, target);\n+            System.out.println(\"元素 \" + target + \" 的插入点的索引为 \" + index);\n+        }\n+\n+        // 包含重复元素的数组\n+        nums = new int[] { 1, 3, 6, 6, 6, 6, 6, 10, 12, 15 };\n+        System.out.println(\"\\n数组 nums = \" + java.util.Arrays.toString(nums));\n+        // 二分查找插入点\n+        for (int target : new int[] { 2, 6, 20 }) {\n+            int index = binarySearchInsertion(nums, target);\n+            System.out.println(\"元素 \" + target + \" 的插入点的索引为 \" + index);\n+        }\n+    }\n+}",
    "output": "Add the section of binary search insertion. (#671)\n\nRefactor the section of binary search edge.\r\nFinetune the figures of binary search."
  },
  {
    "input": "diff --git a/codes/java/chapter_hashing/hash_map_chaining.java b/codes/java/chapter_hashing/hash_map_chaining.java\n--- a/codes/java/chapter_hashing/hash_map_chaining.java\n+++ b/codes/java/chapter_hashing/hash_map_chaining.java\n@@ -80,10 +80,12 @@ void remove(int key) {\n         List<Pair> bucket = buckets.get(index);\n         // 遍历桶，从中删除键值对\n         for (Pair pair : bucket) {\n-            if (pair.key == key)\n+            if (pair.key == key) {\n                 bucket.remove(pair);\n+                size--;\n+                break;\n+            }\n         }\n-        size--;\n     }\n \n     /* 扩容哈希表 */",
    "output": "Fix the code of hash map chaining."
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n--- a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n+++ b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n@@ -43,7 +43,7 @@ public static void main(String[] args) {\n         res = new ArrayList<>();\n         preOrder(root);\n \n-        System.out.println(\"\\n输出所有根节点到节点 7 的路径，路径中不包含值为 3 的节点，仅包含一个值为 7 的节点\");\n+        System.out.println(\"\\n输出所有根节点到节点 7 的路径，路径中不包含值为 3 的节点\");\n         for (List<TreeNode> path : res) {\n             List<Integer> vals = new ArrayList<>();\n             for (TreeNode node : path) {\n\ndiff --git a/codes/java/chapter_backtracking/preorder_traversal_iii_template.java b/codes/java/chapter_backtracking/preorder_traversal_iii_template.java\n--- a/codes/java/chapter_backtracking/preorder_traversal_iii_template.java\n+++ b/codes/java/chapter_backtracking/preorder_traversal_iii_template.java\n@@ -41,7 +41,6 @@ static void backtrack(List<TreeNode> state, List<TreeNode> choices, List<List<Tr\n         if (isSolution(state)) {\n             // 记录解\n             recordSolution(state, res);\n-            return;\n         }\n         // 遍历所有选择\n         for (TreeNode choice : choices) {",
    "output": "Update preorder_traversal_iii."
  },
  {
    "input": "diff --git a/codes/java/chapter_greedy/max_product_cutting.java b/codes/java/chapter_greedy/max_product_cutting.java\n--- a/codes/java/chapter_greedy/max_product_cutting.java\n+++ b/codes/java/chapter_greedy/max_product_cutting.java\n@@ -35,6 +35,6 @@ public static void main(String[] args) {\n \n         // 贪心算法\n         int res = maxProductCutting(n);\n-        System.out.println(\"最大切分乘积为\" + res);\n+        System.out.println(\"最大切分乘积为 \" + res);\n     }\n }",
    "output": "Update max_product_cutting.java (#647)"
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n--- a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n+++ b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n@@ -24,6 +24,7 @@ static void preOrder(TreeNode root) {\n         if (root.val == 7) {\n             // 记录解\n             res.add(new ArrayList<>(path));\n+            path.remove(path.size() - 1);\n             return;\n         }\n         preOrder(root.left);\n@@ -42,7 +43,7 @@ public static void main(String[] args) {\n         res = new ArrayList<>();\n         preOrder(root);\n \n-        System.out.println(\"\\n输出所有根节点到节点 7 的路径，且路径中不包含值为 3 的节点\");\n+        System.out.println(\"\\n输出所有根节点到节点 7 的路径，路径中不包含值为 3 的节点，仅包含一个值为 7 的节点\");\n         for (List<TreeNode> path : res) {\n             List<Integer> vals = new ArrayList<>();\n             for (TreeNode node : path) {",
    "output": "Fix the code of preorder_traversal_iii_compact"
  },
  {
    "input": "diff --git a/codes/java/chapter_greedy/max_product_cutting.java b/codes/java/chapter_greedy/max_product_cutting.java\n--- a/codes/java/chapter_greedy/max_product_cutting.java\n+++ b/codes/java/chapter_greedy/max_product_cutting.java\n@@ -0,0 +1,40 @@\n+/**\n+ * File: max_product_cutting.java\n+ * Created Time: 2023-07-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_greedy;\n+\n+import java.lang.Math;\n+\n+public class max_product_cutting {\n+    /* 最大切分乘积：贪心 */\n+    public static int maxProductCutting(int n) {\n+        // 当 n <= 3 时，必须切分出一个 1\n+        if (n <= 3) {\n+            return 1 * (n - 1);\n+        }\n+        // 贪心地切分出 3 ，a 为 3 的个数，b 为余数\n+        int a = n / 3;\n+        int b = n % 3;\n+        if (b == 1) {\n+            // 当余数为 1 时，将一对 1 * 3 转化为 2 * 2\n+            return (int) Math.pow(3, a - 1) * 2 * 2;\n+        }\n+        if (b == 2) {\n+            // 当余数为 2 时，不做处理\n+            return (int) Math.pow(3, a) * 2;\n+        }\n+        // 当余数为 0 时，不做处理\n+        return (int) Math.pow(3, a);\n+    }\n+\n+    public static void main(String[] args) {\n+        int n = 58;\n+\n+        // 贪心算法\n+        int res = maxProductCutting(n);\n+        System.out.println(\"最大切分乘积为\" + res);\n+    }\n+}",
    "output": "Add the section of max product cutting problem. (#642)"
  },
  {
    "input": "diff --git a/codes/java/chapter_greedy/max_capacity.java b/codes/java/chapter_greedy/max_capacity.java\n--- a/codes/java/chapter_greedy/max_capacity.java\n+++ b/codes/java/chapter_greedy/max_capacity.java\n@@ -0,0 +1,38 @@\n+/**\n+ * File: max_capacity.java\n+ * Created Time: 2023-07-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_greedy;\n+\n+public class max_capacity {\n+    /* 最大容量：贪心 */\n+    static int maxCapacity(int[] ht) {\n+        // 初始化 i, j 分列数组两端\n+        int i = 0, j = ht.length - 1;\n+        // 初始最大容量为 0\n+        int res = 0;\n+        // 循环贪心选择，直至两板相遇\n+        while (i < j) {\n+            // 更新最大容量\n+            int cap = Math.min(ht[i], ht[j]) * (j - i);\n+            res = Math.max(res, cap);\n+            // 向内移动短板\n+            if (ht[i] < ht[j]) {\n+                i++;\n+            } else {\n+                j--;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] ht = { 3, 8, 5, 2, 7, 7, 3, 4 };\n+\n+        // 贪心算法\n+        int res = maxCapacity(ht);\n+        System.out.println(\"最大容量为 \" + res);\n+    }\n+}",
    "output": "Add the section of max capacity problem. (#639)"
  },
  {
    "input": "diff --git a/codes/java/chapter_greedy/coin_change_greedy.java b/codes/java/chapter_greedy/coin_change_greedy.java\n--- a/codes/java/chapter_greedy/coin_change_greedy.java\n+++ b/codes/java/chapter_greedy/coin_change_greedy.java\n@@ -0,0 +1,55 @@\n+/**\n+ * File: coin_change_greedy.java\n+ * Created Time: 2023-07-20\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_greedy;\n+\n+import java.util.Arrays;\n+\n+public class coin_change_greedy {\n+    /* 零钱兑换：贪心 */\n+    static int coinChangeGreedy(int[] coins, int amt) {\n+        // 假设 coins 列表有序\n+        int i = coins.length - 1;\n+        int count = 0;\n+        // 循环进行贪心选择，直到无剩余金额\n+        while (amt > 0) {\n+            // 找到小于且最接近剩余金额的硬币\n+            while (coins[i] > amt) {\n+                i--;\n+            }\n+            // 选择 coins[i]\n+            amt -= coins[i];\n+            count++;\n+        }\n+        // 若未找到可行方案，则返回 -1\n+        return amt == 0 ? count : -1;\n+    }\n+\n+    public static void main(String[] args) {\n+        // 贪心：能够保证找到全局最优解\n+        int[] coins = { 1, 5, 10, 20, 50, 100 };\n+        int amt = 186;\n+        int res = coinChangeGreedy(coins, amt);\n+        System.out.println(\"\\ncoins = \" + Arrays.toString(coins) + \", amt = \" + amt);\n+        System.out.println(\"凑到 \" + amt + \" 所需的最少硬币数量为 \" + res);\n+\n+        // 贪心：无法保证找到全局最优解\n+        coins = new int[] { 1, 20, 50 };\n+        amt = 60;\n+        res = coinChangeGreedy(coins, amt);\n+        System.out.println(\"\\ncoins = \" + Arrays.toString(coins) + \", amt = \" + amt);\n+        System.out.println(\"凑到 \" + amt + \" 所需的最少硬币数量为 \" + res);\n+        System.out.println(\"实际上需要的最少数量为 3 ，即 20 + 20 + 20\");\n+\n+        // 贪心：无法保证找到全局最优解\n+        coins = new int[] { 1, 49, 50 };\n+        amt = 98;\n+        res = coinChangeGreedy(coins, amt);\n+        System.out.println(\"\\ncoins = \" + Arrays.toString(coins) + \", amt = \" + amt);\n+        System.out.println(\"凑到 \" + amt + \" 所需的最少硬币数量为 \" + res);\n+        System.out.println(\"实际上需要的最少数量为 2 ，即 49 + 49\");\n+    }\n+}\n\ndiff --git a/codes/java/chapter_greedy/fractional_knapsack.java b/codes/java/chapter_greedy/fractional_knapsack.java\n--- a/codes/java/chapter_greedy/fractional_knapsack.java\n+++ b/codes/java/chapter_greedy/fractional_knapsack.java\n@@ -0,0 +1,59 @@\n+/**\n+ * File: fractional_knapsack.java\n+ * Created Time: 2023-07-20\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_greedy;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+/* 物品 */\n+class Item {\n+    int w; // 物品重量\n+    int v; // 物品价值\n+\n+    public Item(int w, int v) {\n+        this.w = w;\n+        this.v = v;\n+    }\n+}\n+\n+public class fractional_knapsack {\n+    /* 分数背包：贪心 */\n+    static double fractionalKnapsack(int[] wgt, int[] val, int cap) {\n+        // 创建物品列表，包含两个属性：重量、价值\n+        Item[] items = new Item[wgt.length];\n+        for (int i = 0; i < wgt.length; i++) {\n+            items[i] = new Item(wgt[i], val[i]);\n+        }\n+        // 按照单位价值 item.v / item.w 从高到低进行排序\n+        Arrays.sort(items, Comparator.comparingDouble(item -> -((double) item.v / item.w)));\n+        // 循环贪心选择\n+        double res = 0;\n+        for (Item item : items) {\n+            if (item.w <= cap) {\n+                // 若剩余容量充足，则将当前物品整个装进背包\n+                res += item.v;\n+                cap -= item.w;\n+            } else {\n+                // 若剩余容量不足，则将当前物品的一部分装进背包\n+                res += (double) item.v / item.w * cap;\n+                // 已无剩余容量，因此跳出循环\n+                break;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] wgt = { 10, 20, 30, 40, 50 };\n+        int[] val = { 50, 120, 150, 210, 240 };\n+        int cap = 50;\n+\n+        // 贪心算法\n+        double res = fractionalKnapsack(wgt, val, cap);\n+        System.out.println(\"不超过背包容量的最大物品价值为 \" + res);\n+    }\n+}",
    "output": "Add the chapter of greedy. (#633)\n\nAdd the section of fractional knapsack."
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n--- a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n+++ b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n@@ -24,6 +24,7 @@ static void preOrder(TreeNode root) {\n         if (root.val == 7) {\n             // 记录解\n             res.add(new ArrayList<>(path));\n+            return;\n         }\n         preOrder(root.left);\n         preOrder(root.right);",
    "output": "Modify the problem of preorder_traversal_iii"
  },
  {
    "input": "diff --git a/codes/java/chapter_divide_and_conquer/hanota.java b/codes/java/chapter_divide_and_conquer/hanota.java\n--- a/codes/java/chapter_divide_and_conquer/hanota.java\n+++ b/codes/java/chapter_divide_and_conquer/hanota.java\n@@ -33,7 +33,7 @@ static void dfs(int i, List<Integer> src, List<Integer> buf, List<Integer> tar)\n     }\n \n     /* 求解汉诺塔 */\n-    static void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {\n+    static void solveHanota(List<Integer> A, List<Integer> B, List<Integer> C) {\n         int n = A.size();\n         // 将 A 顶部 n 个圆盘借助 B 移到 C\n         dfs(n, A, B, C);\n@@ -49,7 +49,7 @@ public static void main(String[] args) {\n         System.out.println(\"B = \" + B);\n         System.out.println(\"C = \" + C);\n \n-        hanota(A, B, C);\n+        solveHanota(A, B, C);\n \n         System.out.println(\"圆盘移动完成后：\");\n         System.out.println(\"A = \" + A);",
    "output": "Finetune"
  },
  {
    "input": "diff --git a/codes/java/chapter_graph/graph_bfs.java b/codes/java/chapter_graph/graph_bfs.java\n--- a/codes/java/chapter_graph/graph_bfs.java\n+++ b/codes/java/chapter_graph/graph_bfs.java\n@@ -16,9 +16,11 @@ static List<Vertex> graphBFS(GraphAdjList graph, Vertex startVet) {\n         // 顶点遍历序列\n         List<Vertex> res = new ArrayList<>();\n         // 哈希表，用于记录已被访问过的顶点\n-        Set<Vertex> visited = new HashSet<>() {{ add(startVet); }};\n+        Set<Vertex> visited = new HashSet<>();\n+        visited.add(startVet);\n         // 队列用于实现 BFS\n-        Queue<Vertex> que = new LinkedList<>() {{ offer(startVet); }};\n+        Queue<Vertex> que = new LinkedList<>();\n+        que.offer(startVet);\n         // 以顶点 vet 为起点，循环直至访问完所有顶点\n         while (!que.isEmpty()) {\n             Vertex vet = que.poll(); // 队首顶点出队\n\ndiff --git a/codes/java/chapter_tree/binary_tree_bfs.java b/codes/java/chapter_tree/binary_tree_bfs.java\n--- a/codes/java/chapter_tree/binary_tree_bfs.java\n+++ b/codes/java/chapter_tree/binary_tree_bfs.java\n@@ -13,7 +13,8 @@ public class binary_tree_bfs {\n     /* 层序遍历 */\n     static List<Integer> levelOrder(TreeNode root) {\n         // 初始化队列，加入根节点\n-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<>();\n+        queue.add(root);\n         // 初始化一个列表，用于保存遍历序列\n         List<Integer> list = new ArrayList<>();\n         while (!queue.isEmpty()) {\n\ndiff --git a/codes/java/utils/TreeNode.java b/codes/java/utils/TreeNode.java\n--- a/codes/java/utils/TreeNode.java\n+++ b/codes/java/utils/TreeNode.java\n@@ -26,7 +26,8 @@ public static TreeNode listToTree(List<Integer> list) {\n             return null;\n \n         TreeNode root = new TreeNode(list.get(0));\n-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<>();\n+        queue.add(root);\n         int i = 0;\n         while (!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n@@ -51,7 +52,7 @@ public static List<Integer> treeToList(TreeNode root) {\n         List<Integer> list = new ArrayList<>();\n         if (root == null)\n             return list;\n-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};\n         while (!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n             if (node != null) {",
    "output": "Anonymous inner classes create generic instances that display the dec… (#627)\n\n* Anonymous inner classes create generic instances that display the declared type\r\n\r\n* Update TreeNode.java\r\n\r\n* Update binary_tree_bfs.java\r\n\r\n* Update graph_bfs.java\r\n\r\n---------\r\n\r\nCo-authored-by: zongjianwei <zongjianwei@meituan.com>\r\nCo-authored-by: Yudong Jin <krahets@163.com>"
  },
  {
    "input": "diff --git a/codes/java/chapter_divide_and_conquer/binary_search_recur.java b/codes/java/chapter_divide_and_conquer/binary_search_recur.java\n--- a/codes/java/chapter_divide_and_conquer/binary_search_recur.java\n+++ b/codes/java/chapter_divide_and_conquer/binary_search_recur.java\n@@ -0,0 +1,45 @@\n+/**\n+ * File: binary_search_recur.java\n+ * Created Time: 2023-07-17\n+ * Author: krahets (krahets@163.com)\n+ */\n+\n+package chapter_divide_and_conquer;\n+\n+public class binary_search_recur {\n+    /* 二分查找：问题 f(i, j) */\n+    static int dfs(int[] nums, int target, int i, int j) {\n+        // 若区间为空，代表无目标元素，则返回 -1\n+        if (i > j) {\n+            return -1;\n+        }\n+        // 计算中点索引 m\n+        int m = (i + j) / 2;\n+        if (nums[m] < target) {\n+            // 递归子问题 f(m+1, j)\n+            return dfs(nums, target, m + 1, j);\n+        } else if (nums[m] > target) {\n+            // 递归子问题 f(i, m-1)\n+            return dfs(nums, target, i, m - 1);\n+        } else {\n+            // 找到目标元素，返回其索引\n+            return m;\n+        }\n+    }\n+\n+    /* 二分查找 */\n+    static int binarySearch(int[] nums, int target) {\n+        int n = nums.length;\n+        // 求解问题 f(0, n-1)\n+        return dfs(nums, target, 0, n - 1);\n+    }\n+\n+    public static void main(String[] args) {\n+        int target = 6;\n+        int[] nums = { 1, 3, 6, 8, 12, 15, 23, 26, 31, 35 };\n+\n+        // 二分查找（双闭区间）\n+        int index = binarySearch(nums, target);\n+        System.out.println(\"目标元素 6 的索引 = \" + index);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_divide_and_conquer/build_tree.java b/codes/java/chapter_divide_and_conquer/build_tree.java\n--- a/codes/java/chapter_divide_and_conquer/build_tree.java\n+++ b/codes/java/chapter_divide_and_conquer/build_tree.java\n@@ -0,0 +1,51 @@\n+/**\n+ * File: build_tree.java\n+ * Created Time: 2023-07-17\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_divide_and_conquer;\n+\n+import utils.*;\n+import java.util.*;\n+\n+public class build_tree {\n+    /* 构建二叉树：分治 */\n+    static TreeNode dfs(int[] preorder, int[] inorder, Map<Integer, Integer> hmap, int i, int l, int r) {\n+        // 子树区间为空时终止\n+        if (r - l < 0)\n+            return null;\n+        // 初始化根节点\n+        TreeNode root = new TreeNode(preorder[i]);\n+        // 查询 m ，从而划分左右子树\n+        int m = hmap.get(preorder[i]);\n+        // 子问题：构建左子树\n+        root.left = dfs(preorder, inorder, hmap, i + 1, l, m - 1);\n+        // 子问题：构建右子树\n+        root.right = dfs(preorder, inorder, hmap, i + 1 + m - l, m + 1, r);\n+        // 返回根节点\n+        return root;\n+    }\n+\n+    /* 构建二叉树 */\n+    static TreeNode buildTree(int[] preorder, int[] inorder) {\n+        // 初始化哈希表，存储 inorder 元素到索引的映射\n+        Map<Integer, Integer> hmap = new HashMap<>();\n+        for (int i = 0; i < inorder.length; i++) {\n+            hmap.put(inorder[i], i);\n+        }\n+        TreeNode root = dfs(preorder, inorder, hmap, 0, 0, inorder.length - 1);\n+        return root;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] preorder = { 3, 9, 2, 1, 7 };\n+        int[] inorder = { 9, 3, 1, 2, 7 };\n+        System.out.println(\"前序遍历 = \" + Arrays.toString(preorder));\n+        System.out.println(\"中序遍历 = \" + Arrays.toString(inorder));\n+\n+        TreeNode root = buildTree(preorder, inorder);\n+        System.out.println(\"构建的二叉树为：\");\n+        PrintUtil.printTree(root);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_divide_and_conquer/hanota.java b/codes/java/chapter_divide_and_conquer/hanota.java\n--- a/codes/java/chapter_divide_and_conquer/hanota.java\n+++ b/codes/java/chapter_divide_and_conquer/hanota.java\n@@ -0,0 +1,59 @@\n+/**\n+ * File: hanota.java\n+ * Created Time: 2023-07-17\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_divide_and_conquer;\n+\n+import java.util.*;\n+\n+public class hanota {\n+    /* 移动一个圆盘 */\n+    static void move(List<Integer> src, List<Integer> tar) {\n+        // 从 src 顶部拿出一个圆盘\n+        Integer pan = src.remove(src.size() - 1);\n+        // 将圆盘放入 tar 顶部\n+        tar.add(pan);\n+    }\n+\n+    /* 求解汉诺塔：问题 f(i) */\n+    static void dfs(int i, List<Integer> src, List<Integer> buf, List<Integer> tar) {\n+        // 若 src 只剩下一个圆盘，则直接将其移到 tar\n+        if (i == 1) {\n+            move(src, tar);\n+            return;\n+        }\n+        // 子问题 f(i-1) ：将 src 顶部 i-1 个圆盘借助 tar 移到 buf\n+        dfs(i - 1, src, tar, buf);\n+        // 子问题 f(1) ：将 src 剩余一个圆盘移到 tar\n+        move(src, tar);\n+        // 子问题 f(i-1) ：将 buf 顶部 i-1 个圆盘借助 src 移到 tar\n+        dfs(i - 1, buf, src, tar);\n+    }\n+\n+    /* 求解汉诺塔 */\n+    static void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {\n+        int n = A.size();\n+        // 将 A 顶部 n 个圆盘借助 B 移到 C\n+        dfs(n, A, B, C);\n+    }\n+\n+    public static void main(String[] args) {\n+        // 列表尾部是柱子顶部\n+        List<Integer> A = new ArrayList<>(Arrays.asList(5, 4, 3, 2, 1));\n+        List<Integer> B = new ArrayList<>();\n+        List<Integer> C = new ArrayList<>();\n+        System.out.println(\"初始状态下：\");\n+        System.out.println(\"A = \" + A);\n+        System.out.println(\"B = \" + B);\n+        System.out.println(\"C = \" + C);\n+\n+        hanota(A, B, C);\n+\n+        System.out.println(\"圆盘移动完成后：\");\n+        System.out.println(\"A = \" + A);\n+        System.out.println(\"B = \" + B);\n+        System.out.println(\"C = \" + C);\n+    }\n+}",
    "output": "Add Java and C++ code for the chapter of\ndivide and conquer."
  },
  {
    "input": "diff --git a/codes/java/chapter_dynamic_programming/edit_distance.java b/codes/java/chapter_dynamic_programming/edit_distance.java\n--- a/codes/java/chapter_dynamic_programming/edit_distance.java\n+++ b/codes/java/chapter_dynamic_programming/edit_distance.java\n@@ -0,0 +1,139 @@\n+/**\n+ * File: edit_distance.java\n+ * Created Time: 2023-07-13\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_dynamic_programming;\n+\n+import java.util.Arrays;\n+\n+public class edit_distance {\n+    /* 编辑距离：暴力搜索 */\n+    static int editDistanceDFS(String s, String t, int i, int j) {\n+        // 若 s 和 t 都为空，则返回 0\n+        if (i == 0 && j == 0)\n+            return 0;\n+        // 若 s 为空，则返回 t 长度\n+        if (i == 0)\n+            return j;\n+        // 若 t 为空，则返回 s 长度\n+        if (j == 0)\n+            return i;\n+        // 若两字符相等，则直接跳过此两字符\n+        if (s.charAt(i - 1) == t.charAt(j - 1))\n+            return editDistanceDFS(s, t, i - 1, j - 1);\n+        // 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1\n+        int insert = editDistanceDFS(s, t, i, j - 1);\n+        int delete = editDistanceDFS(s, t, i - 1, j);\n+        int replace = editDistanceDFS(s, t, i - 1, j - 1);\n+        // 返回最少编辑步数\n+        return Math.min(Math.min(insert, delete), replace) + 1;\n+    }\n+\n+    /* 编辑距离：记忆化搜索 */\n+    static int editDistanceDFSMem(String s, String t, int[][] mem, int i, int j) {\n+        // 若 s 和 t 都为空，则返回 0\n+        if (i == 0 && j == 0)\n+            return 0;\n+        // 若 s 为空，则返回 t 长度\n+        if (i == 0)\n+            return j;\n+        // 若 t 为空，则返回 s 长度\n+        if (j == 0)\n+            return i;\n+        // 若已有记录，则直接返回之\n+        if (mem[i][j] != -1)\n+            return mem[i][j];\n+        // 若两字符相等，则直接跳过此两字符\n+        if (s.charAt(i - 1) == t.charAt(j - 1))\n+            return editDistanceDFSMem(s, t, mem, i - 1, j - 1);\n+        // 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1\n+        int insert = editDistanceDFSMem(s, t, mem, i, j - 1);\n+        int delete = editDistanceDFSMem(s, t, mem, i - 1, j);\n+        int replace = editDistanceDFSMem(s, t, mem, i - 1, j - 1);\n+        // 记录并返回最少编辑步数\n+        mem[i][j] = Math.min(Math.min(insert, delete), replace) + 1;\n+        return mem[i][j];\n+    }\n+\n+    /* 编辑距离：动态规划 */\n+    static int editDistanceDP(String s, String t) {\n+        int n = s.length(), m = t.length();\n+        int[][] dp = new int[n + 1][m + 1];\n+        // 状态转移：首行首列\n+        for (int i = 1; i <= n; i++) {\n+            dp[i][0] = i;\n+        }\n+        for (int j = 1; j <= m; j++) {\n+            dp[0][j] = j;\n+        }\n+        // 状态转移：其余行列\n+        for (int i = 1; i <= n; i++) {\n+            for (int j = 1; j <= m; j++) {\n+                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n+                    // 若两字符相等，则直接跳过此两字符\n+                    dp[i][j] = dp[i - 1][j - 1];\n+                } else {\n+                    // 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1\n+                    dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n+                }\n+            }\n+        }\n+        return dp[n][m];\n+    }\n+\n+    /* 编辑距离：状态压缩后的动态规划 */\n+    static int editDistanceDPComp(String s, String t) {\n+        int n = s.length(), m = t.length();\n+        int[] dp = new int[m + 1];\n+        // 状态转移：首行\n+        for (int j = 1; j <= m; j++) {\n+            dp[j] = j;\n+        }\n+        // 状态转移：其余行\n+        for (int i = 1; i <= n; i++) {\n+            // 状态转移：首列\n+            int leftup = dp[0]; // 暂存 dp[i-1, j-1]\n+            dp[0] = i;\n+            // 状态转移：其余列\n+            for (int j = 1; j <= m; j++) {\n+                int temp = dp[j];\n+                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n+                    // 若两字符相等，则直接跳过此两字符\n+                    dp[j] = leftup;\n+                } else {\n+                    // 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1\n+                    dp[j] = Math.min(Math.min(dp[j - 1], dp[j]), leftup) + 1;\n+                }\n+                leftup = temp; // 更新为下一轮的 dp[i-1, j-1]\n+            }\n+        }\n+        return dp[m];\n+    }\n+\n+    public static void main(String[] args) {\n+        String s = \"bag\";\n+        String t = \"pack\";\n+        int n = s.length(), m = t.length();\n+\n+        // 暴力搜索\n+        int res = editDistanceDFS(s, t, n, m);\n+        System.out.println(\"将 \" + s + \" 更改为 \" + t + \" 最少需要编辑 \" + res + \" 步\");\n+\n+        // 记忆化搜索\n+        int[][] mem = new int[n + 1][m + 1];\n+        for (int[] row : mem)\n+            Arrays.fill(row, -1);\n+        res = editDistanceDFSMem(s, t, mem, n, m);\n+        System.out.println(\"将 \" + s + \" 更改为 \" + t + \" 最少需要编辑 \" + res + \" 步\");\n+\n+        // 动态规划\n+        res = editDistanceDP(s, t);\n+        System.out.println(\"将 \" + s + \" 更改为 \" + t + \" 最少需要编辑 \" + res + \" 步\");\n+\n+        // 状态压缩后的动态规划\n+        res = editDistanceDPComp(s, t);\n+        System.out.println(\"将 \" + s + \" 更改为 \" + t + \" 最少需要编辑 \" + res + \" 步\");\n+    }\n+}",
    "output": "Add the section of edit distance problem (#599)"
  },
  {
    "input": "diff --git a/codes/java/chapter_dynamic_programming/coin_change.java b/codes/java/chapter_dynamic_programming/coin_change.java\n--- a/codes/java/chapter_dynamic_programming/coin_change.java\n+++ b/codes/java/chapter_dynamic_programming/coin_change.java\n@@ -0,0 +1,72 @@\n+/**\n+ * File: coin_change.java\n+ * Created Time: 2023-07-11\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_dynamic_programming;\n+\n+import java.util.Arrays;\n+\n+public class coin_change {\n+    /* 零钱兑换：动态规划 */\n+    static int coinChangeDP(int[] coins, int amt) {\n+        int n = coins.length;\n+        int MAX = amt + 1;\n+        // 初始化 dp 表\n+        int[][] dp = new int[n + 1][amt + 1];\n+        // 状态转移：首行首列\n+        for (int a = 1; a <= amt; a++) {\n+            dp[0][a] = MAX;\n+        }\n+        // 状态转移：其余行列\n+        for (int i = 1; i <= n; i++) {\n+            for (int a = 1; a <= amt; a++) {\n+                if (coins[i - 1] > a) {\n+                    // 若超过背包容量，则不选硬币 i\n+                    dp[i][a] = dp[i - 1][a];\n+                } else {\n+                    // 不选和选硬币 i 这两种方案的较小值\n+                    dp[i][a] = Math.min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);\n+                }\n+            }\n+        }\n+        return dp[n][amt] != MAX ? dp[n][amt] : -1;\n+    }\n+\n+    /* 零钱兑换：状态压缩后的动态规划 */\n+    static int coinChangeDPComp(int[] coins, int amt) {\n+        int n = coins.length;\n+        int MAX = amt + 1;\n+        // 初始化 dp 表\n+        int[] dp = new int[amt + 1];\n+        Arrays.fill(dp, MAX);\n+        dp[0] = 0;\n+        // 状态转移\n+        for (int i = 1; i <= n; i++) {\n+            for (int a = 1; a <= amt; a++) {\n+                if (coins[i - 1] > a) {\n+                    // 若超过背包容量，则不选硬币 i\n+                    dp[a] = dp[a];\n+                } else {\n+                    // 不选和选硬币 i 这两种方案的较小值\n+                    dp[a] = Math.min(dp[a], dp[a - coins[i - 1]] + 1);\n+                }\n+            }\n+        }\n+        return dp[amt] != MAX ? dp[amt] : -1;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] coins = { 1, 2, 5 };\n+        int amt = 4;\n+\n+        // 动态规划\n+        int res = coinChangeDP(coins, amt);\n+        System.out.println(\"凑到目标金额所需的最少硬币数量为 \" + res);\n+\n+        // 状态压缩后的动态规划\n+        res = coinChangeDPComp(coins, amt);\n+        System.out.println(\"凑到目标金额所需的最少硬币数量为 \" + res);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_dynamic_programming/coin_change_ii.java b/codes/java/chapter_dynamic_programming/coin_change_ii.java\n--- a/codes/java/chapter_dynamic_programming/coin_change_ii.java\n+++ b/codes/java/chapter_dynamic_programming/coin_change_ii.java\n@@ -0,0 +1,67 @@\n+/**\n+ * File: coin_change_ii.java\n+ * Created Time: 2023-07-11\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_dynamic_programming;\n+\n+public class coin_change_ii {\n+    /* 零钱兑换 II：动态规划 */\n+    static int coinChangeIIDP(int[] coins, int amt) {\n+        int n = coins.length;\n+        // 初始化 dp 表\n+        int[][] dp = new int[n + 1][amt + 1];\n+        // 初始化首列\n+        for (int i = 0; i <= n; i++) {\n+            dp[i][0] = 1;\n+        }\n+        // 状态转移\n+        for (int i = 1; i <= n; i++) {\n+            for (int a = 1; a <= amt; a++) {\n+                if (coins[i - 1] > a) {\n+                    // 若超过背包容量，则不选硬币 i\n+                    dp[i][a] = dp[i - 1][a];\n+                } else {\n+                    // 不选和选硬币 i 这两种方案之和\n+                    dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];\n+                }\n+            }\n+        }\n+        return dp[n][amt];\n+    }\n+\n+    /* 零钱兑换 II：状态压缩后的动态规划 */\n+    static int coinChangeIIDPComp(int[] coins, int amt) {\n+        int n = coins.length;\n+        // 初始化 dp 表\n+        int[] dp = new int[amt + 1];\n+        dp[0] = 1;\n+        // 状态转移\n+        for (int i = 1; i <= n; i++) {\n+            for (int a = 1; a <= amt; a++) {\n+                if (coins[i - 1] > a) {\n+                    // 若超过背包容量，则不选硬币 i\n+                    dp[a] = dp[a];\n+                } else {\n+                    // 不选和选硬币 i 这两种方案之和\n+                    dp[a] = dp[a] + dp[a - coins[i - 1]];\n+                }\n+            }\n+        }\n+        return dp[amt];\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] coins = { 1, 2, 5 };\n+        int amt = 5;\n+\n+        // 动态规划\n+        int res = coinChangeIIDP(coins, amt);\n+        System.out.println(\"凑出目标金额的硬币组合数量为 \" + res);\n+\n+        // 状态压缩后的动态规划\n+        res = coinChangeIIDPComp(coins, amt);\n+        System.out.println(\"凑出目标金额的硬币组合数量为 \" + res);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_dynamic_programming/unbounded_knapsack.java b/codes/java/chapter_dynamic_programming/unbounded_knapsack.java\n--- a/codes/java/chapter_dynamic_programming/unbounded_knapsack.java\n+++ b/codes/java/chapter_dynamic_programming/unbounded_knapsack.java\n@@ -0,0 +1,63 @@\n+/**\n+ * File: unbounded_knapsack.java\n+ * Created Time: 2023-07-11\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_dynamic_programming;\n+\n+public class unbounded_knapsack {\n+    /* 完全背包：动态规划 */\n+    static int unboundedKnapsackDP(int[] wgt, int[] val, int cap) {\n+        int n = wgt.length;\n+        // 初始化 dp 表\n+        int[][] dp = new int[n + 1][cap + 1];\n+        // 状态转移\n+        for (int i = 1; i <= n; i++) {\n+            for (int c = 1; c <= cap; c++) {\n+                if (wgt[i - 1] > c) {\n+                    // 若超过背包容量，则不选物品 i\n+                    dp[i][c] = dp[i - 1][c];\n+                } else {\n+                    // 不选和选物品 i 这两种方案的较大值\n+                    dp[i][c] = Math.max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]);\n+                }\n+            }\n+        }\n+        return dp[n][cap];\n+    }\n+\n+    /* 完全背包：状态压缩后的动态规划 */\n+    static int unboundedKnapsackDPComp(int[] wgt, int[] val, int cap) {\n+        int n = wgt.length;\n+        // 初始化 dp 表\n+        int[] dp = new int[cap + 1];\n+        // 状态转移\n+        for (int i = 1; i <= n; i++) {\n+            for (int c = 1; c <= cap; c++) {\n+                if (wgt[i - 1] > c) {\n+                    // 若超过背包容量，则不选物品 i\n+                    dp[c] = dp[c];\n+                } else {\n+                    // 不选和选物品 i 这两种方案的较大值\n+                    dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);\n+                }\n+            }\n+        }\n+        return dp[cap];\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] wgt = { 1, 2, 3 };\n+        int[] val = { 5, 11, 15 };\n+        int cap = 4;\n+\n+        // 动态规划\n+        int res = unboundedKnapsackDP(wgt, val, cap);\n+        System.out.println(\"不超过背包容量的最大物品价值为 \" + res);\n+\n+        // 状态压缩后的动态规划\n+        res = unboundedKnapsackDPComp(wgt, val, cap);\n+        System.out.println(\"不超过背包容量的最大物品价值为 \" + res);\n+    }\n+}",
    "output": "Add the section of unbounded knapsack problem."
  },
  {
    "input": "diff --git a/codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java b/codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java\n--- a/codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java\n+++ b/codes/java/chapter_dynamic_programming/climbing_stairs_constraint_dp.java\n@@ -0,0 +1,36 @@\n+/**\n+ * File: climbing_stairs_constraint_dp.java\n+ * Created Time: 2023-07-01\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_dynamic_programming;\n+\n+public class climbing_stairs_constraint_dp {\n+    /* 带约束爬楼梯：动态规划 */\n+    static int climbingStairsConstraintDP(int n) {\n+        if (n == 1 || n == 2) {\n+            return n;\n+        }\n+        // 初始化 dp 列表，用于存储子问题的解\n+        int[][] dp = new int[n + 1][3];\n+        // 初始状态：预设最小子问题的解\n+        dp[1][1] = 1;\n+        dp[1][2] = 0;\n+        dp[2][1] = 0;\n+        dp[2][2] = 1;\n+        // 状态转移：从较小子问题逐步求解较大子问题\n+        for (int i = 3; i <= n; i++) {\n+            dp[i][1] = dp[i - 1][2];\n+            dp[i][2] = dp[i - 2][1] + dp[i - 2][2];\n+        }\n+        return dp[n][1] + dp[n][2];\n+    }\n+\n+    public static void main(String[] args) {\n+        int n = 9;\n+\n+        int res = climbingStairsConstraintDP(n);\n+        System.out.println(String.format(\"爬 %d 阶楼梯共有 %d 种方案\", n, res));\n+    }\n+}",
    "output": "Update the section of intro to DP."
  },
  {
    "input": "diff --git a/codes/java/chapter_hashing/hash_map_chaining.java b/codes/java/chapter_hashing/hash_map_chaining.java\n--- a/codes/java/chapter_hashing/hash_map_chaining.java\n+++ b/codes/java/chapter_hashing/hash_map_chaining.java\n@@ -9,17 +9,6 @@\n import java.util.ArrayList;\n import java.util.List;\n \n-/* 键值对 */\n-class Pair {\n-    public int key;\n-    public String val;\n-\n-    public Pair(int key, String val) {\n-        this.key = key;\n-        this.val = val;\n-    }\n-}\n-\n /* 链式地址哈希表 */\n class HashMapChaining {\n     int size; // 键值对数量\n\ndiff --git a/codes/java/chapter_hashing/hash_map_open_addressing.java b/codes/java/chapter_hashing/hash_map_open_addressing.java\n--- a/codes/java/chapter_hashing/hash_map_open_addressing.java\n+++ b/codes/java/chapter_hashing/hash_map_open_addressing.java\n@@ -6,17 +6,6 @@\n \n package chapter_hashing;\n \n-/* 键值对 */\n-class Pair {\n-    public int key;\n-    public String val;\n-\n-    public Pair(int key, String val) {\n-        this.key = key;\n-        this.val = val;\n-    }\n-}\n-\n /* 开放寻址哈希表 */\n class HashMapOpenAddressing {\n     private int size; // 键值对数量",
    "output": "1. Remove Pair class from hash coliision code.\n2. Fix the comment in my_list code.\n3. Add a Q&A to the summary of sorting."
  },
  {
    "input": "diff --git a/codes/java/chapter_hashing/built_in_hash.java b/codes/java/chapter_hashing/built_in_hash.java\n--- a/codes/java/chapter_hashing/built_in_hash.java\n+++ b/codes/java/chapter_hashing/built_in_hash.java\n@@ -0,0 +1,38 @@\n+/**\n+ * File: built_in_hash.java\n+ * Created Time: 2023-06-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_hashing;\n+\n+import utils.*;\n+import java.util.*;\n+\n+public class built_in_hash {\n+    public static void main(String[] args) {\n+        int num = 3;\n+        int hashNum = Integer.hashCode(num);\n+        System.out.println(\"整数 \" + num + \" 的哈希值为 \" + hashNum);\n+\n+        boolean bol = true;\n+        int hashBol = Boolean.hashCode(bol);\n+        System.out.println(\"布尔量 \" + bol + \" 的哈希值为 \" + hashBol);\n+\n+        double dec = 3.14159;\n+        int hashDec = Double.hashCode(dec);\n+        System.out.println(\"小数 \" + dec + \" 的哈希值为 \" + hashDec);\n+\n+        String str = \"Hello 算法\";\n+        int hashStr = str.hashCode();\n+        System.out.println(\"字符串 \" + str + \" 的哈希值为 \" + hashStr);\n+\n+        Object[] arr = { 12836, \"小哈\" };\n+        int hashTup = Arrays.hashCode(arr);\n+        System.out.println(\"数组 \" + Arrays.toString(arr) + \" 的哈希值为 \" + hashTup);\n+\n+        ListNode obj = new ListNode(0);\n+        int hashObj = obj.hashCode();\n+        System.out.println(\"节点对象 \" + obj + \" 的哈希值为 \" + hashObj);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_hashing/simple_hash.java b/codes/java/chapter_hashing/simple_hash.java\n--- a/codes/java/chapter_hashing/simple_hash.java\n+++ b/codes/java/chapter_hashing/simple_hash.java\n@@ -0,0 +1,66 @@\n+/**\n+ * File: simple_hash.java\n+ * Created Time: 2023-06-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_hashing;\n+\n+public class simple_hash {\n+    /* 加法哈希 */\n+    static int addHash(String key) {\n+        long hash = 0;\n+        final int MODULUS = 1000000007;\n+        for (char c : key.toCharArray()) {\n+            hash = (hash + (int) c) % MODULUS;\n+        }\n+        return (int) hash;\n+    }\n+\n+    /* 乘法哈希 */\n+    static int mulHash(String key) {\n+        long hash = 0;\n+        final int MODULUS = 1000000007;\n+        for (char c : key.toCharArray()) {\n+            hash = (31 * hash + (int) c) % MODULUS;\n+        }\n+        return (int) hash;\n+    }\n+\n+    /* 异或哈希 */\n+    static int xorHash(String key) {\n+        int hash = 0;\n+        final int MODULUS = 1000000007;\n+        for (char c : key.toCharArray()) {\n+            System.out.println((int)c);\n+            hash ^= (int) c;\n+        }\n+        return hash & MODULUS;\n+    }\n+\n+    /* 旋转哈希 */\n+    static int rotHash(String key) {\n+        long hash = 0;\n+        final int MODULUS = 1000000007;\n+        for (char c : key.toCharArray()) {\n+            hash = ((hash << 4) ^ (hash >> 28) ^ (int) c) % MODULUS;\n+        }\n+        return (int) hash;\n+    }\n+\n+    public static void main(String[] args) {\n+        String key = \"Hello 算法\";\n+\n+        int hash = addHash(key);\n+        System.out.println(\"加法哈希值为 \" + hash);\n+\n+        hash = mulHash(key);\n+        System.out.println(\"乘法哈希值为 \" + hash);\n+\n+        hash = xorHash(key);\n+        System.out.println(\"异或哈希值为 \" + hash);\n+\n+        hash = rotHash(key);\n+        System.out.println(\"旋转哈希值为 \" + hash);\n+    }\n+}",
    "output": "Add Java and C++ code for the section hash algorithm (#560)"
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/subset_sum_i.java b/codes/java/chapter_backtracking/subset_sum_i.java\n--- a/codes/java/chapter_backtracking/subset_sum_i.java\n+++ b/codes/java/chapter_backtracking/subset_sum_i.java\n@@ -0,0 +1,55 @@\n+/**\n+ * File: subset_sum_i.java\n+ * Created Time: 2023-06-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_backtracking;\n+\n+import java.util.*;\n+\n+public class subset_sum_i {\n+    /* 回溯算法：子集和 I */\n+    static void backtrack(List<Integer> state, int target, int[] choices, int start, List<List<Integer>> res) {\n+        // 子集和等于 target 时，记录解\n+        if (target == 0) {\n+            res.add(new ArrayList<>(state));\n+            return;\n+        }\n+        // 遍历所有选择\n+        // 剪枝二：从 start 开始遍历，避免生成重复子集\n+        for (int i = start; i < choices.length; i++) {\n+            // 剪枝一：若子集和超过 target ，则直接结束循环\n+            // 这是因为数组已排序，后边元素更大，子集和一定超过 target\n+            if (target - choices[i] < 0) {\n+                break;\n+            }\n+            // 尝试：做出选择，更新 target, start\n+            state.add(choices[i]);\n+            // 进行下一轮选择\n+            backtrack(state, target - choices[i], choices, i, res);\n+            // 回退：撤销选择，恢复到之前的状态\n+            state.remove(state.size() - 1);\n+        }\n+    }\n+\n+    /* 求解子集和 I */\n+    static List<List<Integer>> subsetSumI(int[] nums, int target) {\n+        List<Integer> state = new ArrayList<>(); // 状态（子集）\n+        Arrays.sort(nums); // 对 nums 进行排序\n+        int start = 0; // 遍历起始点\n+        List<List<Integer>> res = new ArrayList<>(); // 结果列表（子集列表）\n+        backtrack(state, target, nums, start, res);\n+        return res;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 3, 4, 5 };\n+        int target = 9;\n+\n+        List<List<Integer>> res = subsetSumI(nums, target);\n+\n+        System.out.println(\"输入数组 nums = \" + Arrays.toString(nums) + \", target = \" + target);\n+        System.out.println(\"所有和等于 \" + target + \" 的子集 res = \" + res);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_backtracking/subset_sum_i_naive.java b/codes/java/chapter_backtracking/subset_sum_i_naive.java\n--- a/codes/java/chapter_backtracking/subset_sum_i_naive.java\n+++ b/codes/java/chapter_backtracking/subset_sum_i_naive.java\n@@ -0,0 +1,53 @@\n+/**\n+ * File: subset_sum_i_naive.java\n+ * Created Time: 2023-06-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_backtracking;\n+\n+import java.util.*;\n+\n+public class subset_sum_i_naive {\n+    /* 回溯算法：子集和 I */\n+    static void backtrack(List<Integer> state, int target, int total, int[] choices, List<List<Integer>> res) {\n+        // 子集和等于 target 时，记录解\n+        if (total == target) {\n+            res.add(new ArrayList<>(state));\n+            return;\n+        }\n+        // 遍历所有选择\n+        for (int i = 0; i < choices.length; i++) {\n+            // 剪枝：若子集和超过 target ，则跳过该选择\n+            if (total + choices[i] > target) {\n+                continue;\n+            }\n+            // 尝试：做出选择，更新元素和 total\n+            state.add(choices[i]);\n+            // 进行下一轮选择\n+            backtrack(state, target, total + choices[i], choices, res);\n+            // 回退：撤销选择，恢复到之前的状态\n+            state.remove(state.size() - 1);\n+        }\n+    }\n+\n+    /* 求解子集和 I（包含重复子集） */\n+    static List<List<Integer>> subsetSumINaive(int[] nums, int target) {\n+        List<Integer> state = new ArrayList<>(); // 状态（子集）\n+        int total = 0; // 子集和\n+        List<List<Integer>> res = new ArrayList<>(); // 结果列表（子集列表）\n+        backtrack(state, target, total, nums, res);\n+        return res;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 3, 4, 5 };\n+        int target = 9;\n+\n+        List<List<Integer>> res = subsetSumINaive(nums, target);\n+\n+        System.out.println(\"输入数组 nums = \" + Arrays.toString(nums) + \", target = \" + target);\n+        System.out.println(\"所有和等于 \" + target + \" 的子集 res = \" + res);\n+        System.out.println(\"请注意，该方法输出的结果包含重复集合\");\n+    }\n+}\n\ndiff --git a/codes/java/chapter_backtracking/subset_sum_ii.java b/codes/java/chapter_backtracking/subset_sum_ii.java\n--- a/codes/java/chapter_backtracking/subset_sum_ii.java\n+++ b/codes/java/chapter_backtracking/subset_sum_ii.java\n@@ -0,0 +1,60 @@\n+/**\n+ * File: subset_sum_ii.java\n+ * Created Time: 2023-06-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_backtracking;\n+\n+import java.util.*;\n+\n+public class subset_sum_ii {\n+    /* 回溯算法：子集和 II */\n+    static void backtrack(List<Integer> state, int target, int[] choices, int start, List<List<Integer>> res) {\n+        // 子集和等于 target 时，记录解\n+        if (target == 0) {\n+            res.add(new ArrayList<>(state));\n+            return;\n+        }\n+        // 遍历所有选择\n+        // 剪枝二：从 start 开始遍历，避免生成重复子集\n+        // 剪枝三：从 start 开始遍历，避免重复选择同一元素\n+        for (int i = start; i < choices.length; i++) {\n+            // 剪枝一：若子集和超过 target ，则直接结束循环\n+            // 这是因为数组已排序，后边元素更大，子集和一定超过 target\n+            if (target - choices[i] < 0) {\n+                break;\n+            }\n+            // 剪枝四：如果该元素与左边元素相等，说明该搜索分支重复，直接跳过\n+            if (i > start && choices[i] == choices[i - 1]) {\n+                continue;\n+            }\n+            // 尝试：做出选择，更新 target, start\n+            state.add(choices[i]);\n+            // 进行下一轮选择\n+            backtrack(state, target - choices[i], choices, i + 1, res);\n+            // 回退：撤销选择，恢复到之前的状态\n+            state.remove(state.size() - 1);\n+        }\n+    }\n+\n+    /* 求解子集和 II */\n+    static List<List<Integer>> subsetSumII(int[] nums, int target) {\n+        List<Integer> state = new ArrayList<>(); // 状态（子集）\n+        Arrays.sort(nums); // 对 nums 进行排序\n+        int start = 0; // 遍历起始点\n+        List<List<Integer>> res = new ArrayList<>(); // 结果列表（子集列表）\n+        backtrack(state, target, nums, start, res);\n+        return res;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 4, 4, 5 };\n+        int target = 9;\n+\n+        List<List<Integer>> res = subsetSumII(nums, target);\n+\n+        System.out.println(\"输入数组 nums = \" + Arrays.toString(nums) + \", target = \" + target);\n+        System.out.println(\"所有和等于 \" + target + \" 的子集 res = \" + res);\n+    }\n+}",
    "output": "Add the section of subset sum problem. (#558)"
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/n_queens.java b/codes/java/chapter_backtracking/n_queens.java\n--- a/codes/java/chapter_backtracking/n_queens.java\n+++ b/codes/java/chapter_backtracking/n_queens.java\n@@ -26,8 +26,8 @@ public static void backtrack(int row, int n, List<List<String>> state, List<List\n             // 计算该格子对应的主对角线和副对角线\n             int diag1 = row - col + n - 1;\n             int diag2 = row + col;\n-            // 剪枝：不允许该格子所在 (列 或 主对角线 或 副对角线) 包含皇后\n-            if (!(cols[col] || diags1[diag1] || diags2[diag2])) {\n+            // 剪枝：不允许该格子所在列、主对角线、副对角线存在皇后\n+            if (!cols[col] && !diags1[diag1] && !diags2[diag2]) {\n                 // 尝试：将皇后放置在该格子\n                 state.get(row).set(col, \"Q\");\n                 cols[col] = diags1[diag1] = diags2[diag2] = true;",
    "output": "Update n_queens code."
  },
  {
    "input": "diff --git a/codes/java/chapter_heap/top_k.java b/codes/java/chapter_heap/top_k.java\n--- a/codes/java/chapter_heap/top_k.java\n+++ b/codes/java/chapter_heap/top_k.java\n@@ -0,0 +1,39 @@\n+/**\n+ * File: top_k.java\n+ * Created Time: 2023-06-12\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_heap;\n+\n+import utils.*;\n+import java.util.*;\n+\n+public class top_k {\n+    /* 基于堆查找数组中最大的 k 个元素 */\n+    static Queue<Integer> topKHeap(int[] nums, int k) {\n+        Queue<Integer> heap = new PriorityQueue<Integer>();\n+        // 将数组的前 k 个元素入堆\n+        for (int i = 0; i < k; i++) {\n+            heap.add(nums[i]);\n+        }\n+        // 从第 k+1 个元素开始，保持堆的长度为 k\n+        for (int i = k; i < nums.length; i++) {\n+            // 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆\n+            if (nums[i] > heap.peek()) {\n+                heap.poll();\n+                heap.add(nums[i]);\n+            }\n+        }\n+        return heap;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 1, 7, 6, 3, 2 };\n+        int k = 3;\n+\n+        Queue<Integer> res = topKHeap(nums, k);\n+        System.out.println(\"最大的 \" + k + \" 个元素为\");\n+        PrintUtil.printHeap(res);\n+    }\n+}",
    "output": "feat: Add the section of Top-K problem (#551)\n\n* Add the section of Top-K problem\r\n\r\n* Update my_heap.py\r\n\r\n* Update build_heap.md\r\n\r\n* Update my_heap.py"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -109,10 +109,15 @@ public void remove(int num) {\n             // 当子节点数量 = 0 / 1 时， child = null / 该子节点\n             TreeNode child = cur.left != null ? cur.left : cur.right;\n             // 删除节点 cur\n-            if (pre.left == cur)\n-                pre.left = child;\n-            else\n-                pre.right = child;\n+            if (cur != root) {\n+                if (pre.left == cur)\n+                    pre.left = child;\n+                else\n+                    pre.right = child;\n+            } else {\n+                // 若删除节点为根节点，则重新指定根节点\n+                root = child;\n+            }\n         }\n         // 子节点数量 = 2\n         else {",
    "output": "Fix remove() in binary search tree."
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/heap_sort.java b/codes/java/chapter_sorting/heap_sort.java\n--- a/codes/java/chapter_sorting/heap_sort.java\n+++ b/codes/java/chapter_sorting/heap_sort.java\n@@ -0,0 +1,57 @@\n+/**\n+ * File: heap_sort.java\n+ * Created Time: 2023-05-26\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_sorting;\n+\n+import java.util.Arrays;\n+\n+public class heap_sort {\n+    /* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */\n+    public static void siftDown(int[] nums, int n, int i) {\n+        while (true) {\n+            // 判断节点 i, l, r 中值最大的节点，记为 ma\n+            int l = 2 * i + 1;\n+            int r = 2 * i + 2;\n+            int ma = i;\n+            if (l < n && nums[l] > nums[ma])\n+                ma = l;\n+            if (r < n && nums[r] > nums[ma])\n+                ma = r;\n+            // 若节点 i 最大或索引 l, r 越界，则无需继续堆化，跳出\n+            if (ma == i)\n+                break;\n+            // 交换两节点\n+            int temp = nums[i];\n+            nums[i] = nums[ma];\n+            nums[ma] = temp;\n+            // 循环向下堆化\n+            i = ma;\n+        }\n+    }\n+\n+    /* 堆排序 */\n+    public static void heapSort(int[] nums) {\n+        // 建堆操作：堆化除叶节点以外的其他所有节点\n+        for (int i = nums.length / 2 - 1; i >= 0; i--) {\n+            siftDown(nums, nums.length, i);\n+        }\n+        // 从堆中提取最大元素，循环 n-1 轮\n+        for (int i = nums.length - 1; i > 0; i--) {\n+            // 交换根节点与最右叶节点（即交换首元素与尾元素）\n+            int tmp = nums[0];\n+            nums[0] = nums[i];\n+            nums[i] = tmp;\n+            // 以根节点为起点，从顶至底进行堆化\n+            siftDown(nums, i, 0);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 4, 1, 3, 1, 5, 2 };\n+        heapSort(nums);\n+        System.out.println(\"堆排序完成后 nums = \" + Arrays.toString(nums));\n+    }\n+}",
    "output": "feat: Add the section of heap sort. (#516)\n\n* Add the section of heap sort.\r\n\r\n* Update heap_sort.cpp"
  },
  {
    "input": "diff --git a/codes/java/chapter_heap/my_heap.java b/codes/java/chapter_heap/my_heap.java\n--- a/codes/java/chapter_heap/my_heap.java\n+++ b/codes/java/chapter_heap/my_heap.java\n@@ -41,10 +41,8 @@ private int parent(int i) {\n \n     /* 交换元素 */\n     private void swap(int i, int j) {\n-        int a = maxHeap.get(i);\n-        int b = maxHeap.get(j);\n-        int tmp = a;\n-        maxHeap.set(i, b);\n+        int tmp = maxHeap.get(i);\n+        maxHeap.set(i, maxHeap.get(j));\n         maxHeap.set(j, tmp);\n     }\n ",
    "output": "Update the section of heap."
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/selection_sort.java b/codes/java/chapter_sorting/selection_sort.java\n--- a/codes/java/chapter_sorting/selection_sort.java\n+++ b/codes/java/chapter_sorting/selection_sort.java\n@@ -14,12 +14,11 @@ public static void selectionSort(int[] nums) {\n         int n = nums.length;\n         // 外循环：未排序区间为 [i, n-1]\n         for (int i = 0; i < n - 1; i++) {\n-            // 内循环：找到未排序区间 [i, n-1] 中的最小元素\n+            // 内循环：找到未排序区间内的最小元素\n             int k = i;\n             for (int j = i + 1; j < n; j++) {\n-                if (nums[j] < nums[k]) {\n-                    k = j; // 更新最小元素\n-                }\n+                if (nums[j] < nums[k])\n+                    k = j; // 记录最小元素的索引\n             }\n             // 将该最小元素与未排序区间的首个元素交换\n             int temp = nums[i];",
    "output": "Polish some contents."
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/selection_sort.java b/codes/java/chapter_sorting/selection_sort.java\n--- a/codes/java/chapter_sorting/selection_sort.java\n+++ b/codes/java/chapter_sorting/selection_sort.java\n@@ -0,0 +1,36 @@\n+/**\n+ * File: selection_sort.java\n+ * Created Time: 2023-05-23\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_sorting;\n+\n+import java.util.Arrays;\n+\n+public class selection_sort {\n+    /* 选择排序 */\n+    public static void selectionSort(int[] nums) {\n+        int n = nums.length;\n+        // 外循环：未排序区间为 [i, n-1]\n+        for (int i = 0; i < n - 1; i++) {\n+            // 内循环：找到未排序区间 [i, n-1] 中的最小元素\n+            int k = i;\n+            for (int j = i + 1; j < n; j++) {\n+                if (nums[j] < nums[k]) {\n+                    k = j; // 更新最小元素\n+                }\n+            }\n+            // 将该最小元素与未排序区间的首个元素交换\n+            int temp = nums[i];\n+            nums[i] = nums[k];\n+            nums[k] = temp;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 4, 1, 3, 1, 5, 2 };\n+        selectionSort(nums);\n+        System.out.println(\"选择排序完成后 nums = \" + Arrays.toString(nums));\n+    }\n+}",
    "output": "Add the section of selection sort. (#513)"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/quick_sort.java b/codes/java/chapter_sorting/quick_sort.java\n--- a/codes/java/chapter_sorting/quick_sort.java\n+++ b/codes/java/chapter_sorting/quick_sort.java\n@@ -131,10 +131,10 @@ public static void quickSort(int[] nums, int left, int right) {\n             // 对两个子数组中较短的那个执行快排\n             if (pivot - left < right - pivot) {\n                 quickSort(nums, left, pivot - 1); // 递归排序左子数组\n-                left = pivot + 1; // 剩余待排序区间为 [pivot + 1, right]\n+                left = pivot + 1; // 剩余未排序区间为 [pivot + 1, right]\n             } else {\n                 quickSort(nums, pivot + 1, right); // 递归排序右子数组\n-                right = pivot - 1; // 剩余待排序区间为 [left, pivot - 1]\n+                right = pivot - 1; // 剩余未排序区间为 [left, pivot - 1]\n             }\n         }\n     }",
    "output": "Update bubble sort and insertion sort."
  },
  {
    "input": "diff --git a/codes/java/chapter_searching/binary_search.java b/codes/java/chapter_searching/binary_search.java\n--- a/codes/java/chapter_searching/binary_search.java\n+++ b/codes/java/chapter_searching/binary_search.java\n@@ -45,7 +45,7 @@ else if (nums[m] > target) // 此情况说明 target 在区间 [i, m) 中\n \n     public static void main(String[] args) {\n         int target = 6;\n-        int[] nums = { 1, 3, 6, 8, 12, 15, 23, 67, 70, 92 };\n+        int[] nums = { 1, 3, 6, 8, 12, 15, 23, 26, 31, 35 };\n \n         /* 二分查找（双闭区间） */\n         int index = binarySearch(nums, target);",
    "output": "Fix the test case of binary search."
  },
  {
    "input": "diff --git a/codes/java/chapter_searching/binary_search.java b/codes/java/chapter_searching/binary_search.java\n--- a/codes/java/chapter_searching/binary_search.java\n+++ b/codes/java/chapter_searching/binary_search.java\n@@ -4,7 +4,7 @@\n  * Author: Krahets (krahets@163.com)\n  */\n \n-package chapter_binary_search;\n+package chapter_searching;\n \n public class binary_search {\n     /* 二分查找（双闭区间） */\n\ndiff --git a/codes/java/chapter_searching/binary_search_edge.java b/codes/java/chapter_searching/binary_search_edge.java\n--- a/codes/java/chapter_searching/binary_search_edge.java\n+++ b/codes/java/chapter_searching/binary_search_edge.java\n@@ -4,7 +4,7 @@\n  * Author: Krahets (krahets@163.com)\n  */\n \n-package chapter_binary_search;\n+package chapter_searching;\n \n public class binary_search_edge {\n     /* 二分查找最左一个元素 */",
    "output": "Merge the chapter of binary tree and searching."
  },
  {
    "input": "diff --git a/codes/java/chapter_binary_search/binary_search_edge.java b/codes/java/chapter_binary_search/binary_search_edge.java\n--- a/codes/java/chapter_binary_search/binary_search_edge.java\n+++ b/codes/java/chapter_binary_search/binary_search_edge.java\n@@ -0,0 +1,56 @@\n+/**\n+ * File: binary_search_edge.java\n+ * Created Time: 2023-05-21\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_binary_search;\n+\n+public class binary_search_edge {\n+    /* 二分查找最左一个元素 */\n+    static int binarySearchLeftEdge(int[] nums, int target) {\n+        int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1]\n+        while (i <= j) {\n+            int m = i + (j - i) / 2; // 计算中点索引 m\n+            if (nums[m] < target)\n+                i = m + 1; // target 在区间 [m+1, j] 中\n+            else if (nums[m] > target)\n+                j = m - 1; // target 在区间 [i, m-1] 中\n+            else\n+                j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中\n+        }\n+        if (i == nums.length || nums[i] != target)\n+            return -1; // 未找到目标元素，返回 -1\n+        return i;\n+    }\n+\n+    /* 二分查找最右一个元素 */\n+    static int binarySearchRightEdge(int[] nums, int target) {\n+        int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1]\n+        while (i <= j) {\n+            int m = i + (j - i) / 2; // 计算中点索引 m\n+            if (nums[m] < target)\n+                i = m + 1; // target 在区间 [m+1, j] 中\n+            else if (nums[m] > target)\n+                j = m - 1; // target 在区间 [i, m-1] 中\n+            else\n+                i = m + 1; // 首个大于 target 的元素在区间 [m+1, j] 中\n+        }\n+        if (j < 0 || nums[j] != target)\n+            return -1; // 未找到目标元素，返回 -1\n+        return j;\n+    }\n+\n+    public static void main(String[] args) {\n+        int target = 6;\n+        int[] nums = { 1, 3, 6, 6, 6, 6, 6, 10, 12, 15 };\n+\n+        // 二分查找最左一个元素\n+        int indexLeft = binarySearchLeftEdge(nums, target);\n+        System.out.println(\"数组中最左一个元素 6 的索引 = \" + indexLeft);\n+\n+        // 二分查找最右一个元素\n+        int indexRight = binarySearchRightEdge(nums, target);\n+        System.out.println(\"数组中最右一个元素 6 的索引 = \" + indexRight);\n+    }\n+}",
    "output": "feat: Add the section of binary search edge. (#508)\n\n* Add the section of binary search edge.\r\n\r\n* Delete binary_search_rotation.py"
  },
  {
    "input": "diff --git a/codes/java/chapter_binary_search/binary_search.java b/codes/java/chapter_binary_search/binary_search.java\n--- a/codes/java/chapter_binary_search/binary_search.java\n+++ b/codes/java/chapter_binary_search/binary_search.java\n@@ -13,12 +13,12 @@ static int binarySearch(int[] nums, int target) {\n         int i = 0, j = nums.length - 1;\n         // 循环，当搜索区间为空时跳出（当 i > j 时为空）\n         while (i <= j) {\n-            int m = (i + j) / 2;       // 计算中点索引 m\n-            if (nums[m] < target)      // 此情况说明 target 在区间 [m+1, j] 中\n+            int m = i + (j - i) / 2; // 计算中点索引 m\n+            if (nums[m] < target) // 此情况说明 target 在区间 [m+1, j] 中\n                 i = m + 1;\n             else if (nums[m] > target) // 此情况说明 target 在区间 [i, m-1] 中\n                 j = m - 1;\n-            else                       // 找到目标元素，返回其索引\n+            else // 找到目标元素，返回其索引\n                 return m;\n         }\n         // 未找到目标元素，返回 -1\n@@ -31,12 +31,12 @@ static int binarySearchLCRO(int[] nums, int target) {\n         int i = 0, j = nums.length;\n         // 循环，当搜索区间为空时跳出（当 i = j 时为空）\n         while (i < j) {\n-            int m = (i + j) / 2;       // 计算中点索引 m\n-            if (nums[m] < target)      // 此情况说明 target 在区间 [m+1, j) 中\n+            int m = i + (j - i) / 2; // 计算中点索引 m\n+            if (nums[m] < target) // 此情况说明 target 在区间 [m+1, j) 中\n                 i = m + 1;\n             else if (nums[m] > target) // 此情况说明 target 在区间 [i, m) 中\n                 j = m;\n-            else                       // 找到目标元素，返回其索引\n+            else // 找到目标元素，返回其索引\n                 return m;\n         }\n         // 未找到目标元素，返回 -1",
    "output": "Refactor the section of bianry search."
  },
  {
    "input": "diff --git a/codes/java/chapter_binary_search/binary_search.java b/codes/java/chapter_binary_search/binary_search.java\n--- a/codes/java/chapter_binary_search/binary_search.java\n+++ b/codes/java/chapter_binary_search/binary_search.java\n@@ -26,7 +26,7 @@ else if (nums[m] > target) // 此情况说明 target 在区间 [i, m-1] 中\n     }\n \n     /* 二分查找（左闭右开） */\n-    static int binarySearch1(int[] nums, int target) {\n+    static int binarySearchLCRO(int[] nums, int target) {\n         // 初始化左闭右开 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1\n         int i = 0, j = nums.length;\n         // 循环，当搜索区间为空时跳出（当 i = j 时为空）\n@@ -52,7 +52,7 @@ public static void main(String[] args) {\n         System.out.println(\"目标元素 6 的索引 = \" + index);\n \n         /* 二分查找（左闭右开） */\n-        index = binarySearch1(nums, target);\n+        index = binarySearchLCRO(nums, target);\n         System.out.println(\"目标元素 6 的索引 = \" + index);\n     }\n }",
    "output": "Polish some cotents."
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/bucket_sort.java b/codes/java/chapter_sorting/bucket_sort.java\n--- a/codes/java/chapter_sorting/bucket_sort.java\n+++ b/codes/java/chapter_sorting/bucket_sort.java\n@@ -20,7 +20,7 @@ static void bucketSort(float[] nums) {\n         // 1. 将数组元素分配到各个桶中\n         for (float num : nums) {\n             // 输入数据范围 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]\n-            int i = (int) num * k;\n+            int i = (int) (num * k);\n             // 将 num 添加进桶 i\n             buckets.get(i).add(num);\n         }",
    "output": "Fix bucket_sort."
  },
  {
    "input": "diff --git a/codes/java/chapter_searching/two_sum.java b/codes/java/chapter_searching/two_sum.java\n--- a/codes/java/chapter_searching/two_sum.java\n+++ b/codes/java/chapter_searching/two_sum.java\n@@ -1,5 +1,5 @@\n /**\n- * File: leetcode_two_sum.java\n+ * File: two_sum.java\n  * Created Time: 2022-11-25\n  * Author: Krahets (krahets@163.com)\n  */\n@@ -8,7 +8,7 @@\n \n import java.util.*;\n \n-public class leetcode_two_sum {\n+public class two_sum {\n     /* 方法一：暴力枚举 */\n     static int[] twoSumBruteForce(int[] nums, int target) {\n         int size = nums.length;\n@@ -40,7 +40,7 @@ static int[] twoSumHashTable(int[] nums, int target) {\n     public static void main(String[] args) {\n         // ======= Test Case =======\n         int[] nums = { 2, 7, 11, 15 };\n-        int target = 9;\n+        int target = 13;\n \n         // ====== Driver Code ======\n         // 方法一",
    "output": "Add figures to replace_linear_by_hashing.md"
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/n_queens.java b/codes/java/chapter_backtracking/n_queens.java\n--- a/codes/java/chapter_backtracking/n_queens.java\n+++ b/codes/java/chapter_backtracking/n_queens.java\n@@ -9,27 +9,6 @@\n import java.util.*;\n \n public class n_queens {\n-    /* 求解 N 皇后 */\n-    public static List<List<List<String>>> nQueens(int n) {\n-        // 初始化 n*n 大小的棋盘，其中 'Q' 代表皇后，'#' 代表空位\n-        List<List<String>> state = new ArrayList<>();\n-        for (int i = 0; i < n; i++) {\n-            List<String> row = new ArrayList<>();\n-            for (int j = 0; j < n; j++) {\n-                row.add(\"#\");\n-            }\n-            state.add(row);\n-        }\n-        boolean[] cols = new boolean[n]; // 记录列是否有皇后\n-        boolean[] diags1 = new boolean[2 * n - 1]; // 记录主对角线是否有皇后\n-        boolean[] diags2 = new boolean[2 * n - 1]; // 记录副对角线是否有皇后\n-        List<List<List<String>>> res = new ArrayList<>();\n-\n-        backtrack(0, n, state, res, cols, diags1, diags2);\n-\n-        return res;\n-    }\n-\n     /* 回溯算法：N 皇后 */\n     public static void backtrack(int row, int n, List<List<String>> state, List<List<List<String>>> res,\n             boolean[] cols, boolean[] diags1, boolean[] diags2) {\n@@ -61,6 +40,27 @@ public static void backtrack(int row, int n, List<List<String>> state, List<List\n         }\n     }\n \n+    /* 求解 N 皇后 */\n+    public static List<List<List<String>>> nQueens(int n) {\n+        // 初始化 n*n 大小的棋盘，其中 'Q' 代表皇后，'#' 代表空位\n+        List<List<String>> state = new ArrayList<>();\n+        for (int i = 0; i < n; i++) {\n+            List<String> row = new ArrayList<>();\n+            for (int j = 0; j < n; j++) {\n+                row.add(\"#\");\n+            }\n+            state.add(row);\n+        }\n+        boolean[] cols = new boolean[n]; // 记录列是否有皇后\n+        boolean[] diags1 = new boolean[2 * n - 1]; // 记录主对角线是否有皇后\n+        boolean[] diags2 = new boolean[2 * n - 1]; // 记录副对角线是否有皇后\n+        List<List<List<String>>> res = new ArrayList<>();\n+\n+        backtrack(0, n, state, res, cols, diags1, diags2);\n+\n+        return res;\n+    }\n+\n     public static void main(String[] args) {\n         int n = 4;\n         List<List<List<String>>> res = nQueens(n);",
    "output": "Update n queens."
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/n_queens.java b/codes/java/chapter_backtracking/n_queens.java\n--- a/codes/java/chapter_backtracking/n_queens.java\n+++ b/codes/java/chapter_backtracking/n_queens.java\n@@ -0,0 +1,77 @@\n+/**\n+ * File: n_queens.java\n+ * Created Time: 2023-05-04\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_backtracking;\n+\n+import java.util.*;\n+\n+public class n_queens {\n+    /* 求解 N 皇后 */\n+    public static List<List<List<String>>> nQueens(int n) {\n+        // 初始化 n*n 大小的棋盘，其中 'Q' 代表皇后，'#' 代表空位\n+        List<List<String>> state = new ArrayList<>();\n+        for (int i = 0; i < n; i++) {\n+            List<String> row = new ArrayList<>();\n+            for (int j = 0; j < n; j++) {\n+                row.add(\"#\");\n+            }\n+            state.add(row);\n+        }\n+        boolean[] cols = new boolean[n]; // 记录列是否有皇后\n+        boolean[] diags1 = new boolean[2 * n - 1]; // 记录主对角线是否有皇后\n+        boolean[] diags2 = new boolean[2 * n - 1]; // 记录副对角线是否有皇后\n+        List<List<List<String>>> res = new ArrayList<>();\n+\n+        backtrack(0, n, state, res, cols, diags1, diags2);\n+\n+        return res;\n+    }\n+\n+    /* 回溯算法：N 皇后 */\n+    public static void backtrack(int row, int n, List<List<String>> state, List<List<List<String>>> res,\n+            boolean[] cols, boolean[] diags1, boolean[] diags2) {\n+        // 当放置完所有行时，记录解\n+        if (row == n) {\n+            List<List<String>> copyState = new ArrayList<>();\n+            for (List<String> sRow : state) {\n+                copyState.add(new ArrayList<>(sRow));\n+            }\n+            res.add(copyState);\n+            return;\n+        }\n+        // 遍历所有列\n+        for (int col = 0; col < n; col++) {\n+            // 计算该格子对应的主对角线和副对角线\n+            int diag1 = row - col + n - 1;\n+            int diag2 = row + col;\n+            // 剪枝：不允许该格子所在 (列 或 主对角线 或 副对角线) 包含皇后\n+            if (!(cols[col] || diags1[diag1] || diags2[diag2])) {\n+                // 尝试：将皇后放置在该格子\n+                state.get(row).set(col, \"Q\");\n+                cols[col] = diags1[diag1] = diags2[diag2] = true;\n+                // 放置下一行\n+                backtrack(row + 1, n, state, res, cols, diags1, diags2);\n+                // 回退：将该格子恢复为空位\n+                state.get(row).set(col, \"#\");\n+                cols[col] = diags1[diag1] = diags2[diag2] = false;\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int n = 4;\n+        List<List<List<String>>> res = nQueens(n);\n+\n+        System.out.println(\"输入棋盘长宽为 \" + n);\n+        System.out.println(\"皇后放置方案共有 \" + res.size() + \" 种\");\n+        for (List<List<String>> state : res) {\n+            System.out.println(\"--------------------\");\n+            for (List<String> row : state) {\n+                System.out.println(row);\n+            }\n+        }\n+    }\n+}",
    "output": "feat: Add the section of n queens problem (#483)\n\n* Add the section of n queens problem\r\n\r\n* Update n_queens.py\r\n\r\n* Update n_queens.java\r\n\r\n* Update n_queens.cpp\r\n\r\n* Update n_queens.java"
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/permutations_i.java b/codes/java/chapter_backtracking/permutations_i.java\n--- a/codes/java/chapter_backtracking/permutations_i.java\n+++ b/codes/java/chapter_backtracking/permutations_i.java\n@@ -21,24 +21,29 @@ public static void backtrack(List<Integer> state, int[] choices, boolean[] selec\n             int choice = choices[i];\n             // 剪枝：不允许重复选择元素 且 不允许重复选择相等元素\n             if (!selected[i]) {\n-                // 尝试\n-                selected[i] = true; // 做出选择\n-                state.add(choice); // 更新状态\n+                // 尝试：做出选择，更新状态\n+                selected[i] = true;\n+                state.add(choice);\n                 backtrack(state, choices, selected, res);\n-                // 回退\n-                selected[i] = false; // 撤销选择\n-                state.remove(state.size() - 1); // 恢复到之前的状态\n+                // 回退：撤销选择，恢复到之前的状态\n+                selected[i] = false;\n+                state.remove(state.size() - 1);\n             }\n         }\n     }\n \n+    /* 全排列 I */\n+    static List<List<Integer>> permutationsI(int[] nums) {\n+        List<List<Integer>> res = new ArrayList<List<Integer>>();\n+        backtrack(new ArrayList<Integer>(), nums, new boolean[nums.length], res);\n+        return res;\n+    }\n+\n     public static void main(String[] args) {\n         int[] nums = { 1, 2, 3 };\n-        List<List<Integer>> res = new ArrayList<List<Integer>>();\n \n-        // 回溯算法\n-        backtrack(new ArrayList<Integer>(), nums, new boolean[nums.length], res);\n-        \n+        List<List<Integer>> res = permutationsI(nums);\n+\n         System.out.println(\"输入数组 nums = \" + Arrays.toString(nums));\n         System.out.println(\"所有排列 res = \" + res);\n     }\n\ndiff --git a/codes/java/chapter_backtracking/permutations_ii.java b/codes/java/chapter_backtracking/permutations_ii.java\n--- a/codes/java/chapter_backtracking/permutations_ii.java\n+++ b/codes/java/chapter_backtracking/permutations_ii.java\n@@ -10,7 +10,7 @@\n \n public class permutations_ii {\n     /* 回溯算法：全排列 II */\n-    public static void backtrack(List<Integer> state, int[] choices, boolean[] selected, List<List<Integer>> res) {\n+    static void backtrack(List<Integer> state, int[] choices, boolean[] selected, List<List<Integer>> res) {\n         // 当状态长度等于元素数量时，记录解\n         if (state.size() == choices.length) {\n             res.add(new ArrayList<Integer>(state));\n@@ -22,24 +22,29 @@ public static void backtrack(List<Integer> state, int[] choices, boolean[] selec\n             int choice = choices[i];\n             // 剪枝：不允许重复选择元素 且 不允许重复选择相等元素\n             if (!selected[i] && !duplicated.contains(choice)) {\n-                // 尝试\n+                // 尝试：做出选择，更新状态\n                 duplicated.add(choice); // 记录选择过的元素值\n-                selected[i] = true; // 做出选择\n-                state.add(choice); // 更新状态\n+                selected[i] = true;\n+                state.add(choice);\n                 backtrack(state, choices, selected, res);\n-                // 回退\n-                selected[i] = false; // 撤销选择\n-                state.remove(state.size() - 1); // 恢复到之前的状态\n+                // 回退：撤销选择，恢复到之前的状态\n+                selected[i] = false;\n+                state.remove(state.size() - 1);\n             }\n         }\n     }\n \n+    /* 全排列 II */\n+    static List<List<Integer>> permutationsII(int[] nums) {\n+        List<List<Integer>> res = new ArrayList<List<Integer>>();\n+        backtrack(new ArrayList<Integer>(), nums, new boolean[nums.length], res);\n+        return res;\n+    }\n+\n     public static void main(String[] args) {\n         int[] nums = { 1, 2, 2 };\n-        List<List<Integer>> res = new ArrayList<List<Integer>>();\n \n-        // 回溯算法\n-        backtrack(new ArrayList<Integer>(), nums, new boolean[nums.length], res);\n+        List<List<Integer>> res = permutationsII(nums);\n \n         System.out.println(\"输入数组 nums = \" + Arrays.toString(nums));\n         System.out.println(\"所有排列 res = \" + res);",
    "output": "Update the code of permutations i and ii"
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/permutations_i.java b/codes/java/chapter_backtracking/permutations_i.java\n--- a/codes/java/chapter_backtracking/permutations_i.java\n+++ b/codes/java/chapter_backtracking/permutations_i.java\n@@ -0,0 +1,45 @@\n+/**\n+ * File: permutations_i.java\n+ * Created Time: 2023-04-24\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_backtracking;\n+\n+import java.util.*;\n+\n+public class permutations_i {\n+    /* 回溯算法：全排列 I */\n+    public static void backtrack(List<Integer> state, int[] choices, boolean[] selected, List<List<Integer>> res) {\n+        // 当状态长度等于元素数量时，记录解\n+        if (state.size() == choices.length) {\n+            res.add(new ArrayList<Integer>(state));\n+            return;\n+        }\n+        // 遍历所有选择\n+        for (int i = 0; i < choices.length; i++) {\n+            int choice = choices[i];\n+            // 剪枝：不允许重复选择元素 且 不允许重复选择相等元素\n+            if (!selected[i]) {\n+                // 尝试\n+                selected[i] = true; // 做出选择\n+                state.add(choice); // 更新状态\n+                backtrack(state, choices, selected, res);\n+                // 回退\n+                selected[i] = false; // 撤销选择\n+                state.remove(state.size() - 1); // 恢复到之前的状态\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 1, 2, 3 };\n+        List<List<Integer>> res = new ArrayList<List<Integer>>();\n+\n+        // 回溯算法\n+        backtrack(new ArrayList<Integer>(), nums, new boolean[nums.length], res);\n+        \n+        System.out.println(\"输入数组 nums = \" + Arrays.toString(nums));\n+        System.out.println(\"所有排列 res = \" + res);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_backtracking/permutations_ii.java b/codes/java/chapter_backtracking/permutations_ii.java\n--- a/codes/java/chapter_backtracking/permutations_ii.java\n+++ b/codes/java/chapter_backtracking/permutations_ii.java\n@@ -0,0 +1,47 @@\n+/**\n+ * File: permutations_ii.java\n+ * Created Time: 2023-04-24\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_backtracking;\n+\n+import java.util.*;\n+\n+public class permutations_ii {\n+    /* 回溯算法：全排列 II */\n+    public static void backtrack(List<Integer> state, int[] choices, boolean[] selected, List<List<Integer>> res) {\n+        // 当状态长度等于元素数量时，记录解\n+        if (state.size() == choices.length) {\n+            res.add(new ArrayList<Integer>(state));\n+            return;\n+        }\n+        // 遍历所有选择\n+        Set<Integer> duplicated = new HashSet<Integer>();\n+        for (int i = 0; i < choices.length; i++) {\n+            int choice = choices[i];\n+            // 剪枝：不允许重复选择元素 且 不允许重复选择相等元素\n+            if (!selected[i] && !duplicated.contains(choice)) {\n+                // 尝试\n+                duplicated.add(choice); // 记录选择过的元素值\n+                selected[i] = true; // 做出选择\n+                state.add(choice); // 更新状态\n+                backtrack(state, choices, selected, res);\n+                // 回退\n+                selected[i] = false; // 撤销选择\n+                state.remove(state.size() - 1); // 恢复到之前的状态\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 1, 2, 2 };\n+        List<List<Integer>> res = new ArrayList<List<Integer>>();\n+\n+        // 回溯算法\n+        backtrack(new ArrayList<Integer>(), nums, new boolean[nums.length], res);\n+\n+        System.out.println(\"输入数组 nums = \" + Arrays.toString(nums));\n+        System.out.println(\"所有排列 res = \" + res);\n+    }\n+}",
    "output": "feat: Add the section of permutations problem. (#476)\n\n* Add the section of permutations problem.\r\n\r\n* Update permutations_problem.md"
  },
  {
    "input": "diff --git a/codes/java/chapter_heap/my_heap.java b/codes/java/chapter_heap/my_heap.java\n--- a/codes/java/chapter_heap/my_heap.java\n+++ b/codes/java/chapter_heap/my_heap.java\n@@ -90,7 +90,7 @@ private void siftUp(int i) {\n     public int pop() {\n         // 判空处理\n         if (isEmpty())\n-            throw new EmptyStackException();\n+            throw new IndexOutOfBoundsException();\n         // 交换根节点与最右叶节点（即交换首元素与尾元素）\n         swap(0, size() - 1);\n         // 删除节点\n\ndiff --git a/codes/java/chapter_stack_and_queue/array_deque.java b/codes/java/chapter_stack_and_queue/array_deque.java\n--- a/codes/java/chapter_stack_and_queue/array_deque.java\n+++ b/codes/java/chapter_stack_and_queue/array_deque.java\n@@ -89,14 +89,14 @@ public int popLast() {\n     /* 访问队首元素 */\n     public int peekFirst() {\n         if (isEmpty())\n-            throw new EmptyStackException();\n+            throw new IndexOutOfBoundsException();\n         return nums[front];\n     }\n \n     /* 访问队尾元素 */\n     public int peekLast() {\n         if (isEmpty())\n-            throw new EmptyStackException();\n+            throw new IndexOutOfBoundsException();\n         // 计算尾元素索引\n         int last = index(front + queSize - 1);\n         return nums[last];\n\ndiff --git a/codes/java/chapter_stack_and_queue/array_queue.java b/codes/java/chapter_stack_and_queue/array_queue.java\n--- a/codes/java/chapter_stack_and_queue/array_queue.java\n+++ b/codes/java/chapter_stack_and_queue/array_queue.java\n@@ -60,7 +60,7 @@ public int pop() {\n     /* 访问队首元素 */\n     public int peek() {\n         if (isEmpty())\n-            throw new EmptyStackException();\n+            throw new IndexOutOfBoundsException();\n         return nums[front];\n     }\n \n\ndiff --git a/codes/java/chapter_stack_and_queue/array_stack.java b/codes/java/chapter_stack_and_queue/array_stack.java\n--- a/codes/java/chapter_stack_and_queue/array_stack.java\n+++ b/codes/java/chapter_stack_and_queue/array_stack.java\n@@ -35,14 +35,14 @@ public void push(int num) {\n     /* 出栈 */\n     public int pop() {\n         if (isEmpty())\n-            throw new EmptyStackException();\n+            throw new IndexOutOfBoundsException();\n         return stack.remove(size() - 1);\n     }\n \n     /* 访问栈顶元素 */\n     public int peek() {\n         if (isEmpty())\n-            throw new EmptyStackException();\n+            throw new IndexOutOfBoundsException();\n         return stack.get(size() - 1);\n     }\n \n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_queue.java b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n@@ -56,7 +56,7 @@ public int pop() {\n     /* 访问队首元素 */\n     public int peek() {\n         if (size() == 0)\n-            throw new EmptyStackException();\n+            throw new IndexOutOfBoundsException();\n         return front.val;\n     }\n \n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_stack.java b/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n@@ -47,7 +47,7 @@ public int pop() {\n     /* 访问栈顶元素 */\n     public int peek() {\n         if (size() == 0)\n-            throw new EmptyStackException();\n+            throw new IndexOutOfBoundsException();\n         return stackPeek.val;\n     }\n ",
    "output": "Modify the exception handling in Java and Python."
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/preorder_traversal_i_compact.java b/codes/java/chapter_backtracking/preorder_traversal_i_compact.java\n--- a/codes/java/chapter_backtracking/preorder_traversal_i_compact.java\n+++ b/codes/java/chapter_backtracking/preorder_traversal_i_compact.java\n@@ -1,5 +1,5 @@\n /**\n- * File: preorder_find_nodes.java\n+ * File: preorder_traversal_i_compact.java\n  * Created Time: 2023-04-16\n  * Author: Krahets (krahets@163.com)\n  */\n@@ -9,10 +9,10 @@\n import include.*;\n import java.util.*;\n \n-public class preorder_find_nodes {\n+public class preorder_traversal_i_compact {\n     static List<TreeNode> res;\n \n-    /* 前序遍历 */\n+    /* 前序遍历：例题一 */\n     static void preOrder(TreeNode root) {\n         if (root == null) {\n             return;\n\ndiff --git a/codes/java/chapter_backtracking/preorder_traversal_ii_compact.java b/codes/java/chapter_backtracking/preorder_traversal_ii_compact.java\n--- a/codes/java/chapter_backtracking/preorder_traversal_ii_compact.java\n+++ b/codes/java/chapter_backtracking/preorder_traversal_ii_compact.java\n@@ -1,5 +1,5 @@\n /**\n- * File: preorder_find_paths.java\n+ * File: preorder_traversal_ii_compact.java\n  * Created Time: 2023-04-16\n  * Author: Krahets (krahets@163.com)\n  */\n@@ -9,11 +9,11 @@\n import include.*;\n import java.util.*;\n \n-public class preorder_find_paths {\n+public class preorder_traversal_ii_compact {\n     static List<TreeNode> path;\n     static List<List<TreeNode>> res;\n \n-    /* 前序遍历 */\n+    /* 前序遍历：例题二 */\n     static void preOrder(TreeNode root) {\n         if (root == null) {\n             return;\n\ndiff --git a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n--- a/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n+++ b/codes/java/chapter_backtracking/preorder_traversal_iii_compact.java\n@@ -1,5 +1,5 @@\n /**\n- * File: preorder_find_constrained_paths.java\n+ * File: preorder_traversal_iii_compact.java\n  * Created Time: 2023-04-16\n  * Author: Krahets (krahets@163.com)\n  */\n@@ -9,11 +9,11 @@\n import include.*;\n import java.util.*;\n \n-public class preorder_find_constrained_paths {\n+public class preorder_traversal_iii_compact {\n     static List<TreeNode> path;\n     static List<List<TreeNode>> res;\n \n-    /* 前序遍历 */\n+    /* 前序遍历：例题三 */\n     static void preOrder(TreeNode root) {\n         // 剪枝\n         if (root == null || root.val == 3) {\n\ndiff --git a/codes/java/chapter_backtracking/preorder_traversal_iii_template.java b/codes/java/chapter_backtracking/preorder_traversal_iii_template.java\n--- a/codes/java/chapter_backtracking/preorder_traversal_iii_template.java\n+++ b/codes/java/chapter_backtracking/preorder_traversal_iii_template.java\n@@ -1,5 +1,5 @@\n /**\n- * File: backtrack_find_constrained_paths.java\n+ * File: preorder_traversal_iii_template.java\n  * Created Time: 2023-04-16\n  * Author: Krahets (krahets@163.com)\n  */\n@@ -9,7 +9,7 @@\n import include.*;\n import java.util.*;\n \n-public class backtrack_find_constrained_paths {\n+public class preorder_traversal_iii_template {\n     /* 判断当前状态是否为解 */\n     static boolean isSolution(List<TreeNode> state) {\n         return !state.isEmpty() && state.get(state.size() - 1).val == 7;\n@@ -35,7 +35,7 @@ static void undoChoice(List<TreeNode> state, TreeNode choice) {\n         state.remove(state.size() - 1);\n     }\n \n-    /* 回溯算法 */\n+    /* 回溯算法：例题三 */\n     static void backtrack(List<TreeNode> state, List<TreeNode> choices, List<List<TreeNode>> res) {\n         // 检查是否为解\n         if (isSolution(state)) {",
    "output": "Rename the naming of the coding files\nin backtracking algorithm.\nAdd the typedef to docs."
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/backtrack_find_constrained_paths.java b/codes/java/chapter_backtracking/backtrack_find_constrained_paths.java\n--- a/codes/java/chapter_backtracking/backtrack_find_constrained_paths.java\n+++ b/codes/java/chapter_backtracking/backtrack_find_constrained_paths.java\n@@ -4,6 +4,8 @@\n  * Author: Krahets (krahets@163.com)\n  */\n \n+package chapter_backtracking;\n+\n import include.*;\n import java.util.*;\n \n\ndiff --git a/codes/java/chapter_backtracking/preorder_find_constrained_paths.java b/codes/java/chapter_backtracking/preorder_find_constrained_paths.java\n--- a/codes/java/chapter_backtracking/preorder_find_constrained_paths.java\n+++ b/codes/java/chapter_backtracking/preorder_find_constrained_paths.java\n@@ -4,6 +4,8 @@\n  * Author: Krahets (krahets@163.com)\n  */\n \n+package chapter_backtracking;\n+\n import include.*;\n import java.util.*;\n \n\ndiff --git a/codes/java/chapter_backtracking/preorder_find_nodes.java b/codes/java/chapter_backtracking/preorder_find_nodes.java\n--- a/codes/java/chapter_backtracking/preorder_find_nodes.java\n+++ b/codes/java/chapter_backtracking/preorder_find_nodes.java\n@@ -4,6 +4,8 @@\n  * Author: Krahets (krahets@163.com)\n  */\n \n+package chapter_backtracking;\n+\n import include.*;\n import java.util.*;\n \n\ndiff --git a/codes/java/chapter_backtracking/preorder_find_paths.java b/codes/java/chapter_backtracking/preorder_find_paths.java\n--- a/codes/java/chapter_backtracking/preorder_find_paths.java\n+++ b/codes/java/chapter_backtracking/preorder_find_paths.java\n@@ -4,6 +4,8 @@\n  * Author: Krahets (krahets@163.com)\n  */\n \n+package chapter_backtracking;\n+\n import include.*;\n import java.util.*;\n \n\ndiff --git a/codes/java/chapter_binary_search/binary_search.java b/codes/java/chapter_binary_search/binary_search.java\n--- a/codes/java/chapter_binary_search/binary_search.java\n+++ b/codes/java/chapter_binary_search/binary_search.java\n@@ -4,7 +4,7 @@\n  * Author: Krahets (krahets@163.com)\n  */\n \n-package chapter_searching;\n+package chapter_binary_search;\n \n public class binary_search {\n     /* 二分查找（双闭区间） */\n\ndiff --git a/codes/java/chapter_searching/leetcode_two_sum.java b/codes/java/chapter_searching/leetcode_two_sum.java\n--- a/codes/java/chapter_searching/leetcode_two_sum.java\n+++ b/codes/java/chapter_searching/leetcode_two_sum.java\n@@ -4,7 +4,7 @@\n  * Author: Krahets (krahets@163.com)\n  */\n \n-package chapter_computational_complexity;\n+package chapter_searching;\n \n import java.util.*;\n ",
    "output": "Refactor the articles related to searching algorithm. Add the chapter of binary search. Add the section of searching algorithm revisited. (#464)"
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/preorder_find_nodes.java b/codes/java/chapter_backtracking/preorder_find_nodes.java\n--- a/codes/java/chapter_backtracking/preorder_find_nodes.java\n+++ b/codes/java/chapter_backtracking/preorder_find_nodes.java\n@@ -32,7 +32,7 @@ public static void main(String[] args) {\n         res = new ArrayList<>();\n         preOrder(root);\n \n-        System.out.println(\"\\n输出所有根节点到节点 7 的路径\");\n+        System.out.println(\"\\n输出所有值为 7 的节点\");\n         List<Integer> vals = new ArrayList<>();\n         for (TreeNode node : res) {\n             vals.add(node.val);",
    "output": "Add cpp code for the backtrack algorithm."
  },
  {
    "input": "diff --git a/codes/java/chapter_backtracking/preorder_find_nodes.java b/codes/java/chapter_backtracking/preorder_find_nodes.java\n--- a/codes/java/chapter_backtracking/preorder_find_nodes.java\n+++ b/codes/java/chapter_backtracking/preorder_find_nodes.java\n@@ -15,15 +15,12 @@ static void preOrder(TreeNode root) {\n         if (root == null) {\n             return;\n         }\n-        // 尝试\n         if (root.val == 7) {\n             // 记录解\n             res.add(root);\n         }\n         preOrder(root.left);\n         preOrder(root.right);\n-        // 回退\n-        return;\n     }\n \n     public static void main(String[] args) {",
    "output": "Fix the codes of backtracking."
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -127,17 +127,6 @@ public void remove(int num) {\n             cur.val = tmp.val;\n         }\n     }\n-\n-    /* 获取中序遍历中的下一个节点（仅适用于 root 有左子节点的情况） */\n-    public TreeNode getInOrderNext(TreeNode root) {\n-        if (root == null)\n-            return root;\n-        // 循环访问左子节点，直到叶节点时为最小节点，跳出\n-        while (root.left != null) {\n-            root = root.left;\n-        }\n-        return root;\n-    }\n }\n \n public class binary_search_tree {",
    "output": "Remove unused functions."
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/avl_tree.java b/codes/java/chapter_tree/avl_tree.java\n--- a/codes/java/chapter_tree/avl_tree.java\n+++ b/codes/java/chapter_tree/avl_tree.java\n@@ -92,9 +92,8 @@ private TreeNode rotate(TreeNode node) {\n     }\n \n     /* 插入节点 */\n-    public TreeNode insert(int val) {\n+    public void insert(int val) {\n         root = insertHelper(root, val);\n-        return root;\n     }\n \n     /* 递归插入节点（辅助方法） */\n@@ -116,9 +115,8 @@ else if (val > node.val)\n     }\n \n     /* 删除节点 */\n-    public TreeNode remove(int val) {\n+    public void remove(int val) {\n         root = removeHelper(root, val);\n-        return root;\n     }\n \n     /* 递归删除节点（辅助方法） */\n@@ -141,7 +139,10 @@ else if (val > node.val)\n                     node = child;\n             } else {\n                 // 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点\n-                TreeNode temp = getInOrderNext(node.right);\n+                TreeNode temp = node.right;\n+                while (temp.left != null) {\n+                    temp = temp.left;\n+                }\n                 node.right = removeHelper(node.right, temp.val);\n                 node.val = temp.val;\n             }\n@@ -153,17 +154,6 @@ else if (val > node.val)\n         return node;\n     }\n \n-    /* 获取中序遍历中的下一个节点（仅适用于 root 有左子节点的情况） */\n-    private TreeNode getInOrderNext(TreeNode node) {\n-        if (node == null)\n-            return node;\n-        // 循环访问左子节点，直到叶节点时为最小节点，跳出\n-        while (node.left != null) {\n-            node = node.left;\n-        }\n-        return node;\n-    }\n-\n     /* 查找节点 */\n     public TreeNode search(int val) {\n         TreeNode cur = root;\n\ndiff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -56,16 +56,16 @@ else if (cur.val > num)\n     }\n \n     /* 插入节点 */\n-    public TreeNode insert(int num) {\n+    public void insert(int num) {\n         // 若树为空，直接提前返回\n         if (root == null)\n-            return null;\n+            return;\n         TreeNode cur = root, pre = null;\n         // 循环查找，越过叶节点后跳出\n         while (cur != null) {\n             // 找到重复节点，直接返回\n             if (cur.val == num)\n-                return null;\n+                return;\n             pre = cur;\n             // 插入位置在 cur 的右子树中\n             if (cur.val < num)\n@@ -80,14 +80,13 @@ public TreeNode insert(int num) {\n             pre.right = node;\n         else\n             pre.left = node;\n-        return node;\n     }\n \n     /* 删除节点 */\n-    public TreeNode remove(int num) {\n+    public void remove(int num) {\n         // 若树为空，直接提前返回\n         if (root == null)\n-            return null;\n+            return;\n         TreeNode cur = root, pre = null;\n         // 循环查找，越过叶节点后跳出\n         while (cur != null) {\n@@ -104,7 +103,7 @@ public TreeNode remove(int num) {\n         }\n         // 若无待删除节点，则直接返回\n         if (cur == null)\n-            return null;\n+            return;\n         // 子节点数量 = 0 or 1\n         if (cur.left == null || cur.right == null) {\n             // 当子节点数量 = 0 / 1 时， child = null / 该子节点\n@@ -118,14 +117,15 @@ public TreeNode remove(int num) {\n         // 子节点数量 = 2\n         else {\n             // 获取中序遍历中 cur 的下一个节点\n-            TreeNode nex = getInOrderNext(cur.right);\n-            int tmp = nex.val;\n-            // 递归删除节点 nex\n-            remove(nex.val);\n-            // 将 nex 的值复制给 cur\n-            cur.val = tmp;\n+            TreeNode tmp = cur.right;\n+            while (tmp.left != null) {\n+                tmp = tmp.left;\n+            }\n+            // 递归删除节点 tmp\n+            remove(tmp.val);\n+            // 用 tmp 覆盖 cur\n+            cur.val = tmp.val;\n         }\n-        return cur;\n     }\n \n     /* 获取中序遍历中的下一个节点（仅适用于 root 有左子节点的情况） */\n@@ -153,7 +153,7 @@ public static void main(String[] args) {\n         System.out.println(\"\\n查找到的节点对象为 \" + node + \"，节点值 = \" + node.val);\n \n         /* 插入节点 */\n-        node = bst.insert(16);\n+        bst.insert(16);\n         System.out.println(\"\\n插入节点 16 后，二叉树为\\n\");\n         PrintUtil.printTree(bst.getRoot());\n ",
    "output": "Fix the return type of binary search tree and avl tree"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/radix_sort.java b/codes/java/chapter_sorting/radix_sort.java\n--- a/codes/java/chapter_sorting/radix_sort.java\n+++ b/codes/java/chapter_sorting/radix_sort.java\n@@ -16,51 +16,51 @@ static int digit(int num, int exp) {\n     }\n \n     /* 计数排序（根据 nums 第 k 位排序） */\n-    static void countingSort(int[] nums, int exp) {\n-        // 十进制的各位数字范围为 0~9 ，因此需要长度为 10 的桶\n-        int[] bucket = new int[10];\n+    static void countingSortDigit(int[] nums, int exp) {\n+        // 十进制的位范围为 0~9 ，因此需要长度为 10 的桶\n+        int[] counter = new int[10];\n         int n = nums.length;\n-        // 借助桶来统计 0~9 各数字的出现次数\n+        // 统计 0~9 各数字的出现次数\n         for (int i = 0; i < n; i++) {\n             int d = digit(nums[i], exp); // 获取 nums[i] 第 k 位，记为 d\n-            bucket[d]++;                 // 统计数字 d 的出现次数\n+            counter[d]++;                // 统计数字 d 的出现次数\n         }\n         // 求前缀和，将“出现个数”转换为“数组索引”\n         for (int i = 1; i < 10; i++) {\n-            bucket[i] += bucket[i - 1];\n+            counter[i] += counter[i - 1];\n         }\n-        // 倒序遍历，根据桶内统计结果，将各元素填入暂存数组 tmp\n-        int[] tmp = new int[n];\n+        // 倒序遍历，根据桶内统计结果，将各元素填入 res\n+        int[] res = new int[n];\n         for (int i = n - 1; i >= 0; i--) {\n             int d = digit(nums[i], exp);\n-            int j = bucket[d] - 1; // 获取 d 在数组中的索引 j\n-            tmp[j] = nums[i];      // 将当前元素填入索引 j\n-            bucket[d]--;           // 将 d 的数量减 1\n+            int j = counter[d] - 1; // 获取 d 在数组中的索引 j\n+            res[j] = nums[i];       // 将当前元素填入索引 j\n+            counter[d]--;           // 将 d 的数量减 1\n         }\n-        // 将 tmp 复制到 nums\n+        // 使用结果覆盖原数组 nums\n         for (int i = 0; i < n; i++)\n-            nums[i] = tmp[i];\n+            nums[i] = res[i];\n     }\n \n     /* 基数排序 */\n     static void radixSort(int[] nums) {\n         // 获取数组的最大元素，用于判断最大位数\n-        int ma = Integer.MIN_VALUE;\n+        int m = Integer.MIN_VALUE;\n         for (int num : nums)\n-            if (num > ma) ma = num;\n+            if (num > m) m = num;\n         // 按照从低位到高位的顺序遍历\n-        for (int exp = 1; ma >= exp; exp *= 10)\n-            // 对数组元素的第 k 位执行「计数排序」\n+        for (int exp = 1; exp <= m; exp *= 10)\n+            // 对数组元素的第 k 位执行计数排序\n             // k = 1 -> exp = 1\n             // k = 2 -> exp = 10\n-            // k = 3 -> exp = 100\n             // 即 exp = 10^(k-1)\n-            countingSort(nums, exp);\n+            countingSortDigit(nums, exp);\n     }\n \n     public static void main(String[] args) {\n-        /* 基数排序 */\n-        int[] nums = { 23, 12, 3, 4, 788, 192 };\n+        // 基数排序\n+        int[] nums = { 10546151, 35663510, 42865989, 34862445, 81883077, \n+                       88906420, 72429244, 30524779, 82060337, 63832996 };\n         radixSort(nums);\n         System.out.println(\"基数排序完成后 nums = \" + Arrays.toString(nums));\n     }",
    "output": "Add the section of radix sort. (#441)"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/bucket_sort.java b/codes/java/chapter_sorting/bucket_sort.java\n--- a/codes/java/chapter_sorting/bucket_sort.java\n+++ b/codes/java/chapter_sorting/bucket_sort.java\n@@ -11,7 +11,7 @@\n public class bucket_sort {\n     /* 桶排序 */\n     static void bucketSort(float[] nums) {\n-        // 初始化 k = n/3 个桶，预期向每个桶分配 3 个元素\n+        // 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素\n         int k = nums.length / 2;\n         List<List<Float>> buckets = new ArrayList<>();\n         for (int i = 0; i < k; i++) {\n@@ -40,7 +40,7 @@ static void bucketSort(float[] nums) {\n \n     public static void main(String[] args) {\n         // 设输入数据为浮点数，范围为 [0, 1)\n-        float[] nums = { 0.49f, 0.96f, 0.82f, 0.09f, 0.57f, 0.43f, 0.91f, 0.58f, 0.15f, 0.37f, 0.55f, 0.28f };\n+        float[] nums = { 0.49f, 0.96f, 0.82f, 0.09f, 0.57f, 0.43f, 0.91f, 0.75f, 0.15f, 0.37f };\n         bucketSort(nums);\n         System.out.println(\"桶排序完成后 nums = \" + Arrays.toString(nums));\n     }",
    "output": "Update the test case in bucket_sort.java"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/bucket_sort.java b/codes/java/chapter_sorting/bucket_sort.java\n--- a/codes/java/chapter_sorting/bucket_sort.java\n+++ b/codes/java/chapter_sorting/bucket_sort.java\n@@ -0,0 +1,47 @@\n+/**\n+ * File: bucket_sort.java\n+ * Created Time: 2023-03-17\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_sorting;\n+\n+import java.util.*;\n+\n+public class bucket_sort {\n+    /* 桶排序 */\n+    static void bucketSort(float[] nums) {\n+        // 初始化 k = n/3 个桶，预期向每个桶分配 3 个元素\n+        int k = nums.length / 2;\n+        List<List<Float>> buckets = new ArrayList<>();\n+        for (int i = 0; i < k; i++) {\n+            buckets.add(new ArrayList<>());\n+        }\n+        // 1. 将数组元素分配到各个桶中\n+        for (float num : nums) {\n+            // 输入数据范围 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]\n+            int i = (int) num * k;\n+            // 将 num 添加进桶 i\n+            buckets.get(i).add(num);\n+        }\n+        // 2. 对各个桶执行排序\n+        for (List<Float> bucket : buckets) {\n+            // 使用内置排序函数，也可以替换成其它排序算法\n+            Collections.sort(bucket);\n+        }\n+        // 3. 遍历桶合并结果\n+        int i = 0;\n+        for (List<Float> bucket : buckets) {\n+            for (float num : bucket) {\n+                nums[i++] = num;\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        // 设输入数据为浮点数，范围为 [0, 1)\n+        float[] nums = { 0.49f, 0.96f, 0.82f, 0.09f, 0.57f, 0.43f, 0.91f, 0.58f, 0.15f, 0.37f, 0.55f, 0.28f };\n+        bucketSort(nums);\n+        System.out.println(\"桶排序完成后 nums = \" + Arrays.toString(nums));\n+    }\n+}",
    "output": "Add the section of bucket sort"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/counting_sort.java b/codes/java/chapter_sorting/counting_sort.java\n--- a/codes/java/chapter_sorting/counting_sort.java\n+++ b/codes/java/chapter_sorting/counting_sort.java\n@@ -68,11 +68,11 @@ static void countingSort(int[] nums) {\n \n     public static void main(String[] args) {\n         int[] nums = { 1, 0, 1, 2, 0, 4, 0, 2, 2, 4 };\n-\n         countingSortNaive(nums);\n         System.out.println(\"计数排序（无法排序对象）完成后 nums = \" + Arrays.toString(nums));\n-\n-        countingSort(nums);\n-        System.out.println(\"计数排序完成后 nums = \" + Arrays.toString(nums));\n+        \n+        int[] nums1 = { 1, 0, 1, 2, 0, 4, 0, 2, 2, 4 };\n+        countingSort(nums1);\n+        System.out.println(\"计数排序完成后 nums1 = \" + Arrays.toString(nums1));\n     }\n }",
    "output": "Add Python and C++ code for the counting sort. (#436)"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/counting_sort.java b/codes/java/chapter_sorting/counting_sort.java\n--- a/codes/java/chapter_sorting/counting_sort.java\n+++ b/codes/java/chapter_sorting/counting_sort.java\n@@ -0,0 +1,78 @@\n+/**\n+ * File: bubble_sort.java\n+ * Created Time: 2023-03-17\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_sorting;\n+\n+import java.util.*;\n+\n+public class counting_sort {\n+    /* 计数排序 */\n+    // 简单实现，无法用于排序对象\n+    static void countingSortNaive(int[] nums) {\n+        // 1. 统计数组最大元素 m\n+        int m = 0;\n+        for (int num : nums) {\n+            m = Math.max(m, num);\n+        }\n+        // 2. 统计各数字的出现次数\n+        // counter[num] 代表 num 的出现次数\n+        int[] counter = new int[m + 1];\n+        for (int num : nums) {\n+            counter[num]++;\n+        }\n+        // 3. 遍历 counter ，将各元素填入原数组 nums\n+        int i = 0;\n+        for (int num = 0; num < m + 1; num++) {\n+            for (int j = 0; j < counter[num]; j++, i++) {\n+                nums[i] = num;\n+            }\n+        }\n+    }\n+\n+    /* 计数排序 */\n+    // 完整实现，可排序对象，并且是稳定排序\n+    static void countingSort(int[] nums) {\n+        // 1. 统计数组最大元素 m\n+        int m = 0;\n+        for (int num : nums) {\n+            m = Math.max(m, num);\n+        }\n+        // 2. 统计各数字的出现次数\n+        // counter[num] 代表 num 的出现次数\n+        int[] counter = new int[m + 1];\n+        for (int num : nums) {\n+            counter[num]++;\n+        }\n+        // 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”\n+        // 即 counter[num]-1 是 num 在 res 中最后一次出现的索引\n+        for (int i = 0; i < m; i++) {\n+            counter[i + 1] += counter[i];\n+        }\n+        // 4. 倒序遍历 nums ，将各元素填入结果数组 res\n+        // 初始化数组 res 用于记录结果\n+        int n = nums.length;\n+        int[] res = new int[n];\n+        for (int i = n - 1; i >= 0; i--) {\n+            int num = nums[i];\n+            res[counter[num] - 1] = num; // 将 num 放置到对应索引处\n+            counter[num]--; // 令前缀和自减 1 ，得到下次放置 num 的索引\n+        }\n+        // 使用结果数组 res 覆盖原数组 nums\n+        for (int i = 0; i < n; i++) {\n+            nums[i] = res[i];\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 1, 0, 1, 2, 0, 4, 0, 2, 2, 4 };\n+\n+        countingSortNaive(nums);\n+        System.out.println(\"计数排序（无法排序对象）完成后 nums = \" + Arrays.toString(nums));\n+\n+        countingSort(nums);\n+        System.out.println(\"计数排序完成后 nums = \" + Arrays.toString(nums));\n+    }\n+}",
    "output": "Add the section of counting sort. (#427)"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/radix_sort.java b/codes/java/chapter_sorting/radix_sort.java\n--- a/codes/java/chapter_sorting/radix_sort.java\n+++ b/codes/java/chapter_sorting/radix_sort.java\n@@ -16,7 +16,7 @@ static int digit(int num, int exp) {\n     }\n \n     /* 计数排序（根据 nums 第 k 位排序） */\n-    static void countSort(int[] nums, int exp) {\n+    static void countingSort(int[] nums, int exp) {\n         // 十进制的各位数字范围为 0~9 ，因此需要长度为 10 的桶\n         int[] bucket = new int[10];\n         int n = nums.length;\n@@ -55,7 +55,7 @@ static void radixSort(int[] nums) {\n             // k = 2 -> exp = 10\n             // k = 3 -> exp = 100\n             // 即 exp = 10^(k-1)\n-            countSort(nums, exp);\n+            countingSort(nums, exp);\n     }\n \n     public static void main(String[] args) {",
    "output": "Fix the deconstructor of linkedlist_queue.cpp"
  },
  {
    "input": "diff --git a/codes/java/chapter_hashing/array_hash_map.java b/codes/java/chapter_hashing/array_hash_map.java\n--- a/codes/java/chapter_hashing/array_hash_map.java\n+++ b/codes/java/chapter_hashing/array_hash_map.java\n@@ -20,12 +20,12 @@ public Entry(int key, String val) {\n \n /* 基于数组简易实现的哈希表 */\n class ArrayHashMap {\n-    private List<Entry> bucket;\n+    private List<Entry> buckets;\n     public ArrayHashMap() {\n         // 初始化一个长度为 100 的桶（数组）\n-        bucket = new ArrayList<>();\n+        buckets = new ArrayList<>();\n         for (int i = 0; i < 100; i++) {\n-            bucket.add(null);\n+            buckets.add(null);\n         }\n     }\n \n@@ -38,7 +38,7 @@ private int hashFunc(int key) {\n     /* 查询操作 */\n     public String get(int key) {\n         int index = hashFunc(key);\n-        Entry pair = bucket.get(index);\n+        Entry pair = buckets.get(index);\n         if (pair == null) return null;\n         return pair.val;\n     }\n@@ -47,20 +47,20 @@ public String get(int key) {\n     public void put(int key, String val) {\n         Entry pair = new Entry(key, val);\n         int index = hashFunc(key);\n-        bucket.set(index, pair);\n+        buckets.set(index, pair);\n     }\n \n     /* 删除操作 */\n     public void remove(int key) {\n         int index = hashFunc(key);\n         // 置为 null ，代表删除\n-        bucket.set(index, null);\n+        buckets.set(index, null);\n     }\n \n     /* 获取所有键值对 */\n     public List<Entry> entrySet() {\n         List<Entry> entrySet = new ArrayList<>();\n-        for (Entry pair : bucket) {\n+        for (Entry pair : buckets) {\n             if (pair != null)\n                 entrySet.add(pair);\n         }\n@@ -70,7 +70,7 @@ public List<Entry> entrySet() {\n     /* 获取所有键 */\n     public List<Integer> keySet() {\n         List<Integer> keySet = new ArrayList<>();\n-        for (Entry pair : bucket) {\n+        for (Entry pair : buckets) {\n             if (pair != null)\n                 keySet.add(pair.key);\n         }\n@@ -80,7 +80,7 @@ public List<Integer> keySet() {\n     /* 获取所有值 */\n     public List<String> valueSet() {\n         List<String> valueSet = new ArrayList<>();\n-        for (Entry pair : bucket) {\n+        for (Entry pair : buckets) {\n             if (pair != null)\n                 valueSet.add(pair.val);\n         }",
    "output": "Update array_hash_map"
  },
  {
    "input": "diff --git a/codes/java/chapter_heap/heap.java b/codes/java/chapter_heap/heap.java\n--- a/codes/java/chapter_heap/heap.java\n+++ b/codes/java/chapter_heap/heap.java\n@@ -12,12 +12,12 @@\n \n public class heap {\n     public static void testPush(Queue<Integer> heap, int val) {\n-        heap.add(val); // 元素入堆\n+        heap.offer(val); // 元素入堆\n         System.out.format(\"\\n元素 %d 入堆后\\n\", val);\n         PrintUtil.printHeap(heap);\n     }\n \n-    public static void testPoll(Queue<Integer> heap) {\n+    public static void testPop(Queue<Integer> heap) {\n         int val = heap.poll(); // 堆顶元素出堆\n         System.out.format(\"\\n堆顶元素 %d 出堆后\\n\", val);\n         PrintUtil.printHeap(heap);\n@@ -44,11 +44,11 @@ public static void main(String[] args) {\n         System.out.format(\"\\n堆顶元素为 %d\\n\", peek);\n \n         /* 堆顶元素出堆 */\n-        testPoll(maxHeap);\n-        testPoll(maxHeap);\n-        testPoll(maxHeap);\n-        testPoll(maxHeap);\n-        testPoll(maxHeap);\n+        testPop(maxHeap);\n+        testPop(maxHeap);\n+        testPop(maxHeap);\n+        testPop(maxHeap);\n+        testPop(maxHeap);\n \n         /* 获取堆大小 */\n         int size = maxHeap.size();\n\ndiff --git a/codes/java/chapter_heap/my_heap.java b/codes/java/chapter_heap/my_heap.java\n--- a/codes/java/chapter_heap/my_heap.java\n+++ b/codes/java/chapter_heap/my_heap.java\n@@ -87,7 +87,7 @@ private void siftUp(int i) {\n     }\n \n     /* 元素出堆 */\n-    public int poll() {\n+    public int pop() {\n         // 判空处理\n         if (isEmpty())\n             throw new EmptyStackException();\n@@ -129,18 +129,6 @@ public void print() {\n \n \n public class my_heap {\n-    public static void testPush(MaxHeap maxHeap, int val) {\n-        maxHeap.push(val);  // 元素入堆\n-        System.out.format(\"\\n添加元素 %d 后\\n\", val);\n-        maxHeap.print();\n-    }\n-\n-    public static void testPoll(MaxHeap maxHeap) {\n-        int val = maxHeap.poll(); // 堆顶元素出堆\n-        System.out.format(\"\\n出堆元素为 %d\\n\", val);\n-        maxHeap.print();\n-    }\n-\n     public static void main(String[] args) {\n         /* 初始化大顶堆 */\n         MaxHeap maxHeap = new MaxHeap(Arrays.asList(9, 8, 6, 6, 7, 5, 2, 1, 4, 3, 6, 2));\n@@ -158,7 +146,7 @@ public static void main(String[] args) {\n         maxHeap.print();\n \n         /* 堆顶元素出堆 */\n-        peek = maxHeap.poll();\n+        peek = maxHeap.pop();\n         System.out.format(\"\\n堆顶元素 %d 出堆后\\n\", peek);\n         maxHeap.print();\n ",
    "output": "refactor: Replace 'poll' with 'pop' in Heap (#416)"
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/array_deque.java b/codes/java/chapter_stack_and_queue/array_deque.java\n--- a/codes/java/chapter_stack_and_queue/array_deque.java\n+++ b/codes/java/chapter_stack_and_queue/array_deque.java\n@@ -71,7 +71,7 @@ public void pushLast(int num) {\n     }\n \n     /* 队首出队 */\n-    public int pollFirst() {\n+    public int popFirst() {\n         int num = peekFirst();\n         // 队首指针向后移动一位\n         front = index(front + 1);\n@@ -80,7 +80,7 @@ public int pollFirst() {\n     }\n \n     /* 队尾出队 */\n-    public int pollLast() {\n+    public int popLast() {\n         int num = peekLast();\n         queSize--;\n         return num;\n@@ -135,10 +135,10 @@ public static void main(String[] args) {\n         System.out.println(\"元素 1 队首入队后 deque = \" + Arrays.toString(deque.toArray()));\n \n         /* 元素出队 */\n-        int pollLast = deque.pollLast();\n-        System.out.println(\"队尾出队元素 = \" + pollLast + \"，队尾出队后 deque = \" + Arrays.toString(deque.toArray()));\n-        int pollFirst = deque.pollFirst();\n-        System.out.println(\"队首出队元素 = \" + pollFirst + \"，队首出队后 deque = \" + Arrays.toString(deque.toArray()));\n+        int popLast = deque.popLast();\n+        System.out.println(\"队尾出队元素 = \" + popLast + \"，队尾出队后 deque = \" + Arrays.toString(deque.toArray()));\n+        int popFirst = deque.popFirst();\n+        System.out.println(\"队首出队元素 = \" + popFirst + \"，队首出队后 deque = \" + Arrays.toString(deque.toArray()));\n \n         /* 获取双向队列的长度 */\n         int size = deque.size();\n\ndiff --git a/codes/java/chapter_stack_and_queue/array_queue.java b/codes/java/chapter_stack_and_queue/array_queue.java\n--- a/codes/java/chapter_stack_and_queue/array_queue.java\n+++ b/codes/java/chapter_stack_and_queue/array_queue.java\n@@ -49,7 +49,7 @@ public void push(int num) {\n     }\n \n     /* 出队 */\n-    public int poll() {\n+    public int pop() {\n         int num = peek();\n         // 队首指针向后移动一位，若越过尾部则返回到数组头部\n         front = (front + 1) % capacity();\n@@ -94,8 +94,8 @@ public static void main(String[] args) {\n         System.out.println(\"队首元素 peek = \" + peek);\n \n         /* 元素出队 */\n-        int poll = queue.poll();\n-        System.out.println(\"出队元素 poll = \" + poll + \"，出队后 queue = \" + Arrays.toString(queue.toArray()));\n+        int pop = queue.pop();\n+        System.out.println(\"出队元素 pop = \" + pop + \"，出队后 queue = \" + Arrays.toString(queue.toArray()));\n \n         /* 获取队列的长度 */\n         int size = queue.size();\n@@ -108,7 +108,7 @@ public static void main(String[] args) {\n         /* 测试环形数组 */\n         for (int i = 0; i < 10; i++) {\n             queue.push(i);\n-            queue.poll();\n+            queue.pop();\n             System.out.println(\"第 \" + i + \" 轮入队 + 出队后 queue = \" + Arrays.toString(queue.toArray()));\n         }\n     }\n\ndiff --git a/codes/java/chapter_stack_and_queue/deque.java b/codes/java/chapter_stack_and_queue/deque.java\n--- a/codes/java/chapter_stack_and_queue/deque.java\n+++ b/codes/java/chapter_stack_and_queue/deque.java\n@@ -30,10 +30,10 @@ public static void main(String[] args) {\n         System.out.println(\"元素 1 队首入队后 deque = \" + deque);\n \n         /* 元素出队 */\n-        int pollLast = deque.pollLast();\n-        System.out.println(\"队尾出队元素 = \" + pollLast + \"，队尾出队后 deque = \" + deque);\n-        int pollFirst = deque.pollFirst();\n-        System.out.println(\"队首出队元素 = \" + pollFirst + \"，队首出队后 deque = \" + deque);\n+        int popLast = deque.pollLast();\n+        System.out.println(\"队尾出队元素 = \" + popLast + \"，队尾出队后 deque = \" + deque);\n+        int popFirst = deque.pollFirst();\n+        System.out.println(\"队首出队元素 = \" + popFirst + \"，队首出队后 deque = \" + deque);\n \n         /* 获取双向队列的长度 */\n         int size = deque.size();\n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_deque.java b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n@@ -71,7 +71,7 @@ public void pushLast(int num) {\n     }\n \n     /* 出队操作 */\n-    private Integer poll(boolean isFront) {\n+    private Integer pop(boolean isFront) {\n         // 若队列为空，直接返回 null\n         if (isEmpty())\n             return null;\n@@ -102,13 +102,13 @@ private Integer poll(boolean isFront) {\n     }\n \n     /* 队首出队 */\n-    public Integer pollFirst() {\n-        return poll(true);\n+    public Integer popFirst() {\n+        return pop(true);\n     }\n \n     /* 队尾出队 */\n-    public Integer pollLast() {\n-        return poll(false);\n+    public Integer popLast() {\n+        return pop(false);\n     }\n \n     /* 访问队首元素 */\n@@ -155,10 +155,10 @@ public static void main(String[] args) {\n         System.out.println(\"元素 1 队首入队后 deque = \" + Arrays.toString(deque.toArray()));\n \n         /* 元素出队 */\n-        int pollLast = deque.pollLast();\n-        System.out.println(\"队尾出队元素 = \" + pollLast + \"，队尾出队后 deque = \" + Arrays.toString(deque.toArray()));\n-        int pollFirst = deque.pollFirst();\n-        System.out.println(\"队首出队元素 = \" + pollFirst + \"，队首出队后 deque = \" + Arrays.toString(deque.toArray()));\n+        int popLast = deque.popLast();\n+        System.out.println(\"队尾出队元素 = \" + popLast + \"，队尾出队后 deque = \" + Arrays.toString(deque.toArray()));\n+        int popFirst = deque.popFirst();\n+        System.out.println(\"队首出队元素 = \" + popFirst + \"，队首出队后 deque = \" + Arrays.toString(deque.toArray()));\n \n         /* 获取双向队列的长度 */\n         int size = deque.size();\n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_queue.java b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n@@ -45,7 +45,7 @@ public void push(int num) {\n     }\n \n     /* 出队 */\n-    public int poll() {\n+    public int pop() {\n         int num = peek();\n         // 删除头结点\n         front = front.next;\n@@ -90,8 +90,8 @@ public static void main(String[] args) {\n         System.out.println(\"队首元素 peek = \" + peek);\n \n         /* 元素出队 */\n-        int poll = queue.poll();\n-        System.out.println(\"出队元素 poll = \" + poll + \"，出队后 queue = \" + Arrays.toString(queue.toArray()));\n+        int pop = queue.pop();\n+        System.out.println(\"出队元素 pop = \" + pop + \"，出队后 queue = \" + Arrays.toString(queue.toArray()));\n \n         /* 获取队列的长度 */\n         int size = queue.size();\n\ndiff --git a/codes/java/chapter_stack_and_queue/queue.java b/codes/java/chapter_stack_and_queue/queue.java\n--- a/codes/java/chapter_stack_and_queue/queue.java\n+++ b/codes/java/chapter_stack_and_queue/queue.java\n@@ -26,8 +26,8 @@ public static void main(String[] args) {\n         System.out.println(\"队首元素 peek = \" + peek);\n \n         /* 元素出队 */\n-        int poll = queue.poll();\n-        System.out.println(\"出队元素 poll = \" + poll + \"，出队后 queue = \" + queue);\n+        int pop = queue.poll();\n+        System.out.println(\"出队元素 pop = \" + pop + \"，出队后 queue = \" + queue);\n \n         /* 获取队列的长度 */\n         int size = queue.size();",
    "output": "refactor: Replace poll with pop in Queue and Deque (#415)"
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/stack.java b/codes/java/chapter_stack_and_queue/stack.java\n--- a/codes/java/chapter_stack_and_queue/stack.java\n+++ b/codes/java/chapter_stack_and_queue/stack.java\n@@ -11,23 +11,22 @@\n public class stack {\n     public static void main(String[] args) {\n         /* 初始化栈 */\n-        // 在 Java 中，推荐将 ArrayList 当作栈来使用\n-        List<Integer> stack = new ArrayList<>();\n+        Stack<Integer> stack = new Stack<>();\n \n         /* 元素入栈 */\n-        stack.add(1);\n-        stack.add(3);\n-        stack.add(2);\n-        stack.add(5);\n-        stack.add(4);\n+        stack.push(1);\n+        stack.push(3);\n+        stack.push(2);\n+        stack.push(5);\n+        stack.push(4);\n         System.out.println(\"栈 stack = \" + stack);\n \n         /* 访问栈顶元素 */\n-        int peek = stack.get(stack.size() - 1);\n+        int peek = stack.peek();\n         System.out.println(\"栈顶元素 peek = \" + peek);\n \n         /* 元素出栈 */\n-        int pop = stack.remove(stack.size() - 1);\n+        int pop = stack.pop();\n         System.out.println(\"出栈元素 pop = \" + pop + \"，出栈后 stack = \" + stack);\n \n         /* 获取栈的长度 */",
    "output": "Update the chapter of stack and queue."
  },
  {
    "input": "diff --git a/codes/java/chapter_graph/graph_adjacency_list.java b/codes/java/chapter_graph/graph_adjacency_list.java\n--- a/codes/java/chapter_graph/graph_adjacency_list.java\n+++ b/codes/java/chapter_graph/graph_adjacency_list.java\n@@ -84,7 +84,8 @@ public class graph_adjacency_list {\n     public static void main(String[] args) {\n         /* 初始化无向图 */\n         Vertex[] v = Vertex.valsToVets(new int[] { 1, 3, 2, 5, 4 });\n-        Vertex[][] edges = { { v[0], v[1] }, { v[0], v[3] }, { v[1], v[2] }, { v[2], v[3] }, { v[2], v[4] }, { v[3], v[4] } };\n+        Vertex[][] edges = { { v[0], v[1] }, { v[0], v[3] }, { v[1], v[2] }, \n+                             { v[2], v[3] }, { v[2], v[4] }, { v[3], v[4] } };\n         GraphAdjList graph = new GraphAdjList(edges);\n         System.out.println(\"\\n初始化后，图为\");\n         graph.print();",
    "output": "feat: Add C++ code for the graph bfs and dfs (#401)\n\n* Add C++ code for the graph bfs and dfs\r\n\r\n* Add C++ code for the graph bfs and dfs"
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/linkedlist_deque.java b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n@@ -22,15 +22,15 @@ class ListNode {\n /* 基于双向链表实现的双向队列 */\n class LinkedListDeque {\n     private ListNode front, rear; // 头结点 front ，尾结点 rear\n-    private int size = 0;         // 双向队列的长度\n+    private int queSize = 0;      // 双向队列的长度\n \n     public LinkedListDeque() {\n         front = rear = null;\n     }\n \n     /* 获取双向队列的长度 */\n     public int size() {\n-        return size;\n+        return queSize;\n     }\n \n     /* 判断双向队列是否为空 */\n@@ -57,7 +57,7 @@ else if (isFront) {\n             node.prev = rear;\n             rear = node;  // 更新尾结点\n         }\n-        size++; // 更新队列长度\n+        queSize++; // 更新队列长度\n     }\n \n     /* 队首入队 */\n@@ -97,7 +97,7 @@ private Integer poll(boolean isFront) {\n             }\n             rear = rPrev;    // 更新尾结点\n         }\n-        size--; // 更新队列长度\n+        queSize--; // 更新队列长度\n         return val;\n     }\n ",
    "output": "Add C++ code for the linkedlist deque and array deque (#400)"
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/linked_list.java b/codes/java/chapter_array_and_linkedlist/linked_list.java\n--- a/codes/java/chapter_array_and_linkedlist/linked_list.java\n+++ b/codes/java/chapter_array_and_linkedlist/linked_list.java\n@@ -12,8 +12,8 @@ public class linked_list {\n     /* 在链表的结点 n0 之后插入结点 P */\n     static void insert(ListNode n0, ListNode P) {\n         ListNode n1 = n0.next;\n-        n0.next = P;\n         P.next = n1;\n+        n0.next = P;\n     }\n \n     /* 删除链表的结点 n0 之后的首个结点 */",
    "output": "Change the operations sequence of the likedlist's insert() method."
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/array_deque.java b/codes/java/chapter_stack_and_queue/array_deque.java\n--- a/codes/java/chapter_stack_and_queue/array_deque.java\n+++ b/codes/java/chapter_stack_and_queue/array_deque.java\n@@ -116,7 +116,7 @@ public int[] toArray() {\n public class array_deque {\n     public static void main(String[] args) {\n         /* 初始化双向队列 */\n-        LinkedListDeque deque = new LinkedListDeque();\n+        ArrayDeque deque = new ArrayDeque(10);\n         deque.pushLast(3);\n         deque.pushLast(2);\n         deque.pushLast(5);",
    "output": "Fix array_deque.java\nUnify the book name.\nUpdate cover image."
  },
  {
    "input": "diff --git a/codes/java/chapter_heap/heap.java b/codes/java/chapter_heap/heap.java\n--- a/codes/java/chapter_heap/heap.java\n+++ b/codes/java/chapter_heap/heap.java\n@@ -28,7 +28,7 @@ public static void main(String[] args) {\n         // 初始化小顶堆\n         Queue<Integer> minHeap = new PriorityQueue<>();\n         // 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）\n-        Queue<Integer> maxHeap = new PriorityQueue<>((a, b) -> { return b - a; });\n+        Queue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\n \n         System.out.println(\"\\n以下测试样例为大顶堆\");\n ",
    "output": "refactor:Simplified lambda expressions for PriorityQueue in heap.md and heap.java (#379)"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/bubble_sort.java b/codes/java/chapter_sorting/bubble_sort.java\n--- a/codes/java/chapter_sorting/bubble_sort.java\n+++ b/codes/java/chapter_sorting/bubble_sort.java\n@@ -51,6 +51,6 @@ public static void main(String[] args) {\n \n         int[] nums1 = { 4, 1, 3, 1, 5, 2 };\n         bubbleSortWithFlag(nums1);\n-        System.out.println(\"冒泡排序完成后 nums1 = \" + Arrays.toString(nums));\n+        System.out.println(\"冒泡排序完成后 nums1 = \" + Arrays.toString(nums1));\n     }\n }",
    "output": "add chapter_sorting by dart (#366)\n\n* add chapter_sorting by dart\r\n\r\n* fixed style of dart and bug mentioned before\r\n\r\n* alter min value of dart\r\n\r\n* Update radix_sort.dart\r\n\r\n---------\r\n\r\nCo-authored-by: Yudong Jin <krahets@163.com>"
  },
  {
    "input": "diff --git a/codes/java/chapter_graph/graph_traversal.java b/codes/java/chapter_graph/graph_traversal.java\n--- a/codes/java/chapter_graph/graph_traversal.java\n+++ b/codes/java/chapter_graph/graph_traversal.java\n@@ -1,70 +0,0 @@\n-/**\n- * File: graph_adjacency_list.java\n- * Created Time: 2023-02-12\n- * Author: Krahets (krahets@163.com)\n- */\n-\n-package chapter_graph;\n-\n-import java.util.*;\n-\n-public class graph_traversal {\n-    /* 以顶点 vet 为起点，对图 graph 执行广度优先遍历 */\n-    // 采用 GraphAdjList 表示图，以方便获取指定结点的所有邻接结点\n-    static List<Vertex> graphBFS(GraphAdjList graph, Vertex startVet) {\n-        // 顶点遍历序列\n-        List<Vertex> res = new ArrayList<>();\n-        // 用于记录顶点是否已被访问\n-        Set<Vertex> visited = new HashSet<>() {{ add(startVet); }};\n-        // 队列用于实现 BFS\n-        Queue<Vertex> que = new LinkedList<>() {{ offer(startVet); }};\n-        // 循环直至访问完所有顶点\n-        while (!que.isEmpty()) {\n-            Vertex vet = que.poll(); // 队首顶点出队\n-            res.add(vet);            // 访问该顶点\n-            // 遍历该顶点的所有邻接顶点\n-            for (Vertex adjVet : graph.adjList.get(vet)) {\n-                if (!visited.contains(adjVet)) {\n-                    que.offer(adjVet);   // 只入队未访问的顶点\n-                    visited.add(adjVet); // 标记该顶点已被访问\n-                }\n-            }\n-        }\n-        // 返回顶点遍历序列\n-        return res;\n-    }\n-\n-    /* 输入值列表 vals ，返回顶点列表 vets */\n-    static Vertex[] valsToVets(int[] vals) {\n-        Vertex[] vets = new Vertex[vals.length];\n-        for (int i = 0; i < vals.length; i++) {\n-            vets[i] = new Vertex(vals[i]);\n-        }\n-        return vets;\n-    }\n-\n-    /* 输入顶点列表 vets ，返回值列表 vals */\n-    static List<Integer> vetsToVals(List<Vertex> vets) {\n-        List<Integer> vals = new ArrayList<>();\n-        for (Vertex vet : vets) {\n-            vals.add(vet.val);\n-        }\n-        return vals;\n-    }\n-\n-    public static void main(String[] args) {\n-        /* 初始化无向图 */\n-        Vertex[] v = valsToVets(new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 });\n-        Vertex[][] edges = { { v[0], v[1] }, { v[0], v[3] }, { v[1], v[2] }, { v[1], v[4] }, \n-                             { v[2], v[5] }, { v[3], v[4] }, { v[3], v[6] }, { v[4], v[5] },\n-                             { v[4], v[7] }, { v[5], v[8] }, { v[6], v[7] }, { v[7], v[8] }};\n-        GraphAdjList graph = new GraphAdjList(edges);\n-        System.out.println(\"\\n初始化后，图为\");\n-        graph.print();\n-\n-        /* 广度优先遍历 BFS */\n-        List<Vertex> res = graphBFS(graph, v[0]);\n-        System.out.println(\"\\n广度优先遍历（BFS）顶点序列为\");\n-        System.out.println(vetsToVals(res));\n-    }\n-}",
    "output": "Remove graph_traversal.java"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_tree_bfs.java b/codes/java/chapter_tree/binary_tree_bfs.java\n--- a/codes/java/chapter_tree/binary_tree_bfs.java\n+++ b/codes/java/chapter_tree/binary_tree_bfs.java\n@@ -11,7 +11,7 @@\n \n public class binary_tree_bfs {\n     /* 层序遍历 */\n-    static List<Integer> hierOrder(TreeNode root) {\n+    static List<Integer> levelOrder(TreeNode root) {\n         // 初始化队列，加入根结点\n         Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n         // 初始化一个列表，用于保存遍历序列\n@@ -35,7 +35,7 @@ public static void main(String[] args) {\n         PrintUtil.printTree(root);\n \n         /* 层序遍历 */\n-        List<Integer> list = hierOrder(root);\n+        List<Integer> list = levelOrder(root);\n         System.out.println(\"\\n层序遍历的结点打印序列 = \" + list);\n     }\n }",
    "output": "Merge branch 'develop'"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_tree_bfs.java b/codes/java/chapter_tree/binary_tree_bfs.java\n--- a/codes/java/chapter_tree/binary_tree_bfs.java\n+++ b/codes/java/chapter_tree/binary_tree_bfs.java\n@@ -11,7 +11,7 @@\n \n public class binary_tree_bfs {\n     /* 层序遍历 */\n-    static List<Integer> hierOrder(TreeNode root) {\n+    static List<Integer> levelOrder(TreeNode root) {\n         // 初始化队列，加入根结点\n         Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n         // 初始化一个列表，用于保存遍历序列\n@@ -35,7 +35,7 @@ public static void main(String[] args) {\n         PrintUtil.printTree(root);\n \n         /* 层序遍历 */\n-        List<Integer> list = hierOrder(root);\n+        List<Integer> list = levelOrder(root);\n         System.out.println(\"\\n层序遍历的结点打印序列 = \" + list);\n     }\n }",
    "output": "Update binary_tree_bfs codes"
  },
  {
    "input": "diff --git a/codes/java/chapter_graph/graph_traversal.java b/codes/java/chapter_graph/graph_traversal.java\n--- a/codes/java/chapter_graph/graph_traversal.java\n+++ b/codes/java/chapter_graph/graph_traversal.java\n@@ -1,70 +0,0 @@\n-/**\n- * File: graph_adjacency_list.java\n- * Created Time: 2023-02-12\n- * Author: Krahets (krahets@163.com)\n- */\n-\n-package chapter_graph;\n-\n-import java.util.*;\n-\n-public class graph_traversal {\n-    /* 以顶点 vet 为起点，对图 graph 执行广度优先遍历 */\n-    // 采用 GraphAdjList 表示图，以方便获取指定结点的所有邻接结点\n-    static List<Vertex> graphBFS(GraphAdjList graph, Vertex startVet) {\n-        // 顶点遍历序列\n-        List<Vertex> res = new ArrayList<>();\n-        // 用于记录顶点是否已被访问\n-        Set<Vertex> visited = new HashSet<>() {{ add(startVet); }};\n-        // 队列用于实现 BFS\n-        Queue<Vertex> que = new LinkedList<>() {{ offer(startVet); }};\n-        // 循环直至访问完所有顶点\n-        while (!que.isEmpty()) {\n-            Vertex vet = que.poll(); // 队首顶点出队\n-            res.add(vet);            // 访问该顶点\n-            // 遍历该顶点的所有邻接顶点\n-            for (Vertex adjVet : graph.adjList.get(vet)) {\n-                if (!visited.contains(adjVet)) {\n-                    que.offer(adjVet);   // 只入队未访问的顶点\n-                    visited.add(adjVet); // 标记该顶点已被访问\n-                }\n-            }\n-        }\n-        // 返回顶点遍历序列\n-        return res;\n-    }\n-\n-    /* 输入值列表 vals ，返回顶点列表 vets */\n-    static Vertex[] valsToVets(int[] vals) {\n-        Vertex[] vets = new Vertex[vals.length];\n-        for (int i = 0; i < vals.length; i++) {\n-            vets[i] = new Vertex(vals[i]);\n-        }\n-        return vets;\n-    }\n-\n-    /* 输入顶点列表 vets ，返回值列表 vals */\n-    static List<Integer> vetsToVals(List<Vertex> vets) {\n-        List<Integer> vals = new ArrayList<>();\n-        for (Vertex vet : vets) {\n-            vals.add(vet.val);\n-        }\n-        return vals;\n-    }\n-\n-    public static void main(String[] args) {\n-        /* 初始化无向图 */\n-        Vertex[] v = valsToVets(new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 });\n-        Vertex[][] edges = { { v[0], v[1] }, { v[0], v[3] }, { v[1], v[2] }, { v[1], v[4] }, \n-                             { v[2], v[5] }, { v[3], v[4] }, { v[3], v[6] }, { v[4], v[5] },\n-                             { v[4], v[7] }, { v[5], v[8] }, { v[6], v[7] }, { v[7], v[8] }};\n-        GraphAdjList graph = new GraphAdjList(edges);\n-        System.out.println(\"\\n初始化后，图为\");\n-        graph.print();\n-\n-        /* 广度优先遍历 BFS */\n-        List<Vertex> res = graphBFS(graph, v[0]);\n-        System.out.println(\"\\n广度优先遍历（BFS）顶点序列为\");\n-        System.out.println(vetsToVals(res));\n-    }\n-}",
    "output": "Update graph codes"
  },
  {
    "input": "diff --git a/codes/java/include/Vertex.java b/codes/java/include/Vertex.java\n--- a/codes/java/include/Vertex.java\n+++ b/codes/java/include/Vertex.java\n@@ -0,0 +1,35 @@\n+/**\n+ * File: TreeNode.java\n+ * Created Time: 2022-11-25\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package include;\n+\n+import java.util.*;\n+\n+/* 顶点类 */\n+public class Vertex {\n+    public int val;\n+    public Vertex(int val) {\n+        this.val = val;\n+    }\n+\n+    /* 输入值列表 vals ，返回顶点列表 vets */\n+    public static Vertex[] valsToVets(int[] vals) {\n+        Vertex[] vets = new Vertex[vals.length];\n+        for (int i = 0; i < vals.length; i++) {\n+            vets[i] = new Vertex(vals[i]);\n+        }\n+        return vets;\n+    }\n+\n+    /* 输入顶点列表 vets ，返回值列表 vals */\n+    public static List<Integer> vetsToVals(List<Vertex> vets) {\n+        List<Integer> vals = new ArrayList<>();\n+        for (Vertex vet : vets) {\n+            vals.add(vet.val);\n+        }\n+        return vals;\n+    }\n+}\n\\ No newline at end of file",
    "output": "Add missing Vertex.java"
  },
  {
    "input": "diff --git a/codes/java/chapter_graph/graph_traversal.java b/codes/java/chapter_graph/graph_traversal.java\n--- a/codes/java/chapter_graph/graph_traversal.java\n+++ b/codes/java/chapter_graph/graph_traversal.java\n@@ -0,0 +1,70 @@\n+/**\n+ * File: graph_adjacency_list.java\n+ * Created Time: 2023-02-12\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_graph;\n+\n+import java.util.*;\n+\n+public class graph_traversal {\n+    /* 以顶点 vet 为起点，对图 graph 执行广度优先遍历 */\n+    // 采用 GraphAdjList 表示图，以方便获取指定结点的所有邻接结点\n+    static List<Vertex> graphBFS(GraphAdjList graph, Vertex startVet) {\n+        // 顶点遍历序列\n+        List<Vertex> res = new ArrayList<>();\n+        // 用于记录顶点是否已被访问\n+        Set<Vertex> visited = new HashSet<>() {{ add(startVet); }};\n+        // 队列用于实现 BFS\n+        Queue<Vertex> que = new LinkedList<>() {{ offer(startVet); }};\n+        // 循环直至访问完所有顶点\n+        while (!que.isEmpty()) {\n+            Vertex vet = que.poll(); // 队首顶点出队\n+            res.add(vet);            // 访问该顶点\n+            // 遍历该顶点的所有邻接顶点\n+            for (Vertex adjVet : graph.adjList.get(vet)) {\n+                if (!visited.contains(adjVet)) {\n+                    que.offer(adjVet);   // 只入队未访问的顶点\n+                    visited.add(adjVet); // 标记该顶点已被访问\n+                }\n+            }\n+        }\n+        // 返回顶点遍历序列\n+        return res;\n+    }\n+\n+    /* 输入值列表 vals ，返回顶点列表 vets */\n+    static Vertex[] valsToVets(int[] vals) {\n+        Vertex[] vets = new Vertex[vals.length];\n+        for (int i = 0; i < vals.length; i++) {\n+            vets[i] = new Vertex(vals[i]);\n+        }\n+        return vets;\n+    }\n+\n+    /* 输入顶点列表 vets ，返回值列表 vals */\n+    static List<Integer> vetsToVals(List<Vertex> vets) {\n+        List<Integer> vals = new ArrayList<>();\n+        for (Vertex vet : vets) {\n+            vals.add(vet.val);\n+        }\n+        return vals;\n+    }\n+\n+    public static void main(String[] args) {\n+        /* 初始化无向图 */\n+        Vertex[] v = valsToVets(new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 });\n+        Vertex[][] edges = { { v[0], v[1] }, { v[0], v[3] }, { v[1], v[2] }, { v[1], v[4] }, \n+                             { v[2], v[5] }, { v[3], v[4] }, { v[3], v[6] }, { v[4], v[5] },\n+                             { v[4], v[7] }, { v[5], v[8] }, { v[6], v[7] }, { v[7], v[8] }};\n+        GraphAdjList graph = new GraphAdjList(edges);\n+        System.out.println(\"\\n初始化后，图为\");\n+        graph.print();\n+\n+        /* 广度优先遍历 BFS */\n+        List<Vertex> res = graphBFS(graph, v[0]);\n+        System.out.println(\"\\n广度优先遍历（BFS）顶点序列为\");\n+        System.out.println(vetsToVals(res));\n+    }\n+}",
    "output": "Graph dev"
  },
  {
    "input": "diff --git a/codes/java/chapter_graph/graph_adjacency_matrix.java b/codes/java/chapter_graph/graph_adjacency_matrix.java\n--- a/codes/java/chapter_graph/graph_adjacency_matrix.java\n+++ b/codes/java/chapter_graph/graph_adjacency_matrix.java\n@@ -100,7 +100,7 @@ public static void main(String[] args) {\n         /* 初始化无向图 */\n         // 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引\n         int[] vertices = { 1, 3, 2, 5, 4 };\n-        int[][] edges = { { 0, 1 }, { 0, 2 }, { 1, 2 }, { 2, 3 }, { 0, 3 }, { 2, 4 }, { 3, 4 } };\n+        int[][] edges = { { 0, 1 }, { 1, 2 }, { 2, 3 }, { 0, 3 }, { 2, 4 }, { 3, 4 } };\n         GraphAdjMat graph = new GraphAdjMat(vertices, edges);\n         System.out.println(\"\\n初始化后，图为\");\n         graph.print();",
    "output": "Fix the initial edges in graph_adjacency_matrix"
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/leetcode_two_sum.java b/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n--- a/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n+++ b/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n@@ -8,9 +8,10 @@\n \n import java.util.*;\n \n-/* 方法一：暴力枚举 */\n-class SolutionBruteForce {\n-    public int[] twoSum(int[] nums, int target) {\n+\n+public class leetcode_two_sum {\n+    /* 方法一：暴力枚举 */\n+    static int[] twoSumBruteForce(int[] nums, int target) {\n         int size = nums.length;\n         // 两层循环，时间复杂度 O(n^2)\n         for (int i = 0; i < size - 1; i++) {\n@@ -21,11 +22,9 @@ public int[] twoSum(int[] nums, int target) {\n         }\n         return new int[0];\n     }\n-}\n \n-/* 方法二：辅助哈希表 */\n-class SolutionHashMap {\n-    public int[] twoSum(int[] nums, int target) {\n+    /* 方法二：辅助哈希表 */\n+    static int[] twoSumHashTable(int[] nums, int target) {\n         int size = nums.length;\n         // 辅助哈希表，空间复杂度 O(n)\n         Map<Integer, Integer> dic = new HashMap<>();\n@@ -38,22 +37,18 @@ public int[] twoSum(int[] nums, int target) {\n         }\n         return new int[0];\n     }\n-}\n \n-public class leetcode_two_sum {\n     public static void main(String[] args) {\n         // ======= Test Case =======\n         int[] nums = { 2,7,11,15 };\n         int target = 9;\n         \n         // ====== Driver Code ======\n         // 方法一\n-        SolutionBruteForce slt1 = new SolutionBruteForce();\n-        int[] res = slt1.twoSum(nums, target);\n+        int[] res = twoSumBruteForce(nums, target);\n         System.out.println(\"方法一 res = \" + Arrays.toString(res));\n         // 方法二\n-        SolutionHashMap slt2 = new SolutionHashMap();\n-        res = slt2.twoSum(nums, target);\n+        res = twoSumHashTable(nums, target);\n         System.out.println(\"方法二 res = \" + Arrays.toString(res));\n     }\n }",
    "output": "Add build script for JS and TS codes."
  },
  {
    "input": "diff --git a/codes/java/chapter_searching/hashing_search.java b/codes/java/chapter_searching/hashing_search.java\n--- a/codes/java/chapter_searching/hashing_search.java\n+++ b/codes/java/chapter_searching/hashing_search.java\n@@ -11,14 +11,14 @@\n \n public class hashing_search {\n     /* 哈希查找（数组） */\n-    static int hashingSearch(Map<Integer, Integer> map, int target) {\n+    static int hashingSearchArray(Map<Integer, Integer> map, int target) {\n         // 哈希表的 key: 目标元素，value: 索引\n         // 若哈希表中无此 key ，返回 -1\n         return map.getOrDefault(target, -1);\n     }\n \n     /* 哈希查找（链表） */\n-    static ListNode hashingSearch1(Map<Integer, ListNode> map, int target) {\n+    static ListNode hashingSearchLinkedList(Map<Integer, ListNode> map, int target) {\n         // 哈希表的 key: 目标结点值，value: 结点对象\n         // 若哈希表中无此 key ，返回 null\n         return map.getOrDefault(target, null);\n@@ -34,7 +34,7 @@ public static void main(String[] args) {\n         for (int i = 0; i < nums.length; i++) {\n             map.put(nums[i], i);  // key: 元素，value: 索引\n         }\n-        int index = hashingSearch(map, target);\n+        int index = hashingSearchArray(map, target);\n         System.out.println(\"目标元素 3 的索引 = \" + index);\n \n         /* 哈希查找（链表） */\n@@ -45,7 +45,7 @@ public static void main(String[] args) {\n             map1.put(head.val, head);  // key: 结点值，value: 结点\n             head = head.next;\n         }\n-        ListNode node = hashingSearch1(map1, target);\n+        ListNode node = hashingSearchLinkedList(map1, target);\n         System.out.println(\"目标结点值 3 的对应结点对象为 \" + node);\n     }\n }\n\ndiff --git a/codes/java/chapter_searching/linear_search.java b/codes/java/chapter_searching/linear_search.java\n--- a/codes/java/chapter_searching/linear_search.java\n+++ b/codes/java/chapter_searching/linear_search.java\n@@ -10,7 +10,7 @@\n \n public class linear_search {\n     /* 线性查找（数组） */\n-    static int linearSearch(int[] nums, int target) {\n+    static int linearSearchArray(int[] nums, int target) {\n         // 遍历数组\n         for (int i = 0; i < nums.length; i++) {\n             // 找到目标元素，返回其索引\n@@ -22,7 +22,7 @@ static int linearSearch(int[] nums, int target) {\n     }\n \n     /* 线性查找（链表） */\n-    static ListNode linearSearch(ListNode head, int target) {\n+    static ListNode linearSearchLinkedList(ListNode head, int target) {\n         // 遍历链表\n         while (head != null) {\n             // 找到目标结点，返回之\n@@ -39,12 +39,12 @@ public static void main(String[] args) {\n \n         /* 在数组中执行线性查找 */\n         int[] nums = { 1, 5, 3, 2, 4, 7, 5, 9, 10, 8 };\n-        int index = linearSearch(nums, target);\n+        int index = linearSearchArray(nums, target);\n         System.out.println(\"目标元素 3 的索引 = \" + index);\n \n         /* 在链表中执行线性查找 */\n         ListNode head = ListNode.arrToLinkedList(nums);\n-        ListNode node = linearSearch(head, target);\n+        ListNode node = linearSearchLinkedList(head, target);\n         System.out.println(\"目标结点值 3 的对应结点对象为 \" + node);\n     }\n }",
    "output": "Update linear_search and hashing_search."
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/array_queue.java b/codes/java/chapter_stack_and_queue/array_queue.java\n--- a/codes/java/chapter_stack_and_queue/array_queue.java\n+++ b/codes/java/chapter_stack_and_queue/array_queue.java\n@@ -35,7 +35,7 @@ public boolean isEmpty() {\n     }\n \n     /* 入队 */\n-    public void offer(int num) {\n+    public void push(int num) {\n         if (queSize == capacity()) {\n             System.out.println(\"队列已满\");\n             return;\n@@ -82,11 +82,11 @@ public static void main(String[] args) {\n         ArrayQueue queue = new ArrayQueue(capacity);\n \n         /* 元素入队 */\n-        queue.offer(1);\n-        queue.offer(3);\n-        queue.offer(2);\n-        queue.offer(5);\n-        queue.offer(4);\n+        queue.push(1);\n+        queue.push(3);\n+        queue.push(2);\n+        queue.push(5);\n+        queue.push(4);\n         System.out.println(\"队列 queue = \" + Arrays.toString(queue.toArray()));\n \n         /* 访问队首元素 */\n@@ -107,7 +107,7 @@ public static void main(String[] args) {\n \n         /* 测试环形数组 */\n         for (int i = 0; i < 10; i++) {\n-            queue.offer(i);\n+            queue.push(i);\n             queue.poll();\n             System.out.println(\"第 \" + i + \" 轮入队 + 出队后 queue = \" + Arrays.toString(queue.toArray()));\n         }\n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_deque.java b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n@@ -39,7 +39,7 @@ public boolean isEmpty() {\n     }\n \n     /* 入队操作 */\n-    private void offer(int num, boolean isFront) {\n+    private void push(int num, boolean isFront) {\n         ListNode node = new ListNode(num);\n         // 若链表为空，则令 front, rear 都指向 node\n         if (isEmpty())\n@@ -61,13 +61,13 @@ else if (isFront) {\n     }\n \n     /* 队首入队 */\n-    public void offerFirst(int num) {\n-        offer(num, true);\n+    public void pushFirst(int num) {\n+        push(num, true);\n     }\n \n     /* 队尾入队 */\n-    public void offerLast(int num) {\n-        offer(num, false);\n+    public void pushLast(int num) {\n+        push(num, false);\n     }\n \n     /* 出队操作 */\n@@ -141,9 +141,9 @@ public class linkedlist_deque {\n     public static void main(String[] args) {\n         /* 初始化双向队列 */\n         LinkedListDeque deque = new LinkedListDeque();\n-        deque.offerLast(3);\n-        deque.offerLast(2);\n-        deque.offerLast(5);\n+        deque.pushLast(3);\n+        deque.pushLast(2);\n+        deque.pushLast(5);\n         System.out.print(\"双点队列 deque = \");\n         deque.print();\n \n@@ -154,10 +154,10 @@ public static void main(String[] args) {\n         System.out.println(\"队尾元素 peekLast = \" + peekLast);\n \n         /* 元素入队 */\n-        deque.offerLast(4);\n+        deque.pushLast(4);\n         System.out.print(\"元素 4 队尾入队后 deque = \");\n         deque.print();\n-        deque.offerFirst(1);\n+        deque.pushFirst(1);\n         System.out.print(\"元素 1 队首入队后 deque = \");\n         deque.print();\n \n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_queue.java b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n@@ -7,7 +7,6 @@\n package chapter_stack_and_queue;\n \n import java.util.*;\n-import include.*;\n \n /* 基于链表实现的队列 */\n class LinkedListQueue {\n@@ -30,7 +29,7 @@ public boolean isEmpty() {\n     }\n \n     /* 入队 */\n-    public void offer(int num) {\n+    public void push(int num) {\n         // 尾结点后添加 num\n         ListNode node = new ListNode(num);\n         // 如果队列为空，则令头、尾结点都指向该结点\n@@ -79,11 +78,11 @@ public static void main(String[] args) {\n         LinkedListQueue queue = new LinkedListQueue();\n \n         /* 元素入队 */\n-        queue.offer(1);\n-        queue.offer(3);\n-        queue.offer(2);\n-        queue.offer(5);\n-        queue.offer(4);\n+        queue.push(1);\n+        queue.push(3);\n+        queue.push(2);\n+        queue.push(5);\n+        queue.push(4);\n         System.out.println(\"队列 queue = \" + Arrays.toString(queue.toArray()));\n \n         /* 访问队首元素 */",
    "output": "Unify the function naming of\nqueue from `offer()` to `push()`"
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/array_queue.java b/codes/java/chapter_stack_and_queue/array_queue.java\n--- a/codes/java/chapter_stack_and_queue/array_queue.java\n+++ b/codes/java/chapter_stack_and_queue/array_queue.java\n@@ -10,13 +10,13 @@\n \n /* 基于环形数组实现的队列 */\n class ArrayQueue {\n-    private int[] nums;     // 用于存储队列元素的数组\n-    private int front = 0;  // 头指针，指向队首\n-    private int rear = 0;   // 尾指针，指向队尾 + 1\n+    private int[] nums;  // 用于存储队列元素的数组\n+    private int front;   // 队首指针，指向队首元素\n+    private int queSize; // 队列长度\n \n     public ArrayQueue(int capacity) {\n-        // 初始化数组\n         nums = new int[capacity];\n+        front = queSize = 0;\n     }\n \n     /* 获取队列的容量 */\n@@ -26,33 +26,34 @@ public int capacity() {\n \n     /* 获取队列的长度 */\n     public int size() {\n-        int capacity = capacity();\n-        // 由于将数组看作为环形，可能 rear < front ，因此需要取余数\n-        return (capacity + rear - front) % capacity;\n+        return queSize;\n     }\n \n     /* 判断队列是否为空 */\n     public boolean isEmpty() {\n-        return rear - front == 0;\n+        return queSize == 0;\n     }\n \n     /* 入队 */\n     public void offer(int num) {\n-        if (size() == capacity()) {\n+        if (queSize == capacity()) {\n             System.out.println(\"队列已满\");\n             return;\n         }\n+        // 计算尾指针，指向队尾索引 + 1\n+        // 通过取余操作，实现 rear 越过数组尾部后回到头部\n+        int rear = (front + queSize) % capacity();\n         // 尾结点后添加 num\n         nums[rear] = num;\n-        // 尾指针向后移动一位，越过尾部后返回到数组头部\n-        rear = (rear + 1) % capacity();\n+        queSize++;\n     }\n \n     /* 出队 */\n     public int poll() {\n         int num = peek();\n-        // 队头指针向后移动一位，若越过尾部则返回到数组头部\n+        // 队首指针向后移动一位，若越过尾部则返回到数组头部\n         front = (front + 1) % capacity();\n+        queSize--;\n         return num;\n     }\n \n@@ -65,12 +66,10 @@ public int peek() {\n \n     /* 返回数组 */\n     public int[] toArray() {\n-        int size = size();\n-        int capacity = capacity();\n         // 仅转换有效长度范围内的列表元素\n-        int[] res = new int[size];\n-        for (int i = 0, j = front; i < size; i++, j++) {\n-            res[i] = nums[j % capacity];\n+        int[] res = new int[queSize];\n+        for (int i = 0, j = front; i < queSize; i++, j++) {\n+            res[i] = nums[j % capacity()];\n         }\n         return res;\n     }",
    "output": "Fix array queue."
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/my_list.java b/codes/java/chapter_array_and_linkedlist/my_list.java\n--- a/codes/java/chapter_array_and_linkedlist/my_list.java\n+++ b/codes/java/chapter_array_and_linkedlist/my_list.java\n@@ -33,14 +33,14 @@ public int capacity() {\n     /* 访问元素 */\n     public int get(int index) {\n         // 索引如果越界则抛出异常，下同\n-        if (index >= size)\n+        if (index < 0 || index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         return nums[index];\n     }\n \n     /* 更新元素 */\n     public void set(int index, int num) {\n-        if (index >= size)\n+        if (index < 0 || index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         nums[index] = num;\n     }\n@@ -57,7 +57,7 @@ public void add(int num) {\n \n     /* 中间插入元素 */\n     public void insert(int index, int num) {\n-        if (index >= size)\n+        if (index < 0 || index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         // 元素数量超出容量时，触发扩容机制\n         if (size == capacity())\n@@ -73,7 +73,7 @@ public void insert(int index, int num) {\n \n     /* 删除元素 */\n     public int remove(int index) {\n-        if (index >= size)\n+        if (index < 0 || index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         int num = nums[index];\n         // 将索引 index 之后的元素都向前移动一位",
    "output": "Merge branch 'develop'"
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/my_list.java b/codes/java/chapter_array_and_linkedlist/my_list.java\n--- a/codes/java/chapter_array_and_linkedlist/my_list.java\n+++ b/codes/java/chapter_array_and_linkedlist/my_list.java\n@@ -33,14 +33,14 @@ public int capacity() {\n     /* 访问元素 */\n     public int get(int index) {\n         // 索引如果越界则抛出异常，下同\n-        if (index >= size)\n+        if (index < 0 || index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         return nums[index];\n     }\n \n     /* 更新元素 */\n     public void set(int index, int num) {\n-        if (index >= size)\n+        if (index < 0 || index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         nums[index] = num;\n     }\n@@ -57,7 +57,7 @@ public void add(int num) {\n \n     /* 中间插入元素 */\n     public void insert(int index, int num) {\n-        if (index >= size)\n+        if (index < 0 || index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         // 元素数量超出容量时，触发扩容机制\n         if (size == capacity())\n@@ -73,7 +73,7 @@ public void insert(int index, int num) {\n \n     /* 删除元素 */\n     public int remove(int index) {\n-        if (index >= size)\n+        if (index < 0 || index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         int num = nums[index];\n         // 将索引 index 之后的元素都向前移动一位",
    "output": "Fix the index out of bound check in my_list."
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/deque.java b/codes/java/chapter_stack_and_queue/deque.java\n--- a/codes/java/chapter_stack_and_queue/deque.java\n+++ b/codes/java/chapter_stack_and_queue/deque.java\n@@ -12,13 +12,9 @@ public class deque {\n     public static void main(String[] args) {\n         /* 初始化双向队列 */\n         Deque<Integer> deque = new LinkedList<>();\n-\n-        /* 元素入队 */\n+        deque.offerLast(3);\n         deque.offerLast(2);\n         deque.offerLast(5);\n-        deque.offerLast(4);\n-        deque.offerFirst(3);\n-        deque.offerFirst(1);\n         System.out.println(\"双向队列 deque = \" + deque);\n \n         /* 访问元素 */\n@@ -27,11 +23,17 @@ public static void main(String[] args) {\n         int peekLast = deque.peekLast();\n         System.out.println(\"队尾元素 peekLast = \" + peekLast);\n \n+        /* 元素入队 */\n+        deque.offerLast(4);\n+        System.out.println(\"元素 4 队尾入队后 deque = \" + deque);\n+        deque.offerFirst(1);\n+        System.out.println(\"元素 1 队首入队后 deque = \" + deque);\n+\n         /* 元素出队 */\n-        int pollFirst = deque.pollFirst();\n-        System.out.println(\"队首出队元素 pollFirst = \" + pollFirst + \"，队首出队后 deque = \" + deque);\n         int pollLast = deque.pollLast();\n-        System.out.println(\"队尾出队元素 pollLast = \" + pollLast + \"，队尾出队后 deque = \" + deque);\n+        System.out.println(\"队尾出队元素 = \" + pollLast + \"，队尾出队后 deque = \" + deque);\n+        int pollFirst = deque.pollFirst();\n+        System.out.println(\"队首出队元素 = \" + pollFirst + \"，队首出队后 deque = \" + deque);\n \n         /* 获取双向队列的长度 */\n         int size = deque.size();\n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_deque.java b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n@@ -13,7 +13,6 @@ class ListNode {\n     int val;       // 结点值\n     ListNode next; // 后继结点引用（指针）\n     ListNode prev; // 前驱结点引用（指针）\n-\n     ListNode(int val) {\n         this.val = val;\n         prev = next = null;\n@@ -134,54 +133,45 @@ public void print() {\n             list.add(String.valueOf(head.val));\n             head = head.next;\n         }\n-        System.out.println(\"[\" + String.join(\" <-> \", list) + \"]\");\n+        System.out.println(\"[\" + String.join(\", \", list) + \"]\");\n     }\n }\n \n public class linkedlist_deque {\n     public static void main(String[] args) {\n         /* 初始化双向队列 */\n         LinkedListDeque deque = new LinkedListDeque();\n-        System.out.println(\"初始化空队列\");\n+        deque.offerLast(3);\n+        deque.offerLast(2);\n+        deque.offerLast(5);\n+        System.out.print(\"双点队列 deque = \");\n         deque.print();\n \n-        int[] nums = { 1, 2, 3 }; // 测试数据\n+        /* 访问元素 */\n+        int peekFirst = deque.peekFirst();\n+        System.out.println(\"队首元素 peekFirst = \" + peekFirst);\n+        int peekLast = deque.peekLast();\n+        System.out.println(\"队尾元素 peekLast = \" + peekLast);\n \n-        /* 队尾入队 */\n-        for (int num : nums) {\n-            deque.offerLast(num);\n-            System.out.printf(\"元素 %d 队尾入队后，队列为\\n\", num);\n-            deque.print();\n-        }\n-        /* 获取队尾元素 */\n-        int last = deque.peekLast();\n-        System.out.printf(\"队尾元素为 %d\\n\", last);\n-        /* 队尾出队 */\n-        while (!deque.isEmpty()) {\n-            last = deque.pollLast();\n-            System.out.printf(\"队尾出队元素为 %d ，队列为\\n\", last);\n-            deque.print();\n-        }\n+        /* 元素入队 */\n+        deque.offerLast(4);\n+        System.out.print(\"元素 4 队尾入队后 deque = \");\n+        deque.print();\n+        deque.offerFirst(1);\n+        System.out.print(\"元素 1 队首入队后 deque = \");\n+        deque.print();\n \n-        /* 队首入队 */\n-        for (int num : nums) {\n-            deque.offerFirst(num);\n-            System.out.printf(\"元素 %d 队首入队后，队列为\\n\", num);\n-            deque.print();\n-        }\n-        /* 获取队尾元素 */\n-        int first = deque.peekFirst();\n-        System.out.printf(\"队首元素为 %d\\n\", first);\n-        /* 队首出队 */\n-        while (!deque.isEmpty()) {\n-            first = deque.pollFirst();\n-            System.out.printf(\"队首出队元素为 %d ，队列为\\n\", first);\n-            deque.print();\n-        }\n+        /* 元素出队 */\n+        int pollLast = deque.pollLast();\n+        System.out.print(\"队尾出队元素 = \" + pollLast + \"，队尾出队后 deque = \");\n+        deque.print();\n+        int pollFirst = deque.pollFirst();\n+        System.out.print(\"队首出队元素 = \" + pollFirst + \"，队首出队后 deque = \");\n+        deque.print();\n \n-        /* 获取队列的长度 */\n+        /* 获取双向队列的长度 */\n         int size = deque.size();\n-        System.out.println(\"队列长度 size = \" + size);\n+        System.out.println(\"双向队列长度 size = \" + size);\n \n         /* 判断双向队列是否为空 */\n         boolean isEmpty = deque.isEmpty();",
    "output": "Update the test cases of deque."
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/linkedlist_deque.java b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n@@ -43,7 +43,7 @@ public boolean isEmpty() {\n     private void offer(int num, boolean isFront) {\n         ListNode node = new ListNode(num);\n         // 若链表为空，则令 front, rear 都指向 node\n-        if (size() == 0)\n+        if (isEmpty())\n             front = rear = node;\n         // 队首入队操作\n         else if (isFront) {\n@@ -74,7 +74,7 @@ public void offerLast(int num) {\n     /* 出队操作 */\n     private Integer poll(boolean isFront) {\n         // 若队列为空，直接返回 null\n-        if (size() == 0)\n+        if (isEmpty())\n             return null;\n         int val;\n         // 队首出队操作\n@@ -114,17 +114,17 @@ public Integer pollLast() {\n \n     /* 访问队首元素 */\n     public Integer peekFirst() {\n-        return size() != 0 ? front.val : null;\n+        return isEmpty() ? null : front.val;\n     }\n \n     /* 访问队尾元素 */\n     public Integer peekLast() {\n-        return size() != 0 ? rear.val : null;\n+        return isEmpty() ? null : rear.val;\n     }\n \n     /* 打印双向队列 */\n     public void print() {\n-        if (size() == 0) {\n+        if (isEmpty()) {\n             System.out.println(\"[ ]\");\n             return;\n         }\n@@ -153,9 +153,12 @@ public static void main(String[] args) {\n             System.out.printf(\"元素 %d 队尾入队后，队列为\\n\", num);\n             deque.print();\n         }\n+        /* 获取队尾元素 */\n+        int last = deque.peekLast();\n+        System.out.printf(\"队尾元素为 %d\\n\", last);\n         /* 队尾出队 */\n         while (!deque.isEmpty()) {\n-            int last = deque.pollLast();\n+            last = deque.pollLast();\n             System.out.printf(\"队尾出队元素为 %d ，队列为\\n\", last);\n             deque.print();\n         }\n@@ -166,9 +169,12 @@ public static void main(String[] args) {\n             System.out.printf(\"元素 %d 队首入队后，队列为\\n\", num);\n             deque.print();\n         }\n+        /* 获取队尾元素 */\n+        int first = deque.peekFirst();\n+        System.out.printf(\"队首元素为 %d\\n\", first);\n         /* 队首出队 */\n         while (!deque.isEmpty()) {\n-            int first = deque.pollFirst();\n+            first = deque.pollFirst();\n             System.out.printf(\"队首出队元素为 %d ，队列为\\n\", first);\n             deque.print();\n         }",
    "output": "Update linkedlist_deque.java"
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/linkedlist_deque.java b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_deque.java\n@@ -0,0 +1,184 @@\n+/**\n+ * File: linkedlist_deque.java\n+ * Created Time: 2023-01-20\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_stack_and_queue;\n+\n+import java.util.*;\n+\n+/* 双向链表结点 */\n+class ListNode {\n+    int val;       // 结点值\n+    ListNode next; // 后继结点引用（指针）\n+    ListNode prev; // 前驱结点引用（指针）\n+\n+    ListNode(int val) {\n+        this.val = val;\n+        prev = next = null;\n+    }\n+}\n+\n+/* 基于双向链表实现的双向队列 */\n+class LinkedListDeque {\n+    private ListNode front, rear; // 头结点 front ，尾结点 rear\n+    private int size = 0;         // 双向队列的长度\n+\n+    public LinkedListDeque() {\n+        front = rear = null;\n+    }\n+\n+    /* 获取双向队列的长度 */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /* 判断双向队列是否为空 */\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    /* 入队操作 */\n+    private void offer(int num, boolean isFront) {\n+        ListNode node = new ListNode(num);\n+        // 若链表为空，则令 front, rear 都指向 node\n+        if (size() == 0)\n+            front = rear = node;\n+        // 队首入队操作\n+        else if (isFront) {\n+            // 将 node 添加至链表头部\n+            front.prev = node;\n+            node.next = front;\n+            front = node; // 更新头结点\n+        // 队尾入队操作\n+        } else {\n+            // 将 node 添加至链表尾部\n+            rear.next = node;\n+            node.prev = rear;\n+            rear = node;  // 更新尾结点\n+        }\n+        size++; // 更新队列长度\n+    }\n+\n+    /* 队首入队 */\n+    public void offerFirst(int num) {\n+        offer(num, true);\n+    }\n+\n+    /* 队尾入队 */\n+    public void offerLast(int num) {\n+        offer(num, false);\n+    }\n+\n+    /* 出队操作 */\n+    private Integer poll(boolean isFront) {\n+        // 若队列为空，直接返回 null\n+        if (size() == 0)\n+            return null;\n+        int val;\n+        // 队首出队操作\n+        if (isFront) {\n+            val = front.val; // 暂存头结点值\n+            // 删除头结点\n+            ListNode fNext = front.next;\n+            if (fNext != null) {\n+                fNext.prev = null;\n+                front.next = null;\n+            }\n+            front = fNext;   // 更新头结点\n+        // 队尾出队操作\n+        } else {\n+            val = rear.val;  // 暂存尾结点值\n+            // 删除尾结点\n+            ListNode rPrev = rear.prev;\n+            if (rPrev != null) {\n+                rPrev.next = null;\n+                rear.prev = null;\n+            }\n+            rear = rPrev;    // 更新尾结点\n+        }\n+        size--; // 更新队列长度\n+        return val;\n+    }\n+\n+    /* 队首出队 */\n+    public Integer pollFirst() {\n+        return poll(true);\n+    }\n+\n+    /* 队尾出队 */\n+    public Integer pollLast() {\n+        return poll(false);\n+    }\n+\n+    /* 访问队首元素 */\n+    public Integer peekFirst() {\n+        return size() != 0 ? front.val : null;\n+    }\n+\n+    /* 访问队尾元素 */\n+    public Integer peekLast() {\n+        return size() != 0 ? rear.val : null;\n+    }\n+\n+    /* 打印双向队列 */\n+    public void print() {\n+        if (size() == 0) {\n+            System.out.println(\"[ ]\");\n+            return;\n+        }\n+        List<String> list = new ArrayList<>();\n+        ListNode head = front;\n+        while (head != null) {\n+            list.add(String.valueOf(head.val));\n+            head = head.next;\n+        }\n+        System.out.println(\"[\" + String.join(\" <-> \", list) + \"]\");\n+    }\n+}\n+\n+public class linkedlist_deque {\n+    public static void main(String[] args) {\n+        /* 初始化双向队列 */\n+        LinkedListDeque deque = new LinkedListDeque();\n+        System.out.println(\"初始化空队列\");\n+        deque.print();\n+\n+        int[] nums = { 1, 2, 3 }; // 测试数据\n+\n+        /* 队尾入队 */\n+        for (int num : nums) {\n+            deque.offerLast(num);\n+            System.out.printf(\"元素 %d 队尾入队后，队列为\\n\", num);\n+            deque.print();\n+        }\n+        /* 队尾出队 */\n+        while (!deque.isEmpty()) {\n+            int last = deque.pollLast();\n+            System.out.printf(\"队尾出队元素为 %d ，队列为\\n\", last);\n+            deque.print();\n+        }\n+\n+        /* 队首入队 */\n+        for (int num : nums) {\n+            deque.offerFirst(num);\n+            System.out.printf(\"元素 %d 队首入队后，队列为\\n\", num);\n+            deque.print();\n+        }\n+        /* 队首出队 */\n+        while (!deque.isEmpty()) {\n+            int first = deque.pollFirst();\n+            System.out.printf(\"队首出队元素为 %d ，队列为\\n\", first);\n+            deque.print();\n+        }\n+\n+        /* 获取队列的长度 */\n+        int size = deque.size();\n+        System.out.println(\"队列长度 size = \" + size);\n+\n+        /* 判断双向队列是否为空 */\n+        boolean isEmpty = deque.isEmpty();\n+        System.out.println(\"双向队列是否为空 = \" + isEmpty);\n+    }\n+}",
    "output": "Add linkedlist_deque.java"
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/stack.java b/codes/java/chapter_stack_and_queue/stack.java\n--- a/codes/java/chapter_stack_and_queue/stack.java\n+++ b/codes/java/chapter_stack_and_queue/stack.java\n@@ -11,23 +11,23 @@\n public class stack {\n     public static void main(String[] args) {\n         /* 初始化栈 */\n-        // 在 Java 中，推荐将 LinkedList 当作栈来使用\n-        LinkedList<Integer> stack = new LinkedList<>();\n+        // 在 Java 中，推荐将 ArrayList 当作栈来使用\n+        List<Integer> stack = new ArrayList<>();\n \n         /* 元素入栈 */\n-        stack.addLast(1);\n-        stack.addLast(3);\n-        stack.addLast(2);\n-        stack.addLast(5);\n-        stack.addLast(4);\n+        stack.add(1);\n+        stack.add(3);\n+        stack.add(2);\n+        stack.add(5);\n+        stack.add(4);\n         System.out.println(\"栈 stack = \" + stack);\n \n         /* 访问栈顶元素 */\n-        int peek = stack.peekLast();\n+        int peek = stack.get(stack.size() - 1);\n         System.out.println(\"栈顶元素 peek = \" + peek);\n \n         /* 元素出栈 */\n-        int pop = stack.removeLast();\n+        int pop = stack.remove(stack.size() - 1);\n         System.out.println(\"出栈元素 pop = \" + pop + \"，出栈后 stack = \" + stack);\n \n         /* 获取栈的长度 */",
    "output": "Update stack, queue, space_time_tradeoff"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/radix_sort.java b/codes/java/chapter_sorting/radix_sort.java\n--- a/codes/java/chapter_sorting/radix_sort.java\n+++ b/codes/java/chapter_sorting/radix_sort.java\n@@ -4,65 +4,64 @@\n  * Author: Krahets (krahets@163.com)\n  */\n \n- package chapter_sorting;\n+package chapter_sorting;\n \n- import java.util.*;\n- \n- public class radix_sort {\n-     /* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */\n-     static int digit(int num, int exp) {\n-         // 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算\n-         return (num / exp) % 10;\n-     }\n- \n-     /* 计数排序（根据 nums 第 k 位排序） */\n-     static void countSort(int[] nums, int exp) {\n-         // 十进制的各位数字范围为 0~9 ，因此需要长度为 10 的桶\n-         int[] bucket = new int[10];\n-         int n = nums.length;\n-         // 借助桶来统计 0~9 各数字的出现次数\n-         for (int i = 0; i < n; i++) {\n-             int d = digit(nums[i], exp); // 获取 nums[i] 第 k 位，记为 d\n-             bucket[d]++;                 // 统计数字 d 的出现次数\n-         }\n-         // 求前缀和，将“出现个数”转换为“数组索引”\n-         for (int i = 1; i < 10; i++) {\n-             bucket[i] += bucket[i - 1];\n-         }\n-         // 倒序遍历，根据桶内统计结果，将各元素填入暂存数组 tmp\n-         int[] tmp = new int[n];\n-         for (int i = n - 1; i >= 0; i--) {\n-             int d = digit(nums[i], exp);\n-             int j = bucket[d] - 1; // 获取 d 在数组中的索引 j\n-             tmp[j] = nums[i];      // 将当前元素填入索引 j\n-             bucket[d]--;           // 将 d 的数量减 1\n-         }\n-         // 将 tmp 复制到 nums \n-         for (int i = 0; i < n; i++)\n-             nums[i] = tmp[i];\n-     }\n- \n-     /* 基数排序 */\n-     static void radixSort(int[] nums) {\n-         // 获取数组的最大元素，用于判断最大位数\n-         int ma = Integer.MIN_VALUE;\n-         for (int num : nums)\n-             if (num > ma) ma = num;\n-         // 按照从低位到高位的顺序遍历\n-         // k = 1 -> exp = 1\n-         // k = 2 -> exp = 10\n-         // k = 3 -> exp = 100\n-         // 即 exp = 10^(k-1)\n-         for (int exp = 1; ma >= exp; exp *= 10)\n-             // 对数组元素的第 k 位执行「计数排序」\n-             countSort(nums, exp);\n-     }\n- \n-     public static void main(String[] args) {\n-         /* 基数排序 */\n-         int[] nums = { 23, 12, 3, 4, 788, 192 };\n-         radixSort(nums);\n-         System.out.println(\"基数排序完成后 nums = \" + Arrays.toString(nums));\n-     }\n- }\n- \n\\ No newline at end of file\n+import java.util.*;\n+\n+public class radix_sort {\n+    /* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */\n+    static int digit(int num, int exp) {\n+        // 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算\n+        return (num / exp) % 10;\n+    }\n+\n+    /* 计数排序（根据 nums 第 k 位排序） */\n+    static void countSort(int[] nums, int exp) {\n+        // 十进制的各位数字范围为 0~9 ，因此需要长度为 10 的桶\n+        int[] bucket = new int[10];\n+        int n = nums.length;\n+        // 借助桶来统计 0~9 各数字的出现次数\n+        for (int i = 0; i < n; i++) {\n+            int d = digit(nums[i], exp); // 获取 nums[i] 第 k 位，记为 d\n+            bucket[d]++;                 // 统计数字 d 的出现次数\n+        }\n+        // 求前缀和，将“出现个数”转换为“数组索引”\n+        for (int i = 1; i < 10; i++) {\n+            bucket[i] += bucket[i - 1];\n+        }\n+        // 倒序遍历，根据桶内统计结果，将各元素填入暂存数组 tmp\n+        int[] tmp = new int[n];\n+        for (int i = n - 1; i >= 0; i--) {\n+            int d = digit(nums[i], exp);\n+            int j = bucket[d] - 1; // 获取 d 在数组中的索引 j\n+            tmp[j] = nums[i];      // 将当前元素填入索引 j\n+            bucket[d]--;           // 将 d 的数量减 1\n+        }\n+        // 将 tmp 复制到 nums\n+        for (int i = 0; i < n; i++)\n+            nums[i] = tmp[i];\n+    }\n+\n+    /* 基数排序 */\n+    static void radixSort(int[] nums) {\n+        // 获取数组的最大元素，用于判断最大位数\n+        int ma = Integer.MIN_VALUE;\n+        for (int num : nums)\n+            if (num > ma) ma = num;\n+        // 按照从低位到高位的顺序遍历\n+        for (int exp = 1; ma >= exp; exp *= 10)\n+            // 对数组元素的第 k 位执行「计数排序」\n+            // k = 1 -> exp = 1\n+            // k = 2 -> exp = 10\n+            // k = 3 -> exp = 100\n+            // 即 exp = 10^(k-1)\n+            countSort(nums, exp);\n+    }\n+\n+    public static void main(String[] args) {\n+        /* 基数排序 */\n+        int[] nums = { 23, 12, 3, 4, 788, 192 };\n+        radixSort(nums);\n+        System.out.println(\"基数排序完成后 nums = \" + Arrays.toString(nums));\n+    }\n+}",
    "output": "Update radix_sort.java"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/radix_sort.java b/codes/java/chapter_sorting/radix_sort.java\n--- a/codes/java/chapter_sorting/radix_sort.java\n+++ b/codes/java/chapter_sorting/radix_sort.java\n@@ -0,0 +1,68 @@\n+/**\n+ * File: radix_sort.java\n+ * Created Time: 2023-01-17\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+ package chapter_sorting;\n+\n+ import java.util.*;\n+ \n+ public class radix_sort {\n+     /* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */\n+     static int digit(int num, int exp) {\n+         // 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算\n+         return (num / exp) % 10;\n+     }\n+ \n+     /* 计数排序（根据 nums 第 k 位排序） */\n+     static void countSort(int[] nums, int exp) {\n+         // 十进制的各位数字范围为 0~9 ，因此需要长度为 10 的桶\n+         int[] bucket = new int[10];\n+         int n = nums.length;\n+         // 借助桶来统计 0~9 各数字的出现次数\n+         for (int i = 0; i < n; i++) {\n+             int d = digit(nums[i], exp); // 获取 nums[i] 第 k 位，记为 d\n+             bucket[d]++;                 // 统计数字 d 的出现次数\n+         }\n+         // 求前缀和，将“出现个数”转换为“数组索引”\n+         for (int i = 1; i < 10; i++) {\n+             bucket[i] += bucket[i - 1];\n+         }\n+         // 倒序遍历，根据桶内统计结果，将各元素填入暂存数组 tmp\n+         int[] tmp = new int[n];\n+         for (int i = n - 1; i >= 0; i--) {\n+             int d = digit(nums[i], exp);\n+             int j = bucket[d] - 1; // 获取 d 在数组中的索引 j\n+             tmp[j] = nums[i];      // 将当前元素填入索引 j\n+             bucket[d]--;           // 将 d 的数量减 1\n+         }\n+         // 将 tmp 复制到 nums \n+         for (int i = 0; i < n; i++)\n+             nums[i] = tmp[i];\n+     }\n+ \n+     /* 基数排序 */\n+     static void radixSort(int[] nums) {\n+         // 获取数组的最大元素，用于判断最大位数\n+         int ma = Integer.MIN_VALUE;\n+         for (int num : nums)\n+             if (num > ma) ma = num;\n+         // 按照从低位到高位的顺序遍历\n+         // k = 1 -> exp = 1\n+         // k = 2 -> exp = 10\n+         // k = 3 -> exp = 100\n+         // 即 exp = 10^(k-1)\n+         for (int exp = 1; ma >= exp; exp *= 10)\n+             // 对数组元素的第 k 位执行「计数排序」\n+             countSort(nums, exp);\n+     }\n+ \n+     public static void main(String[] args) {\n+         /* 基数排序 */\n+         int[] nums = { 23, 12, 3, 4, 788, 192 };\n+         radixSort(nums);\n+         System.out.println(\"基数排序完成后 nums = \" + Arrays.toString(nums));\n+     }\n+ }\n+ \n\\ No newline at end of file",
    "output": "Update radix_sort.java"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/quick_sort.java b/codes/java/chapter_sorting/quick_sort.java\n--- a/codes/java/chapter_sorting/quick_sort.java\n+++ b/codes/java/chapter_sorting/quick_sort.java\n@@ -58,7 +58,7 @@ static void swap(int[] nums, int i, int j) {\n     static int medianThree(int[] nums, int left, int mid, int right) {\n         // 使用了异或操作来简化代码\n         // 异或规则为 0 ^ 0 = 1 ^ 1 = 0, 0 ^ 1 = 1 ^ 0 = 1\n-        if ((nums[left] > nums[mid]) ^ (nums[left] > nums[right]))\n+        if ((nums[left] < nums[mid]) ^ (nums[left] < nums[right]))\n             return left;\n         else if ((nums[mid] < nums[left]) ^ (nums[mid] < nums[right]))\n             return mid;",
    "output": "Update medianThree() in quick_sort."
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_tree_bfs.java b/codes/java/chapter_tree/binary_tree_bfs.java\n--- a/codes/java/chapter_tree/binary_tree_bfs.java\n+++ b/codes/java/chapter_tree/binary_tree_bfs.java\n@@ -13,7 +13,7 @@ public class binary_tree_bfs {\n     /* 层序遍历 */\n     static List<Integer> hierOrder(TreeNode root) {\n         // 初始化队列，加入根结点\n-        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n         // 初始化一个列表，用于保存遍历序列\n         List<Integer> list = new ArrayList<>();\n         while (!queue.isEmpty()) {\n\ndiff --git a/codes/java/include/TreeNode.java b/codes/java/include/TreeNode.java\n--- a/codes/java/include/TreeNode.java\n+++ b/codes/java/include/TreeNode.java\n@@ -32,7 +32,7 @@ public static TreeNode listToTree(List<Integer> list) {\n             return null;\n         \n         TreeNode root = new TreeNode(list.get(0));\n-        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n         int i = 0;\n         while(!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n@@ -58,7 +58,7 @@ public static TreeNode listToTree(List<Integer> list) {\n     public static List<Integer> treeToList(TreeNode root) {\n         List<Integer> list = new ArrayList<>();\n         if(root == null) return list;\n-        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n         while(!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n             if(node != null) {",
    "output": "add zig codes for Section 'Heap' (heap.zig)"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_tree_bfs.java b/codes/java/chapter_tree/binary_tree_bfs.java\n--- a/codes/java/chapter_tree/binary_tree_bfs.java\n+++ b/codes/java/chapter_tree/binary_tree_bfs.java\n@@ -13,7 +13,7 @@ public class binary_tree_bfs {\n     /* 层序遍历 */\n     static List<Integer> hierOrder(TreeNode root) {\n         // 初始化队列，加入根结点\n-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};\n         // 初始化一个列表，用于保存遍历序列\n         List<Integer> list = new ArrayList<>();\n         while (!queue.isEmpty()) {\n\ndiff --git a/codes/java/include/TreeNode.java b/codes/java/include/TreeNode.java\n--- a/codes/java/include/TreeNode.java\n+++ b/codes/java/include/TreeNode.java\n@@ -32,7 +32,7 @@ public static TreeNode listToTree(List<Integer> list) {\n             return null;\n         \n         TreeNode root = new TreeNode(list.get(0));\n-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};\n         int i = 0;\n         while(!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n@@ -58,7 +58,7 @@ public static TreeNode listToTree(List<Integer> list) {\n     public static List<Integer> treeToList(TreeNode root) {\n         List<Integer> list = new ArrayList<>();\n         if(root == null) return list;\n-        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n+        Queue<TreeNode> queue = new LinkedList<TreeNode>() {{ add(root); }};\n         while(!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n             if(node != null) {",
    "output": "fix bugs in java codes using JDK 1.8.0"
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/linked_list.java b/codes/java/chapter_array_and_linkedlist/linked_list.java\n--- a/codes/java/chapter_array_and_linkedlist/linked_list.java\n+++ b/codes/java/chapter_array_and_linkedlist/linked_list.java\n@@ -29,9 +29,9 @@ static void remove(ListNode n0) {\n     /* 访问链表中索引为 index 的结点 */\n     static ListNode access(ListNode head, int index) {\n         for (int i = 0; i < index; i++) {\n-            head = head.next;\n             if (head == null)\n                 return null;\n+            head = head.next;\n         }\n         return head;\n     }\n\ndiff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -131,7 +131,7 @@ public static void main(String[] args) {\n         PrintUtil.printTree(bst.getRoot());\n \n         /* 查找结点 */\n-        TreeNode node = bst.search(5);\n+        TreeNode node = bst.search(7);\n         System.out.println(\"\\n查找到的结点对象为 \" + node + \"，结点值 = \" + node.val);\n \n         /* 插入结点 */",
    "output": "Merge branch 'master' into heap-dev"
  },
  {
    "input": "diff --git a/codes/java/chapter_hashing/array_hash_map.java b/codes/java/chapter_hashing/array_hash_map.java\n--- a/codes/java/chapter_hashing/array_hash_map.java\n+++ b/codes/java/chapter_hashing/array_hash_map.java\n@@ -5,6 +5,7 @@\n  */\n \n package chapter_hashing;\n+\n import java.util.*;\n \n /* 键值对 int->String */\n\ndiff --git a/codes/java/chapter_hashing/hash_map.java b/codes/java/chapter_hashing/hash_map.java\n--- a/codes/java/chapter_hashing/hash_map.java\n+++ b/codes/java/chapter_hashing/hash_map.java\n@@ -5,6 +5,7 @@\n  */\n \n package chapter_hashing;\n+\n import java.util.*;\n import include.*;\n \n\ndiff --git a/codes/java/chapter_heap/heap.java b/codes/java/chapter_heap/heap.java\n--- a/codes/java/chapter_heap/heap.java\n+++ b/codes/java/chapter_heap/heap.java\n@@ -13,13 +13,13 @@\n public class heap {\n     public static void testPush(Queue<Integer> heap, int val) {\n         heap.add(val); // 元素入堆\n-        System.out.format(\"\\n添加元素 %d 后\\n\", val);\n+        System.out.format(\"\\n元素 %d 入堆后\\n\", val);\n         PrintUtil.printHeap(heap);\n     }\n \n     public static void testPoll(Queue<Integer> heap) {\n         int val = heap.poll(); // 堆顶元素出堆\n-        System.out.format(\"\\n出堆元素为 %d\\n\", val);\n+        System.out.format(\"\\n堆顶元素 %d 出堆后\\n\", val);\n         PrintUtil.printHeap(heap);\n     }\n \n@@ -46,6 +46,9 @@ public static void main(String[] args) {\n         /* 堆顶元素出堆 */\n         testPoll(maxHeap);\n         testPoll(maxHeap);\n+        testPoll(maxHeap);\n+        testPoll(maxHeap);\n+        testPoll(maxHeap);\n \n         /* 获取堆大小 */\n         int size = maxHeap.size();\n@@ -58,7 +61,7 @@ public static void main(String[] args) {\n         /* 输入列表并建堆 */\n         // 时间复杂度为 O(n) ，而非 O(nlogn)\n         minHeap = new PriorityQueue<>(Arrays.asList(1, 3, 2, 5, 4));\n-        System.out.println(\"\\n输入 [1, 3, 2, 5, 4] ，建立小顶堆\");\n+        System.out.println(\"\\n输入列表并建立小顶堆后\");\n         PrintUtil.printHeap(minHeap);\n     }\n }\n\ndiff --git a/codes/java/chapter_heap/my_heap.java b/codes/java/chapter_heap/my_heap.java\n--- a/codes/java/chapter_heap/my_heap.java\n+++ b/codes/java/chapter_heap/my_heap.java\n@@ -146,26 +146,25 @@ public static void testPoll(MaxHeap maxHeap) {\n     }\n \n     public static void main(String[] args) {\n-        /* 初始化堆 */\n-        // 初始化大顶堆\n-        MaxHeap maxHeap = new MaxHeap();\n-\n-        System.out.println(\"\\n以下测试样例为大顶堆\");\n-\n-        /* 元素入堆 */\n-        testPush(maxHeap, 1);\n-        testPush(maxHeap, 3);\n-        testPush(maxHeap, 2);\n-        testPush(maxHeap, 5);\n-        testPush(maxHeap, 4);\n+        /* 初始化大顶堆 */\n+        MaxHeap maxHeap = new MaxHeap(Arrays.asList(9, 8, 6, 6, 7, 5, 2, 1, 4, 3, 6, 2));\n+        System.out.println(\"\\n输入列表并建堆后\");\n+        maxHeap.print();\n \n         /* 获取堆顶元素 */\n         int peek = maxHeap.peek();\n         System.out.format(\"\\n堆顶元素为 %d\\n\", peek);\n \n+        /* 元素入堆 */\n+        int val = 7;\n+        maxHeap.push(val);\n+        System.out.format(\"\\n元素 %d 入堆后\\n\", val);\n+        maxHeap.print();\n+\n         /* 堆顶元素出堆 */\n-        testPoll(maxHeap);\n-        testPoll(maxHeap);\n+        peek = maxHeap.poll();\n+        System.out.format(\"\\n堆顶元素 %d 出堆后\\n\", peek);\n+        maxHeap.print();\n \n         /* 获取堆大小 */\n         int size = maxHeap.size();\n@@ -174,10 +173,5 @@ public static void main(String[] args) {\n         /* 判断堆是否为空 */\n         boolean isEmpty = maxHeap.isEmpty();\n         System.out.format(\"\\n堆是否为空 %b\\n\", isEmpty);\n-\n-        /* 将输入列表堆化 */\n-        maxHeap = new MaxHeap(Arrays.asList(1, 3, 2, 5, 4));\n-        System.out.println(\"\\n输入 [1, 3, 2, 5, 4] ，建立大顶堆\");\n-        maxHeap.print();\n     }\n }",
    "output": "Update heap."
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -131,7 +131,7 @@ public static void main(String[] args) {\n         PrintUtil.printTree(bst.getRoot());\n \n         /* 查找结点 */\n-        TreeNode node = bst.search(5);\n+        TreeNode node = bst.search(7);\n         System.out.println(\"\\n查找到的结点对象为 \" + node + \"，结点值 = \" + node.val);\n \n         /* 插入结点 */",
    "output": "Merge branch 'krahets:master' into master"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -131,7 +131,7 @@ public static void main(String[] args) {\n         PrintUtil.printTree(bst.getRoot());\n \n         /* 查找结点 */\n-        TreeNode node = bst.search(5);\n+        TreeNode node = bst.search(7);\n         System.out.println(\"\\n查找到的结点对象为 \" + node + \"，结点值 = \" + node.val);\n \n         /* 插入结点 */",
    "output": "Merge pull request #189 from guowei-gong/binary_search_tree\n\ntest(binary_search_tree): update test param"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -131,7 +131,7 @@ public static void main(String[] args) {\n         PrintUtil.printTree(bst.getRoot());\n \n         /* 查找结点 */\n-        TreeNode node = bst.search(5);\n+        TreeNode node = bst.search(7);\n         System.out.println(\"\\n查找到的结点对象为 \" + node + \"，结点值 = \" + node.val);\n \n         /* 插入结点 */",
    "output": "test(binary_search_tree): update test param all the language\n\nuse param value 7, not 5. function test param value with param value in example picture as same."
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/linked_list.java b/codes/java/chapter_array_and_linkedlist/linked_list.java\n--- a/codes/java/chapter_array_and_linkedlist/linked_list.java\n+++ b/codes/java/chapter_array_and_linkedlist/linked_list.java\n@@ -29,9 +29,9 @@ static void remove(ListNode n0) {\n     /* 访问链表中索引为 index 的结点 */\n     static ListNode access(ListNode head, int index) {\n         for (int i = 0; i < index; i++) {\n-            head = head.next;\n             if (head == null)\n                 return null;\n+            head = head.next;\n         }\n         return head;\n     }",
    "output": "Merge branch 'krahets:master' into master"
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/linked_list.java b/codes/java/chapter_array_and_linkedlist/linked_list.java\n--- a/codes/java/chapter_array_and_linkedlist/linked_list.java\n+++ b/codes/java/chapter_array_and_linkedlist/linked_list.java\n@@ -29,9 +29,9 @@ static void remove(ListNode n0) {\n     /* 访问链表中索引为 index 的结点 */\n     static ListNode access(ListNode head, int index) {\n         for (int i = 0; i < index; i++) {\n-            head = head.next;\n             if (head == null)\n                 return null;\n+            head = head.next;\n         }\n         return head;\n     }",
    "output": "Update the access() function of linked_list"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_tree_bfs.java b/codes/java/chapter_tree/binary_tree_bfs.java\n--- a/codes/java/chapter_tree/binary_tree_bfs.java\n+++ b/codes/java/chapter_tree/binary_tree_bfs.java\n@@ -30,8 +30,7 @@ static List<Integer> hierOrder(TreeNode root) {\n     public static void main(String[] args) {\n         /* 初始化二叉树 */\n         // 这里借助了一个从数组直接生成二叉树的函数\n-        TreeNode root = TreeNode.arrToTree(new Integer[] {\n-                1, 2, 3, 4, 5, 6, 7, null, null, null, null, null, null, null, null });\n+        TreeNode root = TreeNode.arrToTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7 });\n         System.out.println(\"\\n初始化二叉树\\n\");\n         PrintUtil.printTree(root);\n \n\ndiff --git a/codes/java/chapter_tree/binary_tree_dfs.java b/codes/java/chapter_tree/binary_tree_dfs.java\n--- a/codes/java/chapter_tree/binary_tree_dfs.java\n+++ b/codes/java/chapter_tree/binary_tree_dfs.java\n@@ -43,8 +43,7 @@ static void postOrder(TreeNode root) {\n     public static void main(String[] args) {\n         /* 初始化二叉树 */\n         // 这里借助了一个从数组直接生成二叉树的函数\n-        TreeNode root = TreeNode.arrToTree(new Integer[] { \n-            1, 2, 3, 4, 5, 6, 7, null, null, null, null, null, null, null, null});\n+        TreeNode root = TreeNode.arrToTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7 });\n         System.out.println(\"\\n初始化二叉树\\n\");\n         PrintUtil.printTree(root);\n \n\ndiff --git a/codes/java/include/PrintUtil.java b/codes/java/include/PrintUtil.java\n--- a/codes/java/include/PrintUtil.java\n+++ b/codes/java/include/PrintUtil.java\n@@ -8,6 +8,7 @@\n \n import java.util.*;\n \n+\n class Trunk {\n     Trunk prev;\n     String str;\n@@ -103,4 +104,11 @@ public static <K, V> void printHashMap(Map<K, V> map) {\n             System.out.println(kv.getKey() + \" -> \" + kv.getValue());\n         }\n     }\n+\n+    public static void printHeap(PriorityQueue<Integer> queue) {\n+        Integer[] nums = (Integer[])queue.toArray();\n+        TreeNode root = TreeNode.arrToTree(nums);\n+        \n+        printTree(root);\n+    }\n }\n\ndiff --git a/codes/java/include/TreeNode.java b/codes/java/include/TreeNode.java\n--- a/codes/java/include/TreeNode.java\n+++ b/codes/java/include/TreeNode.java\n@@ -22,7 +22,7 @@ public TreeNode(int x) {\n     }\n \n     /**\n-     * Generate a binary tree with an array\n+     * Generate a binary tree given an array\n      * @param arr\n      * @return\n      */\n@@ -32,19 +32,19 @@ public static TreeNode arrToTree(Integer[] arr) {\n         \n         TreeNode root = new TreeNode(arr[0]);\n         Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n-        int i = 1;\n+        int i = 0;\n         while(!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n+            if (++i >= arr.length) break;\n             if(arr[i] != null) {\n                 node.left = new TreeNode(arr[i]);\n                 queue.add(node.left);\n             }\n-            i++;\n+            if (++i >= arr.length) break;\n             if(arr[i] != null) {\n                 node.right = new TreeNode(arr[i]);\n                 queue.add(node.right);\n             }\n-            i++;\n         }\n         return root;\n     }\n@@ -71,20 +71,4 @@ public static List<Integer> treeToList(TreeNode root) {\n         }\n         return list;\n     }\n-    \n-    /**\n-     * Get a tree node with specific value in a binary tree\n-     * @param root\n-     * @param val\n-     * @return\n-     */\n-    public static TreeNode getTreeNode(TreeNode root, int val) {\n-        if (root == null)\n-            return null;\n-        if (root.val == val)\n-            return root;\n-        TreeNode left = getTreeNode(root.left, val);\n-        TreeNode right = getTreeNode(root.right, val);\n-        return left != null ? left : right;\n-    }\n }",
    "output": "Merge branch 'krahets:master' into master"
  },
  {
    "input": "diff --git a/codes/java/chapter_heap/heap.java b/codes/java/chapter_heap/heap.java\n--- a/codes/java/chapter_heap/heap.java\n+++ b/codes/java/chapter_heap/heap.java\n@@ -12,28 +12,26 @@\n \n public class heap {\n     public static void testPush(Queue<Integer> heap, int val) {\n-        // 元素入堆\n-        heap.add(val);\n-\n+        heap.add(val); // 元素入堆\n         System.out.format(\"\\n添加元素 %d 后\\n\", val);\n         PrintUtil.printHeap(heap);\n     }\n \n     public static void testPoll(Queue<Integer> heap) {\n-        // 元素出堆\n-        int val = heap.poll();\n-\n+        int val = heap.poll(); // 堆顶元素出堆\n         System.out.format(\"\\n出堆元素为 %d\\n\", val);\n         PrintUtil.printHeap(heap);\n     }\n \n     public static void main(String[] args) {\n         /* 初始化堆 */\n-        // 初始化最小堆\n+        // 初始化小顶堆\n         Queue<Integer> minHeap = new PriorityQueue<>();\n-        // 初始化最大堆（使用 lambda 表达式修改 Comparator）\n+        // 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）\n         Queue<Integer> maxHeap = new PriorityQueue<>((a, b) -> { return b - a; });\n \n+        System.out.println(\"\\n以下测试样例为大顶堆\");\n+\n         /* 元素入堆 */\n         testPush(maxHeap, 1);\n         testPush(maxHeap, 3);\n@@ -45,7 +43,7 @@ public static void main(String[] args) {\n         int peek = maxHeap.peek();\n         System.out.format(\"\\n堆顶元素为 %d\\n\", peek);\n \n-        /* 元素出堆 */\n+        /* 堆顶元素出堆 */\n         testPoll(maxHeap);\n         testPoll(maxHeap);\n \n@@ -56,5 +54,11 @@ public static void main(String[] args) {\n         /* 判断堆是否为空 */\n         boolean isEmpty = maxHeap.isEmpty();\n         System.out.format(\"\\n堆是否为空 %b\\n\", isEmpty);\n+\n+        /* 输入列表并建堆 */\n+        // 时间复杂度为 O(n) ，而非 O(nlogn)\n+        minHeap = new PriorityQueue<>(Arrays.asList(1, 3, 2, 5, 4));\n+        System.out.println(\"\\n输入 [1, 3, 2, 5, 4] ，建立小顶堆\");\n+        PrintUtil.printHeap(minHeap);\n     }\n }\n\ndiff --git a/codes/java/chapter_heap/my_heap.java b/codes/java/chapter_heap/my_heap.java\n--- a/codes/java/chapter_heap/my_heap.java\n+++ b/codes/java/chapter_heap/my_heap.java\n@@ -18,13 +18,13 @@ public MaxHeap() {\n         maxHeap = new ArrayList<>();\n     }\n \n-    /* 构造函数，堆化 nums 所有元素 */\n+    /* 构造函数，根据输入列表建堆 */\n     public MaxHeap(List<Integer> nums) {\n-        // 将元素拷贝至堆中\n+        // 所有元素入堆\n         maxHeap = new ArrayList<>(nums);\n         // 堆化除叶结点以外的其他所有结点\n         for (int i = parent(size() - 1); i >= 0; i--) {\n-            heapify(i);\n+            siftDown(i);\n         }\n     }\n \n@@ -40,7 +40,7 @@ private int right(int i) {\n \n     /* 获取父结点索引 */\n     private int parent(int i) {\n-        return (i - 1) / 2;\n+        return (i - 1) / 2; // 向下整除\n     }\n \n     /* 交换元素 */\n@@ -72,12 +72,20 @@ public void push(int val) {\n         // 添加结点\n         maxHeap.add(val);\n         // 从底至顶堆化\n-        int i = size() - 1;\n+        siftUp(size() - 1);\n+    }\n+\n+    /* 从结点 i 开始，从底至顶堆化 */\n+    private void siftUp(int i) {\n         while (true) {\n+            // 获取结点 i 的父结点\n             int p = parent(i);\n+            // 当“越过根结点”或“结点无需修复”时，结束堆化\n             if (p < 0 || maxHeap.get(i) <= maxHeap.get(p))\n                 break;\n+            // 交换两结点\n             swap(i, p);\n+            // 循环向上堆化\n             i = p;\n         }\n     }\n@@ -87,26 +95,28 @@ public int poll() {\n         // 判空处理\n         if (isEmpty())\n             throw new EmptyStackException();\n-        // 交换根结点与右下角（即最后一个）结点\n+        // 交换根结点与最右叶结点（即交换首元素与尾元素）\n         swap(0, size() - 1);\n         // 删除结点\n         int val = maxHeap.remove(size() - 1);\n         // 从顶至底堆化\n-        heapify(0);\n+        siftDown(0);\n         // 返回堆顶元素\n         return val;\n     }\n \n     /* 从结点 i 开始，从顶至底堆化 */\n-    private void heapify(int i) {\n+    private void siftDown(int i) {\n         while (true) {\n             // 判断结点 i, l, r 中值最大的结点，记为 ma ；\n             int l = left(i), r = right(i), ma = i;\n-            if (l < size() && maxHeap.get(l) > maxHeap.get(ma)) ma = l;\n-            if (r < size() && maxHeap.get(r) > maxHeap.get(ma)) ma = r;\n-            // 若结点 i 最大，则无需继续堆化，跳出\n+            if (l < size() && maxHeap.get(l) > maxHeap.get(ma))\n+                ma = l;\n+            if (r < size() && maxHeap.get(r) > maxHeap.get(ma))\n+                ma = r;\n+            // 若结点 i 最大或索引 l, r 越界，则无需继续堆化，跳出\n             if (ma == i) break;\n-            // 交换结点 i 与结点 max\n+            // 交换两结点\n             swap(i, ma);\n             // 循环向下堆化\n             i = ma;\n@@ -124,26 +134,24 @@ public void print() {\n \n public class my_heap {\n     public static void testPush(MaxHeap maxHeap, int val) {\n-        // 元素入堆\n-        maxHeap.push(val);\n-\n+        maxHeap.push(val);  // 元素入堆\n         System.out.format(\"\\n添加元素 %d 后\\n\", val);\n         maxHeap.print();\n     }\n \n     public static void testPoll(MaxHeap maxHeap) {\n-        // 元素出堆\n-        int val = maxHeap.poll();\n-\n+        int val = maxHeap.poll(); // 堆顶元素出堆\n         System.out.format(\"\\n出堆元素为 %d\\n\", val);\n         maxHeap.print();\n     }\n \n     public static void main(String[] args) {\n         /* 初始化堆 */\n-        // 初始化最大堆\n+        // 初始化大顶堆\n         MaxHeap maxHeap = new MaxHeap();\n \n+        System.out.println(\"\\n以下测试样例为大顶堆\");\n+\n         /* 元素入堆 */\n         testPush(maxHeap, 1);\n         testPush(maxHeap, 3);\n@@ -155,7 +163,7 @@ public static void main(String[] args) {\n         int peek = maxHeap.peek();\n         System.out.format(\"\\n堆顶元素为 %d\\n\", peek);\n \n-        /* 元素出堆 */\n+        /* 堆顶元素出堆 */\n         testPoll(maxHeap);\n         testPoll(maxHeap);\n \n@@ -166,5 +174,10 @@ public static void main(String[] args) {\n         /* 判断堆是否为空 */\n         boolean isEmpty = maxHeap.isEmpty();\n         System.out.format(\"\\n堆是否为空 %b\\n\", isEmpty);\n+\n+        /* 将输入列表堆化 */\n+        maxHeap = new MaxHeap(Arrays.asList(1, 3, 2, 5, 4));\n+        System.out.println(\"\\n输入 [1, 3, 2, 5, 4] ，建立大顶堆\");\n+        maxHeap.print();\n     }\n }",
    "output": "Add time complexity in stack, queue, deque. Update heap."
  },
  {
    "input": "diff --git a/codes/java/chapter_heap/my_heap.java b/codes/java/chapter_heap/my_heap.java\n--- a/codes/java/chapter_heap/my_heap.java\n+++ b/codes/java/chapter_heap/my_heap.java\n@@ -1,115 +0,0 @@\n-/**\n- * File: my_heap.java\n- * Created Time: 2023-01-07\n- * Author: Krahets (krahets@163.com)\n- */\n-\n-package chapter_heap;\n-\n-import include.*;\n-import java.util.*;\n-\n-class MaxHeap {\n-    private List<Integer> heap;\n-\n-    public MaxHeap() {\n-        heap = new ArrayList<>();\n-    }\n-\n-    public MaxHeap(List<Integer> nums) {\n-        // 将元素拷贝至堆中\n-        heap = new ArrayList<>(nums);\n-        // 堆化除叶结点外的其他所有结点\n-        for (int i = parent(size() - 1); i >= 0; i--) {\n-            heapify(i);\n-        }\n-    }\n-\n-    /* 获取左子结点 */\n-    private int left(int i) {\n-        return 2 * i + 1;\n-    }\n-\n-    /* 获取右子结点 */\n-    private int right(int i) {\n-        return 2 * i + 2;\n-    }\n-    \n-    /* 获取父结点 */\n-    private int parent(int i) {\n-        return (i - 1) / 2;\n-    }\n-\n-    /* 交换元素 */\n-    private void swap(int i, int j) {\n-        int tmp = heap.get(i);\n-        heap.set(i, j);\n-        heap.set(j, tmp);\n-    }\n-\n-    public int size() {\n-        return heap.size();\n-    }\n-\n-    public boolean isEmpty() {\n-        return size() == 0;\n-    }\n-\n-    /* 获取堆顶元素 */\n-    public int peek() {\n-        return heap.get(0);\n-    }\n-\n-    /* 元素入堆 */\n-    public void push(int val) {\n-        heap.add(val);\n-\n-        // 从底至顶堆化\n-        int i = size();\n-        while (true) {\n-            int p = parent(i);\n-            if (p < 0 || heap.get(i) > heap.get(p))\n-                break;\n-            swap(i, p);\n-            i = p;\n-        }\n-    }\n-\n-    /* 元素出堆 */\n-    public int poll() {\n-        // 判空处理\n-        if (isEmpty())\n-            throw new EmptyStackException();\n-        // 交换根结点与右下角（即最后一个）结点\n-        swap(0, size() - 1);\n-        // 删除结点\n-        int val = heap.remove(size() - 1);\n-        // 从顶至底堆化\n-        heapify(0);\n-        // 返回堆顶元素\n-        return val;\n-    }\n-\n-    /* 从结点 i 开始，从顶至底堆化 */\n-    private void heapify(int i) {\n-        while (true) {\n-            // 判断结点 i, l, r 中的最大结点，记为 ma ；\n-            int l = left(i), r = right(i), ma = i;\n-            if (heap.get(l) > heap.get(ma)) ma = l;\n-            if (heap.get(r) > heap.get(ma)) ma = r;\n-            // 若结点 i 最大，则无需继续堆化，跳出\n-            if (ma == i) break;\n-            // 交换结点 i 与结点 max\n-            swap(i, ma);\n-            // 循环向下堆化\n-            i = ma;\n-        }\n-    }\n-}\n-\n-\n-public class my_heap {\n-    public static void main(String[] args) {\n-\n-    }\n-}",
    "output": "Update .gitignore"
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_tree_dfs.java b/codes/java/chapter_tree/binary_tree_dfs.java\n--- a/codes/java/chapter_tree/binary_tree_dfs.java\n+++ b/codes/java/chapter_tree/binary_tree_dfs.java\n@@ -43,7 +43,7 @@ static void postOrder(TreeNode root) {\n     public static void main(String[] args) {\n         /* 初始化二叉树 */\n         // 这里借助了一个从数组直接生成二叉树的函数\n-        TreeNode root = TreeNode.arrToTree(new Integer[] { 1, null, 3, 4, 5 });\n+        TreeNode root = TreeNode.arrToTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7 });\n         System.out.println(\"\\n初始化二叉树\\n\");\n         PrintUtil.printTree(root);\n ",
    "output": "Fix the test case of the binary tree dfs in Java."
  },
  {
    "input": "diff --git a/codes/java/chapter_heap/my_heap.java b/codes/java/chapter_heap/my_heap.java\n--- a/codes/java/chapter_heap/my_heap.java\n+++ b/codes/java/chapter_heap/my_heap.java\n@@ -0,0 +1,115 @@\n+/**\n+ * File: my_heap.java\n+ * Created Time: 2023-01-07\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_heap;\n+\n+import include.*;\n+import java.util.*;\n+\n+class MaxHeap {\n+    private List<Integer> heap;\n+\n+    public MaxHeap() {\n+        heap = new ArrayList<>();\n+    }\n+\n+    public MaxHeap(List<Integer> nums) {\n+        // 将元素拷贝至堆中\n+        heap = new ArrayList<>(nums);\n+        // 堆化除叶结点外的其他所有结点\n+        for (int i = parent(size() - 1); i >= 0; i--) {\n+            heapify(i);\n+        }\n+    }\n+\n+    /* 获取左子结点 */\n+    private int left(int i) {\n+        return 2 * i + 1;\n+    }\n+\n+    /* 获取右子结点 */\n+    private int right(int i) {\n+        return 2 * i + 2;\n+    }\n+    \n+    /* 获取父结点 */\n+    private int parent(int i) {\n+        return (i - 1) / 2;\n+    }\n+\n+    /* 交换元素 */\n+    private void swap(int i, int j) {\n+        int tmp = heap.get(i);\n+        heap.set(i, j);\n+        heap.set(j, tmp);\n+    }\n+\n+    public int size() {\n+        return heap.size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    /* 获取堆顶元素 */\n+    public int peek() {\n+        return heap.get(0);\n+    }\n+\n+    /* 元素入堆 */\n+    public void push(int val) {\n+        heap.add(val);\n+\n+        // 从底至顶堆化\n+        int i = size();\n+        while (true) {\n+            int p = parent(i);\n+            if (p < 0 || heap.get(i) > heap.get(p))\n+                break;\n+            swap(i, p);\n+            i = p;\n+        }\n+    }\n+\n+    /* 元素出堆 */\n+    public int poll() {\n+        // 判空处理\n+        if (isEmpty())\n+            throw new EmptyStackException();\n+        // 交换根结点与右下角（即最后一个）结点\n+        swap(0, size() - 1);\n+        // 删除结点\n+        int val = heap.remove(size() - 1);\n+        // 从顶至底堆化\n+        heapify(0);\n+        // 返回堆顶元素\n+        return val;\n+    }\n+\n+    /* 从结点 i 开始，从顶至底堆化 */\n+    private void heapify(int i) {\n+        while (true) {\n+            // 判断结点 i, l, r 中的最大结点，记为 ma ；\n+            int l = left(i), r = right(i), ma = i;\n+            if (heap.get(l) > heap.get(ma)) ma = l;\n+            if (heap.get(r) > heap.get(ma)) ma = r;\n+            // 若结点 i 最大，则无需继续堆化，跳出\n+            if (ma == i) break;\n+            // 交换结点 i 与结点 max\n+            swap(i, ma);\n+            // 循环向下堆化\n+            i = ma;\n+        }\n+    }\n+}\n+\n+\n+public class my_heap {\n+    public static void main(String[] args) {\n+\n+    }\n+}\n\ndiff --git a/codes/java/chapter_tree/binary_tree_bfs.java b/codes/java/chapter_tree/binary_tree_bfs.java\n--- a/codes/java/chapter_tree/binary_tree_bfs.java\n+++ b/codes/java/chapter_tree/binary_tree_bfs.java\n@@ -30,8 +30,7 @@ static List<Integer> hierOrder(TreeNode root) {\n     public static void main(String[] args) {\n         /* 初始化二叉树 */\n         // 这里借助了一个从数组直接生成二叉树的函数\n-        TreeNode root = TreeNode.arrToTree(new Integer[] {\n-                1, 2, 3, 4, 5, 6, 7, null, null, null, null, null, null, null, null });\n+        TreeNode root = TreeNode.arrToTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7 });\n         System.out.println(\"\\n初始化二叉树\\n\");\n         PrintUtil.printTree(root);\n \n\ndiff --git a/codes/java/chapter_tree/binary_tree_dfs.java b/codes/java/chapter_tree/binary_tree_dfs.java\n--- a/codes/java/chapter_tree/binary_tree_dfs.java\n+++ b/codes/java/chapter_tree/binary_tree_dfs.java\n@@ -43,8 +43,7 @@ static void postOrder(TreeNode root) {\n     public static void main(String[] args) {\n         /* 初始化二叉树 */\n         // 这里借助了一个从数组直接生成二叉树的函数\n-        TreeNode root = TreeNode.arrToTree(new Integer[] { \n-            1, 2, 3, 4, 5, 6, 7, null, null, null, null, null, null, null, null});\n+        TreeNode root = TreeNode.arrToTree(new Integer[] { 1, null, 3, 4, 5 });\n         System.out.println(\"\\n初始化二叉树\\n\");\n         PrintUtil.printTree(root);\n \n\ndiff --git a/codes/java/include/PrintUtil.java b/codes/java/include/PrintUtil.java\n--- a/codes/java/include/PrintUtil.java\n+++ b/codes/java/include/PrintUtil.java\n@@ -8,6 +8,7 @@\n \n import java.util.*;\n \n+\n class Trunk {\n     Trunk prev;\n     String str;\n@@ -103,4 +104,11 @@ public static <K, V> void printHashMap(Map<K, V> map) {\n             System.out.println(kv.getKey() + \" -> \" + kv.getValue());\n         }\n     }\n+\n+    public static void printHeap(PriorityQueue<Integer> queue) {\n+        Integer[] nums = (Integer[])queue.toArray();\n+        TreeNode root = TreeNode.arrToTree(nums);\n+        \n+        printTree(root);\n+    }\n }\n\ndiff --git a/codes/java/include/TreeNode.java b/codes/java/include/TreeNode.java\n--- a/codes/java/include/TreeNode.java\n+++ b/codes/java/include/TreeNode.java\n@@ -22,7 +22,7 @@ public TreeNode(int x) {\n     }\n \n     /**\n-     * Generate a binary tree with an array\n+     * Generate a binary tree given an array\n      * @param arr\n      * @return\n      */\n@@ -32,19 +32,19 @@ public static TreeNode arrToTree(Integer[] arr) {\n         \n         TreeNode root = new TreeNode(arr[0]);\n         Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n-        int i = 1;\n+        int i = 0;\n         while(!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n+            if (++i >= arr.length) break;\n             if(arr[i] != null) {\n                 node.left = new TreeNode(arr[i]);\n                 queue.add(node.left);\n             }\n-            i++;\n+            if (++i >= arr.length) break;\n             if(arr[i] != null) {\n                 node.right = new TreeNode(arr[i]);\n                 queue.add(node.right);\n             }\n-            i++;\n         }\n         return root;\n     }\n@@ -71,20 +71,4 @@ public static List<Integer> treeToList(TreeNode root) {\n         }\n         return list;\n     }\n-    \n-    /**\n-     * Get a tree node with specific value in a binary tree\n-     * @param root\n-     * @param val\n-     * @return\n-     */\n-    public static TreeNode getTreeNode(TreeNode root, int val) {\n-        if (root == null)\n-            return null;\n-        if (root.val == val)\n-            return root;\n-        TreeNode left = getTreeNode(root.left, val);\n-        TreeNode right = getTreeNode(root.right, val);\n-        return left != null ? left : right;\n-    }\n }",
    "output": "Optimize arrToTree function\nin java, cpp, py, go, js, ts."
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/avl_tree.java b/codes/java/chapter_tree/avl_tree.java\n--- a/codes/java/chapter_tree/avl_tree.java\n+++ b/codes/java/chapter_tree/avl_tree.java\n@@ -138,7 +138,7 @@ else if (val > node.val)\n                     node = child;\n             } else {\n                 // 子结点数量 = 2 ，则将中序遍历的下个结点删除，并用该结点替换当前结点\n-                TreeNode temp = minNode(node.right);\n+                TreeNode temp = getInOrderNext(node.right);\n                 node.right = removeHelper(node.right, temp.val);\n                 node.val = temp.val;\n             }\n@@ -150,8 +150,8 @@ else if (val > node.val)\n         return node;\n     }\n \n-    /* 获取最小结点 */\n-    private TreeNode minNode(TreeNode node) {\n+    /* 获取中序遍历中的下一个结点（仅适用于 root 有左子结点的情况） */\n+    private TreeNode getInOrderNext(TreeNode node) {\n         if (node == null) return node;\n         // 循环访问左子结点，直到叶结点时为最小结点，跳出\n         while (node.left != null) {\n\ndiff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -101,7 +101,7 @@ public TreeNode remove(int num) {\n         // 子结点数量 = 2\n         else {\n             // 获取中序遍历中 cur 的下一个结点\n-            TreeNode nex = min(cur.right);\n+            TreeNode nex = getInOrderNext(cur.right);\n             int tmp = nex.val;\n             // 递归删除结点 nex\n             remove(nex.val);\n@@ -111,8 +111,8 @@ public TreeNode remove(int num) {\n         return cur;\n     }\n \n-    /* 获取最小结点 */\n-    public TreeNode min(TreeNode root) {\n+    /* 获取中序遍历中的下一个结点（仅适用于 root 有左子结点的情况） */\n+    public TreeNode getInOrderNext(TreeNode root) {\n         if (root == null) return root;\n         // 循环访问左子结点，直到叶结点时为最小结点，跳出\n         while (root.left != null) {",
    "output": "Free memory after removing\na node from a LinkedList or TreeNode."
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/array_queue.java b/codes/java/chapter_stack_and_queue/array_queue.java\n--- a/codes/java/chapter_stack_and_queue/array_queue.java\n+++ b/codes/java/chapter_stack_and_queue/array_queue.java\n@@ -63,13 +63,6 @@ public int peek() {\n         return nums[front];\n     }\n \n-    /* 访问索引 index 处元素 */\n-    int get(int index) {\n-        if (index >= size())\n-            throw new IndexOutOfBoundsException();\n-        return nums[(front + index) % capacity()];\n-    }\n-\n     /* 返回数组 */\n     public int[] toArray() {\n         int size = size();\n\ndiff --git a/codes/java/chapter_stack_and_queue/array_stack.java b/codes/java/chapter_stack_and_queue/array_stack.java\n--- a/codes/java/chapter_stack_and_queue/array_stack.java\n+++ b/codes/java/chapter_stack_and_queue/array_stack.java\n@@ -45,13 +45,6 @@ public int peek() {\n         return stack.get(size() - 1);\n     }\n \n-    /* 访问索引 index 处元素 */\n-    public int get(int index) {\n-        if (index >= size())\n-            throw new IndexOutOfBoundsException();\n-        return stack.get(index);\n-    }\n-\n     /* 将 List 转化为 Array 并返回 */\n     public Object[] toArray() {\n         return stack.toArray();\n@@ -75,10 +68,6 @@ public static void main(String[] args) {\n         int peek = stack.peek();\n         System.out.println(\"栈顶元素 peek = \" + peek);\n \n-        /* 访问索引 index 处元素 */\n-        int num = stack.get(3);\n-        System.out.println(\"栈索引 3 处的元素为 num = \" + num);\n-\n         /* 元素出栈 */\n         int pop = stack.pop();\n         System.out.println(\"出栈元素 pop = \" + pop + \"，出栈后 stack = \" + Arrays.toString(stack.toArray()));",
    "output": "Update the structure of the chapter\nof binary tree."
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/array_queue.java b/codes/java/chapter_stack_and_queue/array_queue.java\n--- a/codes/java/chapter_stack_and_queue/array_queue.java\n+++ b/codes/java/chapter_stack_and_queue/array_queue.java\n@@ -58,7 +58,6 @@ public int poll() {\n \n     /* 访问队首元素 */\n     public int peek() {\n-        // 删除头结点\n         if (isEmpty())\n             throw new EmptyStackException();\n         return nums[front];",
    "output": "Update the chapter of stack and queue."
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/array.java b/codes/java/chapter_array_and_linkedlist/array.java\n--- a/codes/java/chapter_array_and_linkedlist/array.java\n+++ b/codes/java/chapter_array_and_linkedlist/array.java\n@@ -35,7 +35,7 @@ static int[] extend(int[] nums, int enlarge) {\n     /* 在数组的索引 index 处插入元素 num */\n     static void insert(int[] nums, int num, int index) {\n         // 把索引 index 以及之后的所有元素向后移动一位\n-        for (int i = nums.length - 1; i >= index; i--) {\n+        for (int i = nums.length - 1; i > index; i--) {\n             nums[i] = nums[i - 1];\n         }\n         // 将 num 赋给 index 处元素\n\ndiff --git a/codes/java/chapter_stack_and_queue/array_stack.java b/codes/java/chapter_stack_and_queue/array_stack.java\n--- a/codes/java/chapter_stack_and_queue/array_stack.java\n+++ b/codes/java/chapter_stack_and_queue/array_stack.java\n@@ -33,16 +33,22 @@ public void push(int num) {\n \n     /* 出栈 */\n     public int pop() {\n+        if (isEmpty())\n+            throw new EmptyStackException();\n         return stack.remove(size() - 1);\n     }\n \n     /* 访问栈顶元素 */\n     public int peek() {\n+        if (isEmpty())\n+            throw new EmptyStackException();\n         return stack.get(size() - 1);\n     }\n \n     /* 访问索引 index 处元素 */\n     public int get(int index) {\n+        if (index >= size())\n+            throw new IndexOutOfBoundsException();\n         return stack.get(index);\n     }\n \n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_queue.java b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n@@ -57,7 +57,7 @@ public int poll() {\n     /* 访问队首元素 */\n     public int peek() {\n         if (size() == 0)\n-            throw new IndexOutOfBoundsException();\n+            throw new EmptyStackException();\n         return front.val;\n     }\n \n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_stack.java b/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n@@ -47,7 +47,7 @@ public int pop() {\n     /* 访问栈顶元素 */\n     public int peek() {\n         if (size() == 0)\n-            throw new IndexOutOfBoundsException();\n+            throw new EmptyStackException();\n         return stackPeek.val;\n     }\n ",
    "output": "Merge branch 'krahets:master' into typescript"
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/array_stack.java b/codes/java/chapter_stack_and_queue/array_stack.java\n--- a/codes/java/chapter_stack_and_queue/array_stack.java\n+++ b/codes/java/chapter_stack_and_queue/array_stack.java\n@@ -33,16 +33,22 @@ public void push(int num) {\n \n     /* 出栈 */\n     public int pop() {\n+        if (isEmpty())\n+            throw new EmptyStackException();\n         return stack.remove(size() - 1);\n     }\n \n     /* 访问栈顶元素 */\n     public int peek() {\n+        if (isEmpty())\n+            throw new EmptyStackException();\n         return stack.get(size() - 1);\n     }\n \n     /* 访问索引 index 处元素 */\n     public int get(int index) {\n+        if (index >= size())\n+            throw new IndexOutOfBoundsException();\n         return stack.get(index);\n     }\n \n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_queue.java b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n@@ -57,7 +57,7 @@ public int poll() {\n     /* 访问队首元素 */\n     public int peek() {\n         if (size() == 0)\n-            throw new IndexOutOfBoundsException();\n+            throw new EmptyStackException();\n         return front.val;\n     }\n \n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_stack.java b/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n@@ -47,7 +47,7 @@ public int pop() {\n     /* 访问栈顶元素 */\n     public int peek() {\n         if (size() == 0)\n-            throw new IndexOutOfBoundsException();\n+            throw new EmptyStackException();\n         return stackPeek.val;\n     }\n ",
    "output": "Merge pull request #133 from tao363/master\n\nUpdate array stack"
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/array_stack.java b/codes/java/chapter_stack_and_queue/array_stack.java\n--- a/codes/java/chapter_stack_and_queue/array_stack.java\n+++ b/codes/java/chapter_stack_and_queue/array_stack.java\n@@ -33,16 +33,22 @@ public void push(int num) {\n \n     /* 出栈 */\n     public int pop() {\n+        if (isEmpty())\n+            throw new EmptyStackException();\n         return stack.remove(size() - 1);\n     }\n \n     /* 访问栈顶元素 */\n     public int peek() {\n+        if (isEmpty())\n+            throw new EmptyStackException();\n         return stack.get(size() - 1);\n     }\n \n     /* 访问索引 index 处元素 */\n     public int get(int index) {\n+        if (index >= size())\n+            throw new IndexOutOfBoundsException();\n         return stack.get(index);\n     }\n \n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_queue.java b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n@@ -57,7 +57,7 @@ public int poll() {\n     /* 访问队首元素 */\n     public int peek() {\n         if (size() == 0)\n-            throw new IndexOutOfBoundsException();\n+            throw new EmptyStackException();\n         return front.val;\n     }\n \n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_stack.java b/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n@@ -47,7 +47,7 @@ public int pop() {\n     /* 访问栈顶元素 */\n     public int peek() {\n         if (size() == 0)\n-            throw new IndexOutOfBoundsException();\n+            throw new EmptyStackException();\n         return stackPeek.val;\n     }\n ",
    "output": "Update array stack."
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/array.java b/codes/java/chapter_array_and_linkedlist/array.java\n--- a/codes/java/chapter_array_and_linkedlist/array.java\n+++ b/codes/java/chapter_array_and_linkedlist/array.java\n@@ -35,7 +35,7 @@ static int[] extend(int[] nums, int enlarge) {\n     /* 在数组的索引 index 处插入元素 num */\n     static void insert(int[] nums, int num, int index) {\n         // 把索引 index 以及之后的所有元素向后移动一位\n-        for (int i = nums.length - 1; i >= index; i--) {\n+        for (int i = nums.length - 1; i > index; i--) {\n             nums[i] = nums[i - 1];\n         }\n         // 将 num 赋给 index 处元素",
    "output": "Merge pull request #135 from Javesun99/patch-1\n\nUpdate array.md"
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/array.java b/codes/java/chapter_array_and_linkedlist/array.java\n--- a/codes/java/chapter_array_and_linkedlist/array.java\n+++ b/codes/java/chapter_array_and_linkedlist/array.java\n@@ -35,7 +35,7 @@ static int[] extend(int[] nums, int enlarge) {\n     /* 在数组的索引 index 处插入元素 num */\n     static void insert(int[] nums, int num, int index) {\n         // 把索引 index 以及之后的所有元素向后移动一位\n-        for (int i = nums.length - 1; i >= index; i--) {\n+        for (int i = nums.length - 1; i > index; i--) {\n             nums[i] = nums[i - 1];\n         }\n         // 将 num 赋给 index 处元素",
    "output": "Update source codes."
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/space_complexity.java b/codes/java/chapter_computational_complexity/space_complexity.java\n--- a/codes/java/chapter_computational_complexity/space_complexity.java\n+++ b/codes/java/chapter_computational_complexity/space_complexity.java\n@@ -1,5 +1,5 @@\n /*\n- * File: space_complexity_types.java\n+ * File: space_complexity.java\n  * Created Time: 2022-11-25\n  * Author: Krahets (krahets@163.com)\n  */\n@@ -9,7 +9,7 @@\n import include.*;\n import java.util.*;\n \n-public class space_complexity_types {\n+public class space_complexity {\n     /* 函数 */\n     static int function() {\n         // do something\n\ndiff --git a/codes/java/chapter_computational_complexity/time_complexity.java b/codes/java/chapter_computational_complexity/time_complexity.java\n--- a/codes/java/chapter_computational_complexity/time_complexity.java\n+++ b/codes/java/chapter_computational_complexity/time_complexity.java\n@@ -1,12 +1,12 @@\n /*\n- * File: time_complexity_types.java\n+ * File: time_complexity.java\n  * Created Time: 2022-11-25\n  * Author: Krahets (krahets@163.com)\n  */\n \n package chapter_computational_complexity;\n \n-public class time_complexity_types {\n+public class time_complexity {\n     /* 常数阶 */\n     static int constant(int n) {\n         int count = 0;",
    "output": "Update time complexity and space complexity."
  },
  {
    "input": "diff --git a/codes/java/include/TreeNode.java b/codes/java/include/TreeNode.java\n--- a/codes/java/include/TreeNode.java\n+++ b/codes/java/include/TreeNode.java\n@@ -13,6 +13,7 @@\n  */\n public class TreeNode {\n     public int val;\n+    public int height;\n     public TreeNode left;\n     public TreeNode right;\n ",
    "output": "Rewrite the article, and code. Create figures."
  },
  {
    "input": "diff --git a/codes/java/chapter_hashing/array_hash_map.java b/codes/java/chapter_hashing/array_hash_map.java\n--- a/codes/java/chapter_hashing/array_hash_map.java\n+++ b/codes/java/chapter_hashing/array_hash_map.java\n@@ -22,15 +22,15 @@ class ArrayHashMap {\n     private List<Entry> bucket;\n     public ArrayHashMap() {\n         // 初始化一个长度为 10 的桶（数组）\n-        bucket = new ArrayList<>(10);\n-        for (int i = 0; i < 10; i++) {\n+        bucket = new ArrayList<>();\n+        for (int i = 0; i < 100; i++) {\n             bucket.add(null);\n         }\n     }\n \n     /* 哈希函数 */\n     private int hashFunc(int key) {\n-        int index = key % 10000;\n+        int index = key % 100;\n         return index;\n     }\n \n@@ -102,23 +102,23 @@ public static void main(String[] args) {\n \n         /* 添加操作 */\n         // 在哈希表中添加键值对 (key, value)\n-        map.put(10001, \"小哈\");   \n-        map.put(10002, \"小啰\");   \n-        map.put(10003, \"小算\");   \n-        map.put(10004, \"小法\");\n-        map.put(10005, \"小哇\");\n+        map.put(12836, \"小哈\");   \n+        map.put(15937, \"小啰\");   \n+        map.put(16750, \"小算\");   \n+        map.put(13276, \"小法\");\n+        map.put(10583, \"小鸭\");\n         System.out.println(\"\\n添加完成后，哈希表为\\nKey -> Value\");\n         map.print();\n \n         /* 查询操作 */\n         // 向哈希表输入键 key ，得到值 value\n-        String name = map.get(10002);\n-        System.out.println(\"\\n输入学号 10002 ，查询到姓名 \" + name);\n+        String name = map.get(15937);\n+        System.out.println(\"\\n输入学号 15937 ，查询到姓名 \" + name);\n \n         /* 删除操作 */\n         // 在哈希表中删除键值对 (key, value)\n-        map.remove(10005);\n-        System.out.println(\"\\n删除 10005 后，哈希表为\\nKey -> Value\");\n+        map.remove(10583);\n+        System.out.println(\"\\n删除 10583 后，哈希表为\\nKey -> Value\");\n         map.print();\n \n         /* 遍历哈希表 */\n\ndiff --git a/codes/java/chapter_hashing/hash_map.java b/codes/java/chapter_hashing/hash_map.java\n--- a/codes/java/chapter_hashing/hash_map.java\n+++ b/codes/java/chapter_hashing/hash_map.java\n@@ -15,23 +15,23 @@ public static void main(String[] args) {\n \n         /* 添加操作 */\n         // 在哈希表中添加键值对 (key, value)\n-        map.put(10001, \"小哈\");   \n-        map.put(10002, \"小啰\");   \n-        map.put(10003, \"小算\");   \n-        map.put(10004, \"小法\");\n-        map.put(10005, \"小哇\");\n+        map.put(12836, \"小哈\");   \n+        map.put(15937, \"小啰\");   \n+        map.put(16750, \"小算\");   \n+        map.put(13276, \"小法\");\n+        map.put(10583, \"小鸭\");\n         System.out.println(\"\\n添加完成后，哈希表为\\nKey -> Value\");\n         PrintUtil.printHashMap(map);\n \n         /* 查询操作 */\n         // 向哈希表输入键 key ，得到值 value\n-        String name = map.get(10002);\n-        System.out.println(\"\\n输入学号 10002 ，查询到姓名 \" + name);\n+        String name = map.get(15937);\n+        System.out.println(\"\\n输入学号 15937 ，查询到姓名 \" + name);\n \n         /* 删除操作 */\n         // 在哈希表中删除键值对 (key, value)\n-        map.remove(10005);\n-        System.out.println(\"\\n删除 10005 后，哈希表为\\nKey -> Value\");\n+        map.remove(10583);\n+        System.out.println(\"\\n删除 10583 后，哈希表为\\nKey -> Value\");\n         PrintUtil.printHashMap(map);\n \n         /* 遍历哈希表 */",
    "output": "Update the chapter of hashing."
  },
  {
    "input": "diff --git a/codes/java/chapter_hashing/array_hash_map.java b/codes/java/chapter_hashing/array_hash_map.java\n--- a/codes/java/chapter_hashing/array_hash_map.java\n+++ b/codes/java/chapter_hashing/array_hash_map.java\n@@ -0,0 +1,138 @@\n+/*\n+ * File: hash_map.java\n+ * Created Time: 2022-12-04\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_hashing;\n+import java.util.*;\n+\n+/* 键值对 int->String */\n+class Entry {\n+    public int key;\n+    public String val;\n+    public Entry(int key, String val) {\n+        this.key = key;\n+        this.val = val;\n+    }\n+}\n+\n+/* 基于数组简易实现的哈希表 */\n+class ArrayHashMap {\n+    private List<Entry> bucket;\n+    public ArrayHashMap() {\n+        // 初始化一个长度为 10 的桶（数组）\n+        bucket = new ArrayList<>(10);\n+        for (int i = 0; i < 10; i++) {\n+            bucket.add(null);\n+        }\n+    }\n+\n+    /* 哈希函数 */\n+    private int hashFunc(int key) {\n+        int index = key % 10000;\n+        return index;\n+    }\n+\n+    /* 查询操作 */\n+    public String get(int key) {\n+        int index = hashFunc(key);\n+        Entry pair = bucket.get(index);\n+        if (pair == null) return null;\n+        return pair.val;\n+    }\n+\n+    /* 添加操作 */\n+    public void put(int key, String val) {\n+        Entry pair = new Entry(key, val);\n+        int index = hashFunc(key);\n+        bucket.set(index, pair);\n+    }\n+\n+    /* 删除操作 */\n+    public void remove(int key) {\n+        int index = hashFunc(key);\n+        // 置为空字符，代表删除\n+        bucket.set(index, null);\n+    }\n+\n+    /* 获取所有键值对 */\n+    public List<Entry> entrySet() {\n+        List<Entry> entrySet = new ArrayList<>();\n+        for (Entry pair : bucket) {\n+            if (pair != null)\n+                entrySet.add(pair);\n+        }\n+        return entrySet;\n+    }\n+\n+    /* 获取所有键 */\n+    public List<Integer> keySet() {\n+        List<Integer> keySet = new ArrayList<>();\n+        for (Entry pair : bucket) {\n+            if (pair != null)\n+                keySet.add(pair.key);\n+        }\n+        return keySet;\n+    }\n+\n+    /* 获取所有值 */\n+    public List<String> valueSet() {\n+        List<String> valueSet = new ArrayList<>();\n+        for (Entry pair : bucket) {\n+            if (pair != null)\n+                valueSet.add(pair.val);\n+        }\n+        return valueSet;\n+    }\n+\n+    /* 打印哈希表 */\n+    public void print() {\n+        for (Entry kv: entrySet()) {\n+            System.out.println(kv.key + \" -> \" + kv.val);\n+        }\n+    }\n+}\n+\n+\n+public class array_hash_map {\n+    public static void main(String[] args) {\n+        /* 初始化哈希表 */\n+        ArrayHashMap map = new ArrayHashMap();\n+\n+        /* 添加操作 */\n+        // 在哈希表中添加键值对 (key, value)\n+        map.put(10001, \"小哈\");   \n+        map.put(10002, \"小啰\");   \n+        map.put(10003, \"小算\");   \n+        map.put(10004, \"小法\");\n+        map.put(10005, \"小哇\");\n+        System.out.println(\"\\n添加完成后，哈希表为\\nKey -> Value\");\n+        map.print();\n+\n+        /* 查询操作 */\n+        // 向哈希表输入键 key ，得到值 value\n+        String name = map.get(10002);\n+        System.out.println(\"\\n输入学号 10002 ，查询到姓名 \" + name);\n+\n+        /* 删除操作 */\n+        // 在哈希表中删除键值对 (key, value)\n+        map.remove(10005);\n+        System.out.println(\"\\n删除 10005 后，哈希表为\\nKey -> Value\");\n+        map.print();\n+\n+        /* 遍历哈希表 */\n+        System.out.println(\"\\n遍历键值对 Key->Value\");\n+        for (Entry kv: map.entrySet()) {\n+            System.out.println(kv.key + \" -> \" + kv.val);\n+        }\n+        System.out.println(\"\\n单独遍历键 Key\");\n+        for (int key: map.keySet()) {\n+            System.out.println(key);\n+        }\n+        System.out.println(\"\\n单独遍历值 Value\");\n+        for (String val: map.valueSet()) {\n+            System.out.println(val);\n+        }\n+    }\n+}\n\ndiff --git a/codes/java/chapter_hashing/hash_map.java b/codes/java/chapter_hashing/hash_map.java\n--- a/codes/java/chapter_hashing/hash_map.java\n+++ b/codes/java/chapter_hashing/hash_map.java\n@@ -0,0 +1,51 @@\n+/*\n+ * File: hash_map.java\n+ * Created Time: 2022-12-04\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_hashing;\n+import java.util.*;\n+import include.*;\n+\n+public class hash_map {\n+    public static void main(String[] args) {\n+        /* 初始化哈希表 */\n+        Map<Integer, String> map = new HashMap<>();\n+\n+        /* 添加操作 */\n+        // 在哈希表中添加键值对 (key, value)\n+        map.put(10001, \"小哈\");   \n+        map.put(10002, \"小啰\");   \n+        map.put(10003, \"小算\");   \n+        map.put(10004, \"小法\");\n+        map.put(10005, \"小哇\");\n+        System.out.println(\"\\n添加完成后，哈希表为\\nKey -> Value\");\n+        PrintUtil.printHashMap(map);\n+\n+        /* 查询操作 */\n+        // 向哈希表输入键 key ，得到值 value\n+        String name = map.get(10002);\n+        System.out.println(\"\\n输入学号 10002 ，查询到姓名 \" + name);\n+\n+        /* 删除操作 */\n+        // 在哈希表中删除键值对 (key, value)\n+        map.remove(10005);\n+        System.out.println(\"\\n删除 10005 后，哈希表为\\nKey -> Value\");\n+        PrintUtil.printHashMap(map);\n+\n+        /* 遍历哈希表 */\n+        System.out.println(\"\\n遍历键值对 Key->Value\");\n+        for (Map.Entry <Integer, String> kv: map.entrySet()) {\n+            System.out.println(kv.getKey() + \" -> \" + kv.getValue());\n+        }\n+        System.out.println(\"\\n单独遍历键 Key\");\n+        for (int key: map.keySet()) {\n+            System.out.println(key);\n+        }\n+        System.out.println(\"\\n单独遍历值 Value\");\n+        for (String val: map.values()) {\n+            System.out.println(val);\n+        }\n+    }\n+}\n\ndiff --git a/codes/java/include/PrintUtil.java b/codes/java/include/PrintUtil.java\n--- a/codes/java/include/PrintUtil.java\n+++ b/codes/java/include/PrintUtil.java\n@@ -91,4 +91,16 @@ public static void showTrunks(Trunk p) {\n         showTrunks(p.prev);\n         System.out.print(p.str);\n     }\n+\n+    /**\n+     * Print a hash map\n+     * @param <K>\n+     * @param <V>\n+     * @param map\n+     */\n+    public static <K, V> void printHashMap(Map<K, V> map) {\n+        for (Map.Entry <K, V> kv: map.entrySet()) {\n+            System.out.println(kv.getKey() + \" -> \" + kv.getValue());\n+        }\n+    }\n }",
    "output": "Merge branch 'krahets:master' into master"
  },
  {
    "input": "diff --git a/codes/java/chapter_hashing/array_hash_map.java b/codes/java/chapter_hashing/array_hash_map.java\n--- a/codes/java/chapter_hashing/array_hash_map.java\n+++ b/codes/java/chapter_hashing/array_hash_map.java\n@@ -0,0 +1,138 @@\n+/*\n+ * File: hash_map.java\n+ * Created Time: 2022-12-04\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_hashing;\n+import java.util.*;\n+\n+/* 键值对 int->String */\n+class Entry {\n+    public int key;\n+    public String val;\n+    public Entry(int key, String val) {\n+        this.key = key;\n+        this.val = val;\n+    }\n+}\n+\n+/* 基于数组简易实现的哈希表 */\n+class ArrayHashMap {\n+    private List<Entry> bucket;\n+    public ArrayHashMap() {\n+        // 初始化一个长度为 10 的桶（数组）\n+        bucket = new ArrayList<>(10);\n+        for (int i = 0; i < 10; i++) {\n+            bucket.add(null);\n+        }\n+    }\n+\n+    /* 哈希函数 */\n+    private int hashFunc(int key) {\n+        int index = key % 10000;\n+        return index;\n+    }\n+\n+    /* 查询操作 */\n+    public String get(int key) {\n+        int index = hashFunc(key);\n+        Entry pair = bucket.get(index);\n+        if (pair == null) return null;\n+        return pair.val;\n+    }\n+\n+    /* 添加操作 */\n+    public void put(int key, String val) {\n+        Entry pair = new Entry(key, val);\n+        int index = hashFunc(key);\n+        bucket.set(index, pair);\n+    }\n+\n+    /* 删除操作 */\n+    public void remove(int key) {\n+        int index = hashFunc(key);\n+        // 置为空字符，代表删除\n+        bucket.set(index, null);\n+    }\n+\n+    /* 获取所有键值对 */\n+    public List<Entry> entrySet() {\n+        List<Entry> entrySet = new ArrayList<>();\n+        for (Entry pair : bucket) {\n+            if (pair != null)\n+                entrySet.add(pair);\n+        }\n+        return entrySet;\n+    }\n+\n+    /* 获取所有键 */\n+    public List<Integer> keySet() {\n+        List<Integer> keySet = new ArrayList<>();\n+        for (Entry pair : bucket) {\n+            if (pair != null)\n+                keySet.add(pair.key);\n+        }\n+        return keySet;\n+    }\n+\n+    /* 获取所有值 */\n+    public List<String> valueSet() {\n+        List<String> valueSet = new ArrayList<>();\n+        for (Entry pair : bucket) {\n+            if (pair != null)\n+                valueSet.add(pair.val);\n+        }\n+        return valueSet;\n+    }\n+\n+    /* 打印哈希表 */\n+    public void print() {\n+        for (Entry kv: entrySet()) {\n+            System.out.println(kv.key + \" -> \" + kv.val);\n+        }\n+    }\n+}\n+\n+\n+public class array_hash_map {\n+    public static void main(String[] args) {\n+        /* 初始化哈希表 */\n+        ArrayHashMap map = new ArrayHashMap();\n+\n+        /* 添加操作 */\n+        // 在哈希表中添加键值对 (key, value)\n+        map.put(10001, \"小哈\");   \n+        map.put(10002, \"小啰\");   \n+        map.put(10003, \"小算\");   \n+        map.put(10004, \"小法\");\n+        map.put(10005, \"小哇\");\n+        System.out.println(\"\\n添加完成后，哈希表为\\nKey -> Value\");\n+        map.print();\n+\n+        /* 查询操作 */\n+        // 向哈希表输入键 key ，得到值 value\n+        String name = map.get(10002);\n+        System.out.println(\"\\n输入学号 10002 ，查询到姓名 \" + name);\n+\n+        /* 删除操作 */\n+        // 在哈希表中删除键值对 (key, value)\n+        map.remove(10005);\n+        System.out.println(\"\\n删除 10005 后，哈希表为\\nKey -> Value\");\n+        map.print();\n+\n+        /* 遍历哈希表 */\n+        System.out.println(\"\\n遍历键值对 Key->Value\");\n+        for (Entry kv: map.entrySet()) {\n+            System.out.println(kv.key + \" -> \" + kv.val);\n+        }\n+        System.out.println(\"\\n单独遍历键 Key\");\n+        for (int key: map.keySet()) {\n+            System.out.println(key);\n+        }\n+        System.out.println(\"\\n单独遍历值 Value\");\n+        for (String val: map.valueSet()) {\n+            System.out.println(val);\n+        }\n+    }\n+}\n\ndiff --git a/codes/java/chapter_hashing/hash_map.java b/codes/java/chapter_hashing/hash_map.java\n--- a/codes/java/chapter_hashing/hash_map.java\n+++ b/codes/java/chapter_hashing/hash_map.java\n@@ -0,0 +1,51 @@\n+/*\n+ * File: hash_map.java\n+ * Created Time: 2022-12-04\n+ * Author: Krahets (krahets@163.com)\n+ */\n+\n+package chapter_hashing;\n+import java.util.*;\n+import include.*;\n+\n+public class hash_map {\n+    public static void main(String[] args) {\n+        /* 初始化哈希表 */\n+        Map<Integer, String> map = new HashMap<>();\n+\n+        /* 添加操作 */\n+        // 在哈希表中添加键值对 (key, value)\n+        map.put(10001, \"小哈\");   \n+        map.put(10002, \"小啰\");   \n+        map.put(10003, \"小算\");   \n+        map.put(10004, \"小法\");\n+        map.put(10005, \"小哇\");\n+        System.out.println(\"\\n添加完成后，哈希表为\\nKey -> Value\");\n+        PrintUtil.printHashMap(map);\n+\n+        /* 查询操作 */\n+        // 向哈希表输入键 key ，得到值 value\n+        String name = map.get(10002);\n+        System.out.println(\"\\n输入学号 10002 ，查询到姓名 \" + name);\n+\n+        /* 删除操作 */\n+        // 在哈希表中删除键值对 (key, value)\n+        map.remove(10005);\n+        System.out.println(\"\\n删除 10005 后，哈希表为\\nKey -> Value\");\n+        PrintUtil.printHashMap(map);\n+\n+        /* 遍历哈希表 */\n+        System.out.println(\"\\n遍历键值对 Key->Value\");\n+        for (Map.Entry <Integer, String> kv: map.entrySet()) {\n+            System.out.println(kv.getKey() + \" -> \" + kv.getValue());\n+        }\n+        System.out.println(\"\\n单独遍历键 Key\");\n+        for (int key: map.keySet()) {\n+            System.out.println(key);\n+        }\n+        System.out.println(\"\\n单独遍历值 Value\");\n+        for (String val: map.values()) {\n+            System.out.println(val);\n+        }\n+    }\n+}\n\ndiff --git a/codes/java/include/PrintUtil.java b/codes/java/include/PrintUtil.java\n--- a/codes/java/include/PrintUtil.java\n+++ b/codes/java/include/PrintUtil.java\n@@ -91,4 +91,16 @@ public static void showTrunks(Trunk p) {\n         showTrunks(p.prev);\n         System.out.print(p.str);\n     }\n+\n+    /**\n+     * Print a hash map\n+     * @param <K>\n+     * @param <V>\n+     * @param map\n+     */\n+    public static <K, V> void printHashMap(Map<K, V> map) {\n+        for (Map.Entry <K, V> kv: map.entrySet()) {\n+            System.out.println(kv.getKey() + \" -> \" + kv.getValue());\n+        }\n+    }\n }",
    "output": "Add the chapter of hash map."
  },
  {
    "input": "diff --git a/codes/java/include/TreeNode.java b/codes/java/include/TreeNode.java\n--- a/codes/java/include/TreeNode.java\n+++ b/codes/java/include/TreeNode.java\n@@ -26,6 +26,9 @@ public TreeNode(int x) {\n      * @return\n      */\n     public static TreeNode arrToTree(Integer[] arr) {\n+        if (arr.length == 0)\n+            return null;\n+        \n         TreeNode root = new TreeNode(arr[0]);\n         Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};\n         int i = 1;",
    "output": "Fix the util of array to tree."
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/my_list.java b/codes/java/chapter_array_and_linkedlist/my_list.java\n--- a/codes/java/chapter_array_and_linkedlist/my_list.java\n+++ b/codes/java/chapter_array_and_linkedlist/my_list.java\n@@ -56,13 +56,13 @@ public void add(int num) {\n     }\n \n     /* 中间插入元素 */\n-    public void add(int index, int num) {\n+    public void insert(int index, int num) {\n         if (index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         // 元素数量超出容量时，触发扩容机制\n         if (size == capacity())\n             extendCapacity();\n-        // 索引 i 以及之后的元素都向后移动一位\n+        // 将索引 index 以及之后的元素都向后移动一位\n         for (int j = size - 1; j >= index; j--) {\n             nums[j + 1] = nums[j];\n         }\n@@ -72,15 +72,18 @@ public void add(int index, int num) {\n     }\n \n     /* 删除元素 */\n-    public void remove(int index) {\n+    public int remove(int index) {\n         if (index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n-        // 索引 i 之后的元素都向前移动一位\n+        int num = nums[index];\n+        // 将索引 index 之后的元素都向前移动一位\n         for (int j = index; j < size - 1; j++) {\n             nums[j] = nums[j + 1];\n         }\n         // 更新元素数量\n         size--;\n+        // 返回被删除元素\n+        return num;\n     }\n \n     /* 列表扩容 */\n@@ -118,7 +121,7 @@ public static void main(String[] args) {\n                            \" ，容量 = \" + list.capacity() + \" ，长度 = \" + list.size());\n \n         /* 中间插入元素 */\n-        list.add(3, 6);\n+        list.insert(3, 6);\n         System.out.println(\"在索引 3 处插入数字 6 ，得到 list = \" + Arrays.toString(list.toArray()));\n \n         /* 删除元素 */\n\ndiff --git a/codes/java/chapter_stack_and_queue/array_queue.java b/codes/java/chapter_stack_and_queue/array_queue.java\n--- a/codes/java/chapter_stack_and_queue/array_queue.java\n+++ b/codes/java/chapter_stack_and_queue/array_queue.java\n@@ -50,11 +50,8 @@ public void offer(int num) {\n \n     /* 出队 */\n     public int poll() {\n-        // 删除头结点\n-        if (isEmpty())\n-            throw new EmptyStackException();\n-        int num = nums[front];\n-        // 队头指针向后移动，越过尾部后返回到数组头部\n+        int num = peek();\n+        // 队头指针向后移动一位，若越过尾部则返回到数组头部\n         front = (front + 1) % capacity();\n         return num;\n     }",
    "output": "Add python code of chapter queue to docs."
  },
  {
    "input": "diff --git a/codes/java/chapter_stack_and_queue/array_queue.java b/codes/java/chapter_stack_and_queue/array_queue.java\n--- a/codes/java/chapter_stack_and_queue/array_queue.java\n+++ b/codes/java/chapter_stack_and_queue/array_queue.java\n@@ -67,15 +67,23 @@ public int peek() {\n         return nums[front];\n     }\n \n+    /* 访问索引 index 处元素 */\n+    int get(int index) {\n+        if (index >= size())\n+            throw new IndexOutOfBoundsException();\n+        return nums[(front + index) % capacity()];\n+    }\n+\n+    /* 返回数组 */\n     public int[] toArray() {\n         int size = size();\n         int capacity = capacity();\n         // 仅转换有效长度范围内的列表元素\n-        int[] arr = new int[size];\n+        int[] res = new int[size];\n         for (int i = 0, j = front; i < size; i++, j++) {\n-            arr[i] = nums[j % capacity];\n+            res[i] = nums[j % capacity];\n         }\n-        return arr;\n+        return res;\n     }\n }\n \n\ndiff --git a/codes/java/chapter_stack_and_queue/array_stack.java b/codes/java/chapter_stack_and_queue/array_stack.java\n--- a/codes/java/chapter_stack_and_queue/array_stack.java\n+++ b/codes/java/chapter_stack_and_queue/array_stack.java\n@@ -69,6 +69,10 @@ public static void main(String[] args) {\n         int peek = stack.peek();\n         System.out.println(\"栈顶元素 peek = \" + peek);\n \n+        /* 访问索引 index 处元素 */\n+        int num = stack.get(3);\n+        System.out.println(\"栈索引 3 处的元素为 num = \" + num);\n+\n         /* 元素出栈 */\n         int pop = stack.pop();\n         System.out.println(\"出栈元素 pop = \" + pop + \"，出栈后 stack = \" + Arrays.toString(stack.toArray()));\n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_queue.java b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_queue.java\n@@ -7,46 +7,69 @@\n package chapter_stack_and_queue;\n \n import java.util.*;\n+import include.*;\n \n /* 基于链表实现的队列 */\n class LinkedListQueue {\n-    LinkedList<Integer> list;\n+    private ListNode front, rear;  // 头结点 front ，尾结点 rear \n+    private int queSize = 0;\n \n     public LinkedListQueue() {\n-        // 初始化链表\n-        list = new LinkedList<>();\n+        front = null;\n+        rear = null;\n     }\n \n     /* 获取队列的长度 */\n     public int size() {\n-        return list.size();\n+        return queSize;\n     }\n \n     /* 判断队列是否为空 */\n     public boolean isEmpty() {\n-        return list.size() == 0;\n+        return size() == 0;\n     }\n \n     /* 入队 */\n     public void offer(int num) {\n         // 尾结点后添加 num\n-        list.addLast(num);\n+        ListNode node = new ListNode(num);\n+        // 如果队列为空，则令头、尾结点都指向该结点\n+        if (front == null) {\n+            front = node;\n+            rear = node;\n+        // 如果队列不为空，则将该结点添加到尾结点后\n+        } else {\n+            rear.next = node;\n+            rear = node;\n+        }\n+        queSize++;\n     }\n \n     /* 出队 */\n     public int poll() {\n+        int num = peek();\n         // 删除头结点\n-        return list.removeFirst();\n+        front = front.next;\n+        queSize--;\n+        return num;\n     }\n \n     /* 访问队首元素 */\n     public int peek() {\n-        return list.getFirst();\n+        if (size() == 0)\n+            throw new IndexOutOfBoundsException();\n+        return front.val;\n     }\n \n-    /* 将 List 转化为 Array 并返回 */\n-    public Object[] toArray() {\n-        return list.toArray();\n+    /* 将链表转化为 Array 并返回 */\n+    public int[] toArray() {\n+        ListNode node = front;\n+        int[] res = new int[size()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = node.val;\n+            node = node.next;\n+        }\n+        return res;\n     }\n }\n \n\ndiff --git a/codes/java/chapter_stack_and_queue/linkedlist_stack.java b/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n--- a/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n+++ b/codes/java/chapter_stack_and_queue/linkedlist_stack.java\n@@ -12,15 +12,15 @@\n /* 基于链表实现的栈 */\n class LinkedListStack {\n     private ListNode stackPeek;  // 将头结点作为栈顶\n-    private int stackSize = 0;   // 栈的长度\n+    private int stkSize = 0;   // 栈的长度\n     \n     public LinkedListStack() {\n         stackPeek = null;\n     }\n \n     /* 获取栈的长度 */\n     public int size() {\n-        return stackSize;\n+        return stkSize;\n     }\n \n     /* 判断栈是否为空 */\n@@ -33,16 +33,14 @@ public void push(int num) {\n         ListNode node = new ListNode(num);\n         node.next = stackPeek;\n         stackPeek = node;\n-        stackSize++;\n+        stkSize++;\n     }\n \n     /* 出栈 */\n     public int pop() {\n-        if (size() == 0)\n-            throw new IndexOutOfBoundsException();\n         int num = peek();\n         stackPeek = stackPeek.next;\n-        stackSize--;\n+        stkSize--;\n         return num;\n     }\n ",
    "output": "update stack and queue."
  },
  {
    "input": "diff --git a/codes/java/chapter_array_and_linkedlist/my_list.java b/codes/java/chapter_array_and_linkedlist/my_list.java\n--- a/codes/java/chapter_array_and_linkedlist/my_list.java\n+++ b/codes/java/chapter_array_and_linkedlist/my_list.java\n@@ -10,14 +10,14 @@\n \n /* 列表类简易实现 */\n class MyList {\n-    int[] nums;               // 数组（存储列表元素）\n-    int initialCapacity = 10; // 列表初始容量\n-    int size = 0;             // 列表长度（即当前元素数量）\n-    int extendRatio = 2;      // 每次列表扩容的倍数\n+    private int[] nums;           // 数组（存储列表元素）\n+    private int capacity = 10;    // 列表容量\n+    private int size = 0;         // 列表长度（即当前元素数量）\n+    private int extendRatio = 2;  // 每次列表扩容的倍数\n \n     /* 构造函数 */\n     public MyList() {\n-        nums = new int[initialCapacity];\n+        nums = new int[capacity];\n     }\n \n     /* 获取列表长度（即当前元素数量）*/\n@@ -27,7 +27,7 @@ public int size() {\n \n     /* 获取列表容量 */\n     public int capacity() {\n-        return nums.length;\n+        return capacity;\n     }\n \n     /* 访问元素 */\n@@ -48,7 +48,7 @@ public void set(int index, int num) {\n     /* 尾部添加元素 */\n     public void add(int num) {\n         // 元素数量超出容量时，触发扩容机制\n-        if (size == nums.length)\n+        if (size == capacity())\n             extendCapacity();\n         nums[size] = num;\n         // 更新元素数量\n@@ -60,7 +60,7 @@ public void add(int index, int num) {\n         if (index >= size)\n             throw new IndexOutOfBoundsException(\"索引越界\");\n         // 元素数量超出容量时，触发扩容机制\n-        if (size == nums.length)\n+        if (size == capacity())\n             extendCapacity();\n         // 索引 i 以及之后的元素都向后移动一位\n         for (int j = size - 1; j >= index; j--) {\n@@ -86,7 +86,9 @@ public void remove(int index) {\n     /* 列表扩容 */\n     public void extendCapacity() {\n         // 新建一个长度为 size 的数组，并将原数组拷贝到新数组\n-        nums = Arrays.copyOf(nums, nums.length * extendRatio);\n+        nums = Arrays.copyOf(nums, capacity() * extendRatio);\n+        // 更新列表容量\n+        capacity = nums.length;\n     }\n \n     /* 将列表转换为数组 */",
    "output": "Add C++ codes for the chapter\narray and linked list."
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/leetcode_two_sum.java b/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n--- a/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n+++ b/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n@@ -48,10 +48,10 @@ public static void main(String[] args) {\n         // 方法一\n         SolutionBruteForce slt1 = new SolutionBruteForce();\n         int[] res = slt1.twoSum(nums, target);\n-        System.out.println(Arrays.toString(res));\n+        System.out.println(\"方法一 res = \" + Arrays.toString(res));\n         // 方法二\n         SolutionHashMap slt2 = new SolutionHashMap();\n         res = slt2.twoSum(nums, target);\n-        System.out.println(Arrays.toString(res));\n+        System.out.println(\"方法二 res = \" + Arrays.toString(res));\n     }\n }",
    "output": "1. Add C++ codes for the chapter of\ncomputational complexity, sorting, searching.\n2. Corrected some mistakes.\n3. Update README."
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/leetcode_two_sum.java b/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n--- a/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n+++ b/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n@@ -8,9 +8,10 @@\n \n import java.util.*;\n \n-class solution_brute_force {\n+class SolutionBruteForce {\n     public int[] twoSum(int[] nums, int target) {\n         int size = nums.length;\n+        // 两层循环，时间复杂度 O(n^2)\n         for (int i = 0; i < size - 1; i++) {\n             for (int j = i + 1; j < size; j++) {\n                 if (nums[i] + nums[j] == target)\n@@ -21,10 +22,12 @@ public int[] twoSum(int[] nums, int target) {\n     }\n }\n \n-class solution_hash_map {\n+class SolutionHashMap {\n     public int[] twoSum(int[] nums, int target) {\n         int size = nums.length;\n+        // 辅助哈希表，空间复杂度 O(n)\n         Map<Integer, Integer> dic = new HashMap<>();\n+        // 单层循环，时间复杂度 O(n)\n         for (int i = 0; i < size; i++) {\n             if (dic.containsKey(target - nums[i])) {\n                 return new int[] { dic.get(target - nums[i]), i };\n@@ -43,11 +46,11 @@ public static void main(String[] args) {\n         \n         // ====== Driver Code ======\n         // 方法一\n-        solution_brute_force slt1 = new solution_brute_force();\n+        SolutionBruteForce slt1 = new SolutionBruteForce();\n         int[] res = slt1.twoSum(nums, target);\n         System.out.println(Arrays.toString(res));\n         // 方法二\n-        solution_hash_map slt2 = new solution_hash_map();\n+        SolutionHashMap slt2 = new SolutionHashMap();\n         res = slt2.twoSum(nums, target);\n         System.out.println(Arrays.toString(res));\n     }\n\ndiff --git a/codes/java/chapter_computational_complexity/space_complexity_types.java b/codes/java/chapter_computational_complexity/space_complexity_types.java\n--- a/codes/java/chapter_computational_complexity/space_complexity_types.java\n+++ b/codes/java/chapter_computational_complexity/space_complexity_types.java\n@@ -100,7 +100,7 @@ public static void main(String[] args) {\n         quadratic(n);\n         quadraticRecur(n);\n         // 指数阶\n-        TreeNode tree = buildTree(n);\n-        PrintUtil.printTree(tree);\n+        TreeNode root = buildTree(n);\n+        PrintUtil.printTree(root);\n     }\n }\n\ndiff --git a/codes/java/chapter_computational_complexity/time_complexity_types.java b/codes/java/chapter_computational_complexity/time_complexity_types.java\n--- a/codes/java/chapter_computational_complexity/time_complexity_types.java\n+++ b/codes/java/chapter_computational_complexity/time_complexity_types.java\n@@ -29,7 +29,6 @@ static int arrayTraversal(int[] nums) {\n         int count = 0;\n         // 循环次数与数组长度成正比\n         for (int num : nums) {\n-            // System.out.println(num);\n             count++;\n         }\n         return count;\n@@ -38,6 +37,7 @@ static int arrayTraversal(int[] nums) {\n     /* 平方阶 */\n     static int quadratic(int n) {\n         int count = 0;\n+        // 循环次数与数组长度成平方关系\n         for (int i = 0; i < n; i++) {\n             for (int j = 0; j < n; j++) {\n                 count++;\n@@ -47,18 +47,22 @@ static int quadratic(int n) {\n     }\n \n     /* 平方阶（冒泡排序） */\n-    static void bubbleSort(int[] nums) {\n-        int n = nums.length;\n-        for (int i = 0; i < n - 1; i++) {\n-            for (int j = 0; j < n - 1 - i; j++) {\n+    static int bubbleSort(int[] nums) {\n+        int count = 0;  // 计数器\n+        // 外循环：待排序元素数量为 n-1, n-2, ..., 1\n+        for (int i = nums.length - 1; i > 0; i--) {\n+            // 内循环：冒泡操作\n+            for (int j = 0; j < i; j++) {\n                 if (nums[j] > nums[j + 1]) {\n-                    // 交换 nums[j] 和 nums[j + 1]\n+                    // 交换 nums[j] 与 nums[j + 1]\n                     int tmp = nums[j];\n                     nums[j] = nums[j + 1];\n                     nums[j + 1] = tmp;\n+                    count += 3;  // 元素交换包含 3 个单元操作\n                 }\n             }\n         }\n+        return count;\n     }\n \n     /* 指数阶（循环实现） */\n@@ -135,6 +139,11 @@ public static void main(String[] args) {\n \n         count = quadratic(n);\n         System.out.println(\"平方阶的计算操作数量 = \" + count);\n+        int[] nums = new int[n];\n+        for (int i = 0; i < n; i++)\n+            nums[i] = n - i;  // [n,n-1,...,2,1]\n+        count = bubbleSort(nums);\n+        System.out.println(\"平方阶（冒泡排序）的计算操作数量 = \" + count);\n \n         count = exponential(n);\n         System.out.println(\"指数阶（循环实现）的计算操作数量 = \" + count);",
    "output": "Merge branch 'krahets:master' into master"
  },
  {
    "input": "diff --git a/codes/java/chapter_computational_complexity/leetcode_two_sum.java b/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n--- a/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n+++ b/codes/java/chapter_computational_complexity/leetcode_two_sum.java\n@@ -8,9 +8,10 @@\n \n import java.util.*;\n \n-class solution_brute_force {\n+class SolutionBruteForce {\n     public int[] twoSum(int[] nums, int target) {\n         int size = nums.length;\n+        // 两层循环，时间复杂度 O(n^2)\n         for (int i = 0; i < size - 1; i++) {\n             for (int j = i + 1; j < size; j++) {\n                 if (nums[i] + nums[j] == target)\n@@ -21,10 +22,12 @@ public int[] twoSum(int[] nums, int target) {\n     }\n }\n \n-class solution_hash_map {\n+class SolutionHashMap {\n     public int[] twoSum(int[] nums, int target) {\n         int size = nums.length;\n+        // 辅助哈希表，空间复杂度 O(n)\n         Map<Integer, Integer> dic = new HashMap<>();\n+        // 单层循环，时间复杂度 O(n)\n         for (int i = 0; i < size; i++) {\n             if (dic.containsKey(target - nums[i])) {\n                 return new int[] { dic.get(target - nums[i]), i };\n@@ -43,11 +46,11 @@ public static void main(String[] args) {\n         \n         // ====== Driver Code ======\n         // 方法一\n-        solution_brute_force slt1 = new solution_brute_force();\n+        SolutionBruteForce slt1 = new SolutionBruteForce();\n         int[] res = slt1.twoSum(nums, target);\n         System.out.println(Arrays.toString(res));\n         // 方法二\n-        solution_hash_map slt2 = new solution_hash_map();\n+        SolutionHashMap slt2 = new SolutionHashMap();\n         res = slt2.twoSum(nums, target);\n         System.out.println(Arrays.toString(res));\n     }\n\ndiff --git a/codes/java/chapter_computational_complexity/space_complexity_types.java b/codes/java/chapter_computational_complexity/space_complexity_types.java\n--- a/codes/java/chapter_computational_complexity/space_complexity_types.java\n+++ b/codes/java/chapter_computational_complexity/space_complexity_types.java\n@@ -100,7 +100,7 @@ public static void main(String[] args) {\n         quadratic(n);\n         quadraticRecur(n);\n         // 指数阶\n-        TreeNode tree = buildTree(n);\n-        PrintUtil.printTree(tree);\n+        TreeNode root = buildTree(n);\n+        PrintUtil.printTree(root);\n     }\n }\n\ndiff --git a/codes/java/chapter_computational_complexity/time_complexity_types.java b/codes/java/chapter_computational_complexity/time_complexity_types.java\n--- a/codes/java/chapter_computational_complexity/time_complexity_types.java\n+++ b/codes/java/chapter_computational_complexity/time_complexity_types.java\n@@ -29,7 +29,6 @@ static int arrayTraversal(int[] nums) {\n         int count = 0;\n         // 循环次数与数组长度成正比\n         for (int num : nums) {\n-            // System.out.println(num);\n             count++;\n         }\n         return count;\n@@ -38,6 +37,7 @@ static int arrayTraversal(int[] nums) {\n     /* 平方阶 */\n     static int quadratic(int n) {\n         int count = 0;\n+        // 循环次数与数组长度成平方关系\n         for (int i = 0; i < n; i++) {\n             for (int j = 0; j < n; j++) {\n                 count++;\n@@ -47,18 +47,22 @@ static int quadratic(int n) {\n     }\n \n     /* 平方阶（冒泡排序） */\n-    static void bubbleSort(int[] nums) {\n-        int n = nums.length;\n-        for (int i = 0; i < n - 1; i++) {\n-            for (int j = 0; j < n - 1 - i; j++) {\n+    static int bubbleSort(int[] nums) {\n+        int count = 0;  // 计数器\n+        // 外循环：待排序元素数量为 n-1, n-2, ..., 1\n+        for (int i = nums.length - 1; i > 0; i--) {\n+            // 内循环：冒泡操作\n+            for (int j = 0; j < i; j++) {\n                 if (nums[j] > nums[j + 1]) {\n-                    // 交换 nums[j] 和 nums[j + 1]\n+                    // 交换 nums[j] 与 nums[j + 1]\n                     int tmp = nums[j];\n                     nums[j] = nums[j + 1];\n                     nums[j + 1] = tmp;\n+                    count += 3;  // 元素交换包含 3 个单元操作\n                 }\n             }\n         }\n+        return count;\n     }\n \n     /* 指数阶（循环实现） */\n@@ -135,6 +139,11 @@ public static void main(String[] args) {\n \n         count = quadratic(n);\n         System.out.println(\"平方阶的计算操作数量 = \" + count);\n+        int[] nums = new int[n];\n+        for (int i = 0; i < n; i++)\n+            nums[i] = n - i;  // [n,n-1,...,2,1]\n+        count = bubbleSort(nums);\n+        System.out.println(\"平方阶（冒泡排序）的计算操作数量 = \" + count);\n \n         count = exponential(n);\n         System.out.println(\"指数阶（循环实现）的计算操作数量 = \" + count);",
    "output": "Add python codes and for the chapter of\ncomputational complexity.\nUpdate Java codes.\nUpdate Contributors."
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/merge_sort.java b/codes/java/chapter_sorting/merge_sort.java\n--- a/codes/java/chapter_sorting/merge_sort.java\n+++ b/codes/java/chapter_sorting/merge_sort.java\n@@ -9,10 +9,14 @@ public class merge_sort {\n      * 右子数组区间 [mid + 1, right]\n      */\n     static void merge(int[] nums, int left, int mid, int right) {\n-        int[] tmp = Arrays.copyOfRange(nums, left, right + 1);     // 初始化辅助数组\n-        int leftStart = left - left, leftEnd = mid - left,         // 左子数组的起始索引和结束索引\n-            rightStart = mid + 1 - left, rightEnd = right - left;  // 右子数组的起始索引和结束索引\n-        int i = leftStart, j = rightStart;                // i,j 分别指向左子数组、右子数组的首元素\n+        // 初始化辅助数组\n+        int[] tmp = Arrays.copyOfRange(nums, left, right + 1);   \n+        // 左子数组的起始索引和结束索引  \n+        int leftStart = left - left, leftEnd = mid - left;\n+        // 右子数组的起始索引和结束索引       \n+        int rightStart = mid + 1 - left, rightEnd = right - left;\n+        // i, j 分别指向左子数组、右子数组的首元素\n+        int i = leftStart, j = rightStart;                \n         // 通过覆盖原数组 nums 来合并左子数组和右子数组\n         for (int k = left; k <= right; k++) {\n             // 若 “左子数组已全部合并完”，则选取右子数组元素，并且 j++",
    "output": "Add merge sort, and sorting algorithm."
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/merge_sort.java b/codes/java/chapter_sorting/merge_sort.java\n--- a/codes/java/chapter_sorting/merge_sort.java\n+++ b/codes/java/chapter_sorting/merge_sort.java\n@@ -0,0 +1,48 @@\n+package chapter_sorting;\n+\n+import java.util.*;\n+\n+public class merge_sort {\n+    /**\n+     * 合并左子数组和右子数组\n+     * 左子数组区间 [left, mid]\n+     * 右子数组区间 [mid + 1, right]\n+     */\n+    static void merge(int[] nums, int left, int mid, int right) {\n+        int[] tmp = Arrays.copyOfRange(nums, left, right + 1);     // 初始化辅助数组\n+        int leftStart = left - left, leftEnd = mid - left,         // 左子数组的起始索引和结束索引\n+            rightStart = mid + 1 - left, rightEnd = right - left;  // 右子数组的起始索引和结束索引\n+        int i = leftStart, j = rightStart;                // i,j 分别指向左子数组、右子数组的首元素\n+        // 通过覆盖原数组 nums 来合并左子数组和右子数组\n+        for (int k = left; k <= right; k++) {\n+            // 若 “左子数组已全部合并完”，则选取右子数组元素，并且 j++\n+            if (i > leftEnd)\n+                nums[k] = tmp[j++];\n+            // 否则，若 “右子数组已全部合并完” 或 “左子数组元素 < 右子数组元素”，则选取左子数组元素，并且 i++\n+            else if (j > rightEnd || tmp[i] <= tmp[j])\n+                nums[k] = tmp[i++];\n+            // 否则，若 “左子数组元素 > 右子数组元素”，则选取右子数组元素，并且 j++\n+            else\n+                nums[k] = tmp[j++];\n+        }\n+    }\n+\n+    /* 归并排序 */\n+    static void mergeSort(int[] nums, int left, int right) {\n+        // 终止条件\n+        if (left >= right) return;       // 当子数组长度为 1 时终止递归\n+        // 划分阶段\n+        int mid = (left + right) / 2;    // 计算中点\n+        mergeSort(nums, left, mid);      // 递归左子数组\n+        mergeSort(nums, mid + 1, right); // 递归右子数组\n+        // 合并阶段\n+        merge(nums, left, mid, right);\n+    }\n+\n+    public static void main(String[] args) {\n+        /* 归并排序 */\n+        int[] nums = { 2, 4, 1, 0, 3, 5 };\n+        mergeSort(nums, 0, nums.length - 1);\n+        System.out.println(\"归并排序完成后 nums = \" + Arrays.toString(nums));\n+    }\n+}\n\ndiff --git a/codes/java/chapter_sorting/quick_sort.java b/codes/java/chapter_sorting/quick_sort.java\n--- a/codes/java/chapter_sorting/quick_sort.java\n+++ b/codes/java/chapter_sorting/quick_sort.java\n@@ -0,0 +1,154 @@\n+package chapter_sorting;\n+\n+import java.util.*;\n+\n+/* 快速排序类 */\n+class QuickSort {\n+    /* 元素交换 */\n+    static void swap(int[] nums, int i, int j) {\n+        int tmp = nums[i];\n+        nums[i] = nums[j];\n+        nums[j] = tmp;\n+    }\n+\n+    /* 哨兵划分 */\n+    static int partition(int[] nums, int left, int right) {\n+        // 以 nums[left] 作为基准数\n+        int i = left, j = right;\n+        while (i < j) {\n+            while (i < j && nums[j] >= nums[left])\n+                j--;          // 从右向左找首个小于基准数的元素\n+            while (i < j && nums[i] <= nums[left])\n+                i++;          // 从左向右找首个大于基准数的元素\n+            swap(nums, i, j); // 交换这两个元素\n+        }\n+        swap(nums, i, left);  // 将基准数交换至两子数组的分界线\n+        return i;             // 返回基准数的索引\n+    }\n+\n+    /* 快速排序 */\n+    public static void quickSort(int[] nums, int left, int right) {\n+        // 子数组长度为 1 时终止递归\n+        if (left >= right)\n+            return;\n+        // 哨兵划分\n+        int pivot = partition(nums, left, right);\n+        // 递归左子数组、右子数组\n+        quickSort(nums, left, pivot - 1);\n+        quickSort(nums, pivot + 1, right);\n+    }\n+}\n+\n+/* 快速排序类（中位基准数优化） */\n+class QuickSortMedian {\n+    /* 元素交换 */\n+    static void swap(int[] nums, int i, int j) {\n+        int tmp = nums[i];\n+        nums[i] = nums[j];\n+        nums[j] = tmp;\n+    }\n+\n+    /* 选取三个元素的中位数 */\n+    static int medianThree(int[] nums, int left, int mid, int right) {\n+        // 使用了异或操作来简化代码\n+        // 异或规则为 0 ^ 0 = 1 ^ 1 = 0, 0 ^ 1 = 1 ^ 0 = 1\n+        if ((nums[left] > nums[mid]) ^ (nums[left] > nums[right]))\n+            return left;\n+        else if ((nums[mid] < nums[left]) ^ (nums[mid] < nums[right]))\n+            return mid;\n+        else\n+            return right;\n+    }\n+\n+    /* 哨兵划分（三数取中值） */\n+    static int partition(int[] nums, int left, int right) {\n+        // 选取三个候选元素的中位数\n+        int med = medianThree(nums, left, (left + right) / 2, right);\n+        // 将中位数交换至数组最左端\n+        swap(nums, left, med);\n+        // 以 nums[left] 作为基准数\n+        int i = left, j = right;\n+        while (i < j) {\n+            while (i < j && nums[j] >= nums[left])\n+                j--;          // 从右向左找首个小于基准数的元素\n+            while (i < j && nums[i] <= nums[left])\n+                i++;          // 从左向右找首个大于基准数的元素\n+            swap(nums, i, j); // 交换这两个元素\n+        }\n+        swap(nums, i, left);  // 将基准数交换至两子数组的分界线\n+        return i;             // 返回基准数的索引\n+    }\n+\n+    /* 快速排序 */\n+    public static void quickSort(int[] nums, int left, int right) {\n+        // 子数组长度为 1 时终止递归\n+        if (left >= right)\n+            return;\n+        // 哨兵划分\n+        int pivot = partition(nums, left, right);\n+        // 递归左子数组、右子数组\n+        quickSort(nums, left, pivot - 1);\n+        quickSort(nums, pivot + 1, right);\n+    }\n+}\n+\n+/* 快速排序类（尾递归优化） */\n+class QuickSortTailCall {\n+    /* 元素交换 */\n+    static void swap(int[] nums, int i, int j) {\n+        int tmp = nums[i];\n+        nums[i] = nums[j];\n+        nums[j] = tmp;\n+    }\n+\n+    /* 哨兵划分 */\n+    static int partition(int[] nums, int left, int right) {\n+        // 以 nums[left] 作为基准数\n+        int i = left, j = right;\n+        while (i < j) {\n+            while (i < j && nums[j] >= nums[left])\n+                j--;          // 从右向左找首个小于基准数的元素\n+            while (i < j && nums[i] <= nums[left])\n+                i++;          // 从左向右找首个大于基准数的元素\n+            swap(nums, i, j); // 交换这两个元素\n+        }\n+        swap(nums, i, left);  // 将基准数交换至两子数组的分界线\n+        return i; // 返回基准数的索引\n+    }\n+\n+    /* 快速排序（尾递归优化） */\n+    static void quickSort(int[] nums, int left, int right) {\n+        // 子数组长度为 1 时终止\n+        while (left < right) {\n+            // 哨兵划分操作\n+            int pivot = partition(nums, left, right);\n+            // 对两个子数组中较短的那个执行快排\n+            if (pivot - left < right - pivot) {\n+                quickSort(nums, left, pivot - 1);  // 递归排序左子数组\n+                left = pivot + 1;  // 剩余待排序区间为 [pivot + 1, right]\n+            } else {\n+                quickSort(nums, pivot + 1, right); // 递归排序右子数组\n+                right = pivot - 1; // 剩余待排序区间为 [left, pivot - 1]\n+            }\n+        }\n+    }\n+}\n+\n+public class quick_sort {\n+    public static void main(String[] args) {\n+        /* 快速排序 */\n+        int[] nums = { 2, 4, 1, 0, 3, 5 };\n+        QuickSort.quickSort(nums, 0, nums.length - 1);\n+        System.out.println(\"快速排序完成后 nums = \" + Arrays.toString(nums));\n+\n+        /* 快速排序（中位基准数优化） */\n+        int[] nums1 = { 2, 4, 1, 0, 3, 5 };\n+        QuickSortMedian.quickSort(nums1, 0, nums1.length - 1);\n+        System.out.println(\"快速排序（中位基准数优化）完成后 nums1 = \" + Arrays.toString(nums1));\n+\n+        /* 快速排序（尾递归优化） */\n+        int[] nums2 = { 2, 4, 1, 0, 3, 5 };\n+        QuickSortTailCall.quickSort(nums2, 0, nums2.length - 1);\n+        System.out.println(\"快速排序（尾递归优化）完成后 nums2 = \" + Arrays.toString(nums2));\n+    }\n+}",
    "output": "deploy"
  },
  {
    "input": "diff --git a/codes/java/chapter_sorting/bubble_sort.java b/codes/java/chapter_sorting/bubble_sort.java\n--- a/codes/java/chapter_sorting/bubble_sort.java\n+++ b/codes/java/chapter_sorting/bubble_sort.java\n@@ -0,0 +1,50 @@\n+package chapter_sorting;\n+\n+import java.util.*;\n+\n+public class bubble_sort {\n+    /* 冒泡排序 */\n+    static void bubbleSort(int[] nums) {\n+        // 外循环：待排序元素数量为 n-1, n-2, ..., 1\n+        for (int i = nums.length - 1; i > 0; i--) {\n+            // 内循环：冒泡操作\n+            for (int j = 0; j < i; j++) {\n+                if (nums[j] > nums[j + 1]) {\n+                    // 交换 nums[j] 与 nums[j + 1]\n+                    int tmp = nums[j];\n+                    nums[j] = nums[j + 1];\n+                    nums[j + 1] = tmp;\n+                }\n+            }\n+        }\n+    }\n+\n+    /* 冒泡排序（标志优化）*/\n+    static void bubbleSortWithFlag(int[] nums) {\n+        // 外循环：待排序元素数量为 n-1, n-2, ..., 1\n+        for (int i = nums.length - 1; i > 0; i--) {\n+            boolean flag = false; // 初始化标志位\n+            // 内循环：冒泡操作\n+            for (int j = 0; j < i; j++) {\n+                if (nums[j] > nums[j + 1]) {\n+                    // 交换 nums[j] 与 nums[j + 1]\n+                    int tmp = nums[j];\n+                    nums[j] = nums[j + 1];\n+                    nums[j + 1] = tmp;\n+                    flag = true;  // 记录交换元素\n+                }\n+            }\n+            if (!flag) break;     // 此轮冒泡未交换任何元素，直接跳出\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 4, 1, 3, 1, 5, 2 };\n+        bubbleSort(nums);\n+        System.out.println(\"排序后数组 nums = \" + Arrays.toString(nums));\n+\n+        int[] nums1 = { 4, 1, 3, 1, 5, 2 };\n+        bubbleSortWithFlag(nums1);\n+        System.out.println(\"排序后数组 nums1 = \" + Arrays.toString(nums));\n+    }\n+}\n\ndiff --git a/codes/java/chapter_sorting/insertion_sort.java b/codes/java/chapter_sorting/insertion_sort.java\n--- a/codes/java/chapter_sorting/insertion_sort.java\n+++ b/codes/java/chapter_sorting/insertion_sort.java\n@@ -0,0 +1,25 @@\n+package chapter_sorting;\n+\n+import java.util.*;\n+\n+public class insertion_sort {\n+    /* 插入排序 */\n+    static void insertionSort(int[] nums) {\n+        // 外循环：base = nums[1], nums[2], ..., nums[n-1]\n+        for (int i = 1; i < nums.length; i++) {\n+            int base = nums[i], j = i - 1;\n+            // 内循环：将 base 插入到左边的正确位置\n+            while (j >= 0 && nums[j] > base) {\n+                nums[j + 1] = nums[j];  // 1. 将 nums[j] 向右移动一位\n+                j--;\n+            }\n+            nums[j + 1] = base;         // 2. 将 base 赋值到正确位置\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] nums = { 4, 1, 3, 1, 5, 2 };\n+        insertionSort(nums);\n+        System.out.println(\"排序后数组 nums = \" + Arrays.toString(nums));\n+    }\n+}",
    "output": "Add bubble sort, insertion sort."
  },
  {
    "input": "diff --git a/codes/java/chapter_searching/binary_search.java b/codes/java/chapter_searching/binary_search.java\n--- a/codes/java/chapter_searching/binary_search.java\n+++ b/codes/java/chapter_searching/binary_search.java\n@@ -0,0 +1,52 @@\n+package chapter_searching;\n+\n+public class binary_search {\n+    /* 二分查找（双闭区间） */\n+    static int binarySearch(int[] nums, int target) {\n+        // 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素\n+        int i = 0, j = nums.length - 1;\n+        // 循环，当搜索区间为空时跳出（当 i > j 时为空）\n+        while (i <= j) {\n+            int m = (i + j) / 2;       // 计算中点索引 m\n+            if (nums[m] < target)      // 此情况说明 target 在区间 [m+1, j] 中\n+                i = m + 1;\n+            else if (nums[m] > target) // 此情况说明 target 在区间 [i, m-1] 中\n+                j = m - 1;\n+            else                       // 找到目标元素，返回其索引\n+                return m;\n+        }\n+        // 未找到目标元素，返回 -1\n+        return -1;\n+    }\n+\n+    /* 二分查找（左闭右开） */\n+    static int binarySearch1(int[] nums, int target) {\n+        // 初始化左闭右开 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1\n+        int i = 0, j = nums.length;\n+        // 循环，当搜索区间为空时跳出（当 i = j 时为空）\n+        while (i < j) {\n+            int m = (i + j) / 2;       // 计算中点索引 m\n+            if (nums[m] < target)      // 此情况说明 target 在区间 [m+1, j) 中\n+                i = m + 1;\n+            else if (nums[m] > target) // 此情况说明 target 在区间 [i, m) 中\n+                j = m;\n+            else                       // 找到目标元素，返回其索引\n+                return m;\n+        }\n+        // 未找到目标元素，返回 -1\n+        return -1;\n+    }\n+    \n+    public static void main(String[] args) {\n+        int target = 6;\n+        int[] nums = { 1, 3, 6, 8, 12, 15, 23, 67, 70, 92 };\n+        \n+        /* 二分查找（双闭区间） */\n+        int index = binarySearch(nums, target);\n+        System.out.println(\"目标元素 6 的索引 = \" + index);\n+\n+        /* 二分查找（左闭右开） */\n+        index = binarySearch1(nums, target);\n+        System.out.println(\"目标元素 6 的索引 = \" + index);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_searching/hashing_search.java b/codes/java/chapter_searching/hashing_search.java\n--- a/codes/java/chapter_searching/hashing_search.java\n+++ b/codes/java/chapter_searching/hashing_search.java\n@@ -0,0 +1,45 @@\n+package chapter_searching;\n+\n+import include.*;\n+import java.util.*;\n+\n+public class hashing_search {\n+    /* 哈希查找（数组） */\n+    static int hashingSearch(Map<Integer, Integer> map, int target) {\n+        // 哈希表的 key: 目标元素，value: 索引\n+        // 若哈希表中无此 key ，返回 -1\n+        return map.getOrDefault(target, -1);\n+    }\n+\n+    /* 哈希查找（链表） */\n+    static ListNode hashingSearch1(Map<Integer, ListNode> map, int target) {\n+        // 哈希表的 key: 目标结点值，value: 结点对象\n+        // 若哈希表中无此 key ，返回 -1\n+        return map.getOrDefault(target, null);\n+    }\n+\n+    public static void main(String[] args) {\n+        int target = 3;\n+\n+        /* 哈希查找（数组） */\n+        int[] nums = { 1, 5, 3, 2, 4, 7, 5, 9, 10, 8 };\n+        // 初始化哈希表\n+        Map<Integer, Integer> map = new HashMap<>();\n+        for (int i = 0; i < nums.length; i++) {\n+            map.put(nums[i], i);  // key: 元素，value: 索引\n+        }\n+        int index = hashingSearch(map, target);\n+        System.out.println(\"目标元素 3 的索引 = \" + index);\n+\n+        /* 哈希查找（链表） */\n+        ListNode head = ListNode.arrToLinkedList(nums);\n+        // 初始化哈希表\n+        Map<Integer, ListNode> map1 = new HashMap<>();\n+        while (head != null) {\n+            map1.put(head.val, head);  // key: 结点值，value: 结点\n+            head = head.next;\n+        }\n+        ListNode node = hashingSearch1(map1, target);\n+        System.out.println(\"目标结点值 3 的对应结点对象为 \" + node);\n+    }\n+}\n\ndiff --git a/codes/java/chapter_searching/linear_search.java b/codes/java/chapter_searching/linear_search.java\n--- a/codes/java/chapter_searching/linear_search.java\n+++ b/codes/java/chapter_searching/linear_search.java\n@@ -0,0 +1,45 @@\n+package chapter_searching;\n+\n+import include.*;\n+\n+public class linear_search {\n+\n+    /* 线性查找（数组） */\n+    static int linearSearch(int[] nums, int target) {\n+        // 遍历数组\n+        for (int i = 0; i < nums.length; i++) {\n+            // 找到目标元素，返回其索引\n+            if (nums[i] == target)\n+                return i;\n+        }\n+        // 未找到目标元素，返回 -1\n+        return -1;\n+    }\n+\n+    /* 线性查找（链表） */\n+    static ListNode linearSearch(ListNode head, int target) {\n+        // 遍历链表\n+        while (head != null) {\n+            // 找到目标结点，返回之\n+            if (head.val == target)\n+                return head;\n+            head = head.next;\n+        }\n+        // 未找到目标结点，返回 null\n+        return null;\n+    }\n+\n+    public static void main(String[] args) {\n+        int target = 3;\n+\n+        /* 在数组中执行线性查找 */\n+        int[] nums = { 1, 5, 3, 2, 4, 7, 5, 9, 10, 8 };\n+        int index = linearSearch(nums, target);\n+        System.out.println(\"目标元素 3 的索引 = \" + index);\n+\n+        /* 在链表中执行线性查找 */\n+        ListNode head = ListNode.arrToLinkedList(nums);\n+        ListNode node = linearSearch(head, target);\n+        System.out.println(\"目标结点值 3 的对应结点对象为 \" + node);\n+    }\n+}",
    "output": "Add the chapter of searching."
  },
  {
    "input": "diff --git a/codes/java/chapter_tree/binary_search_tree.java b/codes/java/chapter_tree/binary_search_tree.java\n--- a/codes/java/chapter_tree/binary_search_tree.java\n+++ b/codes/java/chapter_tree/binary_search_tree.java\n@@ -0,0 +1,146 @@\n+package chapter_tree;\n+\n+import java.util.*;\n+import include.*;\n+\n+class BinarySearchTree {\n+    private TreeNode root;\n+\n+    public BinarySearchTree(int[] nums) {\n+        Arrays.sort(nums); // 排序数组\n+        root = buildTree(nums, 0, nums.length - 1);  // 构建二叉搜索树\n+    }\n+\n+    /* 获取二叉树根结点 */\n+    public TreeNode getRoot() {\n+        return root;\n+    }\n+\n+    /* 构建二叉搜索树 */\n+    public TreeNode buildTree(int[] nums, int i, int j) {\n+        if (i > j) return null;\n+        // 将数组中间结点作为根结点\n+        int mid = (i + j) / 2;\n+        TreeNode root = new TreeNode(nums[mid]);\n+        // 递归建立左子树和右子树\n+        root.left = buildTree(nums, i, mid - 1);\n+        root.right = buildTree(nums, mid + 1, j);\n+        return root;\n+    }\n+\n+    /* 查找结点 */\n+    public TreeNode search(int num) {\n+        TreeNode cur = root;\n+        // 循环查找，越过叶结点后跳出\n+        while (cur != null) {\n+            // 目标结点在 root 的右子树中\n+            if (cur.val < num) cur = cur.right;\n+            // 目标结点在 root 的左子树中\n+            else if (cur.val > num) cur = cur.left;\n+            // 找到目标结点，跳出循环\n+            else break;\n+        }\n+        // 返回目标结点\n+        return cur;\n+    }\n+\n+    /* 插入结点 */\n+    public TreeNode insert(int num) {\n+        // 若树为空，直接提前返回\n+        if (root == null) return null;\n+        TreeNode cur = root, pre = null;\n+        // 循环查找，越过叶结点后跳出\n+        while (cur != null) {\n+            // 找到重复结点，直接返回\n+            if (cur.val == num) return null;\n+            pre = cur;\n+            // 插入位置在 root 的右子树中\n+            if (cur.val < num) cur = cur.right;\n+            // 插入位置在 root 的左子树中\n+            else cur = cur.left;\n+        }\n+        // 插入结点 val\n+        TreeNode node = new TreeNode(num);\n+        if (pre.val < num) pre.right = node;\n+        else pre.left = node;\n+        return node;\n+    }\n+\n+    /* 删除结点 */\n+    public TreeNode remove(int num) {\n+        // 若树为空，直接提前返回\n+        if (root == null) return null;\n+        TreeNode cur = root, pre = null;\n+        // 循环查找，越过叶结点后跳出\n+        while (cur != null) {\n+            // 找到待删除结点，跳出循环\n+            if (cur.val == num) break;\n+            pre = cur;\n+            // 待删除结点在 root 的右子树中\n+            if (cur.val < num) cur = cur.right;\n+            // 待删除结点在 root 的左子树中\n+            else cur = cur.left;\n+        }\n+        // 若无待删除结点，则直接返回\n+        if (cur == null) return null;\n+        // 子结点数量 = 0 or 1\n+        if (cur.left == null || cur.right == null) {\n+            // 当子结点数量 = 0 / 1 时， child = null / 该子结点\n+            TreeNode child = cur.left != null ? cur.left : cur.right;\n+            // 删除结点 cur\n+            if (pre.left == cur) pre.left = child;\n+            else pre.right = child;\n+        }\n+        // 子结点数量 = 2\n+        else {\n+            // 获取中序遍历中 cur 的下一个结点\n+            TreeNode nex = min(cur.right);\n+            int tmp = nex.val;\n+            // 递归删除结点 nex\n+            remove(nex.val);\n+            // 将 nex 的值复制给 cur\n+            cur.val = tmp;\n+        }\n+        return cur;\n+    }\n+\n+    /* 获取最小结点 */\n+    public TreeNode min(TreeNode root) {\n+        if (root == null) return root;\n+        // 循环访问左子结点，直到叶结点时为最小结点，跳出\n+        while (root.left != null) {\n+            root = root.left;\n+        }\n+        return root;\n+    }\n+}\n+\n+public class binary_search_tree {\n+    public static void main(String[] args) {\n+        /* 初始化二叉搜索树 */\n+        int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+        BinarySearchTree bst = new BinarySearchTree(nums);\n+        System.out.println(\"\\n初始化的二叉树为\\n\");\n+        PrintUtil.printTree(bst.getRoot());\n+\n+        /* 查找结点 */\n+        TreeNode node = bst.search(5);\n+        System.out.println(\"\\n查找到的结点对象为 \" + node + \"，结点值 = \" + node.val);\n+\n+        /* 插入结点 */\n+        node = bst.insert(16);\n+        System.out.println(\"\\n插入结点 16 后，二叉树为\\n\");\n+        PrintUtil.printTree(bst.getRoot());\n+\n+        /* 删除结点 */\n+        bst.remove(1);\n+        System.out.println(\"\\n删除结点 1 后，二叉树为\\n\");\n+        PrintUtil.printTree(bst.getRoot());\n+        bst.remove(2);\n+        System.out.println(\"\\n删除结点 2 后，二叉树为\\n\");\n+        PrintUtil.printTree(bst.getRoot());\n+        bst.remove(4);\n+        System.out.println(\"\\n删除结点 4 后，二叉树为\\n\");\n+        PrintUtil.printTree(bst.getRoot());\n+    }\n+}",
    "output": "Add section of binary search tree.\nMake all table align center."
  }
]