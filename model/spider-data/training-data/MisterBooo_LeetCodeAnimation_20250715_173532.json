[
  {
    "input": "diff --git a/0004-median-of-two-sorted-arrays/Code/1.java b/0004-median-of-two-sorted-arrays/Code/1.java\n--- a/0004-median-of-two-sorted-arrays/Code/1.java\n+++ b/0004-median-of-two-sorted-arrays/Code/1.java\n@@ -0,0 +1,54 @@\n+public class Solution {\r\n+  public double findMedianSortedArrays(int[] nums1, int[] nums2) {\r\n+    // ʹnums1��Ϊ�϶�����,����������߼����ٶ�,ͬʱ���Ա���һЩ�߽�����\r\n+    if (nums1.length > nums2.length) {\r\n+      int[] temp = nums1;\r\n+      nums1 = nums2;\r\n+      nums2 = temp;\r\n+    }\r\n+\r\n+    int len1 = nums1.length;\r\n+    int len2 = nums2.length;\r\n+    int leftLen = (len1 + len2 + 1) / 2; //������ϲ�&�����,���ߵĳ���\r\n+    \r\n+    // ������1���ж��ּ���\r\n+    int start = 0;\r\n+    int end = len1;\r\n+    while (start <= end) {\r\n+      // ��������ı�����A,B��λ��(��1��ʼ����)\r\n+      // count1 = 2 ��ʾ num1 ����ĵ�2������\r\n+      // ��index��1\r\n+      int count1 = start + ((end - start) / 2);\r\n+      int count2 = leftLen - count1;\r\n+      \r\n+      if (count1 > 0 && nums1[count1 - 1] > nums2[count2]) {\r\n+        // A��B��next��Ҫ��\r\n+        end = count1 - 1;\r\n+      } else if (count1 < len1 && nums2[count2 - 1] > nums1[count1]) {\r\n+        // B��A��next��Ҫ��\r\n+        start = count1 + 1;\r\n+      } else {\r\n+        // ��ȡ��λ��\r\n+        int result =  (count1 == 0)? nums2[count2 - 1]: // ��num1������������������ұ�\r\n+                      (count2 == 0)? nums1[count1 - 1]: // ��num2������������������ұ�\r\n+                      Math.max(nums1[count1 - 1], nums2[count2 - 1]); // �Ƚ�A,B\r\n+        if (isOdd(len1 + len2)) {\r\n+          return result;\r\n+        }\r\n+\r\n+        // ����ż�����������\r\n+        int nextValue = (count1 == len1) ? nums2[count2]:\r\n+                        (count2 == len2) ? nums1[count1]:\r\n+                        Math.min(nums1[count1], nums2[count2]);\r\n+        return (result + nextValue) / 2.0;\r\n+      }\r\n+    }\r\n+\r\n+    return Integer.MIN_VALUE; // ���Ե���������\r\n+  }\r\n+\r\n+  // ��������true,ż������false\r\n+  private boolean isOdd(int x) {\r\n+    return (x & 1) == 1;\r\n+  }\r\n+}\r",
    "output": "Merge pull request #86 from freetreer/master\n\n0004_Solved"
  },
  {
    "input": "diff --git a/0004-median-of-two-sorted-arrays/Code/1.java b/0004-median-of-two-sorted-arrays/Code/1.java\n--- a/0004-median-of-two-sorted-arrays/Code/1.java\n+++ b/0004-median-of-two-sorted-arrays/Code/1.java\n@@ -0,0 +1,54 @@\n+public class Solution {\r\n+  public double findMedianSortedArrays(int[] nums1, int[] nums2) {\r\n+    // ʹnums1��Ϊ�϶�����,����������߼����ٶ�,ͬʱ���Ա���һЩ�߽�����\r\n+    if (nums1.length > nums2.length) {\r\n+      int[] temp = nums1;\r\n+      nums1 = nums2;\r\n+      nums2 = temp;\r\n+    }\r\n+\r\n+    int len1 = nums1.length;\r\n+    int len2 = nums2.length;\r\n+    int leftLen = (len1 + len2 + 1) / 2; //������ϲ�&�����,���ߵĳ���\r\n+    \r\n+    // ������1���ж��ּ���\r\n+    int start = 0;\r\n+    int end = len1;\r\n+    while (start <= end) {\r\n+      // ��������ı�����A,B��λ��(��1��ʼ����)\r\n+      // count1 = 2 ��ʾ num1 ����ĵ�2������\r\n+      // ��index��1\r\n+      int count1 = start + ((end - start) / 2);\r\n+      int count2 = leftLen - count1;\r\n+      \r\n+      if (count1 > 0 && nums1[count1 - 1] > nums2[count2]) {\r\n+        // A��B��next��Ҫ��\r\n+        end = count1 - 1;\r\n+      } else if (count1 < len1 && nums2[count2 - 1] > nums1[count1]) {\r\n+        // B��A��next��Ҫ��\r\n+        start = count1 + 1;\r\n+      } else {\r\n+        // ��ȡ��λ��\r\n+        int result =  (count1 == 0)? nums2[count2 - 1]: // ��num1������������������ұ�\r\n+                      (count2 == 0)? nums1[count1 - 1]: // ��num2������������������ұ�\r\n+                      Math.max(nums1[count1 - 1], nums2[count2 - 1]); // �Ƚ�A,B\r\n+        if (isOdd(len1 + len2)) {\r\n+          return result;\r\n+        }\r\n+\r\n+        // ����ż�����������\r\n+        int nextValue = (count1 == len1) ? nums2[count2]:\r\n+                        (count2 == len2) ? nums1[count1]:\r\n+                        Math.min(nums1[count1], nums2[count2]);\r\n+        return (result + nextValue) / 2.0;\r\n+      }\r\n+    }\r\n+\r\n+    return Integer.MIN_VALUE; // ���Ե���������\r\n+  }\r\n+\r\n+  // ��������true,ż������false\r\n+  private boolean isOdd(int x) {\r\n+    return (x & 1) == 1;\r\n+  }\r\n+}\r",
    "output": "0004_Solved\n\n0004_Solved"
  },
  {
    "input": "diff --git a/0034-find-first-and-last-position-of-element-in-sorted-array/Code/1.java b/0034-find-first-and-last-position-of-element-in-sorted-array/Code/1.java\n--- a/0034-find-first-and-last-position-of-element-in-sorted-array/Code/1.java\n+++ b/0034-find-first-and-last-position-of-element-in-sorted-array/Code/1.java\n@@ -0,0 +1,33 @@\n+class Solution {\n+    public int[] searchRange(int[] nums, int target) {\n+\t\tint[] res = new int[] { -1, -1 };\n+\t\tint left = 0;\n+\t\tint right = nums.length - 1;\n+\t\tint l = left;\n+\t\tint r = right;\n+\t\twhile (left < right) {\n+\t\t\tint mid = (left + right) / 2;\n+\t\t\tif (nums[mid] < target) {\n+\t\t\t\tleft = mid + 1;\n+\t\t\t} else {\n+\t\t\t\tright = mid;\n+\t\t\t}\n+\t\t}\n+\t\tif (left>right||nums[left]!=target) {\n+\t\t\treturn new int[]{-1,-1};\n+\t\t}\n+\t\twhile (l < r) {\n+\t\t\tint mid = (l + r) / 2 + 1;\n+\t\t\tif (nums[mid] > target) {\n+\t\t\t\tr = mid - 1;\n+\t\t\t} else {\n+\t\t\t\tl = mid;\n+\t\t\t}\n+\t\t}\n+\t\tif (left > right || left > r) {\n+\t\t\treturn new int[] { -1, -1 };\n+\t\t} else {\n+\t\t\treturn new int[] { left, r };\n+\t\t}\n+\t}\n+}\n\\ No newline at end of file\n\ndiff --git a/0035-search-insert-position/Code/1.java b/0035-search-insert-position/Code/1.java\n--- a/0035-search-insert-position/Code/1.java\n+++ b/0035-search-insert-position/Code/1.java\n@@ -0,0 +1,11 @@\n+class Solution1 {\n+    public int searchInsert(int[] nums, int target) {\n+        int i=0;\n+        for(;i<nums.length;i++){\n+            if (nums[i]>=target){\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+}\n\\ No newline at end of file\n\ndiff --git a/0035-search-insert-position/Code/2.java b/0035-search-insert-position/Code/2.java\n--- a/0035-search-insert-position/Code/2.java\n+++ b/0035-search-insert-position/Code/2.java\n@@ -0,0 +1,21 @@\n+//时间复杂度：O(lon(n))\n+//空间复杂度：O(1)\n+class Solution2 {\n+    public int searchInsert(int[] nums, int target) {\n+        if (target>nums[nums.length-1]) {\n+            return nums.length;\n+        }\n+        int left=0;\n+        int right=nums.length-1;\n+        while (left < right) {\n+            int mid = (left + right) / 2;\n+            if (nums[mid] < target) {\n+                left = mid + 1;\n+            } else {\n+                right = mid;\n+            }\n+        }\n+        return left;\n+\n+    }\n+}\n\\ No newline at end of file\n\ndiff --git a/0036-valid-sudoku/Code/1.java b/0036-valid-sudoku/Code/1.java\n--- a/0036-valid-sudoku/Code/1.java\n+++ b/0036-valid-sudoku/Code/1.java\n@@ -0,0 +1,34 @@\n+class Solution {\n+    public boolean isValidSudoku(char[][] board) {\n+        HashMap[] row = new HashMap[9];\n+        HashMap[] column = new HashMap[9];\n+        HashMap[] box = new HashMap[9];\n+        for (int i = 0; i < 9; i++) {\n+            row[i] = new HashMap(9);\n+            column[i] = new HashMap(9);\n+            box[i] = new HashMap(9);\n+        }\n+        for (int i = 0; i < 9; i++) {\n+            for (int j = 0; j < 9; j++) {\n+                if (board[i][j] == '.') {\n+                    continue;\n+                }\n+                int boxIndex=i / 3 * 3 + j / 3;\n+                if ((boolean) row[i].getOrDefault(board[i][j], true)) {\n+                    return false;\n+                }\n+                if ((boolean) column[j].getOrDefault(board[i][j], true)) {\n+                    return false;\n+                }\n+                if ((boolean) box[boxIndex].getOrDefault(board[i][j], true)) {\n+                    return false;\n+                }\n+                row[i].put(board[i][j], false);\n+                column[j].put(board[i][j], false);\n+                box[boxIndex].put(board[i][j], false);\n+            }\n+        }\n+\n+        return true;\n+\t}\n+}\n\\ No newline at end of file",
    "output": "0034、0035、0036 solved"
  },
  {
    "input": "diff --git a/0771-Jewels-Stones/Code/1.java b/0771-Jewels-Stones/Code/1.java\n--- a/0771-Jewels-Stones/Code/1.java\n+++ b/0771-Jewels-Stones/Code/1.java\n@@ -0,0 +1,14 @@\n+\r\n+class Solution {\r\n+    public int numJewelsInStones(String J, String S) {\r\n+        Set<Character> Jset = new HashSet();\r\n+        for (char j: J.toCharArray())\r\n+            Jset.add(j);\r\n+\r\n+        int ans = 0;\r\n+        for (char s: S.toCharArray())\r\n+            if (Jset.contains(s))\r\n+                ans++;\r\n+        return ans;\r\n+    }\r\n+}\n\\ No newline at end of file",
    "output": "Merge pull request #61 from chilimyan/master\n\n0771 Solved"
  },
  {
    "input": "diff --git a/0771-Jewels-Stones/Code/1.java b/0771-Jewels-Stones/Code/1.java\n--- a/0771-Jewels-Stones/Code/1.java\n+++ b/0771-Jewels-Stones/Code/1.java\n@@ -0,0 +1,14 @@\n+\r\n+class Solution {\r\n+    public int numJewelsInStones(String J, String S) {\r\n+        Set<Character> Jset = new HashSet();\r\n+        for (char j: J.toCharArray())\r\n+            Jset.add(j);\r\n+\r\n+        int ans = 0;\r\n+        for (char s: S.toCharArray())\r\n+            if (Jset.contains(s))\r\n+                ans++;\r\n+        return ans;\r\n+    }\r\n+}\n\\ No newline at end of file",
    "output": "0771 Solved"
  },
  {
    "input": "diff --git a/0155-min-stack/Code/1.java b/0155-min-stack/Code/1.java\n--- a/0155-min-stack/Code/1.java\n+++ b/0155-min-stack/Code/1.java\n@@ -0,0 +1,37 @@\n+class MinStack {\n+\n+    private Stack<Integer> _data;\n+    private Stack<Integer> _min;\n+\n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        _data = new Stack<>();\n+        _min = new Stack<>();\n+    }\n+    \n+    public void push(int x) {\n+        _data.add(x);\n+        if (_min.isEmpty()){\n+            _min.push(x);\n+        }\n+        else{\n+            if (x > _min.peek()){\n+                x = _min.peek();\n+            }\n+            _min.push(x);\n+        }\n+    }\n+    \n+    public void pop() {\n+        _data.pop();\n+        _min.pop();\n+    }\n+    \n+    public int top() {\n+        return _data.peek();\n+    }\n+    \n+    public int getMin() {\n+        return _min.peek();\n+    }\n+}\n\\ No newline at end of file\n\ndiff --git a/0215-Kth-Largest-Element-in-an-Array/Code/1.java b/0215-Kth-Largest-Element-in-an-Array/Code/1.java\n--- a/0215-Kth-Largest-Element-in-an-Array/Code/1.java\n+++ b/0215-Kth-Largest-Element-in-an-Array/Code/1.java\n@@ -0,0 +1,18 @@\n+class Solution {\n+    public int findKthLargest(int[] nums, int k) {\n+        // // ����һ��С���ѣ����ȶ���ģ�⣩\n+        PriorityQueue<Integer> heap =\n+            new PriorityQueue<Integer>();\n+\n+        // �ڶ���ά����ǰ���k��Ԫ��\n+        for (int i = 0; i < nums.length; i++){\n+            if(heap.size() < k){\n+                heap.add(nums[i]);\n+            }else if (heap.element() < nums[i]){\n+                heap.poll();\n+                heap.add(nums[i]);\n+            }\n+        }\n+        return heap.poll();        \n+  }\n+}\n\\ No newline at end of file\n\ndiff --git a/0290-Word-Pattern/Code/1.java b/0290-Word-Pattern/Code/1.java\n--- a/0290-Word-Pattern/Code/1.java\n+++ b/0290-Word-Pattern/Code/1.java\n@@ -0,0 +1,26 @@\n+class Solution {\n+    public boolean wordPattern(String pattern, String str) {\n+        HashMap<Character, String> map = new HashMap<>();\n+        HashSet<String> set = new HashSet<>();\n+        String[] array = str.split(\" \");\n+\n+        if (pattern.length() != array.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < pattern.length(); i++) {\n+            char key = pattern.charAt(i);\n+            if (!map.containsKey(key)) {\n+                if (set.contains(array[i])) {\n+                    return false;\n+                }\n+                map.put(key, array[i]);\n+                set.add(array[i]);\n+            } else {\n+                if (!map.get(key).equals(array[i])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n\\ No newline at end of file\n\ndiff --git a/0394-Decode-String/Code/1.java b/0394-Decode-String/Code/1.java\n--- a/0394-Decode-String/Code/1.java\n+++ b/0394-Decode-String/Code/1.java\n@@ -0,0 +1,34 @@\n+class Solution {\n+    public String decodeString(String s) {\n+        StringBuilder res = new StringBuilder();\n+        int multi = 0;\n+\n+        Stack<Integer> stack_multi = new Stack();\n+        Stack<String> stack_res = new Stack();\n+\n+        for (int i = 0; i < s.length(); i++) {\n+            char c = s.charAt(i);\n+            if ('[' == c){\n+                stack_multi.push(multi);\n+                stack_res.push(res.toString());\n+                multi = 0;\n+                res = new StringBuilder();\n+            }\n+            else if (']' == c) {\n+                StringBuilder tmp = new StringBuilder();\n+                int cur_multi = stack_multi.pop();\n+                for (int j = 0; j < cur_multi; j++){\n+                    tmp.append(res);\n+                }\n+                res = new StringBuilder(stack_res.pop() + tmp);\n+            }\n+            else if(c >= '0' && c <= '9'){\n+                multi = multi * 10 + (c - '0');\n+            }\n+            else{\n+                res.append(c);\n+            }\n+        }\n+        return res.toString();\n+    }\n+}\n\\ No newline at end of file\n\ndiff --git a/0946--validate-stack-sequences/Code/1.java b/0946--validate-stack-sequences/Code/1.java\n--- a/0946--validate-stack-sequences/Code/1.java\n+++ b/0946--validate-stack-sequences/Code/1.java\n@@ -0,0 +1,21 @@\n+class Solution {\n+    public boolean validateStackSequences(int[] pushed, int[] popped) {\n+        \n+        int N = pushed.length;\n+        Stack<Integer> stack = new Stack();\n+        \n+        int j = 0;\n+        for (int x: pushed) {\n+            stack.push(x);\n+            while (!stack.isEmpty() && j < N && stack.peek() == popped[j]) {\n+                //��ͷԪ�س��ӣ�ջ��Ԫ�س�ջ\n+                stack.pop();\n+                j++;\n+            }\n+        }\n+        if (!stack.isEmpty()){\n+            return false;\n+        }\n+        return true;\n+    }\n+}\n\\ No newline at end of file",
    "output": "Merge pull request #57 from zjming/master\n\n0155-0215-0290-0394-0946"
  },
  {
    "input": "diff --git a/0155-min-stack/Code/1.java b/0155-min-stack/Code/1.java\n--- a/0155-min-stack/Code/1.java\n+++ b/0155-min-stack/Code/1.java\n@@ -0,0 +1,37 @@\n+class MinStack {\n+\n+    private Stack<Integer> _data;\n+    private Stack<Integer> _min;\n+\n+    /** initialize your data structure here. */\n+    public MinStack() {\n+        _data = new Stack<>();\n+        _min = new Stack<>();\n+    }\n+    \n+    public void push(int x) {\n+        _data.add(x);\n+        if (_min.isEmpty()){\n+            _min.push(x);\n+        }\n+        else{\n+            if (x > _min.peek()){\n+                x = _min.peek();\n+            }\n+            _min.push(x);\n+        }\n+    }\n+    \n+    public void pop() {\n+        _data.pop();\n+        _min.pop();\n+    }\n+    \n+    public int top() {\n+        return _data.peek();\n+    }\n+    \n+    public int getMin() {\n+        return _min.peek();\n+    }\n+}\n\\ No newline at end of file\n\ndiff --git a/0215-Kth-Largest-Element-in-an-Array/Code/1.java b/0215-Kth-Largest-Element-in-an-Array/Code/1.java\n--- a/0215-Kth-Largest-Element-in-an-Array/Code/1.java\n+++ b/0215-Kth-Largest-Element-in-an-Array/Code/1.java\n@@ -0,0 +1,18 @@\n+class Solution {\n+    public int findKthLargest(int[] nums, int k) {\n+        // // ����һ��С���ѣ����ȶ���ģ�⣩\n+        PriorityQueue<Integer> heap =\n+            new PriorityQueue<Integer>();\n+\n+        // �ڶ���ά����ǰ���k��Ԫ��\n+        for (int i = 0; i < nums.length; i++){\n+            if(heap.size() < k){\n+                heap.add(nums[i]);\n+            }else if (heap.element() < nums[i]){\n+                heap.poll();\n+                heap.add(nums[i]);\n+            }\n+        }\n+        return heap.poll();        \n+  }\n+}\n\\ No newline at end of file\n\ndiff --git a/0290-Word-Pattern/Code/1.java b/0290-Word-Pattern/Code/1.java\n--- a/0290-Word-Pattern/Code/1.java\n+++ b/0290-Word-Pattern/Code/1.java\n@@ -0,0 +1,26 @@\n+class Solution {\n+    public boolean wordPattern(String pattern, String str) {\n+        HashMap<Character, String> map = new HashMap<>();\n+        HashSet<String> set = new HashSet<>();\n+        String[] array = str.split(\" \");\n+\n+        if (pattern.length() != array.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < pattern.length(); i++) {\n+            char key = pattern.charAt(i);\n+            if (!map.containsKey(key)) {\n+                if (set.contains(array[i])) {\n+                    return false;\n+                }\n+                map.put(key, array[i]);\n+                set.add(array[i]);\n+            } else {\n+                if (!map.get(key).equals(array[i])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n\\ No newline at end of file\n\ndiff --git a/0394-Decode-String/Code/1.java b/0394-Decode-String/Code/1.java\n--- a/0394-Decode-String/Code/1.java\n+++ b/0394-Decode-String/Code/1.java\n@@ -0,0 +1,34 @@\n+class Solution {\n+    public String decodeString(String s) {\n+        StringBuilder res = new StringBuilder();\n+        int multi = 0;\n+\n+        Stack<Integer> stack_multi = new Stack();\n+        Stack<String> stack_res = new Stack();\n+\n+        for (int i = 0; i < s.length(); i++) {\n+            char c = s.charAt(i);\n+            if ('[' == c){\n+                stack_multi.push(multi);\n+                stack_res.push(res.toString());\n+                multi = 0;\n+                res = new StringBuilder();\n+            }\n+            else if (']' == c) {\n+                StringBuilder tmp = new StringBuilder();\n+                int cur_multi = stack_multi.pop();\n+                for (int j = 0; j < cur_multi; j++){\n+                    tmp.append(res);\n+                }\n+                res = new StringBuilder(stack_res.pop() + tmp);\n+            }\n+            else if(c >= '0' && c <= '9'){\n+                multi = multi * 10 + (c - '0');\n+            }\n+            else{\n+                res.append(c);\n+            }\n+        }\n+        return res.toString();\n+    }\n+}\n\\ No newline at end of file\n\ndiff --git a/0946--validate-stack-sequences/Code/1.java b/0946--validate-stack-sequences/Code/1.java\n--- a/0946--validate-stack-sequences/Code/1.java\n+++ b/0946--validate-stack-sequences/Code/1.java\n@@ -0,0 +1,21 @@\n+class Solution {\n+    public boolean validateStackSequences(int[] pushed, int[] popped) {\n+        \n+        int N = pushed.length;\n+        Stack<Integer> stack = new Stack();\n+        \n+        int j = 0;\n+        for (int x: pushed) {\n+            stack.push(x);\n+            while (!stack.isEmpty() && j < N && stack.peek() == popped[j]) {\n+                //��ͷԪ�س��ӣ�ջ��Ԫ�س�ջ\n+                stack.pop();\n+                j++;\n+            }\n+        }\n+        if (!stack.isEmpty()){\n+            return false;\n+        }\n+        return true;\n+    }\n+}\n\\ No newline at end of file",
    "output": "Solved @zjming"
  },
  {
    "input": "diff --git a/0279-Perfect-Squares/java-0279/src/Solution1.java b/0279-Perfect-Squares/java-0279/src/Solution1.java\n--- a/0279-Perfect-Squares/java-0279/src/Solution1.java\n+++ b/0279-Perfect-Squares/java-0279/src/Solution1.java\n@@ -0,0 +1,50 @@\n+/// Source : https://leetcode.com/problems/perfect-squares/description/\n+/// Author : liuyubobobo\n+/// Time   : 2017-11-17\n+\n+import java.util.LinkedList;\n+import javafx.util.Pair;\n+\n+/// BFS\n+/// Time Complexity: O(n)\n+/// Space Complexity: O(n)\n+public class Solution1 {\n+\n+    public int numSquares(int n) {\n+\n+        if(n == 0)\n+            return 0;\n+\n+        LinkedList<Pair<Integer, Integer>> queue = new LinkedList<Pair<Integer, Integer>>();\n+        queue.addLast(new Pair<Integer, Integer>(n, 0));\n+\n+        boolean[] visited = new boolean[n+1];\n+        visited[n] = true;\n+\n+        while(!queue.isEmpty()){\n+            Pair<Integer, Integer> front = queue.removeFirst();\n+            int num = front.getKey();\n+            int step = front.getValue();\n+\n+            if(num == 0)\n+                return step;\n+\n+            for(int i = 1 ; num - i*i >= 0 ; i ++){\n+                int a = num - i*i;\n+                if(!visited[a]){\n+                    if(a == 0) return step + 1;\n+                    queue.addLast(new Pair(num - i * i, step + 1));\n+                    visited[num - i * i] = true;\n+                }\n+            }\n+        }\n+\n+        throw new IllegalStateException(\"No Solution.\");\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        System.out.println((new Solution1()).numSquares(12));\n+        System.out.println((new Solution1()).numSquares(13));\n+    }\n+}\n\ndiff --git a/0279-Perfect-Squares/java-0279/src/Solution2.java b/0279-Perfect-Squares/java-0279/src/Solution2.java\n--- a/0279-Perfect-Squares/java-0279/src/Solution2.java\n+++ b/0279-Perfect-Squares/java-0279/src/Solution2.java\n@@ -0,0 +1,39 @@\n+/// Source : https://leetcode.com/problems/perfect-squares/description/\n+/// Author : liuyubobobo\n+/// Time   : 2017-11-17\n+\n+import java.util.Arrays;\n+\n+/// Memory Search\n+/// Time Complexity: O(n)\n+/// Space Complexity: O(n)\n+public class Solution2 {\n+\n+    public int numSquares(int n) {\n+\n+        int[] mem = new int[n+1];\n+        Arrays.fill(mem, -1);\n+\n+        return numSquares(n, mem);\n+    }\n+\n+    private int numSquares(int n, int[] mem){\n+\n+        if(n == 0)\n+            return 0;\n+\n+        if(mem[n] != -1)\n+            return mem[n];\n+\n+        int res = Integer.MAX_VALUE;\n+        for(int i = 1; n - i * i >= 0; i ++ )\n+            res = Math.min(res, 1 + numSquares(n - i * i, mem));\n+        return mem[n] = res;\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        System.out.println((new Solution2()).numSquares(12));\n+        System.out.println((new Solution2()).numSquares(13));\n+    }\n+}\n\ndiff --git a/0279-Perfect-Squares/java-0279/src/Solution3.java b/0279-Perfect-Squares/java-0279/src/Solution3.java\n--- a/0279-Perfect-Squares/java-0279/src/Solution3.java\n+++ b/0279-Perfect-Squares/java-0279/src/Solution3.java\n@@ -0,0 +1,29 @@\n+/// Source : https://leetcode.com/problems/perfect-squares/description/\n+/// Author : liuyubobobo\n+/// Time   : 2017-11-17\n+\n+import java.util.Arrays;\n+\n+/// Dynamic Programming\n+/// Time Complexity: O(n)\n+/// Space Complexity: O(n)\n+public class Solution3 {\n+\n+    public int numSquares(int n) {\n+\n+        int[] mem = new int[n+1];\n+        Arrays.fill(mem, Integer.MAX_VALUE);\n+        mem[0] = 0;\n+        for(int i = 1; i <= n ; i ++)\n+            for(int j = 1 ; i - j * j >= 0 ; j ++)\n+                mem[i] = Math.min(mem[i], 1 + mem[i - j * j]);\n+\n+        return mem[n];\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        System.out.println((new Solution3()).numSquares(12));\n+        System.out.println((new Solution3()).numSquares(13));\n+    }\n+}",
    "output": "Add 279 code"
  }
]