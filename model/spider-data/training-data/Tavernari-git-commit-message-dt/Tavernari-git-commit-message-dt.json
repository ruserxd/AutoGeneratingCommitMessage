[
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/graphs/PrimMST.java b/src/main/java/com/thealgorithms/datastructures/graphs/PrimMST.java\nindex 7e11862786f6..8017c18ce6ac 100644\n--- a/src/main/java/com/thealgorithms/datastructures/graphs/PrimMST.java\n+++ b/src/main/java/com/thealgorithms/datastructures/graphs/PrimMST.java\n@@ -1,19 +1,17 @@\n package com.thealgorithms.datastructures.graphs;\n \n /**\n- * A Java program for Prim's Minimum Spanning Tree (MST) algorithm. adjacency\n- * matrix representation of the graph\n+ * A Java program for Prim's Minimum Spanning Tree (MST) algorithm.\n+ * Adjacency matrix representation of the graph.\n  */\n-class PrimMST {\n+public class PrimMST {\n \n     // Number of vertices in the graph\n-\n     private static final int V = 5;\n \n-    // A utility function to find the vertex with minimum key\n-    // value, from the set of vertices not yet included in MST\n+    // A utility function to find the vertex with the minimum key\n+    // value, from the set of vertices not yet included in the MST\n     int minKey(int[] key, Boolean[] mstSet) {\n-        // Initialize min value\n         int min = Integer.MAX_VALUE;\n         int minIndex = -1;\n \n@@ -27,54 +25,30 @@ int minKey(int[] key, Boolean[] mstSet) {\n         return minIndex;\n     }\n \n-    // A utility function to print the constructed MST stored in\n-    // parent[]\n-    void printMST(int[] parent, int n, int[][] graph) {\n-        System.out.println(\"Edge   Weight\");\n-        for (int i = 1; i < V; i++) {\n-            System.out.println(parent[i] + \" - \" + i + \"    \" + graph[i][parent[i]]);\n-        }\n-    }\n-\n-    // Function to construct and print MST for a graph represented\n-    //  using adjacency matrix representation\n-    void primMST(int[][] graph) {\n-        // Array to store constructed MST\n-        int[] parent = new int[V];\n-\n-        // Key values used to pick minimum weight edge in cut\n-        int[] key = new int[V];\n+    // Function to construct MST for a graph using adjacency matrix representation\n+    public int[] primMST(int[][] graph) {\n+        int[] parent = new int[V]; // Array to store constructed MST\n+        int[] key = new int[V]; // Key values to pick minimum weight edge\n+        Boolean[] mstSet = new Boolean[V]; // Vertices not yet included in MST\n \n-        // To represent set of vertices not yet included in MST\n-        Boolean[] mstSet = new Boolean[V];\n-\n-        // Initialize all keys as INFINITE\n+        // Initialize all keys as INFINITE and mstSet[] as false\n         for (int i = 0; i < V; i++) {\n             key[i] = Integer.MAX_VALUE;\n             mstSet[i] = Boolean.FALSE;\n         }\n \n-        // Always include first 1st vertex in MST.\n-        key[0] = 0; // Make key 0 so that this vertex is\n-        // picked as first vertex\n+        // Always include the first vertex in MST\n+        key[0] = 0; // Make key 0 to pick the first vertex\n         parent[0] = -1; // First node is always root of MST\n \n         // The MST will have V vertices\n         for (int count = 0; count < V - 1; count++) {\n-            // Pick thd minimum key vertex from the set of vertices\n-            // not yet included in MST\n+            // Pick the minimum key vertex not yet included in MST\n             int u = minKey(key, mstSet);\n-\n-            // Add the picked vertex to the MST Set\n             mstSet[u] = Boolean.TRUE;\n \n-            // Update key value and parent index of the adjacent\n-            // vertices of the picked vertex. Consider only those\n-            // vertices which are not yet included in MST\n-            for (int v = 0; v < V; v++) // Update the key only if graph[u][v] is smaller than key[v] // mstSet[v] is\n-                                        // false for vertices not yet included in MST // graph[u][v] is non zero only\n-                                        // for adjacent vertices of m\n-            {\n+            // Update key value and parent index of adjacent vertices of the picked vertex\n+            for (int v = 0; v < V; v++) {\n                 if (graph[u][v] != 0 && !mstSet[v] && graph[u][v] < key[v]) {\n                     parent[v] = u;\n                     key[v] = graph[u][v];\n@@ -82,29 +56,6 @@ void primMST(int[][] graph) {\n             }\n         }\n \n-        // print the constructed MST\n-        printMST(parent, V, graph);\n-    }\n-\n-    public static void main(String[] args) {\n-        /* Let us create the following graph\n-       2    3\n-    (0)--(1)--(2)\n-    |    / \\   |\n-    6| 8/   \\5 |7\n-    | /      \\ |\n-    (3)-------(4)\n-         9          */\n-        PrimMST t = new PrimMST();\n-        int[][] graph = new int[][] {\n-            {0, 2, 0, 6, 0},\n-            {2, 0, 3, 8, 5},\n-            {0, 3, 0, 0, 7},\n-            {6, 8, 0, 0, 9},\n-            {0, 5, 7, 9, 0},\n-        };\n-\n-        // Print the solution\n-        t.primMST(graph);\n+        return parent; // Return the MST parent array\n     }\n }\ndiff --git a/src/test/java/com/thealgorithms/datastructures/graphs/PrimMSTTest.java b/src/test/java/com/thealgorithms/datastructures/graphs/PrimMSTTest.java\nnew file mode 100644\nindex 000000000000..ec59a3880642\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/datastructures/graphs/PrimMSTTest.java\n@@ -0,0 +1,54 @@\n+package com.thealgorithms.datastructures.graphs;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class PrimMSTTest {\n+\n+    private final PrimMST primMST = new PrimMST();\n+\n+    @Test\n+    public void testSimpleGraph() {\n+        // Test graph with 5 nodes and weighted edges\n+        int[][] graph = {{0, 2, 0, 6, 0}, {2, 0, 3, 8, 5}, {0, 3, 0, 0, 7}, {6, 8, 0, 0, 9}, {0, 5, 7, 9, 0}};\n+\n+        int[] expectedParent = {-1, 0, 1, 0, 1};\n+        int[] actualParent = primMST.primMST(graph);\n+\n+        assertArrayEquals(expectedParent, actualParent);\n+    }\n+\n+    @Test\n+    public void testDisconnectedGraph() {\n+        // Test case with a disconnected graph (no valid MST)\n+        int[][] graph = {{0, 1, 0, 0, 0}, {1, 0, 2, 0, 0}, {0, 2, 0, 3, 0}, {0, 0, 3, 0, 4}, {0, 0, 0, 4, 0}};\n+\n+        int[] expectedParent = {-1, 0, 1, 2, 3}; // Expected MST parent array\n+        int[] actualParent = primMST.primMST(graph);\n+\n+        assertArrayEquals(expectedParent, actualParent);\n+    }\n+\n+    @Test\n+    public void testAllEqualWeightsGraph() {\n+        // Test case where all edges have equal weight\n+        int[][] graph = {{0, 1, 1, 1, 1}, {1, 0, 1, 1, 1}, {1, 1, 0, 1, 1}, {1, 1, 1, 0, 1}, {1, 1, 1, 1, 0}};\n+\n+        int[] expectedParent = {-1, 0, 0, 0, 0}; // Expected MST parent array (any valid spanning tree)\n+        int[] actualParent = primMST.primMST(graph);\n+\n+        assertArrayEquals(expectedParent, actualParent);\n+    }\n+\n+    @Test\n+    public void testSparseGraph() {\n+        // Test case with a sparse graph (few edges)\n+        int[][] graph = {{0, 1, 0, 0, 0}, {1, 0, 1, 0, 0}, {0, 1, 0, 1, 0}, {0, 0, 1, 0, 1}, {0, 0, 0, 1, 0}};\n+\n+        int[] expectedParent = {-1, 0, 1, 2, 3}; // Expected MST parent array\n+        int[] actualParent = primMST.primMST(graph);\n+\n+        assertArrayEquals(expectedParent, actualParent);\n+    }\n+}",
    "output": {
      "why": "The changes enhance the code's functionality by adding a comprehensive set of unit tests for the Prim's Minimum Spanning Tree algorithm. The visibility of the `PrimMST` class has been updated to public, allowing it to be easily instantiated in tests. Cleaner comments improve understanding, and modifications enforce a proper function output.",
      "commit_message": "Add unit tests for PrimMST and adjust visibility\n- Introduced `PrimMSTTest.java`, containing multiple unit tests to validate the functionality of Prim's MST algorithm.\n- Made the `PrimMST` class public to facilitate its use in testing.\n- Enhanced comments in PrimMST.java for improved clarity and readability.\n- Modified the `primMST` function to return the MST parent array, aligning with expected behavior for unit tests."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/heaps/Heap.java b/src/main/java/com/thealgorithms/datastructures/heaps/Heap.java\nindex 63e101d9b13d..8cb93edf78f3 100644\n--- a/src/main/java/com/thealgorithms/datastructures/heaps/Heap.java\n+++ b/src/main/java/com/thealgorithms/datastructures/heaps/Heap.java\n@@ -40,5 +40,5 @@ public interface Heap {\n      * @param elementIndex int containing the position in the heap of the\n      * element to be deleted.\n      */\n-    void deleteElement(int elementIndex);\n+    void deleteElement(int elementIndex) throws EmptyHeapException;\n }\ndiff --git a/src/main/java/com/thealgorithms/datastructures/heaps/HeapElement.java b/src/main/java/com/thealgorithms/datastructures/heaps/HeapElement.java\nindex 20f33bd2d146..57cc9e37122d 100644\n--- a/src/main/java/com/thealgorithms/datastructures/heaps/HeapElement.java\n+++ b/src/main/java/com/thealgorithms/datastructures/heaps/HeapElement.java\n@@ -167,4 +167,8 @@ public int hashCode() {\n         result += (additionalInfo != null) ? additionalInfo.hashCode() : 0;\n         return result;\n     }\n+\n+    public String getValue() {\n+        return additionalInfo.toString();\n+    }\n }\ndiff --git a/src/main/java/com/thealgorithms/datastructures/heaps/MinHeap.java b/src/main/java/com/thealgorithms/datastructures/heaps/MinHeap.java\nindex 46864fba0047..3a4822142b5f 100644\n--- a/src/main/java/com/thealgorithms/datastructures/heaps/MinHeap.java\n+++ b/src/main/java/com/thealgorithms/datastructures/heaps/MinHeap.java\n@@ -4,8 +4,25 @@\n import java.util.List;\n \n /**\n- * Heap tree where a node's key is higher than or equal to its parent's and\n- * lower than or equal to its children's.\n+ * A Min Heap implementation where each node's key is lower than or equal to its children's keys.\n+ * This data structure provides O(log n) time complexity for insertion and deletion operations,\n+ * and O(1) for retrieving the minimum element.\n+ *\n+ * Properties:\n+ * 1. Complete Binary Tree\n+ * 2. Parent node's key ≤ Children nodes' keys\n+ * 3. Root contains the minimum element\n+ *\n+ * Example usage:\n+ * ```java\n+ * List<HeapElement> elements = Arrays.asList(\n+ *     new HeapElement(5, \"Five\"),\n+ *     new HeapElement(2, \"Two\")\n+ * );\n+ * MinHeap heap = new MinHeap(elements);\n+ * heap.insertElement(new HeapElement(1, \"One\"));\n+ * HeapElement min = heap.getElement(); // Returns and removes the minimum element\n+ * ```\n  *\n  * @author Nicolas Renard\n  */\n@@ -13,113 +30,242 @@ public class MinHeap implements Heap {\n \n     private final List<HeapElement> minHeap;\n \n+    /**\n+     * Constructs a new MinHeap from a list of elements.\n+     * Null elements in the input list are ignored with a warning message.\n+     *\n+     * @param listElements List of HeapElement objects to initialize the heap\n+     * @throws IllegalArgumentException if the input list is null\n+     */\n     public MinHeap(List<HeapElement> listElements) {\n+        if (listElements == null) {\n+            throw new IllegalArgumentException(\"Input list cannot be null\");\n+        }\n+\n         minHeap = new ArrayList<>();\n+\n+        // Safe initialization: directly add elements first\n         for (HeapElement heapElement : listElements) {\n             if (heapElement != null) {\n-                insertElement(heapElement);\n+                minHeap.add(heapElement);\n             } else {\n                 System.out.println(\"Null element. Not added to heap\");\n             }\n         }\n+\n+        // Heapify the array bottom-up\n+        for (int i = minHeap.size() / 2; i >= 0; i--) {\n+            heapifyDown(i + 1);\n+        }\n+\n         if (minHeap.isEmpty()) {\n             System.out.println(\"No element has been added, empty heap.\");\n         }\n     }\n \n-    // Get the element at a given index. The key for the list is equal to index value - 1\n+    /**\n+     * Retrieves the element at the specified index without removing it.\n+     * Note: The index is 1-based for consistency with heap operations.\n+     *\n+     * @param elementIndex 1-based index of the element to retrieve\n+     * @return HeapElement at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n     public HeapElement getElement(int elementIndex) {\n         if ((elementIndex <= 0) || (elementIndex > minHeap.size())) {\n-            throw new IndexOutOfBoundsException(\"Index out of heap range\");\n+            throw new IndexOutOfBoundsException(\"Index \" + elementIndex + \" is out of heap range [1, \" + minHeap.size() + \"]\");\n         }\n         return minHeap.get(elementIndex - 1);\n     }\n \n-    // Get the key of the element at a given index\n+    /**\n+     * Retrieves the key value of an element at the specified index.\n+     *\n+     * @param elementIndex 1-based index of the element\n+     * @return double value representing the key\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n     private double getElementKey(int elementIndex) {\n         if ((elementIndex <= 0) || (elementIndex > minHeap.size())) {\n-            throw new IndexOutOfBoundsException(\"Index out of heap range\");\n+            throw new IndexOutOfBoundsException(\"Index \" + elementIndex + \" is out of heap range [1, \" + minHeap.size() + \"]\");\n         }\n-\n         return minHeap.get(elementIndex - 1).getKey();\n     }\n \n-    // Swaps two elements in the heap\n+    /**\n+     * Swaps two elements in the heap.\n+     *\n+     * @param index1 1-based index of first element\n+     * @param index2 1-based index of second element\n+     */\n     private void swap(int index1, int index2) {\n         HeapElement temporaryElement = minHeap.get(index1 - 1);\n         minHeap.set(index1 - 1, minHeap.get(index2 - 1));\n         minHeap.set(index2 - 1, temporaryElement);\n     }\n \n-    // Toggle an element up to its right place as long as its key is lower than its parent's\n+    /**\n+     * Maintains heap properties by moving an element down the heap.\n+     * Used specifically during initialization.\n+     *\n+     * @param elementIndex 1-based index of the element to heapify\n+     */\n+    private void heapifyDown(int elementIndex) {\n+        int smallest = elementIndex - 1; // Convert to 0-based index\n+        int leftChild = 2 * elementIndex - 1;\n+        int rightChild = 2 * elementIndex;\n+\n+        // Check if left child is smaller than root\n+        if (leftChild < minHeap.size() && minHeap.get(leftChild).getKey() < minHeap.get(smallest).getKey()) {\n+            smallest = leftChild;\n+        }\n+\n+        // Check if right child is smaller than smallest so far\n+        if (rightChild < minHeap.size() && minHeap.get(rightChild).getKey() < minHeap.get(smallest).getKey()) {\n+            smallest = rightChild;\n+        }\n+\n+        // If smallest is not root\n+        if (smallest != elementIndex - 1) {\n+            HeapElement swap = minHeap.get(elementIndex - 1);\n+            minHeap.set(elementIndex - 1, minHeap.get(smallest));\n+            minHeap.set(smallest, swap);\n+\n+            // Recursively heapify the affected sub-tree\n+            heapifyDown(smallest + 1); // Convert back to 1-based index\n+        }\n+    }\n+\n+    /**\n+     * Moves an element up the heap until heap properties are satisfied.\n+     * This operation is called after insertion to maintain heap properties.\n+     *\n+     * @param elementIndex 1-based index of the element to move up\n+     */\n     private void toggleUp(int elementIndex) {\n+        if (elementIndex <= 1) {\n+            return;\n+        }\n+\n         double key = minHeap.get(elementIndex - 1).getKey();\n-        while (getElementKey((int) Math.floor(elementIndex / 2.0) + 1) > key) {\n-            swap(elementIndex, (int) Math.floor(elementIndex / 2.0));\n-            elementIndex = (int) Math.floor(elementIndex / 2.0);\n+        int parentIndex = (int) Math.floor(elementIndex / 2.0);\n+\n+        while (elementIndex > 1 && getElementKey(parentIndex) > key) {\n+            swap(elementIndex, parentIndex);\n+            elementIndex = parentIndex;\n+            parentIndex = (int) Math.floor(elementIndex / 2.0);\n         }\n     }\n \n-    // Toggle an element down to its right place as long as its key is higher\n-    // than any of its children's\n+    /**\n+     * Moves an element down the heap until heap properties are satisfied.\n+     * This operation is called after deletion to maintain heap properties.\n+     *\n+     * @param elementIndex 1-based index of the element to move down\n+     */\n     private void toggleDown(int elementIndex) {\n         double key = minHeap.get(elementIndex - 1).getKey();\n-        boolean wrongOrder = (key > getElementKey(elementIndex * 2)) || (key > getElementKey(Math.min(elementIndex * 2, minHeap.size())));\n-        while ((2 * elementIndex <= minHeap.size()) && wrongOrder) {\n-            // Check whether it shall swap the element with its left child or its right one if any.\n-            if ((2 * elementIndex < minHeap.size()) && (getElementKey(elementIndex * 2 + 1) < getElementKey(elementIndex * 2))) {\n-                swap(elementIndex, 2 * elementIndex + 1);\n-                elementIndex = 2 * elementIndex + 1;\n-            } else {\n-                swap(elementIndex, 2 * elementIndex);\n-                elementIndex = 2 * elementIndex;\n+        int size = minHeap.size();\n+\n+        while (true) {\n+            int smallest = elementIndex;\n+            int leftChild = 2 * elementIndex;\n+            int rightChild = 2 * elementIndex + 1;\n+\n+            if (leftChild <= size && getElementKey(leftChild) < key) {\n+                smallest = leftChild;\n+            }\n+\n+            if (rightChild <= size && getElementKey(rightChild) < getElementKey(smallest)) {\n+                smallest = rightChild;\n+            }\n+\n+            if (smallest == elementIndex) {\n+                break;\n             }\n-            wrongOrder = (key > getElementKey(elementIndex * 2)) || (key > getElementKey(Math.min(elementIndex * 2, minHeap.size())));\n+\n+            swap(elementIndex, smallest);\n+            elementIndex = smallest;\n         }\n     }\n \n-    private HeapElement extractMin() {\n-        HeapElement result = minHeap.get(0);\n-        deleteElement(0);\n+    /**\n+     * Extracts and returns the minimum element from the heap.\n+     *\n+     * @return HeapElement with the lowest key\n+     * @throws EmptyHeapException if the heap is empty\n+     */\n+    private HeapElement extractMin() throws EmptyHeapException {\n+        if (minHeap.isEmpty()) {\n+            throw new EmptyHeapException(\"Cannot extract from empty heap\");\n+        }\n+        HeapElement result = minHeap.getFirst();\n+        deleteElement(1);\n         return result;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     @Override\n-    public final void insertElement(HeapElement element) {\n+    public void insertElement(HeapElement element) {\n+        if (element == null) {\n+            throw new IllegalArgumentException(\"Cannot insert null element\");\n+        }\n         minHeap.add(element);\n         toggleUp(minHeap.size());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     @Override\n-    public void deleteElement(int elementIndex) {\n+    public void deleteElement(int elementIndex) throws EmptyHeapException {\n         if (minHeap.isEmpty()) {\n-            try {\n-                throw new EmptyHeapException(\"Attempt to delete an element from an empty heap\");\n-            } catch (EmptyHeapException e) {\n-                e.printStackTrace();\n-            }\n+            throw new EmptyHeapException(\"Cannot delete from empty heap\");\n         }\n         if ((elementIndex > minHeap.size()) || (elementIndex <= 0)) {\n-            throw new IndexOutOfBoundsException(\"Index out of heap range\");\n-        }\n-        // The last element in heap replaces the one to be deleted\n-        minHeap.set(elementIndex - 1, getElement(minHeap.size()));\n-        minHeap.remove(minHeap.size());\n-        // Shall the new element be moved up...\n-        if (getElementKey(elementIndex) < getElementKey((int) Math.floor(elementIndex / 2.0))) {\n-            toggleUp(elementIndex);\n-        } // ... or down ?\n-        else if (((2 * elementIndex <= minHeap.size()) && (getElementKey(elementIndex) > getElementKey(elementIndex * 2))) || ((2 * elementIndex < minHeap.size()) && (getElementKey(elementIndex) > getElementKey(elementIndex * 2)))) {\n-            toggleDown(elementIndex);\n+            throw new IndexOutOfBoundsException(\"Index \" + elementIndex + \" is out of heap range [1, \" + minHeap.size() + \"]\");\n+        }\n+\n+        // Replace with last element and remove last position\n+        minHeap.set(elementIndex - 1, minHeap.getLast());\n+        minHeap.removeLast();\n+\n+        // No need to toggle if we just removed the last element\n+        if (!minHeap.isEmpty() && elementIndex <= minHeap.size()) {\n+            // Determine whether to toggle up or down\n+            if (elementIndex > 1 && getElementKey(elementIndex) < getElementKey((int) Math.floor(elementIndex / 2.0))) {\n+                toggleUp(elementIndex);\n+            } else {\n+                toggleDown(elementIndex);\n+            }\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     @Override\n     public HeapElement getElement() throws EmptyHeapException {\n-        try {\n-            return extractMin();\n-        } catch (Exception e) {\n-            throw new EmptyHeapException(\"Heap is empty. Error retrieving element\", e);\n-        }\n+        return extractMin();\n+    }\n+\n+    /**\n+     * Returns the current size of the heap.\n+     *\n+     * @return number of elements in the heap\n+     */\n+    public int size() {\n+        return minHeap.size();\n+    }\n+\n+    /**\n+     * Checks if the heap is empty.\n+     *\n+     * @return true if the heap contains no elements\n+     */\n+    public boolean isEmpty() {\n+        return minHeap.isEmpty();\n     }\n }\ndiff --git a/src/test/java/com/thealgorithms/datastructures/heaps/MinHeapTest.java b/src/test/java/com/thealgorithms/datastructures/heaps/MinHeapTest.java\nnew file mode 100644\nindex 000000000000..1c2caf54cdb1\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/datastructures/heaps/MinHeapTest.java\n@@ -0,0 +1,141 @@\n+package com.thealgorithms.datastructures.heaps;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+class MinHeapTest {\n+\n+    private MinHeap heap;\n+\n+    @BeforeEach\n+    void setUp() {\n+        // Create a fresh heap for each test\n+        List<HeapElement> elements = Arrays.asList(new HeapElement(5.0, \"Five\"), new HeapElement(2.0, \"Two\"), new HeapElement(8.0, \"Eight\"), new HeapElement(1.0, \"One\"), new HeapElement(9.0, \"Nine\"));\n+        heap = new MinHeap(elements);\n+    }\n+\n+    @Test\n+    void testConstructorWithNullList() {\n+        assertThrows(IllegalArgumentException.class, () -> new MinHeap(null));\n+    }\n+\n+    @Test\n+    void testConstructorWithEmptyList() {\n+        MinHeap emptyHeap = new MinHeap(new ArrayList<>());\n+        assertTrue(emptyHeap.isEmpty());\n+    }\n+\n+    @Test\n+    void testConstructorWithNullElements() {\n+        List<HeapElement> elements = Arrays.asList(new HeapElement(1.0, \"One\"), null, new HeapElement(2.0, \"Two\"));\n+        MinHeap heap = new MinHeap(elements);\n+        assertEquals(2, heap.size());\n+    }\n+\n+    @Test\n+    void testInsertElement() {\n+        heap.insertElement(new HeapElement(0.5, \"Half\"));\n+        assertEquals(0.5, heap.getElement(1).getKey());\n+        assertEquals(6, heap.size());\n+    }\n+\n+    @Test\n+    void testInsertNullElement() {\n+        assertThrows(IllegalArgumentException.class, () -> heap.insertElement(null));\n+    }\n+\n+    @Test\n+    void testGetElementAtIndex() {\n+        HeapElement element = heap.getElement(1);\n+        assertEquals(1.0, element.getKey());\n+        assertEquals(\"One\", element.getValue());\n+    }\n+\n+    @Test\n+    void testGetElementAtInvalidIndex() {\n+        assertThrows(IndexOutOfBoundsException.class, () -> heap.getElement(0));\n+        assertThrows(IndexOutOfBoundsException.class, () -> heap.getElement(10));\n+    }\n+\n+    @Test\n+    void testDeleteElement() throws EmptyHeapException {\n+        heap.deleteElement(1);\n+        assertEquals(2.0, heap.getElement(1).getKey());\n+        assertEquals(4, heap.size());\n+    }\n+\n+    @Test\n+    void testDeleteElementAtInvalidIndex() {\n+        assertThrows(IndexOutOfBoundsException.class, () -> heap.deleteElement(0));\n+        assertThrows(IndexOutOfBoundsException.class, () -> heap.deleteElement(10));\n+    }\n+\n+    @Test\n+    void testDeleteFromEmptyHeap() {\n+        MinHeap emptyHeap = new MinHeap(new ArrayList<>());\n+        assertThrows(EmptyHeapException.class, () -> emptyHeap.deleteElement(1));\n+    }\n+\n+    @Test\n+    void testExtractMin() throws EmptyHeapException {\n+        HeapElement min = heap.getElement();\n+        assertEquals(1.0, min.getKey());\n+        assertEquals(\"One\", min.getValue());\n+        assertEquals(4, heap.size());\n+\n+        min = heap.getElement();\n+        assertEquals(2.0, min.getKey());\n+        assertEquals(3, heap.size());\n+    }\n+\n+    @Test\n+    void testExtractMinFromEmptyHeap() {\n+        MinHeap emptyHeap = new MinHeap(new ArrayList<>());\n+        assertThrows(EmptyHeapException.class, () -> emptyHeap.getElement());\n+    }\n+\n+    @Test\n+    void testHeapOrder() {\n+        // Test that parent is always smaller than or equal to children\n+        for (int i = 1; i <= heap.size() / 2; i++) {\n+            double parentKey = heap.getElement(i).getKey();\n+\n+            // Check left child\n+            if (2 * i <= heap.size()) {\n+                assertTrue(parentKey <= heap.getElement(2 * i).getKey());\n+            }\n+\n+            // Check right child\n+            if (2 * i + 1 <= heap.size()) {\n+                assertTrue(parentKey <= heap.getElement(2 * i + 1).getKey());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void testSizeAndEmpty() {\n+        assertEquals(5, heap.size());\n+        assertFalse(heap.isEmpty());\n+\n+        // Remove all elements\n+        while (!heap.isEmpty()) {\n+            try {\n+                heap.getElement();\n+            } catch (EmptyHeapException e) {\n+                Assertions.fail(\"Should not throw EmptyHeapException while heap is not empty\");\n+            }\n+        }\n+\n+        assertEquals(0, heap.size());\n+        assertTrue(heap.isEmpty());\n+    }\n+}",
    "output": {
      "why": "The changes enhance the integrity of the heap data structure by ensuring methods throw appropriate exceptions and handle null values. Additionally, the new test cases ensure the functionality of the `MinHeap` implementation is validated, promoting code robustness and error handling.",
      "commit_message": "Enhance MinHeap implementation and add tests\n- Added `MinHeapTest` class to validate `MinHeap` operations and behaviors.\n- Updated `Heap` interface to declare `deleteElement` method as throwing `EmptyHeapException` to promote correct error handling.\n- Enhanced `MinHeap` constructor to reject null lists and ignore null elements with warnings.\n- Introduced `getValue` method in `HeapElement` for better data representation.\n- Updated method documentation and error messages for improved clarity and consistency."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java\nindex 5424e14c72fd..915e4228b618 100644\n--- a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java\n+++ b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java\n@@ -3,19 +3,23 @@\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n-/*\n-This class finds the majority element(s) in an array of integers.\n-A majority element is an element that appears more than or equal to n/2 times, where n is the length\n-of the array.\n-*/\n+\n+/**\n+ * This class provides a method to find the majority element(s) in an array of integers.\n+ * A majority element is defined as an element that appears at least ⌊n/2⌋ times,\n+ * where n is the length of the array. If multiple elements qualify as majority elements,\n+ * they are all returned in a list.\n+ */\n public final class MajorityElement {\n     private MajorityElement() {\n     }\n-    /*\n-   This method returns the majority element(s) in the given array of integers.\n-   @param nums: an array of integers\n-   @return a list of majority elements\n-   */\n+\n+    /**\n+     * Returns a list of majority element(s) from the given array of integers.\n+     *\n+     * @param nums an array of integers\n+     * @return a list containing the majority element(s); returns an empty list if none exist\n+     */\n     public static List<Integer> majority(int[] nums) {\n         HashMap<Integer, Integer> numToCount = new HashMap<>();\n         for (final var num : nums) {\ndiff --git a/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElementTest.java b/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElementTest.java\nindex 49133ba5ffb5..7dcd5eb7a8f4 100644\n--- a/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElementTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElementTest.java\n@@ -42,4 +42,39 @@ void testMajorityWithEmptyArray() {\n         List<Integer> actual = MajorityElement.majority(nums);\n         assertEquals(expected, actual);\n     }\n+\n+    @Test\n+    void testMajorityWithAllElementsSame() {\n+        int[] nums = {5, 5, 5, 5, 5};\n+        List<Integer> expected = new ArrayList<>();\n+        expected.add(5);\n+        List<Integer> actual = MajorityElement.majority(nums);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void testMajorityWithEvenCountAndOneMajorityElement() {\n+        int[] nums = {1, 2, 2, 3, 3, 2};\n+        List<Integer> expected = new ArrayList<>();\n+        expected.add(2);\n+        List<Integer> actual = MajorityElement.majority(nums);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void testMajorityWithNoElementsEqualToHalf() {\n+        int[] nums = {1, 1, 2, 2, 3, 3, 4};\n+        List<Integer> expected = Collections.emptyList();\n+        List<Integer> actual = MajorityElement.majority(nums);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void testMajorityWithLargeArray() {\n+        int[] nums = {1, 2, 3, 1, 1, 1, 2, 1, 1};\n+        List<Integer> expected = new ArrayList<>();\n+        expected.add(1);\n+        List<Integer> actual = MajorityElement.majority(nums);\n+        assertEquals(expected, actual);\n+    }\n }",
    "output": {
      "why": "The JavaDoc comments were revised to improve clarity and better describe the functionality of the class and methods. Additionally, new test cases were added to cover various edge cases, ensuring the majority calculation is robust and verified across different input scenarios.",
      "commit_message": "Enhance documentation and improve test coverage for `MajorityElement`\n- Refined JavaDoc comments for clarity and added detail in `MajorityElement.java`.\n- Introduced new test cases in `MajorityElementTest.java` to cover:\n- All elements being the same.\n- An even count of numbers with one majority element.\n- A situation where no elements are equal to half.\n- A large array scenario to validate performance and correctness."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/AbsoluteMin.java b/src/main/java/com/thealgorithms/maths/AbsoluteMin.java\nindex 1ffe6d2e81bc..1b9575a330dd 100644\n--- a/src/main/java/com/thealgorithms/maths/AbsoluteMin.java\n+++ b/src/main/java/com/thealgorithms/maths/AbsoluteMin.java\n@@ -19,7 +19,7 @@ public static int getMinValue(int... numbers) {\n \n         var absMinWrapper = new Object() { int value = numbers[0]; };\n \n-        Arrays.stream(numbers).skip(1).filter(number -> Math.abs(number) < Math.abs(absMinWrapper.value)).forEach(number -> absMinWrapper.value = number);\n+        Arrays.stream(numbers).skip(1).filter(number -> Math.abs(number) <= Math.abs(absMinWrapper.value)).forEach(number -> absMinWrapper.value = Math.min(absMinWrapper.value, number));\n \n         return absMinWrapper.value;\n     }\ndiff --git a/src/test/java/com/thealgorithms/maths/AbsoluteMinTest.java b/src/test/java/com/thealgorithms/maths/AbsoluteMinTest.java\nindex 4b676ca634f7..dfca757fd877 100644\n--- a/src/test/java/com/thealgorithms/maths/AbsoluteMinTest.java\n+++ b/src/test/java/com/thealgorithms/maths/AbsoluteMinTest.java\n@@ -15,7 +15,13 @@ void testGetMinValue() {\n \n     @Test\n     void testGetMinValueWithNoArguments() {\n-        Exception exception = assertThrows(IllegalArgumentException.class, () -> AbsoluteMin.getMinValue());\n+        Exception exception = assertThrows(IllegalArgumentException.class, AbsoluteMin::getMinValue);\n         assertEquals(\"Numbers array cannot be empty\", exception.getMessage());\n     }\n+\n+    @Test\n+    void testGetMinValueWithSameAbsoluteValues() {\n+        assertEquals(-5, AbsoluteMin.getMinValue(-5, 5));\n+        assertEquals(-5, AbsoluteMin.getMinValue(5, -5));\n+    }\n }",
    "output": {
      "why": "The condition for determining the minimum absolute value is adjusted to include equal absolute values, ensuring accuracy in cases where the minimum value occurs alongside an equivalent value. New tests were also added to cover this scenario.",
      "commit_message": "Adjust absolute minimum value logic and enhance test coverage\n- Updated the logic in `getMinValue` to return the minimum value even when absolute values are the same. This ensures correctness in edge cases where two numbers have the same absolute value.\n- Added a new test to validate the behavior of `getMinValue` when provided with pairs of numbers that have the same absolute value.\n- Refactored an existing test to utilize method reference for improved readability."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/conversions/AnytoAny.java b/src/main/java/com/thealgorithms/conversions/AnytoAny.java\nindex 801e493032e0..e7bdbc2b79c4 100644\n--- a/src/main/java/com/thealgorithms/conversions/AnytoAny.java\n+++ b/src/main/java/com/thealgorithms/conversions/AnytoAny.java\n@@ -1,35 +1,68 @@\n package com.thealgorithms.conversions;\n \n-import java.util.Scanner;\n-\n-// given a source number , source base, destination base, this code can give you the destination\n-// number.\n-// sn ,sb,db ---> ()dn  .   this is what we have to do    .\n-\n+/**\n+ * A utility class for converting numbers from any base to any other base.\n+ *\n+ * This class provides a method to convert a source number from a given base\n+ * to a destination number in another base. Valid bases range from 2 to 10.\n+ */\n public final class AnytoAny {\n     private AnytoAny() {\n     }\n \n-    public static void main(String[] args) {\n-        Scanner scn = new Scanner(System.in);\n-        int sn = scn.nextInt();\n-        int sb = scn.nextInt();\n-        int db = scn.nextInt();\n-        int m = 1;\n-        int dec = 0;\n-        int dn = 0;\n-        while (sn != 0) {\n-            dec = dec + (sn % 10) * m;\n-            m *= sb;\n-            sn /= 10;\n+    /**\n+     * Converts a number from a source base to a destination base.\n+     *\n+     * @param sourceNumber The number in the source base (as an integer).\n+     * @param sourceBase The base of the source number (between 2 and 10).\n+     * @param destBase The base to which the number should be converted (between 2 and 10).\n+     * @throws IllegalArgumentException if the bases are not between 2 and 10.\n+     * @return The converted number in the destination base (as an integer).\n+     */\n+    public static int convertBase(int sourceNumber, int sourceBase, int destBase) {\n+        if (sourceBase < 2 || sourceBase > 10 || destBase < 2 || destBase > 10) {\n+            throw new IllegalArgumentException(\"Bases must be between 2 and 10.\");\n+        }\n+\n+        int decimalValue = toDecimal(sourceNumber, sourceBase);\n+        return fromDecimal(decimalValue, destBase);\n+    }\n+\n+    /**\n+     * Converts a number from a given base to its decimal representation (base 10).\n+     *\n+     * @param number The number in the original base.\n+     * @param base The base of the given number.\n+     * @return The decimal representation of the number.\n+     */\n+    private static int toDecimal(int number, int base) {\n+        int decimalValue = 0;\n+        int multiplier = 1;\n+\n+        while (number != 0) {\n+            decimalValue += (number % 10) * multiplier;\n+            multiplier *= base;\n+            number /= 10;\n         }\n-        m = 1;\n-        while (dec != 0) {\n-            dn = dn + (dec % db) * m;\n-            m *= 10;\n-            dec /= db;\n+        return decimalValue;\n+    }\n+\n+    /**\n+     * Converts a decimal (base 10) number to a specified base.\n+     *\n+     * @param decimal The decimal number to convert.\n+     * @param base The destination base for conversion.\n+     * @return The number in the specified base.\n+     */\n+    private static int fromDecimal(int decimal, int base) {\n+        int result = 0;\n+        int multiplier = 1;\n+\n+        while (decimal != 0) {\n+            result += (decimal % base) * multiplier;\n+            multiplier *= 10;\n+            decimal /= base;\n         }\n-        System.out.println(dn);\n-        scn.close();\n+        return result;\n     }\n }\ndiff --git a/src/test/java/com/thealgorithms/conversions/AnytoAnyTest.java b/src/test/java/com/thealgorithms/conversions/AnytoAnyTest.java\nnew file mode 100644\nindex 000000000000..cdc012180bf9\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/conversions/AnytoAnyTest.java\n@@ -0,0 +1,48 @@\n+package com.thealgorithms.conversions;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class AnytoAnyTest {\n+\n+    @Test\n+    void testValidConversions() {\n+        assertEquals(101, AnytoAny.convertBase(5, 10, 2), \"Decimal 5 should convert to binary 101\");\n+        assertEquals(2, AnytoAny.convertBase(2, 2, 10), \"Binary 10 should convert to decimal 2\");\n+        assertEquals(6, AnytoAny.convertBase(110, 2, 8), \"Binary 110 should convert to octal 6\");\n+        assertEquals(111, AnytoAny.convertBase(7, 10, 2), \"Decimal 7 should convert to binary 111\");\n+    }\n+\n+    @Test\n+    void testDecimalToBinary() {\n+        assertEquals(1101, AnytoAny.convertBase(13, 10, 2), \"Decimal 13 should convert to binary 1101\");\n+        assertEquals(0, AnytoAny.convertBase(0, 10, 2), \"Decimal 0 should convert to binary 0\");\n+    }\n+\n+    @Test\n+    void testBinaryToDecimal() {\n+        assertEquals(13, AnytoAny.convertBase(1101, 2, 10), \"Binary 1101 should convert to decimal 13\");\n+        assertEquals(0, AnytoAny.convertBase(0, 2, 10), \"Binary 0 should convert to decimal 0\");\n+    }\n+\n+    @Test\n+    void testOctalToDecimal() {\n+        assertEquals(8, AnytoAny.convertBase(10, 8, 10), \"Octal 10 should convert to decimal 8\");\n+        assertEquals(65, AnytoAny.convertBase(101, 8, 10), \"Octal 101 should convert to decimal 65\");\n+    }\n+\n+    @Test\n+    void testInvalidBases() {\n+        assertThrows(IllegalArgumentException.class, () -> AnytoAny.convertBase(5, 1, 10), \"Source base less than 2 should throw IllegalArgumentException\");\n+\n+        assertThrows(IllegalArgumentException.class, () -> AnytoAny.convertBase(5, 10, 11), \"Destination base greater than 10 should throw IllegalArgumentException\");\n+    }\n+\n+    @Test\n+    void testLargeNumberConversion() {\n+        assertEquals(1111101000, AnytoAny.convertBase(1000, 10, 2), \"Decimal 1000 should convert to binary 1111101000\");\n+        assertEquals(1750, AnytoAny.convertBase(1000, 10, 8), \"Decimal 1000 should convert to octal 1750\");\n+    }\n+}",
    "output": {
      "why": "These changes introduce a new utility function `convertBase` for converting numbers between arbitrary bases, while also implementing thorough unit tests to validate functionality and input constraints.",
      "commit_message": "Add `convertBase` method for base conversion and unit tests\n- Introduced `convertBase` method which enables conversion of numbers from any base (2 to 10) to another.\n- Refactored existing main method from `AnytoAny` for better utility and separated responsibilities.\n- Created `AnytoAnyTest` class with tests for various conversion scenarios and validation of base constraints.\n- Enhanced code documentation to clarify usage and behavior of the methods."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/strings/ReverseString.java b/src/main/java/com/thealgorithms/strings/ReverseString.java\nindex 46a0494fcbb4..54a9b779e828 100644\n--- a/src/main/java/com/thealgorithms/strings/ReverseString.java\n+++ b/src/main/java/com/thealgorithms/strings/ReverseString.java\n@@ -36,4 +36,25 @@ public static String reverse2(String str) {\n         }\n         return new String(value);\n     }\n+\n+    /**\n+     * Reverse version 3 the given string using a StringBuilder.\n+     * This method converts the string to a character array,\n+     * iterates through it in reverse order, and appends each character\n+     * to a StringBuilder.\n+     *\n+     * @param string The input string to be reversed.\n+     * @return The reversed string.\n+     */\n+    public static String reverse3(String string) {\n+        if (string.isEmpty()) {\n+            return string;\n+        }\n+        char[] chars = string.toCharArray();\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = string.length() - 1; i >= 0; i--) {\n+            sb.append(chars[i]);\n+        }\n+        return sb.toString();\n+    }\n }\ndiff --git a/src/test/java/com/thealgorithms/strings/ReverseStringTest.java b/src/test/java/com/thealgorithms/strings/ReverseStringTest.java\nindex 501f702976ec..08f5fb586d82 100644\n--- a/src/test/java/com/thealgorithms/strings/ReverseStringTest.java\n+++ b/src/test/java/com/thealgorithms/strings/ReverseStringTest.java\n@@ -25,4 +25,10 @@ public void testReverseString(String input, String expectedOutput) {\n     public void testReverseString2(String input, String expectedOutput) {\n         assertEquals(expectedOutput, ReverseString.reverse2(input));\n     }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testCases\")\n+    public void testReverseString3(String input, String expectedOutput) {\n+        assertEquals(expectedOutput, ReverseString.reverse3(input));\n+    }\n }",
    "output": {
      "why": "The new reverse3 method was added to provide an alternative way to reverse a string in a more efficient manner using StringBuilder. This enhances performance, especially for larger strings, and the accompanying tests ensure its correctness.",
      "commit_message": "Add `reverse3` method to reverse strings using StringBuilder\n- Introduced a new `reverse3` method in `ReverseString.java` that reverses a given string using a StringBuilder for improved efficiency.\n- Included javadoc comments to explain the implementation details and parameters.\n- Added a new test method `testReverseString3` in `ReverseStringTest.java` to validate the functionality of the `reverse3` method with various input cases."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArray.java b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArray.java\nindex 416cee99d028..3637e323f097 100644\n--- a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArray.java\n+++ b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArray.java\n@@ -2,23 +2,45 @@\n \n import java.util.LinkedList;\n \n-// implementation of generic hashmaps using array of Linked Lists\n-\n+/**\n+ * A generic implementation of a hash map using an array of linked lists for collision resolution.\n+ * This class provides a way to store key-value pairs efficiently, allowing for average-case\n+ * constant time complexity for insertion, deletion, and retrieval operations.\n+ *\n+ * <p>\n+ * The hash map uses separate chaining for collision resolution. Each bucket in the hash map is a\n+ * linked list that stores nodes containing key-value pairs. When a collision occurs (i.e., when\n+ * two keys hash to the same index), the new key-value pair is simply added to the corresponding\n+ * linked list.\n+ * </p>\n+ *\n+ * <p>\n+ * The hash map automatically resizes itself when the load factor exceeds 0.75. The load factor is\n+ * defined as the ratio of the number of entries to the number of buckets. When resizing occurs,\n+ * all existing entries are rehashed and inserted into the new buckets.\n+ * </p>\n+ *\n+ * @param <K> the type of keys maintained by this hash map\n+ * @param <V> the type of mapped values\n+ */\n public class GenericHashMapUsingArray<K, V> {\n \n-    private int size; // n (total number of key-value pairs)\n-    private LinkedList<Node>[] buckets; // N = buckets.length\n-    private float lf = 0.75f;\n+    private int size; // Total number of key-value pairs\n+    private LinkedList<Node>[] buckets; // Array of linked lists (buckets) for storing entries\n \n+    /**\n+     * Constructs a new empty hash map with an initial capacity of 16.\n+     */\n     public GenericHashMapUsingArray() {\n         initBuckets(16);\n         size = 0;\n     }\n \n-    // load factor = 0.75 means if we need to add 100 items and we have added\n-    // 75, then adding 76th item it will double the size, copy all elements\n-    // & then add 76th item.\n-\n+    /**\n+     * Initializes the buckets for the hash map with the specified number of buckets.\n+     *\n+     * @param n the number of buckets to initialize\n+     */\n     private void initBuckets(int n) {\n         buckets = new LinkedList[n];\n         for (int i = 0; i < buckets.length; i++) {\n@@ -26,43 +48,66 @@ private void initBuckets(int n) {\n         }\n     }\n \n+    /**\n+     * Associates the specified value with the specified key in this map.\n+     * If the map previously contained a mapping for the key, the old value is replaced.\n+     *\n+     * @param key the key with which the specified value is to be associated\n+     * @param value the value to be associated with the specified key\n+     */\n     public void put(K key, V value) {\n         int bucketIndex = hashFunction(key);\n         LinkedList<Node> nodes = buckets[bucketIndex];\n-        for (Node node : nodes) { // if key present => update\n+        // Update existing key's value if present\n+        for (Node node : nodes) {\n             if (node.key.equals(key)) {\n                 node.value = value;\n                 return;\n             }\n         }\n \n-        // key is not present => insert\n+        // Insert new key-value pair\n         nodes.add(new Node(key, value));\n         size++;\n \n-        if ((float) size / buckets.length > lf) {\n+        // Check if rehashing is needed\n+        // Load factor threshold for resizing\n+        float loadFactorThreshold = 0.75f;\n+        if ((float) size / buckets.length > loadFactorThreshold) {\n             reHash();\n         }\n     }\n \n-    // tells which bucket to go to\n+    /**\n+     * Returns the index of the bucket in which the key would be stored.\n+     *\n+     * @param key the key whose bucket index is to be computed\n+     * @return the bucket index\n+     */\n     private int hashFunction(K key) {\n         return Math.floorMod(key.hashCode(), buckets.length);\n     }\n \n+    /**\n+     * Rehashes the map by doubling the number of buckets and re-inserting all entries.\n+     */\n     private void reHash() {\n-        System.out.println(\"Rehashing!\");\n-        LinkedList<Node>[] old = buckets;\n-        initBuckets(old.length * 2);\n+        LinkedList<Node>[] oldBuckets = buckets;\n+        initBuckets(oldBuckets.length * 2);\n         this.size = 0;\n \n-        for (LinkedList<Node> nodes : old) {\n+        for (LinkedList<Node> nodes : oldBuckets) {\n             for (Node node : nodes) {\n                 put(node.key, node.value);\n             }\n         }\n     }\n \n+    /**\n+     * Removes the mapping for the specified key from this map if present.\n+     *\n+     * @param key the key whose mapping is to be removed from the map\n+     */\n     public void remove(K key) {\n         int bucketIndex = hashFunction(key);\n         LinkedList<Node> nodes = buckets[bucketIndex];\n@@ -74,14 +119,28 @@ public void remove(K key) {\n                 break;\n             }\n         }\n-        nodes.remove(target);\n-        size--;\n+\n+        if (target != null) {\n+            nodes.remove(target);\n+            size--;\n+        }\n     }\n \n+    /**\n+     * Returns the number of key-value pairs in this map.\n+     *\n+     * @return the number of key-value pairs\n+     */\n     public int size() {\n         return this.size;\n     }\n \n+    /**\n+     * Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.\n+     *\n+     * @param key the key whose associated value is to be returned\n+     * @return the value associated with the specified key, or null if no mapping exists\n+     */\n     public V get(K key) {\n         int bucketIndex = hashFunction(key);\n         LinkedList<Node> nodes = buckets[bucketIndex];\n@@ -96,7 +155,6 @@ public V get(K key) {\n     @Override\n     public String toString() {\n         StringBuilder builder = new StringBuilder();\n-\n         builder.append(\"{\");\n         for (LinkedList<Node> nodes : buckets) {\n             for (Node node : nodes) {\n@@ -106,19 +164,37 @@ public String toString() {\n                 builder.append(\", \");\n             }\n         }\n+        // Remove trailing comma and space\n+        if (builder.length() > 1) {\n+            builder.setLength(builder.length() - 2);\n+        }\n         builder.append(\"}\");\n         return builder.toString();\n     }\n \n+    /**\n+     * Returns true if this map contains a mapping for the specified key.\n+     *\n+     * @param key the key whose presence in this map is to be tested\n+     * @return true if this map contains a mapping for the specified key\n+     */\n     public boolean containsKey(K key) {\n         return get(key) != null;\n     }\n \n+    /**\n+     * A private class representing a key-value pair (node) in the hash map.\n+     */\n     public class Node {\n-\n         K key;\n         V value;\n \n+        /**\n+         * Constructs a new Node with the specified key and value.\n+         *\n+         * @param key the key of the key-value pair\n+         * @param value the value of the key-value pair\n+         */\n         public Node(K key, V value) {\n             this.key = key;\n             this.value = value;\ndiff --git a/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayTest.java b/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayTest.java\nindex 483e43bb5cb3..5d1733a3e97c 100644\n--- a/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayTest.java\n@@ -50,4 +50,47 @@ void testGenericHashmapWhichUsesArrayAndKeyIsIntegerValueIsString() {\n         assertEquals(\"Washington DC\", map.get(101));\n         assertTrue(map.containsKey(46));\n     }\n+\n+    @Test\n+    void testRemoveNonExistentKey() {\n+        GenericHashMapUsingArray<String, String> map = new GenericHashMapUsingArray<>();\n+        map.put(\"USA\", \"Washington DC\");\n+        map.remove(\"Nepal\"); // Attempting to remove a non-existent key\n+        assertEquals(1, map.size()); // Size should remain the same\n+    }\n+\n+    @Test\n+    void testRehashing() {\n+        GenericHashMapUsingArray<String, String> map = new GenericHashMapUsingArray<>();\n+        for (int i = 0; i < 20; i++) {\n+            map.put(\"Key\" + i, \"Value\" + i);\n+        }\n+        assertEquals(20, map.size()); // Ensure all items were added\n+        assertEquals(\"Value5\", map.get(\"Key5\")); // Check retrieval after rehash\n+    }\n+\n+    @Test\n+    void testUpdateValueForExistingKey() {\n+        GenericHashMapUsingArray<String, String> map = new GenericHashMapUsingArray<>();\n+        map.put(\"USA\", \"Washington DC\");\n+        map.put(\"USA\", \"New Washington DC\"); // Updating value for existing key\n+        assertEquals(\"New Washington DC\", map.get(\"USA\"));\n+    }\n+\n+    @Test\n+    void testToStringMethod() {\n+        GenericHashMapUsingArray<String, String> map = new GenericHashMapUsingArray<>();\n+        map.put(\"USA\", \"Washington DC\");\n+        map.put(\"Nepal\", \"Kathmandu\");\n+        String expected = \"{USA : Washington DC, Nepal : Kathmandu}\";\n+        assertEquals(expected, map.toString());\n+    }\n+\n+    @Test\n+    void testContainsKey() {\n+        GenericHashMapUsingArray<String, String> map = new GenericHashMapUsingArray<>();\n+        map.put(\"USA\", \"Washington DC\");\n+        assertTrue(map.containsKey(\"USA\"));\n+        assertFalse(map.containsKey(\"Nepal\"));\n+    }\n }",
    "output": {
      "why": "The changes enhance code maintainability by adding comprehensive Javadoc comments that explain class usage and method functionalities. This improves onboarding for new developers and aids in understanding the class's role within the codebase. Additionally, unit tests were included to verify the correctness of key functionalities, such as rehashing and key-value operations, which ensures robustness and reliable future modifications.",
      "commit_message": "Enhance documentation and add unit tests for GenericHashMap\n- Improved code documentation by adding detailed Javadoc comments to clarify the purpose and usage of the `GenericHashMapUsingArray` class and its methods.\n- Updated existing comments for better readability and understanding.\n- Added unit tests to verify functionalities like removing non-existent keys, rehashing behavior, updating values for existing keys, and string representation.\n- Ensured that the class behaves correctly under various scenarios, enhancing overall code reliability."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/stacks/NodeStack.java b/src/main/java/com/thealgorithms/datastructures/stacks/NodeStack.java\nindex 384cf3c0395a..bbcdfe1cc2a8 100644\n--- a/src/main/java/com/thealgorithms/datastructures/stacks/NodeStack.java\n+++ b/src/main/java/com/thealgorithms/datastructures/stacks/NodeStack.java\n@@ -95,15 +95,4 @@ public boolean isEmpty() {\n     public int size() {\n         return size;\n     }\n-\n-    /**\n-     * Prints the contents of the stack from top to bottom.\n-     */\n-    public void print() {\n-        Node current = head;\n-        while (current != null) {\n-            System.out.println(current.data);\n-            current = current.previous;\n-        }\n-    }\n }\ndiff --git a/src/test/java/com/thealgorithms/datastructures/stacks/NodeStackTest.java b/src/test/java/com/thealgorithms/datastructures/stacks/NodeStackTest.java\nindex e05319359815..7ac0d8bc324b 100644\n--- a/src/test/java/com/thealgorithms/datastructures/stacks/NodeStackTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/stacks/NodeStackTest.java\n@@ -70,16 +70,4 @@ void testSize() {\n         stack.pop();\n         assertEquals(0, stack.size(), \"Size should be 0 after popping all elements.\");\n     }\n-\n-    @Test\n-    void testPrint() {\n-        NodeStack<Integer> stack = new NodeStack<>();\n-        stack.push(1);\n-        stack.push(2);\n-        stack.push(3);\n-\n-        // Output verification would ideally be handled through a different means\n-        // but you can print as a basic check to confirm method runs without errors.\n-        stack.print();\n-    }\n }\ndiff --git a/src/test/java/com/thealgorithms/datastructures/trees/BinaryTreeTest.java b/src/test/java/com/thealgorithms/datastructures/trees/BinaryTreeTest.java\nindex b153c5d667de..08a82e50ca02 100644\n--- a/src/test/java/com/thealgorithms/datastructures/trees/BinaryTreeTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/trees/BinaryTreeTest.java\n@@ -1,6 +1,7 @@\n package com.thealgorithms.datastructures.trees;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n \n import org.junit.jupiter.api.Test;\n \n@@ -35,7 +36,12 @@ void test2() {\n         t.remove(5);\n         t.remove(7);\n \n-        assertEquals(t.getRoot().data, 9);\n+        // Checks whether the root is null before accessing date\n+        if (t.getRoot() != null) {\n+            assertEquals(t.getRoot().data, 9);\n+        } else {\n+            fail(\"The root node is null after removal.\");\n+        }\n     }\n \n     // checks that removing an unexistend node returns false",
    "output": {
      "why": "The `print` method was removed from `NodeStack` to keep the API cleaner and to separate concerns, while the test cases in `NodeStackTest` were updated to reflect this change. The BinaryTreeTest was improved to handle a potential null root node situation safely, ensuring that tests can report meaningful errors.",
      "commit_message": "Remove `print` method from `NodeStack` and improve tests\n- Removed the `print` method from the `NodeStack` class to enhance code clarity and maintainability.\n- Updated unit tests in `NodeStackTest` to reflect the removal of the `print` method.\n- Added null checks in `BinaryTreeTest` to ensure safe access to the root node after removing nodes."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/Armstrong.java b/src/main/java/com/thealgorithms/maths/Armstrong.java\nindex ff4ae027a0b7..9a7a014ec99f 100644\n--- a/src/main/java/com/thealgorithms/maths/Armstrong.java\n+++ b/src/main/java/com/thealgorithms/maths/Armstrong.java\n@@ -10,6 +10,7 @@\n  * An Armstrong number is often called a Narcissistic number.\n  *\n  * @author satyabarghav\n+ * @modifier rahul katteda - (13/01/2025) - [updated the logic for getting total number of digits]\n  */\n public class Armstrong {\n \n@@ -20,14 +21,16 @@ public class Armstrong {\n      * @return {@code true} if the given number is an Armstrong number, {@code false} otherwise\n      */\n     public boolean isArmstrong(int number) {\n+        if (number < 0) {\n+            return false; // Negative numbers cannot be Armstrong numbers\n+        }\n         long sum = 0;\n-        String temp = Integer.toString(number); // Convert the given number to a string\n-        int power = temp.length(); // Extract the length of the number (number of digits)\n+        int totalDigits = (int) Math.log10(number) + 1; // get the length of the number (number of digits)\n         long originalNumber = number;\n \n         while (originalNumber > 0) {\n             long digit = originalNumber % 10;\n-            sum += (long) Math.pow(digit, power); // The digit raised to the power of the number of digits and added to the sum.\n+            sum += (long) Math.pow(digit, totalDigits); // The digit raised to the power of total number of digits and added to the sum.\n             originalNumber /= 10;\n         }",
    "output": {
      "why": "The changes were made to improve the `isArmstrong` method by adding a check that returns `false` for negative numbers, as they cannot be Armstrong numbers. Additionally, the logic for calculating the total number of digits was streamlined to enhance readability and performance.",
      "commit_message": "Enhance `isArmstrong` method in `Armstrong` class\n- Introduced a check for negative numbers, ensuring they are correctly handled.\n- Revised the calculation of the total number of digits for clarity and efficiency, using logarithm instead of string conversion.\n- Improved variable naming for better understanding of the code logic."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/trees/AVLTree.java b/src/main/java/com/thealgorithms/datastructures/trees/AVLTree.java\nindex 7b959b085353..77ee5d5fa23e 100644\n--- a/src/main/java/com/thealgorithms/datastructures/trees/AVLTree.java\n+++ b/src/main/java/com/thealgorithms/datastructures/trees/AVLTree.java\n@@ -1,11 +1,19 @@\n package com.thealgorithms.datastructures.trees;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Represents an AVL Tree, a self-balancing binary search tree.\n+ * In an AVL tree, the heights of the two child subtrees of any node\n+ * differ by at most one. If they differ by more than one at any time,\n+ * rebalancing is performed to restore this property.\n+ */\n public class AVLTree {\n \n     private Node root;\n \n-    private class Node {\n-\n+    private static class Node {\n         private int key;\n         private int balance;\n         private int height;\n@@ -17,8 +25,18 @@ private class Node {\n             key = k;\n             parent = p;\n         }\n+\n+        public Integer getBalance() {\n+            return balance;\n+        }\n     }\n \n+    /**\n+     * Inserts a new key into the AVL tree.\n+     *\n+     * @param key the key to be inserted\n+     * @return {@code true} if the key was inserted, {@code false} if the key already exists\n+     */\n     public boolean insert(int key) {\n         if (root == null) {\n             root = new Node(key, null);\n@@ -31,7 +49,6 @@ public boolean insert(int key) {\n                 }\n \n                 parent = n;\n-\n                 boolean goLeft = n.key > key;\n                 n = goLeft ? n.left : n.right;\n \n@@ -49,8 +66,32 @@ public boolean insert(int key) {\n         return true;\n     }\n \n+    /**\n+     * Deletes a key from the AVL tree.\n+     *\n+     * @param delKey the key to be deleted\n+     */\n+    public void delete(int delKey) {\n+        if (root == null) {\n+            return;\n+        }\n+\n+        // Find the node to be deleted\n+        Node node = root;\n+        Node child = root;\n+        while (child != null) {\n+            node = child;\n+            child = delKey >= node.key ? node.right : node.left;\n+            if (delKey == node.key) {\n+                delete(node);\n+                return;\n+            }\n+        }\n+    }\n+\n     private void delete(Node node) {\n         if (node.left == null && node.right == null) {\n+            // Leaf node\n             if (node.parent == null) {\n                 root = null;\n             } else {\n@@ -64,6 +105,8 @@ private void delete(Node node) {\n             }\n             return;\n         }\n+\n+        // Node has one or two children\n         Node child;\n         if (node.left != null) {\n             child = node.left;\n@@ -80,26 +123,49 @@ private void delete(Node node) {\n         delete(child);\n     }\n \n-    public void delete(int delKey) {\n-        if (root == null) {\n-            return;\n+    /**\n+     * Returns a list of balance factors for each node in the tree.\n+     *\n+     * @return a list of integers representing the balance factors of the nodes\n+     */\n+    public List<Integer> returnBalance() {\n+        List<Integer> balances = new ArrayList<>();\n+        returnBalance(root, balances);\n+        return balances;\n+    }\n+\n+    private void returnBalance(Node n, List<Integer> balances) {\n+        if (n != null) {\n+            returnBalance(n.left, balances);\n+            balances.add(n.getBalance());\n+            returnBalance(n.right, balances);\n         }\n-        Node node = root;\n-        Node child = root;\n+    }\n \n-        while (child != null) {\n-            node = child;\n-            child = delKey >= node.key ? node.right : node.left;\n-            if (delKey == node.key) {\n-                delete(node);\n-                return;\n-            }\n+    /**\n+     * Searches for a key in the AVL tree.\n+     *\n+     * @param key the key to be searched\n+     * @return true if the key is found, false otherwise\n+     */\n+    public boolean search(int key) {\n+        Node result = searchHelper(this.root, key);\n+        return result != null;\n+    }\n+\n+    private Node searchHelper(Node root, int key) {\n+        if (root == null || root.key == key) {\n+            return root;\n         }\n+\n+        if (root.key > key) {\n+            return searchHelper(root.left, key);\n+        }\n+        return searchHelper(root.right, key);\n     }\n \n     private void rebalance(Node n) {\n         setBalance(n);\n-\n         if (n.balance == -2) {\n             if (height(n.left.left) >= height(n.left.right)) {\n                 n = rotateRight(n);\n@@ -143,7 +209,6 @@ private Node rotateLeft(Node a) {\n         }\n \n         setBalance(a, b);\n-\n         return b;\n     }\n \n@@ -169,7 +234,6 @@ private Node rotateRight(Node a) {\n         }\n \n         setBalance(a, b);\n-\n         return b;\n     }\n \n@@ -197,53 +261,9 @@ private void setBalance(Node... nodes) {\n         }\n     }\n \n-    public void printBalance() {\n-        printBalance(root);\n-    }\n-\n-    private void printBalance(Node n) {\n-        if (n != null) {\n-            printBalance(n.left);\n-            System.out.printf(\"%s \", n.balance);\n-            printBalance(n.right);\n-        }\n-    }\n-\n     private void reheight(Node node) {\n         if (node != null) {\n             node.height = 1 + Math.max(height(node.left), height(node.right));\n         }\n     }\n-\n-    public boolean search(int key) {\n-        Node result = searchHelper(this.root, key);\n-        return result != null;\n-    }\n-\n-    private Node searchHelper(Node root, int key) {\n-        // root is null or key is present at root\n-        if (root == null || root.key == key) {\n-            return root;\n-        }\n-\n-        // key is greater than root's key\n-        if (root.key > key) {\n-            return searchHelper(root.left, key); // call the function on the node's left child\n-        }\n-        // key is less than root's key then\n-        // call the function on the node's right child as it is greater\n-        return searchHelper(root.right, key);\n-    }\n-\n-    public static void main(String[] args) {\n-        AVLTree tree = new AVLTree();\n-\n-        System.out.println(\"Inserting values 1 to 10\");\n-        for (int i = 1; i < 10; i++) {\n-            tree.insert(i);\n-        }\n-\n-        System.out.print(\"Printing balance: \");\n-        tree.printBalance();\n-    }\n }\ndiff --git a/src/test/java/com/thealgorithms/datastructures/trees/AVLTreeTest.java b/src/test/java/com/thealgorithms/datastructures/trees/AVLTreeTest.java\nnew file mode 100644\nindex 000000000000..6aa5dc9e22ed\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/datastructures/trees/AVLTreeTest.java\n@@ -0,0 +1,101 @@\n+package com.thealgorithms.datastructures.trees;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+public class AVLTreeTest {\n+    private AVLTree avlTree;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        avlTree = new AVLTree();\n+    }\n+\n+    @Test\n+    public void testInsert() {\n+        assertTrue(avlTree.insert(10));\n+        assertTrue(avlTree.insert(20));\n+        assertTrue(avlTree.insert(5));\n+        assertFalse(avlTree.insert(10)); // Duplicate\n+    }\n+\n+    @Test\n+    public void testSearch() {\n+        avlTree.insert(15);\n+        avlTree.insert(25);\n+        assertTrue(avlTree.search(15));\n+        assertFalse(avlTree.search(30)); // Not in the tree\n+    }\n+\n+    @Test\n+    public void testDeleteLeafNode() {\n+        avlTree.insert(10);\n+        avlTree.insert(20);\n+        avlTree.insert(30);\n+        avlTree.delete(30);\n+        assertFalse(avlTree.search(30));\n+    }\n+\n+    @Test\n+    public void testDeleteNodeWithOneChild() {\n+        avlTree.insert(20);\n+        avlTree.insert(10);\n+        avlTree.insert(30);\n+        avlTree.delete(10);\n+        assertFalse(avlTree.search(10));\n+    }\n+\n+    @Test\n+    public void testDeleteNodeWithTwoChildren() {\n+        avlTree.insert(20);\n+        avlTree.insert(10);\n+        avlTree.insert(30);\n+        avlTree.insert(25);\n+        avlTree.delete(20);\n+        assertFalse(avlTree.search(20));\n+        assertTrue(avlTree.search(30));\n+        assertTrue(avlTree.search(25));\n+    }\n+\n+    @Test\n+    public void testReturnBalance() {\n+        avlTree.insert(10);\n+        avlTree.insert(20);\n+        avlTree.insert(5);\n+        List<Integer> balances = avlTree.returnBalance();\n+        assertEquals(3, balances.size()); // There should be 3 nodes\n+        assertEquals(0, balances.get(0)); // Balance for node 5\n+        assertEquals(0, balances.get(1)); // Balance for node 10\n+        assertEquals(0, balances.get(2)); // Balance for node 20\n+    }\n+\n+    @Test\n+    public void testInsertAndRebalance() {\n+        avlTree.insert(30);\n+        avlTree.insert(20);\n+        avlTree.insert(10); // This should cause a right rotation\n+        assertTrue(avlTree.search(20));\n+        assertTrue(avlTree.search(10));\n+        assertTrue(avlTree.search(30));\n+    }\n+\n+    @Test\n+    public void testComplexInsertionAndDeletion() {\n+        avlTree.insert(30);\n+        avlTree.insert(20);\n+        avlTree.insert(10);\n+        avlTree.insert(25);\n+        avlTree.insert(5);\n+        avlTree.insert(15);\n+\n+        avlTree.delete(20); // Test deletion\n+        assertFalse(avlTree.search(20));\n+        assertTrue(avlTree.search(30));\n+        assertTrue(avlTree.search(25));\n+    }\n+}",
    "output": {
      "why": "The changes were made to enhance the functionality and maintainability of the AVLTree class by adding crucial methods for deletion and balance retrieval, improving code documentation with JavaDoc comments, and ensuring the AVL tree is properly tested through the newly created test class.",
      "commit_message": "Enhance AVL Tree functionality with tests and documentation\n- Added `delete` and `returnBalance` methods to the AVLTree class.\n- Improved visibility of the Node class to enable better unit testing and access.\n- Included comprehensive JavaDoc comments to document methods clearly.\n- Created `AVLTreeTest` class for unit testing, covering insertion, deletion, and balance functionality.\n- Updated `DIRECTORY.md` to include a reference to the new test class."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/VampireNumber.java b/src/main/java/com/thealgorithms/maths/VampireNumber.java\nindex 8820f8a23f70..45bb9a587778 100644\n--- a/src/main/java/com/thealgorithms/maths/VampireNumber.java\n+++ b/src/main/java/com/thealgorithms/maths/VampireNumber.java\n@@ -1,78 +1,48 @@\n package com.thealgorithms.maths;\n \n import java.util.ArrayList;\n-import java.util.Collections;\n \n /**\n- * n number theory, a vampire number (or true vampire number) is a composite\n+ * In number theory, a vampire number (or true vampire number) is a composite\n  * natural number with an even number of digits, that can be factored into two\n  * natural numbers each with half as many digits as the original number and not\n  * both with trailing zeroes, where the two factors contain precisely all the\n  * digits of the original number, in any order, counting multiplicity. The first\n- * vampire number is 1260 = 21 × 60. *\n+ * vampire number is 1260 = 21 × 60.\n  *\n- * <p>\n- * link: https://en.wikipedia.org/wiki/Vampire_number *\n- *\n- * <p>\n+ * @see <a href='https://en.wikipedia.org/wiki/Vampire_number'>Vampire number on Wikipedia</a>\n  */\n public final class VampireNumber {\n+    // Forbid instantiation.\n     private VampireNumber() {\n     }\n \n-    public static void main(String[] args) {\n-        test(10, 1000);\n-    }\n-\n-    static void test(int startValue, int stopValue) {\n-        int countofRes = 1;\n-        StringBuilder res = new StringBuilder();\n-\n-        for (int i = startValue; i <= stopValue; i++) {\n-            for (int j = i; j <= stopValue; j++) {\n-                // System.out.println(i+ \" \"+ j);\n-                if (isVampireNumber(i, j, true)) {\n-                    countofRes++;\n-                    res.append(\"\").append(countofRes).append(\": = ( \").append(i).append(\",\").append(j).append(\" = \").append(i * j).append(\")\").append(\"\\n\");\n-                }\n-            }\n-        }\n-        System.out.println(res);\n-    }\n-\n-    static boolean isVampireNumber(int a, int b, boolean noPseudoVamireNumbers) {\n-        // this is for pseudoVampireNumbers  pseudovampire number need not be of length n/2 digits\n-        // for example 126 = 6 x 21\n-        if (noPseudoVamireNumbers) {\n-            if (a * 10 <= b || b * 10 <= a) {\n-                return false;\n-            }\n+    static boolean isVampireNumber(int a, int b, boolean ignorePseudoVampireNumbers) {\n+        // Pseudo vampire numbers don't have to be of n/2 digits. E.g., 126 = 6 x 21 is such a number.\n+        if (ignorePseudoVampireNumbers && String.valueOf(a).length() != String.valueOf(b).length()) {\n+            return false;\n         }\n \n-        String mulDigits = splitIntoDigits(a * b, 0);\n-        String faktorDigits = splitIntoDigits(a, b);\n+        String mulDigits = splitIntoSortedDigits(a * b);\n+        String factorDigits = splitIntoSortedDigits(a, b);\n \n-        return mulDigits.equals(faktorDigits);\n+        return mulDigits.equals(factorDigits);\n     }\n \n-    // methode to Split the numbers to Digits\n-    static String splitIntoDigits(int num, int num2) {\n-        StringBuilder res = new StringBuilder();\n-\n+    // Method to split a pair of numbers to digits and sort them in the ascending order.\n+    static String splitIntoSortedDigits(int... nums) {\n+        // Collect all digits in a list.\n         ArrayList<Integer> digits = new ArrayList<>();\n-        while (num > 0) {\n-            digits.add(num % 10);\n-            num /= 10;\n-        }\n-        while (num2 > 0) {\n-            digits.add(num2 % 10);\n-            num2 /= 10;\n-        }\n-        Collections.sort(digits);\n-        for (int i : digits) {\n-            res.append(i);\n+        for (int num : nums) {\n+            while (num > 0) {\n+                digits.add(num % 10);\n+                num /= 10;\n+            }\n         }\n \n+        // Sort all digits and convert to String.\n+        StringBuilder res = new StringBuilder();\n+        digits.stream().sorted().forEach(res::append);\n         return res.toString();\n     }\n }\ndiff --git a/src/test/java/com/thealgorithms/maths/VampireNumberTest.java b/src/test/java/com/thealgorithms/maths/VampireNumberTest.java\nnew file mode 100644\nindex 000000000000..6f331f1252cd\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/maths/VampireNumberTest.java\n@@ -0,0 +1,32 @@\n+package com.thealgorithms.maths;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+class VampireNumberTest {\n+    @Test\n+    void areVampireNumbers() {\n+        Assertions.assertTrue(VampireNumber.isVampireNumber(15, 93, true));\n+        Assertions.assertTrue(VampireNumber.isVampireNumber(135, 801, true));\n+        Assertions.assertTrue(VampireNumber.isVampireNumber(201, 600, true));\n+    }\n+\n+    @Test\n+    void arePseudoVampireNumbers() {\n+        Assertions.assertTrue(VampireNumber.isVampireNumber(150, 93, false));\n+        Assertions.assertTrue(VampireNumber.isVampireNumber(546, 84, false));\n+        Assertions.assertTrue(VampireNumber.isVampireNumber(641, 65, false));\n+    }\n+\n+    @Test\n+    void areNotVampireNumbers() {\n+        Assertions.assertFalse(VampireNumber.isVampireNumber(51, 39, false));\n+        Assertions.assertFalse(VampireNumber.isVampireNumber(51, 39, true));\n+    }\n+\n+    @Test\n+    void testSplitIntoSortedDigits() {\n+        Assertions.assertEquals(\"123\", VampireNumber.splitIntoSortedDigits(321));\n+        Assertions.assertEquals(\"02234\", VampireNumber.splitIntoSortedDigits(20, 324));\n+    }\n+}",
    "output": {
      "why": "The changes enhance code clarity by refining comments and method names, and a new unit test class is added for validating the vampire number functionality and edge cases.",
      "commit_message": "Refactor `VampireNumber` class and add unit tests\n- Improved the documentation in the `VampireNumber` class for better clarity and understanding.\n- Renamed method `isVampireNumber` parameter for clarity.\n- Changed the implementation of digit splitting to allow for multiple numbers and sort them in ascending order.\n- Introduced a new test class `VampireNumberTest` to cover scenarios for vampire and pseudo vampire numbers.\n- Added assertions to test number validity and edge cases."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/backtracking/Combination.java b/src/main/java/com/thealgorithms/backtracking/Combination.java\nindex bf2a672a0ef8..ecaf7428f986 100644\n--- a/src/main/java/com/thealgorithms/backtracking/Combination.java\n+++ b/src/main/java/com/thealgorithms/backtracking/Combination.java\n@@ -1,6 +1,7 @@\n package com.thealgorithms.backtracking;\n \n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.TreeSet;\n@@ -13,8 +14,6 @@ public final class Combination {\n     private Combination() {\n     }\n \n-    private static int length;\n-\n     /**\n      * Find all combinations of given array using backtracking\n      * @param arr the array.\n@@ -23,39 +22,45 @@ private Combination() {\n      * @return a list of all combinations of length n. If n == 0, return null.\n      */\n     public static <T> List<TreeSet<T>> combination(T[] arr, int n) {\n+        if (n < 0) {\n+            throw new IllegalArgumentException(\"The combination length cannot be negative.\");\n+        }\n+\n         if (n == 0) {\n-            return null;\n+            return Collections.emptyList();\n         }\n-        length = n;\n         T[] array = arr.clone();\n         Arrays.sort(array);\n+\n         List<TreeSet<T>> result = new LinkedList<>();\n-        backtracking(array, 0, new TreeSet<T>(), result);\n+        backtracking(array, n, 0, new TreeSet<T>(), result);\n         return result;\n     }\n \n     /**\n      * Backtrack all possible combinations of a given array\n      * @param arr the array.\n+     * @param n length of the combination\n      * @param index the starting index.\n      * @param currSet set that tracks current combination\n      * @param result the list contains all combination.\n      * @param <T> the type of elements in the array.\n      */\n-    private static <T> void backtracking(T[] arr, int index, TreeSet<T> currSet, List<TreeSet<T>> result) {\n-        if (index + length - currSet.size() > arr.length) {\n+    private static <T> void backtracking(T[] arr, int n, int index, TreeSet<T> currSet, List<TreeSet<T>> result) {\n+        if (index + n - currSet.size() > arr.length) {\n             return;\n         }\n-        if (length - 1 == currSet.size()) {\n+        if (currSet.size() == n - 1) {\n             for (int i = index; i < arr.length; i++) {\n                 currSet.add(arr[i]);\n-                result.add((TreeSet<T>) currSet.clone());\n+                result.add(new TreeSet<>(currSet));\n                 currSet.remove(arr[i]);\n             }\n+            return;\n         }\n         for (int i = index; i < arr.length; i++) {\n             currSet.add(arr[i]);\n-            backtracking(arr, i + 1, currSet, result);\n+            backtracking(arr, n, i + 1, currSet, result);\n             currSet.remove(arr[i]);\n         }\n     }\ndiff --git a/src/test/java/com/thealgorithms/backtracking/CombinationTest.java b/src/test/java/com/thealgorithms/backtracking/CombinationTest.java\nindex 44edc3077fd5..a9d1163f3ecd 100644\n--- a/src/test/java/com/thealgorithms/backtracking/CombinationTest.java\n+++ b/src/test/java/com/thealgorithms/backtracking/CombinationTest.java\n@@ -1,17 +1,28 @@\n package com.thealgorithms.backtracking;\n \n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n import java.util.List;\n+import java.util.Set;\n import java.util.TreeSet;\n import org.junit.jupiter.api.Test;\n \n public class CombinationTest {\n \n+    @Test\n+    void testNegativeElement() {\n+        Integer[] array = {1, 2};\n+        assertThrows(IllegalArgumentException.class, () -> { Combination.combination(array, -1); });\n+    }\n+\n     @Test\n     void testNoElement() {\n         List<TreeSet<Integer>> result = Combination.combination(new Integer[] {1, 2}, 0);\n-        assertTrue(result == null);\n+        assertNotNull(result);\n+        assertEquals(0, result.size());\n     }\n \n     @Test\n@@ -28,4 +39,13 @@ void testLengthTwo() {\n         assertTrue(arr[0] == 1);\n         assertTrue(arr[1] == 2);\n     }\n+\n+    @Test\n+    void testCombinationsWithStrings() {\n+        List<TreeSet<String>> result = Combination.combination(new String[] {\"a\", \"b\", \"c\"}, 2);\n+        assertEquals(3, result.size());\n+        assertTrue(result.contains(new TreeSet<>(Set.of(\"a\", \"b\"))));\n+        assertTrue(result.contains(new TreeSet<>(Set.of(\"a\", \"c\"))));\n+        assertTrue(result.contains(new TreeSet<>(Set.of(\"b\", \"c\"))));\n+    }\n }",
    "output": {
      "why": "The changes were likely made to improve input validation for the combination generation method by rejecting negative values, ensuring the method behaves correctly. Additionally, modifications in the backtracking logic and method parameters help streamline the process of generating combinations based on a specified length.",
      "commit_message": "Enhance combination generation with input validation and logic refinement\n- Added a check for negative values in the `combination` method, throwing an `IllegalArgumentException` if `n` is negative.\n- Adjusted the method signature of `backtracking` to accept `n` as a parameter, enhancing clarity and functionality.\n- Modified return behavior for a zero-length combination to return an empty list instead of null.\n- Updated test cases to include validation for negative input and to confirm behavior for combinations with string elements."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java b/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java\nindex cf0de4a92030..ff02fe38970b 100644\n--- a/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java\n+++ b/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java\n@@ -144,7 +144,7 @@ public boolean remove(int value) {\n             if (temp == root) {\n                 root = null;\n             } // This if/else assigns the new node to be either the left or right child of the\n-              // parent\n+            // parent\n             else if (temp.parent.data < temp.data) {\n                 temp.parent.right = null;\n             } else {\ndiff --git a/src/main/java/com/thealgorithms/slidingwindow/LongestSubarrayWithSumLessOrEqualToK.java b/src/main/java/com/thealgorithms/slidingwindow/LongestSubarrayWithSumLessOrEqualToK.java\nnew file mode 100644\nindex 000000000000..55c3f709b467\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/slidingwindow/LongestSubarrayWithSumLessOrEqualToK.java\n@@ -0,0 +1,48 @@\n+package com.thealgorithms.slidingwindow;\n+\n+/**\n+ * The Longest Subarray with Sum Less Than or Equal to k algorithm finds the length\n+ * of the longest subarray whose sum is less than or equal to a given value k.\n+ *\n+ * <p>\n+ * Worst-case performance O(n)\n+ * Best-case performance O(n)\n+ * Average performance O(n)\n+ * Worst-case space complexity O(1)\n+ *\n+ * @author https://github.com/Chiefpatwal\n+ */\n+public final class LongestSubarrayWithSumLessOrEqualToK {\n+\n+    // Prevent instantiation\n+    private LongestSubarrayWithSumLessOrEqualToK() {\n+    }\n+\n+    /**\n+     * This method finds the length of the longest subarray with a sum less than or equal to k.\n+     *\n+     * @param arr is the input array\n+     * @param k   is the maximum sum allowed\n+     * @return the length of the longest subarray with sum less than or equal to k\n+     */\n+    public static int longestSubarrayWithSumLEK(int[] arr, int k) {\n+        int maxLength = 0; // To store the maximum length found\n+        int currentSum = 0; // To store the current sum of the window\n+        int left = 0; // Left index of the sliding window\n+\n+        for (int right = 0; right < arr.length; right++) {\n+            currentSum += arr[right]; // Expand the window to the right\n+\n+            // Shrink the window from the left if the current sum exceeds k\n+            while (currentSum > k && left <= right) {\n+                currentSum -= arr[left]; // Remove the leftmost element\n+                left++; // Move the left index to the right\n+            }\n+\n+            // Update maxLength if the current window is valid\n+            maxLength = Math.max(maxLength, right - left + 1);\n+        }\n+\n+        return maxLength; // Return the maximum length found\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/datastructures/trees/BinaryTreeTest.java b/src/test/java/com/thealgorithms/datastructures/trees/BinaryTreeTest.java\nindex 08a82e50ca02..d6581fb8c4e8 100644\n--- a/src/test/java/com/thealgorithms/datastructures/trees/BinaryTreeTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/trees/BinaryTreeTest.java\n@@ -1,82 +1,78 @@\n package com.thealgorithms.datastructures.trees;\n \n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.fail;\n-\n+import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n \n+/**\n+ * Unit tests for the BinaryTree class.\n+ */\n public class BinaryTreeTest {\n \n-    // checks that adding populating the tree and searching for data\n-    // retrieves the expected data\n     @Test\n-    void test1() {\n-        BinaryTree t = new BinaryTree();\n-        t.put(3);\n-        t.put(5);\n-        t.put(7);\n-        t.put(9);\n-        t.put(12);\n+    public void testInsertAndFind() {\n+        BinaryTree tree = new BinaryTree();\n+        tree.put(3);\n+        tree.put(5);\n+        tree.put(7);\n+        tree.put(9);\n+        tree.put(12);\n \n-        assertEquals(t.find(5).data, 5);\n-        assertEquals(t.find(7).data, 7);\n+        Assertions.assertNotNull(tree.find(5), \"Node with value 5 should exist\");\n+        Assertions.assertEquals(5, tree.find(5).data, \"Value of the found node should be 5\");\n+        Assertions.assertEquals(7, tree.find(7).data, \"Value of the found node should be 7\");\n     }\n \n-    // checks that removing data from the tree\n-    // properly removes and makes the new root the expected new root\n     @Test\n-    void test2() {\n-        BinaryTree t = new BinaryTree();\n-        t.put(3);\n-        t.put(5);\n-        t.put(7);\n-        t.put(9);\n-        t.put(12);\n-        t.remove(3);\n-        t.remove(5);\n-        t.remove(7);\n+    public void testRemove() {\n+        BinaryTree tree = new BinaryTree();\n+        tree.put(3);\n+        tree.put(5);\n+        tree.put(7);\n+        tree.put(9);\n+        tree.put(12);\n+        tree.remove(3);\n+        tree.remove(5);\n+        tree.remove(7);\n \n-        // Checks whether the root is null before accessing date\n-        if (t.getRoot() != null) {\n-            assertEquals(t.getRoot().data, 9);\n+        Assertions.assertNotNull(tree.getRoot(), \"Root should not be null after removals\");\n+        if (tree.getRoot() != null) {\n+            Assertions.assertEquals(9, tree.getRoot().data, \"Root value should be 9 after removals\");\n         } else {\n-            fail(\"The root node is null after removal.\");\n+            Assertions.fail(\"Root should not be null after removals, but it is.\");\n         }\n     }\n \n-    // checks that removing an unexistend node returns false\n-    //  as specified by the documentation of the function\n     @Test\n-    void test3() {\n-        BinaryTree t = new BinaryTree();\n-        t.put(3);\n-        t.put(5);\n-        t.put(7);\n-        t.put(9);\n-        t.put(12);\n+    public void testRemoveReturnValue() {\n+        BinaryTree tree = new BinaryTree();\n+        tree.put(3);\n+        tree.put(5);\n+        tree.put(7);\n+        tree.put(9);\n+        tree.put(12);\n \n-        assertEquals(t.remove(9), true);\n-        assertEquals(t.remove(398745987), false);\n+        Assertions.assertTrue(tree.remove(9), \"Removing existing node 9 should return true\");\n+        Assertions.assertFalse(tree.remove(398745987), \"Removing non-existing node should return false\");\n     }\n \n-    // check if the bfs, inOrder, preOrder and postOrder functions\n-    // worg as expected, also increases the coverage measures in\n-    // JaCoCo\n     @Test\n-    void test4() {\n-        BinaryTree t = new BinaryTree();\n-        t.put(3);\n-        t.put(5);\n-        t.put(7);\n-        t.put(9);\n-        t.put(12);\n+    public void testTraversalMethods() {\n+        BinaryTree tree = new BinaryTree();\n+        tree.put(3);\n+        tree.put(5);\n+        tree.put(7);\n+        tree.put(9);\n+        tree.put(12);\n+\n+        // Testing traversal methods\n+        tree.bfs(tree.getRoot());\n+        tree.inOrder(tree.getRoot());\n+        tree.preOrder(tree.getRoot());\n+        tree.postOrder(tree.getRoot());\n \n-        t.bfs(t.find(12));\n-        t.inOrder(t.getRoot());\n-        t.preOrder(t.getRoot());\n-        t.postOrder(t.getRoot());\n+        Assertions.assertTrue(tree.remove(9), \"Removing existing node 9 should return true\");\n+        Assertions.assertFalse(tree.remove(398745987), \"Removing non-existing node should return false\");\n \n-        assertEquals(t.remove(9), true);\n-        assertEquals(t.remove(398745987), false);\n+        Assertions.assertNotNull(tree.getRoot(), \"Root should not be null after operations\");\n     }\n }\ndiff --git a/src/test/java/com/thealgorithms/slidingwindow/LongestSubarrayWithSumLessOrEqualToKTest.java b/src/test/java/com/thealgorithms/slidingwindow/LongestSubarrayWithSumLessOrEqualToKTest.java\nnew file mode 100644\nindex 000000000000..da282ab35ef3\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/slidingwindow/LongestSubarrayWithSumLessOrEqualToKTest.java\n@@ -0,0 +1,22 @@\n+package com.thealgorithms.slidingwindow;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Unit tests for the LongestSubarrayWithSumLessOrEqualToK algorithm.\n+ */\n+public class LongestSubarrayWithSumLessOrEqualToKTest {\n+\n+    /**\n+     * Tests for the longest subarray with a sum less than or equal to k.\n+     */\n+    @Test\n+    public void testLongestSubarrayWithSumLEK() {\n+        assertEquals(3, LongestSubarrayWithSumLessOrEqualToK.longestSubarrayWithSumLEK(new int[] {1, 2, 3, 4}, 6)); // {1, 2, 3}\n+        assertEquals(4, LongestSubarrayWithSumLessOrEqualToK.longestSubarrayWithSumLEK(new int[] {1, 2, 3, 4}, 10)); // {1, 2, 3, 4}\n+        assertEquals(2, LongestSubarrayWithSumLessOrEqualToK.longestSubarrayWithSumLEK(new int[] {5, 1, 2, 3}, 5)); // {5}\n+        assertEquals(0, LongestSubarrayWithSumLessOrEqualToK.longestSubarrayWithSumLEK(new int[] {1, 2, 3}, 0)); // No valid subarray\n+    }\n+}",
    "output": {
      "why": "The comment adjustment in `BinaryTree.java` makes the code clearer for future maintainers. The introduction of `LongestSubarrayWithSumLessOrEqualToK` enhances the functionality of the project. Refactoring tests improves readability and maintains consistency in testing assertions.",
      "commit_message": "Refactor comment in `BinaryTree` and add `LongestSubarrayWithSumLessOrEqualToK` class\n- Updated a comment in `BinaryTree.java` for improved clarity.\n- Introduced `LongestSubarrayWithSumLessOrEqualToK` class to compute the length of the longest subarray with a sum less than or equal to k, complete with performance documentation.\n- Refactored `BinaryTreeTest` methods for better naming conventions and enhanced the use of assertions for better test clarity.\n- Added unit tests for the new `LongestSubarrayWithSumLessOrEqualToK` class."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/slidingwindow/MinSumKSizeSubarray.java b/src/main/java/com/thealgorithms/slidingwindow/MinSumKSizeSubarray.java\nnew file mode 100644\nindex 000000000000..40a5441fa7a0\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/slidingwindow/MinSumKSizeSubarray.java\n@@ -0,0 +1,51 @@\n+package com.thealgorithms.slidingwindow;\n+/**\n+ * The Sliding Window algorithm is used to find the minimum sum of a subarray\n+ * of a fixed size k within a given array.\n+ *\n+ * <p>\n+ * Worst-case performance O(n)\n+ * Best-case performance O(n)\n+ * Average performance O(n)\n+ * Worst-case space complexity O(1)\n+ *\n+ * This class provides a static method to find the minimum sum of a subarray\n+ * with a specified length k.\n+ *\n+ * @author Rashi Dashore (https://github.com/rashi07dashore)\n+ */\n+public final class MinSumKSizeSubarray {\n+\n+    // Prevent instantiation\n+    private MinSumKSizeSubarray() {\n+    }\n+\n+    /**\n+     * This method finds the minimum sum of a subarray of a given size k.\n+     *\n+     * @param arr is the input array where the minimum sum needs to be found\n+     * @param k   is the size of the subarray\n+     * @return the minimum sum of the subarray of size k\n+     */\n+    public static int minSumKSizeSubarray(int[] arr, int k) {\n+        if (arr.length < k) {\n+            return -1; // Edge case: not enough elements\n+        }\n+\n+        int minSum;\n+        int windowSum = 0;\n+\n+        // Calculate the sum of the first window\n+        for (int i = 0; i < k; i++) {\n+            windowSum += arr[i];\n+        }\n+        minSum = windowSum;\n+\n+        // Slide the window across the array\n+        for (int i = k; i < arr.length; i++) {\n+            windowSum += arr[i] - arr[i - k];\n+            minSum = Math.min(minSum, windowSum);\n+        }\n+        return minSum;\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/slidingwindow/MinSumKSizeSubarrayTest.java b/src/test/java/com/thealgorithms/slidingwindow/MinSumKSizeSubarrayTest.java\nnew file mode 100644\nindex 000000000000..4656c8baf327\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/slidingwindow/MinSumKSizeSubarrayTest.java\n@@ -0,0 +1,79 @@\n+package com.thealgorithms.slidingwindow;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Unit tests for the MinSumKSizeSubarray class.\n+ *\n+ * @author Rashi Dashore (https://github.com/rashi07dashore)\n+ */\n+class MinSumKSizeSubarrayTest {\n+\n+    /**\n+     * Test for the basic case of finding the minimum sum.\n+     */\n+    @Test\n+    void testMinSumKSizeSubarray() {\n+        int[] arr = {2, 1, 5, 1, 3, 2};\n+        int k = 3;\n+        int expectedMinSum = 6; // Corrected: Minimum sum of a subarray of size 3\n+        assertEquals(expectedMinSum, MinSumKSizeSubarray.minSumKSizeSubarray(arr, k));\n+    }\n+\n+    /**\n+     * Test for a different array and subarray size.\n+     */\n+    @Test\n+    void testMinSumKSizeSubarrayWithDifferentValues() {\n+        int[] arr = {1, 2, 3, 4, 5};\n+        int k = 2;\n+        int expectedMinSum = 3; // 1 + 2\n+        assertEquals(expectedMinSum, MinSumKSizeSubarray.minSumKSizeSubarray(arr, k));\n+    }\n+\n+    /**\n+     * Test for edge case with insufficient elements.\n+     */\n+    @Test\n+    void testMinSumKSizeSubarrayWithInsufficientElements() {\n+        int[] arr = {1, 2};\n+        int k = 3; // Not enough elements\n+        int expectedMinSum = -1; // Edge case\n+        assertEquals(expectedMinSum, MinSumKSizeSubarray.minSumKSizeSubarray(arr, k));\n+    }\n+\n+    /**\n+     * Test for large array.\n+     */\n+    @Test\n+    void testMinSumKSizeSubarrayWithLargeArray() {\n+        int[] arr = {5, 4, 3, 2, 1, 0, -1, -2, -3, -4};\n+        int k = 5;\n+        int expectedMinSum = -10; // -1 + -2 + -3 + -4 + 0\n+        assertEquals(expectedMinSum, MinSumKSizeSubarray.minSumKSizeSubarray(arr, k));\n+    }\n+\n+    /**\n+     * Test for array with negative numbers.\n+     */\n+    @Test\n+    void testMinSumKSizeSubarrayWithNegativeNumbers() {\n+        int[] arr = {-1, -2, -3, -4, -5};\n+        int k = 2;\n+        int expectedMinSum = -9; // -4 + -5\n+        assertEquals(expectedMinSum, MinSumKSizeSubarray.minSumKSizeSubarray(arr, k));\n+    }\n+\n+    /**\n+     * Test for the case where k equals the array length.\n+     */\n+    @Test\n+    void testMinSumKSizeSubarrayWithKEqualToArrayLength() {\n+        int[] arr = {1, 2, 3, 4, 5};\n+        int k = 5;\n+        int expectedMinSum = 15; // 1 + 2 + 3 + 4 + 5\n+        assertEquals(expectedMinSum, MinSumKSizeSubarray.minSumKSizeSubarray(arr, k));\n+    }\n+}",
    "output": {
      "why": "The implementation of the `MinSumKSizeSubarray` class is aimed at providing a utility to find the minimum sum of a subarray of fixed size `k`. The accompanying test class ensures the correctness of this implementation across various scenarios, including edge cases.",
      "commit_message": "Implement `MinSumKSizeSubarray` class and associated tests\n- Introduced a new class `MinSumKSizeSubarray` that utilizes the sliding window algorithm to calculate the minimum sum of a subarray of size `k`.\n- Added unit tests in `MinSumKSizeSubarrayTest` to validate functionality, including basic cases, edge cases, and scenarios with negative numbers.\n- Ensured robust error handling for cases where the array length is less than `k`."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/AbsoluteMax.java b/src/main/java/com/thealgorithms/maths/AbsoluteMax.java\nindex d0c3db3790a3..c32a408b6609 100644\n--- a/src/main/java/com/thealgorithms/maths/AbsoluteMax.java\n+++ b/src/main/java/com/thealgorithms/maths/AbsoluteMax.java\n@@ -17,7 +17,7 @@ public static int getMaxValue(int... numbers) {\n         }\n         int absMax = numbers[0];\n         for (int i = 1; i < numbers.length; i++) {\n-            if (Math.abs(numbers[i]) > Math.abs(absMax)) {\n+            if (Math.abs(numbers[i]) > Math.abs(absMax) || (Math.abs(numbers[i]) == Math.abs(absMax) && numbers[i] > absMax)) {\n                 absMax = numbers[i];\n             }\n         }\ndiff --git a/src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java b/src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java\nindex 70d2f64bc541..33461fbbc088 100644\n--- a/src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java\n+++ b/src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java\n@@ -19,4 +19,12 @@ void testGetMaxValue() {\n     void testGetMaxValueWithNoArguments() {\n         assertThrows(IllegalArgumentException.class, AbsoluteMax::getMaxValue);\n     }\n+\n+    @Test\n+    void testGetMaxValueWithSameAbsoluteValues() {\n+        assertEquals(5, AbsoluteMax.getMaxValue(-5, 5));\n+        assertEquals(5, AbsoluteMax.getMaxValue(5, -5));\n+        assertEquals(12, AbsoluteMax.getMaxValue(-12, 9, 3, 12, 1));\n+        assertEquals(12, AbsoluteMax.getMaxValue(12, 9, 3, -12, 1));\n+    }\n }",
    "output": {
      "why": "The changes in the `getMaxValue` method enhance its logic by ensuring that when two numbers have the same absolute value, the larger number is returned. Additionally, new test cases in `AbsoluteMaxTest` validate this behavior with various scenarios, ensuring the correctness of the implementation.",
      "commit_message": "Enhance `getMaxValue` to handle equal absolute values\n- Modified the condition in `getMaxValue` to return the maximum of two numbers when they have the same absolute value.\n- Added tests in `AbsoluteMaxTest` to confirm the functionality for scenarios with equal absolute values, ensuring the method correctly identifies the greater value."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayList.java b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayList.java\nindex a1ef457f3432..89e25f4eb0f7 100644\n--- a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayList.java\n+++ b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayList.java\n@@ -3,12 +3,34 @@\n import java.util.ArrayList;\n import java.util.LinkedList;\n \n+/**\n+ * A generic implementation of a hash map using an array list of linked lists for collision resolution.\n+ * This class allows storage of key-value pairs with average-case constant time complexity for insertion,\n+ * deletion, and retrieval operations.\n+ *\n+ * <p>\n+ * The hash map uses separate chaining to handle collisions. Each bucket in the hash map is represented\n+ * by a linked list that holds nodes containing key-value pairs. When multiple keys hash to the same index,\n+ * they are stored in the same linked list.\n+ * </p>\n+ *\n+ * <p>\n+ * The hash map automatically resizes itself when the load factor exceeds 0.5. The load factor is defined\n+ * as the ratio of the number of entries to the number of buckets. When resizing occurs, all existing entries\n+ * are rehashed and inserted into the new buckets.\n+ * </p>\n+ *\n+ * @param <K> the type of keys maintained by this hash map\n+ * @param <V> the type of mapped values\n+ */\n public class GenericHashMapUsingArrayList<K, V> {\n \n-    ArrayList<LinkedList<Node>> buckets;\n-    private float lf = 0.5f;\n-    private int size;\n+    private ArrayList<LinkedList<Node>> buckets; // Array list of buckets (linked lists)\n+    private int size; // Number of key-value pairs in the hash map\n \n+    /**\n+     * Constructs a new empty hash map with an initial capacity of 10 buckets.\n+     */\n     public GenericHashMapUsingArrayList() {\n         buckets = new ArrayList<>();\n         for (int i = 0; i < 10; i++) {\n@@ -17,6 +39,13 @@ public GenericHashMapUsingArrayList() {\n         size = 0;\n     }\n \n+    /**\n+     * Associates the specified value with the specified key in this map.\n+     * If the map previously contained a mapping for the key, the old value is replaced.\n+     *\n+     * @param key the key with which the specified value is to be associated\n+     * @param value the value to be associated with the specified key\n+     */\n     public void put(K key, V value) {\n         int hash = Math.abs(key.hashCode() % buckets.size());\n         LinkedList<Node> nodes = buckets.get(hash);\n@@ -31,25 +60,36 @@ public void put(K key, V value) {\n         nodes.add(new Node(key, value));\n         size++;\n \n-        if ((float) size / buckets.size() > lf) {\n+        // Load factor threshold for resizing\n+        float loadFactorThreshold = 0.5f;\n+        if ((float) size / buckets.size() > loadFactorThreshold) {\n             reHash();\n         }\n     }\n \n+    /**\n+     * Resizes the hash map by doubling the number of buckets and rehashing existing entries.\n+     */\n     private void reHash() {\n-        ArrayList<LinkedList<Node>> old = buckets;\n+        ArrayList<LinkedList<Node>> oldBuckets = buckets;\n         buckets = new ArrayList<>();\n         size = 0;\n-        for (int i = 0; i < old.size() * 2; i++) {\n+        for (int i = 0; i < oldBuckets.size() * 2; i++) {\n             buckets.add(new LinkedList<>());\n         }\n-        for (LinkedList<Node> nodes : buckets) {\n+        for (LinkedList<Node> nodes : oldBuckets) {\n             for (Node node : nodes) {\n                 put(node.key, node.val);\n             }\n         }\n     }\n \n+    /**\n+     * Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.\n+     *\n+     * @param key the key whose associated value is to be returned\n+     * @return the value associated with the specified key, or null if no mapping exists\n+     */\n     public V get(K key) {\n         int hash = Math.abs(key.hashCode() % buckets.size());\n         LinkedList<Node> nodes = buckets.get(hash);\n@@ -61,6 +101,11 @@ public V get(K key) {\n         return null;\n     }\n \n+    /**\n+     * Removes the mapping for the specified key from this map if present.\n+     *\n+     * @param key the key whose mapping is to be removed from the map\n+     */\n     public void remove(K key) {\n         int hash = Math.abs(key.hashCode() % buckets.size());\n         LinkedList<Node> nodes = buckets.get(hash);\n@@ -72,18 +117,36 @@ public void remove(K key) {\n                 break;\n             }\n         }\n-        nodes.remove(target);\n-        size--;\n+        if (target != null) {\n+            nodes.remove(target);\n+            size--;\n+        }\n     }\n \n+    /**\n+     * Returns true if this map contains a mapping for the specified key.\n+     *\n+     * @param key the key whose presence in this map is to be tested\n+     * @return true if this map contains a mapping for the specified key\n+     */\n     public boolean containsKey(K key) {\n         return get(key) != null;\n     }\n \n+    /**\n+     * Returns the number of key-value pairs in this map.\n+     *\n+     * @return the number of key-value pairs\n+     */\n     public int size() {\n         return this.size;\n     }\n \n+    /**\n+     * Returns a string representation of the map, containing all key-value pairs.\n+     *\n+     * @return a string representation of the map\n+     */\n     @Override\n     public String toString() {\n         StringBuilder builder = new StringBuilder();\n@@ -96,15 +159,27 @@ public String toString() {\n                 builder.append(\", \");\n             }\n         }\n+        // Remove trailing comma and space if there are any elements\n+        if (builder.length() > 1) {\n+            builder.setLength(builder.length() - 2);\n+        }\n         builder.append(\"}\");\n         return builder.toString();\n     }\n \n+    /**\n+     * A private inner class representing a key-value pair (node) in the hash map.\n+     */\n     private class Node {\n-\n         K key;\n         V val;\n \n+        /**\n+         * Constructs a new Node with the specified key and value.\n+         *\n+         * @param key the key of the key-value pair\n+         * @param val the value of the key-value pair\n+         */\n         Node(K key, V val) {\n             this.key = key;\n             this.val = val;\ndiff --git a/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayListTest.java b/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayListTest.java\nindex 37e43d2aada3..629aaae95753 100644\n--- a/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayListTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayListTest.java\n@@ -50,4 +50,47 @@ void testGenericHashmapWhichUsesArrayAndKeyIsIntegerValueIsString() {\n         assertEquals(\"Washington DC\", map.get(101));\n         assertTrue(map.containsKey(46));\n     }\n+\n+    @Test\n+    void testRemoveNonExistentKey() {\n+        GenericHashMapUsingArrayList<String, String> map = new GenericHashMapUsingArrayList<>();\n+        map.put(\"USA\", \"Washington DC\");\n+        map.remove(\"Nepal\"); // Attempting to remove a non-existent key\n+        assertEquals(1, map.size()); // Size should remain the same\n+    }\n+\n+    @Test\n+    void testRehashing() {\n+        GenericHashMapUsingArrayList<String, String> map = new GenericHashMapUsingArrayList<>();\n+        for (int i = 0; i < 20; i++) {\n+            map.put(\"Key\" + i, \"Value\" + i);\n+        }\n+        assertEquals(20, map.size()); // Ensure all items were added\n+        assertEquals(\"Value5\", map.get(\"Key5\")); // Check retrieval after rehash\n+    }\n+\n+    @Test\n+    void testUpdateValueForExistingKey() {\n+        GenericHashMapUsingArrayList<String, String> map = new GenericHashMapUsingArrayList<>();\n+        map.put(\"USA\", \"Washington DC\");\n+        map.put(\"USA\", \"New Washington DC\"); // Updating value for existing key\n+        assertEquals(\"New Washington DC\", map.get(\"USA\"));\n+    }\n+\n+    @Test\n+    void testToStringMethod() {\n+        GenericHashMapUsingArrayList<String, String> map = new GenericHashMapUsingArrayList<>();\n+        map.put(\"USA\", \"Washington DC\");\n+        map.put(\"Nepal\", \"Kathmandu\");\n+        String expected = \"{USA : Washington DC, Nepal : Kathmandu}\";\n+        assertEquals(expected, map.toString());\n+    }\n+\n+    @Test\n+    void testContainsKey() {\n+        GenericHashMapUsingArrayList<String, String> map = new GenericHashMapUsingArrayList<>();\n+        map.put(\"USA\", \"Washington DC\");\n+        assertTrue(map.containsKey(\"USA\"));\n+        assertFalse(map.containsKey(\"Nepal\"));\n+    }\n }",
    "output": {
      "why": "The changes aim to enhance code documentation for better understanding of the `GenericHashMapUsingArrayList` class. New Javadoc comments were added to explain class methods and their parameters clearly. Furthermore, additional test cases ensure that edge cases, such as removing non-existent keys and rehashing behavior, are addressed, which helps improve reliability.",
      "commit_message": "Enhance documentation and tests for `GenericHashMapUsingArrayList`\n- Added detailed Javadoc comments for all methods in the `GenericHashMapUsingArrayList` class to improve maintainability and clarity.\n- Improved the structure of methods by clarifying variable declarations and enhancing readability.\n- Introduced new test cases to validate:\n- Behavior when attempting to remove a non-existent key.\n- Correct behavior of rehashing after exceeding load factor.\n- Updating values for existing keys.\n- Proper string representation of the hash map entries.\n- Existence checks for keys."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/heaps/FibonacciHeap.java b/src/main/java/com/thealgorithms/datastructures/heaps/FibonacciHeap.java\nindex d248bc3316ed..7a263fc08ac5 100644\n--- a/src/main/java/com/thealgorithms/datastructures/heaps/FibonacciHeap.java\n+++ b/src/main/java/com/thealgorithms/datastructures/heaps/FibonacciHeap.java\n@@ -1,5 +1,30 @@\n package com.thealgorithms.datastructures.heaps;\n \n+/**\n+ * The {@code FibonacciHeap} class implements a Fibonacci Heap data structure,\n+ * which is a collection of trees that satisfy the minimum heap property.\n+ * This heap allows for efficient merging of heaps, as well as faster\n+ * decrease-key and delete operations compared to other heap data structures.\n+ *\n+ * <p>Key features of the Fibonacci Heap include:\n+ * <ul>\n+ *   <li>Amortized O(1) time complexity for insert and decrease-key operations.</li>\n+ *   <li>Amortized O(log n) time complexity for delete and delete-min operations.</li>\n+ *   <li>Meld operation that combines two heaps in O(1) time.</li>\n+ *   <li>Potential function that helps analyze the amortized time complexity.</li>\n+ * </ul>\n+ *\n+ * <p>This implementation maintains additional statistics such as the total number\n+ * of link and cut operations performed during the lifetime of the heap, which can\n+ * be accessed through static methods.\n+ *\n+ * <p>The Fibonacci Heap is composed of nodes represented by the inner class\n+ * {@code HeapNode}. Each node maintains a key, rank, marked status, and pointers\n+ * to its children and siblings. Nodes can be linked and cut as part of the heap\n+ * restructuring processes.\n+ *\n+ * @see HeapNode\n+ */\n public class FibonacciHeap {\n \n     private static final double GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;\ndiff --git a/src/test/java/com/thealgorithms/datastructures/heaps/FibonacciHeapTest.java b/src/test/java/com/thealgorithms/datastructures/heaps/FibonacciHeapTest.java\nindex b414bab2b8a0..d911f3ac30d8 100644\n--- a/src/test/java/com/thealgorithms/datastructures/heaps/FibonacciHeapTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/heaps/FibonacciHeapTest.java\n@@ -6,7 +6,7 @@\n public class FibonacciHeapTest {\n \n     @Test\n-    void testHeap() {\n+    void testHeapInsertionAndMinimum() {\n         FibonacciHeap fibonacciHeap = new FibonacciHeap();\n         fibonacciHeap.insert(5);\n         fibonacciHeap.insert(3);\n@@ -14,8 +14,95 @@ void testHeap() {\n         fibonacciHeap.insert(18);\n         fibonacciHeap.insert(33);\n \n-        Assertions.assertEquals(fibonacciHeap.findMin().getKey(), 1);\n+        Assertions.assertEquals(1, fibonacciHeap.findMin().getKey());\n         fibonacciHeap.deleteMin();\n-        Assertions.assertEquals(fibonacciHeap.findMin().getKey(), 3);\n+        Assertions.assertEquals(3, fibonacciHeap.findMin().getKey());\n+    }\n+\n+    @Test\n+    void testDeleteMinOnSingleElementHeap() {\n+        FibonacciHeap fibonacciHeap = new FibonacciHeap(10);\n+        Assertions.assertEquals(10, fibonacciHeap.findMin().getKey());\n+        fibonacciHeap.deleteMin();\n+        Assertions.assertTrue(fibonacciHeap.empty());\n+    }\n+\n+    @Test\n+    void testHeapMeld() {\n+        FibonacciHeap heap1 = new FibonacciHeap();\n+        FibonacciHeap heap2 = new FibonacciHeap();\n+        heap1.insert(1);\n+        heap1.insert(2);\n+        heap2.insert(3);\n+        heap2.insert(4);\n+\n+        heap1.meld(heap2);\n+        Assertions.assertEquals(1, heap1.findMin().getKey());\n+    }\n+\n+    @Test\n+    void testHeapSize() {\n+        FibonacciHeap fibonacciHeap = new FibonacciHeap();\n+        Assertions.assertEquals(0, fibonacciHeap.size());\n+        fibonacciHeap.insert(5);\n+        Assertions.assertEquals(1, fibonacciHeap.size());\n+        fibonacciHeap.insert(3);\n+        Assertions.assertEquals(2, fibonacciHeap.size());\n+        fibonacciHeap.deleteMin();\n+        Assertions.assertEquals(1, fibonacciHeap.size());\n+    }\n+\n+    @Test\n+    void testCountersRep() {\n+        FibonacciHeap fibonacciHeap = new FibonacciHeap();\n+        fibonacciHeap.insert(5);\n+        fibonacciHeap.insert(3);\n+        fibonacciHeap.insert(8);\n+        fibonacciHeap.insert(1);\n+\n+        int[] counters = fibonacciHeap.countersRep();\n+        Assertions.assertEquals(4, counters[0]);\n+        Assertions.assertEquals(0, counters[1]);\n+    }\n+\n+    @Test\n+    void testDeleteMinMultipleElements() {\n+        FibonacciHeap fibonacciHeap = new FibonacciHeap();\n+        fibonacciHeap.insert(5);\n+        fibonacciHeap.insert(2);\n+        fibonacciHeap.insert(8);\n+        fibonacciHeap.insert(1);\n+\n+        Assertions.assertEquals(1, fibonacciHeap.findMin().getKey());\n+        fibonacciHeap.deleteMin();\n+        Assertions.assertEquals(2, fibonacciHeap.findMin().getKey());\n+    }\n+\n+    @Test\n+    void testInsertNegativeKeys() {\n+        FibonacciHeap fibonacciHeap = new FibonacciHeap();\n+        fibonacciHeap.insert(-10);\n+        fibonacciHeap.insert(-5);\n+        fibonacciHeap.insert(-20);\n+\n+        Assertions.assertEquals(-20, fibonacciHeap.findMin().getKey());\n+    }\n+\n+    @Test\n+    void testDeleteOnEmptyHeap() {\n+        FibonacciHeap fibonacciHeap = new FibonacciHeap();\n+        Assertions.assertThrows(NullPointerException.class, () -> { fibonacciHeap.delete(fibonacciHeap.findMin()); });\n+    }\n+\n+    @Test\n+    void testPotentialCalculation() {\n+        FibonacciHeap fibonacciHeap = new FibonacciHeap();\n+        fibonacciHeap.insert(10);\n+        fibonacciHeap.insert(20);\n+\n+        Assertions.assertEquals(2, fibonacciHeap.potential()); // 2 trees, no marked nodes\n+        var node = fibonacciHeap.findMin();\n+        fibonacciHeap.delete(node);\n+        Assertions.assertEquals(1, fibonacciHeap.potential());\n     }\n }",
    "output": {
      "why": "The JavaDoc enhances documentation for the Fibonacci Heap, clarifying its structure and operations. The method name change improves clarity in testing, while the new tests validate edge cases and functionality, ensuring robustness.",
      "commit_message": "Enhance `FibonacciHeap` documentation and testing\n- Added comprehensive JavaDoc comments to the `FibonacciHeap` class to explain its functionality and features.\n- Renamed the test method `testHeap` to `testHeapInsertionAndMinimum` for better clarity.\n- Introduced additional test methods to cover various operations including heap melding, deletion on single-element, and potential calculations, ensuring thorough testing of the heap's behavior."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/conversions/HexaDecimalToBinary.java b/src/main/java/com/thealgorithms/conversions/HexaDecimalToBinary.java\nindex b6228488dc76..07acefc9fb14 100644\n--- a/src/main/java/com/thealgorithms/conversions/HexaDecimalToBinary.java\n+++ b/src/main/java/com/thealgorithms/conversions/HexaDecimalToBinary.java\n@@ -1,43 +1,60 @@\n package com.thealgorithms.conversions;\n \n-// Hex [0-9],[A-F] -> Binary [0,1]\n+/**\n+ * Utility class for converting hexadecimal numbers to binary representation.\n+ * <p>\n+ * A hexadecimal number consists of digits from {@code [0-9]} and {@code [A-F]} (case-insensitive),\n+ * while binary representation uses only {@code [0, 1]}.\n+ * <p>\n+ * This class provides methods to:\n+ * <ul>\n+ *   <li>Convert a hexadecimal string to its binary string equivalent.</li>\n+ *   <li>Ensure the binary output is padded to 8 bits (1 byte).</li>\n+ * </ul>\n+ * <p>\n+ * Example:\n+ * <ul>\n+ *   <li>{@code \"A1\"} → {@code \"10100001\"}</li>\n+ *   <li>{@code \"1\"} → {@code \"00000001\"}</li>\n+ * </ul>\n+ *\n+ * <p>This class assumes that the input hexadecimal string is valid.</p>\n+ */\n public class HexaDecimalToBinary {\n+\n+    /**\n+     * Converts a hexadecimal string to its binary string equivalent.\n+     * The binary output is padded to a minimum of 8 bits (1 byte).\n+     * Steps:\n+     * <ol>\n+     *     <li>Convert the hexadecimal string to an integer.</li>\n+     *     <li>Convert the integer to a binary string.</li>\n+     *     <li>Pad the binary string to ensure it is at least 8 bits long.</li>\n+     *     <li>Return the padded binary string.</li>\n+     * </ol>\n+     *\n+     * @param numHex the hexadecimal string (e.g., \"A1\", \"7F\")\n+     * @throws NumberFormatException if the input string is not a valid hexadecimal number\n+     * @return the binary string representation, padded to 8 bits (e.g., \"10100001\")\n+     */\n     public String convert(String numHex) {\n-        // String a HexaDecimal:\n         int conHex = Integer.parseInt(numHex, 16);\n-        // Hex a Binary:\n         String binary = Integer.toBinaryString(conHex);\n-        // Output:\n         return completeDigits(binary);\n     }\n \n+    /**\n+     * Pads the binary string to ensure it is at least 8 bits long.\n+     * If the binary string is shorter than 8 bits, it adds leading zeros.\n+     *\n+     * @param binNum the binary string to pad\n+     * @return the padded binary string with a minimum length of 8\n+     */\n     public String completeDigits(String binNum) {\n-        final int longBits = 8;\n-        for (int i = binNum.length(); i < longBits; i++) {\n+        final int byteSize = 8;\n+        while (binNum.length() < byteSize) {\n             binNum = \"0\" + binNum;\n         }\n         return binNum;\n     }\n-\n-    public static void main(String[] args) {\n-        // Testing Numbers:\n-        String[] hexNums = {\n-            \"1\",\n-            \"A1\",\n-            \"ef\",\n-            \"BA\",\n-            \"AA\",\n-            \"BB\",\n-            \"19\",\n-            \"01\",\n-            \"02\",\n-            \"03\",\n-            \"04\",\n-        };\n-        HexaDecimalToBinary objConvert = new HexaDecimalToBinary();\n-\n-        for (String num : hexNums) {\n-            System.out.println(num + \" = \" + objConvert.convert(num));\n-        }\n-    }\n }\ndiff --git a/src/test/java/com/thealgorithms/conversions/HexaDecimalToBinaryTest.java b/src/test/java/com/thealgorithms/conversions/HexaDecimalToBinaryTest.java\nindex 72a0a0174a93..1426eab64d2c 100644\n--- a/src/test/java/com/thealgorithms/conversions/HexaDecimalToBinaryTest.java\n+++ b/src/test/java/com/thealgorithms/conversions/HexaDecimalToBinaryTest.java\n@@ -2,14 +2,44 @@\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n \n+/**\n+ * Unit tests for the {@link EndianConverter} class.\n+ */\n public class HexaDecimalToBinaryTest {\n \n-    @Test\n-    public void testHexaDecimalToBinary() {\n-        HexaDecimalToBinary hexaDecimalToBinary = new HexaDecimalToBinary();\n-        assertEquals(\"1111111111111111111111111111111\", hexaDecimalToBinary.convert(\"7fffffff\"));\n-        assertEquals(\"101010111100110111101111\", hexaDecimalToBinary.convert(\"abcdef\"));\n+    /**\n+     * Parameterized test to validate the conversion from little-endian to big-endian.\n+     * Hexadecimal values are passed as strings and converted to integers during the test.\n+     */\n+    @ParameterizedTest\n+    @CsvSource({\n+        \"0x78563412, 0x12345678\", \"0x00000000, 0x00000000\", \"0x00000001, 0x01000000\",\n+        \"0xFFFFFFFF, 0xFFFFFFFF\", // -1 in two's complement\n+        \"0x0000007F, 0x7F000000\" // Positive boundary case\n+    })\n+    public void\n+    testLittleToBigEndian(String inputHex, String expectedHex) {\n+        int input = (int) Long.parseLong(inputHex.substring(2), 16); // Convert hex string to int\n+        int expected = (int) Long.parseLong(expectedHex.substring(2), 16); // Convert hex string to int\n+        assertEquals(expected, EndianConverter.littleToBigEndian(input));\n+    }\n+\n+    /**\n+     * Parameterized test to validate the conversion from big-endian to little-endian.\n+     */\n+    @ParameterizedTest\n+    @CsvSource({\n+        \"0x12345678, 0x78563412\", \"0x00000000, 0x00000000\", \"0x01000000, 0x00000001\",\n+        \"0xFFFFFFFF, 0xFFFFFFFF\", // -1 in two's complement\n+        \"0x7F000000, 0x0000007F\" // Positive boundary case\n+    })\n+    public void\n+    testBigToLittleEndian(String inputHex, String expectedHex) {\n+        int input = (int) Long.parseLong(inputHex.substring(2), 16); // Convert hex string to int\n+        int expected = (int) Long.parseLong(expectedHex.substring(2), 16); // Convert hex string to int\n+        assertEquals(expected, EndianConverter.bigToLittleEndian(input));\n     }\n }",
    "output": {
      "why": "The changes improve code readability and maintainability by enhancing documentation through JavaDoc comments.\n- The removal of the main method streamlines the class for utility purposes.\n- New parameterized tests provide comprehensive coverage for endian conversions, ensuring the functionality is correctly validated.",
      "commit_message": "Enhance documentation and testing for HexaDecimalToBinary class\n- Added comprehensive Javadoc comments to the `HexaDecimalToBinary` class and its methods, explaining their purpose and usage.\n- Updated the `completeDigits` method to utilize a while loop for clarity in binary string padding.\n- Removed the `main` method to focus the class on being a utility.\n- Introduced parameterized tests to thoroughly assess conversions between little-endian and big-endian representations for various hexadecimal inputs, enhancing testing coverage and reliability."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/graphs/DijkstraOptimizedAlgorithm.java b/src/main/java/com/thealgorithms/datastructures/graphs/DijkstraOptimizedAlgorithm.java\nnew file mode 100644\nindex 000000000000..a686b808a970\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/datastructures/graphs/DijkstraOptimizedAlgorithm.java\n@@ -0,0 +1,66 @@\n+package com.thealgorithms.datastructures.graphs;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+/**\n+ * Dijkstra's algorithm for finding the shortest path from a single source vertex to all other vertices in a graph.\n+ */\n+public class DijkstraOptimizedAlgorithm {\n+\n+    private final int vertexCount;\n+\n+    /**\n+     * Constructs a Dijkstra object with the given number of vertices.\n+     *\n+     * @param vertexCount The number of vertices in the graph.\n+     */\n+    public DijkstraOptimizedAlgorithm(int vertexCount) {\n+        this.vertexCount = vertexCount;\n+    }\n+\n+    /**\n+     * Executes Dijkstra's algorithm on the provided graph to find the shortest paths from the source vertex to all other vertices.\n+     *\n+     * The graph is represented as an adjacency matrix where {@code graph[i][j]} represents the weight of the edge from vertex {@code i}\n+     * to vertex {@code j}. A value of 0 indicates no edge exists between the vertices.\n+     *\n+     * @param graph The graph represented as an adjacency matrix.\n+     * @param source The source vertex.\n+     * @return An array where the value at each index {@code i} represents the shortest distance from the source vertex to vertex {@code i}.\n+     * @throws IllegalArgumentException if the source vertex is out of range.\n+     */\n+    public int[] run(int[][] graph, int source) {\n+        if (source < 0 || source >= vertexCount) {\n+            throw new IllegalArgumentException(\"Incorrect source\");\n+        }\n+\n+        int[] distances = new int[vertexCount];\n+        boolean[] processed = new boolean[vertexCount];\n+        Set<Pair<Integer, Integer>> unprocessed = new TreeSet<>();\n+\n+        Arrays.fill(distances, Integer.MAX_VALUE);\n+        Arrays.fill(processed, false);\n+        distances[source] = 0;\n+        unprocessed.add(Pair.of(0, source));\n+\n+        while (!unprocessed.isEmpty()) {\n+            Pair<Integer, Integer> distanceAndU = unprocessed.iterator().next();\n+            unprocessed.remove(distanceAndU);\n+            int u = distanceAndU.getRight();\n+            processed[u] = true;\n+\n+            for (int v = 0; v < vertexCount; v++) {\n+                if (!processed[v] && graph[u][v] != 0 && distances[u] != Integer.MAX_VALUE && distances[u] + graph[u][v] < distances[v]) {\n+                    unprocessed.remove(Pair.of(distances[v], v));\n+                    distances[v] = distances[u] + graph[u][v];\n+                    unprocessed.add(Pair.of(distances[v], v));\n+                }\n+            }\n+        }\n+\n+        return distances;\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/datastructures/graphs/DijkstraOptimizedAlgorithmTest.java b/src/test/java/com/thealgorithms/datastructures/graphs/DijkstraOptimizedAlgorithmTest.java\nnew file mode 100644\nindex 000000000000..bf4e2828e069\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/datastructures/graphs/DijkstraOptimizedAlgorithmTest.java\n@@ -0,0 +1,64 @@\n+package com.thealgorithms.datastructures.graphs;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+public class DijkstraOptimizedAlgorithmTest {\n+\n+    private DijkstraOptimizedAlgorithm dijkstraOptimizedAlgorithm;\n+    private int[][] graph;\n+\n+    @BeforeEach\n+    void setUp() {\n+        graph = new int[][] {\n+            {0, 4, 0, 0, 0, 0, 0, 8, 0},\n+            {4, 0, 8, 0, 0, 0, 0, 11, 0},\n+            {0, 8, 0, 7, 0, 4, 0, 0, 2},\n+            {0, 0, 7, 0, 9, 14, 0, 0, 0},\n+            {0, 0, 0, 9, 0, 10, 0, 0, 0},\n+            {0, 0, 4, 14, 10, 0, 2, 0, 0},\n+            {0, 0, 0, 0, 0, 2, 0, 1, 6},\n+            {8, 11, 0, 0, 0, 0, 1, 0, 7},\n+            {0, 0, 2, 0, 0, 0, 6, 7, 0},\n+        };\n+\n+        dijkstraOptimizedAlgorithm = new DijkstraOptimizedAlgorithm(graph.length);\n+    }\n+\n+    @Test\n+    void testRunAlgorithm() {\n+        int[] expectedDistances = {0, 4, 12, 19, 21, 11, 9, 8, 14};\n+        assertArrayEquals(expectedDistances, dijkstraOptimizedAlgorithm.run(graph, 0));\n+    }\n+\n+    @Test\n+    void testGraphWithDisconnectedNodes() {\n+        int[][] disconnectedGraph = {\n+            {0, 3, 0, 0}, {3, 0, 1, 0}, {0, 1, 0, 0}, {0, 0, 0, 0} // Node 3 is disconnected\n+        };\n+\n+        DijkstraOptimizedAlgorithm dijkstraDisconnected = new DijkstraOptimizedAlgorithm(disconnectedGraph.length);\n+\n+        // Testing from vertex 0\n+        int[] expectedDistances = {0, 3, 4, Integer.MAX_VALUE}; // Node 3 is unreachable\n+        assertArrayEquals(expectedDistances, dijkstraDisconnected.run(disconnectedGraph, 0));\n+    }\n+\n+    @Test\n+    void testSingleVertexGraph() {\n+        int[][] singleVertexGraph = {{0}};\n+        DijkstraOptimizedAlgorithm dijkstraSingleVertex = new DijkstraOptimizedAlgorithm(1);\n+\n+        int[] expectedDistances = {0}; // The only vertex's distance to itself is 0\n+        assertArrayEquals(expectedDistances, dijkstraSingleVertex.run(singleVertexGraph, 0));\n+    }\n+\n+    @Test\n+    void testInvalidSourceVertex() {\n+        assertThrows(IllegalArgumentException.class, () -> dijkstraOptimizedAlgorithm.run(graph, -1));\n+        assertThrows(IllegalArgumentException.class, () -> dijkstraOptimizedAlgorithm.run(graph, graph.length));\n+    }\n+}",
    "output": {
      "why": "The implementation introduces a new Dijkstra algorithm class to efficiently find the shortest paths in graphs. The corresponding test class validates the algorithm's functionality, ensuring it handles various scenarios including disconnected nodes and invalid inputs.",
      "commit_message": "Add DijkstraOptimizedAlgorithm implementation and tests\n- Introduced `DijkstraOptimizedAlgorithm` class for computing shortest paths using Dijkstra's algorithm.\n- Created unit tests in `DijkstraOptimizedAlgorithmTest` to validate:\n- Correctness of shortest path computations.\n- Handling of disconnected nodes.\n- Management of a single vertex graph.\n- Exceptions for invalid source vertex inputs."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/audiofilters/EMAFilter.java b/src/main/java/com/thealgorithms/audiofilters/EMAFilter.java\nnew file mode 100644\nindex 000000000000..0dd23e937953\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/audiofilters/EMAFilter.java\n@@ -0,0 +1,48 @@\n+package com.thealgorithms.audiofilters;\n+\n+/**\n+ * Exponential Moving Average (EMA) Filter for smoothing audio signals.\n+ *\n+ * <p>This filter applies an exponential moving average to a sequence of audio\n+ * signal values, making it useful for smoothing out rapid fluctuations.\n+ * The smoothing factor (alpha) controls the degree of smoothing.\n+ *\n+ * <p>Based on the definition from\n+ * <a href=\"https://en.wikipedia.org/wiki/Moving_average\">Wikipedia link</a>.\n+ */\n+public class EMAFilter {\n+    private final double alpha;\n+    private double emaValue;\n+    /**\n+     * Constructs an EMA filter with a given smoothing factor.\n+     *\n+     * @param alpha Smoothing factor (0 < alpha <= 1)\n+     * @throws IllegalArgumentException if alpha is not in (0, 1]\n+     */\n+    public EMAFilter(double alpha) {\n+        if (alpha <= 0 || alpha > 1) {\n+            throw new IllegalArgumentException(\"Alpha must be between 0 and 1.\");\n+        }\n+        this.alpha = alpha;\n+        this.emaValue = 0.0;\n+    }\n+    /**\n+     * Applies the EMA filter to an audio signal array.\n+     *\n+     * @param audioSignal Array of audio samples to process\n+     * @return Array of processed (smoothed) samples\n+     */\n+    public double[] apply(double[] audioSignal) {\n+        if (audioSignal.length == 0) {\n+            return new double[0];\n+        }\n+        double[] emaSignal = new double[audioSignal.length];\n+        emaValue = audioSignal[0];\n+        emaSignal[0] = emaValue;\n+        for (int i = 1; i < audioSignal.length; i++) {\n+            emaValue = alpha * audioSignal[i] + (1 - alpha) * emaValue;\n+            emaSignal[i] = emaValue;\n+        }\n+        return emaSignal;\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/audiofilters/EMAFilterTest.java b/src/test/java/com/thealgorithms/audiofilters/EMAFilterTest.java\nnew file mode 100644\nindex 000000000000..f2338d3d8296\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/audiofilters/EMAFilterTest.java\n@@ -0,0 +1,41 @@\n+package com.thealgorithms.audiofilters;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class EMAFilterTest {\n+\n+    @Test\n+    public void testApplyBasicSignal() {\n+        EMAFilter emaFilter = new EMAFilter(0.2);\n+        double[] audioSignal = {0.1, 0.5, 0.8, 0.6, 0.3, 0.9, 0.4};\n+        double[] expectedOutput = {0.1, 0.18, 0.304, 0.3632, 0.35056, 0.460448, 0.4483584};\n+        double[] result = emaFilter.apply(audioSignal);\n+        assertArrayEquals(expectedOutput, result, 1e-5);\n+    }\n+\n+    @Test\n+    public void testApplyEmptySignal() {\n+        EMAFilter emaFilter = new EMAFilter(0.2);\n+        double[] audioSignal = {};\n+        double[] expectedOutput = {};\n+        double[] result = emaFilter.apply(audioSignal);\n+        assertArrayEquals(expectedOutput, result);\n+    }\n+\n+    @Test\n+    public void testAlphaBounds() {\n+        EMAFilter emaFilterMin = new EMAFilter(0.01);\n+        EMAFilter emaFilterMax = new EMAFilter(1.0);\n+        double[] audioSignal = {1.0, 1.0, 1.0, 1.0};\n+\n+        // Minimal smoothing (alpha close to 0)\n+        double[] resultMin = emaFilterMin.apply(audioSignal);\n+        assertArrayEquals(audioSignal, resultMin, 1e-5);\n+\n+        // Maximum smoothing (alpha = 1, output should match input)\n+        double[] resultMax = emaFilterMax.apply(audioSignal);\n+        assertArrayEquals(audioSignal, resultMax, 1e-5);\n+    }\n+}",
    "output": {
      "why": "The implementation of the EMAFilter class provides a method for smoothing audio signals using an exponential moving average, which can help improve audio processing performance. The accompanying tests ensure that the filter behaves correctly with different inputs and validates edge cases like empty signals and alpha values.",
      "commit_message": "Add `EMAFilter` class for audio signal smoothing\n- Introduced a new `EMAFilter` class that applies an exponential moving average to audio signals, allowing for smoother audio playback.\n- Added input validation for the smoothing factor (alpha) to ensure it's in the range (0, 1].\n- Created an `EMAFilterTest` class with unit tests for key functionalities:\n- Basic application of the filter to a sample audio signal.\n- Handling of empty audio signal input.\n- Validation of the alpha bounds for minimum and maximum smoothing."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/scheduling/SJFScheduling.java b/src/main/java/com/thealgorithms/scheduling/SJFScheduling.java\nindex 6d105003e68f..cbbc65a3afc5 100644\n--- a/src/main/java/com/thealgorithms/scheduling/SJFScheduling.java\n+++ b/src/main/java/com/thealgorithms/scheduling/SJFScheduling.java\n@@ -14,6 +14,18 @@ public class SJFScheduling {\n     protected ArrayList<ProcessDetails> processes;\n     protected ArrayList<String> schedule;\n \n+    private static void sortProcessesByArrivalTime(List<ProcessDetails> processes) {\n+        for (int i = 0; i < processes.size(); i++) {\n+            for (int j = i + 1; j < processes.size() - 1; j++) {\n+                if (processes.get(j).getArrivalTime() > processes.get(j + 1).getArrivalTime()) {\n+                    final var temp = processes.get(j);\n+                    processes.set(j, processes.get(j + 1));\n+                    processes.set(j + 1, temp);\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * a simple constructor\n      * @param processes a list of processes the user wants to schedule\n@@ -22,22 +34,10 @@ public class SJFScheduling {\n     SJFScheduling(final ArrayList<ProcessDetails> processes) {\n         this.processes = processes;\n         schedule = new ArrayList<>();\n-        sortByArrivalTime();\n+        sortProcessesByArrivalTime(this.processes);\n     }\n     protected void sortByArrivalTime() {\n-        int size = processes.size();\n-        int i;\n-        int j;\n-        ProcessDetails temp;\n-        for (i = 0; i < size; i++) {\n-            for (j = i + 1; j < size - 1; j++) {\n-                if (processes.get(j).getArrivalTime() > processes.get(j + 1).getArrivalTime()) {\n-                    temp = processes.get(j);\n-                    processes.set(j, processes.get(j + 1));\n-                    processes.set(j + 1, temp);\n-                }\n-            }\n-        }\n+        sortProcessesByArrivalTime(processes);\n     }\n \n     /**",
    "output": {
      "why": "The exclusion for PCOA was likely considered unnecessary, as it may have been identified as a non-issue. The new `sortProcessesByArrivalTime` method improves code readability and reusability by encapsulating the sorting logic, and replacing the existing sorting implementation in both the constructor and existing methods streamlines these processes.",
      "commit_message": "Refactor process sorting in SJFScheduling\n- Removed the exclusion of the bug pattern `PCOA_PARTIALLY_CONSTRUCTED_OBJECT_ACCESS` from `spotbugs-exclude.xml`.\n- Introduced a new method `sortProcessesByArrivalTime` for sorting processes based on their arrival time.\n- Updated the constructor and `sortByArrivalTime` method to utilize the new sorting method, enhancing code readability and maintainability."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/Recursion/FibonacciSeries.java b/src/main/java/com/thealgorithms/Recursion/FibonacciSeries.java\nnew file mode 100644\nindex 000000000000..a89d110b8da3\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/Recursion/FibonacciSeries.java\n@@ -0,0 +1,21 @@\n+package com.thealgorithms.Recursion;\n+\n+/*\n+    The Fibonacci series is a sequence of numbers where each number is the sum of the two preceding ones,\n+    starting with 0 and 1.\n+       NUMBER    0 1 2 3 4 5 6 7  8  9  10 ...\n+       FIBONACCI 0 1 1 2 3 5 8 13 21 34 55 ...\n+*/\n+\n+public final class FibonacciSeries {\n+    private FibonacciSeries() {\n+        throw new UnsupportedOperationException(\"Utility class\");\n+    }\n+    public static int fibonacci(int n) {\n+        if (n <= 1) {\n+            return n;\n+        } else {\n+            return fibonacci(n - 1) + fibonacci(n - 2);\n+        }\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/Recursion/FibonacciSeriesTest.java b/src/test/java/com/thealgorithms/Recursion/FibonacciSeriesTest.java\nnew file mode 100644\nindex 000000000000..4e4fc45809ba\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/Recursion/FibonacciSeriesTest.java\n@@ -0,0 +1,27 @@\n+package com.thealgorithms.Recursion;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class FibonacciSeriesTest {\n+\n+    @Test\n+    public void testFibonacci() {\n+        assertEquals(0, FibonacciSeries.fibonacci(0));\n+        assertEquals(1, FibonacciSeries.fibonacci(1));\n+        assertEquals(1, FibonacciSeries.fibonacci(2));\n+        assertEquals(2, FibonacciSeries.fibonacci(3));\n+        assertEquals(3, FibonacciSeries.fibonacci(4));\n+        assertEquals(5, FibonacciSeries.fibonacci(5));\n+        assertEquals(8, FibonacciSeries.fibonacci(6));\n+        assertEquals(13, FibonacciSeries.fibonacci(7));\n+        assertEquals(21, FibonacciSeries.fibonacci(8));\n+        assertEquals(34, FibonacciSeries.fibonacci(9));\n+        assertEquals(55, FibonacciSeries.fibonacci(10));\n+        assertEquals(89, FibonacciSeries.fibonacci(11));\n+        assertEquals(144, FibonacciSeries.fibonacci(12));\n+        assertEquals(233, FibonacciSeries.fibonacci(13));\n+        assertEquals(377, FibonacciSeries.fibonacci(14));\n+    }\n+}",
    "output": {
      "why": "The changes introduce a new utility class for calculating Fibonacci numbers recursively and a corresponding test class to ensure the implementation produces the correct results for various inputs.",
      "commit_message": "Add Fibonacci series utility class and tests\n- Created `FibonacciSeries` class to compute Fibonacci numbers recursively.\n- Added a private constructor to restrict instantiation of the utility class.\n- Implemented unit tests in `FibonacciSeriesTest` to validate the Fibonacci calculations for multiple input cases."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/graphs/WelshPowell.java b/src/main/java/com/thealgorithms/datastructures/graphs/WelshPowell.java\nindex 0981638d4903..26ca97736fe9 100644\n--- a/src/main/java/com/thealgorithms/datastructures/graphs/WelshPowell.java\n+++ b/src/main/java/com/thealgorithms/datastructures/graphs/WelshPowell.java\n@@ -5,21 +5,41 @@\n import java.util.HashSet;\n import java.util.stream.IntStream;\n \n-/*\n- *  The Welsh-Powell algorithm is a graph coloring algorithm\n- *  used for coloring a graph with the minimum number of colors.\n- *  https://en.wikipedia.org/wiki/Graph_coloring\n+/**\n+ * The Welsh-Powell algorithm is a graph coloring algorithm that aims to color a graph\n+ * using the minimum number of colors such that no two adjacent vertices share the same color.\n+ *\n+ * <p>\n+ * The algorithm works by:\n+ * <ol>\n+ * <li>Sorting the vertices in descending order based on their degrees (number of edges connected).</li>\n+ * <li>Iterating through each vertex and assigning it the smallest available color that has not been used by its adjacent vertices.</li>\n+ * <li>Coloring adjacent vertices with the same color is avoided.</li>\n+ * </ol>\n+ * </p>\n+ *\n+ * <p>\n+ * For more information, see <a href=\"https://en.wikipedia.org/wiki/Graph_coloring\">Graph Coloring</a>.\n+ * </p>\n  */\n-\n public final class WelshPowell {\n-    private static final int BLANK_COLOR = -1; // Representing uncolored state\n+    private static final int BLANK_COLOR = -1; // Constant representing an uncolored state\n \n     private WelshPowell() {\n     }\n \n+    /**\n+     * Represents a graph using an adjacency list.\n+     */\n     static final class Graph {\n-        private HashSet<Integer>[] adjacencyLists;\n-\n+        private final HashSet<Integer>[] adjacencyLists;\n+\n+        /**\n+         * Initializes a graph with a specified number of vertices.\n+         *\n+         * @param vertices the number of vertices in the graph\n+         * @throws IllegalArgumentException if the number of vertices is negative\n+         */\n         private Graph(int vertices) {\n             if (vertices < 0) {\n                 throw new IllegalArgumentException(\"Number of vertices cannot be negative\");\n@@ -29,6 +49,13 @@ private Graph(int vertices) {\n             Arrays.setAll(adjacencyLists, i -> new HashSet<>());\n         }\n \n+        /**\n+         * Adds an edge between two vertices in the graph.\n+         *\n+         * @param nodeA one end of the edge\n+         * @param nodeB the other end of the edge\n+         * @throws IllegalArgumentException if the vertices are out of bounds or if a self-loop is attempted\n+         */\n         private void addEdge(int nodeA, int nodeB) {\n             validateVertex(nodeA);\n             validateVertex(nodeB);\n@@ -39,21 +66,46 @@ private void addEdge(int nodeA, int nodeB) {\n             adjacencyLists[nodeB].add(nodeA);\n         }\n \n+        /**\n+         * Validates that the vertex index is within the bounds of the graph.\n+         *\n+         * @param vertex the index of the vertex to validate\n+         * @throws IllegalArgumentException if the vertex is out of bounds\n+         */\n         private void validateVertex(int vertex) {\n             if (vertex < 0 || vertex >= getNumVertices()) {\n                 throw new IllegalArgumentException(\"Vertex \" + vertex + \" is out of bounds\");\n             }\n         }\n \n+        /**\n+         * Returns the adjacency list for a specific vertex.\n+         *\n+         * @param vertex the index of the vertex\n+         * @return the set of adjacent vertices\n+         */\n         HashSet<Integer> getAdjacencyList(int vertex) {\n             return adjacencyLists[vertex];\n         }\n \n+        /**\n+         * Returns the number of vertices in the graph.\n+         *\n+         * @return the number of vertices\n+         */\n         int getNumVertices() {\n             return adjacencyLists.length;\n         }\n     }\n \n+    /**\n+     * Creates a graph with the specified number of vertices and edges.\n+     *\n+     * @param numberOfVertices the total number of vertices\n+     * @param listOfEdges a 2D array representing edges where each inner array contains two vertex indices\n+     * @return a Graph object representing the created graph\n+     * @throws IllegalArgumentException if the edge array is invalid or vertices are out of bounds\n+     */\n     public static Graph makeGraph(int numberOfVertices, int[][] listOfEdges) {\n         Graph graph = new Graph(numberOfVertices);\n         for (int[] edge : listOfEdges) {\n@@ -65,6 +117,12 @@ public static Graph makeGraph(int numberOfVertices, int[][] listOfEdges) {\n         return graph;\n     }\n \n+    /**\n+     * Finds the coloring of the given graph using the Welsh-Powell algorithm.\n+     *\n+     * @param graph the input graph to color\n+     * @return an array of integers where each index represents a vertex and the value represents the color assigned\n+     */\n     public static int[] findColoring(Graph graph) {\n         int[] colors = initializeColors(graph.getNumVertices());\n         Integer[] sortedVertices = getSortedNodes(graph);\n@@ -83,30 +141,70 @@ public static int[] findColoring(Graph graph) {\n         return colors;\n     }\n \n+    /**\n+     * Helper method to check if a color is unassigned\n+     *\n+     * @param color the color to check\n+     * @return {@code true} if the color is unassigned, {@code false} otherwise\n+     */\n     private static boolean isBlank(int color) {\n         return color == BLANK_COLOR;\n     }\n \n+    /**\n+     * Checks if a vertex has adjacent colored vertices\n+     *\n+     * @param graph the input graph\n+     * @param vertex the vertex to check\n+     * @param colors the array of colors assigned to the vertices\n+     * @return {@code true} if the vertex has adjacent colored vertices, {@code false} otherwise\n+     */\n     private static boolean isAdjacentToColored(Graph graph, int vertex, int[] colors) {\n         return graph.getAdjacencyList(vertex).stream().anyMatch(otherVertex -> !isBlank(colors[otherVertex]));\n     }\n \n+    /**\n+     * Initializes the colors array with blank color\n+     *\n+     * @param numberOfVertices the number of vertices in the graph\n+     * @return an array of integers representing the colors assigned to the vertices\n+     */\n     private static int[] initializeColors(int numberOfVertices) {\n         int[] colors = new int[numberOfVertices];\n         Arrays.fill(colors, BLANK_COLOR);\n         return colors;\n     }\n \n+    /**\n+     * Sorts the vertices by their degree in descending order\n+     *\n+     * @param graph the input graph\n+     * @return an array of integers representing the vertices sorted by degree\n+     */\n     private static Integer[] getSortedNodes(final Graph graph) {\n         return IntStream.range(0, graph.getNumVertices()).boxed().sorted(Comparator.comparingInt(v -> - graph.getAdjacencyList(v).size())).toArray(Integer[] ::new);\n     }\n \n+    /**\n+     * Computes the colors already used by the adjacent vertices\n+     *\n+     * @param graph the input graph\n+     * @param vertex the vertex to check\n+     * @param colors the array of colors assigned to the vertices\n+     * @return an array of booleans representing the colors used by the adjacent vertices\n+     */\n     private static boolean[] computeUsedColors(final Graph graph, final int vertex, final int[] colors) {\n         boolean[] usedColors = new boolean[graph.getNumVertices()];\n         graph.getAdjacencyList(vertex).stream().map(neighbor -> colors[neighbor]).filter(color -> !isBlank(color)).forEach(color -> usedColors[color] = true);\n         return usedColors;\n     }\n \n+    /**\n+     * Finds the first unused color\n+     *\n+     * @param usedColors the array of colors used by the adjacent vertices\n+     * @return the first unused color\n+     */\n     private static int firstUnusedColor(boolean[] usedColors) {\n         return IntStream.range(0, usedColors.length).filter(color -> !usedColors[color]).findFirst().getAsInt();\n     }\ndiff --git a/src/test/java/com/thealgorithms/datastructures/graphs/WelshPowellTest.java b/src/test/java/com/thealgorithms/datastructures/graphs/WelshPowellTest.java\nindex b37657db5c05..f45c4e10be56 100644\n--- a/src/test/java/com/thealgorithms/datastructures/graphs/WelshPowellTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/graphs/WelshPowellTest.java\n@@ -34,26 +34,25 @@ void testCompleteGraph() {\n         assertEquals(3, countDistinctColors(colors));\n     }\n \n-    // The following test originates from the following website : https://www.geeksforgeeks.org/welsh-powell-graph-colouring-algorithm/\n     @Test\n     void testComplexGraph() {\n         int[][] edges = {\n-            {0, 7}, // A-H\n-            {0, 1}, // A-B\n-            {1, 3}, // B-D\n-            {2, 3}, // C-D\n-            {3, 8}, // D-I\n-            {3, 10}, // D-K\n-            {4, 10}, // E-K\n-            {4, 5}, // E-F\n-            {5, 6}, // F-G\n-            {6, 10}, // G-K\n-            {6, 7}, // G-H\n-            {7, 8}, // H-I\n-            {7, 9}, // H-J\n-            {7, 10}, // H-K\n-            {8, 9}, // I-J\n-            {9, 10}, // J-K\n+            {0, 7},\n+            {0, 1},\n+            {1, 3},\n+            {2, 3},\n+            {3, 8},\n+            {3, 10},\n+            {4, 10},\n+            {4, 5},\n+            {5, 6},\n+            {6, 10},\n+            {6, 7},\n+            {7, 8},\n+            {7, 9},\n+            {7, 10},\n+            {8, 9},\n+            {9, 10},\n         };\n \n         final var graph = WelshPowell.makeGraph(11, edges); // 11 vertices from A (0) to K (10)\n@@ -86,24 +85,35 @@ void testInvalidEdgeArray() {\n \n     @Test\n     void testWithPreColoredVertex() {\n-        // Create a linear graph with 4 vertices and edges connecting them in sequence\n         final var graph = WelshPowell.makeGraph(4, new int[][] {{0, 1}, {1, 2}, {2, 3}});\n-\n-        // Apply the Welsh-Powell coloring algorithm to the graph\n         int[] colors = WelshPowell.findColoring(graph);\n-\n-        // Validate that the coloring is correct (no two adjacent vertices have the same color)\n         assertTrue(isColoringValid(graph, colors));\n-\n-        // Check if the algorithm has used at least 2 colors (expected for a linear graph)\n         assertTrue(countDistinctColors(colors) >= 2);\n-\n-        // Verify that all vertices have been assigned a color\n         for (int color : colors) {\n             assertTrue(color >= 0);\n         }\n     }\n \n+    @Test\n+    void testLargeGraph() {\n+        int[][] edges = {{0, 1}, {1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 0}, {6, 7}, {7, 8}, {8, 6}, {9, 10}, {10, 11}, {11, 9}, {12, 13}, {13, 14}, {14, 15}};\n+\n+        final var graph = WelshPowell.makeGraph(16, edges); // 16 vertices\n+        int[] colors = WelshPowell.findColoring(graph);\n+        assertTrue(isColoringValid(graph, colors));\n+        assertEquals(3, countDistinctColors(colors)); // Expecting a maximum of 3 colors\n+    }\n+\n+    @Test\n+    void testStarGraph() {\n+        int[][] edges = {{0, 1}, {0, 2}, {0, 3}, {0, 4}};\n+\n+        final var graph = WelshPowell.makeGraph(5, edges); // 5 vertices in a star formation\n+        int[] colors = WelshPowell.findColoring(graph);\n+        assertTrue(isColoringValid(graph, colors));\n+        assertEquals(2, countDistinctColors(colors)); // Star graph can be colored with 2 colors\n+    }\n+\n     private boolean isColoringValid(Graph graph, int[] colors) {\n         if (Arrays.stream(colors).anyMatch(n -> n < 0)) {\n             return false;",
    "output": {
      "why": "The changes enhance code documentation and readability. By updating the JavaDoc comments, each method's functionality and parameters are clearer. The added tests increase coverage, ensuring the algorithm is robust against various graph structures.",
      "commit_message": "Improve documentation and add tests for WelshPowell algorithm\n- Enhanced JavaDoc comments for the WelshPowell algorithm and its methods to provide clearer explanations of functionality and parameter usage.\n- Reformatted comments for consistency in styling across the class.\n- Added new test cases for handling larger graphs and specific structures like star graphs to improve test coverage and validate correctness."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/strings/zigZagPattern/ZigZagPattern.java b/src/main/java/com/thealgorithms/strings/zigZagPattern/ZigZagPattern.java\nindex 3f33fc17b9b0..ad7835bdbb97 100644\n--- a/src/main/java/com/thealgorithms/strings/zigZagPattern/ZigZagPattern.java\n+++ b/src/main/java/com/thealgorithms/strings/zigZagPattern/ZigZagPattern.java\n@@ -1,41 +1,38 @@\n package com.thealgorithms.strings.zigZagPattern;\n \n final class ZigZagPattern {\n+\n     private ZigZagPattern() {\n     }\n \n+    /**\n+     * Encodes a given string into a zig-zag pattern.\n+     *\n+     * @param s       the input string to be encoded\n+     * @param numRows the number of rows in the zigzag pattern\n+     * @return the encoded string in zigzag pattern format\n+     */\n     public static String encode(String s, int numRows) {\n         if (numRows < 2 || s.length() < numRows) {\n             return s;\n         }\n-        int start = 0;\n-        int index = 0;\n-        int height = 1;\n-        int depth = numRows;\n-        char[] zigZagedArray = new char[s.length()];\n-        while (depth != 0) {\n-            int pointer = start;\n-            int heightSpace = 2 + ((height - 2) * 2);\n-            int depthSpace = 2 + ((depth - 2) * 2);\n-            boolean bool = true;\n-            while (pointer < s.length()) {\n-                zigZagedArray[index++] = s.charAt(pointer);\n-                if (heightSpace == 0) {\n-                    pointer += depthSpace;\n-                } else if (depthSpace == 0) {\n-                    pointer += heightSpace;\n-                } else if (bool) {\n-                    pointer += depthSpace;\n-                    bool = false;\n-                } else {\n-                    pointer += heightSpace;\n-                    bool = true;\n+\n+        StringBuilder result = new StringBuilder(s.length());\n+        int cycleLength = 2 * numRows - 2;\n+\n+        for (int row = 0; row < numRows; row++) {\n+            for (int j = row; j < s.length(); j += cycleLength) {\n+                result.append(s.charAt(j));\n+\n+                if (row > 0 && row < numRows - 1) {\n+                    int diagonal = j + cycleLength - 2 * row;\n+                    if (diagonal < s.length()) {\n+                        result.append(s.charAt(diagonal));\n+                    }\n                 }\n             }\n-            height++;\n-            depth--;\n-            start++;\n         }\n-        return new String(zigZagedArray);\n+\n+        return result.toString();\n     }\n }\ndiff --git a/src/test/java/com/thealgorithms/strings/zigZagPattern/ZigZagPatternTest.java b/src/test/java/com/thealgorithms/strings/zigZagPattern/ZigZagPatternTest.java\nindex 518bfab80f08..2cbbfe3d2dd8 100644\n--- a/src/test/java/com/thealgorithms/strings/zigZagPattern/ZigZagPatternTest.java\n+++ b/src/test/java/com/thealgorithms/strings/zigZagPattern/ZigZagPatternTest.java\n@@ -6,10 +6,14 @@\n public class ZigZagPatternTest {\n \n     @Test\n-    public void palindrome() {\n+    public void testZigZagPattern() {\n         String input1 = \"HelloWorldFromJava\";\n         String input2 = \"javaIsAProgrammingLanguage\";\n         Assertions.assertEquals(ZigZagPattern.encode(input1, 4), \"HooeWrrmalolFJvlda\");\n         Assertions.assertEquals(ZigZagPattern.encode(input2, 4), \"jAaLgasPrmgaaevIrgmnnuaoig\");\n+        // Edge cases\n+        Assertions.assertEquals(\"ABC\", ZigZagPattern.encode(\"ABC\", 1)); // Single row\n+        Assertions.assertEquals(\"A\", ZigZagPattern.encode(\"A\", 2)); // numRows > length of string\n+        Assertions.assertEquals(\"\", ZigZagPattern.encode(\"\", 3)); // Empty string\n     }\n }",
    "output": {
      "why": "The changes improve both the readability and efficiency of the `encode` method by using `StringBuilder` and simplifying the logic. The addition of JavaDoc enhances documentation, making it easier for users to understand how to use the function. The test method was renamed to better reflect its purpose and additional edge cases were included to ensure robustness.",
      "commit_message": "Refactor `encode` method for the ZigZagPattern class\n- Simplified the logic of the `encode` method by using a `StringBuilder` for better performance and readability.\n- Added a Javadoc comment to describe the method’s functionality and parameters.\n- Renamed the test method to `testZigZagPattern` for clarity and updated it with edge case tests to cover various scenarios including single row and empty string inputs."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/heaps/LeftistHeap.java b/src/main/java/com/thealgorithms/datastructures/heaps/LeftistHeap.java\nindex ca18673c6724..1c91d24f0fb5 100644\n--- a/src/main/java/com/thealgorithms/datastructures/heaps/LeftistHeap.java\n+++ b/src/main/java/com/thealgorithms/datastructures/heaps/LeftistHeap.java\n@@ -2,24 +2,33 @@\n \n import java.util.ArrayList;\n \n-/*\n- * This is a leftist heap that follows the same operations as a\n- * binary min heap, but may be unbalanced at times and follows a\n- * leftist property, in which the left side is more heavy on the\n- * right based on the null-path length (npl) values.\n+/**\n+ * This class implements a Leftist Heap, which is a type of priority queue\n+ * that follows similar operations to a binary min-heap but allows for\n+ * unbalanced structures based on the leftist property.\n  *\n- * Source: https://iq.opengenus.org/leftist-heap/\n+ * <p>\n+ * A Leftist Heap maintains the leftist property, which ensures that the\n+ * left subtree is heavier than the right subtree based on the\n+ * null-path length (npl) values. This allows for efficient merging\n+ * of heaps and supports operations like insertion, extraction of\n+ * the minimum element, and in-order traversal.\n+ * </p>\n  *\n+ * <p>\n+ * For more information on Leftist Heaps, visit:\n+ * <a href=\"https://iq.opengenus.org/leftist-heap/\">OpenGenus</a>\n+ * </p>\n  */\n-\n public class LeftistHeap {\n+    // Node class representing each element in the Leftist Heap\n     private static final class Node {\n         private final int element;\n         private int npl;\n         private Node left;\n         private Node right;\n \n-        // Node constructor setting the data element and left/right pointers to null\n+        // Node constructor that initializes the element and sets child pointers to null\n         private Node(int element) {\n             this.element = element;\n             left = null;\n@@ -30,31 +39,45 @@ private Node(int element) {\n \n     private Node root;\n \n-    // Constructor\n+    // Constructor initializing an empty Leftist Heap\n     public LeftistHeap() {\n         root = null;\n     }\n \n-    // Checks if heap is empty\n+    /**\n+     * Checks if the heap is empty.\n+     *\n+     * @return true if the heap is empty; false otherwise\n+     */\n     public boolean isEmpty() {\n         return root == null;\n     }\n \n-    // Resets structure to initial state\n+    /**\n+     * Resets the heap to its initial state, effectively clearing all elements.\n+     */\n     public void clear() {\n-        // We will put head is null\n-        root = null;\n+        root = null; // Set root to null to clear the heap\n     }\n \n-    // Merge function that merges the contents of another leftist heap with the\n-    // current one\n+    /**\n+     * Merges the contents of another Leftist Heap into this one.\n+     *\n+     * @param h1 the LeftistHeap to be merged into this heap\n+     */\n     public void merge(LeftistHeap h1) {\n-        // If the present function is rhs then we ignore the merge\n+        // Merge the current heap with the provided heap and set the provided heap's root to null\n         root = merge(root, h1.root);\n         h1.root = null;\n     }\n \n-    // Function merge with two Nodes a and b\n+    /**\n+     * Merges two nodes, maintaining the leftist property.\n+     *\n+     * @param a the first node\n+     * @param b the second node\n+     * @return the merged node maintaining the leftist property\n+     */\n     public Node merge(Node a, Node b) {\n         if (a == null) {\n             return b;\n@@ -64,17 +87,17 @@ public Node merge(Node a, Node b) {\n             return a;\n         }\n \n-        // Violates leftist property, so must do a swap\n+        // Ensure that the leftist property is maintained\n         if (a.element > b.element) {\n             Node temp = a;\n             a = b;\n             b = temp;\n         }\n \n-        // Now we call the function merge to merge a and b\n+        // Merge the right child of node a with node b\n         a.right = merge(a.right, b);\n \n-        // Violates leftist property so must swap here\n+        // If left child is null, make right child the left child\n         if (a.left == null) {\n             a.left = a.right;\n             a.right = null;\n@@ -89,14 +112,21 @@ public Node merge(Node a, Node b) {\n         return a;\n     }\n \n-    // Function insert. Uses the merge function to add the data\n+    /**\n+     * Inserts a new element into the Leftist Heap.\n+     *\n+     * @param a the element to be inserted\n+     */\n     public void insert(int a) {\n         root = merge(new Node(a), root);\n     }\n \n-    // Returns and removes the minimum element in the heap\n+    /**\n+     * Extracts and removes the minimum element from the heap.\n+     *\n+     * @return the minimum element in the heap, or -1 if the heap is empty\n+     */\n     public int extractMin() {\n-        // If is empty return -1\n         if (isEmpty()) {\n             return -1;\n         }\n@@ -106,14 +136,23 @@ public int extractMin() {\n         return min;\n     }\n \n-    // Function returning a list of an in order traversal of the data structure\n+    /**\n+     * Returns a list of the elements in the heap in in-order traversal.\n+     *\n+     * @return an ArrayList containing the elements in in-order\n+     */\n     public ArrayList<Integer> inOrder() {\n         ArrayList<Integer> lst = new ArrayList<>();\n         inOrderAux(root, lst);\n         return new ArrayList<>(lst);\n     }\n \n-    // Auxiliary function for in_order\n+    /**\n+     * Auxiliary function for in-order traversal\n+     *\n+     * @param n the current node\n+     * @param lst the list to store the elements in in-order\n+     */\n     private void inOrderAux(Node n, ArrayList<Integer> lst) {\n         if (n == null) {\n             return;\ndiff --git a/src/test/java/com/thealgorithms/datastructures/heaps/LeftistHeapTest.java b/src/test/java/com/thealgorithms/datastructures/heaps/LeftistHeapTest.java\nindex f4c4c548ffbf..8c313237f88f 100644\n--- a/src/test/java/com/thealgorithms/datastructures/heaps/LeftistHeapTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/heaps/LeftistHeapTest.java\n@@ -6,23 +6,80 @@\n public class LeftistHeapTest {\n \n     @Test\n-    void testLeftistHeap() {\n+    void testIsEmpty() {\n+        LeftistHeap heap = new LeftistHeap();\n+        Assertions.assertTrue(heap.isEmpty(), \"Heap should be empty initially.\");\n+\n+        heap.insert(10);\n+        Assertions.assertFalse(heap.isEmpty(), \"Heap should not be empty after insertion.\");\n+\n+        heap.clear();\n+        Assertions.assertTrue(heap.isEmpty(), \"Heap should be empty after clearing.\");\n+    }\n+\n+    @Test\n+    void testInsertAndExtractMin() {\n         LeftistHeap heap = new LeftistHeap();\n-        Assertions.assertTrue(heap.isEmpty());\n         heap.insert(6);\n-        Assertions.assertTrue(!heap.isEmpty());\n         heap.insert(2);\n         heap.insert(3);\n         heap.insert(1);\n-        heap.inOrder();\n-        Assertions.assertTrue(heap.inOrder().toString().equals(\"[6, 2, 3, 1]\"));\n-        Assertions.assertTrue(heap.extractMin() == 1);\n-        Assertions.assertTrue(heap.inOrder().toString().equals(\"[6, 2, 3]\"));\n+\n+        Assertions.assertEquals(1, heap.extractMin(), \"Minimum should be 1.\");\n+        Assertions.assertEquals(2, heap.extractMin(), \"Next minimum should be 2.\");\n+        Assertions.assertEquals(3, heap.extractMin(), \"Next minimum should be 3.\");\n+        Assertions.assertEquals(6, heap.extractMin(), \"Next minimum should be 6.\");\n+        Assertions.assertEquals(-1, heap.extractMin(), \"Extracting from an empty heap should return -1.\");\n+    }\n+\n+    @Test\n+    void testMerge() {\n+        LeftistHeap heap1 = new LeftistHeap();\n+        heap1.insert(1);\n+        heap1.insert(3);\n+        heap1.insert(5);\n+\n+        LeftistHeap heap2 = new LeftistHeap();\n+        heap2.insert(2);\n+        heap2.insert(4);\n+        heap2.insert(6);\n+\n+        heap1.merge(heap2);\n+\n+        Assertions.assertEquals(1, heap1.extractMin(), \"After merging, minimum should be 1.\");\n+        Assertions.assertEquals(2, heap1.extractMin(), \"Next minimum should be 2.\");\n+        Assertions.assertEquals(3, heap1.extractMin(), \"Next minimum should be 3.\");\n+        Assertions.assertEquals(4, heap1.extractMin(), \"Next minimum should be 4.\");\n+        Assertions.assertEquals(5, heap1.extractMin(), \"Next minimum should be 5.\");\n+        Assertions.assertEquals(6, heap1.extractMin(), \"Next minimum should be 6.\");\n+        Assertions.assertEquals(-1, heap1.extractMin(), \"Extracting from an empty heap should return -1.\");\n+    }\n+\n+    @Test\n+    void testInOrderTraversal() {\n+        LeftistHeap heap = new LeftistHeap();\n+        heap.insert(10);\n+        heap.insert(5);\n+        heap.insert(20);\n+        heap.insert(15);\n+        heap.insert(30);\n+\n+        Assertions.assertEquals(\"[20, 15, 30, 5, 10]\", heap.inOrder().toString(), \"In-order traversal should match the expected output.\");\n+    }\n+\n+    @Test\n+    void testMultipleExtractions() {\n+        LeftistHeap heap = new LeftistHeap();\n+        heap.insert(10);\n+        heap.insert(5);\n+        heap.insert(3);\n         heap.insert(8);\n-        heap.insert(12);\n-        heap.insert(4);\n-        Assertions.assertTrue(heap.inOrder().toString().equals(\"[8, 3, 12, 2, 6, 4]\"));\n-        heap.clear();\n-        Assertions.assertTrue(heap.isEmpty());\n+\n+        // Extract multiple elements\n+        Assertions.assertEquals(3, heap.extractMin());\n+        Assertions.assertEquals(5, heap.extractMin());\n+        Assertions.assertEquals(8, heap.extractMin());\n+        Assertions.assertEquals(10, heap.extractMin());\n+        Assertions.assertEquals(-1, heap.extractMin(), \"Extracting from an empty heap should return -1.\");\n     }\n }",
    "output": {
      "why": "The changes were made to improve documentation within the `LeftistHeap` class, providing clearer explanations for methods and their purposes. The test cases were also enhanced to ensure they provide meaningful context and better validate functionality.",
      "commit_message": "Enhance documentation and improve tests for `LeftistHeap`\n- Updated Javadoc comments in the `LeftistHeap` class for better clarity and understanding of methods and their roles.\n- Refactored test method names for improved readability and context, ensuring tests are intuitively named to describe their functions.\n- Enhanced assertions in tests to provide clearer failure messages and better verification of heap functionalities such as insertion, extraction, and merging.\n- Ensured thorough testing of edge cases such as extracting from an empty heap."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/ciphers/Vigenere.java b/src/main/java/com/thealgorithms/ciphers/Vigenere.java\nindex 1702f1abb94c..0f117853bb85 100644\n--- a/src/main/java/com/thealgorithms/ciphers/Vigenere.java\n+++ b/src/main/java/com/thealgorithms/ciphers/Vigenere.java\n@@ -1,16 +1,54 @@\n package com.thealgorithms.ciphers;\n \n /**\n- * A Java implementation of Vigenere Cipher.\n+ * A Java implementation of the Vigenère Cipher.\n+ *\n+ * The Vigenère Cipher is a polyalphabetic substitution cipher that uses a\n+ * keyword to shift letters in the plaintext by different amounts, depending\n+ * on the corresponding character in the keyword. It wraps around the alphabet,\n+ * ensuring the shifts are within 'A'-'Z' or 'a'-'z'.\n+ *\n+ * Non-alphabetic characters (like spaces, punctuation) are kept unchanged.\n+ *\n+ * Encryption Example:\n+ * - Plaintext: \"Hello World!\"\n+ * - Key: \"suchsecret\"\n+ * - Encrypted Text: \"Zynsg Yfvev!\"\n+ *\n+ * Decryption Example:\n+ * - Ciphertext: \"Zynsg Yfvev!\"\n+ * - Key: \"suchsecret\"\n+ * - Decrypted Text: \"Hello World!\"\n+ *\n+ * Wikipedia Reference:\n+ * <a href=\"https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher\">Vigenère Cipher - Wikipedia</a>\n  *\n  * @author straiffix\n  * @author beingmartinbmc\n  */\n public class Vigenere {\n \n+    /**\n+     * Encrypts a given message using the Vigenère Cipher with the specified key.\n+     * Steps:\n+     * 1. Iterate over each character in the message.\n+     * 2. If the character is a letter, shift it by the corresponding character in the key.\n+     * 3. Preserve the case of the letter.\n+     * 4. Preserve non-alphabetic characters.\n+     * 5. Move to the next character in the key (cyclic).\n+     * 6. Return the encrypted message.\n+     *\n+     * @param message The plaintext message to encrypt.\n+     * @param key The keyword used for encryption.\n+     * @throws IllegalArgumentException if the key is empty.\n+     * @return The encrypted message.\n+     */\n     public String encrypt(final String message, final String key) {\n-        StringBuilder result = new StringBuilder();\n+        if (key.isEmpty()) {\n+            throw new IllegalArgumentException(\"Key cannot be empty.\");\n+        }\n \n+        StringBuilder result = new StringBuilder();\n         int j = 0;\n         for (int i = 0; i < message.length(); i++) {\n             char c = message.charAt(i);\n@@ -20,17 +58,35 @@ public String encrypt(final String message, final String key) {\n                 } else {\n                     result.append((char) ((c + key.toLowerCase().charAt(j) - 2 * 'a') % 26 + 'a'));\n                 }\n+                j = ++j % key.length();\n             } else {\n                 result.append(c);\n             }\n-            j = ++j % key.length();\n         }\n         return result.toString();\n     }\n \n+    /**\n+     * Decrypts a given message encrypted with the Vigenère Cipher using the specified key.\n+     * Steps:\n+     * 1. Iterate over each character in the message.\n+     * 2. If the character is a letter, shift it back by the corresponding character in the key.\n+     * 3. Preserve the case of the letter.\n+     * 4. Preserve non-alphabetic characters.\n+     * 5. Move to the next character in the key (cyclic).\n+     * 6. Return the decrypted message.\n+     *\n+     * @param message The encrypted message to decrypt.\n+     * @param key The keyword used for decryption.\n+     * @throws IllegalArgumentException if the key is empty.\n+     * @return The decrypted plaintext message.\n+     */\n     public String decrypt(final String message, final String key) {\n-        StringBuilder result = new StringBuilder();\n+        if (key.isEmpty()) {\n+            throw new IllegalArgumentException(\"Key cannot be empty.\");\n+        }\n \n+        StringBuilder result = new StringBuilder();\n         int j = 0;\n         for (int i = 0; i < message.length(); i++) {\n             char c = message.charAt(i);\n@@ -40,11 +96,10 @@ public String decrypt(final String message, final String key) {\n                 } else {\n                     result.append((char) ('z' - (25 - (c - key.toLowerCase().charAt(j))) % 26));\n                 }\n+                j = ++j % key.length();\n             } else {\n                 result.append(c);\n             }\n-\n-            j = ++j % key.length();\n         }\n         return result.toString();\n     }\ndiff --git a/src/test/java/com/thealgorithms/ciphers/VigenereTest.java b/src/test/java/com/thealgorithms/ciphers/VigenereTest.java\nindex c5935de95dfa..7f94e5731989 100644\n--- a/src/test/java/com/thealgorithms/ciphers/VigenereTest.java\n+++ b/src/test/java/com/thealgorithms/ciphers/VigenereTest.java\n@@ -1,6 +1,7 @@\n package com.thealgorithms.ciphers;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n import org.junit.jupiter.api.Test;\n \n@@ -9,28 +10,71 @@ class VigenereTest {\n     Vigenere vigenere = new Vigenere();\n \n     @Test\n-    void vigenereEncryptTest() {\n-        // given\n+    void testVigenereEncryptDecrypt() {\n         String text = \"Hello World!\";\n         String key = \"suchsecret\";\n \n-        // when\n-        String cipherText = vigenere.encrypt(text, key);\n+        String encryptedText = vigenere.encrypt(text, key);\n+        String decryptedText = vigenere.decrypt(encryptedText, key);\n \n-        // then\n-        assertEquals(\"Zynsg Yfvev!\", cipherText);\n+        assertEquals(\"Zynsg Aqipw!\", encryptedText);\n+        assertEquals(\"Hello World!\", decryptedText);\n     }\n \n     @Test\n-    void vigenereDecryptTest() {\n-        // given\n-        String encryptedText = \"Zynsg Yfvev!\";\n-        String key = \"suchsecret\";\n+    void testWithEmptyMessage() {\n+        String text = \"\";\n+        String key = \"anykey\";\n \n-        // when\n+        String encryptedText = vigenere.encrypt(text, key);\n         String decryptedText = vigenere.decrypt(encryptedText, key);\n \n-        // then\n-        assertEquals(\"Hello World!\", decryptedText);\n+        assertEquals(\"\", encryptedText);\n+        assertEquals(\"\", decryptedText);\n+    }\n+\n+    @Test\n+    void testWithEmptyKey() {\n+        String text = \"This should remain the same\";\n+        String key = \"\";\n+\n+        assertThrows(IllegalArgumentException.class, () -> vigenere.encrypt(text, key));\n+        assertThrows(IllegalArgumentException.class, () -> vigenere.decrypt(text, key));\n+    }\n+\n+    @Test\n+    void testWithNumbersInMessage() {\n+        String text = \"Vigenere123!\";\n+        String key = \"cipher\";\n+\n+        String encryptedText = vigenere.encrypt(text, key);\n+        String decryptedText = vigenere.decrypt(encryptedText, key);\n+\n+        assertEquals(\"Xqvlrvtm123!\", encryptedText);\n+        assertEquals(text, decryptedText);\n+    }\n+\n+    @Test\n+    void testLongerKeyThanMessage() {\n+        String text = \"Short\";\n+        String key = \"VeryLongSecretKey\";\n+\n+        String encryptedText = vigenere.encrypt(text, key);\n+        String decryptedText = vigenere.decrypt(encryptedText, key);\n+\n+        assertEquals(\"Nlfpe\", encryptedText);\n+        assertEquals(text, decryptedText);\n+    }\n+\n+    @Test\n+    void testUppercaseMessageAndKey() {\n+        String text = \"HELLO\";\n+        String key = \"SECRET\";\n+\n+        String encryptedText = vigenere.encrypt(text, key);\n+        String decryptedText = vigenere.decrypt(encryptedText, key);\n+\n+        assertEquals(\"ZINCS\", encryptedText);\n+        assertEquals(text, decryptedText);\n     }\n }",
    "output": {
      "why": "The changes improve the overall clarity and usability of the `Vigenère Cipher` class by fixing naming errors, updating documentation for better understanding, enforcing key constraints, and broadening the test coverage.",
      "commit_message": "Fix name and enhance documentation for `Vigenere` class\n- Corrected the spelling of `Vigenere` throughout the codebase.\n- Improved class and method documentation to provide clearer explanations of functionality and usage examples.\n- Introduced checks for empty keys in `encrypt` and `decrypt` methods, throwing appropriate exceptions.\n- Expanded unit tests to cover various scenarios, including empty messages, empty keys, messages with numbers, keys longer than messages, and different cases (upper/lower)."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/backtracking/ArrayCombination.java b/src/main/java/com/thealgorithms/backtracking/ArrayCombination.java\nindex 6569896bd1b7..f8cd0c40c20e 100644\n--- a/src/main/java/com/thealgorithms/backtracking/ArrayCombination.java\n+++ b/src/main/java/com/thealgorithms/backtracking/ArrayCombination.java\n@@ -48,7 +48,7 @@ private static void combine(List<List<Integer>> combinations, List<Integer> curr\n         for (int i = start; i < n; i++) {\n             current.add(i);\n             combine(combinations, current, i + 1, n, k);\n-            current.removeLast(); // Backtrack\n+            current.remove(current.size() - 1); // Backtrack\n         }\n     }\n }",
    "output": {
      "why": "The change modifies the backtracking logic to use a more general method for removing elements from the list, improving clarity and supporting better understanding of the operations performed.",
      "commit_message": "Update backtracking element removal method\n- Replaced `current.removeLast()` with `current.remove(current.size() - 1)` to clarify the backtracking operation in the combination generation process.\n- Ensured that the removal operation is consistent with typical Java List operations, enhancing code readability."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/dynamicprogramming/AllConstruct.java b/src/main/java/com/thealgorithms/dynamicprogramming/AllConstruct.java\nnew file mode 100644\nindex 000000000000..e7712b13a2b7\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/dynamicprogramming/AllConstruct.java\n@@ -0,0 +1,61 @@\n+package com.thealgorithms.dynamicprogramming;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This class provides a solution to the \"All Construct\" problem.\n+ *\n+ * The problem is to determine all the ways a target string can be constructed\n+ * from a given list of substrings. Each substring in the word bank can be used\n+ * multiple times, and the order of substrings matters.\n+ *\n+ * @author Hardvan\n+ */\n+public final class AllConstruct {\n+    private AllConstruct() {\n+    }\n+\n+    /**\n+     * Finds all possible ways to construct the target string using substrings\n+     * from the given word bank.\n+     * Time Complexity: O(n * m * k), where n = length of the target,\n+     * m = number of words in wordBank, and k = average length of a word.\n+     *\n+     * Space Complexity: O(n * m) due to the size of the table storing combinations.\n+     *\n+     * @param target   The target string to construct.\n+     * @param wordBank An iterable collection of substrings that can be used to construct the target.\n+     * @return A list of lists, where each inner list represents one possible\n+     *         way of constructing the target string using the given word bank.\n+     */\n+    public static List<List<String>> allConstruct(String target, Iterable<String> wordBank) {\n+        List<List<List<String>>> table = new ArrayList<>(target.length() + 1);\n+\n+        for (int i = 0; i <= target.length(); i++) {\n+            table.add(new ArrayList<>());\n+        }\n+\n+        table.get(0).add(new ArrayList<>());\n+\n+        for (int i = 0; i <= target.length(); i++) {\n+            if (!table.get(i).isEmpty()) {\n+                for (String word : wordBank) {\n+                    if (i + word.length() <= target.length() && target.substring(i, i + word.length()).equals(word)) {\n+\n+                        List<List<String>> newCombinations = new ArrayList<>();\n+                        for (List<String> combination : table.get(i)) {\n+                            List<String> newCombination = new ArrayList<>(combination);\n+                            newCombination.add(word);\n+                            newCombinations.add(newCombination);\n+                        }\n+\n+                        table.get(i + word.length()).addAll(newCombinations);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return table.get(target.length());\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/dynamicprogramming/AllConstructTest.java b/src/test/java/com/thealgorithms/dynamicprogramming/AllConstructTest.java\nnew file mode 100644\nindex 000000000000..4979327fbf2c\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/dynamicprogramming/AllConstructTest.java\n@@ -0,0 +1,38 @@\n+package com.thealgorithms.dynamicprogramming;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+\n+public class AllConstructTest {\n+\n+    @Test\n+    public void testAllConstructBasic() {\n+        List<List<String>> expected = Arrays.asList(Arrays.asList(\"he\", \"l\", \"l\", \"o\"));\n+        List<List<String>> result = AllConstruct.allConstruct(\"hello\", Arrays.asList(\"he\", \"l\", \"o\"));\n+        assertEquals(expected, result);\n+    }\n+\n+    @Test\n+    public void testAllConstructMultipleWays() {\n+        List<List<String>> expected = Arrays.asList(Arrays.asList(\"purp\", \"le\"), Arrays.asList(\"p\", \"ur\", \"p\", \"le\"));\n+        List<List<String>> result = AllConstruct.allConstruct(\"purple\", Arrays.asList(\"purp\", \"p\", \"ur\", \"le\", \"purpl\"));\n+        assertEquals(expected, result);\n+    }\n+\n+    @Test\n+    public void testAllConstructNoWays() {\n+        List<List<String>> expected = Arrays.asList();\n+        List<List<String>> result = AllConstruct.allConstruct(\"abcdef\", Arrays.asList(\"gh\", \"ijk\"));\n+        assertEquals(expected, result);\n+    }\n+\n+    @Test\n+    public void testAllConstructEmptyTarget() {\n+        List<List<String>> expected = Arrays.asList(Arrays.asList());\n+        List<List<String>> result = AllConstruct.allConstruct(\"\", Arrays.asList(\"a\", \"b\", \"c\"));\n+        assertEquals(expected, result);\n+    }\n+}",
    "output": {
      "why": "The `AllConstruct` class was implemented to solve the \"All Construct\" problem, enabling users to find all possible ways to create a target string from a given word bank. Additionally, test cases were added to ensure the correctness of this new functionality.",
      "commit_message": "Add `AllConstruct` class and corresponding tests\n- Implemented the `AllConstruct` class to determine all possible ways to construct a target string from a list of substrings.\n- Updated `DIRECTORY.md` to include references to the new class and its corresponding test file.\n- Added unit tests in `AllConstructTest` to validate different scenarios including basic cases, multiple ways to construct, and edge cases."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMap.java b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMap.java\nindex 1aae122b48ec..aed39c941430 100644\n--- a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMap.java\n+++ b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/HashMap.java\n@@ -85,6 +85,28 @@ public void display() {\n         }\n     }\n \n+    /**\n+     * Clears the contents of the hash map by reinitializing each bucket.\n+     */\n+    public void clear() {\n+        for (int i = 0; i < hashSize; i++) {\n+            buckets[i] = new LinkedList<>();\n+        }\n+    }\n+\n+    /**\n+     * Gets the number of key-value pairs in the hash map.\n+     *\n+     * @return the number of key-value pairs in the hash map\n+     */\n+    public int size() {\n+        int size = 0;\n+        for (int i = 0; i < hashSize; i++) {\n+            size += buckets[i].isEmpty() ? 0 : 1;\n+        }\n+        return size;\n+    }\n+\n     /**\n      * A nested static class that represents a linked list used for separate chaining in the hash map.\n      *\ndiff --git a/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/HashMapTest.java b/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/HashMapTest.java\nindex 3552bc1aa9c5..ff3ba3ed2571 100644\n--- a/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/HashMapTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/HashMapTest.java\n@@ -17,7 +17,7 @@ public void testInsertAndSearch() {\n         assertEquals(\"Value15\", hashMap.search(15));\n         assertEquals(\"Value25\", hashMap.search(25));\n         assertEquals(\"Value35\", hashMap.search(35));\n-        assertNull(hashMap.search(45));\n+        assertNull(hashMap.search(45)); // Test for non-existent key\n     }\n \n     @Test\n@@ -29,7 +29,7 @@ public void testDelete() {\n \n         assertEquals(\"Value25\", hashMap.search(25));\n         hashMap.delete(25);\n-        assertNull(hashMap.search(25));\n+        assertNull(hashMap.search(25)); // Confirm deletion\n     }\n \n     @Test\n@@ -38,21 +38,22 @@ public void testDisplay() {\n         hashMap.insert(15, \"Value15\");\n         hashMap.insert(25, \"Value25\");\n         hashMap.insert(35, \"Value35\");\n-        hashMap.display();\n+        // Optionally verify display functionality if it returns a string\n+        hashMap.display(); // Manual check during test execution\n     }\n \n     @Test\n     public void testInsertNullKey() {\n         HashMap<Integer, String> hashMap = new HashMap<>(10);\n         hashMap.insert(null, \"NullValue\");\n-        assertEquals(\"NullValue\", hashMap.search(null));\n+        assertEquals(\"NullValue\", hashMap.search(null)); // Verify null key handling\n     }\n \n     @Test\n     public void testInsertNullValue() {\n         HashMap<Integer, String> hashMap = new HashMap<>(10);\n         hashMap.insert(15, null);\n-        assertNull(hashMap.search(15));\n+        assertNull(hashMap.search(15)); // Verify null value handling\n     }\n \n     @Test\n@@ -61,12 +62,12 @@ public void testUpdateExistingKey() {\n         hashMap.insert(15, \"Value15\");\n         hashMap.insert(15, \"UpdatedValue15\");\n \n-        assertEquals(\"UpdatedValue15\", hashMap.search(15));\n+        assertEquals(\"UpdatedValue15\", hashMap.search(15)); // Verify update\n     }\n \n     @Test\n     public void testHandleCollisions() {\n-        HashMap<Integer, String> hashMap = new HashMap<>(3);\n+        HashMap<Integer, String> hashMap = new HashMap<>(3); // Create a small bucket size to force collisions\n         // These keys should collide if the hash function is modulo 3\n         hashMap.insert(1, \"Value1\");\n         hashMap.insert(4, \"Value4\");\n@@ -80,17 +81,17 @@ public void testHandleCollisions() {\n     @Test\n     public void testSearchInEmptyHashMap() {\n         HashMap<Integer, String> hashMap = new HashMap<>(10);\n-        assertNull(hashMap.search(10));\n+        assertNull(hashMap.search(10)); // Confirm search returns null in empty map\n     }\n \n     @Test\n     public void testDeleteNonExistentKey() {\n         HashMap<Integer, String> hashMap = new HashMap<>(10);\n         hashMap.insert(15, \"Value15\");\n-        hashMap.delete(25);\n+        hashMap.delete(25); // Delete non-existent key\n \n-        assertEquals(\"Value15\", hashMap.search(15));\n-        assertNull(hashMap.search(25));\n+        assertEquals(\"Value15\", hashMap.search(15)); // Ensure existing key remains\n+        assertNull(hashMap.search(25)); // Confirm non-existent key remains null\n     }\n \n     @Test\n@@ -101,7 +102,7 @@ public void testInsertLargeNumberOfElements() {\n         }\n \n         for (int i = 0; i < 100; i++) {\n-            assertEquals(\"Value\" + i, hashMap.search(i));\n+            assertEquals(\"Value\" + i, hashMap.search(i)); // Verify all inserted values\n         }\n     }\n \n@@ -113,7 +114,7 @@ public void testDeleteHeadOfBucket() {\n         hashMap.insert(7, \"Value7\");\n \n         hashMap.delete(1);\n-        assertNull(hashMap.search(1));\n+        assertNull(hashMap.search(1)); // Verify head deletion\n         assertEquals(\"Value4\", hashMap.search(4));\n         assertEquals(\"Value7\", hashMap.search(7));\n     }\n@@ -126,7 +127,7 @@ public void testDeleteTailOfBucket() {\n         hashMap.insert(7, \"Value7\");\n \n         hashMap.delete(7);\n-        assertNull(hashMap.search(7));\n+        assertNull(hashMap.search(7)); // Verify tail deletion\n         assertEquals(\"Value1\", hashMap.search(1));\n         assertEquals(\"Value4\", hashMap.search(4));\n     }\n@@ -139,8 +140,45 @@ public void testDeleteMiddleElementOfBucket() {\n         hashMap.insert(7, \"Value7\");\n \n         hashMap.delete(4);\n-        assertNull(hashMap.search(4));\n+        assertNull(hashMap.search(4)); // Verify middle element deletion\n         assertEquals(\"Value1\", hashMap.search(1));\n         assertEquals(\"Value7\", hashMap.search(7));\n     }\n+\n+    @Test\n+    public void testResizeHashMap() {\n+        HashMap<Integer, String> hashMap = new HashMap<>(2); // Small initial size to force rehashing\n+        for (int i = 0; i < 10; i++) {\n+            hashMap.insert(i, \"Value\" + i);\n+        }\n+\n+        // Verify all values after resizing\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(\"Value\" + i, hashMap.search(i));\n+        }\n+    }\n+\n+    @Test\n+    public void testCollisionResolution() {\n+        HashMap<String, String> hashMap = new HashMap<>(3);\n+        hashMap.insert(\"abc\", \"Value1\"); // Hash index 0\n+        hashMap.insert(\"cab\", \"Value2\"); // Hash index 0 (collision)\n+        hashMap.insert(\"bac\", \"Value3\"); // Hash index 0 (collision)\n+\n+        assertEquals(\"Value1\", hashMap.search(\"abc\"));\n+        assertEquals(\"Value2\", hashMap.search(\"cab\"));\n+        assertEquals(\"Value3\", hashMap.search(\"bac\"));\n+    }\n+\n+    @Test\n+    public void testClearHashMap() {\n+        HashMap<Integer, String> hashMap = new HashMap<>(10);\n+        hashMap.insert(1, \"Value1\");\n+        hashMap.insert(2, \"Value2\");\n+\n+        hashMap.clear(); // Assuming clear method resets the hash map\n+        assertNull(hashMap.search(1));\n+        assertNull(hashMap.search(2));\n+        assertEquals(0, hashMap.size()); // Verify size is reset\n+    }\n }",
    "output": {
      "why": "New methods `clear` and `size` are added to manage hash map contents effectively. The added tests ensure these methods function correctly and the comments improve clarity for future developers.",
      "commit_message": "Add `clear` and `size` methods to `HashMap`, enhance tests\n- Implemented `clear` to reset the hash map content by reinitializing buckets.\n- Introduced `size` method to return the number of key-value pairs in the hash map.\n- Updated `HashMapTest` class with comprehensive tests for the new methods and improved existing test comments for better understanding."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/ciphers/XORCipher.java b/src/main/java/com/thealgorithms/ciphers/XORCipher.java\nindex c4410d8c77ba..a612ccfbcdef 100644\n--- a/src/main/java/com/thealgorithms/ciphers/XORCipher.java\n+++ b/src/main/java/com/thealgorithms/ciphers/XORCipher.java\n@@ -5,18 +5,46 @@\n import java.util.HexFormat;\n \n /**\n- * A simple implementation of XOR cipher that, given a key, allows to encrypt and decrypt a plaintext.\n+ * A simple implementation of the XOR cipher that allows both encryption and decryption\n+ * using a given key. This cipher works by applying the XOR bitwise operation between\n+ * the bytes of the input text and the corresponding bytes of the key (repeating the key\n+ * if necessary).\n  *\n- * @author <a href=\"https://github.com/lcsjunior\">lcsjunior</a>\n+ * Usage:\n+ * - Encryption: Converts plaintext into a hexadecimal-encoded ciphertext.\n+ * - Decryption: Converts the hexadecimal ciphertext back into plaintext.\n+ *\n+ * Characteristics:\n+ * - Symmetric: The same key is used for both encryption and decryption.\n+ * - Simple but vulnerable: XOR encryption is insecure for real-world cryptography,\n+ *   especially when the same key is reused.\n+ *\n+ * Example:\n+ * Plaintext: \"Hello!\"\n+ * Key: \"key\"\n+ * Encrypted: \"27090c03120b\"\n+ * Decrypted: \"Hello!\"\n  *\n+ * Reference: <a href=\"https://en.wikipedia.org/wiki/XOR_cipher\">XOR Cipher - Wikipedia</a>\n+ *\n+ * @author <a href=\"https://github.com/lcsjunior\">lcsjunior</a>\n  */\n public final class XORCipher {\n \n+    // Default character encoding for string conversion\n     private static final Charset CS_DEFAULT = StandardCharsets.UTF_8;\n \n     private XORCipher() {\n     }\n \n+    /**\n+     * Applies the XOR operation between the input bytes and the key bytes.\n+     * If the key is shorter than the input, it wraps around (cyclically).\n+     *\n+     * @param inputBytes The input byte array (plaintext or ciphertext).\n+     * @param keyBytes The key byte array used for XOR operation.\n+     * @return A new byte array containing the XOR result.\n+     */\n     public static byte[] xor(final byte[] inputBytes, final byte[] keyBytes) {\n         byte[] outputBytes = new byte[inputBytes.length];\n         for (int i = 0; i < inputBytes.length; ++i) {\n@@ -25,14 +53,40 @@ public static byte[] xor(final byte[] inputBytes, final byte[] keyBytes) {\n         return outputBytes;\n     }\n \n+    /**\n+     * Encrypts the given plaintext using the XOR cipher with the specified key.\n+     * The result is a hexadecimal-encoded string representing the ciphertext.\n+     *\n+     * @param plainText The input plaintext to encrypt.\n+     * @param key The encryption key.\n+     * @throws IllegalArgumentException if the key is empty.\n+     * @return A hexadecimal string representing the encrypted text.\n+     */\n     public static String encrypt(final String plainText, final String key) {\n+        if (key.isEmpty()) {\n+            throw new IllegalArgumentException(\"Key must not be empty\");\n+        }\n+\n         byte[] plainTextBytes = plainText.getBytes(CS_DEFAULT);\n         byte[] keyBytes = key.getBytes(CS_DEFAULT);\n         byte[] xorResult = xor(plainTextBytes, keyBytes);\n         return HexFormat.of().formatHex(xorResult);\n     }\n \n+    /**\n+     * Decrypts the given ciphertext (in hexadecimal format) using the XOR cipher\n+     * with the specified key. The result is the original plaintext.\n+     *\n+     * @param cipherText The hexadecimal string representing the encrypted text.\n+     * @param key The decryption key (must be the same as the encryption key).\n+     * @throws IllegalArgumentException if the key is empty.\n+     * @return The decrypted plaintext.\n+     */\n     public static String decrypt(final String cipherText, final String key) {\n+        if (key.isEmpty()) {\n+            throw new IllegalArgumentException(\"Key must not be empty\");\n+        }\n+\n         byte[] cipherBytes = HexFormat.of().parseHex(cipherText);\n         byte[] keyBytes = key.getBytes(CS_DEFAULT);\n         byte[] xorResult = xor(cipherBytes, keyBytes);\ndiff --git a/src/test/java/com/thealgorithms/ciphers/XORCipherTest.java b/src/test/java/com/thealgorithms/ciphers/XORCipherTest.java\nindex 15e27d5d6778..fdfe640cc19b 100644\n--- a/src/test/java/com/thealgorithms/ciphers/XORCipherTest.java\n+++ b/src/test/java/com/thealgorithms/ciphers/XORCipherTest.java\n@@ -1,34 +1,85 @@\n package com.thealgorithms.ciphers;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n import org.junit.jupiter.api.Test;\n \n class XORCipherTest {\n \n     @Test\n-    void xorEncryptTest() {\n-        // given\n+    void xorEncryptDecryptTest() {\n         String plaintext = \"My t&xt th@t will be ençrypted...\";\n         String key = \"My ç&cret key!\";\n \n-        // when\n         String cipherText = XORCipher.encrypt(plaintext, key);\n+        String decryptedText = XORCipher.decrypt(cipherText, key);\n \n-        // then\n-        assertEquals(\"000000b7815e1752111c601f450e48211500a1c206061ca6d35212150d4429570eed\", cipherText);\n+        assertEquals(\"My t&xt th@t will be ençrypted...\", decryptedText);\n     }\n \n     @Test\n-    void xorDecryptTest() {\n-        // given\n-        String cipherText = \"000000b7815e1752111c601f450e48211500a1c206061ca6d35212150d4429570eed\";\n-        String key = \"My ç&cret key!\";\n+    void testEmptyPlaintext() {\n+        String plaintext = \"\";\n+        String key = \"anykey\";\n+\n+        String cipherText = XORCipher.encrypt(plaintext, key);\n+        String decryptedText = XORCipher.decrypt(cipherText, key);\n+\n+        assertEquals(\"\", cipherText);\n+        assertEquals(\"\", decryptedText);\n+    }\n+\n+    @Test\n+    void testEmptyKey() {\n+        String plaintext = \"Hello World!\";\n+        String key = \"\";\n+\n+        assertThrows(IllegalArgumentException.class, () -> XORCipher.encrypt(plaintext, key));\n+        assertThrows(IllegalArgumentException.class, () -> XORCipher.decrypt(plaintext, key));\n+    }\n+\n+    @Test\n+    void testShortKey() {\n+        String plaintext = \"Short message\";\n+        String key = \"k\";\n+\n+        String cipherText = XORCipher.encrypt(plaintext, key);\n+        String decryptedText = XORCipher.decrypt(cipherText, key);\n+\n+        assertEquals(plaintext, decryptedText);\n+    }\n \n-        // when\n-        String plainText = XORCipher.decrypt(cipherText, key);\n+    @Test\n+    void testNonASCIICharacters() {\n+        String plaintext = \"こんにちは世界\"; // \"Hello World\" in Japanese (Konichiwa Sekai)\n+        String key = \"key\";\n+\n+        String cipherText = XORCipher.encrypt(plaintext, key);\n+        String decryptedText = XORCipher.decrypt(cipherText, key);\n+\n+        assertEquals(plaintext, decryptedText);\n+    }\n+\n+    @Test\n+    void testSameKeyAndPlaintext() {\n+        String plaintext = \"samekey\";\n+        String key = \"samekey\";\n+\n+        String cipherText = XORCipher.encrypt(plaintext, key);\n+        String decryptedText = XORCipher.decrypt(cipherText, key);\n+\n+        assertEquals(plaintext, decryptedText);\n+    }\n+\n+    @Test\n+    void testLongPlaintextShortKey() {\n+        String plaintext = \"This is a long plaintext message.\";\n+        String key = \"key\";\n+\n+        String cipherText = XORCipher.encrypt(plaintext, key);\n+        String decryptedText = XORCipher.decrypt(cipherText, key);\n \n-        // then\n-        assertEquals(\"My t&xt th@t will be ençrypted...\", plainText);\n+        assertEquals(plaintext, decryptedText);\n     }\n }",
    "output": {
      "why": "These changes improve documentation clarity for the XORCipher class and ensure proper handling of edge cases through additional unit tests. The addition of `MinSumKSizeSubarray` maintains updated references for algorithm implementations, promoting easier access for users.",
      "commit_message": "Add `MinSumKSizeSubarray` references and enhance `XORCipher`\n- Included links for `MinSumKSizeSubarray` and its test in `DIRECTORY.md`.\n- Updated documentation in `XORCipher.java` to clarify usage, including details about encryption and decryption processes.\n- Expanded unit tests in `XORCipherTest` to cover edge cases:\n- Testing decryption of empty plaintext.\n- Handling of empty keys and very short keys.\n- Validating non-ASCII character support and comparing ciphertext with same plaintext keys."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/scheduling/RandomScheduling.java b/src/main/java/com/thealgorithms/scheduling/RandomScheduling.java\nnew file mode 100644\nindex 000000000000..b7e863b5cfd8\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/scheduling/RandomScheduling.java\n@@ -0,0 +1,45 @@\n+package com.thealgorithms.scheduling;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Random;\n+\n+/**\n+ * RandomScheduling is an algorithm that assigns tasks in a random order.\n+ * It doesn't consider priority, deadlines, or burst times, making it\n+ * inefficient but useful in scenarios where fairness or unpredictability\n+ * is required (e.g., load balancing in distributed systems).\n+ *\n+ * Use Case: Distributed systems where randomness helps avoid task starvation.\n+ *\n+ * @author Hardvan\n+ */\n+public final class RandomScheduling {\n+\n+    private final List<String> tasks;\n+    private final Random random;\n+\n+    /**\n+     * Constructs a new RandomScheduling instance.\n+     *\n+     * @param tasks A collection of task names to be scheduled.\n+     * @param random A Random instance for generating random numbers.\n+     */\n+    public RandomScheduling(Collection<String> tasks, Random random) {\n+        this.tasks = new ArrayList<>(tasks);\n+        this.random = random;\n+    }\n+\n+    /**\n+     * Schedules the tasks randomly and returns the randomized order.\n+     *\n+     * @return A list representing the tasks in their randomized execution order.\n+     */\n+    public List<String> schedule() {\n+        List<String> shuffledTasks = new ArrayList<>(tasks);\n+        Collections.shuffle(shuffledTasks, random);\n+        return shuffledTasks;\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/scheduling/RandomSchedulingTest.java b/src/test/java/com/thealgorithms/scheduling/RandomSchedulingTest.java\nnew file mode 100644\nindex 000000000000..e2c8777d892f\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/scheduling/RandomSchedulingTest.java\n@@ -0,0 +1,93 @@\n+package com.thealgorithms.scheduling;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.Mockito.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.List;\n+import java.util.Random;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+public class RandomSchedulingTest {\n+\n+    private RandomScheduling randomScheduling;\n+    private Random mockRandom;\n+\n+    @BeforeEach\n+    public void setup() {\n+        mockRandom = mock(Random.class); // Mocking Random for predictable behavior\n+    }\n+\n+    @Test\n+    public void testRandomOrder1() {\n+        // Arrange\n+        List<String> tasks = List.of(\"Task1\", \"Task2\", \"Task3\");\n+        // Mock the random sequence to control shuffling: swap 0 <-> 1, and 1 <-> 2.\n+        when(mockRandom.nextInt(anyInt())).thenReturn(1, 2, 0);\n+        randomScheduling = new RandomScheduling(tasks, mockRandom);\n+\n+        // Act\n+        List<String> result = randomScheduling.schedule();\n+\n+        // Assert\n+        assertEquals(List.of(\"Task1\", \"Task2\", \"Task3\"), result);\n+    }\n+\n+    @Test\n+    public void testRandomOrder2() {\n+        // Arrange\n+        List<String> tasks = List.of(\"A\", \"B\", \"C\", \"D\");\n+        // Mocking predictable swaps for the sequence: [C, B, D, A]\n+        when(mockRandom.nextInt(anyInt())).thenReturn(2, 1, 3, 0);\n+        randomScheduling = new RandomScheduling(tasks, mockRandom);\n+\n+        // Act\n+        List<String> result = randomScheduling.schedule();\n+\n+        // Assert\n+        assertEquals(List.of(\"A\", \"C\", \"B\", \"D\"), result);\n+    }\n+\n+    @Test\n+    public void testSingleTask() {\n+        // Arrange\n+        List<String> tasks = List.of(\"SingleTask\");\n+        when(mockRandom.nextInt(anyInt())).thenReturn(0); // No real shuffle\n+        randomScheduling = new RandomScheduling(tasks, mockRandom);\n+\n+        // Act\n+        List<String> result = randomScheduling.schedule();\n+\n+        // Assert\n+        assertEquals(List.of(\"SingleTask\"), result);\n+    }\n+\n+    @Test\n+    public void testEmptyTaskList() {\n+        // Arrange\n+        List<String> tasks = List.of();\n+        randomScheduling = new RandomScheduling(tasks, mockRandom);\n+\n+        // Act\n+        List<String> result = randomScheduling.schedule();\n+\n+        // Assert\n+        assertEquals(List.of(), result); // Should return an empty list\n+    }\n+\n+    @Test\n+    public void testSameTasksMultipleTimes() {\n+        // Arrange\n+        List<String> tasks = List.of(\"X\", \"X\", \"Y\", \"Z\");\n+        when(mockRandom.nextInt(anyInt())).thenReturn(3, 0, 1, 2);\n+        randomScheduling = new RandomScheduling(tasks, mockRandom);\n+\n+        // Act\n+        List<String> result = randomScheduling.schedule();\n+\n+        // Assert\n+        assertEquals(List.of(\"Y\", \"X\", \"X\", \"Z\"), result);\n+    }\n+}",
    "output": {
      "why": "The new algorithm for random scheduling was introduced to allow tasks to be assigned in a random order, which can be useful for fairness in scenarios like load balancing. Additionally, test cases were added to ensure its functionality was correct and predictable through mocked random outputs, demonstrating effective unit testing.",
      "commit_message": "Add `RandomScheduling` algorithm and corresponding tests\n- Introduced the `RandomScheduling` class that assigns tasks randomly, useful for scenarios that require unpredictability.\n- Added a comprehensive test suite in `RandomSchedulingTest.java` to verify the correct behavior of the scheduling algorithm with mocked random outputs.\n- Updated `DIRECTORY.md` to include links to the new class and its tests for better navigation in the codebase."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/bitmanipulation/SwapAdjacentBits.java b/src/main/java/com/thealgorithms/bitmanipulation/SwapAdjacentBits.java\nindex 933dec5654a0..98a7de8bdf1a 100644\n--- a/src/main/java/com/thealgorithms/bitmanipulation/SwapAdjacentBits.java\n+++ b/src/main/java/com/thealgorithms/bitmanipulation/SwapAdjacentBits.java\n@@ -1,14 +1,45 @@\n package com.thealgorithms.bitmanipulation;\n \n /**\n- * Swap every pair of adjacent bits of a given number.\n- * @author Lakshyajeet Singh Goyal (https://github.com/DarkMatter-999)\n+ * A utility class to swap every pair of adjacent bits in a given integer.\n+ * This operation shifts the even-positioned bits to odd positions and vice versa.\n+ *\n+ * Example:\n+ * - Input: 2 (binary: `10`) → Output: 1 (binary: `01`)\n+ * - Input: 43 (binary: `101011`) → Output: 23 (binary: `010111`)\n+ *\n+ * **Explanation of the Algorithm:**\n+ * 1. Mask even-positioned bits: Using `0xAAAAAAAA` (binary: `101010...`),\n+ *    which selects bits in even positions.\n+ * 2. Mask odd-positioned bits: Using `0x55555555` (binary: `010101...`),\n+ *    which selects bits in odd positions.\n+ * 3. Shift bits:\n+ *    - Right-shift even-positioned bits by 1 to move them to odd positions.\n+ *    - Left-shift odd-positioned bits by 1 to move them to even positions.\n+ * 4. Combine both shifted results using bitwise OR (`|`) to produce the final result.\n+ *\n+ * Use Case: This algorithm can be useful in applications involving low-level bit manipulation,\n+ * such as encoding, data compression, or cryptographic transformations.\n+ *\n+ * Time Complexity: O(1) (constant time, since operations are bitwise).\n+ *\n+ * Author: Lakshyajeet Singh Goyal (https://github.com/DarkMatter-999)\n  */\n-\n public final class SwapAdjacentBits {\n     private SwapAdjacentBits() {\n     }\n \n+    /**\n+     * Swaps every pair of adjacent bits of a given integer.\n+     * Steps:\n+     * 1. Mask the even-positioned bits.\n+     * 2. Mask the odd-positioned bits.\n+     * 3. Shift the even bits to the right and the odd bits to the left.\n+     * 4. Combine the shifted bits.\n+     *\n+     * @param num the integer whose bits are to be swapped\n+     * @return the integer after swapping every pair of adjacent bits\n+     */\n     public static int swapAdjacentBits(int num) {\n         // mask the even bits (0xAAAAAAAA => 10101010...)\n         int evenBits = num & 0xAAAAAAAA;\ndiff --git a/src/test/java/com/thealgorithms/bitmanipulation/SwapAdjacentBitsTest.java b/src/test/java/com/thealgorithms/bitmanipulation/SwapAdjacentBitsTest.java\nindex 67c986136ab0..12f0542b92f6 100644\n--- a/src/test/java/com/thealgorithms/bitmanipulation/SwapAdjacentBitsTest.java\n+++ b/src/test/java/com/thealgorithms/bitmanipulation/SwapAdjacentBitsTest.java\n@@ -8,13 +8,20 @@\n class SwapAdjacentBitsTest {\n \n     @ParameterizedTest\n-    @CsvSource({\n-        \"2, 1\", // 2 (10 in binary) should become 1 (01 in binary)\n-        \"43, 23\", // 43 should become 23\n-        \"153, 102\", // 153 should become 102\n-        \"15, 15\", // 15 (1111) remains 15 (1111)\n-        \"0, 0\" // 0 (0000) remains 0 (0000)\n-    })\n+    @CsvSource({\"2, 1\", // 2 (binary: 10) -> 1 (binary: 01)\n+        \"43, 23\", // 43 (binary: 101011) -> 23 (binary: 010111)\n+        \"153, 102\", // 153 (binary: 10011001) -> 102 (binary: 01100110)\n+        \"15, 15\", // 15 (binary: 1111) -> 15 (binary: 1111) (no change)\n+        \"0, 0\", // 0 (binary: 0000) -> 0 (binary: 0000) (no change)\n+        \"1, 2\", // 1 (binary: 01) -> 2 (binary: 10)\n+        \"170, 85\", // 170 (binary: 10101010) -> 85 (binary: 01010101)\n+        \"85, 170\", // 85 (binary: 01010101) -> 170 (binary: 10101010)\n+        \"255, 255\", // 255 (binary: 11111111) -> 255 (binary: 11111111) (no change)\n+        \"128, 64\", // 128 (binary: 10000000) -> 64 (binary: 01000000)\n+        \"1024, 2048\",\n+        \"-1, -1\", // -1 (all bits 1) remains -1 (no change due to two's complement)\n+        \"-2, -3\", // -2 (binary: ...1110) -> -3 (binary: ...1101)\n+        \"2147483647, -1073741825\", \"-2147483648, -1073741824\"})\n     void\n     testSwapAdjacentBits(int input, int expected) {\n         assertEquals(expected, SwapAdjacentBits.swapAdjacentBits(input));",
    "output": {
      "why": "The Javadoc comments were made clearer and more informative, providing examples and a detailed algorithm explanation to help users understand how to use the `swapAdjacentBits` method effectively. Additionally, test cases were expanded to cover more scenarios, ensuring robust testing.",
      "commit_message": "Enhance documentation and expand test cases for `SwapAdjacentBits`\n- Updated Javadoc in `SwapAdjacentBits` to include:\n- Clear definitions of the function's purpose.\n- Detailed example inputs and outputs demonstrating the bit-swap operation.\n- Step-by-step explanation of the algorithm used.\n- Expanded test cases in `SwapAdjacentBitsTest` to ensure comprehensive coverage:\n- Added tests for edge cases and additional scenarios, such as negative numbers and maximum integer values."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/ciphers/RSA.java b/src/main/java/com/thealgorithms/ciphers/RSA.java\nindex f50e501e68c8..28af1a62032a 100644\n--- a/src/main/java/com/thealgorithms/ciphers/RSA.java\n+++ b/src/main/java/com/thealgorithms/ciphers/RSA.java\n@@ -4,7 +4,27 @@\n import java.security.SecureRandom;\n \n /**\n- * @author Nguyen Duy Tiep on 23-Oct-17.\n+ * RSA is an asymmetric cryptographic algorithm used for secure data encryption and decryption.\n+ * It relies on a pair of keys: a public key (used for encryption) and a private key\n+ * (used for decryption). The algorithm is based on the difficulty of factoring large prime numbers.\n+ *\n+ * This implementation includes key generation, encryption, and decryption methods that can handle both\n+ * text-based messages and BigInteger inputs. For more details on RSA:\n+ * <a href=\"https://en.wikipedia.org/wiki/RSA_(cryptosystem)\">RSA Cryptosystem - Wikipedia</a>.\n+ *\n+ * Example Usage:\n+ * <pre>\n+ * RSA rsa = new RSA(1024);\n+ * String encryptedMessage = rsa.encrypt(\"Hello RSA!\");\n+ * String decryptedMessage = rsa.decrypt(encryptedMessage);\n+ * System.out.println(decryptedMessage);  // Output: Hello RSA!\n+ * </pre>\n+ *\n+ * Note: The key size directly affects the security and performance of the RSA algorithm.\n+ * Larger keys are more secure but slower to compute.\n+ *\n+ * @author Nguyen Duy Tiep\n+ * @version 23-Oct-17\n  */\n public class RSA {\n \n@@ -12,55 +32,88 @@ public class RSA {\n     private BigInteger privateKey;\n     private BigInteger publicKey;\n \n+    /**\n+     * Constructor that generates RSA keys with the specified number of bits.\n+     *\n+     * @param bits The bit length of the keys to be generated. Common sizes include 512, 1024, 2048, etc.\n+     */\n     public RSA(int bits) {\n         generateKeys(bits);\n     }\n \n     /**\n-     * @return encrypted message\n+     * Encrypts a text message using the RSA public key.\n+     *\n+     * @param message The plaintext message to be encrypted.\n+     * @throws IllegalArgumentException If the message is empty.\n+     * @return The encrypted message represented as a String.\n      */\n     public synchronized String encrypt(String message) {\n+        if (message.isEmpty()) {\n+            throw new IllegalArgumentException(\"Message is empty\");\n+        }\n         return (new BigInteger(message.getBytes())).modPow(publicKey, modulus).toString();\n     }\n \n     /**\n-     * @return encrypted message as big integer\n+     * Encrypts a BigInteger message using the RSA public key.\n+     *\n+     * @param message The plaintext message as a BigInteger.\n+     * @return The encrypted message as a BigInteger.\n      */\n     public synchronized BigInteger encrypt(BigInteger message) {\n         return message.modPow(publicKey, modulus);\n     }\n \n     /**\n-     * @return plain message\n+     * Decrypts an encrypted message (as String) using the RSA private key.\n+     *\n+     * @param encryptedMessage The encrypted message to be decrypted, represented as a String.\n+     * @throws IllegalArgumentException If the message is empty.\n+     * @return The decrypted plaintext message as a String.\n      */\n     public synchronized String decrypt(String encryptedMessage) {\n+        if (encryptedMessage.isEmpty()) {\n+            throw new IllegalArgumentException(\"Message is empty\");\n+        }\n         return new String((new BigInteger(encryptedMessage)).modPow(privateKey, modulus).toByteArray());\n     }\n \n     /**\n-     * @return plain message as big integer\n+     * Decrypts an encrypted BigInteger message using the RSA private key.\n+     *\n+     * @param encryptedMessage The encrypted message as a BigInteger.\n+     * @return The decrypted plaintext message as a BigInteger.\n      */\n     public synchronized BigInteger decrypt(BigInteger encryptedMessage) {\n         return encryptedMessage.modPow(privateKey, modulus);\n     }\n \n     /**\n-     * Generate a new public and private key set.\n+     * Generates a new RSA key pair (public and private keys) with the specified bit length.\n+     * Steps:\n+     * 1. Generate two large prime numbers p and q.\n+     * 2. Compute the modulus n = p * q.\n+     * 3. Compute Euler's totient function: φ(n) = (p-1) * (q-1).\n+     * 4. Choose a public key e (starting from 3) that is coprime with φ(n).\n+     * 5. Compute the private key d as the modular inverse of e mod φ(n).\n+     * The public key is (e, n) and the private key is (d, n).\n+     *\n+     * @param bits The bit length of the keys to be generated.\n      */\n     public final synchronized void generateKeys(int bits) {\n-        SecureRandom r = new SecureRandom();\n-        BigInteger p = new BigInteger(bits / 2, 100, r);\n-        BigInteger q = new BigInteger(bits / 2, 100, r);\n+        SecureRandom random = new SecureRandom();\n+        BigInteger p = new BigInteger(bits / 2, 100, random);\n+        BigInteger q = new BigInteger(bits / 2, 100, random);\n         modulus = p.multiply(q);\n \n-        BigInteger m = (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));\n+        BigInteger phi = (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));\n \n         publicKey = BigInteger.valueOf(3L);\n-\n-        while (m.gcd(publicKey).intValue() > 1) {\n+        while (phi.gcd(publicKey).intValue() > 1) {\n             publicKey = publicKey.add(BigInteger.TWO);\n         }\n \n-        privateKey = publicKey.modInverse(m);\n+        privateKey = publicKey.modInverse(phi);\n     }\n }\ndiff --git a/src/test/java/com/thealgorithms/ciphers/RSATest.java b/src/test/java/com/thealgorithms/ciphers/RSATest.java\nindex c82f68d11f4c..577f56426be8 100644\n--- a/src/test/java/com/thealgorithms/ciphers/RSATest.java\n+++ b/src/test/java/com/thealgorithms/ciphers/RSATest.java\n@@ -1,23 +1,64 @@\n package com.thealgorithms.ciphers;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n+import java.math.BigInteger;\n import org.junit.jupiter.api.Test;\n \n class RSATest {\n \n-    RSA rsa = new RSA(1024);\n+    private final RSA rsa = new RSA(1024);\n \n     @Test\n-    void testRSA() {\n-        // given\n-        String textToEncrypt = \"Such secure\";\n+    void testEncryptDecryptString() {\n+        String originalMessage = \"Such secure\";\n+        String encryptedMessage = rsa.encrypt(originalMessage);\n+        String decryptedMessage = rsa.decrypt(encryptedMessage);\n+        assertEquals(originalMessage, decryptedMessage);\n+    }\n+\n+    @Test\n+    void testEncryptDecryptBigInteger() {\n+        BigInteger originalMessage = new BigInteger(\"12345678901234567890\");\n+        BigInteger encryptedMessage = rsa.encrypt(originalMessage);\n+        BigInteger decryptedMessage = rsa.decrypt(encryptedMessage);\n+        assertEquals(originalMessage, decryptedMessage);\n+    }\n \n-        // when\n-        String cipherText = rsa.encrypt(textToEncrypt);\n-        String decryptedText = rsa.decrypt(cipherText);\n+    @Test\n+    void testEmptyMessage() {\n+        String originalMessage = \"\";\n+        assertThrows(IllegalArgumentException.class, () -> rsa.encrypt(originalMessage));\n+        assertThrows(IllegalArgumentException.class, () -> rsa.decrypt(originalMessage));\n+    }\n+\n+    @Test\n+    void testDifferentKeySizes() {\n+        // Testing with 512-bit RSA keys\n+        RSA smallRSA = new RSA(512);\n+        String originalMessage = \"Test with smaller key\";\n \n-        // then\n-        assertEquals(\"Such secure\", decryptedText);\n+        String encryptedMessage = smallRSA.encrypt(originalMessage);\n+        String decryptedMessage = smallRSA.decrypt(encryptedMessage);\n+\n+        assertEquals(originalMessage, decryptedMessage);\n+\n+        // Testing with 2048-bit RSA keys\n+        RSA largeRSA = new RSA(2048);\n+        String largeOriginalMessage = \"Test with larger key\";\n+\n+        String largeEncryptedMessage = largeRSA.encrypt(largeOriginalMessage);\n+        String largeDecryptedMessage = largeRSA.decrypt(largeEncryptedMessage);\n+\n+        assertEquals(largeOriginalMessage, largeDecryptedMessage);\n+    }\n+\n+    @Test\n+    void testSpecialCharacters() {\n+        String originalMessage = \"Hello, RSA! @2024#\";\n+        String encryptedMessage = rsa.encrypt(originalMessage);\n+        String decryptedMessage = rsa.decrypt(encryptedMessage);\n+        assertEquals(originalMessage, decryptedMessage);\n     }\n }",
    "output": {
      "why": "The changes aim to improve the overall documentation of the RSA class and its methods, making it clearer for users to understand how to use them. Additionally, the test class expanded to cover various scenarios, including empty messages and different key sizes, ensuring that the implementation is robust and handles edge cases effectively.",
      "commit_message": "Enhance documentation and testing for RSA implementation\n- Expanded the class-level documentation in RSA.java to provide a clear overview of the RSA algorithm, including its key concepts and usage examples.\n- Added detailed method descriptions for all public methods in the RSA class to improve understanding of their functionality.\n- Improved error handling by throwing exceptions for empty messages in the encrypt and decrypt methods.\n- Enhanced RSATest with additional test cases to ensure comprehensive coverage, including tests for empty messages, special characters, and varying key sizes (512, 1024, 2048 bits)."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/graph/ConstrainedShortestPath.java b/src/main/java/com/thealgorithms/graph/ConstrainedShortestPath.java\nnew file mode 100644\nindex 000000000000..f397989911d9\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/graph/ConstrainedShortestPath.java\n@@ -0,0 +1,123 @@\n+package com.thealgorithms.graph;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * This class implements a solution for the Constrained Shortest Path Problem (CSPP).\n+ * also known as Shortest Path Problem with Resource Constraints (SPPRC).\n+ * The goal is to find the shortest path between two nodes while ensuring that\n+ * the resource constraint is not exceeded.\n+ *\n+ * @author  <a href=\"https://github.com/DenizAltunkapan\">Deniz Altunkapan</a>\n+ */\n+public class ConstrainedShortestPath {\n+\n+    /**\n+     * Represents a graph using an adjacency list.\n+     * This graph is designed for the Constrained Shortest Path Problem (CSPP).\n+     */\n+    public static class Graph {\n+\n+        private List<List<Edge>> adjacencyList;\n+\n+        public Graph(int numNodes) {\n+            adjacencyList = new ArrayList<>();\n+            for (int i = 0; i < numNodes; i++) {\n+                adjacencyList.add(new ArrayList<>());\n+            }\n+        }\n+\n+        /**\n+         * Adds an edge to the graph.\n+         * @param from the starting node\n+         * @param to the ending node\n+         * @param cost the cost of the edge\n+         * @param resource the resource required to traverse the edge\n+         */\n+        public void addEdge(int from, int to, int cost, int resource) {\n+            adjacencyList.get(from).add(new Edge(from, to, cost, resource));\n+        }\n+\n+        /**\n+         * Gets the edges that are adjacent to a given node.\n+         * @param node the node to get the edges for\n+         * @return the list of edges adjacent to the node\n+         */\n+        public List<Edge> getEdges(int node) {\n+            return adjacencyList.get(node);\n+        }\n+\n+        /**\n+         * Gets the number of nodes in the graph.\n+         * @return the number of nodes\n+         */\n+        public int getNumNodes() {\n+            return adjacencyList.size();\n+        }\n+\n+        public record Edge(int from, int to, int cost, int resource) {\n+        }\n+    }\n+\n+    private Graph graph;\n+    private int maxResource;\n+\n+    /**\n+     * Constructs a CSPSolver with the given graph and maximum resource constraint.\n+     *\n+     * @param graph       the graph representing the problem\n+     * @param maxResource the maximum allowable resource\n+     */\n+    public ConstrainedShortestPath(Graph graph, int maxResource) {\n+        this.graph = graph;\n+        this.maxResource = maxResource;\n+    }\n+\n+    /**\n+     * Solves the CSP to find the shortest path from the start node to the target node\n+     * without exceeding the resource constraint.\n+     *\n+     * @param start  the starting node\n+     * @param target the target node\n+     * @return the minimum cost to reach the target node within the resource constraint,\n+     *         or -1 if no valid path exists\n+     */\n+    public int solve(int start, int target) {\n+        int numNodes = graph.getNumNodes();\n+        int[][] dp = new int[maxResource + 1][numNodes];\n+\n+        // Initialize dp table with maximum values\n+        for (int i = 0; i <= maxResource; i++) {\n+            Arrays.fill(dp[i], Integer.MAX_VALUE);\n+        }\n+        dp[0][start] = 0;\n+\n+        // Dynamic Programming: Iterate over resources and nodes\n+        for (int r = 0; r <= maxResource; r++) {\n+            for (int u = 0; u < numNodes; u++) {\n+                if (dp[r][u] == Integer.MAX_VALUE) {\n+                    continue;\n+                }\n+                for (Graph.Edge edge : graph.getEdges(u)) {\n+                    int v = edge.to();\n+                    int cost = edge.cost();\n+                    int resource = edge.resource();\n+\n+                    if (r + resource <= maxResource) {\n+                        dp[r + resource][v] = Math.min(dp[r + resource][v], dp[r][u] + cost);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Find the minimum cost to reach the target node\n+        int minCost = Integer.MAX_VALUE;\n+        for (int r = 0; r <= maxResource; r++) {\n+            minCost = Math.min(minCost, dp[r][target]);\n+        }\n+\n+        return minCost == Integer.MAX_VALUE ? -1 : minCost;\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/graph/ConstrainedShortestPathTest.java b/src/test/java/com/thealgorithms/graph/ConstrainedShortestPathTest.java\nnew file mode 100644\nindex 000000000000..eccd359f2634\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/graph/ConstrainedShortestPathTest.java\n@@ -0,0 +1,218 @@\n+package com.thealgorithms.graph;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import com.thealgorithms.graph.ConstrainedShortestPath.Graph;\n+import org.junit.jupiter.api.Test;\n+\n+public class ConstrainedShortestPathTest {\n+\n+    /**\n+     * Tests a simple linear graph to verify if the solver calculates the shortest path correctly.\n+     * Expected: The minimal path cost from node 0 to node 2 should be 5 while not exceeding the resource limit.\n+     */\n+    @Test\n+    public void testSimpleGraph() {\n+        Graph graph = new Graph(3);\n+        graph.addEdge(0, 1, 2, 3);\n+        graph.addEdge(1, 2, 3, 2);\n+\n+        int maxResource = 5;\n+        ConstrainedShortestPath solver = new ConstrainedShortestPath(graph, maxResource);\n+\n+        assertEquals(5, solver.solve(0, 2));\n+    }\n+\n+    /**\n+     * Tests a graph where no valid path exists due to resource constraints.\n+     * Expected: The solver should return -1, indicating no path is feasible.\n+     */\n+    @Test\n+    public void testNoPath() {\n+        Graph graph = new Graph(3);\n+        graph.addEdge(0, 1, 2, 6);\n+        graph.addEdge(1, 2, 3, 6);\n+\n+        int maxResource = 5;\n+        ConstrainedShortestPath solver = new ConstrainedShortestPath(graph, maxResource);\n+\n+        assertEquals(-1, solver.solve(0, 2));\n+    }\n+\n+    /**\n+     * Tests a graph with multiple paths between source and destination.\n+     * Expected: The solver should choose the path with the minimal cost of 5, considering the resource limit.\n+     */\n+    @Test\n+    public void testMultiplePaths() {\n+        Graph graph = new Graph(4);\n+        graph.addEdge(0, 1, 1, 1);\n+        graph.addEdge(1, 3, 5, 2);\n+        graph.addEdge(0, 2, 2, 1);\n+        graph.addEdge(2, 3, 3, 2);\n+\n+        int maxResource = 3;\n+        ConstrainedShortestPath solver = new ConstrainedShortestPath(graph, maxResource);\n+\n+        assertEquals(5, solver.solve(0, 3));\n+    }\n+\n+    /**\n+     * Verifies that the solver allows a path exactly matching the resource limit.\n+     * Expected: The path is valid with a total cost of 5.\n+     */\n+    @Test\n+    public void testExactResourceLimit() {\n+        Graph graph = new Graph(3);\n+        graph.addEdge(0, 1, 2, 3);\n+        graph.addEdge(1, 2, 3, 2);\n+\n+        int maxResource = 5;\n+        ConstrainedShortestPath solver = new ConstrainedShortestPath(graph, maxResource);\n+\n+        assertEquals(5, solver.solve(0, 2));\n+    }\n+\n+    /**\n+     * Tests a disconnected graph where the destination node cannot be reached.\n+     * Expected: The solver should return -1, as the destination is unreachable.\n+     */\n+    @Test\n+    public void testDisconnectedGraph() {\n+        Graph graph = new Graph(4);\n+        graph.addEdge(0, 1, 2, 2);\n+        graph.addEdge(2, 3, 3, 2);\n+\n+        int maxResource = 5;\n+        ConstrainedShortestPath solver = new ConstrainedShortestPath(graph, maxResource);\n+\n+        assertEquals(-1, solver.solve(0, 3));\n+    }\n+\n+    /**\n+     * Tests a graph with cycles to ensure the solver does not fall into infinite loops and correctly calculates costs.\n+     * Expected: The solver should compute the minimal path cost of 6.\n+     */\n+    @Test\n+    public void testGraphWithCycles() {\n+        Graph graph = new Graph(4);\n+        graph.addEdge(0, 1, 2, 1);\n+        graph.addEdge(1, 2, 3, 1);\n+        graph.addEdge(2, 0, 1, 1);\n+        graph.addEdge(1, 3, 4, 2);\n+\n+        int maxResource = 3;\n+        ConstrainedShortestPath solver = new ConstrainedShortestPath(graph, maxResource);\n+\n+        assertEquals(6, solver.solve(0, 3));\n+    }\n+\n+    /**\n+     * Tests the solver's performance and correctness on a large linear graph with 1000 nodes.\n+     * Expected: The solver should efficiently calculate the shortest path with a cost of 999.\n+     */\n+    @Test\n+    public void testLargeGraphPerformance() {\n+        int nodeCount = 1000;\n+        Graph graph = new Graph(nodeCount);\n+        for (int i = 0; i < nodeCount - 1; i++) {\n+            graph.addEdge(i, i + 1, 1, 1);\n+        }\n+\n+        int maxResource = 1000;\n+        ConstrainedShortestPath solver = new ConstrainedShortestPath(graph, maxResource);\n+\n+        assertEquals(999, solver.solve(0, nodeCount - 1));\n+    }\n+\n+    /**\n+     * Tests a graph with isolated nodes to ensure the solver recognizes unreachable destinations.\n+     * Expected: The solver should return -1 for unreachable nodes.\n+     */\n+    @Test\n+    public void testIsolatedNodes() {\n+        Graph graph = new Graph(5);\n+        graph.addEdge(0, 1, 2, 1);\n+        graph.addEdge(1, 2, 3, 1);\n+\n+        int maxResource = 5;\n+        ConstrainedShortestPath solver = new ConstrainedShortestPath(graph, maxResource);\n+\n+        assertEquals(-1, solver.solve(0, 3));\n+    }\n+\n+    /**\n+     * Tests a cyclic large graph with multiple overlapping paths.\n+     * Expected: The solver should calculate the shortest path cost of 5.\n+     */\n+    @Test\n+    public void testCyclicLargeGraph() {\n+        Graph graph = new Graph(10);\n+        for (int i = 0; i < 9; i++) {\n+            graph.addEdge(i, (i + 1) % 10, 1, 1);\n+        }\n+        graph.addEdge(0, 5, 5, 3);\n+\n+        int maxResource = 10;\n+        ConstrainedShortestPath solver = new ConstrainedShortestPath(graph, maxResource);\n+\n+        assertEquals(5, solver.solve(0, 5));\n+    }\n+\n+    /**\n+     * Tests a large complex graph with multiple paths and varying resource constraints.\n+     * Expected: The solver should identify the optimal path with a cost of 19 within the resource limit.\n+     */\n+    @Test\n+    public void testLargeComplexGraph() {\n+        Graph graph = new Graph(10);\n+        graph.addEdge(0, 1, 4, 2);\n+        graph.addEdge(0, 2, 3, 3);\n+        graph.addEdge(1, 3, 2, 1);\n+        graph.addEdge(2, 3, 5, 2);\n+        graph.addEdge(2, 4, 8, 4);\n+        graph.addEdge(3, 5, 7, 3);\n+        graph.addEdge(3, 6, 6, 2);\n+        graph.addEdge(4, 6, 3, 2);\n+        graph.addEdge(5, 7, 1, 1);\n+        graph.addEdge(6, 7, 2, 2);\n+        graph.addEdge(7, 8, 3, 1);\n+        graph.addEdge(8, 9, 2, 1);\n+\n+        int maxResource = 10;\n+        ConstrainedShortestPath solver = new ConstrainedShortestPath(graph, maxResource);\n+\n+        assertEquals(19, solver.solve(0, 9));\n+    }\n+\n+    /**\n+     * Edge case test where the graph has only one node and no edges.\n+     * Expected: The minimal path cost is 0, as the start and destination are the same.\n+     */\n+    @Test\n+    public void testSingleNodeGraph() {\n+        Graph graph = new Graph(1);\n+\n+        int maxResource = 0;\n+        ConstrainedShortestPath solver = new ConstrainedShortestPath(graph, maxResource);\n+\n+        assertEquals(0, solver.solve(0, 0));\n+    }\n+\n+    /**\n+     * Tests a graph with multiple paths but a tight resource constraint.\n+     * Expected: The solver should return -1 if no path can be found within the resource limit.\n+     */\n+    @Test\n+    public void testTightResourceConstraint() {\n+        Graph graph = new Graph(4);\n+        graph.addEdge(0, 1, 3, 4);\n+        graph.addEdge(1, 2, 1, 2);\n+        graph.addEdge(0, 2, 2, 2);\n+\n+        int maxResource = 3;\n+        ConstrainedShortestPath solver = new ConstrainedShortestPath(graph, maxResource);\n+\n+        assertEquals(2, solver.solve(0, 2));\n+    }\n+}",
    "output": {
      "why": "This implementation introduces a new algorithm for solving the Constrained Shortest Path Problem, allowing for efficient pathfinding under resource constraints, which can be essential for applications requiring optimal resource management.",
      "commit_message": "Add Constrained Shortest Path algorithm and unit tests\n- Implemented the `ConstrainedShortestPath` class with methods to solve the shortest path problem considering resource constraints using dynamic programming.\n- Created a `Graph` class to represent graphs as adjacency lists and defined an `Edge` record for graph edges.\n- Added comprehensive unit tests to ensure the correctness of the algorithm with different graph scenarios, including linear, disconnected, cyclic, and resource-constrained cases."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/heaps/GenericHeap.java b/src/main/java/com/thealgorithms/datastructures/heaps/GenericHeap.java\nindex f1772b5b3112..b8a289db60b9 100644\n--- a/src/main/java/com/thealgorithms/datastructures/heaps/GenericHeap.java\n+++ b/src/main/java/com/thealgorithms/datastructures/heaps/GenericHeap.java\n@@ -3,49 +3,83 @@\n import java.util.ArrayList;\n import java.util.HashMap;\n \n+/**\n+ * A generic implementation of a max heap data structure.\n+ *\n+ * @param <T> the type of elements in this heap, must extend Comparable.\n+ */\n public class GenericHeap<T extends Comparable<T>> {\n \n-    ArrayList<T> data = new ArrayList<>();\n-    HashMap<T, Integer> map = new HashMap<>();\n+    private final ArrayList<T> data = new ArrayList<>();\n+    private final HashMap<T, Integer> map = new HashMap<>();\n \n+    /**\n+     * Adds an item to the heap, maintaining the heap property.\n+     *\n+     * @param item the item to be added\n+     */\n     public void add(T item) {\n         if (item == null) {\n             throw new IllegalArgumentException(\"Cannot insert null into the heap.\");\n         }\n \n         this.data.add(item);\n-        map.put(item, this.data.size() - 1); //\n+        map.put(item, this.data.size() - 1);\n         upHeapify(this.data.size() - 1);\n     }\n \n+    /**\n+     * Restores the heap property by moving the item at the given index upwards.\n+     *\n+     * @param ci the index of the current item\n+     */\n     private void upHeapify(int ci) {\n         int pi = (ci - 1) / 2;\n-        if (isLarger(this.data.get(ci), this.data.get(pi)) > 0) {\n+        if (ci > 0 && isLarger(this.data.get(ci), this.data.get(pi)) > 0) {\n             swap(pi, ci);\n             upHeapify(pi);\n         }\n     }\n \n-    public void display() {\n-        System.out.println(this.data);\n-    }\n-\n+    /**\n+     * Returns the number of elements in the heap.\n+     *\n+     * @return the size of the heap\n+     */\n     public int size() {\n         return this.data.size();\n     }\n \n+    /**\n+     * Checks if the heap is empty.\n+     *\n+     * @return true if the heap is empty, false otherwise\n+     */\n     public boolean isEmpty() {\n         return this.size() == 0;\n     }\n \n+    /**\n+     * Removes and returns the maximum item from the heap.\n+     *\n+     * @return the maximum item\n+     */\n     public T remove() {\n+        if (isEmpty()) {\n+            throw new IllegalStateException(\"Heap is empty\");\n+        }\n         this.swap(0, this.size() - 1);\n         T rv = this.data.remove(this.size() - 1);\n-        downHeapify(0);\n         map.remove(rv);\n+        downHeapify(0);\n         return rv;\n     }\n \n+    /**\n+     * Restores the heap property by moving the item at the given index downwards.\n+     *\n+     * @param pi the index of the current item\n+     */\n     private void downHeapify(int pi) {\n         int lci = 2 * pi + 1;\n         int rci = 2 * pi + 2;\n@@ -62,15 +96,35 @@ private void downHeapify(int pi) {\n         }\n     }\n \n+    /**\n+     * Retrieves the maximum item from the heap without removing it.\n+     *\n+     * @return the maximum item\n+     */\n     public T get() {\n-        return this.data.get(0);\n+        if (isEmpty()) {\n+            throw new IllegalStateException(\"Heap is empty\");\n+        }\n+        return this.data.getFirst();\n     }\n \n-    // t has higher property then return +ve\n+    /**\n+     * Compares two items to determine their order.\n+     *\n+     * @param t the first item\n+     * @param o the second item\n+     * @return a positive integer if t is greater than o, negative if t is less, and zero if they are equal\n+     */\n     private int isLarger(T t, T o) {\n         return t.compareTo(o);\n     }\n \n+    /**\n+     * Swaps two items in the heap and updates their indices in the map.\n+     *\n+     * @param i index of the first item\n+     * @param j index of the second item\n+     */\n     private void swap(int i, int j) {\n         T ith = this.data.get(i);\n         T jth = this.data.get(j);\n@@ -80,9 +134,16 @@ private void swap(int i, int j) {\n         map.put(jth, i);\n     }\n \n+    /**\n+     * Updates the priority of the specified item by restoring the heap property.\n+     *\n+     * @param item the item whose priority is to be updated\n+     */\n     public void updatePriority(T item) {\n+        if (!map.containsKey(item)) {\n+            throw new IllegalArgumentException(\"Item not found in the heap\");\n+        }\n         int index = map.get(item);\n-        // because we enter lesser value then old vale\n         upHeapify(index);\n     }\n }\ndiff --git a/src/test/java/com/thealgorithms/datastructures/heaps/GenericHeapTest.java b/src/test/java/com/thealgorithms/datastructures/heaps/GenericHeapTest.java\nindex 8915a6d8aef2..a3642996b769 100644\n--- a/src/test/java/com/thealgorithms/datastructures/heaps/GenericHeapTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/heaps/GenericHeapTest.java\n@@ -13,114 +13,73 @@ public class GenericHeapTest {\n     private GenericHeap<Integer> heap;\n \n     @BeforeEach\n-    public void setUp() {\n+    void setUp() {\n         heap = new GenericHeap<>();\n     }\n \n     @Test\n-    public void testGenericHeapAddAndGet() {\n-        heap.add(19);\n-        heap.add(36);\n-        heap.add(100);\n-        heap.add(-17);\n-        heap.add(3);\n-\n-        // Check that the largest element (100) is at the top of the heap\n-        assertEquals(100, heap.get());\n-    }\n-\n-    @Test\n-    public void testGenericHeapRemove() {\n-        heap.add(19);\n-        heap.add(36);\n-        heap.add(100);\n-        heap.add(-17);\n-        heap.add(3);\n-\n-        // Verify that the largest element is removed correctly\n-        assertEquals(100, heap.remove());\n-\n-        // The new element at the top should be 36\n-        assertEquals(36, heap.get());\n+    void testAddAndGet() {\n+        heap.add(10);\n+        heap.add(20);\n+        heap.add(5);\n \n-        // Check that the size is correct after removal\n-        assertEquals(4, heap.size());\n+        assertEquals(20, heap.get());\n     }\n \n     @Test\n-    public void testGenericHeapSize() {\n-        assertTrue(heap.isEmpty());\n-\n+    void testRemove() {\n         heap.add(10);\n         heap.add(20);\n+        heap.add(5);\n \n-        // Check that the size is correct\n-        assertEquals(2, heap.size());\n-\n-        heap.remove();\n-\n-        // After removal, the size should be 1\n-        assertEquals(1, heap.size());\n+        assertEquals(20, heap.remove());\n+        assertEquals(10, heap.get());\n     }\n \n     @Test\n-    public void testGenericHeapIsEmpty() {\n-        // Verify that the heap is initially empty\n+    void testIsEmpty() {\n         assertTrue(heap.isEmpty());\n-\n-        heap.add(15);\n-\n-        // Now the heap should not be empty\n+        heap.add(1);\n         assertFalse(heap.isEmpty());\n-\n-        heap.remove();\n-\n-        // After removing the one element, it should be empty again\n-        assertTrue(heap.isEmpty());\n     }\n \n     @Test\n-    public void testGenericHeapUpdatePriority() {\n-        heap.add(19);\n-        heap.add(36);\n-        heap.add(100);\n-        heap.add(-17);\n-        heap.add(3);\n-\n-        // Verify that the largest element initially is 100\n-        assertEquals(100, heap.get());\n+    void testSize() {\n+        assertEquals(0, heap.size());\n+        heap.add(1);\n+        heap.add(2);\n+        assertEquals(2, heap.size());\n+    }\n \n-        heap.remove();\n+    @Test\n+    void testUpdatePriority() {\n+        heap.add(10);\n+        heap.add(20);\n+        heap.add(5);\n \n-        // Simulates a change in priority by increasing the value of 100 to 44\n-        heap.add(44);\n+        heap.updatePriority(10);\n+        assertEquals(20, heap.get());\n \n-        // Now, the new high should be 25\n-        assertEquals(44, heap.get());\n+        heap.add(30);\n+        heap.updatePriority(20); // 20 will be moved up\n+        assertEquals(30, heap.get());\n     }\n \n     @Test\n-    public void testGenericHeapRemoveUntilEmpty() {\n-        heap.add(5);\n-        heap.add(3);\n-        heap.add(4);\n-        heap.add(1);\n-        heap.add(2);\n-\n-        // Remove all items and check that they are removed in descending order\n-        assertEquals(5, heap.remove());\n-        assertEquals(4, heap.remove());\n-        assertEquals(3, heap.remove());\n-        assertEquals(2, heap.remove());\n-        assertEquals(1, heap.remove());\n+    void testRemoveFromEmptyHeap() {\n+        Exception exception = assertThrows(IllegalStateException.class, () -> heap.remove());\n+        assertEquals(\"Heap is empty\", exception.getMessage());\n+    }\n \n-        // Empty heap\n-        assertTrue(heap.isEmpty());\n+    @Test\n+    void testGetFromEmptyHeap() {\n+        Exception exception = assertThrows(IllegalStateException.class, () -> heap.get());\n+        assertEquals(\"Heap is empty\", exception.getMessage());\n     }\n \n     @Test\n-    public void testGenericHeapAddNullItem() {\n-        // Check null item\n-        assertThrows(IllegalArgumentException.class, () -> { heap.add(null); });\n+    void testUpdatePriorityForNonExistentItem() {\n+        Exception exception = assertThrows(IllegalArgumentException.class, () -> heap.updatePriority(100));\n+        assertEquals(\"Item not found in the heap\", exception.getMessage());\n     }\n }",
    "output": {
      "why": "The changes were made to enhance code documentation, making the implementation clearer through comprehensive Javadoc comments. Additionally, method visibility was set to default for a more encapsulated approach, which is a common practice for utility classes like heaps. Improved exception handling ensures that the users of the heap class are adequately informed about its state and constraints.",
      "commit_message": "Enhance `GenericHeap` class with Javadoc and exception handling\n- Added detailed Javadoc comments to all methods for better documentation and clarity regarding usage.\n- Changed visibility of some methods to default to encapsulate implementation details.\n- Enhanced exception handling for methods such as `remove`, `get`, and `updatePriority` to provide clearer feedback to users when the heap is empty or when attempting to update a non-existent item."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/conversions/HexaDecimalToDecimal.java b/src/main/java/com/thealgorithms/conversions/HexaDecimalToDecimal.java\nindex 003781da9d5e..2cf6024d90a3 100644\n--- a/src/main/java/com/thealgorithms/conversions/HexaDecimalToDecimal.java\n+++ b/src/main/java/com/thealgorithms/conversions/HexaDecimalToDecimal.java\n@@ -1,39 +1,45 @@\n package com.thealgorithms.conversions;\n \n-import java.util.Scanner;\n-\n+/**\n+ * Utility class for converting a hexadecimal string to its decimal representation.\n+ * <p>\n+ * A hexadecimal number uses the base-16 numeral system, with the following characters:\n+ * <ul>\n+ *   <li>Digits: 0-9</li>\n+ *   <li>Letters: A-F (case-insensitive)</li>\n+ * </ul>\n+ * Each character represents a power of 16. For example:\n+ * <pre>\n+ *   Hexadecimal \"A1\" = 10*16^1 + 1*16^0 = 161 (decimal)\n+ * </pre>\n+ *\n+ * <p>This class provides a method to perform the conversion without using built-in Java utilities.</p>\n+ */\n public final class HexaDecimalToDecimal {\n     private HexaDecimalToDecimal() {\n     }\n \n-    // convert hexadecimal to decimal\n+    /**\n+     * Converts a hexadecimal string to its decimal integer equivalent.\n+     * <p>The input string is case-insensitive, and must contain valid hexadecimal characters [0-9, A-F].</p>\n+     *\n+     * @param hex the hexadecimal string to convert\n+     * @return the decimal integer representation of the input hexadecimal string\n+     * @throws IllegalArgumentException if the input string contains invalid characters\n+     */\n     public static int getHexaToDec(String hex) {\n         String digits = \"0123456789ABCDEF\";\n         hex = hex.toUpperCase();\n         int val = 0;\n+\n         for (int i = 0; i < hex.length(); i++) {\n             int d = digits.indexOf(hex.charAt(i));\n+            if (d == -1) {\n+                throw new IllegalArgumentException(\"Invalid hexadecimal character: \" + hex.charAt(i));\n+            }\n             val = 16 * val + d;\n         }\n-        return val;\n-    }\n \n-    // Main method gets the hexadecimal input from user and converts it into Decimal output.\n-    public static void main(String[] args) {\n-        String hexaInput;\n-        int decOutput;\n-        Scanner scan = new Scanner(System.in);\n-\n-        System.out.print(\"Enter Hexadecimal Number : \");\n-        hexaInput = scan.nextLine();\n-\n-        // convert hexadecimal to decimal\n-        decOutput = getHexaToDec(hexaInput);\n-        /*\n-    Pass the string to the getHexaToDec function\n-    and it returns the decimal form in the variable decOutput.\n-         */\n-        System.out.println(\"Number in Decimal: \" + decOutput);\n-        scan.close();\n+        return val;\n     }\n }\ndiff --git a/src/test/java/com/thealgorithms/conversions/HexaDecimalToDecimalTest.java b/src/test/java/com/thealgorithms/conversions/HexaDecimalToDecimalTest.java\nindex c9c2ab2161ed..d0d6b400e299 100644\n--- a/src/test/java/com/thealgorithms/conversions/HexaDecimalToDecimalTest.java\n+++ b/src/test/java/com/thealgorithms/conversions/HexaDecimalToDecimalTest.java\n@@ -1,14 +1,37 @@\n package com.thealgorithms.conversions;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n \n public class HexaDecimalToDecimalTest {\n \n-    @Test\n-    public void testhexaDecimalToDecimal() {\n-        assertEquals(161, HexaDecimalToDecimal.getHexaToDec(\"A1\"));\n-        assertEquals(428, HexaDecimalToDecimal.getHexaToDec(\"1ac\"));\n+    @ParameterizedTest\n+    @CsvSource({\n+        \"A1, 161\", // Simple case with two characters\n+        \"1AC, 428\", // Mixed-case input\n+        \"0, 0\", // Single zero\n+        \"F, 15\", // Single digit\n+        \"10, 16\", // Power of 16\n+        \"FFFF, 65535\", // Max 4-character hex\n+        \"7FFFFFFF, 2147483647\" // Max positive int value\n+    })\n+    public void\n+    testValidHexaToDecimal(String hexInput, int expectedDecimal) {\n+        assertEquals(expectedDecimal, HexaDecimalToDecimal.getHexaToDec(hexInput));\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+        \"G\", // Invalid character\n+        \"1Z\", // Mixed invalid input\n+        \"123G\", // Valid prefix with invalid character\n+        \"#$%\" // Non-hexadecimal symbols\n+    })\n+    public void\n+    testInvalidHexaToDecimal(String invalidHex) {\n+        assertThrows(IllegalArgumentException.class, () -> HexaDecimalToDecimal.getHexaToDec(invalidHex));\n     }\n }",
    "output": {
      "why": "The updates improve code modularity by removing the main method, enhancing testability through parameterized tests. The additional documentation clarifies the utility and expected behavior of the conversion method, aiding developers in understanding its functionality.",
      "commit_message": "Enhance HexaDecimalToDecimal class with documentation and tests\n- Added detailed JavaDoc comments for the `HexaDecimalToDecimal` class and its method to describe functionality and usage.\n- Removed the main method for cleaner API design and replaced it with a suite of parameterized unit tests to validate various hexadecimal inputs.\n- Introduced input validation for invalid characters to prevent runtime errors, improving robustness of the conversion method."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/bitmanipulation/GenerateSubsets.java b/src/main/java/com/thealgorithms/bitmanipulation/GenerateSubsets.java\nnew file mode 100644\nindex 000000000000..f1b812495c1b\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/bitmanipulation/GenerateSubsets.java\n@@ -0,0 +1,44 @@\n+package com.thealgorithms.bitmanipulation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This class provides a method to generate all subsets (power set)\n+ * of a given set using bit manipulation.\n+ *\n+ * @author Hardvan\n+ */\n+public final class GenerateSubsets {\n+    private GenerateSubsets() {\n+    }\n+\n+    /**\n+     * Generates all subsets of a given set using bit manipulation.\n+     * Steps:\n+     * 1. Iterate over all numbers from 0 to 2^n - 1.\n+     * 2. For each number, iterate over all bits from 0 to n - 1.\n+     * 3. If the i-th bit of the number is set, add the i-th element of the set to the current subset.\n+     * 4. Add the current subset to the list of subsets.\n+     * 5. Return the list of subsets.\n+     *\n+     * @param set the input set of integers\n+     * @return a list of all subsets represented as lists of integers\n+     */\n+    public static List<List<Integer>> generateSubsets(int[] set) {\n+        int n = set.length;\n+        List<List<Integer>> subsets = new ArrayList<>();\n+\n+        for (int mask = 0; mask < (1 << n); mask++) {\n+            List<Integer> subset = new ArrayList<>();\n+            for (int i = 0; i < n; i++) {\n+                if ((mask & (1 << i)) != 0) {\n+                    subset.add(set[i]);\n+                }\n+            }\n+            subsets.add(subset);\n+        }\n+\n+        return subsets;\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/bitmanipulation/GenerateSubsetsTest.java b/src/test/java/com/thealgorithms/bitmanipulation/GenerateSubsetsTest.java\nnew file mode 100644\nindex 000000000000..e3205d1d0dba\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/bitmanipulation/GenerateSubsetsTest.java\n@@ -0,0 +1,52 @@\n+package com.thealgorithms.bitmanipulation;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+\n+class GenerateSubsetsTest {\n+\n+    @Test\n+    void testGenerateSubsetsWithTwoElements() {\n+        int[] set = {1, 2};\n+        List<List<Integer>> expected = new ArrayList<>();\n+        expected.add(new ArrayList<>());\n+        expected.add(Arrays.asList(1));\n+        expected.add(Arrays.asList(2));\n+        expected.add(Arrays.asList(1, 2));\n+\n+        List<List<Integer>> result = GenerateSubsets.generateSubsets(set);\n+        assertEquals(expected, result);\n+    }\n+\n+    @Test\n+    void testGenerateSubsetsWithOneElement() {\n+        int[] set = {3};\n+        List<List<Integer>> expected = new ArrayList<>();\n+        expected.add(new ArrayList<>());\n+        expected.add(Arrays.asList(3));\n+\n+        List<List<Integer>> result = GenerateSubsets.generateSubsets(set);\n+        assertEquals(expected, result);\n+    }\n+\n+    @Test\n+    void testGenerateSubsetsWithThreeElements() {\n+        int[] set = {4, 5, 6};\n+        List<List<Integer>> expected = new ArrayList<>();\n+        expected.add(new ArrayList<>());\n+        expected.add(Arrays.asList(4));\n+        expected.add(Arrays.asList(5));\n+        expected.add(Arrays.asList(4, 5));\n+        expected.add(Arrays.asList(6));\n+        expected.add(Arrays.asList(4, 6));\n+        expected.add(Arrays.asList(5, 6));\n+        expected.add(Arrays.asList(4, 5, 6));\n+\n+        List<List<Integer>> result = GenerateSubsets.generateSubsets(set);\n+        assertEquals(expected, result);\n+    }\n+}",
    "output": {
      "why": "The new `GenerateSubsets` class is implemented to provide functionality for generating all subsets of a given set using bit manipulation, which enhances the capability of the project. Correspondingly, test cases have been added to ensure the correctness of the new functionality. Additionally, the `DIRECTORY.md` file has been updated to include references to these new files for better organization.",
      "commit_message": "Add `GenerateSubsets` class and corresponding test cases\n- Introduced `GenerateSubsets` class to generate all subsets of a given set using bit manipulation techniques.\n- Implemented comprehensive test cases in `GenerateSubsetsTest` to validate the functionality of the new method.\n- Updated `DIRECTORY.md` to include links to newly created files."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/strings/LongestCommonPrefix.java b/src/main/java/com/thealgorithms/strings/LongestCommonPrefix.java\nnew file mode 100644\nindex 000000000000..0fabdaa2658b\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/strings/LongestCommonPrefix.java\n@@ -0,0 +1,22 @@\n+package com.thealgorithms.strings;\n+\n+import java.util.Arrays;\n+\n+public final class LongestCommonPrefix {\n+    public String longestCommonPrefix(String[] strs) {\n+        if (strs == null || strs.length == 0) {\n+            return \"\";\n+        }\n+\n+        Arrays.sort(strs);\n+        String shortest = strs[0];\n+        String longest = strs[strs.length - 1];\n+\n+        int index = 0;\n+        while (index < shortest.length() && index < longest.length() && shortest.charAt(index) == longest.charAt(index)) {\n+            index++;\n+        }\n+\n+        return shortest.substring(0, index);\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/strings/LongestCommonPrefixTest.java b/src/test/java/com/thealgorithms/strings/LongestCommonPrefixTest.java\nnew file mode 100644\nindex 000000000000..580a2726d285\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/strings/LongestCommonPrefixTest.java\n@@ -0,0 +1,73 @@\n+package com.thealgorithms.strings;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class LongestCommonPrefixTest {\n+\n+    private final LongestCommonPrefix longestCommonPrefix = new LongestCommonPrefix();\n+\n+    @Test\n+    public void testCommonPrefix() {\n+        String[] input = {\"flower\", \"flow\", \"flight\"};\n+        String expected = \"fl\";\n+        assertEquals(expected, longestCommonPrefix.longestCommonPrefix(input));\n+    }\n+\n+    @Test\n+    public void testNoCommonPrefix() {\n+        String[] input = {\"dog\", \"racecar\", \"car\"};\n+        String expected = \"\";\n+        assertEquals(expected, longestCommonPrefix.longestCommonPrefix(input));\n+    }\n+\n+    @Test\n+    public void testEmptyArray() {\n+        String[] input = {};\n+        String expected = \"\";\n+        assertEquals(expected, longestCommonPrefix.longestCommonPrefix(input));\n+    }\n+\n+    @Test\n+    public void testNullArray() {\n+        String[] input = null;\n+        String expected = \"\";\n+        assertEquals(expected, longestCommonPrefix.longestCommonPrefix(input));\n+    }\n+\n+    @Test\n+    public void testSingleString() {\n+        String[] input = {\"single\"};\n+        String expected = \"single\";\n+        assertEquals(expected, longestCommonPrefix.longestCommonPrefix(input));\n+    }\n+\n+    @Test\n+    public void testCommonPrefixWithDifferentLengths() {\n+        String[] input = {\"ab\", \"a\"};\n+        String expected = \"a\";\n+        assertEquals(expected, longestCommonPrefix.longestCommonPrefix(input));\n+    }\n+\n+    @Test\n+    public void testAllSameStrings() {\n+        String[] input = {\"test\", \"test\", \"test\"};\n+        String expected = \"test\";\n+        assertEquals(expected, longestCommonPrefix.longestCommonPrefix(input));\n+    }\n+\n+    @Test\n+    public void testPrefixAtEnd() {\n+        String[] input = {\"abcde\", \"abcfgh\", \"abcmnop\"};\n+        String expected = \"abc\";\n+        assertEquals(expected, longestCommonPrefix.longestCommonPrefix(input));\n+    }\n+\n+    @Test\n+    public void testMixedCase() {\n+        String[] input = {\"Flower\", \"flow\", \"flight\"};\n+        String expected = \"\";\n+        assertEquals(expected, longestCommonPrefix.longestCommonPrefix(input));\n+    }\n+}",
    "output": {
      "why": "The `LongestCommonPrefix` method was introduced to provide a solution to find the longest common prefix among an array of strings, and a corresponding test suite was added to ensure its functionality was adequately verified. Updating the `DIRECTORY.md` ensures documentation includes references to these new files.",
      "commit_message": "Add `LongestCommonPrefix` implementation and tests\n- Added `LongestCommonPrefix.java` for calculating the longest common prefix of an array of strings.\n- Created `LongestCommonPrefixTest.java` with multiple test cases to validate the functionality, including edge cases such as empty input and single string inputs.\n- Updated `DIRECTORY.md` to include links to the new implementation and its test suite."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/bitmanipulation/NextHigherSameBitCount.java b/src/main/java/com/thealgorithms/bitmanipulation/NextHigherSameBitCount.java\nnew file mode 100644\nindex 000000000000..6a764d806279\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/bitmanipulation/NextHigherSameBitCount.java\n@@ -0,0 +1,30 @@\n+package com.thealgorithms.bitmanipulation;\n+\n+/**\n+ * This class provides a method to find the next higher number\n+ * with the same number of set bits as the given number.\n+ *\n+ * @author Hardvan\n+ */\n+public final class NextHigherSameBitCount {\n+    private NextHigherSameBitCount() {\n+    }\n+\n+    /**\n+     * Finds the next higher integer with the same number of set bits.\n+     * Steps:\n+     * 1. Find {@code c}, the rightmost set bit of {@code n}.\n+     * 2. Find {@code r}, the rightmost set bit of {@code n + c}.\n+     * 3. Swap the bits of {@code r} and {@code n} to the right of {@code c}.\n+     * 4. Shift the bits of {@code r} and {@code n} to the right of {@code c} to the rightmost.\n+     * 5. Combine the results of steps 3 and 4.\n+     *\n+     * @param n the input number\n+     * @return the next higher integer with the same set bit count\n+     */\n+    public static int nextHigherSameBitCount(int n) {\n+        int c = n & -n;\n+        int r = n + c;\n+        return (((r ^ n) >> 2) / c) | r;\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/bitmanipulation/NextHigherSameBitCountTest.java b/src/test/java/com/thealgorithms/bitmanipulation/NextHigherSameBitCountTest.java\nnew file mode 100644\nindex 000000000000..c8fb9ef21b60\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/bitmanipulation/NextHigherSameBitCountTest.java\n@@ -0,0 +1,22 @@\n+package com.thealgorithms.bitmanipulation;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+class NextHigherSameBitCountTest {\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+        \"5, 6\", // 101 -> 110\n+        \"7, 11\", // 0111 -> 1011\n+        \"3, 5\", // 011 -> 101\n+        \"12, 17\", // 001100 -> 010001\n+        \"15, 23\" // 01111 -> 10111\n+    })\n+    void\n+    testNextHigherSameBitCount(int input, int expected) {\n+        assertEquals(expected, NextHigherSameBitCount.nextHigherSameBitCount(input));\n+    }\n+}",
    "output": {
      "why": "The `NextHigherSameBitCount` class was added to provide a method for finding the next higher number with the same number of set bits, increasing the functionality of bit manipulation algorithms. The corresponding test ensures its correctness, and updates to `DIRECTORY.md` allow users to easily find and reference the new class and test.",
      "commit_message": "Add `NextHigherSameBitCount` class and its test\n- Introduced the `NextHigherSameBitCount` class, which implements a method to find the next higher integer with the same number of set bits.\n- Created a parameterized test for `NextHigherSameBitCount` to validate functionality across multiple test cases.\n- Updated `DIRECTORY.md` to include links to the new class and its test for easier navigation."
    }
  },
  {
    "input": "diff --git a/src/test/java/com/thealgorithms/dynamicprogramming/EditDistanceTest.java b/src/test/java/com/thealgorithms/dynamicprogramming/EditDistanceTest.java\nindex 267be9b056de..737e8d1d0918 100644\n--- a/src/test/java/com/thealgorithms/dynamicprogramming/EditDistanceTest.java\n+++ b/src/test/java/com/thealgorithms/dynamicprogramming/EditDistanceTest.java\n@@ -1,7 +1,9 @@\n package com.thealgorithms.dynamicprogramming;\n \n+import static org.junit.jupiter.api.Assertions.assertAll;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n+import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.CsvSource;\n \n@@ -12,4 +14,91 @@ public class EditDistanceTest {\n     void testMinDistance(String str1, String str2, int expected) {\n         assertEquals(expected, EditDistance.minDistance(str1, str2));\n     }\n+\n+    @Test\n+    public void testEditDistanceBothEmptyStrings() {\n+        assertEquals(0, EditDistance.editDistance(\"\", \"\"));\n+    }\n+\n+    @Test\n+    public void testEditDistanceOneEmptyString() {\n+        assertEquals(5, EditDistance.editDistance(\"\", \"hello\"));\n+        assertEquals(7, EditDistance.editDistance(\"worldly\", \"\"));\n+    }\n+\n+    @Test\n+    public void testEditDistanceOneEmptyStringMemoization() {\n+        int[][] storage = new int[1][6];\n+        assertAll(\"String assertions\",\n+            ()\n+                -> assertEquals(5, EditDistance.editDistance(\"\", \"hello\", storage)),\n+            () -> assertEquals(0, storage[0][0]), () -> assertEquals(0, storage[0][1]), () -> assertEquals(0, storage[0][2]), () -> assertEquals(0, storage[0][3]), () -> assertEquals(0, storage[0][4]), () -> assertEquals(5, storage[0][5]));\n+    }\n+\n+    @Test\n+    public void testEditDistanceEqualStrings() {\n+        assertEquals(0, EditDistance.editDistance(\"test\", \"test\"));\n+        assertEquals(0, EditDistance.editDistance(\"abc\", \"abc\"));\n+    }\n+\n+    @Test\n+    public void testEditDistanceEqualStringsMemoization() {\n+        int[][] storage = new int[4][4];\n+        assertAll(\"String assertions\",\n+            ()\n+                -> assertEquals(0, EditDistance.editDistance(\"abc\", \"abc\", storage)),\n+            ()\n+                -> assertEquals(0, storage[0][0]),\n+            ()\n+                -> assertEquals(0, storage[0][1]),\n+            ()\n+                -> assertEquals(0, storage[0][2]),\n+            ()\n+                -> assertEquals(0, storage[0][3]),\n+            ()\n+                -> assertEquals(0, storage[1][0]),\n+            ()\n+                -> assertEquals(0, storage[1][1]),\n+            ()\n+                -> assertEquals(0, storage[1][2]),\n+            ()\n+                -> assertEquals(0, storage[1][3]),\n+            ()\n+                -> assertEquals(0, storage[2][0]),\n+            () -> assertEquals(0, storage[2][1]), () -> assertEquals(0, storage[2][2]), () -> assertEquals(0, storage[2][3]), () -> assertEquals(0, storage[3][0]), () -> assertEquals(0, storage[3][1]), () -> assertEquals(0, storage[3][2]), () -> assertEquals(0, storage[3][3]));\n+    }\n+\n+    @Test\n+    public void testEditDistanceOneCharacterDifference() {\n+        assertEquals(1, EditDistance.editDistance(\"cat\", \"bat\"));\n+        assertEquals(1, EditDistance.editDistance(\"cat\", \"cats\"));\n+        assertEquals(1, EditDistance.editDistance(\"cats\", \"cat\"));\n+    }\n+\n+    @Test\n+    public void testEditDistanceOneCharacterDifferenceMemoization() {\n+        int[][] storage = new int[3][3];\n+        assertAll(\"All assertions\",\n+            ()\n+                -> assertEquals(1, EditDistance.editDistance(\"at\", \"it\", storage)),\n+            ()\n+                -> assertEquals(0, storage[0][0]),\n+            ()\n+                -> assertEquals(1, storage[0][1]),\n+            () -> assertEquals(2, storage[0][2]), () -> assertEquals(1, storage[1][0]), () -> assertEquals(0, storage[1][1]), () -> assertEquals(1, storage[1][2]), () -> assertEquals(2, storage[2][0]), () -> assertEquals(1, storage[2][1]), () -> assertEquals(1, storage[2][2]));\n+    }\n+\n+    @Test\n+    public void testEditDistanceGeneralCases() {\n+        assertEquals(3, EditDistance.editDistance(\"kitten\", \"sitting\"));\n+        assertEquals(2, EditDistance.editDistance(\"flaw\", \"lawn\"));\n+        assertEquals(5, EditDistance.editDistance(\"intention\", \"execution\"));\n+    }\n+\n+    @Test\n+    public void testEditDistanceGeneralCasesMemoization() {\n+        int[][] storage = new int[7][8];\n+        assertEquals(3, EditDistance.editDistance(\"kitten\", \"sitting\", storage));\n+        assertAll(\"All assertions\", () -> assertEquals(0, storage[0][0]), () -> assertEquals(3, storage[6][7]));\n+    }\n }",
    "output": {
      "why": "The changes were made to enhance the test coverage for the `EditDistance` class. By adding various test cases, including edge cases, the goal is to ensure that the implementation is robust and handles different input scenarios correctly.",
      "commit_message": "Add comprehensive JUnit tests for `EditDistance`\n- Introduced multiple test cases to cover edge conditions such as:\n- Both strings being empty.\n- One string being empty.\n- Equal strings comparisons.\n- Scenarios with one character difference.\n- General cases with varying string lengths.\n- Included tests for memoization to verify that intermediate results are correctly stored and reused during calculations."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/Average.java b/src/main/java/com/thealgorithms/maths/Average.java\nindex 6b9c20162da1..a550a7f6504d 100644\n--- a/src/main/java/com/thealgorithms/maths/Average.java\n+++ b/src/main/java/com/thealgorithms/maths/Average.java\n@@ -37,7 +37,7 @@ public static double average(double[] numbers) {\n      * @return the average of the given numbers\n      * @throws IllegalArgumentException if the input array is {@code null} or empty\n      */\n-    public static double average(int[] numbers) {\n+    public static long average(int[] numbers) {\n         if (numbers == null || numbers.length == 0) {\n             throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n         }\n@@ -45,6 +45,6 @@ public static double average(int[] numbers) {\n         for (int number : numbers) {\n             sum += number;\n         }\n-        return (double) (sum / numbers.length);\n+        return sum / numbers.length;\n     }\n }\ndiff --git a/src/main/java/com/thealgorithms/others/KochSnowflake.java b/src/main/java/com/thealgorithms/others/KochSnowflake.java\nindex 46b8edb1f177..10986aabec4f 100644\n--- a/src/main/java/com/thealgorithms/others/KochSnowflake.java\n+++ b/src/main/java/com/thealgorithms/others/KochSnowflake.java\n@@ -105,7 +105,7 @@ public static BufferedImage getKochSnowflake(int imageWidth, int steps) {\n         double offsetX = imageWidth / 10.;\n         double offsetY = imageWidth / 3.7;\n         Vector2 vector1 = new Vector2(offsetX, offsetY);\n-        Vector2 vector2 = new Vector2(imageWidth / 2, Math.sin(Math.PI / 3) * imageWidth * 0.8 + offsetY);\n+        Vector2 vector2 = new Vector2(imageWidth / 2.0, Math.sin(Math.PI / 3.0) * imageWidth * 0.8 + offsetY);\n         Vector2 vector3 = new Vector2(imageWidth - offsetX, offsetY);\n         ArrayList<Vector2> initialVectors = new ArrayList<Vector2>();\n         initialVectors.add(vector1);",
    "output": {
      "why": "The exclusion of the `ICAST_IDIV_CAST_TO_DOUBLE` bug pattern from SpotBugs likely addresses a false positive or is deemed unnecessary. Changing the return type of the `average` method in `Average.java` from `double` to `long` indicates a decision to provide integer results, improving performance and usability with integer arrays. The adjustments in `KochSnowflake.java`, particularly ensuring proper floating-point divisions by using `.0`, enhance precision in calculations.",
      "commit_message": "Refactor Average and KochSnowflake classes; update SpotBugs configuration\n- Removed exclusion for bug pattern `ICAST_IDIV_CAST_TO_DOUBLE` from SpotBugs.\n- Changed the return type of the `average` method from `double` to `long` in `Average.java` for better performance with integer inputs.\n- Modified floating-point literal definitions in `KochSnowflake.java` to ensure accurate calculations."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/strings/Upper.java b/src/main/java/com/thealgorithms/strings/Upper.java\nindex fa9a408416ea..5e248cb6ee39 100644\n--- a/src/main/java/com/thealgorithms/strings/Upper.java\n+++ b/src/main/java/com/thealgorithms/strings/Upper.java\n@@ -21,15 +21,19 @@ public static void main(String[] args) {\n      * @return the {@code String}, converted to uppercase.\n      */\n     public static String toUpperCase(String s) {\n-        if (s == null || s.isEmpty()) {\n+        if (s == null) {\n+            throw new IllegalArgumentException(\"Input string connot be null\");\n+        }\n+        if (s.isEmpty()) {\n             return s;\n         }\n-        char[] values = s.toCharArray();\n-        for (int i = 0; i < values.length; ++i) {\n-            if (Character.isLetter(values[i]) && Character.isLowerCase(values[i])) {\n-                values[i] = Character.toUpperCase(values[i]);\n+        StringBuilder result = new StringBuilder(s);\n+        for (int i = 0; i < result.length(); ++i) {\n+            char currentChar = result.charAt(i);\n+            if (Character.isLetter(currentChar) && Character.isLowerCase(currentChar)) {\n+                result.setCharAt(i, Character.toUpperCase(currentChar));\n             }\n         }\n-        return new String(values);\n+        return result.toString();\n     }\n }",
    "output": {
      "why": "The modifications enhance the `toUpperCase` method by checking for null input, providing clearer error feedback, and utilizing `StringBuilder` for improved performance in string manipulation.",
      "commit_message": "Enhance `toUpperCase` method with better error handling\n- Added a null check that throws an `IllegalArgumentException` if the input string is null, improving reliability.\n- Changed how the method processes the string by using `StringBuilder`, optimizing performance during character manipulation.\n- Retained functionality for empty strings, returning them directly without converting."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/graphs/MatrixGraphs.java b/src/main/java/com/thealgorithms/datastructures/graphs/MatrixGraphs.java\nindex 902553f9a54c..c1d47df457da 100644\n--- a/src/main/java/com/thealgorithms/datastructures/graphs/MatrixGraphs.java\n+++ b/src/main/java/com/thealgorithms/datastructures/graphs/MatrixGraphs.java\n@@ -102,7 +102,7 @@ public int numberOfVertices() {\n     /**\n      * Updates the number of edges in the graph\n      *\n-     * @param newNumberOfEdges\n+     * @param newNumberOfEdges the new number of edges\n      *\n      */\n     private void setNumberOfEdges(int newNumberOfEdges) {\n@@ -202,7 +202,7 @@ public boolean addEdge(int from, int to) {\n      * exists and is removed\n      */\n     public boolean removeEdge(int from, int to) {\n-        if (!this.vertexDoesExist(from) || !this.vertexDoesExist(to)) {\n+        if (this.vertexDoesExist(from) && this.vertexDoesExist(to)) {\n             if (this.adjacencyOfEdgeDoesExist(from, to)) {\n                 this.adjacency()[from][to] = AdjacencyMatrixGraph.EDGE_NONE;\n                 this.adjacency()[to][from] = AdjacencyMatrixGraph.EDGE_NONE;\n@@ -223,14 +223,14 @@ public boolean removeEdge(int from, int to) {\n     public List<Integer> depthFirstOrder(int startVertex) {\n         // If the startVertex is invalid, return an empty list\n         if (startVertex >= vertexCount || startVertex < 0) {\n-            return new ArrayList<Integer>();\n+            return new ArrayList<>();\n         }\n \n         // Create an array to track the visited vertices\n         boolean[] visited = new boolean[vertexCount];\n \n         // Create a list to keep track of the order of our traversal\n-        ArrayList<Integer> orderList = new ArrayList<Integer>();\n+        ArrayList<Integer> orderList = new ArrayList<>();\n \n         // Perform our DFS algorithm\n         depthFirstOrder(startVertex, visited, orderList);\n@@ -278,18 +278,18 @@ private void depthFirstOrder(int currentVertex, boolean[] visited, List<Integer>\n     public List<Integer> breadthFirstOrder(int startVertex) {\n         // If the specified startVertex is invalid, return an empty list\n         if (startVertex >= vertexCount || startVertex < 0) {\n-            return new ArrayList<Integer>();\n+            return new ArrayList<>();\n         }\n \n         // Create an array to keep track of the visited vertices\n         boolean[] visited = new boolean[vertexCount];\n \n         // Create a list to keep track of the ordered vertices\n-        ArrayList<Integer> orderList = new ArrayList<Integer>();\n+        ArrayList<Integer> orderList = new ArrayList<>();\n \n         // Create a queue for our BFS algorithm and add the startVertex\n         // to the queue\n-        Queue<Integer> queue = new LinkedList<Integer>();\n+        Queue<Integer> queue = new LinkedList<>();\n         queue.add(startVertex);\n \n         // Continue until the queue is empty\n@@ -327,19 +327,19 @@ public List<Integer> breadthFirstOrder(int startVertex) {\n      * @return returns a string describing this graph\n      */\n     public String toString() {\n-        String s = \"    \";\n+        StringBuilder s = new StringBuilder(\"    \");\n         for (int i = 0; i < this.numberOfVertices(); i++) {\n-            s = s + i + \" \";\n+            s.append(i).append(\" \");\n         }\n-        s = s + \" \\n\";\n+        s.append(\" \\n\");\n \n         for (int i = 0; i < this.numberOfVertices(); i++) {\n-            s = s + i + \" : \";\n+            s.append(i).append(\" : \");\n             for (int j = 0; j < this.numberOfVertices(); j++) {\n-                s = s + this.adjMatrix[i][j] + \" \";\n+                s.append(this.adjMatrix[i][j]).append(\" \");\n             }\n-            s = s + \"\\n\";\n+            s.append(\"\\n\");\n         }\n-        return s;\n+        return s.toString();\n     }\n }\ndiff --git a/src/test/java/com/thealgorithms/datastructures/graphs/MatrixGraphsTest.java b/src/test/java/com/thealgorithms/datastructures/graphs/MatrixGraphsTest.java\nnew file mode 100644\nindex 000000000000..cc8a2df872ce\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/datastructures/graphs/MatrixGraphsTest.java\n@@ -0,0 +1,140 @@\n+package com.thealgorithms.datastructures.graphs;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+\n+class MatrixGraphsTest {\n+\n+    @Test\n+    void testGraphConstruction() {\n+        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(5);\n+        assertEquals(5, graph.numberOfVertices());\n+        assertEquals(0, graph.numberOfEdges());\n+    }\n+\n+    @Test\n+    void testAddEdge() {\n+        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(5);\n+        assertTrue(graph.addEdge(0, 1));\n+        assertTrue(graph.edgeDoesExist(0, 1));\n+        assertTrue(graph.edgeDoesExist(1, 0));\n+        assertEquals(1, graph.numberOfEdges());\n+\n+        // Adding the same edge again should return false\n+        assertFalse(graph.addEdge(0, 1));\n+        assertFalse(graph.addEdge(5, 1));\n+        assertFalse(graph.addEdge(-1, 1));\n+    }\n+\n+    @Test\n+    void testRemoveEdge() {\n+        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(5);\n+        graph.addEdge(0, 1);\n+        graph.addEdge(1, 2);\n+\n+        assertTrue(graph.removeEdge(0, 1));\n+        assertFalse(graph.edgeDoesExist(0, 1));\n+        assertFalse(graph.edgeDoesExist(1, 0));\n+        assertEquals(1, graph.numberOfEdges());\n+\n+        assertFalse(graph.removeEdge(0, 3));\n+        assertFalse(graph.removeEdge(5, 1));\n+        assertFalse(graph.removeEdge(-1, 1));\n+    }\n+\n+    @Test\n+    void testVertexDoesExist() {\n+        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(5);\n+        assertTrue(graph.vertexDoesExist(0));\n+        assertTrue(graph.vertexDoesExist(4));\n+        assertFalse(graph.vertexDoesExist(5));\n+        assertFalse(graph.vertexDoesExist(-1));\n+    }\n+\n+    @Test\n+    void testDepthFirstOrder() {\n+        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(5);\n+        graph.addEdge(0, 1);\n+        graph.addEdge(0, 2);\n+        graph.addEdge(1, 3);\n+        graph.addEdge(2, 4);\n+\n+        List<Integer> dfs = graph.depthFirstOrder(0);\n+        assertEquals(5, dfs.size());\n+        assertEquals(0, dfs.getFirst());\n+\n+        assertTrue(dfs.containsAll(Arrays.asList(0, 1, 2, 3, 4)));\n+\n+        List<Integer> emptyDfs = graph.depthFirstOrder(5);\n+        assertTrue(emptyDfs.isEmpty());\n+    }\n+\n+    @Test\n+    void testBreadthFirstOrder() {\n+        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(5);\n+        graph.addEdge(0, 1);\n+        graph.addEdge(0, 2);\n+        graph.addEdge(1, 3);\n+        graph.addEdge(2, 4);\n+\n+        List<Integer> bfs = graph.breadthFirstOrder(0);\n+        assertEquals(5, bfs.size());\n+        assertEquals(0, bfs.getFirst());\n+\n+        assertTrue(bfs.containsAll(Arrays.asList(0, 1, 2, 3, 4)));\n+\n+        List<Integer> emptyBfs = graph.breadthFirstOrder(5);\n+        assertTrue(emptyBfs.isEmpty());\n+    }\n+\n+    @Test\n+    void testToString() {\n+        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(3);\n+        graph.addEdge(0, 1);\n+        graph.addEdge(1, 2);\n+\n+        String expected = \"    0 1 2  \\n\"\n+            + \"0 : 0 1 0 \\n\"\n+            + \"1 : 1 0 1 \\n\"\n+            + \"2 : 0 1 0 \\n\";\n+\n+        assertEquals(expected, graph.toString());\n+    }\n+\n+    @Test\n+    void testCyclicGraph() {\n+        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(4);\n+        graph.addEdge(0, 1);\n+        graph.addEdge(1, 2);\n+        graph.addEdge(2, 3);\n+        graph.addEdge(3, 0);\n+\n+        List<Integer> dfs = graph.depthFirstOrder(0);\n+        List<Integer> bfs = graph.breadthFirstOrder(0);\n+\n+        assertEquals(4, dfs.size());\n+        assertEquals(4, bfs.size());\n+        assertTrue(dfs.containsAll(Arrays.asList(0, 1, 2, 3)));\n+        assertTrue(bfs.containsAll(Arrays.asList(0, 1, 2, 3)));\n+    }\n+\n+    @Test\n+    void testDisconnectedGraph() {\n+        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(5);\n+        graph.addEdge(0, 1);\n+        graph.addEdge(2, 3);\n+\n+        List<Integer> dfs = graph.depthFirstOrder(0);\n+        List<Integer> bfs = graph.breadthFirstOrder(0);\n+\n+        assertEquals(2, dfs.size());\n+        assertEquals(2, bfs.size());\n+        assertTrue(dfs.containsAll(Arrays.asList(0, 1)));\n+        assertTrue(bfs.containsAll(Arrays.asList(0, 1)));\n+    }\n+}",
    "output": {
      "why": "The changes were likely made to improve code clarity, maintain best practices in Java (like using the diamond operator), enhance the logic of `removeEdge` method, and add a new test suite to ensure functionality of `MatrixGraphs`.",
      "commit_message": "Add unit tests for `MatrixGraphs` and improve code clarity\n- Introduced `MatrixGraphsTest` class to implement unit tests for the `MatrixGraphs` functionality, including edge addition, removal, and traversal methods.\n- Enhanced comments for method parameters to improve understanding.\n- Improved logic in the `removeEdge` method to correctly handle non-existing vertices.\n- Replaced verbose list initializations with the diamond operator for better type inference.\n- Refined the `toString` method to use a `StringBuilder` for efficient string concatenation."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/ciphers/ADFGVXCipher.java b/src/main/java/com/thealgorithms/ciphers/ADFGVXCipher.java\nindex 3e62d6a26dcb..d915858f9e6f 100644\n--- a/src/main/java/com/thealgorithms/ciphers/ADFGVXCipher.java\n+++ b/src/main/java/com/thealgorithms/ciphers/ADFGVXCipher.java\n@@ -3,23 +3,38 @@\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n+\n /**\n- * The ADFGVX cipher is a historically significant cipher used by\n- * the German Army during World War I. It is a fractionating transposition\n- * cipher that combines a Polybius square substitution with a columnar\n- * transposition. It's named after the six letters (A, D, F, G, V, X)\n- * that it uses in its substitution process.\n- * https://en.wikipedia.org/wiki/ADFGVX_cipher\n+ * The ADFGVX cipher is a fractionating transposition cipher that was used by\n+ * the German Army during World War I. It combines a **Polybius square substitution**\n+ * with a **columnar transposition** to enhance encryption strength.\n+ * <p>\n+ * The name \"ADFGVX\" refers to the six letters (A, D, F, G, V, X) used as row and\n+ * column labels in the Polybius square. This cipher was designed to secure\n+ * communication and create complex, hard-to-break ciphertexts.\n+ * <p>\n+ * Learn more: <a href=\"https://en.wikipedia.org/wiki/ADFGVX_cipher\">ADFGVX Cipher - Wikipedia</a>.\n+ * <p>\n+ * Example usage:\n+ * <pre>\n+ * ADFGVXCipher cipher = new ADFGVXCipher();\n+ * String encrypted = cipher.encrypt(\"attack at 1200am\", \"PRIVACY\");\n+ * String decrypted = cipher.decrypt(encrypted, \"PRIVACY\");\n+ * </pre>\n  *\n  * @author bennybebo\n  */\n public class ADFGVXCipher {\n \n+    // Constants used in the Polybius square\n     private static final char[] POLYBIUS_LETTERS = {'A', 'D', 'F', 'G', 'V', 'X'};\n     private static final char[][] POLYBIUS_SQUARE = {{'N', 'A', '1', 'C', '3', 'H'}, {'8', 'T', 'B', '2', 'O', 'M'}, {'E', '5', 'W', 'R', 'P', 'D'}, {'4', 'F', '6', 'G', '7', 'I'}, {'9', 'J', '0', 'K', 'L', 'Q'}, {'S', 'U', 'V', 'X', 'Y', 'Z'}};\n+\n+    // Maps for fast substitution lookups\n     private static final Map<String, Character> POLYBIUS_MAP = new HashMap<>();\n     private static final Map<Character, String> REVERSE_POLYBIUS_MAP = new HashMap<>();\n \n+    // Static block to initialize the lookup tables from the Polybius square\n     static {\n         for (int i = 0; i < POLYBIUS_SQUARE.length; i++) {\n             for (int j = 0; j < POLYBIUS_SQUARE[i].length; j++) {\n@@ -30,26 +45,41 @@ public class ADFGVXCipher {\n         }\n     }\n \n-    // Encrypts the plaintext using the ADFGVX cipher\n+    /**\n+     * Encrypts a given plaintext using the ADFGVX cipher with the provided keyword.\n+     * Steps:\n+     * 1. Substitute each letter in the plaintext with a pair of ADFGVX letters.\n+     * 2. Perform a columnar transposition on the fractionated text using the keyword.\n+     *\n+     * @param plaintext The message to be encrypted (can contain letters and digits).\n+     * @param key       The keyword for columnar transposition.\n+     * @return The encrypted message as ciphertext.\n+     */\n     public String encrypt(String plaintext, String key) {\n-        plaintext = plaintext.toUpperCase().replaceAll(\"[^A-Z0-9]\", \"\");\n+        plaintext = plaintext.toUpperCase().replaceAll(\"[^A-Z0-9]\", \"\"); // Sanitize input\n         StringBuilder fractionatedText = new StringBuilder();\n \n-        // Step 1: Polybius square substitution\n         for (char c : plaintext.toCharArray()) {\n             fractionatedText.append(REVERSE_POLYBIUS_MAP.get(c));\n         }\n \n-        // Step 2: Columnar transposition\n         return columnarTransposition(fractionatedText.toString(), key);\n     }\n \n-    // Decrypts the ciphertext using the ADFGVX cipher\n+    /**\n+     * Decrypts a given ciphertext using the ADFGVX cipher with the provided keyword.\n+     * Steps:\n+     * 1. Reverse the columnar transposition performed during encryption.\n+     * 2. Substitute each pair of ADFGVX letters with the corresponding plaintext letter.\n+     * The resulting text is the decrypted message.\n+     *\n+     * @param ciphertext The encrypted message.\n+     * @param key        The keyword used during encryption.\n+     * @return The decrypted plaintext message.\n+     */\n     public String decrypt(String ciphertext, String key) {\n-        // Step 1: Reverse the columnar transposition\n         String fractionatedText = reverseColumnarTransposition(ciphertext, key);\n \n-        // Step 2: Polybius square substitution\n         StringBuilder plaintext = new StringBuilder();\n         for (int i = 0; i < fractionatedText.length(); i += 2) {\n             String pair = fractionatedText.substring(i, i + 2);\n@@ -59,14 +89,21 @@ public String decrypt(String ciphertext, String key) {\n         return plaintext.toString();\n     }\n \n+    /**\n+     * Helper method: Performs columnar transposition during encryption\n+     *\n+     * @param text The fractionated text to be transposed\n+     * @param key  The keyword for columnar transposition\n+     * @return The transposed text\n+     */\n     private String columnarTransposition(String text, String key) {\n         int numRows = (int) Math.ceil((double) text.length() / key.length());\n         char[][] table = new char[numRows][key.length()];\n-        for (char[] row : table) {\n-            Arrays.fill(row, '_'); // Fill with underscores to handle empty cells\n+        for (char[] row : table) { // Fill empty cells with underscores\n+            Arrays.fill(row, '_');\n         }\n \n-        // Fill the table row by row\n+        // Populate the table row by row\n         for (int i = 0; i < text.length(); i++) {\n             table[i / key.length()][i % key.length()] = text.charAt(i);\n         }\n@@ -88,6 +125,13 @@ private String columnarTransposition(String text, String key) {\n         return ciphertext.toString();\n     }\n \n+    /**\n+     * Helper method: Reverses the columnar transposition during decryption\n+     *\n+     * @param ciphertext The transposed text to be reversed\n+     * @param key        The keyword used during encryption\n+     * @return The reversed text\n+     */\n     private String reverseColumnarTransposition(String ciphertext, String key) {\n         int numRows = (int) Math.ceil((double) ciphertext.length() / key.length());\n         char[][] table = new char[numRows][key.length()];\n@@ -96,19 +140,19 @@ private String reverseColumnarTransposition(String ciphertext, String key) {\n         Arrays.sort(sortedKey);\n \n         int index = 0;\n-        // Fill the table column by column according to the sorted key order\n+        // Populate the table column by column according to the sorted key\n         for (char keyChar : sortedKey) {\n             int column = key.indexOf(keyChar);\n             for (int row = 0; row < numRows; row++) {\n                 if (index < ciphertext.length()) {\n                     table[row][column] = ciphertext.charAt(index++);\n                 } else {\n-                    table[row][column] = '_'; // Fill empty cells with an underscore\n+                    table[row][column] = '_';\n                 }\n             }\n         }\n \n-        // Read the table row by row to get the fractionated text\n+        // Read the table row by row to reconstruct the fractionated text\n         StringBuilder fractionatedText = new StringBuilder();\n         for (char[] row : table) {\n             for (char cell : row) {\ndiff --git a/src/test/java/com/thealgorithms/ciphers/ADFGVXCipherTest.java b/src/test/java/com/thealgorithms/ciphers/ADFGVXCipherTest.java\nindex a1fc4fd9ebe5..4db856e40b84 100644\n--- a/src/test/java/com/thealgorithms/ciphers/ADFGVXCipherTest.java\n+++ b/src/test/java/com/thealgorithms/ciphers/ADFGVXCipherTest.java\n@@ -6,31 +6,41 @@\n \n class ADFGVXCipherTest {\n \n-    ADFGVXCipher adfgvxCipher = new ADFGVXCipher();\n+    private final ADFGVXCipher adfgvxCipher = new ADFGVXCipher();\n \n     @Test\n-    void adfgvxCipherEncryptTest() {\n-        // given\n-        String message = \"attack at 1200am\"; // Plaintext message\n-        String keyword = \"PRIVACY\";\n+    void testEncrypt() {\n+        String message = \"attack at 1200am\";\n+        String key = \"PRIVACY\";\n \n-        // when\n-        String cipherText = adfgvxCipher.encrypt(message, keyword);\n+        String encrypted = adfgvxCipher.encrypt(message, key);\n+        assertEquals(\"DGDDDAGDDGAFADDFDADVDVFAADVX\", encrypted);\n+    }\n+\n+    @Test\n+    void testDecrypt() {\n+        String encrypted = \"DGDDDAGDDGAFADDFDADVDVFAADVX\";\n+        String key = \"PRIVACY\";\n \n-        // then\n-        assertEquals(\"DGDDDAGDDGAFADDFDADVDVFAADVX\", cipherText);\n+        String decrypted = adfgvxCipher.decrypt(encrypted, key);\n+        assertEquals(\"ATTACKAT1200AM\", decrypted);\n     }\n \n     @Test\n-    void adfgvxCipherDecryptTest() {\n-        // given\n-        String cipherText = \"DGDDDAGDDGAFADDFDADVDVFAADVX\"; // Ciphertext message\n-        String keyword = \"PRIVACY\";\n+    void testEmptyInput() {\n+        String encrypted = adfgvxCipher.encrypt(\"\", \"PRIVACY\");\n+        String decrypted = adfgvxCipher.decrypt(\"\", \"PRIVACY\");\n+        assertEquals(\"\", encrypted);\n+        assertEquals(\"\", decrypted);\n+    }\n \n-        // when\n-        String plainText = adfgvxCipher.decrypt(cipherText, keyword);\n+    @Test\n+    void testShortKey() {\n+        String message = \"TESTING\";\n+        String key = \"A\";\n \n-        // then\n-        assertEquals(\"ATTACKAT1200AM\", plainText);\n+        String encrypted = adfgvxCipher.encrypt(message, key);\n+        String decrypted = adfgvxCipher.decrypt(encrypted, key);\n+        assertEquals(\"TESTING\", decrypted);\n     }\n }",
    "output": {
      "why": "Clarifying the functionality of the ADFGVX cipher was essential for future maintainers and users. Improving documentation and adding examples aids in understanding how to use the class effectively. The unit tests were updated to cover various scenarios, ensuring better coverage and validation of the cipher methods.",
      "commit_message": "Enhance documentation and unit tests for ADFGVX cipher\n- Improved Javadoc comments for both encrypt and decrypt methods.\n- Added example usage in class-level documentation for better clarity.\n- Renamed test methods for consistency and clarity.\n- Expanded unit tests to include cases for empty input and short keys, ensuring comprehensive coverage of the methods."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/misc/ShuffleArray.java b/src/main/java/com/thealgorithms/misc/ShuffleArray.java\nnew file mode 100644\nindex 000000000000..65d38adfc37a\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/misc/ShuffleArray.java\n@@ -0,0 +1,38 @@\n+package com.thealgorithms.misc;\n+\n+import java.util.Random;\n+\n+/**\n+ * The Fisher-Yates (Knuth) Shuffle algorithm randomly permutes an array's\n+ * elements, ensuring each permutation is equally likely.\n+ *\n+ * <p>\n+ * Worst-case performance O(n)\n+ * Best-case performance O(n)\n+ * Average performance O(n)\n+ * Worst-case space complexity O(1)\n+ *\n+ * This class provides a static method to shuffle an array in place.\n+ *\n+ * @author Rashi Dashore (https://github.com/rashi07dashore)\n+ */\n+public final class ShuffleArray {\n+    // Prevent instantiation\n+    private ShuffleArray() {\n+    }\n+\n+    /**\n+     * This method shuffles an array using the Fisher-Yates algorithm.\n+     *\n+     * @param arr is the input array to be shuffled\n+     */\n+    public static void shuffle(int[] arr) {\n+        Random random = new Random();\n+        for (int i = arr.length - 1; i > 0; i--) {\n+            int j = random.nextInt(i + 1);\n+            int temp = arr[i];\n+            arr[i] = arr[j];\n+            arr[j] = temp;\n+        }\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/misc/ShuffleArrayTest.java b/src/test/java/com/thealgorithms/misc/ShuffleArrayTest.java\nnew file mode 100644\nindex 000000000000..915b83e376b6\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/misc/ShuffleArrayTest.java\n@@ -0,0 +1,84 @@\n+package com.thealgorithms.misc;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class ShuffleArrayTest {\n+\n+    @Test\n+    void testShuffleBasic() {\n+        int[] arr = {1, 2, 3, 4, 5};\n+        int[] originalArr = arr.clone(); // Clone original array for comparison\n+        ShuffleArray.shuffle(arr);\n+\n+        // Check that the shuffled array is not the same as the original\n+        assertNotEquals(originalArr, arr);\n+    }\n+\n+    @Test\n+    void testShuffleSingleElement() {\n+        int[] arr = {1};\n+        int[] originalArr = arr.clone();\n+        ShuffleArray.shuffle(arr);\n+\n+        // Check that the shuffled array is the same as the original\n+        assertArrayEquals(originalArr, arr);\n+    }\n+\n+    @Test\n+    void testShuffleTwoElements() {\n+        int[] arr = {1, 2};\n+        int[] originalArr = arr.clone();\n+        ShuffleArray.shuffle(arr);\n+\n+        // Check that the shuffled array is not the same as the original\n+        assertNotEquals(originalArr, arr);\n+        // Check that the shuffled array still contains the same elements\n+        assertTrue(arr[0] == 1 || arr[0] == 2);\n+        assertTrue(arr[1] == 1 || arr[1] == 2);\n+    }\n+\n+    @Test\n+    void testShuffleEmptyArray() {\n+        int[] arr = {};\n+        int[] originalArr = arr.clone();\n+        ShuffleArray.shuffle(arr);\n+\n+        // Check that the shuffled array is the same as the original (still empty)\n+        assertArrayEquals(originalArr, arr);\n+    }\n+\n+    @Test\n+    void testShuffleLargeArray() {\n+        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n+        int[] originalArr = arr.clone();\n+        ShuffleArray.shuffle(arr);\n+\n+        // Check that the shuffled array is not the same as the original\n+        assertNotEquals(originalArr, arr);\n+    }\n+\n+    @Test\n+    void testShuffleRetainsElements() {\n+        int[] arr = {1, 2, 3, 4, 5};\n+        ShuffleArray.shuffle(arr);\n+\n+        // Check that the shuffled array contains the same elements\n+        assertTrue(arr.length == 5);\n+        for (int i = 1; i <= 5; i++) {\n+            assertTrue(contains(arr, i));\n+        }\n+    }\n+\n+    private boolean contains(int[] arr, int value) {\n+        for (int num : arr) {\n+            if (num == value) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}",
    "output": {
      "why": "The addition of the `ShuffleArray` class implements the Fisher-Yates shuffle algorithm to provide a reliable way to randomly permute arrays. The accompanying tests ensure that the method works correctly under various conditions, including edge cases, thereby maintaining code quality and reliability.",
      "commit_message": "Add `ShuffleArray` class with Fisher-Yates shuffle implementation\n- Introduced the `ShuffleArray` class that implements the Fisher-Yates algorithm to shuffle arrays in place.\n- Added unit tests for the shuffle method to validate functionality:\n- Basic shuffling for multiple elements.\n- Situations with single and empty arrays.\n- Verification that shuffled arrays retain original elements."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/lists/ReverseKGroup.java b/src/main/java/com/thealgorithms/datastructures/lists/ReverseKGroup.java\nindex 3c4b9331266c..c9a5c1df9870 100644\n--- a/src/main/java/com/thealgorithms/datastructures/lists/ReverseKGroup.java\n+++ b/src/main/java/com/thealgorithms/datastructures/lists/ReverseKGroup.java\n@@ -1,11 +1,43 @@\n package com.thealgorithms.datastructures.lists;\n \n /**\n- * Reverse K Group LinkedList (https://www.topcoder.com/thrive/articles/reverse-node-in-k-group)\n+ * The ReverseKGroup class provides functionality to reverse nodes in a\n+ * linked list in groups of k nodes.\n+ * <p>\n+ * This algorithm follows the approach of reversing the linked list in segments of\n+ * size k. If the remaining nodes are fewer than k, they remain unchanged.\n+ * </p>\n+ * <p>\n+ * Example:\n+ * Given a linked list: 1 -> 2 -> 3 -> 4 -> 5 and k = 3,\n+ * the output will be: 3 -> 2 -> 1 -> 4 -> 5.\n+ * </p>\n+ * <p>\n+ * The implementation contains:\n+ * - {@code length(Node head)}: A method to calculate the length of the linked list.\n+ * - {@code reverse(Node head, int count, int k)}: A helper method that reverses the nodes\n+ *   in the linked list in groups of k.\n+ * - {@code reverseKGroup(Node head, int k)}: The main method that initiates the reversal\n+ *   process by calling the reverse method.\n+ * </p>\n+ * <p>\n+ * Complexity:\n+ * <ul>\n+ *   <li>Time Complexity: O(n), where n is the number of nodes in the linked list.</li>\n+ *   <li>Space Complexity: O(1), as we are reversing in place.</li>\n+ * </ul>\n+ * </p>\n+ *\n  * Author: Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n  */\n-\n public class ReverseKGroup {\n+\n+    /**\n+     * Calculates the length of the linked list.\n+     *\n+     * @param head The head node of the linked list.\n+     * @return The total number of nodes in the linked list.\n+     */\n     public int length(Node head) {\n         Node curr = head;\n         int count = 0;\n@@ -15,7 +47,15 @@ public int length(Node head) {\n         }\n         return count;\n     }\n-    // reverse function\n+\n+    /**\n+     * Reverses the linked list in groups of k nodes.\n+     *\n+     * @param head The head node of the linked list.\n+     * @param count The remaining number of nodes.\n+     * @param k The size of the group to reverse.\n+     * @return The new head of the reversed linked list segment.\n+     */\n     public Node reverse(Node head, int count, int k) {\n         if (count < k) {\n             return head;\n@@ -37,9 +77,16 @@ public Node reverse(Node head, int count, int k) {\n         }\n         return prev;\n     }\n+\n+    /**\n+     * Reverses the linked list in groups of k nodes.\n+     *\n+     * @param head The head node of the linked list.\n+     * @param k The size of the group to reverse.\n+     * @return The head of the modified linked list after reversal.\n+     */\n     public Node reverseKGroup(Node head, int k) {\n         int count = length(head);\n-        Node ans = reverse(head, count, k);\n-        return ans;\n+        return reverse(head, count, k);\n     }\n }\ndiff --git a/src/test/java/com/thealgorithms/datastructures/lists/ReverseKGroupTest.java b/src/test/java/com/thealgorithms/datastructures/lists/ReverseKGroupTest.java\nindex e7e3cca4083f..b2db478f692c 100644\n--- a/src/test/java/com/thealgorithms/datastructures/lists/ReverseKGroupTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/lists/ReverseKGroupTest.java\n@@ -4,6 +4,7 @@\n import static org.junit.jupiter.api.Assertions.assertNull;\n \n import org.junit.jupiter.api.Test;\n+\n /**\n  * Test cases for Reverse K Group LinkedList\n  * Author: Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)",
    "output": {
      "why": "The changes enhance the documentation of the `ReverseKGroup` class by adding comprehensive Javadoc comments. This improves code understandability for new developers and facilitates better maintenance.",
      "commit_message": "Enhance documentation for `ReverseKGroup` class\n- Added detailed Javadoc comments for the `length`, `reverse`, and `reverseKGroup` methods to clarify their purpose and usage.\n- Updated class header to provide a clearer explanation of the algorithm's functionality, including complexity analysis and usage examples.\n- Improved overall documentation quality to help future developers understand the functionality and structure of the code more easily."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/GoldbachConjecture.java b/src/main/java/com/thealgorithms/maths/GoldbachConjecture.java\nnew file mode 100644\nindex 000000000000..52391bc100d8\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/maths/GoldbachConjecture.java\n@@ -0,0 +1,30 @@\n+package com.thealgorithms.maths;\n+\n+import static com.thealgorithms.maths.PrimeCheck.isPrime;\n+\n+/**\n+ * This is a representation of the unsolved problem of Goldbach's Projection, according to which every\n+ * even natural number greater than 2 can be written as the sum of 2 prime numbers\n+ * More info: https://en.wikipedia.org/wiki/Goldbach%27s_conjecture\n+ * @author Vasilis Sarantidis (https://github.com/BILLSARAN)\n+ */\n+\n+public final class GoldbachConjecture {\n+    private GoldbachConjecture() {\n+    }\n+    public record Result(int number1, int number2) {\n+    }\n+\n+    public static Result getPrimeSum(int number) {\n+        if (number <= 2 || number % 2 != 0) {\n+            throw new IllegalArgumentException(\"Number must be even and greater than 2.\");\n+        }\n+\n+        for (int i = 0; i <= number / 2; i++) {\n+            if (isPrime(i) && isPrime(number - i)) {\n+                return new Result(i, number - i);\n+            }\n+        }\n+        throw new IllegalStateException(\"No valid prime sum found.\"); // Should not occur\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/maths/GoldbachConjectureTest.java b/src/test/java/com/thealgorithms/maths/GoldbachConjectureTest.java\nnew file mode 100644\nindex 000000000000..84c5824d26ae\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/maths/GoldbachConjectureTest.java\n@@ -0,0 +1,29 @@\n+package com.thealgorithms.maths;\n+\n+import static com.thealgorithms.maths.GoldbachConjecture.getPrimeSum;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class GoldbachConjectureTest {\n+    @Test\n+    void testValidEvenNumbers() {\n+        assertEquals(new GoldbachConjecture.Result(3, 7), getPrimeSum(10)); // 10 = 3 + 7\n+        assertEquals(new GoldbachConjecture.Result(5, 7), getPrimeSum(12)); // 12 = 5 + 7\n+        assertEquals(new GoldbachConjecture.Result(3, 11), getPrimeSum(14)); // 14 = 3 + 11\n+        assertEquals(new GoldbachConjecture.Result(5, 13), getPrimeSum(18)); // 18 = 5 + 13\n+    }\n+    @Test\n+    void testInvalidOddNumbers() {\n+        assertThrows(IllegalArgumentException.class, () -> getPrimeSum(7));\n+        assertThrows(IllegalArgumentException.class, () -> getPrimeSum(15));\n+    }\n+    @Test\n+    void testLesserThanTwo() {\n+        assertThrows(IllegalArgumentException.class, () -> getPrimeSum(1));\n+        assertThrows(IllegalArgumentException.class, () -> getPrimeSum(2));\n+        assertThrows(IllegalArgumentException.class, () -> getPrimeSum(-5));\n+        assertThrows(IllegalArgumentException.class, () -> getPrimeSum(-26));\n+    }\n+}",
    "output": {
      "why": "The GoldbachConjecture class implements a method to find two prime numbers that sum to a given even number, providing input validation for suitable arguments. Corresponding unit tests have been created to ensure functionality and correctness.",
      "commit_message": "Implement Goldbach's Conjecture solution and tests\n- Introduced the `GoldbachConjecture` class which includes a method `getPrimeSum`\nto calculate two prime numbers that add up to a given even number.\n- Added validations to ensure the number is even and greater than 2.\n- Created `GoldbachConjectureTest` class with unit tests for:\n- Valid even numbers confirming expected prime pairs.\n- Handling of invalid inputs (odd numbers and numbers less than or equal to 2)."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/maths/UniformNumbers.java b/src/main/java/com/thealgorithms/maths/UniformNumbers.java\nnew file mode 100644\nindex 000000000000..c83783aab0b3\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/maths/UniformNumbers.java\n@@ -0,0 +1,50 @@\n+package com.thealgorithms.maths;\n+\n+/**\n+ * A positive integer is considered uniform if all\n+ * of its digits are equal. For example, 222 is uniform,\n+ * while 223 is not.\n+ * Given two positive integers a and b, determine the\n+ * number of uniform integers between a and b.\n+ */\n+public final class UniformNumbers {\n+    // Private constructor to prevent instantiation of the utility class\n+    private UniformNumbers() {\n+        // Prevent instantiation\n+    }\n+    /**\n+     * This function will find the number of uniform numbers\n+     * from 1 to num\n+     * @param num upper limit to find the uniform numbers\n+     * @return the count of uniform numbers between 1 and num\n+     */\n+    public static int uniformNumbers(int num) {\n+        String numStr = Integer.toString(num);\n+        int uniformCount = (numStr.length() - 1) * 9;\n+        int finalUniform = Integer.parseInt(String.valueOf(numStr.charAt(0)).repeat(numStr.length()));\n+\n+        if (finalUniform <= num) {\n+            uniformCount += Integer.parseInt(String.valueOf(numStr.charAt(0)));\n+        } else {\n+            uniformCount += Integer.parseInt(String.valueOf(numStr.charAt(0))) - 1;\n+        }\n+\n+        return uniformCount;\n+    }\n+    /**\n+     * This function will calculate the number of uniform numbers\n+     * between a and b\n+     * @param a lower bound of range\n+     * @param b upper bound of range\n+     * @return  the count of uniform numbers between a and b\n+     */\n+    public static int countUniformIntegers(int a, int b) {\n+        if (b > a && b > 0 && a > 0) {\n+            return uniformNumbers(b) - uniformNumbers(a - 1);\n+        } else if (b == a) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/maths/UniformNumbersTest.java b/src/test/java/com/thealgorithms/maths/UniformNumbersTest.java\nnew file mode 100644\nindex 000000000000..ac46c00014ad\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/maths/UniformNumbersTest.java\n@@ -0,0 +1,56 @@\n+package com.thealgorithms.maths;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+class UniformNumbersTest {\n+\n+    @Test\n+    void testSingleUniformDigitRange() {\n+        assertEquals(1, UniformNumbers.countUniformIntegers(1, 1));\n+        assertEquals(9, UniformNumbers.countUniformIntegers(1, 9));\n+    }\n+\n+    @Test\n+    void testSmallRange() {\n+        assertEquals(1, UniformNumbers.countUniformIntegers(10, 11));\n+        assertEquals(2, UniformNumbers.countUniformIntegers(22, 33));\n+    }\n+\n+    @Test\n+    void testRangeWithNoUniformNumbers() {\n+        assertEquals(0, UniformNumbers.countUniformIntegers(12, 21));\n+        assertEquals(0, UniformNumbers.countUniformIntegers(123, 128));\n+    }\n+\n+    @Test\n+    void testRangeWithAllUniformNumbers() {\n+        assertEquals(9, UniformNumbers.countUniformIntegers(1, 9));\n+        assertEquals(18, UniformNumbers.countUniformIntegers(1, 99));\n+    }\n+\n+    @Test\n+    void testMultiDigitRangeWithUniformNumbers() {\n+        assertEquals(1, UniformNumbers.countUniformIntegers(100, 111));\n+        assertEquals(2, UniformNumbers.countUniformIntegers(111, 222));\n+    }\n+\n+    @Test\n+    void testExactUniformBoundary() {\n+        assertEquals(1, UniformNumbers.countUniformIntegers(111, 111));\n+        assertEquals(2, UniformNumbers.countUniformIntegers(111, 222));\n+    }\n+\n+    @Test\n+    void testLargeRange() {\n+        assertEquals(27, UniformNumbers.countUniformIntegers(1, 999));\n+        assertEquals(36, UniformNumbers.countUniformIntegers(1, 9999));\n+    }\n+\n+    @Test\n+    void testInvalidRange() {\n+        assertEquals(0, UniformNumbers.countUniformIntegers(500, 100));\n+        assertEquals(0, UniformNumbers.countUniformIntegers(-100, -1));\n+    }\n+}",
    "output": {
      "why": "The UniformNumbers class was added to introduce functionality for counting uniform integers within a specified range. Corresponding test cases were created to ensure the accuracy of this implementation.",
      "commit_message": "Add `UniformNumbers` class and related tests\n- Implemented the `UniformNumbers` class, which provides methods to count uniform integers between given bounds.\n- The directory file was updated to include links to the new class and its test.\n- Added comprehensive unit tests for various scenarios, including single-digit ranges, small ranges, and invalid input cases."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/tree/HeavyLightDecomposition.java b/src/main/java/com/thealgorithms/tree/HeavyLightDecomposition.java\nnew file mode 100644\nindex 000000000000..236a23205180\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/tree/HeavyLightDecomposition.java\n@@ -0,0 +1,157 @@\n+package com.thealgorithms.tree;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Heavy-Light Decomposition (HLD) implementation in Java.\n+ * HLD is used to efficiently handle path queries on trees, such as maximum,\n+ * sum, or updates. It decomposes the tree into heavy and light chains,\n+ * enabling queries in O(log N) time.\n+ * Wikipedia Reference: https://en.wikipedia.org/wiki/Heavy-light_decomposition\n+ * Author: Nithin U.\n+ * Github: https://github.com/NithinU2802\n+ */\n+\n+public class HeavyLightDecomposition {\n+    private List<List<Integer>> tree;\n+    private int[] parent;\n+    private int[] depth;\n+    private int[] subtreeSize;\n+    private int[] chainHead;\n+    private int[] position;\n+    private int[] nodeValue;\n+    private int[] segmentTree;\n+    private int positionIndex;\n+\n+    public HeavyLightDecomposition(int n) {\n+        tree = new ArrayList<>();\n+        for (int i = 0; i <= n; i++) {\n+            tree.add(new ArrayList<>());\n+        }\n+        parent = new int[n + 1];\n+        depth = new int[n + 1];\n+        subtreeSize = new int[n + 1];\n+        chainHead = new int[n + 1];\n+        position = new int[n + 1];\n+        nodeValue = new int[n + 1];\n+        segmentTree = new int[4 * (n + 1)];\n+        for (int i = 0; i <= n; i++) {\n+            chainHead[i] = -1;\n+        }\n+        positionIndex = 0;\n+    }\n+\n+    public int getPosition(int index) {\n+        return position[index];\n+    }\n+\n+    public int getPositionIndex() {\n+        return positionIndex;\n+    }\n+\n+    public void addEdge(int u, int v) {\n+        tree.get(u).add(v);\n+        tree.get(v).add(u);\n+    }\n+\n+    private void dfsSize(int node, int parentNode) {\n+        parent[node] = parentNode;\n+        subtreeSize[node] = 1;\n+        for (int child : tree.get(node)) {\n+            if (child != parentNode) {\n+                depth[child] = depth[node] + 1;\n+                dfsSize(child, node);\n+                subtreeSize[node] += subtreeSize[child];\n+            }\n+        }\n+    }\n+\n+    private void decompose(int node, int head) {\n+        chainHead[node] = head;\n+        position[node] = positionIndex++;\n+        int heavyChild = -1;\n+        int maxSubtreeSize = -1;\n+        for (int child : tree.get(node)) {\n+            if (child != parent[node] && subtreeSize[child] > maxSubtreeSize) {\n+                heavyChild = child;\n+                maxSubtreeSize = subtreeSize[child];\n+            }\n+        }\n+        if (heavyChild != -1) {\n+            decompose(heavyChild, head);\n+        }\n+        for (int child : tree.get(node)) {\n+            if (child != parent[node] && child != heavyChild) {\n+                decompose(child, child);\n+            }\n+        }\n+    }\n+\n+    private void buildSegmentTree(int node, int start, int end) {\n+        if (start == end) {\n+            segmentTree[node] = nodeValue[start];\n+            return;\n+        }\n+        int mid = (start + end) / 2;\n+        buildSegmentTree(2 * node, start, mid);\n+        buildSegmentTree(2 * node + 1, mid + 1, end);\n+        segmentTree[node] = Math.max(segmentTree[2 * node], segmentTree[2 * node + 1]);\n+    }\n+\n+    public void updateSegmentTree(int node, int start, int end, int index, int value) {\n+        if (start == end) {\n+            segmentTree[node] = value;\n+            return;\n+        }\n+        int mid = (start + end) / 2;\n+        if (index <= mid) {\n+            updateSegmentTree(2 * node, start, mid, index, value);\n+        } else {\n+            updateSegmentTree(2 * node + 1, mid + 1, end, index, value);\n+        }\n+        segmentTree[node] = Math.max(segmentTree[2 * node], segmentTree[2 * node + 1]);\n+    }\n+\n+    public int querySegmentTree(int node, int start, int end, int left, int right) {\n+        if (left > end || right < start) {\n+            return Integer.MIN_VALUE;\n+        }\n+        if (left <= start && end <= right) {\n+            return segmentTree[node];\n+        }\n+        int mid = (start + end) / 2;\n+        int leftQuery = querySegmentTree(2 * node, start, mid, left, right);\n+        int rightQuery = querySegmentTree(2 * node + 1, mid + 1, end, left, right);\n+        return Math.max(leftQuery, rightQuery);\n+    }\n+\n+    public int queryMaxInPath(int u, int v) {\n+        int result = Integer.MIN_VALUE;\n+        while (chainHead[u] != chainHead[v]) {\n+            if (depth[chainHead[u]] < depth[chainHead[v]]) {\n+                int temp = u;\n+                u = v;\n+                v = temp;\n+            }\n+            result = Math.max(result, querySegmentTree(1, 0, positionIndex - 1, position[chainHead[u]], position[u]));\n+            u = parent[chainHead[u]];\n+        }\n+        if (depth[u] > depth[v]) {\n+            int temp = u;\n+            u = v;\n+            v = temp;\n+        }\n+        result = Math.max(result, querySegmentTree(1, 0, positionIndex - 1, position[u], position[v]));\n+        return result;\n+    }\n+\n+    public void initialize(int root, int[] values) {\n+        dfsSize(root, -1);\n+        decompose(root, root);\n+        for (int i = 0; i < values.length; i++) {\n+            nodeValue[position[i]] = values[i];\n+        }\n+        buildSegmentTree(1, 0, positionIndex - 1);\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/tree/HeavyLightDecompositionTest.java b/src/test/java/com/thealgorithms/tree/HeavyLightDecompositionTest.java\nnew file mode 100644\nindex 000000000000..29189290e1d4\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/tree/HeavyLightDecompositionTest.java\n@@ -0,0 +1,69 @@\n+package com.thealgorithms.tree;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+class HeavyLightDecompositionTest {\n+\n+    private HeavyLightDecomposition hld;\n+    private final int[] values = {0, 10, 20, 30, 40, 50};\n+\n+    /**\n+     * Initializes the test environment with a predefined tree structure and values.\n+     */\n+    @BeforeEach\n+    void setUp() {\n+        hld = new HeavyLightDecomposition(5);\n+        hld.addEdge(1, 2);\n+        hld.addEdge(1, 3);\n+        hld.addEdge(2, 4);\n+        hld.addEdge(2, 5);\n+        hld.initialize(1, values);\n+    }\n+\n+    /**\n+     * Verifies that the tree initializes successfully without errors.\n+     */\n+    @Test\n+    void testBasicTreeInitialization() {\n+        assertTrue(true, \"Basic tree structure initialized successfully\");\n+    }\n+\n+    /**\n+     * Tests the maximum value query in the path between nodes.\n+     */\n+    @Test\n+    void testQueryMaxInPath() {\n+        assertEquals(50, hld.queryMaxInPath(4, 5), \"Max value in path (4,5) should be 50\");\n+        assertEquals(30, hld.queryMaxInPath(3, 2), \"Max value in path (3,2) should be 30\");\n+    }\n+\n+    /**\n+     * Tests updating a node's value and ensuring it is reflected in queries.\n+     */\n+    @Test\n+    void testUpdateNodeValue() {\n+        hld.updateSegmentTree(1, 0, hld.getPositionIndex() - 1, hld.getPosition(4), 100);\n+        assertEquals(100, hld.queryMaxInPath(4, 5), \"Updated value should be reflected in query\");\n+    }\n+\n+    /**\n+     * Tests the maximum value query in a skewed tree structure.\n+     */\n+    @Test\n+    void testSkewedTreeMaxQuery() {\n+        assertEquals(40, hld.queryMaxInPath(1, 4), \"Max value in skewed tree (1,4) should be 40\");\n+    }\n+\n+    /**\n+     * Ensures query handles cases where u is a deeper node correctly.\n+     */\n+    @Test\n+    void testDepthSwapInPathQuery() {\n+        assertEquals(50, hld.queryMaxInPath(5, 2), \"Query should handle depth swap correctly\");\n+        assertEquals(40, hld.queryMaxInPath(4, 1), \"Query should handle swapped nodes correctly and return max value\");\n+    }\n+}",
    "output": {
      "why": "The new `HeavyLightDecomposition` class was introduced to efficiently perform path queries on trees, providing a better structure for tree-based operations. The accompanying tests ensure functionality and correctness.",
      "commit_message": "Add Heavy-Light Decomposition implementation and tests\n- Introduced `HeavyLightDecomposition` class to handle efficient path queries on trees using heavy-light decomposition.\n- Updated the `DIRECTORY.md` file to include the new class and its related test case.\n- Added unit tests for the `HeavyLightDecomposition` to verify initialization, querying, and updating values in a tree structure."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/ciphers/AtbashCipher.java b/src/main/java/com/thealgorithms/ciphers/AtbashCipher.java\nindex c3b673144c63..9169aa82bd75 100644\n--- a/src/main/java/com/thealgorithms/ciphers/AtbashCipher.java\n+++ b/src/main/java/com/thealgorithms/ciphers/AtbashCipher.java\n@@ -1,68 +1,98 @@\n package com.thealgorithms.ciphers;\n \n /**\n- * The Atbash cipher is a simple substitution cipher that replaces each letter\n- * in the alphabet with its reverse.\n- * For example, 'A' becomes 'Z', 'B' becomes 'Y', and so on. It works\n- * identically for both uppercase and lowercase letters.\n- * It's a symmetric cipher, meaning applying it twice returns the original text.\n- * Hence, the encrypting and the decrypting functions are identical\n- * @author https://github.com/Krounosity\n- * Learn more: https://en.wikipedia.org/wiki/Atbash\n+ * The Atbash cipher is a classic substitution cipher that substitutes each letter\n+ * with its opposite letter in the alphabet.\n+ *\n+ * For example:\n+ * - 'A' becomes 'Z', 'B' becomes 'Y', 'C' becomes 'X', and so on.\n+ * - Similarly, 'a' becomes 'z', 'b' becomes 'y', and so on.\n+ *\n+ * The cipher works identically for both uppercase and lowercase letters.\n+ * Non-alphabetical characters remain unchanged in the output.\n+ *\n+ * This cipher is symmetric, meaning that applying the cipher twice will return\n+ * the original text. Therefore, the same function is used for both encryption and decryption.\n+ *\n+ * <p>Usage Example:</p>\n+ * <pre>\n+ * AtbashCipher cipher = new AtbashCipher(\"Hello World!\");\n+ * String encrypted = cipher.convert(); // Output: \"Svool Dliow!\"\n+ * </pre>\n+ *\n+ * @author <a href=\"https://github.com/Krounosity\">Krounosity</a>\n+ * @see <a href=\"https://en.wikipedia.org/wiki/Atbash\">Atbash Cipher (Wikipedia)</a>\n  */\n-\n public class AtbashCipher {\n \n     private String toConvert;\n \n-    // Default constructor.\n-    AtbashCipher() {\n+    public AtbashCipher() {\n     }\n \n-    // String setting constructor.\n-    AtbashCipher(String str) {\n-        toConvert = str;\n+    /**\n+     * Constructor with a string parameter.\n+     *\n+     * @param str The string to be converted using the Atbash cipher\n+     */\n+    public AtbashCipher(String str) {\n+        this.toConvert = str;\n     }\n \n-    // String getter method.\n+    /**\n+     * Returns the current string set for conversion.\n+     *\n+     * @return The string to be converted\n+     */\n     public String getString() {\n         return toConvert;\n     }\n \n-    // String setter method.\n+    /**\n+     * Sets the string to be converted using the Atbash cipher.\n+     *\n+     * @param str The new string to convert\n+     */\n     public void setString(String str) {\n-        toConvert = str;\n+        this.toConvert = str;\n     }\n \n-    // Checking whether the current character is capital.\n+    /**\n+     * Checks if a character is uppercase.\n+     *\n+     * @param ch The character to check\n+     * @return {@code true} if the character is uppercase, {@code false} otherwise\n+     */\n     private boolean isCapital(char ch) {\n         return ch >= 'A' && ch <= 'Z';\n     }\n \n-    // Checking whether the current character is smallcased.\n+    /**\n+     * Checks if a character is lowercase.\n+     *\n+     * @param ch The character to check\n+     * @return {@code true} if the character is lowercase, {@code false} otherwise\n+     */\n     private boolean isSmall(char ch) {\n         return ch >= 'a' && ch <= 'z';\n     }\n \n-    // Converting text to atbash cipher code or vice versa.\n+    /**\n+     * Converts the input string using the Atbash cipher.\n+     * Alphabetic characters are substituted with their opposite in the alphabet,\n+     * while non-alphabetic characters remain unchanged.\n+     *\n+     * @return The converted string after applying the Atbash cipher\n+     */\n     public String convert() {\n-\n-        // Using StringBuilder to store new string.\n         StringBuilder convertedString = new StringBuilder();\n \n-        // Iterating for each character.\n         for (char ch : toConvert.toCharArray()) {\n-\n-            // If the character is smallcased.\n             if (isSmall(ch)) {\n                 convertedString.append((char) ('z' - (ch - 'a')));\n-            }\n-            // If the character is capital cased.\n-            else if (isCapital(ch)) {\n+            } else if (isCapital(ch)) {\n                 convertedString.append((char) ('Z' - (ch - 'A')));\n-            }\n-            // Non-alphabetical character.\n-            else {\n+            } else {\n                 convertedString.append(ch);\n             }\n         }\ndiff --git a/src/test/java/com/thealgorithms/ciphers/AtbashTest.java b/src/test/java/com/thealgorithms/ciphers/AtbashTest.java\nindex 26812cf2b0d4..ec34bc26ad72 100644\n--- a/src/test/java/com/thealgorithms/ciphers/AtbashTest.java\n+++ b/src/test/java/com/thealgorithms/ciphers/AtbashTest.java\n@@ -2,27 +2,42 @@\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n-import org.junit.jupiter.api.Test;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n \n public class AtbashTest {\n \n-    @Test\n-    public void atbashEncrypt() {\n-        AtbashCipher normalToEncrypt = new AtbashCipher(\"Hello World! 123, @cipher abcDEF ZYX 987 madam zzZ Palindrome!\");\n-        String expectedText = \"Svool Dliow! 123, @xrksvi zyxWVU ABC 987 nzwzn aaA Kzormwilnv!\";\n+    @ParameterizedTest\n+    @MethodSource(\"cipherTestProvider\")\n+    public void testAtbashCipher(String input, String expected) {\n+        AtbashCipher cipher = new AtbashCipher(input);\n+        assertEquals(expected, cipher.convert());\n+    }\n \n-        normalToEncrypt.setString(normalToEncrypt.convert());\n+    private static Stream<Arguments> cipherTestProvider() {\n+        return Stream.of(\n+            // Basic tests with lowercase and uppercase\n+            Arguments.of(\"Hello\", \"Svool\"), Arguments.of(\"WORLD\", \"DLIOW\"),\n \n-        assertEquals(expectedText, normalToEncrypt.getString());\n-    }\n+            // Mixed case with spaces and punctuation\n+            Arguments.of(\"Hello World!\", \"Svool Dliow!\"), Arguments.of(\"123 ABC xyz\", \"123 ZYX cba\"),\n+\n+            // Palindromes and mixed cases\n+            Arguments.of(\"madam\", \"nzwzn\"), Arguments.of(\"Palindrome\", \"Kzormwilnv\"),\n+\n+            // Non-alphabetic characters should remain unchanged\n+            Arguments.of(\"@cipher 123!\", \"@xrksvi 123!\"), Arguments.of(\"no-change\", \"ml-xszmtv\"),\n \n-    @Test\n-    public void atbashDecrypt() {\n-        AtbashCipher encryptToNormal = new AtbashCipher(\"Svool Dliow! 123, @xrksvi zyxWVU ABC 987 nzwzn aaA Kzormwilnv!\");\n-        String expectedText = \"Hello World! 123, @cipher abcDEF ZYX 987 madam zzZ Palindrome!\";\n+            // Empty string and single characters\n+            Arguments.of(\"\", \"\"), Arguments.of(\"A\", \"Z\"), Arguments.of(\"z\", \"a\"),\n \n-        encryptToNormal.setString(encryptToNormal.convert());\n+            // Numbers and symbols\n+            Arguments.of(\"!@#123\", \"!@#123\"),\n \n-        assertEquals(expectedText, encryptToNormal.getString());\n+            // Full sentence with uppercase, lowercase, symbols, and numbers\n+            Arguments.of(\"Hello World! 123, @cipher abcDEF ZYX 987 madam zzZ Palindrome!\", \"Svool Dliow! 123, @xrksvi zyxWVU ABC 987 nzwzn aaA Kzormwilnv!\"),\n+            Arguments.of(\"Svool Dliow! 123, @xrksvi zyxWVU ABC 987 nzwzn aaA Kzormwilnv!\", \"Hello World! 123, @cipher abcDEF ZYX 987 madam zzZ Palindrome!\"));\n     }\n }",
    "output": {
      "why": "The changes enhance the documentation of the Atbash cipher, clarifying its functionality, and adding usage examples for ease of understanding. \n- The transition to parameterized tests improves the testing structure, allowing for broader test scenarios and clearer assertions.",
      "commit_message": "Enhance documentation and testing of AtbashCipher\n- Improved the documentation of the AtbashCipher class for clarity, including detailed explanations and usage examples.\n- Updated the constructor and method comments to follow Javadoc standards.\n- Refactored unit tests to use parameterized tests for better coverage and readability.\n- Ensured that all character cases and non-alphabetic characters are adequately tested to validate the cipher's behavior."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/LinearProbingHashMap.java b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/LinearProbingHashMap.java\nindex c96da27c0331..10d5dc7decae 100644\n--- a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/LinearProbingHashMap.java\n+++ b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/LinearProbingHashMap.java\n@@ -2,24 +2,51 @@\n \n import java.util.ArrayList;\n \n-/***\n- * This class is an implementation of a hash table using linear probing.\n+/**\n+ * This class implements a hash table using linear probing to resolve collisions.\n+ * Linear probing is a collision resolution method where each slot in the hash table is checked in a sequential manner\n+ * until an empty slot is found.\n+ *\n+ * <p>\n+ * The class allows for storing key-value pairs, where both the key and value are generic types.\n+ * The key must be of a type that implements the Comparable interface to ensure that the keys can be compared for sorting.\n+ * </p>\n+ *\n+ * <p>\n+ * This implementation supports basic operations such as:\n+ * <ul>\n+ *     <li><b>put(Key key, Value value)</b>: Adds a key-value pair to the hash table. If the key already exists, its value is updated.</li>\n+ *     <li><b>get(Key key)</b>: Retrieves the value associated with the given key.</li>\n+ *     <li><b>delete(Key key)</b>: Removes the key and its associated value from the hash table.</li>\n+ *     <li><b>contains(Key key)</b>: Checks if the hash table contains a given key.</li>\n+ *     <li><b>size()</b>: Returns the number of key-value pairs in the hash table.</li>\n+ *     <li><b>keys()</b>: Returns an iterable collection of keys stored in the hash table.</li>\n+ * </ul>\n+ * </p>\n+ *\n+ * <p>\n+ * The internal size of the hash table is automatically resized when the load factor exceeds 0.5 or falls below 0.125,\n+ * ensuring efficient space utilization.\n+ * </p>\n+ *\n  * @see <a href=\"https://en.wikipedia.org/wiki/Linear_probing\">Linear Probing Hash Table</a>\n  *\n- * @param <Key> keys type.\n- * @param <Value> values type.\n+ * @param <Key> the type of keys maintained by this map\n+ * @param <Value> the type of mapped values\n  */\n public class LinearProbingHashMap<Key extends Comparable<Key>, Value> extends Map<Key, Value> {\n     private int hsize; // size of the hash table\n-    private Key[] keys;\n-    private Value[] values;\n-    private int size; // amount of elements in the hash table\n+    private Key[] keys; // array to store keys\n+    private Value[] values; // array to store values\n+    private int size; // number of elements in the hash table\n \n+    // Default constructor initializes the table with a default size of 16\n     public LinearProbingHashMap() {\n         this(16);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n+    // Constructor to initialize the hash table with a specified size\n     public LinearProbingHashMap(int size) {\n         this.hsize = size;\n         keys = (Key[]) new Comparable[size];\n@@ -81,7 +108,7 @@ public boolean delete(Key key) {\n \n         i = increment(i);\n         while (keys[i] != null) {\n-            // delete keys[i] an vals[i] and reinsert\n+            // Save the key and value for rehashing\n             Key keyToRehash = keys[i];\n             Value valToRehash = values[i];\n             keys[i] = null;\ndiff --git a/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/LinearProbingHashMapTest.java b/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/LinearProbingHashMapTest.java\nindex d0a72a1509ee..34b165d4bbcf 100644\n--- a/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/LinearProbingHashMapTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/LinearProbingHashMapTest.java\n@@ -1,8 +1,91 @@\n package com.thealgorithms.datastructures.hashmap.hashing;\n \n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.junit.jupiter.api.Test;\n+\n class LinearProbingHashMapTest extends MapTest {\n+\n     @Override\n     <Key extends Comparable<Key>, Value> Map<Key, Value> getMap() {\n         return new LinearProbingHashMap<>();\n     }\n+\n+    @Test\n+    void putNullKey() {\n+        Map<Integer, String> map = getMap();\n+        assertFalse(map.put(null, \"value\"), \"Putting a null key should return false\");\n+    }\n+\n+    @Test\n+    void putDuplicateKeys() {\n+        Map<Integer, String> map = getMap();\n+        map.put(1, \"one\");\n+        map.put(1, \"uno\");\n+        assertEquals(\"uno\", map.get(1), \"Value should be updated to 'uno'\");\n+    }\n+\n+    @Test\n+    void putResizeTest() {\n+        Map<Integer, String> map = getMap();\n+        for (int i = 0; i < 20; i++) {\n+            map.put(i, String.valueOf(i));\n+        }\n+        assertEquals(20, map.size(), \"Map size should be 20 after inserting 20 elements\");\n+    }\n+\n+    @Test\n+    void deleteNonExistentKey() {\n+        Map<Integer, String> map = getMap();\n+        assertFalse(map.delete(999), \"Deleting a non-existent key should return false\");\n+    }\n+\n+    @Test\n+    void deleteAndReinsert() {\n+        Map<Integer, String> map = getMap();\n+        map.put(1, \"one\");\n+        map.delete(1);\n+        assertFalse(map.contains(1), \"Map should not contain the deleted key\");\n+        map.put(1, \"one again\");\n+        assertTrue(map.contains(1), \"Map should contain the key after reinsertion\");\n+    }\n+\n+    @Test\n+    void resizeDown() {\n+        Map<Integer, String> map = getMap();\n+        for (int i = 0; i < 16; i++) {\n+            map.put(i, String.valueOf(i));\n+        }\n+        for (int i = 0; i < 12; i++) {\n+            map.delete(i);\n+        }\n+        assertEquals(4, map.size(), \"Map size should be 4 after deleting 12 elements\");\n+    }\n+\n+    @Test\n+    void keysOrderTest() {\n+        Map<Integer, String> map = getMap();\n+        for (int i = 10; i > 0; i--) {\n+            map.put(i, String.valueOf(i));\n+        }\n+        int expectedKey = 1;\n+        for (Integer key : map.keys()) {\n+            assertEquals(expectedKey++, key, \"Keys should be in sorted order\");\n+        }\n+    }\n+\n+    @Test\n+    void stressTest() {\n+        Map<Integer, String> map = getMap();\n+        for (int i = 0; i < 1000; i++) {\n+            map.put(i, String.valueOf(i));\n+            assertEquals(i + 1, map.size(), \"Size should match number of inserted elements\");\n+        }\n+        for (int i = 0; i < 500; i++) {\n+            map.delete(i);\n+            assertEquals(1000 - (i + 1), map.size(), \"Size should decrease correctly\");\n+        }\n+    }\n }",
    "output": {
      "why": "The changes enhance documentation clarity regarding the functionality of the `LinearProbingHashMap` and add comprehensive test cases to ensure reliable behavior across various scenarios, including edge cases like handling null keys, duplicate keys, resizing, and stress testing.",
      "commit_message": "Enhance documentation and tests for `LinearProbingHashMap`\n- Improved Javadoc comments in `LinearProbingHashMap` class for better clarity on methods and usage.\n- Added new unit tests to cover various scenarios including:\n- Attempting to put a null key.\n- Updating values for duplicate keys.\n- Ensuring resizing works correctly when exceeding capacity.\n- Verifying behavior when deleting non-existent keys and reinserting keys.\n- Ensuring keys are returned in sorted order.\n- Stress testing with large numbers of insert/delete operations."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/Intersection.java b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/Intersection.java\nindex 54bd10de50fa..0e49218d6348 100644\n--- a/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/Intersection.java\n+++ b/src/main/java/com/thealgorithms/datastructures/hashmap/hashing/Intersection.java\n@@ -1,27 +1,57 @@\n package com.thealgorithms.datastructures.hashmap.hashing;\n \n-/*\n- * this is algo which implies common mathematical set theory concept\n- * called intersection in which result is common values of both the sets\n- * here metaphor of sets is HashMap\n- */\n-\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n+/**\n+ * The {@code Intersection} class provides a method to compute the intersection of two integer arrays.\n+ * The intersection is defined as the set of common elements present in both arrays.\n+ * <p>\n+ * This class utilizes a HashMap to efficiently count occurrences of elements in the first array,\n+ * allowing for an efficient lookup of common elements in the second array.\n+ * </p>\n+ *\n+ * <p>\n+ * Example:\n+ * <pre>\n+ * int[] array1 = {1, 2, 2, 1};\n+ * int[] array2 = {2, 2};\n+ * List<Integer> result = Intersection.intersection(array1, array2); // result will contain [2, 2]\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>\n+ * Note: The order of the returned list may vary since it depends on the order of elements\n+ * in the input arrays.\n+ * </p>\n+ */\n public final class Intersection {\n \n+    /**\n+     * Computes the intersection of two integer arrays.\n+     * Steps:\n+     * 1. Count the occurrences of each element in the first array using a HashMap.\n+     * 2. Iterate over the second array and check if the element is present in the HashMap.\n+     * If it is, add it to the result list and decrement the count in the HashMap.\n+     * 3. Return the result list containing the intersection of the two arrays.\n+     *\n+     * @param arr1 the first array of integers\n+     * @param arr2 the second array of integers\n+     * @return a list containing the intersection of the two arrays, or an empty list if either array is null or empty\n+     */\n     public static List<Integer> intersection(int[] arr1, int[] arr2) {\n         if (arr1 == null || arr2 == null || arr1.length == 0 || arr2.length == 0) {\n             return Collections.emptyList();\n         }\n+\n         Map<Integer, Integer> cnt = new HashMap<>(16);\n         for (int v : arr1) {\n             cnt.put(v, cnt.getOrDefault(v, 0) + 1);\n         }\n+\n         List<Integer> res = new ArrayList<>();\n         for (int v : arr2) {\n             if (cnt.containsKey(v) && cnt.get(v) > 0) {\ndiff --git a/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/IntersectionTest.java b/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/IntersectionTest.java\nnew file mode 100644\nindex 000000000000..df6d15fd9ba4\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/datastructures/hashmap/hashing/IntersectionTest.java\n@@ -0,0 +1,76 @@\n+package com.thealgorithms.datastructures.hashmap.hashing;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+\n+public class IntersectionTest {\n+\n+    @Test\n+    void testBasicIntersection() {\n+        int[] arr1 = {1, 2, 2, 1};\n+        int[] arr2 = {2, 2};\n+        List<Integer> result = Intersection.intersection(arr1, arr2);\n+        assertEquals(List.of(2, 2), result, \"Intersection should return [2, 2]\");\n+    }\n+\n+    @Test\n+    void testNoIntersection() {\n+        int[] arr1 = {1, 2, 3};\n+        int[] arr2 = {4, 5, 6};\n+        List<Integer> result = Intersection.intersection(arr1, arr2);\n+        assertTrue(result.isEmpty(), \"Intersection should be empty for disjoint sets\");\n+    }\n+\n+    @Test\n+    void testEmptyArray() {\n+        int[] arr1 = {};\n+        int[] arr2 = {1, 2, 3};\n+        List<Integer> result = Intersection.intersection(arr1, arr2);\n+        assertTrue(result.isEmpty(), \"Intersection should be empty when first array is empty\");\n+\n+        result = Intersection.intersection(arr2, arr1);\n+        assertTrue(result.isEmpty(), \"Intersection should be empty when second array is empty\");\n+    }\n+\n+    @Test\n+    void testNullArray() {\n+        int[] arr1 = null;\n+        int[] arr2 = {1, 2, 3};\n+        List<Integer> result = Intersection.intersection(arr1, arr2);\n+        assertTrue(result.isEmpty(), \"Intersection should be empty when first array is null\");\n+\n+        result = Intersection.intersection(arr2, arr1);\n+        assertTrue(result.isEmpty(), \"Intersection should be empty when second array is null\");\n+    }\n+\n+    @Test\n+    void testMultipleOccurrences() {\n+        int[] arr1 = {5, 5, 5, 6};\n+        int[] arr2 = {5, 5, 6, 6, 6};\n+        List<Integer> result = Intersection.intersection(arr1, arr2);\n+        assertEquals(List.of(5, 5, 6), result, \"Intersection should return [5, 5, 6]\");\n+    }\n+\n+    @Test\n+    void testSameElements() {\n+        int[] arr1 = {1, 1, 1};\n+        int[] arr2 = {1, 1, 1};\n+        List<Integer> result = Intersection.intersection(arr1, arr2);\n+        assertEquals(List.of(1, 1, 1), result, \"Intersection should return [1, 1, 1] for same elements\");\n+    }\n+\n+    @Test\n+    void testLargeArrays() {\n+        int[] arr1 = new int[1000];\n+        int[] arr2 = new int[1000];\n+        for (int i = 0; i < 1000; i++) {\n+            arr1[i] = i;\n+            arr2[i] = i;\n+        }\n+        List<Integer> result = Intersection.intersection(arr1, arr2);\n+        assertEquals(1000, result.size(), \"Intersection should return all elements for identical large arrays\");\n+    }\n+}",
    "output": {
      "why": "These changes add a new feature that computes the intersection of two integer arrays, which is a valuable operation for set manipulation. The addition of detailed documentation improves code clarity, while new tests ensure functionality is validated against various scenarios.",
      "commit_message": "Add Intersection class for array intersection functionality\n- Implemented the `Intersection` class to compute the intersection of two integer arrays using a HashMap for efficient element counting.\n- Added comprehensive JavaDoc comments to explain class functionality and usage examples.\n- Created `IntersectionTest.java` with multiple test cases to validate intersection logic, including checks for various scenarios such as no overlap, empty inputs, and large data sets.\n- Updated `DIRECTORY.md` to include the new test class in the documentation."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/sorts/DarkSort.java b/src/main/java/com/thealgorithms/sorts/DarkSort.java\nnew file mode 100644\nindex 000000000000..4887d7d124ba\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/sorts/DarkSort.java\n@@ -0,0 +1,59 @@\n+package com.thealgorithms.sorts;\n+\n+/**\n+ * Dark Sort algorithm implementation.\n+ *\n+ * Dark Sort uses a temporary array to count occurrences of elements and\n+ * reconstructs the sorted array based on the counts.\n+ */\n+class DarkSort {\n+\n+    /**\n+     * Sorts the array using the Dark Sort algorithm.\n+     *\n+     * @param unsorted the array to be sorted\n+     * @return sorted array\n+     */\n+    public Integer[] sort(Integer[] unsorted) {\n+        if (unsorted == null || unsorted.length <= 1) {\n+            return unsorted;\n+        }\n+\n+        int max = findMax(unsorted); // Find the maximum value in the array\n+\n+        // Create a temporary array for counting occurrences\n+        int[] temp = new int[max + 1];\n+\n+        // Count occurrences of each element\n+        for (int value : unsorted) {\n+            temp[value]++;\n+        }\n+\n+        // Reconstruct the sorted array\n+        int index = 0;\n+        for (int i = 0; i < temp.length; i++) {\n+            while (temp[i] > 0) {\n+                unsorted[index++] = i;\n+                temp[i]--;\n+            }\n+        }\n+\n+        return unsorted;\n+    }\n+\n+    /**\n+     * Helper method to find the maximum value in an array.\n+     *\n+     * @param arr the array\n+     * @return the maximum value\n+     */\n+    private int findMax(Integer[] arr) {\n+        int max = arr[0];\n+        for (int value : arr) {\n+            if (value > max) {\n+                max = value;\n+            }\n+        }\n+        return max;\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/sorts/DarkSortTest.java b/src/test/java/com/thealgorithms/sorts/DarkSortTest.java\nnew file mode 100644\nindex 000000000000..1df077e2ad74\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/sorts/DarkSortTest.java\n@@ -0,0 +1,74 @@\n+package com.thealgorithms.sorts;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+import org.junit.jupiter.api.Test;\n+\n+class DarkSortTest {\n+\n+    @Test\n+    void testSortWithIntegers() {\n+        Integer[] unsorted = {5, 3, 8, 6, 2, 7, 4, 1};\n+        Integer[] expected = {1, 2, 3, 4, 5, 6, 7, 8};\n+\n+        DarkSort darkSort = new DarkSort();\n+        Integer[] sorted = darkSort.sort(unsorted);\n+\n+        assertArrayEquals(expected, sorted);\n+    }\n+\n+    @Test\n+    void testEmptyArray() {\n+        Integer[] unsorted = {};\n+        Integer[] expected = {};\n+\n+        DarkSort darkSort = new DarkSort();\n+        Integer[] sorted = darkSort.sort(unsorted);\n+\n+        assertArrayEquals(expected, sorted);\n+    }\n+\n+    @Test\n+    void testSingleElementArray() {\n+        Integer[] unsorted = {42};\n+        Integer[] expected = {42};\n+\n+        DarkSort darkSort = new DarkSort();\n+        Integer[] sorted = darkSort.sort(unsorted);\n+\n+        assertArrayEquals(expected, sorted);\n+    }\n+\n+    @Test\n+    void testAlreadySortedArray() {\n+        Integer[] unsorted = {1, 2, 3, 4, 5};\n+        Integer[] expected = {1, 2, 3, 4, 5};\n+\n+        DarkSort darkSort = new DarkSort();\n+        Integer[] sorted = darkSort.sort(unsorted);\n+\n+        assertArrayEquals(expected, sorted);\n+    }\n+\n+    @Test\n+    void testDuplicateElementsArray() {\n+        Integer[] unsorted = {4, 2, 7, 2, 1, 4};\n+        Integer[] expected = {1, 2, 2, 4, 4, 7};\n+\n+        DarkSort darkSort = new DarkSort();\n+        Integer[] sorted = darkSort.sort(unsorted);\n+\n+        assertArrayEquals(expected, sorted);\n+    }\n+\n+    @Test\n+    void testNullArray() {\n+        Integer[] unsorted = null;\n+\n+        DarkSort darkSort = new DarkSort();\n+        Integer[] sorted = darkSort.sort(unsorted);\n+\n+        assertNull(sorted, \"Sorting a null array should return null\");\n+    }\n+}",
    "output": {
      "why": "The new implementation provides a sorting algorithm using the Dark Sort approach, which is efficient for counting occurrences. Unit tests ensure the functionality is validated across various scenarios including edge cases like empty and null inputs.",
      "commit_message": "Add Dark Sort algorithm implementation with unit tests\n- Implemented the Dark Sort algorithm in `DarkSort.java`, which sorts an array by counting occurrences of elements.\n- Added `DarkSortTest.java` to validate the algorithm with unit tests, covering:\n- Normal sorting of integers\n- Empty and single-element arrays\n- Already sorted arrays\n- Arrays with duplicate elements\n- Handling null inputs"
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/lists/SearchSinglyLinkedListRecursion.java b/src/main/java/com/thealgorithms/datastructures/lists/SearchSinglyLinkedListRecursion.java\nindex 35f8c9a95b56..a40e9b2a1a66 100644\n--- a/src/main/java/com/thealgorithms/datastructures/lists/SearchSinglyLinkedListRecursion.java\n+++ b/src/main/java/com/thealgorithms/datastructures/lists/SearchSinglyLinkedListRecursion.java\n@@ -1,31 +1,45 @@\n package com.thealgorithms.datastructures.lists;\n \n+/**\n+ * The SearchSinglyLinkedListRecursion class extends SinglyLinkedList and provides\n+ * a method to search for a value in a singly linked list using recursion.\n+ * <p>\n+ * This class demonstrates a recursive approach to check if a given integer value is\n+ * present in the linked list. The search method calls a private recursive helper method\n+ * `searchRecursion`, which checks each node's value and moves to the next node if necessary.\n+ * </p>\n+ * <p>\n+ * Example:\n+ * Given a list containing the values 1 -> 2 -> 3 -> 4, calling search(3) will return `true`,\n+ * while calling search(5) will return `false`.\n+ * </p>\n+ * <p>\n+ * Complexity:\n+ * <ul>\n+ *   <li>Time Complexity: O(n), where n is the number of nodes in the linked list.</li>\n+ *   <li>Space Complexity: O(n), due to the recursive call stack in the worst case.</li>\n+ * </ul>\n+ * </p>\n+ */\n public class SearchSinglyLinkedListRecursion extends SinglyLinkedList {\n \n-    public static void main(String[] args) {\n-        SearchSinglyLinkedListRecursion list = new SearchSinglyLinkedListRecursion();\n-        for (int i = 1; i <= 10; ++i) {\n-            list.insert(i);\n-        }\n-\n-        for (int i = 1; i <= 10; ++i) {\n-            assert list.search(i);\n-        }\n-        assert !list.search(-1) && !list.search(100);\n-    }\n-\n     /**\n-     * Test if the value key is present in the list using recursion.\n+     * Recursively searches for a given value in the linked list.\n      *\n-     * @param node the head node.\n-     * @param key the value to be searched.\n-     * @return {@code true} if key is present in the list, otherwise\n-     * {@code false}.\n+     * @param node the head node to start the search.\n+     * @param key the integer value to be searched for.\n+     * @return {@code true} if the value `key` is present in the list; otherwise, {@code false}.\n      */\n     private boolean searchRecursion(Node node, int key) {\n         return (node != null && (node.value == key || searchRecursion(node.next, key)));\n     }\n \n+    /**\n+     * Public search method to determine if a key is present in the linked list.\n+     *\n+     * @param key the integer value to be searched for.\n+     * @return {@code true} if the value `key` is present in the list; otherwise, {@code false}.\n+     */\n     @Override\n     public boolean search(int key) {\n         return searchRecursion(getHead(), key);\ndiff --git a/src/test/java/com/thealgorithms/datastructures/lists/SearchSinglyLinkedListRecursionTest.java b/src/test/java/com/thealgorithms/datastructures/lists/SearchSinglyLinkedListRecursionTest.java\nnew file mode 100644\nindex 000000000000..76b905841c18\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/datastructures/lists/SearchSinglyLinkedListRecursionTest.java\n@@ -0,0 +1,89 @@\n+package com.thealgorithms.datastructures.lists;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+public class SearchSinglyLinkedListRecursionTest {\n+\n+    private SearchSinglyLinkedListRecursion list;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        list = new SearchSinglyLinkedListRecursion();\n+    }\n+\n+    @Test\n+    public void testSearchInEmptyList() {\n+        // Test searching for a value in an empty list (should return false)\n+        assertFalse(list.search(1));\n+    }\n+\n+    @Test\n+    public void testSearchSingleElementListFound() {\n+        // Insert a single element and search for it\n+        list.insert(5);\n+        assertTrue(list.search(5));\n+    }\n+\n+    @Test\n+    public void testSearchSingleElementListNotFound() {\n+        // Insert a single element and search for a non-existent value\n+        list.insert(5);\n+        assertFalse(list.search(10));\n+    }\n+\n+    @Test\n+    public void testSearchMultipleElementsListFound() {\n+        // Insert multiple elements and search for a middle value\n+        for (int i = 1; i <= 10; i++) {\n+            list.insert(i);\n+        }\n+        assertTrue(list.search(5));\n+    }\n+\n+    @Test\n+    public void testSearchMultipleElementsListFirstElement() {\n+        // Insert multiple elements and search for the first element\n+        for (int i = 1; i <= 10; i++) {\n+            list.insert(i);\n+        }\n+        assertTrue(list.search(1));\n+    }\n+\n+    @Test\n+    public void testSearchMultipleElementsListLastElement() {\n+        // Insert multiple elements and search for the last element\n+        for (int i = 1; i <= 10; i++) {\n+            list.insert(i);\n+        }\n+        assertTrue(list.search(10));\n+    }\n+\n+    @Test\n+    public void testSearchMultipleElementsListNotFound() {\n+        // Insert multiple elements and search for a non-existent element\n+        for (int i = 1; i <= 10; i++) {\n+            list.insert(i);\n+        }\n+        assertFalse(list.search(15));\n+    }\n+\n+    @Test\n+    public void testSearchNegativeValues() {\n+        // Insert positive and negative values and search for a negative value\n+        list.insert(-5);\n+        list.insert(-10);\n+        list.insert(5);\n+        assertTrue(list.search(-10));\n+        assertFalse(list.search(-3));\n+    }\n+\n+    @Test\n+    public void testSearchZeroValue() {\n+        list.insert(0);\n+        assertTrue(list.search(0));\n+    }\n+}",
    "output": {
      "why": "The changes introduce a new algorithm implementation (`SearchSinglyLinkedListRecursion`) and its corresponding test class, improving project functionality and coverage. The addition of links in `DIRECTORY.md` ensures proper documentation and discoverability of the newly added algorithm and tests.",
      "commit_message": "Add `SearchSinglyLinkedListRecursion` class and tests\n- Introduced the `SearchSinglyLinkedListRecursion` class that implements a recursive search method for singly linked lists, enhancing list search capabilities.\n- Added tests in `SearchSinglyLinkedListRecursionTest` to ensure functionality, including searches in empty and populated lists for various edge cases.\n- Updated `DIRECTORY.md` to include links to the newly added class and test files for easier navigation."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/others/MaximumSlidingWindow.java b/src/main/java/com/thealgorithms/others/MaximumSlidingWindow.java\nnew file mode 100644\nindex 000000000000..d0b2c2a0e56d\n--- /dev/null\n+++ b/src/main/java/com/thealgorithms/others/MaximumSlidingWindow.java\n@@ -0,0 +1,56 @@\n+package com.thealgorithms.others;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n+/**\n+ * Maximum Sliding Window Algorithm\n+ *\n+ * This algorithm finds the maximum element in each sliding window of size k\n+ * in a given array of integers. It uses a deque (double-ended queue) to\n+ * efficiently keep track of potential maximum values in the current window.\n+ *\n+ * Time Complexity: O(n), where n is the number of elements in the input array\n+ * Space Complexity: O(k), where k is the size of the sliding window\n+ */\n+\n+public class MaximumSlidingWindow {\n+\n+    /**\n+     * Finds the maximum values in each sliding window of size k.\n+     *\n+     * @param nums The input array of integers\n+     * @param windowSize The size of the sliding window\n+     * @return An array of integers representing the maximums in each window\n+     */\n+    public int[] maxSlidingWindow(int[] nums, int windowSize) {\n+        if (nums == null || nums.length == 0 || windowSize <= 0 || windowSize > nums.length) {\n+            return new int[0]; // Handle edge cases\n+        }\n+\n+        int[] result = new int[nums.length - windowSize + 1];\n+        Deque<Integer> deque = new ArrayDeque<>();\n+\n+        for (int currentIndex = 0; currentIndex < nums.length; currentIndex++) {\n+\n+            // Remove the first element if it's outside the current window\n+            if (!deque.isEmpty() && deque.peekFirst() == currentIndex - windowSize) {\n+                deque.pollFirst();\n+            }\n+\n+            // Remove all elements smaller than the current element from the end\n+            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[currentIndex]) {\n+                deque.pollLast();\n+            }\n+\n+            // Add the current element's index to the deque\n+            deque.offerLast(currentIndex);\n+\n+            // If we have processed at least k elements, add to result\n+            if (currentIndex >= windowSize - 1) {\n+                result[currentIndex - windowSize + 1] = nums[deque.peekFirst()];\n+            }\n+        }\n+        return result;\n+    }\n+}\ndiff --git a/src/test/java/com/thealgorithms/others/MaximumSlidingWindowTest.java b/src/test/java/com/thealgorithms/others/MaximumSlidingWindowTest.java\nnew file mode 100644\nindex 000000000000..9209136a5af3\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/others/MaximumSlidingWindowTest.java\n@@ -0,0 +1,63 @@\n+package com.thealgorithms.others;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+class MaximumSlidingWindowTest {\n+\n+    MaximumSlidingWindow msw;\n+    int[] nums;\n+    int k;\n+\n+    @BeforeEach\n+    void setUp() {\n+        msw = new MaximumSlidingWindow(); // Initialize the MaximumSlidingWindow object\n+    }\n+\n+    // Test for a simple sliding window case\n+    @Test\n+    void testMaxSlidingWindowSimpleCase() {\n+        nums = new int[] {1, 3, -1, -3, 5, 3, 6, 7};\n+        k = 3;\n+        int[] expected = {3, 3, 5, 5, 6, 7};\n+        assertArrayEquals(expected, msw.maxSlidingWindow(nums, k));\n+    }\n+\n+    // Test when window size is 1 (output should be the array itself)\n+    @Test\n+    void testMaxSlidingWindowWindowSizeOne() {\n+        nums = new int[] {4, 2, 12, 11, -5};\n+        k = 1;\n+        int[] expected = {4, 2, 12, 11, -5};\n+        assertArrayEquals(expected, msw.maxSlidingWindow(nums, k));\n+    }\n+\n+    // Test when the window size is equal to the array length (output should be a single max element)\n+    @Test\n+    void testMaxSlidingWindowWindowSizeEqualsArrayLength() {\n+        nums = new int[] {4, 2, 12, 11, -5};\n+        k = nums.length;\n+        int[] expected = {12}; // Maximum of the entire array\n+        assertArrayEquals(expected, msw.maxSlidingWindow(nums, k));\n+    }\n+\n+    // Test when the input array is empty\n+    @Test\n+    void testMaxSlidingWindowEmptyArray() {\n+        nums = new int[] {};\n+        k = 3;\n+        int[] expected = {};\n+        assertArrayEquals(expected, msw.maxSlidingWindow(nums, k));\n+    }\n+\n+    // Test when the window size is larger than the array (should return empty)\n+    @Test\n+    void testMaxSlidingWindowWindowSizeLargerThanArray() {\n+        nums = new int[] {1, 2, 3};\n+        k = 5;\n+        int[] expected = {}; // Window size is too large, so no result\n+        assertArrayEquals(expected, msw.maxSlidingWindow(nums, k));\n+    }\n+}",
    "output": {
      "why": "These changes introduce a new algorithm to efficiently find the maximum value in each sliding window of a given size. The implementation ensures performance optimization using a deque and includes extensive test cases to validate functionality under different scenarios.",
      "commit_message": "Add Maximum Sliding Window algorithm with test cases\n- Created `MaximumSlidingWindow` class to implement the algorithm for finding maximums in sliding windows of an array.\n- Introduced `maxSlidingWindow` method featuring edge case handling and optimized performance using a deque.\n- Added `MaximumSlidingWindowTest` class that includes multiple test cases for validating the functionality, covering scenarios with various window sizes and input conditions."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/others/FibbonaciSeries.java b/src/main/java/com/thealgorithms/others/FibbonaciSeries.java\ndeleted file mode 100644\nindex a4815296e547..000000000000\n--- a/src/main/java/com/thealgorithms/others/FibbonaciSeries.java\n+++ /dev/null\n@@ -1,37 +0,0 @@\n-package com.thealgorithms.others;\n-\n-import java.util.Scanner;\n-\n-/**\n- * Fibonacci sequence, and characterized by the fact that every number after the\n- * first two is the sum of the two preceding ones.\n- *\n- * <p>\n- * Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21,...\n- *\n- * <p>\n- * Source for the explanation: https://en.wikipedia.org/wiki/Fibonacci_number\n- *\n- * Problem Statement: print all Fibonacci numbers that are smaller than your\n- * given input N\n- */\n-public final class FibbonaciSeries {\n-    private FibbonaciSeries() {\n-    }\n-\n-    public static void main(String[] args) {\n-        // Get input from the user\n-        Scanner scan = new Scanner(System.in);\n-        int n = scan.nextInt();\n-        int first = 0;\n-        int second = 1;\n-        scan.close();\n-        while (first <= n) {\n-            // print first fibo 0 then add second fibo into it while updating second as well\n-            System.out.println(first);\n-            int next = first + second;\n-            first = second;\n-            second = next;\n-        }\n-    }\n-}\ndiff --git a/src/main/java/com/thealgorithms/Recursion/FibonacciSeries.java b/src/main/java/com/thealgorithms/recursion/FibonacciSeries.java\nsimilarity index 93%\nrename from src/main/java/com/thealgorithms/Recursion/FibonacciSeries.java\nrename to src/main/java/com/thealgorithms/recursion/FibonacciSeries.java\nindex a89d110b8da3..e5f474085367 100644\n--- a/src/main/java/com/thealgorithms/Recursion/FibonacciSeries.java\n+++ b/src/main/java/com/thealgorithms/recursion/FibonacciSeries.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.Recursion;\n+package com.thealgorithms.recursion;\n \n /*\n     The Fibonacci series is a sequence of numbers where each number is the sum of the two preceding ones,\ndiff --git a/src/main/java/com/thealgorithms/Recursion/GenerateSubsets.java b/src/main/java/com/thealgorithms/recursion/GenerateSubsets.java\nsimilarity index 96%\nrename from src/main/java/com/thealgorithms/Recursion/GenerateSubsets.java\nrename to src/main/java/com/thealgorithms/recursion/GenerateSubsets.java\nindex 417bf1307790..5a3ff2e88040 100644\n--- a/src/main/java/com/thealgorithms/Recursion/GenerateSubsets.java\n+++ b/src/main/java/com/thealgorithms/recursion/GenerateSubsets.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.Recursion;\n+package com.thealgorithms.recursion;\n \n // program to find power set of a string\n \ndiff --git a/src/test/java/com/thealgorithms/Recursion/FibonacciSeriesTest.java b/src/test/java/com/thealgorithms/recursion/FibonacciSeriesTest.java\nsimilarity index 96%\nrename from src/test/java/com/thealgorithms/Recursion/FibonacciSeriesTest.java\nrename to src/test/java/com/thealgorithms/recursion/FibonacciSeriesTest.java\nindex 4e4fc45809ba..f8b59f7e9ac6 100644\n--- a/src/test/java/com/thealgorithms/Recursion/FibonacciSeriesTest.java\n+++ b/src/test/java/com/thealgorithms/recursion/FibonacciSeriesTest.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.Recursion;\n+package com.thealgorithms.recursion;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \ndiff --git a/src/test/java/com/thealgorithms/Recursion/GenerateSubsetsTest.java b/src/test/java/com/thealgorithms/recursion/GenerateSubsetsTest.java\nsimilarity index 96%\nrename from src/test/java/com/thealgorithms/Recursion/GenerateSubsetsTest.java\nrename to src/test/java/com/thealgorithms/recursion/GenerateSubsetsTest.java\nindex d4bc7e488f80..b92d1406b0a7 100644\n--- a/src/test/java/com/thealgorithms/Recursion/GenerateSubsetsTest.java\n+++ b/src/test/java/com/thealgorithms/recursion/GenerateSubsetsTest.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.Recursion;\n+package com.thealgorithms.recursion;\n \n import static org.junit.jupiter.api.Assertions.assertArrayEquals;",
    "output": {
      "why": "The deletion of `FibbonaciSeries.java` indicates removal of an unneeded or duplicate implementation. The renaming of the classes and test files to lowercase promotes consistency across the codebase and follows Java naming conventions.",
      "commit_message": "Remove duplicate `FibbonaciSeries.java` and standardize naming\n- Deleted `FibbonaciSeries.java` as it was likely redundant.\n- Renamed packages and classes from `Recursion` to `recursion` to adhere to Java naming conventions and enhance consistency across the project.\n- Similar changes also made for `GenerateSubsets` files."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/misc/InverseOfMatrix.java b/src/main/java/com/thealgorithms/matrix/InverseOfMatrix.java\nsimilarity index 98%\nrename from src/main/java/com/thealgorithms/misc/InverseOfMatrix.java\nrename to src/main/java/com/thealgorithms/matrix/InverseOfMatrix.java\nindex 706feab0c69d..13e795a91297 100644\n--- a/src/main/java/com/thealgorithms/misc/InverseOfMatrix.java\n+++ b/src/main/java/com/thealgorithms/matrix/InverseOfMatrix.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.misc;\n+package com.thealgorithms.matrix;\n \n /**\n  * This class provides methods to compute the inverse of a square matrix\ndiff --git a/src/main/java/com/thealgorithms/misc/MatrixTranspose.java b/src/main/java/com/thealgorithms/matrix/MatrixTranspose.java\nsimilarity index 97%\nrename from src/main/java/com/thealgorithms/misc/MatrixTranspose.java\nrename to src/main/java/com/thealgorithms/matrix/MatrixTranspose.java\nindex 743682780b01..f91ebc10b8a9 100644\n--- a/src/main/java/com/thealgorithms/misc/MatrixTranspose.java\n+++ b/src/main/java/com/thealgorithms/matrix/MatrixTranspose.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.misc;\n+package com.thealgorithms.matrix;\n \n /**\n  *\ndiff --git a/src/main/java/com/thealgorithms/misc/MedianOfMatrix.java b/src/main/java/com/thealgorithms/matrix/MedianOfMatrix.java\nsimilarity index 95%\nrename from src/main/java/com/thealgorithms/misc/MedianOfMatrix.java\nrename to src/main/java/com/thealgorithms/matrix/MedianOfMatrix.java\nindex edeedbbee540..c710c60a2d2a 100644\n--- a/src/main/java/com/thealgorithms/misc/MedianOfMatrix.java\n+++ b/src/main/java/com/thealgorithms/matrix/MedianOfMatrix.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.misc;\n+package com.thealgorithms.matrix;\n \n import java.util.ArrayList;\n import java.util.Collections;\ndiff --git a/src/main/java/com/thealgorithms/misc/MirrorOfMatrix.java b/src/main/java/com/thealgorithms/matrix/MirrorOfMatrix.java\nsimilarity index 98%\nrename from src/main/java/com/thealgorithms/misc/MirrorOfMatrix.java\nrename to src/main/java/com/thealgorithms/matrix/MirrorOfMatrix.java\nindex 89dfce3fe049..b24fcba75619 100644\n--- a/src/main/java/com/thealgorithms/misc/MirrorOfMatrix.java\n+++ b/src/main/java/com/thealgorithms/matrix/MirrorOfMatrix.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.misc;\n+package com.thealgorithms.matrix;\n \n // Problem Statement\n /*\ndiff --git a/src/main/java/com/thealgorithms/others/PrintAMatrixInSpiralOrder.java b/src/main/java/com/thealgorithms/matrix/PrintAMatrixInSpiralOrder.java\nsimilarity index 94%\nrename from src/main/java/com/thealgorithms/others/PrintAMatrixInSpiralOrder.java\nrename to src/main/java/com/thealgorithms/matrix/PrintAMatrixInSpiralOrder.java\nindex ddc37a916cbf..2e735222b7a6 100644\n--- a/src/main/java/com/thealgorithms/others/PrintAMatrixInSpiralOrder.java\n+++ b/src/main/java/com/thealgorithms/matrix/PrintAMatrixInSpiralOrder.java\n@@ -1,62 +1,62 @@\n-package com.thealgorithms.others;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public class PrintAMatrixInSpiralOrder {\n-    /**\n-     * Search a key in row and column wise sorted matrix\n-     *\n-     * @param matrix matrix to be searched\n-     * @param row    number of rows matrix has\n-     * @param col    number of columns matrix has\n-     * @author Sadiul Hakim : https://github.com/sadiul-hakim\n-     */\n-\n-    public List<Integer> print(int[][] matrix, int row, int col) {\n-\n-        // r traverses matrix row wise from first\n-        int r = 0;\n-        // c traverses matrix column wise from first\n-        int c = 0;\n-        int i;\n-\n-        List<Integer> result = new ArrayList<>();\n-\n-        while (r < row && c < col) {\n-            // print first row of matrix\n-            for (i = c; i < col; i++) {\n-                result.add(matrix[r][i]);\n-            }\n-\n-            // increase r by one because first row printed\n-            r++;\n-\n-            // print last column\n-            for (i = r; i < row; i++) {\n-                result.add(matrix[i][col - 1]);\n-            }\n-\n-            // decrease col by one because last column has been printed\n-            col--;\n-\n-            // print rows from last except printed elements\n-            if (r < row) {\n-                for (i = col - 1; i >= c; i--) {\n-                    result.add(matrix[row - 1][i]);\n-                }\n-\n-                row--;\n-            }\n-\n-            // print columns from first except printed elements\n-            if (c < col) {\n-                for (i = row - 1; i >= r; i--) {\n-                    result.add(matrix[i][c]);\n-                }\n-                c++;\n-            }\n-        }\n-        return result;\n-    }\n-}\n+package com.thealgorithms.matrix;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class PrintAMatrixInSpiralOrder {\n+    /**\n+     * Search a key in row and column wise sorted matrix\n+     *\n+     * @param matrix matrix to be searched\n+     * @param row    number of rows matrix has\n+     * @param col    number of columns matrix has\n+     * @author Sadiul Hakim : https://github.com/sadiul-hakim\n+     */\n+\n+    public List<Integer> print(int[][] matrix, int row, int col) {\n+\n+        // r traverses matrix row wise from first\n+        int r = 0;\n+        // c traverses matrix column wise from first\n+        int c = 0;\n+        int i;\n+\n+        List<Integer> result = new ArrayList<>();\n+\n+        while (r < row && c < col) {\n+            // print first row of matrix\n+            for (i = c; i < col; i++) {\n+                result.add(matrix[r][i]);\n+            }\n+\n+            // increase r by one because first row printed\n+            r++;\n+\n+            // print last column\n+            for (i = r; i < row; i++) {\n+                result.add(matrix[i][col - 1]);\n+            }\n+\n+            // decrease col by one because last column has been printed\n+            col--;\n+\n+            // print rows from last except printed elements\n+            if (r < row) {\n+                for (i = col - 1; i >= c; i--) {\n+                    result.add(matrix[row - 1][i]);\n+                }\n+\n+                row--;\n+            }\n+\n+            // print columns from first except printed elements\n+            if (c < col) {\n+                for (i = row - 1; i >= r; i--) {\n+                    result.add(matrix[i][c]);\n+                }\n+                c++;\n+            }\n+        }\n+        return result;\n+    }\n+}\ndiff --git a/src/main/java/com/thealgorithms/others/RotateMatrixBy90Degrees.java b/src/main/java/com/thealgorithms/matrix/RotateMatrixBy90Degrees.java\nsimilarity index 98%\nrename from src/main/java/com/thealgorithms/others/RotateMatrixBy90Degrees.java\nrename to src/main/java/com/thealgorithms/matrix/RotateMatrixBy90Degrees.java\nindex 6ad0ef024342..9a7f255282ac 100644\n--- a/src/main/java/com/thealgorithms/others/RotateMatrixBy90Degrees.java\n+++ b/src/main/java/com/thealgorithms/matrix/RotateMatrixBy90Degrees.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.others;\n+package com.thealgorithms.matrix;\n \n import java.util.Scanner;\n /**\ndiff --git a/src/main/java/com/thealgorithms/matrixexponentiation/Fibonacci.java b/src/main/java/com/thealgorithms/matrix/matrixexponentiation/Fibonacci.java\nsimilarity index 93%\nrename from src/main/java/com/thealgorithms/matrixexponentiation/Fibonacci.java\nrename to src/main/java/com/thealgorithms/matrix/matrixexponentiation/Fibonacci.java\nindex afd34933047a..9c9f97b93ea4 100644\n--- a/src/main/java/com/thealgorithms/matrixexponentiation/Fibonacci.java\n+++ b/src/main/java/com/thealgorithms/matrix/matrixexponentiation/Fibonacci.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.matrixexponentiation;\n+package com.thealgorithms.matrix.matrixexponentiation;\n \n import java.util.Scanner;\n \n@@ -55,14 +55,14 @@ private static int[][] matrixMultiplication(int[][] matrix1, int[][] matrix2) {\n      */\n     public static int[][] fib(int n) {\n         if (n == 0) {\n-            return Fibonacci.IDENTITY_MATRIX;\n+            return IDENTITY_MATRIX;\n         } else {\n             int[][] cachedResult = fib(n / 2);\n             int[][] matrixExpResult = matrixMultiplication(cachedResult, cachedResult);\n             if (n % 2 == 0) {\n                 return matrixExpResult;\n             } else {\n-                return matrixMultiplication(Fibonacci.FIB_MATRIX, matrixExpResult);\n+                return matrixMultiplication(FIB_MATRIX, matrixExpResult);\n             }\n         }\n     }\ndiff --git a/src/test/java/com/thealgorithms/misc/InverseOfMatrixTest.java b/src/test/java/com/thealgorithms/matrix/InverseOfMatrixTest.java\nsimilarity index 96%\nrename from src/test/java/com/thealgorithms/misc/InverseOfMatrixTest.java\nrename to src/test/java/com/thealgorithms/matrix/InverseOfMatrixTest.java\nindex 2f20de444315..930fb377cd32 100644\n--- a/src/test/java/com/thealgorithms/misc/InverseOfMatrixTest.java\n+++ b/src/test/java/com/thealgorithms/matrix/InverseOfMatrixTest.java\n@@ -1,5 +1,4 @@\n-package com.thealgorithms.misc;\n-\n+package com.thealgorithms.matrix;\n import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n \n import java.util.stream.Stream;\ndiff --git a/src/test/java/com/thealgorithms/misc/MatrixTransposeTest.java b/src/test/java/com/thealgorithms/matrix/MatrixTransposeTest.java\nsimilarity index 98%\nrename from src/test/java/com/thealgorithms/misc/MatrixTransposeTest.java\nrename to src/test/java/com/thealgorithms/matrix/MatrixTransposeTest.java\nindex cf668807b819..0457f31418cf 100644\n--- a/src/test/java/com/thealgorithms/misc/MatrixTransposeTest.java\n+++ b/src/test/java/com/thealgorithms/matrix/MatrixTransposeTest.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.misc;\n+package com.thealgorithms.matrix;\n \n import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertThrows;\ndiff --git a/src/test/java/com/thealgorithms/misc/MedianOfMatrixTest.java b/src/test/java/com/thealgorithms/matrix/MedianOfMatrixTest.java\nsimilarity index 96%\nrename from src/test/java/com/thealgorithms/misc/MedianOfMatrixTest.java\nrename to src/test/java/com/thealgorithms/matrix/MedianOfMatrixTest.java\nindex 19bc66857ae6..db66bb2d187b 100644\n--- a/src/test/java/com/thealgorithms/misc/MedianOfMatrixTest.java\n+++ b/src/test/java/com/thealgorithms/matrix/MedianOfMatrixTest.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.misc;\n+package com.thealgorithms.matrix;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \ndiff --git a/src/test/java/com/thealgorithms/misc/MirrorOfMatrixTest.java b/src/test/java/com/thealgorithms/matrix/MirrorOfMatrixTest.java\nsimilarity index 98%\nrename from src/test/java/com/thealgorithms/misc/MirrorOfMatrixTest.java\nrename to src/test/java/com/thealgorithms/matrix/MirrorOfMatrixTest.java\nindex 0da0cf0f804a..2d68e1faaa17 100644\n--- a/src/test/java/com/thealgorithms/misc/MirrorOfMatrixTest.java\n+++ b/src/test/java/com/thealgorithms/matrix/MirrorOfMatrixTest.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.misc;\n+package com.thealgorithms.matrix;\n \n import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertNull;\ndiff --git a/src/test/java/com/thealgorithms/others/TestPrintMatrixInSpiralOrder.java b/src/test/java/com/thealgorithms/matrix/TestPrintMatrixInSpiralOrder.java\nsimilarity index 96%\nrename from src/test/java/com/thealgorithms/others/TestPrintMatrixInSpiralOrder.java\nrename to src/test/java/com/thealgorithms/matrix/TestPrintMatrixInSpiralOrder.java\nindex 986e72ea45b5..bb415a5861a8 100644\n--- a/src/test/java/com/thealgorithms/others/TestPrintMatrixInSpiralOrder.java\n+++ b/src/test/java/com/thealgorithms/matrix/TestPrintMatrixInSpiralOrder.java\n@@ -1,4 +1,4 @@\n-package com.thealgorithms.others;\n+package com.thealgorithms.matrix;\n \n import static org.junit.jupiter.api.Assertions.assertIterableEquals;",
    "output": {
      "why": "The changes likely reflect an organizational effort to centralize matrix-related classes and tests under a `matrix` package for better structure and maintainability. The exclusion from `pmd-exclude.properties` suggests that the excluded class was deemed necessary or that its issues should be addressed rather than ignored.",
      "commit_message": "Refactor package structure to centralize matrix-related classes\n- Renamed multiple Java files and updated their package declarations to `com.thealgorithms.matrix` to better organize matrix-related functionality.\n- Removed `UnnecessaryFullyQualifiedName` exclusion for `Fibonacci` in `pmd-exclude.properties` to ensure proper code quality checks."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/bitmanipulation/ReverseBits.java b/src/main/java/com/thealgorithms/bitmanipulation/ReverseBits.java\nindex e8f2930d3afe..12c269d9be48 100644\n--- a/src/main/java/com/thealgorithms/bitmanipulation/ReverseBits.java\n+++ b/src/main/java/com/thealgorithms/bitmanipulation/ReverseBits.java\n@@ -1,14 +1,33 @@\n package com.thealgorithms.bitmanipulation;\n \n /**\n- * Converts any Octal Number to a Binary Number\n+ * This class provides a method to reverse the bits of a 32-bit integer.\n+ * Reversing the bits means that the least significant bit (LSB) becomes\n+ * the most significant bit (MSB) and vice versa.\n+ *\n+ * Example:\n+ * Input (binary): 00000010100101000001111010011100 (43261596)\n+ * Output (binary): 00111001011110000010100101000000 (964176192)\n+ *\n+ * Time Complexity: O(32) - A fixed number of 32 iterations\n+ * Space Complexity: O(1) - No extra space used\n+ *\n+ * Note:\n+ * - If the input is negative, Java handles it using two’s complement representation.\n+ * - This function works on 32-bit integers by default.\n+ *\n  * @author Bama Charan Chhandogi\n  */\n-\n public final class ReverseBits {\n     private ReverseBits() {\n     }\n \n+    /**\n+     * Reverses the bits of a 32-bit integer.\n+     *\n+     * @param n the integer whose bits are to be reversed\n+     * @return the integer obtained by reversing the bits of the input\n+     */\n     public static int reverseBits(int n) {\n         int result = 0;\n         int bitCount = 32;\ndiff --git a/src/test/java/com/thealgorithms/bitmanipulation/ReverseBitsTest.java b/src/test/java/com/thealgorithms/bitmanipulation/ReverseBitsTest.java\nindex 967a89a1ee97..5cfa82355ce7 100644\n--- a/src/test/java/com/thealgorithms/bitmanipulation/ReverseBitsTest.java\n+++ b/src/test/java/com/thealgorithms/bitmanipulation/ReverseBitsTest.java\n@@ -2,14 +2,40 @@\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n-import org.junit.jupiter.api.Test;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n \n class ReverseBitsTest {\n \n-    @Test\n-    void testReverseBits() {\n-        assertEquals(0, ReverseBits.reverseBits(0));\n-        assertEquals(-1, ReverseBits.reverseBits(-1));\n-        assertEquals(964176192, ReverseBits.reverseBits(43261596));\n+    @ParameterizedTest\n+    @MethodSource(\"provideTestCases\")\n+    void testReverseBits(int input, int expected) {\n+        assertEquals(expected, ReverseBits.reverseBits(input));\n+    }\n+\n+    private static Stream<Arguments> provideTestCases() {\n+        return Stream.of(\n+            // Edge case: All bits are 0\n+            Arguments.of(0, 0),\n+\n+            // Edge case: All bits are 1 (Two’s complement representation of -1)\n+            Arguments.of(-1, -1),\n+\n+            // Case with random number 43261596\n+            Arguments.of(43261596, 964176192),\n+\n+            // Case with maximum positive value for 32-bit integer\n+            Arguments.of(Integer.MAX_VALUE, -2),\n+\n+            // Case with minimum value (all bits 1 except the sign bit)\n+            Arguments.of(Integer.MIN_VALUE, 1),\n+\n+            // Case with a single bit set (2^0 = 1)\n+            Arguments.of(1, Integer.MIN_VALUE),\n+\n+            // Case with alternating bits: 0b101010...10 (in binary)\n+            Arguments.of(0xAAAAAAAA, 0x55555555));\n     }\n }",
    "output": {
      "why": "The changes enhance the documentation of the `ReverseBits` class and improve the testing strategy by using parameterized tests. This makes the code easier to maintain and understand, ensuring comprehensive test coverage for various input scenarios.",
      "commit_message": "Enhance documentation and testing for `ReverseBits`\n- Updated the main class documentation to clarify the functionality of the `reverseBits` method, including time and space complexity.\n- Refactored the test class to use parameterized tests for more flexibility and coverage.\n- Added various test cases, including edge cases and typical scenarios, to ensure the robustness of the `reverseBits` function."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/graphs/TarjansAlgorithm.java b/src/main/java/com/thealgorithms/datastructures/graphs/TarjansAlgorithm.java\nindex de50044256c6..91974ba13319 100644\n--- a/src/main/java/com/thealgorithms/datastructures/graphs/TarjansAlgorithm.java\n+++ b/src/main/java/com/thealgorithms/datastructures/graphs/TarjansAlgorithm.java\n@@ -5,66 +5,73 @@\n import java.util.Stack;\n \n /**\n- * Java program that implements Tarjan's Algorithm.\n- * @author <a href=\"https://github.com/shivu2002a\">Shivanagouda S A</a>\n+ * Java program that implements Tarjan's Algorithm to find Strongly Connected Components (SCCs) in a directed graph.\n+ *\n  * <p>\n- * Tarjan's algorithm is a linear time algorithm to find the strongly connected components of a\n-directed graph, which, from here onwards will be referred as SCC.\n-\n- * A graph is said to be strongly connected if every vertex is reachable from every other vertex.\n-The SCCs of a directed graph form a partition into subgraphs that are themselves strongly\n-connected. Single node is always a SCC.\n-\n- * Example:\n-0 --------> 1 -------> 3 --------> 4\n-^          /\n-|         /\n-|        /\n-|       /\n-|      /\n-|     /\n-|    /\n-|   /\n-|  /\n-| /\n-|V\n-2\n-\n-For the above graph, the SCC list goes as follows:\n-1, 2, 0\n-3\n-4\n-\n-We can also see that order of the nodes in an SCC doesn't matter since they are in cycle.\n-\n-{@summary}\n-Tarjan's Algorithm:\n- * DFS search produces a DFS tree\n- * Strongly Connected Components form subtrees of the DFS tree.\n- * If we can find the head of these subtrees, we can get all the nodes in that subtree (including\n-the head) and that will be one SCC.\n- * There is no back edge from one SCC to another (here can be cross edges, but they will not be\n-used).\n-\n- * Kosaraju Algorithm aims at doing the same but uses two DFS traversalse whereas Tarjan’s\n-algorithm does the same in a single DFS, which leads to much lower constant factors in the latter.\n-\n+ * Tarjan's algorithm is a linear time algorithm (O(V + E)) that identifies the SCCs of a directed graph.\n+ * An SCC is a maximal subgraph where every vertex is reachable from every other vertex within the subgraph.\n+ *\n+ * <h3>Algorithm Overview:</h3>\n+ * <ul>\n+ * <li>DFS Search: A depth-first search (DFS) is performed on the graph to generate a DFS tree.</li>\n+ * <li>Identification of SCCs: SCCs correspond to subtrees within this DFS tree.</li>\n+ * <li>Low-Link Values: For each node, a low-link value is maintained, which indicates the earliest visited\n+ * vertex (the one with the minimum insertion time) that can be reached from that subtree.</li>\n+ * <li>Stack Usage: Nodes are stored in a stack during DFS. When an SCC is identified, nodes are popped from\n+ * the stack until the head of the SCC is reached.</li>\n+ * </ul>\n+ *\n+ * <p>\n+ * Example of a directed graph:\n+ * <pre>\n+ *  0 --------> 1 -------> 3 --------> 4\n+ *  ^          /\n+ *  |         /\n+ *  |        /\n+ *  |       /\n+ *  |      /\n+ *  |     /\n+ *  |    /\n+ *  |   /\n+ *  |  /\n+ *  | /\n+ *  V\n+ *  2\n+ * </pre>\n+ *\n+ * <p>\n+ * For the above graph, the SCC list is as follows:\n+ * <ul>\n+ * <li>1, 2, 0</li>\n+ * <li>3</li>\n+ * <li>4</li>\n+ * </ul>\n+ * The order of nodes in an SCC does not matter as they form cycles.\n+ *\n+ * <h3>Comparison with Kosaraju's Algorithm:</h3>\n+ * <p>\n+ * Kosaraju's algorithm also identifies SCCs but does so using two DFS traversals.\n+ * In contrast, Tarjan's algorithm achieves this in a single DFS traversal, leading to improved performance\n+ * in terms of constant factors.\n+ * </p>\n  */\n public class TarjansAlgorithm {\n \n-    // Timer for tracking lowtime and insertion time\n+    // Timer for tracking low time and insertion time\n     private int time;\n \n-    private final List<List<Integer>> sccList = new ArrayList<List<Integer>>();\n+    // List to store all strongly connected components\n+    private final List<List<Integer>> sccList = new ArrayList<>();\n \n+    /**\n+     * Finds and returns the strongly connected components (SCCs) of the directed graph.\n+     *\n+     * @param v the number of vertices in the graph\n+     * @param graph the adjacency list representation of the graph\n+     * @return a list of lists, where each inner list represents a strongly connected component\n+     */\n     public List<List<Integer>> stronglyConnectedComponents(int v, List<List<Integer>> graph) {\n-\n-        // Initially all vertices as unvisited, insertion and low time are undefined\n-\n-        // insertionTime:Time when a node is visited 1st time while DFS traversal\n-\n-        // lowTime: indicates the earliest visited vertex (the vertex with minimum insertion time)\n-        // that can be reached from a subtree rooted with a particular node.\n+        // Initialize arrays for insertion time and low-link values\n         int[] lowTime = new int[v];\n         int[] insertionTime = new int[v];\n         for (int i = 0; i < v; i++) {\n@@ -72,11 +79,11 @@ public List<List<Integer>> stronglyConnectedComponents(int v, List<List<Integer>\n             lowTime[i] = -1;\n         }\n \n-        // To check if element is present in stack\n+        // Track if vertices are in the stack\n         boolean[] isInStack = new boolean[v];\n \n-        // Store nodes during DFS\n-        Stack<Integer> st = new Stack<Integer>();\n+        // Stack to hold nodes during DFS\n+        Stack<Integer> st = new Stack<>();\n \n         for (int i = 0; i < v; i++) {\n             if (insertionTime[i] == -1) {\n@@ -87,36 +94,44 @@ public List<List<Integer>> stronglyConnectedComponents(int v, List<List<Integer>\n         return sccList;\n     }\n \n+    /**\n+     * A utility function to perform DFS and find SCCs.\n+     *\n+     * @param u the current vertex being visited\n+     * @param lowTime array to keep track of the low-link values\n+     * @param insertionTime array to keep track of the insertion times\n+     * @param isInStack boolean array indicating if a vertex is in the stack\n+     * @param st the stack used for DFS\n+     * @param graph the adjacency list representation of the graph\n+     */\n     private void stronglyConnCompsUtil(int u, int[] lowTime, int[] insertionTime, boolean[] isInStack, Stack<Integer> st, List<List<Integer>> graph) {\n-\n-        // Initialize insertion time and lowTime value of current node\n+        // Set insertion time and low-link value\n         insertionTime[u] = time;\n         lowTime[u] = time;\n-        time += 1;\n+        time++;\n \n-        // Push current node into stack\n+        // Push current node onto the stack\n         isInStack[u] = true;\n         st.push(u);\n \n-        // Go through all vertices adjacent to this\n+        // Explore adjacent vertices\n         for (Integer vertex : graph.get(u)) {\n-            // If the adjacent node is unvisited, do DFS\n             if (insertionTime[vertex] == -1) {\n                 stronglyConnCompsUtil(vertex, lowTime, insertionTime, isInStack, st, graph);\n-                // update lowTime for the current node comparing lowtime of adj node\n+                // Update low-link value\n                 lowTime[u] = Math.min(lowTime[u], lowTime[vertex]);\n             } else if (isInStack[vertex]) {\n-                // If adj node is in stack, update low\n+                // Vertex is in the stack; update low-link value\n                 lowTime[u] = Math.min(lowTime[u], insertionTime[vertex]);\n             }\n         }\n-        // If lowtime and insertion time are same, current node is the head of an SCC\n-        //  head node found, get all the nodes in this SCC\n+\n+        // Check if the current vertex is the root of an SCC\n         if (lowTime[u] == insertionTime[u]) {\n             int w = -1;\n-            var scc = new ArrayList<Integer>();\n+            List<Integer> scc = new ArrayList<>();\n \n-            // Stack has all the nodes of the current SCC\n+            // Pop vertices from the stack until the root is found\n             while (w != u) {\n                 w = st.pop();\n                 scc.add(w);\ndiff --git a/src/test/java/com/thealgorithms/datastructures/graphs/TarjansAlgorithmTest.java b/src/test/java/com/thealgorithms/datastructures/graphs/TarjansAlgorithmTest.java\nindex dc81d99dd0bf..314cc415815d 100644\n--- a/src/test/java/com/thealgorithms/datastructures/graphs/TarjansAlgorithmTest.java\n+++ b/src/test/java/com/thealgorithms/datastructures/graphs/TarjansAlgorithmTest.java\n@@ -1,6 +1,6 @@\n package com.thealgorithms.datastructures.graphs;\n \n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n \n import java.util.ArrayList;\n import java.util.Arrays;\n@@ -9,11 +9,11 @@\n \n public class TarjansAlgorithmTest {\n \n-    TarjansAlgorithm tarjansAlgo = new TarjansAlgorithm();\n+    private final TarjansAlgorithm tarjansAlgo = new TarjansAlgorithm();\n \n     @Test\n-    public void findStronglyConnectedComps() {\n-        var v = 5;\n+    public void testFindStronglyConnectedComponents() {\n+        int v = 5;\n         var graph = new ArrayList<List<Integer>>();\n         for (int i = 0; i < v; i++) {\n             graph.add(new ArrayList<>());\n@@ -32,23 +32,20 @@ public void findStronglyConnectedComps() {\n             4\n         */\n         List<List<Integer>> expectedResult = new ArrayList<>();\n-\n-        expectedResult.add(Arrays.asList(4));\n-        expectedResult.add(Arrays.asList(3));\n+        expectedResult.add(List.of(4));\n+        expectedResult.add(List.of(3));\n         expectedResult.add(Arrays.asList(2, 1, 0));\n-        assertTrue(expectedResult.equals(actualResult));\n+        assertEquals(expectedResult, actualResult);\n     }\n \n     @Test\n-    public void findStronglyConnectedCompsShouldGetSingleNodes() {\n-        // Create a adjacency list of graph\n-        var n = 8;\n+    public void testFindStronglyConnectedComponentsWithSingleNodes() {\n+        // Create a graph where each node is its own SCC\n+        int n = 8;\n         var adjList = new ArrayList<List<Integer>>(n);\n-\n         for (int i = 0; i < n; i++) {\n             adjList.add(new ArrayList<>());\n         }\n-\n         adjList.get(0).add(1);\n         adjList.get(1).add(2);\n         adjList.get(2).add(3);\n@@ -65,6 +62,71 @@ public void findStronglyConnectedCompsShouldGetSingleNodes() {\n             7, 6, 5, 4, 3, 2, 1, 0\n         */\n         expectedResult.add(Arrays.asList(7, 6, 5, 4, 3, 2, 1, 0));\n-        assertTrue(expectedResult.equals(actualResult));\n+        assertEquals(expectedResult, actualResult);\n+    }\n+\n+    @Test\n+    public void testGraphWithMultipleSCCs() {\n+        int v = 6;\n+        var graph = new ArrayList<List<Integer>>();\n+        for (int i = 0; i < v; i++) {\n+            graph.add(new ArrayList<>());\n+        }\n+        graph.get(0).add(1);\n+        graph.get(1).add(2);\n+        graph.get(2).add(0);\n+        graph.get(3).add(4);\n+        graph.get(4).add(5);\n+        graph.get(5).add(3);\n+\n+        var actualResult = tarjansAlgo.stronglyConnectedComponents(v, graph);\n+        List<List<Integer>> expectedResult = new ArrayList<>();\n+        expectedResult.add(Arrays.asList(2, 1, 0)); // SCC containing 0, 1, 2\n+        expectedResult.add(Arrays.asList(5, 4, 3)); // SCC containing 3, 4, 5\n+        assertEquals(expectedResult, actualResult);\n+    }\n+\n+    @Test\n+    public void testDisconnectedGraph() {\n+        int v = 7;\n+        var graph = new ArrayList<List<Integer>>();\n+        for (int i = 0; i < v; i++) {\n+            graph.add(new ArrayList<>());\n+        }\n+        graph.get(0).add(1);\n+        graph.get(1).add(0);\n+        graph.get(2).add(3);\n+        graph.get(3).add(4);\n+        graph.get(4).add(2);\n+\n+        var actualResult = tarjansAlgo.stronglyConnectedComponents(v, graph);\n+        List<List<Integer>> expectedResult = new ArrayList<>();\n+        expectedResult.add(Arrays.asList(1, 0)); // SCC containing 0, 1\n+        expectedResult.add(Arrays.asList(4, 3, 2)); // SCC containing 2, 3, 4\n+        expectedResult.add(List.of(5)); // SCC containing 5\n+        expectedResult.add(List.of(6)); // SCC containing 6\n+        assertEquals(expectedResult, actualResult);\n+    }\n+\n+    @Test\n+    public void testSingleNodeGraph() {\n+        int v = 1;\n+        var graph = new ArrayList<List<Integer>>();\n+        graph.add(new ArrayList<>());\n+\n+        var actualResult = tarjansAlgo.stronglyConnectedComponents(v, graph);\n+        List<List<Integer>> expectedResult = new ArrayList<>();\n+        expectedResult.add(List.of(0)); // SCC with a single node\n+        assertEquals(expectedResult, actualResult);\n+    }\n+\n+    @Test\n+    public void testEmptyGraph() {\n+        int v = 0;\n+        var graph = new ArrayList<List<Integer>>();\n+\n+        var actualResult = tarjansAlgo.stronglyConnectedComponents(v, graph);\n+        List<List<Integer>> expectedResult = new ArrayList<>(); // No SCCs in an empty graph\n+        assertEquals(expectedResult, actualResult);\n     }\n }",
    "output": {
      "why": "The changes provide clearer and more detailed documentation for Tarjan's Algorithm, which enhances understanding for future developers. Improvements in naming conventions and comments contribute to better maintainability of the code. Additional test cases ensure robustness in finding strongly connected components (SCCs), covering various graph scenarios.",
      "commit_message": "Enhance documentation and tests for Tarjan's Algorithm\n- Updated JavaDoc comments to provide clearer explanations and examples of Tarjan's Algorithm and its implementation details.\n- Improved variable and method names for better readability and understanding (`insertion time` and `low time`).\n- Added new test cases covering multiple SCCs, disconnected graphs, single-node graphs, and empty graphs.\n- Streamlined comments throughout the code for clarity and consistency."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/conversions/EndianConverter.java b/src/main/java/com/thealgorithms/conversions/EndianConverter.java\nindex d20d9d6d63b5..0d69098e8255 100644\n--- a/src/main/java/com/thealgorithms/conversions/EndianConverter.java\n+++ b/src/main/java/com/thealgorithms/conversions/EndianConverter.java\n@@ -1,11 +1,23 @@\n package com.thealgorithms.conversions;\n \n /**\n- * Converts between big-endian and little-endian formats.\n- * Big-endian is the most significant byte first, while little-endian is the least significant byte first.\n- * Big-endian to little-endian: 0x12345678 -> 0x78563412\n+ * Utility class for converting integers between big-endian and little-endian formats.\n+ * <p>\n+ * Endianness defines how byte sequences represent multi-byte data types:\n+ * <ul>\n+ *   <li><b>Big-endian</b>: The most significant byte (MSB) comes first.</li>\n+ *   <li><b>Little-endian</b>: The least significant byte (LSB) comes first.</li>\n+ * </ul>\n+ * <p>\n+ * Example conversion:\n+ * <ul>\n+ *   <li>Big-endian to little-endian: {@code 0x12345678} → {@code 0x78563412}</li>\n+ *   <li>Little-endian to big-endian: {@code 0x78563412} → {@code 0x12345678}</li>\n+ * </ul>\n  *\n- * Little-endian to big-endian: 0x12345678 -> 0x78563412\n+ * <p>Note: Both conversions in this utility are equivalent since reversing the bytes is symmetric.</p>\n+ *\n+ * <p>This class only supports 32-bit integers.</p>\n  *\n  * @author Hardvan\n  */\n@@ -13,10 +25,22 @@ public final class EndianConverter {\n     private EndianConverter() {\n     }\n \n+    /**\n+     * Converts a 32-bit integer from big-endian to little-endian.\n+     *\n+     * @param value the integer in big-endian format\n+     * @return the integer in little-endian format\n+     */\n     public static int bigToLittleEndian(int value) {\n         return Integer.reverseBytes(value);\n     }\n \n+    /**\n+     * Converts a 32-bit integer from little-endian to big-endian.\n+     *\n+     * @param value the integer in little-endian format\n+     * @return the integer in big-endian format\n+     */\n     public static int littleToBigEndian(int value) {\n         return Integer.reverseBytes(value);\n     }\ndiff --git a/src/test/java/com/thealgorithms/conversions/EndianConverterTest.java b/src/test/java/com/thealgorithms/conversions/EndianConverterTest.java\nindex 9598dd163146..85ffa2190962 100644\n--- a/src/test/java/com/thealgorithms/conversions/EndianConverterTest.java\n+++ b/src/test/java/com/thealgorithms/conversions/EndianConverterTest.java\n@@ -2,21 +2,34 @@\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n \n public class EndianConverterTest {\n \n-    @Test\n-    public void testBigToLittleEndian() {\n-        assertEquals(0x78563412, EndianConverter.bigToLittleEndian(0x12345678));\n-        assertEquals(0x00000000, EndianConverter.bigToLittleEndian(0x00000000));\n-        assertEquals(0x00000001, EndianConverter.bigToLittleEndian(0x01000000));\n+    @ParameterizedTest\n+    @CsvSource({\n+        \"0x78563412, 0x12345678\", \"0x00000000, 0x00000000\", \"0x00000001, 0x01000000\",\n+        \"0xFFFFFFFF, 0xFFFFFFFF\", // -1 in two's complement\n+        \"0x0000007F, 0x7F000000\" // Positive boundary case\n+    })\n+    public void\n+    testLittleToBigEndian(String inputHex, String expectedHex) {\n+        int input = (int) Long.parseLong(inputHex.substring(2), 16); // Convert hex string to int\n+        int expected = (int) Long.parseLong(expectedHex.substring(2), 16); // Convert hex string to int\n+        assertEquals(expected, EndianConverter.littleToBigEndian(input));\n     }\n \n-    @Test\n-    public void testLittleToBigEndian() {\n-        assertEquals(0x12345678, EndianConverter.littleToBigEndian(0x78563412));\n-        assertEquals(0x00000000, EndianConverter.littleToBigEndian(0x00000000));\n-        assertEquals(0x01000000, EndianConverter.littleToBigEndian(0x00000001));\n+    @ParameterizedTest\n+    @CsvSource({\n+        \"0x12345678, 0x78563412\", \"0x00000000, 0x00000000\", \"0x01000000, 0x00000001\",\n+        \"0xFFFFFFFF, 0xFFFFFFFF\", // -1 in two's complement\n+        \"0x7F000000, 0x0000007F\" // Positive boundary case\n+    })\n+    public void\n+    testBigToLittleEndian(String inputHex, String expectedHex) {\n+        int input = (int) Long.parseLong(inputHex.substring(2), 16); // Convert hex string to int\n+        int expected = (int) Long.parseLong(expectedHex.substring(2), 16); // Convert hex string to int\n+        assertEquals(expected, EndianConverter.bigToLittleEndian(input));\n     }\n }",
    "output": {
      "why": "The documentation was enhanced to define endianness more clearly and provide examples of conversions. Parameterized tests were introduced for better coverage and validation of the integer conversion methods.",
      "commit_message": "Enhance documentation and tests in `EndianConverter`\n- Improved the JavaDoc documentation for the `EndianConverter` class to clarify endianness concepts with examples.\n- Added parameterized tests for both `bigToLittleEndian` and `littleToBigEndian` methods to ensure robustness of conversion logic with a variety of test cases."
    }
  },
  {
    "input": "diff --git a/src/main/java/com/thealgorithms/datastructures/heaps/HeapElement.java b/src/main/java/com/thealgorithms/datastructures/heaps/HeapElement.java\nindex 7c457a340645..20f33bd2d146 100644\n--- a/src/main/java/com/thealgorithms/datastructures/heaps/HeapElement.java\n+++ b/src/main/java/com/thealgorithms/datastructures/heaps/HeapElement.java\n@@ -1,14 +1,24 @@\n package com.thealgorithms.datastructures.heaps;\n \n /**\n- * Class for heap elements.<br>\n+ * Class representing an element in a heap.\n  *\n  * <p>\n- * A heap element contains two attributes: a key which will be used to build the\n- * tree (int or double, either primitive type or object) and any kind of\n- * IMMUTABLE object the user sees fit to carry any information he/she likes. Be\n- * aware that the use of a mutable object might jeopardize the integrity of this\n- * information.\n+ * A heap element contains two attributes: a key used for ordering in the heap\n+ * (which can be of type int or double, either as primitive types or as wrapper objects)\n+ * and an additional immutable object that can store any supplementary information the user desires.\n+ * Note that using mutable objects may compromise the integrity of this information.\n+ * </p>\n+ *\n+ * <p>\n+ * The key attribute is used to determine the order of elements in the heap,\n+ * while the additionalInfo attribute can carry user-defined data associated with the key.\n+ * </p>\n+ *\n+ * <p>\n+ * This class provides multiple constructors to accommodate various key types and includes\n+ * methods to retrieve the key and additional information.\n+ * </p>\n  *\n  * @author Nicolas Renard\n  */\n@@ -19,9 +29,10 @@ public class HeapElement {\n \n     // Constructors\n     /**\n-     * @param key : a number of primitive type 'double'\n-     * @param info : any kind of IMMUTABLE object. May be null, since the\n-     * purpose is only to carry additional information of use for the user\n+     * Creates a HeapElement with the specified key and additional information.\n+     *\n+     * @param key  the key of the element (primitive type double)\n+     * @param info any immutable object containing additional information, may be null\n      */\n     public HeapElement(double key, Object info) {\n         this.key = key;\n@@ -29,9 +40,10 @@ public HeapElement(double key, Object info) {\n     }\n \n     /**\n-     * @param key : a number of primitive type 'int'\n-     * @param info : any kind of IMMUTABLE object. May be null, since the\n-     * purpose is only to carry additional information of use for the user\n+     * Creates a HeapElement with the specified key and additional information.\n+     *\n+     * @param key  the key of the element (primitive type int)\n+     * @param info any immutable object containing additional information, may be null\n      */\n     public HeapElement(int key, Object info) {\n         this.key = key;\n@@ -39,9 +51,10 @@ public HeapElement(int key, Object info) {\n     }\n \n     /**\n-     * @param key : a number of object type 'Integer'\n-     * @param info : any kind of IMMUTABLE object. May be null, since the\n-     * purpose is only to carry additional information of use for the user\n+     * Creates a HeapElement with the specified key and additional information.\n+     *\n+     * @param key  the key of the element (object type Integer)\n+     * @param info any immutable object containing additional information, may be null\n      */\n     public HeapElement(Integer key, Object info) {\n         this.key = key;\n@@ -49,9 +62,10 @@ public HeapElement(Integer key, Object info) {\n     }\n \n     /**\n-     * @param key : a number of object type 'Double'\n-     * @param info : any kind of IMMUTABLE object. May be null, since the\n-     * purpose is only to carry additional information of use for the user\n+     * Creates a HeapElement with the specified key and additional information.\n+     *\n+     * @param key  the key of the element (object type Double)\n+     * @param info any immutable object containing additional information, may be null\n      */\n     public HeapElement(Double key, Object info) {\n         this.key = key;\n@@ -59,7 +73,9 @@ public HeapElement(Double key, Object info) {\n     }\n \n     /**\n-     * @param key : a number of primitive type 'double'\n+     * Creates a HeapElement with the specified key.\n+     *\n+     * @param key the key of the element (primitive type double)\n      */\n     public HeapElement(double key) {\n         this.key = key;\n@@ -67,7 +83,9 @@ public HeapElement(double key) {\n     }\n \n     /**\n-     * @param key : a number of primitive type 'int'\n+     * Creates a HeapElement with the specified key.\n+     *\n+     * @param key the key of the element (primitive type int)\n      */\n     public HeapElement(int key) {\n         this.key = key;\n@@ -75,7 +93,9 @@ public HeapElement(int key) {\n     }\n \n     /**\n-     * @param key : a number of object type 'Integer'\n+     * Creates a HeapElement with the specified key.\n+     *\n+     * @param key the key of the element (object type Integer)\n      */\n     public HeapElement(Integer key) {\n         this.key = key;\n@@ -83,7 +103,9 @@ public HeapElement(Integer key) {\n     }\n \n     /**\n-     * @param key : a number of object type 'Double'\n+     * Creates a HeapElement with the specified key.\n+     *\n+     * @param key the key of the element (object type Double)\n      */\n     public HeapElement(Double key) {\n         this.key = key;\n@@ -92,46 +114,57 @@ public HeapElement(Double key) {\n \n     // Getters\n     /**\n-     * @return the object containing the additional info provided by the user.\n+     * Returns the object containing the additional information provided by the user.\n+     *\n+     * @return the additional information\n      */\n     public Object getInfo() {\n         return additionalInfo;\n     }\n \n     /**\n-     * @return the key value of the element\n+     * Returns the key value of the element.\n+     *\n+     * @return the key of the element\n      */\n     public double getKey() {\n         return key;\n     }\n \n     // Overridden object methods\n+    /**\n+     * Returns a string representation of the heap element.\n+     *\n+     * @return a string describing the key and additional information\n+     */\n+    @Override\n     public String toString() {\n-        return \"Key: \" + key + \" - \" + additionalInfo.toString();\n+        return \"Key: \" + key + \" - \" + (additionalInfo != null ? additionalInfo.toString() : \"No additional info\");\n     }\n \n     /**\n-     * @param otherHeapElement\n-     * @return true if the keys on both elements are identical and the\n-     * additional info objects are identical.\n+     * Compares this heap element to another object for equality.\n+     *\n+     * @param o the object to compare with\n+     * @return true if the keys and additional information are identical, false otherwise\n      */\n     @Override\n     public boolean equals(Object o) {\n-        if (o != null) {\n-            if (!(o instanceof HeapElement)) {\n-                return false;\n-            }\n-            HeapElement otherHeapElement = (HeapElement) o;\n-            return ((this.key == otherHeapElement.key) && (this.additionalInfo.equals(otherHeapElement.additionalInfo)));\n+        if (o instanceof HeapElement otherHeapElement) {\n+            return this.key == otherHeapElement.key && (this.additionalInfo != null ? this.additionalInfo.equals(otherHeapElement.additionalInfo) : otherHeapElement.additionalInfo == null);\n         }\n         return false;\n     }\n \n+    /**\n+     * Returns a hash code value for the heap element.\n+     *\n+     * @return a hash code value for this heap element\n+     */\n     @Override\n     public int hashCode() {\n-        int result = 0;\n-        result = 31 * result + (int) key;\n-        result = 31 * result + (additionalInfo != null ? additionalInfo.hashCode() : 0);\n+        int result = 31 * (int) key;\n+        result += (additionalInfo != null) ? additionalInfo.hashCode() : 0;\n         return result;\n     }\n }\ndiff --git a/src/test/java/com/thealgorithms/datastructures/heaps/HeapElementTest.java b/src/test/java/com/thealgorithms/datastructures/heaps/HeapElementTest.java\nnew file mode 100644\nindex 000000000000..d04a9de8a94b\n--- /dev/null\n+++ b/src/test/java/com/thealgorithms/datastructures/heaps/HeapElementTest.java\n@@ -0,0 +1,55 @@\n+package com.thealgorithms.datastructures.heaps;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+import org.junit.jupiter.api.Test;\n+\n+class HeapElementTest {\n+\n+    @Test\n+    void testConstructorAndGetters() {\n+        HeapElement element = new HeapElement(5.0, \"Info\");\n+        assertEquals(5.0, element.getKey());\n+        assertEquals(\"Info\", element.getInfo());\n+    }\n+\n+    @Test\n+    void testConstructorWithNullInfo() {\n+        HeapElement element = new HeapElement(10);\n+        assertEquals(10, element.getKey());\n+        assertNull(element.getInfo());\n+    }\n+\n+    @Test\n+    void testToString() {\n+        HeapElement element = new HeapElement(7.5, \"TestInfo\");\n+        assertEquals(\"Key: 7.5 - TestInfo\", element.toString());\n+\n+        HeapElement elementWithoutInfo = new HeapElement(3);\n+        assertEquals(\"Key: 3.0 - No additional info\", elementWithoutInfo.toString());\n+    }\n+\n+    @Test\n+    void testEquals() {\n+        HeapElement element1 = new HeapElement(2.5, \"Data\");\n+        HeapElement element2 = new HeapElement(2.5, \"Data\");\n+        HeapElement element3 = new HeapElement(3.0, \"DifferentData\");\n+\n+        assertEquals(element1, element2); // Same key and info\n+        assertNotEquals(element1, element3); // Different key\n+        assertNotEquals(null, element1); // Check for null\n+        assertNotEquals(\"String\", element1); // Check for different type\n+    }\n+\n+    @Test\n+    void testHashCode() {\n+        HeapElement element1 = new HeapElement(4, \"HashMe\");\n+        HeapElement element2 = new HeapElement(4, \"HashMe\");\n+        HeapElement element3 = new HeapElement(4, \"DifferentHash\");\n+\n+        assertEquals(element1.hashCode(), element2.hashCode()); // Same key and info\n+        assertNotEquals(element1.hashCode(), element3.hashCode()); // Different info\n+    }\n+}",
    "output": {
      "why": "The changes improve code documentation and add unit tests for HeapElement. This enhances maintainability and ensures that core functionalities are validated through testing.",
      "commit_message": "Add unit tests for `HeapElement` and improve documentation\n- Created `HeapElementTest` to validate constructors, getters, `toString()`, `equals()`, and `hashCode()` methods.\n- Enhanced Javadoc comments in `HeapElement` class for clarity on attributes and methods.\n- Ensured proper handling of null values and provided meaningful output in `toString()`."
    }
  }
]
